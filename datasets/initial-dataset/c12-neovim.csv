user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10541,305290661,2019-07-19T10:07:56Z,src/nvim/option_defs.h,"@@ -366,6 +366,7 @@ static char *(p_cb_values[]) = {""unnamed"", ""unnamedplus"", NULL}; # define CB_UNNAMEDMASK         (CB_UNNAMED | CB_UNNAMEDPLUS) EXTERN long p_cwh;              // 'cmdwinheight' EXTERN long p_ch;               // 'cmdheight'+EXTERN long p_columns;          // 'p_columns'",```suggestionEXTERN long p_columns;          // 'columns'```,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10541,305304650,2019-07-19T10:49:06Z,src/nvim/option_defs.h,"@@ -476,6 +477,7 @@ EXTERN char_u   *p_langmap;     // 'langmap' EXTERN int p_lnr;               // 'langnoremap' EXTERN int p_lrm;               // 'langremap' EXTERN char_u   *p_lm;          // 'langmenu'+EXTERN long     p_lines;        // 'lines' EXTERN long     *p_linespace;   // 'linespace'","It works because `long *` has the same size as `long`, and the value is never accessed directly, so it is extremely unlikely the compiler will exploit the UB. Also test coverage on little-endian systems (all our CI, as far as I know) will not cover issues only apparent on big-endian systems (such as the `bool *` vs `int *` punning we used to have).",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10543,305402365,2019-07-19T15:12:49Z,src/nvim/screen.c,"@@ -4033,7 +4031,7 @@ win_line (         && filler_todo <= 0         && (wp->w_p_rl ? col == 0 : col == grid->Columns - 1)         && (*ptr != NUL-            || (wp->w_p_list && lcs_eol_one > 0)",`wp->w_p_list` is already checked on line 4031,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/10521,305530514,2019-07-19T21:29:36Z,src/nvim/profile.c,"@@ -176,22 +169,31 @@ bool profile_equal(proftime_T tm1, proftime_T tm2) FUNC_ATTR_CONST   return tm1 == tm2; } -/// Calculates the sign of a 64-bit integer.+/// Converts a proftime_T value `tm` to a signed integer. ///-/// @return -1, 0, or +1-static inline int sgn64(int64_t x) FUNC_ATTR_CONST+/// @return signed representation of the given time value","Sorry for the extremely delayed review. I think the CL is good, but I had one more thought.Being exposed to Go a lot made me think that I would solve it with two distinct types:  - A type for points in time (proftime_T).  - A type for the subtraction of two points in time (duration_T or something else). This could be unsigned for negative durations. `profile_sub` would take two `proftime_T`'s and return a `duration_T`.(It's been a while, but I think C's automatic type conversion might make accidentally assigning one to the other far too easy, and it's not worth defining two types.)At first sight, they're semantically quite different. One is an absolute point in time (though we don't know the starting point), and the other is a duration.On second look, there's also something to be said for keeping them as the same type. Essentially, proftime_T (as defined above) is the duration since the processor was started. When subtracting two proftime_T's, it's just rebasing the starting point to the second operand.I guess what I'm trying to say is: the way it is right now is IMHO a decent tradeoff, as C won't provide too much protection either way (Go would complain if one doesn't cast, even for the same underlying type). The only thing I'd change is to document that `profile_signed` is meant to be used `proftime_T`s that are (perhaps indirectly) the result of `profile_sub` calls.The comment itself is not that important, maybe if you ever pass over the code again.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10550,305577836,2019-07-20T12:10:33Z,test/functional/ui/screen.lua,"@@ -1246,6 +1260,26 @@ function Screen:print_snapshot(attrs, ignore)     end   end +  -- Build keyword-args for screen:expect().+  local kwargs = {}+  if attr_state.modified then+    kwargs['attr_ids'] = {}+    for i, a in pairs(attr_state.ids) do+      kwargs['attr_ids'][i] = a","Not sure, will check later. Some of the differences between hlstate and standard linegrid are just technical debt, I should clean it up.. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10565,305881852,2019-07-22T14:41:46Z,src/nvim/os/input.c,"@@ -159,15 +159,26 @@ bool os_char_avail(void) // Check for CTRL-C typed by reading all available characters. void os_breakcheck(void) {-  int save_us = updating_screen;+  static bool recursive = false;+  const int save_updating_screen = updating_screen;++  // We could be called recursively if stderr is redirected, calling+  // fill_input_buf() calls settmode() when stdin isn't a tty.  settmode()+  // calls vgetorpeek() which calls os_breakcheck() again.","Recursive `os_breakcheck` is essentially a special case of recursive `loop_poll_events` in nvim, which we have decided to forbid by `abort()`. The code we allow to run inside `breakcheck` / `loop_poll_events` is very limited (in what editor state it is allowed to touch). It would be better to unconditionally abort, if this code is accidentally allowed to do something wrong, rather than either `abort()` or either ignore it, depending how the ""outer"" loop was invoked. (i e: not apply this patch to nvim).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10580,305948852,2019-07-22T17:40:54Z,test/functional/core/job_spec.lua,"@@ -759,7 +753,7 @@ describe('jobs', function()   it('cannot have both rpc and pty options', function()     command(""let g:job_opts.pty = v:true"")     command(""let g:job_opts.rpc = v:true"")-    local _, err = pcall(command, ""let j = jobstart(has('win32') ? ['find', '/v', ''] : ['cat', '-'], g:job_opts)"")+    local _, err = pcall(command, ""let j = jobstart(['cat', '-'], g:job_opts)"")",At long as the command doesn't exit quickly. That's why `cat -` is used: to make the process long-lived.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10573,306036452,2019-07-22T21:15:45Z,src/nvim/os/process.c,"@@ -71,24 +72,30 @@ static bool os_proc_tree_kill_rec(HANDLE process, int sig)   return (bool)TerminateProcess(process, (unsigned int)sig); } /// Kills process `pid` and its descendants recursively.-bool os_proc_tree_kill(int pid, int sig)+bool os_proc_tree_kill(Process *proc, int sig) {   assert(sig >= 0);   assert(sig == SIGTERM || sig == SIGKILL);   if (pid > 0) {     ILOG(""terminating process tree: %d"", pid);     HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, false, (DWORD)pid);-    return os_proc_tree_kill_rec(h, sig);+    bool rv = os_proc_tree_kill_rec(h, sig);+    if (rv) {+      // uv_process_kill sets this manually (for Windows), but is not used by+      // use (and on Unix uv_kill is used directly).+      proc->exit_signal = sig;+    }",Would rather change the return type that require Process parameter.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10573,306059730,2019-07-22T22:28:43Z,src/nvim/os/process.c,"@@ -71,24 +72,30 @@ static bool os_proc_tree_kill_rec(HANDLE process, int sig)   return (bool)TerminateProcess(process, (unsigned int)sig); } /// Kills process `pid` and its descendants recursively.-bool os_proc_tree_kill(int pid, int sig)+bool os_proc_tree_kill(Process *proc, int sig) {   assert(sig >= 0);   assert(sig == SIGTERM || sig == SIGKILL);   if (pid > 0) {     ILOG(""terminating process tree: %d"", pid);     HANDLE h = OpenProcess(PROCESS_ALL_ACCESS, false, (DWORD)pid);-    return os_proc_tree_kill_rec(h, sig);+    bool rv = os_proc_tree_kill_rec(h, sig);+    if (rv) {+      // uv_process_kill sets this manually (for Windows), but is not used by+      // use (and on Unix uv_kill is used directly).+      proc->exit_signal = sig;+    }","? os_proc is the prefix for this module.  Not every function here needs a Process parameter, and an extra function isn't needed.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10558,306234979,2019-07-23T10:04:03Z,src/nvim/os/env.c,"@@ -105,6 +105,10 @@ bool os_env_exists(const char *name)   return (r == 0 || r == UV_ENOBUFS); } +/// Sets an environment variable.+///+/// @warning Existing pointers to the result of os_getenv(""foo"") are+///          INVALID after os_setenv(""foo"", ���). int os_setenv(const char *name, const char *value, int overwrite)","Future improvement: instead of returning `int`, we could return a pointer to the new `os_getenv()` result. So the caller pattern could be like:    term = os_setenv(""TERM"", term, ...)However, after inspecting of all existing calls to `os_setenv` and `vim_setenv`, it looks like `tui.c` was the only case where a `os_getenv` result was passed to `os_setenv`.",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10582,306296190,2019-07-23T12:43:52Z,src/nvim/screen.c,"@@ -1615,8 +1615,8 @@ static void win_draw_end(win_T *wp, int c1, int c2, bool draw_margin, int row,     }   } -  int attr = hl_combine_attr(wp->w_hl_attr_normal,-                             hl ? win_hl_attr(wp, hl) : 0);+  int hl_prim_attr =  hl != HLF_8 ? win_hl_attr(wp, hl) : 0;+  int attr = hl_combine_attr(wp->w_hl_attr_normal, hl_prim_attr);","@bfredl @justinmk I am struggling to understand the semantic value of `hl != -1`. The enum starts at `0`, so this condition will always be true and we will get another PVS warning. Same for `HLF_COUNT` - condition will always be true.Can we simply do like this?:```cint attr = hl_combine_attr(wp->w_hl_attr_normal, win_hl_attr(wp, hl))?```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10430,307061256,2019-07-24T23:26:47Z,src/nvim/eval.c,"@@ -21686,6 +21788,71 @@ static inline bool eval_fname_sid(const char *const name)   return *name == 's' || TOUPPER_ASC(name[2]) == 'I'; } +/// Return the declaration body of the function.+///+/// @param[in]  fp       Function pointer.+/// @param[in]  replace  Add '!' to function head (i.e.: ""function!"").+///+/// @return allocated function declaration body string.+char *get_func_body(ufunc_T *fp, bool replace)","`:verbose func Foo` shows the body of a function. Impl is `ex_function` https://github.com/neovim/neovim/blob/b8fcf62da9261e47821c5e3d369dc4fd58d2b721/src/nvim/eval.c#L20997-L20999I guess you already looked at it, because `get_func_body` seems to have several special-cases covered. I'm a little uncomfortable about the code duplication because it is quite a lot of details that will need similar test coverage, if the goal is to faithfully transport function definitions...I wonder if `:verbose func` could actually be used for this purpose. E.g. in VimL (or Lua) we can simply use:    :let a=execute('func Foo')Then `a` contains the body of Foo() (with line numbers, but that could be trimmed or we could add a mode to `ex_function`).",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10430,307070858,2019-07-25T00:14:01Z,src/nvim/shada.c,"@@ -4117,3 +4053,225 @@ static bool shada_removable(const char *name)   xfree(new_name);   return retval; }++/// Initialize ShaDa jumplist entries.+///+/// @param[in,out]  jumps           Array of ShaDa entries to set.+/// @param[in]      removable_bufs  Cache of buffers ignored due to their+///                                 location.+///+/// @return number of jumplist entries+static inline size_t shada_init_jumps(+    PossiblyFreedShadaEntry *jumps, khash_t(bufset) *const removable_bufs)","Why is `remove_bufs`  needed everywhere? If we can avoid it, then we can also:- avoid lifting `khash_t(bufset)`  out of the shada module.- keep `shada_removable` private (static)`remove_bufs` is documented as ""Cache of buffers ignored"". Why is it so important to cache it? Just make the shada module figure it out internally. It's ok if `FOR_ALL_BUFFERS` needs to happen multiple times, that's not really a bottleneck and not worth the burden of passing around this awkward data structure. Not to mention, cache management itself is risky and should be avoided unless absolutely necessary.Creating a `Context` is inherently an _expensive_ operation. Of course, we shouldn't be sloppy, but saving 1% here and there is almost never worth a more complicated interface.",x
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/10430,307783106,2019-07-26T15:01:31Z,src/nvim/eval.c,"@@ -21686,6 +21788,71 @@ static inline bool eval_fname_sid(const char *const name)   return *name == 's' || TOUPPER_ASC(name[2]) == 'I'; } +/// Return the declaration body of the function.+///+/// @param[in]  fp       Function pointer.+/// @param[in]  replace  Add '!' to function head (i.e.: ""function!"").+///+/// @return allocated function declaration body string.+char *get_func_body(ufunc_T *fp, bool replace)","Yeah, I've copied a considerable amount from `list_func_head`. I'm thinking of refactoring it out of `list_func_head` into, say, `get_func_head`, and using it in both `list_func_head` and the context stuff. As for the body, I'm also thinking of keeping `get_func_body` limited to that and adding some flags to it (whether to include line numbers, indent lines, etc...) and then using it in both `ex_function` and the context stuff.",x
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/10430,307785156,2019-07-26T15:06:01Z,src/nvim/eval.c,"@@ -21686,6 +21788,71 @@ static inline bool eval_fname_sid(const char *const name)   return *name == 's' || TOUPPER_ASC(name[2]) == 'I'; } +/// Return the declaration body of the function.+///+/// @param[in]  fp       Function pointer.+/// @param[in]  replace  Add '!' to function head (i.e.: ""function!"").+///+/// @return allocated function declaration body string.+char *get_func_body(ufunc_T *fp, bool replace)","Or maybe I should just capture the output of `:func {name}`, is it fine to use API handlers (e.g.: `nvim_command_output`) internally? I see it very rarely done (for example, [here](https://github.com/neovim/neovim/blob/master/src/nvim/eval.c#L8834-L8835))",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10430,307791956,2019-07-26T15:21:47Z,src/nvim/eval.c,"@@ -21686,6 +21788,71 @@ static inline bool eval_fname_sid(const char *const name)   return *name == 's' || TOUPPER_ASC(name[2]) == 'I'; } +/// Return the declaration body of the function.+///+/// @param[in]  fp       Function pointer.+/// @param[in]  replace  Add '!' to function head (i.e.: ""function!"").+///+/// @return allocated function declaration body string.+char *get_func_body(ufunc_T *fp, bool replace)","> Or maybe I should just capture the output of `:func {name}`, is it fine to use API handlers (e.g.: `nvim_command_output`) internally? I see it very rarely done (for example, [here](https://github.com/neovim/neovim/blob/master/src/nvim/eval.c#L8834-L8835))Yes, totally fine. It's not common because it's not very ""ergonomic"", currently.Do you want to attempt that in this PR? Else I think we can merge this.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10606,307940765,2019-07-26T23:46:54Z,src/nvim/testdir/test_arglist.vim,"@@ -74,7 +74,6 @@ func Test_argadd()   call assert_equal(1, len(argv()))   call assert_equal('some file', get(argv(), 0, '')) -  call delete('Xargadd')",In Vim this is with `Test_argadd_empty_curbuf`.Not sure what the question really is here though.The only diff in `test_arglist.vim` is `Test_argadd_empty_curbuf` now - which will be added with v8.1.0341.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10584,307959708,2019-07-27T09:34:02Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);","This ""close stdin"" step was from aa9cb48bf08af14068178619, before we fixed/reworked the SIGTERM timing logic. So it's probably outdated / no longer needed, as you guessed in 7933eb46b4c5b14bad7fd1bb735713fb13988d13 ; but the commit message should explain this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10617,307963120,2019-07-27T11:55:05Z,src/nvim/pos.h,"@@ -1,6 +1,9 @@ #ifndef NVIM_POS_H #define NVIM_POS_H +// for INT_MAX, LONG_MAX et al.+#include <limits.h>","unless this is required for things directly in pos.h, in general we don't want to have ""mega-headers"" that bring in other headers (`os.h` is an exception).",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/10617,307966302,2019-07-27T14:09:09Z,src/nvim/pos.h,"@@ -11,9 +14,9 @@ typedef int colnr_T; #define PRIdCOLNR ""d""  /// Maximal (invalid) line number-enum { MAXLNUM = 0x7fffffff };+#define MAXLNUM LONG_MAX",This breaks buffer updates.Tried changing this line to `const long MAXLNUM = LONG_MAX;` but it fails the static assertions where `SIZE_MAX >= MAXLNUM`.Can buffer updates be done in chunks of `SIZE_MAX`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10430,307968267,2019-07-27T15:17:20Z,src/nvim/eval.c,"@@ -20966,6 +21068,8 @@ void ex_function(exarg_T *eap)    /*    * "":function func"" with only function name: list function.+   * If bang is given, include bang in function head and exclude line numbers+   * from function body.","should have an explicit test for this (`:func` vs `:func!`). and mention in docs (will do in  https://github.com/neovim/neovim/pull/10619 ).Also, it's a bit weird that `:func!` always appends a bang to the listed function, regardless of how the function was defined. ",
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/10430,307968522,2019-07-27T15:26:53Z,src/nvim/context.c,"@@ -0,0 +1,383 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++// Context: snapshot of the entire editor state as one big object/map++#include ""nvim/context.h""+#include ""nvim/eval/encode.h""+#include ""nvim/ex_docmd.h""+#include ""nvim/option.h""+#include ""nvim/shada.h""+#include ""nvim/api/vim.h""+#include ""nvim/api/private/helpers.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""context.c.generated.h""+#endif++int kCtxAll = (kCtxRegs | kCtxJumps | kCtxBuflist | kCtxGVars | kCtxSFuncs+               | kCtxFuncs);++static ContextVec ctx_stack = KV_INITIAL_VALUE;++/// Clears and frees the context stack+void free_ctx_stack(void)+{+  for (size_t i = 0; i < kv_size(ctx_stack); i++) {+    ctx_free(&kv_A(ctx_stack, i));+  }+  kv_destroy(ctx_stack);+}++/// Returns the size of the context stack.+size_t ctx_size(void)+{+  return kv_size(ctx_stack);+}++/// Returns pointer to Context object with given zero-based index from the top+/// of context stack or NULL if index is out of bounds.+Context *ctx_get(size_t index)+{+  if (index < kv_size(ctx_stack)) {+    return &kv_Z(ctx_stack, index);+  }+  return NULL;+}++/// Free resources used by Context object.+///+/// param[in]  ctx  pointer to Context object to free.+void ctx_free(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  if (ctx->regs.data) {+    msgpack_sbuffer_destroy(&ctx->regs);+  }+  if (ctx->jumps.data) {+    msgpack_sbuffer_destroy(&ctx->jumps);+  }+  if (ctx->buflist.data) {+    msgpack_sbuffer_destroy(&ctx->buflist);+  }+  if (ctx->gvars.data) {+    msgpack_sbuffer_destroy(&ctx->gvars);+  }+  if (ctx->funcs.items) {+    api_free_array(ctx->funcs);+  }+}++/// Saves the editor state to a context.+///+/// If ""context"" is NULL, pushes context on context stack.+/// Use ""flags"" to select particular types of context.+///+/// @param  ctx    Save to this context, or push on context stack if NULL.+/// @param  flags  Flags, see ContextTypeFlags enum.+void ctx_save(Context *ctx, const int flags)+{+  if (ctx == NULL) {+    kv_push(ctx_stack, CONTEXT_INIT);+    ctx = &kv_last(ctx_stack);+  }++  if (flags & kCtxRegs) {+    ctx_save_regs(ctx);+  }++  if (flags & kCtxJumps) {+    ctx_save_jumps(ctx);+  }++  if (flags & kCtxBuflist) {+    ctx_save_buflist(ctx);+  }++  if (flags & kCtxGVars) {+    ctx_save_gvars(ctx);+  }++  if (flags & kCtxFuncs) {+    ctx_save_funcs(ctx, false);+  } else if (flags & kCtxSFuncs) {+    ctx_save_funcs(ctx, true);+  }+}++/// Restores the editor state from a context.+///+/// If ""context"" is NULL, pops context from context stack.+/// Use ""flags"" to select particular types of context.+///+/// @param  ctx    Restore from this context. Pop from context stack if NULL.+/// @param  flags  Flags, see ContextTypeFlags enum.+///+/// @return true on success, false otherwise (i.e.: empty context stack).+bool ctx_restore(Context *ctx, const int flags)+{+  bool free_ctx = false;+  if (ctx == NULL) {+    if (ctx_stack.size == 0) {+      return false;+    }+    ctx = &kv_pop(ctx_stack);+    free_ctx = true;+  }++  char_u *op_shada;+  get_option_value((char_u *)""shada"", NULL, &op_shada, OPT_GLOBAL);+  set_option_value(""shada"", 0L, ""!,'100,%"", OPT_GLOBAL);++  if (flags & kCtxRegs) {+    ctx_restore_regs(ctx);+  }++  if (flags & kCtxJumps) {+    ctx_restore_jumps(ctx);+  }++  if (flags & kCtxBuflist) {+    ctx_restore_buflist(ctx);+  }++  if (flags & kCtxGVars) {+    ctx_restore_gvars(ctx);+  }++  if (flags & kCtxFuncs) {+    ctx_restore_funcs(ctx);+  }++  if (free_ctx) {+    ctx_free(ctx);+  }++  set_option_value(""shada"", 0L, (char *)op_shada, OPT_GLOBAL);+  xfree(op_shada);++  return true;+}++/// Saves the global registers to a context.+///+/// @param  ctx    Save to this context.+static inline void ctx_save_regs(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->regs);+  shada_encode_regs(&ctx->regs);+}++/// Restores the global registers from a context.+///+/// @param  ctx   Restore from this context.+static inline void ctx_restore_regs(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->regs, kShaDaWantInfo | kShaDaForceit);+}++/// Saves the jumplist to a context.+///+/// @param  ctx  Save to this context.+static inline void ctx_save_jumps(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->jumps);+  shada_encode_jumps(&ctx->jumps);+}++/// Restores the jumplist from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_jumps(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->jumps, kShaDaWantInfo | kShaDaForceit);+}++/// Saves the buffer list to a context.+///+/// @param  ctx  Save to this context.+static inline void ctx_save_buflist(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->buflist);+  shada_encode_buflist(&ctx->buflist);+}++/// Restores the buffer list from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_buflist(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->buflist, kShaDaWantInfo | kShaDaForceit);+}++/// Saves global variables to a context.+///+/// @param  ctx  Save to this context.+static inline void ctx_save_gvars(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->gvars);+  shada_encode_gvars(&ctx->gvars);+}++/// Restores global variables from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_gvars(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->gvars, kShaDaWantInfo | kShaDaForceit);+}++/// Saves functions to a context.+///+/// @param  ctx         Save to this context.+/// @param  scriptonly  Save script functions only.+static inline void ctx_save_funcs(Context *ctx, bool scriptonly)+  FUNC_ATTR_NONNULL_ALL+{+  ctx->funcs = (Array)ARRAY_DICT_INIT;+  Error err = ERROR_INIT;++  HASHTAB_ITER(&func_hashtab, hi, {+    const char_u *const name = hi->hi_key;+    bool islambda = (STRNCMP(name, ""<lambda>"", 8) == 0);+    bool isscript = (name[0] == K_SPECIAL);++    if (!islambda && (!scriptonly || isscript)) {+      size_t cmd_len = sizeof(""func! "") + STRLEN(name);+      char *cmd = xmalloc(cmd_len);+      snprintf(cmd, cmd_len, ""func! %s"", name);+      String func_body = nvim_command_output(cstr_as_string(cmd), &err);+      xfree(cmd);+      if (!ERROR_SET(&err)) {+        ADD(ctx->funcs, STRING_OBJ(func_body));+      }+      api_clear_error(&err);+    }+  });+}++/// Restores functions from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_funcs(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  for (size_t i = 0; i < ctx->funcs.size; i++) {+    do_cmdline_cmd(ctx->funcs.items[i].data.string.data);+  }+}++/// Convert msgpack_sbuffer to readfile()-style array.+///+/// @param[in]  sbuf  msgpack_sbuffer to convert.+///+/// @return readfile()-style array representation of ""sbuf"".+static inline Array sbuf_to_array(msgpack_sbuffer sbuf)+{+  list_T *const list = tv_list_alloc(kListLenMayKnow);+  tv_list_append_string(list, """", 0);+  if (sbuf.size > 0) {+    encode_list_write(list, sbuf.data, sbuf.size);+  }++  typval_T list_tv = (typval_T) {+    .v_lock = VAR_UNLOCKED,+    .v_type = VAR_LIST,+    .vval.v_list = list+  };++  Array array = vim_to_object(&list_tv).data.array;+  tv_clear(&list_tv);+  return array;+}++/// Convert readfile()-style array to msgpack_sbuffer.+///+/// @param[in]  array  readfile()-style array to convert.+///+/// @return msgpack_sbuffer with conversion result.+static inline msgpack_sbuffer array_to_sbuf(Array array)+{+  msgpack_sbuffer sbuf;+  msgpack_sbuffer_init(&sbuf);++  typval_T list_tv;+  Error err = ERROR_INIT;+  object_to_vim(ARRAY_OBJ(array), &list_tv, &err);++  if (!encode_vim_list_to_buf(list_tv.vval.v_list, &sbuf.size, &sbuf.data)) {+    EMSG(_(""E474: Failed to convert list to msgpack string buffer""));+  }+  sbuf.alloc = sbuf.size;++  tv_clear(&list_tv);+  api_clear_error(&err);+  return sbuf;+}++/// Converts Context to Dictionary representation.+///+/// @param[in]  ctx  Context to convert.+///+/// @return Dictionary representing ""ctx"".+Dictionary ctx_to_dict(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  assert(ctx != NULL);++  Dictionary rv = ARRAY_DICT_INIT;++  PUT(rv, ""regs"", ARRAY_OBJ(sbuf_to_array(ctx->regs)));+  PUT(rv, ""jumps"", ARRAY_OBJ(sbuf_to_array(ctx->jumps)));+  PUT(rv, ""buflist"", ARRAY_OBJ(sbuf_to_array(ctx->buflist)));+  PUT(rv, ""gvars"", ARRAY_OBJ(sbuf_to_array(ctx->gvars)));+  PUT(rv, ""funcs"", ARRAY_OBJ(copy_array(ctx->funcs)));++  return rv;+}++/// Converts Dictionary representation of Context back to Context object.+///+/// @param[in]   dict  Context Dictionary representation.+/// @param[out]  ctx   Context object to store conversion result into.+///+/// @return types of included context items.+int ctx_from_dict(Dictionary dict, Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  assert(ctx != NULL);++  int types = 0;+  for (size_t i = 0; i < dict.size; i++) {+    KeyValuePair item = dict.items[i];+    if (item.value.type != kObjectTypeArray) {+      continue;+    }+    if (strequal(item.key.data, ""regs"")) {+      types |= kCtxRegs;+      ctx->regs = array_to_sbuf(item.value.data.array);+    } else if (strequal(item.key.data, ""jumps"")) {+      types |= kCtxJumps;+      ctx->jumps = array_to_sbuf(item.value.data.array);+    } else if (strequal(item.key.data, ""buflist"")) {+      types |= kCtxBuflist;+      ctx->buflist = array_to_sbuf(item.value.data.array);+    } else if (strequal(item.key.data, ""gvars"")) {+      types |= kCtxGVars;+      ctx->gvars = array_to_sbuf(item.value.data.array);+    } else if (strequal(item.key.data, ""funcs"")) {+      types |= kCtxFuncs;+      ctx->funcs = copy_object(item.value).data.array;+    }+  }++  return types;","Yeah...no need for returning anything actually, I originally did it coz I planned to return a list of the loaded types from `nvim_load_context` and the likes, but forgot to remove it.",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10621,307970116,2019-07-27T16:24:09Z,src/nvim/fileio.c,"@@ -4248,15 +4248,13 @@ void shorten_buf_fname(buf_T *buf, char_u *dirname, int force)       buf->b_sfname = vim_strsave(p);       buf->b_fname = buf->b_sfname;     }-    if (p == NULL || buf->b_fname == NULL) {",inverse condition on line: 4239,
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10621,307970134,2019-07-27T16:24:59Z,src/nvim/eval.c,"@@ -15073,15 +15073,15 @@ static void set_buffer_lines(buf_T *buf, linenr_T lnum, typval_T *lines,     }      rettv->vval.v_number = 1;  // FAIL-    if (line == NULL || lnum < 1 || lnum > curbuf->b_ml.ml_line_count + 1) {","function exits on same condition, line 15034",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10621,307970194,2019-07-27T16:27:21Z,src/nvim/getchar.c,"@@ -4104,30 +4114,35 @@ makemap (                 return FAIL;             }           }-          if (c1 && putc(c1, fd) < 0)-            return FAIL;-          if (mp->m_noremap != REMAP_YES && fprintf(fd, ""nore"") < 0)+          if (c1 && putc(c1, fd) < 0) {             return FAIL;-          if (fputs(cmd, fd) < 0)+          }+          if (mp->m_noremap != REMAP_YES && fprintf(fd, ""nore"") < 0) {             return FAIL;-          if (buf != NULL && fputs("" <buffer>"", fd) < 0)+          }+          if (fputs(cmd, fd) < 0) {             return FAIL;-          if (mp->m_nowait && fputs("" <nowait>"", fd) < 0)+          }+          if (buf != NULL && fputs("" <buffer>"", fd) < 0) {             return FAIL;-          if (mp->m_silent && fputs("" <silent>"", fd) < 0)+          }+          if (mp->m_nowait && fputs("" <nowait>"", fd) < 0) {             return FAIL;-          if (mp->m_noremap == REMAP_SCRIPT","same condition used to skip look cycle, line 3992",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10624,307973084,2019-07-27T18:09:41Z,src/nvim/regexp.c,"@@ -4829,33 +4860,35 @@ static int regmatch(         break;        case RS_BRCPLX_MORE:-        /* Pop the state.  Restore pointers when there is no match. */+        // Pop the state.  Restore pointers when there is no match.         if (status == RA_NOMATCH) {           reg_restore(&rp->rs_un.regsave, &backpos);-          --brace_count[rp->rs_no];             /* decrement match count */+          brace_count[rp->rs_no]--;             // decrement match count",increment changed here. not sure if semantics are preserved,
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10624,307973091,2019-07-27T18:10:07Z,src/nvim/regexp.c,"@@ -4829,33 +4860,35 @@ static int regmatch(         break;        case RS_BRCPLX_MORE:-        /* Pop the state.  Restore pointers when there is no match. */+        // Pop the state.  Restore pointers when there is no match.         if (status == RA_NOMATCH) {           reg_restore(&rp->rs_un.regsave, &backpos);-          --brace_count[rp->rs_no];             /* decrement match count */+          brace_count[rp->rs_no]--;             // decrement match count         }         regstack_pop(&scan);         break;        case RS_BRCPLX_LONG:-        /* Pop the state.  Restore pointers when there is no match. */+        // Pop the state.  Restore pointers when there is no match.         if (status == RA_NOMATCH) {-          /* There was no match, but we did find enough matches. */+          // There was no match, but we did find enough matches.           reg_restore(&rp->rs_un.regsave, &backpos);-          --brace_count[rp->rs_no];-          /* continue with the items after ""\{}"" */+          brace_count[rp->rs_no]--;",increment changed here. not sure if semantics are preserved,
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10624,307973097,2019-07-27T18:10:26Z,src/nvim/regexp.c,"@@ -4941,16 +4974,16 @@ static int regmatch(                      < behind_pos.rs_u.pos.lnum                      ? (colnr_T)STRLEN(regline)                      : behind_pos.rs_u.pos.col)-                    - rp->rs_un.regsave.rs_u.pos.col >= limit))+                    - rp->rs_un.regsave.rs_u.pos.col >= limit)) {               no = FAIL;-            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {+            } else if (rp->rs_un.regsave.rs_u.pos.col == 0) {               if (rp->rs_un.regsave.rs_u.pos.lnum                   < behind_pos.rs_u.pos.lnum                   || reg_getline(-                      --rp->rs_un.regsave.rs_u.pos.lnum)-                  == NULL)+                      (rp--)->rs_un.regsave.rs_u.pos.lnum)",increment changed here. not sure if semantics are preserved,
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10623,307973336,2019-07-27T18:18:57Z,src/nvim/quickfix.c,"@@ -1326,7 +1326,7 @@ static int qf_parse_multiline_pfx(qf_info_T *qi, int qf_idx, int idx,     if (qfprev == NULL) {       return QF_FAIL;     }-    if (*fields->errmsg && !qfl->qf_multiignore) {","same condition on outer if branch, line: 1323",X
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10623,307973365,2019-07-27T18:19:44Z,src/nvim/quickfix.c,"@@ -2229,8 +2228,7 @@ static int qf_jump_edit_buffer(qf_info_T *qi, qfline_T *qf_ptr, int forceit,         EMSG(_(e_loc_list_changed));         *abort = true;       }-    } else if (old_qf_curlist != qi->qf_curlist",line 2215: `old_qf_curlist = qi->qf_curlist;` comparing to itself,
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10623,307973387,2019-07-27T18:20:29Z,src/nvim/quickfix.c,"@@ -2212,7 +2212,6 @@ static int qf_jump_edit_buffer(qf_info_T *qi, qfline_T *qf_ptr, int forceit,                        oldwin == curwin ? curwin : NULL);     }   } else {-    int old_qf_curlist = qi->qf_curlist;",`old_qf_curlist` is not used anywhere (after fixing condition below),X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10624,307973999,2019-07-27T18:42:14Z,src/nvim/regexp.c,"@@ -4829,33 +4860,35 @@ static int regmatch(         break;        case RS_BRCPLX_MORE:-        /* Pop the state.  Restore pointers when there is no match. */+        // Pop the state.  Restore pointers when there is no match.         if (status == RA_NOMATCH) {           reg_restore(&rp->rs_un.regsave, &backpos);-          --brace_count[rp->rs_no];             /* decrement match count */+          brace_count[rp->rs_no]--;             // decrement match count         }         regstack_pop(&scan);         break;        case RS_BRCPLX_LONG:-        /* Pop the state.  Restore pointers when there is no match. */+        // Pop the state.  Restore pointers when there is no match.         if (status == RA_NOMATCH) {-          /* There was no match, but we did find enough matches. */+          // There was no match, but we did find enough matches.           reg_restore(&rp->rs_un.regsave, &backpos);-          --brace_count[rp->rs_no];-          /* continue with the items after ""\{}"" */+          brace_count[rp->rs_no]--;","they are. But this file is listed in [frozen modules](https://github.com/neovim/neovim/wiki/Refactoring) because we don't plan to change it significantly. Thus we don't want to spend time on it. In particular, linting it is a low priority.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10624,307974037,2019-07-27T18:43:28Z,src/nvim/regexp.c,"@@ -4941,16 +4974,16 @@ static int regmatch(                      < behind_pos.rs_u.pos.lnum                      ? (colnr_T)STRLEN(regline)                      : behind_pos.rs_u.pos.col)-                    - rp->rs_un.regsave.rs_u.pos.col >= limit))+                    - rp->rs_un.regsave.rs_u.pos.col >= limit)) {               no = FAIL;-            else if (rp->rs_un.regsave.rs_u.pos.col == 0) {+            } else if (rp->rs_un.regsave.rs_u.pos.col == 0) {               if (rp->rs_un.regsave.rs_u.pos.lnum                   < behind_pos.rs_u.pos.lnum                   || reg_getline(-                      --rp->rs_un.regsave.rs_u.pos.lnum)-                  == NULL)+                      (rp--)->rs_un.regsave.rs_u.pos.lnum)","this is wrong. Did the linter actually complain about this line?Given this mistake, I am hesitant to merge this big lint change. Would rather leave it out. Micro-managing regexp.c is not worth our time.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10430,307975352,2019-07-27T19:28:07Z,src/nvim/context.c,"@@ -0,0 +1,383 @@+// This is an open source non-commercial project. Dear PVS-Studio, please check+// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com++// Context: snapshot of the entire editor state as one big object/map++#include ""nvim/context.h""+#include ""nvim/eval/encode.h""+#include ""nvim/ex_docmd.h""+#include ""nvim/option.h""+#include ""nvim/shada.h""+#include ""nvim/api/vim.h""+#include ""nvim/api/private/helpers.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""context.c.generated.h""+#endif++int kCtxAll = (kCtxRegs | kCtxJumps | kCtxBuflist | kCtxGVars | kCtxSFuncs+               | kCtxFuncs);++static ContextVec ctx_stack = KV_INITIAL_VALUE;++/// Clears and frees the context stack+void ctx_free_all(void)+{+  for (size_t i = 0; i < kv_size(ctx_stack); i++) {+    ctx_free(&kv_A(ctx_stack, i));+  }+  kv_destroy(ctx_stack);+}++/// Returns the size of the context stack.+size_t ctx_size(void)+{+  return kv_size(ctx_stack);+}++/// Returns pointer to Context object with given zero-based index from the top+/// of context stack or NULL if index is out of bounds.+Context *ctx_get(size_t index)+{+  if (index < kv_size(ctx_stack)) {+    return &kv_Z(ctx_stack, index);+  }+  return NULL;+}++/// Free resources used by Context object.+///+/// param[in]  ctx  pointer to Context object to free.+void ctx_free(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  if (ctx->regs.data) {+    msgpack_sbuffer_destroy(&ctx->regs);+  }+  if (ctx->jumps.data) {+    msgpack_sbuffer_destroy(&ctx->jumps);+  }+  if (ctx->buflist.data) {+    msgpack_sbuffer_destroy(&ctx->buflist);+  }+  if (ctx->gvars.data) {+    msgpack_sbuffer_destroy(&ctx->gvars);+  }+  if (ctx->funcs.items) {+    api_free_array(ctx->funcs);+  }+}++/// Saves the editor state to a context.+///+/// If ""context"" is NULL, pushes context on context stack.+/// Use ""flags"" to select particular types of context.+///+/// @param  ctx    Save to this context, or push on context stack if NULL.+/// @param  flags  Flags, see ContextTypeFlags enum.+void ctx_save(Context *ctx, const int flags)+{+  if (ctx == NULL) {+    kv_push(ctx_stack, CONTEXT_INIT);+    ctx = &kv_last(ctx_stack);+  }++  if (flags & kCtxRegs) {+    ctx_save_regs(ctx);+  }++  if (flags & kCtxJumps) {+    ctx_save_jumps(ctx);+  }++  if (flags & kCtxBuflist) {+    ctx_save_buflist(ctx);+  }++  if (flags & kCtxGVars) {+    ctx_save_gvars(ctx);+  }++  if (flags & kCtxFuncs) {+    ctx_save_funcs(ctx, false);+  } else if (flags & kCtxSFuncs) {+    ctx_save_funcs(ctx, true);+  }+}++/// Restores the editor state from a context.+///+/// If ""context"" is NULL, pops context from context stack.+/// Use ""flags"" to select particular types of context.+///+/// @param  ctx    Restore from this context. Pop from context stack if NULL.+/// @param  flags  Flags, see ContextTypeFlags enum.+///+/// @return true on success, false otherwise (i.e.: empty context stack).+bool ctx_restore(Context *ctx, const int flags)+{+  bool free_ctx = false;+  if (ctx == NULL) {+    if (ctx_stack.size == 0) {+      return false;+    }+    ctx = &kv_pop(ctx_stack);+    free_ctx = true;+  }++  char_u *op_shada;+  get_option_value((char_u *)""shada"", NULL, &op_shada, OPT_GLOBAL);+  set_option_value(""shada"", 0L, ""!,'100,%"", OPT_GLOBAL);++  if (flags & kCtxRegs) {+    ctx_restore_regs(ctx);+  }++  if (flags & kCtxJumps) {+    ctx_restore_jumps(ctx);+  }++  if (flags & kCtxBuflist) {+    ctx_restore_buflist(ctx);+  }++  if (flags & kCtxGVars) {+    ctx_restore_gvars(ctx);+  }++  if (flags & kCtxFuncs) {+    ctx_restore_funcs(ctx);+  }++  if (free_ctx) {+    ctx_free(ctx);+  }++  set_option_value(""shada"", 0L, (char *)op_shada, OPT_GLOBAL);+  xfree(op_shada);++  return true;+}++/// Saves the global registers to a context.+///+/// @param  ctx    Save to this context.+static inline void ctx_save_regs(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->regs);+  shada_encode_regs(&ctx->regs);+}++/// Restores the global registers from a context.+///+/// @param  ctx   Restore from this context.+static inline void ctx_restore_regs(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->regs, kShaDaWantInfo | kShaDaForceit);+}++/// Saves the jumplist to a context.+///+/// @param  ctx  Save to this context.+static inline void ctx_save_jumps(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->jumps);+  shada_encode_jumps(&ctx->jumps);+}++/// Restores the jumplist from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_jumps(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->jumps, kShaDaWantInfo | kShaDaForceit);+}++/// Saves the buffer list to a context.+///+/// @param  ctx  Save to this context.+static inline void ctx_save_buflist(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->buflist);+  shada_encode_buflist(&ctx->buflist);+}++/// Restores the buffer list from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_buflist(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->buflist, kShaDaWantInfo | kShaDaForceit);+}++/// Saves global variables to a context.+///+/// @param  ctx  Save to this context.+static inline void ctx_save_gvars(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  msgpack_sbuffer_init(&ctx->gvars);+  shada_encode_gvars(&ctx->gvars);+}++/// Restores global variables from a context.+///+/// @param  ctx  Restore from this context.+static inline void ctx_restore_gvars(Context *ctx)+  FUNC_ATTR_NONNULL_ALL+{+  shada_read_sbuf(&ctx->gvars, kShaDaWantInfo | kShaDaForceit);+}++/// Saves functions to a context.+///+/// @param  ctx         Save to this context.+/// @param  scriptonly  Save script functions only.+static inline void ctx_save_funcs(Context *ctx, bool scriptonly)+  FUNC_ATTR_NONNULL_ALL+{+  ctx->funcs = (Array)ARRAY_DICT_INIT;+  Error err = ERROR_INIT;++  HASHTAB_ITER(&func_hashtab, hi, {+    const char_u *const name = hi->hi_key;+    bool islambda = (STRNCMP(name, ""<lambda>"", 8) == 0);+    bool isscript = (name[0] == K_SPECIAL);++    if (!islambda && (!scriptonly || isscript)) {",`(!scriptonly || isscript)` seems like a weird condition.  With `scriptonly==true` I would expect it to check `isscript==true`.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10619,307997913,2019-07-28T11:52:01Z,src/nvim/shada.c,"@@ -4117,3 +4074,224 @@ static bool shada_removable(const char *name)   xfree(new_name);   return retval; }++/// Initialize ShaDa jumplist entries.+///+/// @param[in,out]  jumps           Array of ShaDa entries to set.+/// @param[in]      removable_bufs  Cache of buffers ignored due to their+///                                 location.+///+/// @return number of jumplist entries+static inline size_t shada_init_jumps(+    PossiblyFreedShadaEntry *jumps, khash_t(bufset) *const removable_bufs)+{+  // Initialize jump list+  size_t jumps_size = 0;+  const void *jump_iter = NULL;+  setpcmark();+  cleanup_jumplist(curwin, false);+  do {+    xfmark_T fm;+    jump_iter = mark_jumplist_iter(jump_iter, curwin, &fm);++    if (fm.fmark.mark.lnum == 0) {+      iemsgf(""ShaDa: mark lnum zero (ji:%p, js:%p, len:%i)"",+             (void *)jump_iter, (void *)&curwin->w_jumplist[0],+             curwin->w_jumplistlen);+      continue;+    }+    const buf_T *const buf = (fm.fmark.fnum == 0+                              ? NULL+                              : buflist_findnr(fm.fmark.fnum));+    if (buf != NULL+        ? in_bufset(removable_bufs, buf)+        : fm.fmark.fnum != 0) {+      continue;+    }+    const char *const fname = (char *) (fm.fmark.fnum == 0+                                        ? (fm.fname == NULL ? NULL : fm.fname)+                                        : buf->b_ffname);+    if (fname == NULL) {+      continue;+    }+    jumps[jumps_size++] = (PossiblyFreedShadaEntry) {+      .can_free_entry = false,+      .data = {+        .type = kSDItemJump,+        .timestamp = fm.fmark.timestamp,+        .data = {+          .filemark = {+            .name = NUL,+            .mark = fm.fmark.mark,+            .fname = (char *) fname,+            .additional_data = fm.fmark.additional_data,+          }+        }+      }+    };+  } while (jump_iter != NULL);+  return jumps_size;+}++/// Write registers ShaDa entries in given msgpack_sbuffer.+///+/// @param[in]  sbuf  target msgpack_sbuffer to write to.+void shada_encode_regs(msgpack_sbuffer *const sbuf)+  FUNC_ATTR_NONNULL_ALL+{+  WriteMergerState wms;+  shada_initialize_registers(&wms, -1);+  msgpack_packer packer;+  msgpack_packer_init(&packer, sbuf, msgpack_sbuffer_write);+  for (size_t i = 0; i < ARRAY_SIZE(wms.registers); i++) {+    if (wms.registers[i].data.type == kSDItemRegister) {+      shada_pack_pfreed_entry(&packer, wms.registers[i], 0);","@abdelhakeem these new `shada_encode_xx` functions do not check the result of `shada_pack_pfreed_entry`, unlike the existing `PACK_WMS_ARRAY` macro. https://github.com/neovim/neovim/pull/10637What about the idea of extending `shada_write()` instead of having new `shada_encode_xx` functions? Seems like duplicate logic.",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10638,308012231,2019-07-28T18:19:22Z,src/nvim/fileio.c,"@@ -4248,15 +4248,13 @@ void shorten_buf_fname(buf_T *buf, char_u *dirname, int force)       buf->b_sfname = vim_strsave(p);       buf->b_fname = buf->b_sfname;     }-    if (p == NULL || buf->b_fname == NULL) {",inverse condition on line: 4239,
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10641,308015396,2019-07-28T19:49:44Z,src/nvim/getchar.c,"@@ -4111,36 +4119,42 @@ makemap (                 return FAIL;             }           }-          if (c1 && putc(c1, fd) < 0)-            return FAIL;-          if (mp->m_noremap != REMAP_YES && fprintf(fd, ""nore"") < 0)+          if (c1 && putc(c1, fd) < 0) {             return FAIL;-          if (fputs(cmd, fd) < 0)+          }+          if (mp->m_noremap != REMAP_YES && fprintf(fd, ""nore"") < 0) {             return FAIL;-          if (buf != NULL && fputs("" <buffer>"", fd) < 0)+          }+          if (fputs(cmd, fd) < 0) {             return FAIL;-          if (mp->m_nowait && fputs("" <nowait>"", fd) < 0)+          }+          if (buf != NULL && fputs("" <buffer>"", fd) < 0) {             return FAIL;-          if (mp->m_silent && fputs("" <silent>"", fd) < 0)+          }+          if (mp->m_nowait && fputs("" <nowait>"", fd) < 0) {             return FAIL;-          if (mp->m_noremap == REMAP_SCRIPT","same condition used to skip look cycle, line 3995",X
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/10617,308090109,2019-07-29T07:37:16Z,src/nvim/pos.h,"@@ -11,9 +14,9 @@ typedef int colnr_T; #define PRIdCOLNR ""d""  /// Maximal (invalid) line number-enum { MAXLNUM = 0x7fffffff };+#define MAXLNUM LONG_MAX","So I started looking at this, but I'm confused on an early level. First, the assertions are justified because of the following casts, good we have them :)But then, if `SIZE_MAX < MAXLNUM`, that means we're potentially having more lines than fit in a `size_t`. Is that a real usecase, can that happen? I'm on shaky ground here, but I always assumed `SIZE_MAX` is really the largest addressable thing. The vim issue doesn't really discuss things...I'd have figured `#define MAXLUM SIZE_MAX` would be the way to go then. Since line numbers are `long`, things get complicated, but could we just take the smaller value of `LONG_MAX` and `SIZE_MAX`?We've always left the question open on chunking updates, and I'm a tad unclear on how it could be done.",X
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10654,308516463,2019-07-30T03:08:05Z,src/nvim/ex_cmds.c,"@@ -5324,13 +5324,11 @@ static void helptags_one(char_u *const dir, const char_u *const ext,    FreeWild(filecount, files); -  if (!got_int) {+  if (!got_int && ga.ga_data != NULL) {     /*      * Sort the tags.      */-    if (ga.ga_data != NULL) {","This suggests that execution of the function continues when `ga_data ==NULL`Line 5339: for clang here is potential null pointer dereference, as connection between `ga_len` and `ga_data` is implicit",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10662,309052012,2019-07-31T06:12:02Z,src/nvim/testdir/test_windows_home.vim,"@@ -60,18 +60,18 @@ func Test_WindowsHome()     let $USERPROFILE = 'unused'     let $HOMEDRIVE = 'C:'     let $HOMEPATH = '\foobar'-    let $HOME = ''  "" Force recomputing ""homedir""+    unlet $HOME  "" Force recomputing ""homedir""","Yes, plugins are an issue - it is bad if they see different behavior in subtle areas.But for this test: this could/should be changed like this in Vim itself already - I assume it is from before `unlet` supported envs.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10584,309177055,2019-07-31T11:52:36Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);-      break;-    case kProcessTypePty:-      // close all streams for pty processes to send SIGHUP to the process-      process_close_streams(proc);-      pty_process_close_master((PtyProcess *)proc);-      break;-    default:-      abort();-  }+  assert(proc->type == kProcessTypeUv || proc->type == kProcessTypePty);+  os_proc_tree_kill(proc->pid, SIGTERM);","@hardenedapple @bfredl What do you think about sending SIGTERM first, and only SIGHUP after 2s (when the job is still there)?  (via https://github.com/neovim/neovim/issues/5619)/cc @jamessan via https://github.com/neovim/neovim/issues/8760#issuecomment-406380765As seen in https://github.com/neovim/neovim/issues/8760#issuecomment-406364645 sending SIGTERM additionally makes sense (I assume that wasn't the case back then maybe?).  This is about the order it should happen in.I see SIGHUP here similar to closing stdin, which might cause a job to exit already, and think that using SIGTERM first is more explicity.  For non-pty jobs it makes the outcome more predictable (when closing stdin and sending SIGTERM is done together).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10584,309239900,2019-07-31T14:06:45Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);-      break;-    case kProcessTypePty:-      // close all streams for pty processes to send SIGHUP to the process-      process_close_streams(proc);-      pty_process_close_master((PtyProcess *)proc);-      break;-    default:-      abort();-  }+  assert(proc->type == kProcessTypeUv || proc->type == kProcessTypePty);+  os_proc_tree_kill(proc->pid, SIGTERM);","The point of using a pty job is to get pty semantics. If you do not want those, don't use a pty job or override the semantics manually. ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10584,309273492,2019-07-31T15:05:28Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);-      break;-    case kProcessTypePty:-      // close all streams for pty processes to send SIGHUP to the process-      process_close_streams(proc);-      pty_process_close_master((PtyProcess *)proc);-      break;-    default:-      abort();-  }+  assert(proc->type == kProcessTypeUv || proc->type == kProcessTypePty);+  os_proc_tree_kill(proc->pid, SIGTERM);",> The point of using a pty job is to get pty semantics.Not necessarily - I thought about using it only for merging stdout/stderr in the first place.I get your point though.  I will back it out of here.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10584,309293166,2019-07-31T15:41:25Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);-      break;-    case kProcessTypePty:-      // close all streams for pty processes to send SIGHUP to the process-      process_close_streams(proc);-      pty_process_close_master((PtyProcess *)proc);-      break;-    default:-      abort();-  }+  assert(proc->type == kProcessTypeUv || proc->type == kProcessTypePty);+  os_proc_tree_kill(proc->pid, SIGTERM);","> Not necessarily - I thought about using it only for merging stdout/stderr in the first placeDidnt we already discuss implementing this properly by just sharing a uv pipe? Merging stderr with stdout is an independent desicion from running with a controlling pty. We should enable additional behaviors by adding new options, not by distorting the defaults for non-standard use cases. Most terminals don't hunt down and SIGTERM/KILL their child processes, especially not before closing the pty (= SIGHUP). ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10584,309361785,2019-07-31T18:13:05Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);-      break;-    case kProcessTypePty:-      // close all streams for pty processes to send SIGHUP to the process-      process_close_streams(proc);-      pty_process_close_master((PtyProcess *)proc);-      break;-    default:-      abort();-  }+  assert(proc->type == kProcessTypeUv || proc->type == kProcessTypePty);+  os_proc_tree_kill(proc->pid, SIGTERM);","> Didnt we already discuss implementing this properly by just sharing a uv pipe?Yes, still wanted to give this as an example (again).> Most terminals don't hunt down and SIGTERM/KILL their child processesTrue.Should we stop doing this then also?> , especially not before closing the pty (= SIGHUP).That wasn't clear to me.However `process_close_streams(proc);` is still called before closing the master - which is similar to closing stdin for non-pty before SIGTERM, no?  I.e. there are inconsistent outcomes there then also (the process might exit itself due to stdin being closed, instead of because of SIGHUP).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10584,309368399,2019-07-31T18:27:10Z,src/nvim/event/process.c,"@@ -221,29 +221,15 @@ void process_stop(Process *proc) FUNC_ATTR_NONNULL_ALL   }   proc->stopped_time = os_hrtime(); -  switch (proc->type) {-    case kProcessTypeUv:-      // Close the process's stdin. If the process doesn't close its own-      // stdout/stderr, they will be closed when it exits(possibly due to being-      // terminated after a timeout)-      stream_may_close(&proc->in);-      os_proc_tree_kill(proc->pid, SIGTERM);-      break;-    case kProcessTypePty:-      // close all streams for pty processes to send SIGHUP to the process-      process_close_streams(proc);-      pty_process_close_master((PtyProcess *)proc);-      break;-    default:-      abort();-  }+  assert(proc->type == kProcessTypeUv || proc->type == kProcessTypePty);+  os_proc_tree_kill(proc->pid, SIGTERM);","> Should we stop doing this then also?I thought I/we implemented this long ago (perhaps one of the linked issues, but my travel battery is a bit low so I won't read them all through now).> I.e. there are inconsistent outcomes there then also (the process might exit itself due to stdin being closed, instead of because of SIGHUP).AFAIK this is up to the client process and not our concern. We just close the master end ( `process_close_streams` are just duplicates of the same master handle to make the code simpler IIRC), and the process might choose to handle SIGHUP or be killed by it, or silence it and exit by stdin read failure, or just ignore it altogheter etc.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10161,310375734,2019-08-04T08:08:27Z,src/nvim/eval.c,"@@ -23985,50 +23985,23 @@ typval_T eval_call_provider(char *provider, char *method, list_T *arguments)   return rettv; } -bool eval_has_provider(const char *name)-{-#define CHECK_PROVIDER(name) \-  if (has_##name == -1) { \-    has_##name = !!find_func((char_u *)""provider#"" #name ""#Call""); \-    if (!has_##name) { \-      script_autoload(""provider#"" #name ""#Call"", \-                      sizeof(""provider#"" #name ""#Call"") - 1, \-                      false); \-      has_##name = !!find_func((char_u *)""provider#"" #name ""#Call""); \-    } \-  }--  static int has_clipboard = -1;-  static int has_python = -1;-  static int has_python3 = -1;-  static int has_ruby = -1;--  if (strequal(name, ""clipboard"")) {-    CHECK_PROVIDER(clipboard);-    return has_clipboard;-  } else if (strequal(name, ""python3"")) {-    CHECK_PROVIDER(python3);-    return has_python3;-  } else if (strequal(name, ""python"")) {-    CHECK_PROVIDER(python);-    return has_python;-  } else if (strequal(name, ""ruby"")) {-    bool need_check_ruby = (has_ruby == -1);-    CHECK_PROVIDER(ruby);-    if (need_check_ruby && has_ruby == 1) {-      char *rubyhost = call_func_retstr(""provider#ruby#Detect"", 0, NULL, true);-      if (rubyhost) {-        if (*rubyhost == NUL) {-          // Invalid rubyhost executable. Gem is probably not installed.-          has_ruby = 0;-        }-        xfree(rubyhost);-      }-    }-    return has_ruby;+/// Check if a named provider exists.+bool eval_has_provider(const char *provider)+{+  char varname[256];+  int varname_len = snprintf(varname, sizeof(varname),+                             ""provider#%s#enabled"", provider);++  typval_T tv;+  if (get_var_tv(varname, varname_len, &tv, NULL, false, false) == FAIL) {+    return false;","I think we should keep a whitelist with the known provider names. It seems like an anti-feature to me that user code can turn any `has(""xyz"")` to true. We can easily add more names to the list as we add more provider features.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10690,310404958,2019-08-04T21:41:37Z,src/nvim/lua/executor.c,"@@ -323,6 +326,42 @@ void executor_exec_lua(const String str, typval_T *const ret_tv)   nlua_pop_typval(lstate, ret_tv); } +static void nlua_print_event(void **argv)+{+  char *str = argv[0];+  const size_t len = (size_t)(intptr_t)argv[1]-1;  // exclude final NUL++  for (size_t i = 0; i < len;) {+    const size_t start = i;+    while (i < len) {+      switch (str[i]) {+        case NUL: {+          str[i] = NL;","As mentioned five lines below in the same commit this is a temporary stopgap. The intention is to add something like `nvim_message` that is a lot more flexible, then `print()` can be implemented in pure lua on top of that.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10697,310824780,2019-08-05T23:02:41Z,CMakeLists.txt,"@@ -463,6 +463,9 @@ endif() if(ENABLE_LIBICONV)   find_package(Iconv REQUIRED)   include_directories(SYSTEM ${Iconv_INCLUDE_DIRS})+  if(MSVC)+    set(CMAKE_REQUIRED_INCLUDES ${ICONV_INCLUDE_DIR})","should this be:    list(APPEND CMAKE_REQUIRED_INCLUDES ""${ICONV_INCLUDE_DIR}"")based on:  https://github.com/neovim/neovim/blob/7086751c5e4eb3cfee0b98df0d3cedc8bff47d35/cmake/FindLibIntl.cmake#L33-L35Maybe do it in `FindIconv.cmake`, without the MSVC check, similar to `FindLibIntl.cmake`?``` if (ICONV_INCLUDE_DIR)    list(APPEND CMAKE_REQUIRED_INCLUDES ""${ICONV_INCLUDE_DIR}"")  endif() ```",
18271144,ngortheone,https://api.github.com/repos/neovim/neovim/pulls/10705,311024389,2019-08-06T12:02:47Z,CMakeLists.txt,"@@ -251,14 +251,15 @@ int main(void) {   void *trace[1];   int trace_size = backtrace(trace, 1);+  (void)trace_size;","Yes, clang gives warning of dead assignment here, this is no-op use if the variable should suppress it. This is the trick @justinmk taught me ",X
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10705,311294470,2019-08-06T22:01:30Z,CMakeLists.txt,"@@ -251,14 +251,15 @@ int main(void) {   void *trace[1];   int trace_size = backtrace(trace, 1);+  (void)trace_size;","What I mean is that this will also avoid the warning (since there is not unused var in the first place):```diffdiff --git i/CMakeLists.txt w/CMakeLists.txtindex 947de6198..3d3c19efe 100644--- i/CMakeLists.txt+++ w/CMakeLists.txt@@ -250,7 +250,7 @@ check_c_source_compiles("" int main(void) {   void *trace[1];-  int trace_size = backtrace(trace, 1);+  backtrace(trace, 1);   return 0; } "" HAVE_EXECINFO_BACKTRACE)```",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10650,311856524,2019-08-08T05:04:42Z,src/nvim/testdir/unix.vim,"@@ -2,14 +2,20 @@ "" Always use ""sh"", don't use the value of ""$SHELL"". set shell=sh +"" Only when the +eval feature is present. +if 1+  "" While some tests overwrite $HOME to prevent them from polluting user files,+  "" we need to remember the original value so that we can tell external systems+  "" where to ask about their own user settings.+  let g:tester_HOME = $HOME+endif++source setup.vim++"" TODO: upstream?+"" Initially added in https://github.com/neovim/neovim/commit/4a5bc6275d090.+"" Appears to make sense as in ""adjust for set shell=sh"". if has('win32')   set shellcmdflag=-c shellxquote= shellxescape= shellquote=   let &shellredir = '>%s 2>&1'-  set shellslash",..but nvim does not have that: https://github.com/vim/vim/blob/8c5a278fc508da6dfe50e69b6ee734451aa4eafb/src/option.c#L4173-L4232,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10749,312859872,2019-08-12T10:24:56Z,test/functional/ui/inccommand_spec.lua,"@@ -2634,3 +2634,19 @@ it(':substitute with inccommand, timer-induced :redraw #9777', function()     :%s/foo/ZZZ^                   |   ]]) end)++it('long :%s/ with inccomand does not collapse cmdline', function()","```suggestionit('long :%s/ with inccommand does not collapse cmdline', function()```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10754,313018484,2019-08-12T16:41:14Z,test/functional/terminal/tui_spec.lua,"@@ -438,34 +438,29 @@ describe('TUI FocusGained/FocusLost', function()     feed_data(':set shell='..nvim_dir..'/shell-test\n')     feed_data(':set noshowmode laststatus=0\n') -    retry(3, nil, function()-      feed_data(':terminal\n')-      screen:sleep(1)-      feed_data('\027[I')-      screen:expect([[-        {1:r}eady $                                           |-        [Process exited 0]                                |-                                                          |-                                                          |-                                                          |-        gained                                            |-        {3:-- TERMINAL --}                                    |-      ]])-      feed_data('\027[O')-      screen:expect([[-        {1:r}eady $                                           |-        [Process exited 0]                                |-                                                          |-                                                          |-                                                          |-        lost                                              |-        {3:-- TERMINAL --}                                    |-      ]])--      -- If retry is needed...-      feed_data(""\034\016"")  -- CTRL-\ CTRL-N-      feed_data(':bwipeout!\n')-    end)+    feed_data(':terminal\n')+    screen:sleep(1)+    feed_data('\027[I')+    screen:expect({grid=[[+      {1:r}eady $                                           |+      [Process exited 0]                                |+                                                        |+                                                        |+                                                        |+      gained                                            |+      {3:-- TERMINAL --}                                    |+    ]], timeout=(3 * screen.timeout)})","I don't think this will help. The reason for the retry() was because of potential ""racy"" behavior with `feed_data('\027[I')` or focus gained/lost ordering.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10755,313515394,2019-08-13T17:18:09Z,src/nvim/edit.c,"@@ -3672,28 +3672,28 @@ static buf_T *ins_compl_next_buf(buf_T *buf, int flag) }  -/*- * Execute user defined complete function 'completefunc' or 'omnifunc', and- * get matches in ""matches"".- */+// Execute user defined complete function 'completefunc' or 'omnifunc', and+// get matches in ""matches"". static void-expand_by_function (-    int type,                   /* CTRL_X_OMNI or CTRL_X_FUNCTION */+expand_by_function(+    int type,                   // CTRL_X_OMNI or CTRL_X_FUNCTION     char_u *base ) {-  list_T      *matchlist = NULL;-  dict_T      *matchdict = NULL;-  char_u      *funcname;+  list_T *matchlist = NULL;+  dict_T *matchdict = NULL;+  char_u *funcname;   pos_T pos;-  win_T       *curwin_save;-  buf_T       *curbuf_save;+  win_T *curwin_save;+  buf_T *curbuf_save;   typval_T rettv;   const int save_State = State; +  assert(curbuf != NULL && curbuf->b_p_cfu != NULL && curbuf->b_p_ofu != NULL);   funcname = (type == CTRL_X_FUNCTION) ? curbuf->b_p_cfu : curbuf->b_p_ofu;-  if (*funcname == NUL)+  if (*funcname == NUL) {     return;",Which makes sense according to the above `assert`..So this appears to be dead code now?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10755,313554735,2019-08-13T18:44:05Z,src/nvim/edit.c,"@@ -3672,28 +3672,28 @@ static buf_T *ins_compl_next_buf(buf_T *buf, int flag) }  -/*- * Execute user defined complete function 'completefunc' or 'omnifunc', and- * get matches in ""matches"".- */+// Execute user defined complete function 'completefunc' or 'omnifunc', and+// get matches in ""matches"". static void-expand_by_function (-    int type,                   /* CTRL_X_OMNI or CTRL_X_FUNCTION */+expand_by_function(+    int type,                   // CTRL_X_OMNI or CTRL_X_FUNCTION     char_u *base ) {-  list_T      *matchlist = NULL;-  dict_T      *matchdict = NULL;-  char_u      *funcname;+  list_T *matchlist = NULL;+  dict_T *matchdict = NULL;+  char_u *funcname;   pos_T pos;-  win_T       *curwin_save;-  buf_T       *curbuf_save;+  win_T *curwin_save;+  buf_T *curbuf_save;   typval_T rettv;   const int save_State = State; +  assert(curbuf != NULL && curbuf->b_p_cfu != NULL && curbuf->b_p_ofu != NULL);   funcname = (type == CTRL_X_FUNCTION) ? curbuf->b_p_cfu : curbuf->b_p_ofu;-  if (*funcname == NUL)+  if (*funcname == NUL) {     return;","yeah the ternary would be dead code if we are asserting `curbuf->b_p_cfu != NULL` just before it. The clang warning wasn't clear to me, I thought it was only warning about `curbuf` being NULL. So let's only assert  that, and see if clang still warns after that.    assert(curbuf != NULL);",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10761,313583642,2019-08-13T19:55:05Z,src/nvim/message.c,"@@ -2559,10 +2559,11 @@ static int do_more_prompt(int typed_char) #if defined(WIN32) void mch_errmsg(char *str) {+  assert(str != NULL);   wchar_t *utf16str;-  int conversion_result = utf8_to_utf16((str), &utf16str);-  if (conversion_result != 0) {-    EMSG2(""utf8_to_utf16 failed: %d"", conversion_result);+  int r = utf8_to_utf16(str, -1, &utf16str);+  if (r != 0) {+    fprintf(stderr, ""utf8_to_utf16 failed: %d"", r);",EMSG2 could be circular I guess.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10773,313725228,2019-08-14T06:46:46Z,test/functional/api/vim_spec.lua,"@@ -1148,6 +1148,13 @@ describe('API', function()     before_each(function()       meths.set_option('isident', '')     end)++    local it+    if (helpers.isCI('appveyor') and os.getenv('CONFIGURATION') == 'MSVC_32') then+      -- 'works with &opt' is flaky on MSVC_32, but not easy to skip alone.  #10241+      it = pending","Let's not use this pattern. It will cause many ""SKIP"" messages, we only want 1 message.```suggestion      pending('broken on MSVC_32', function() end)      return```",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10773,313735153,2019-08-14T07:21:16Z,test/functional/api/vim_spec.lua,"@@ -1148,6 +1148,13 @@ describe('API', function()     before_each(function()       meths.set_option('isident', '')     end)++    local it+    if (helpers.isCI('appveyor') and os.getenv('CONFIGURATION') == 'MSVC_32') then+      -- 'works with &opt' is flaky on MSVC_32, but not easy to skip alone.  #10241+      it = pending","That will not work here.. the tests are run in/via a different file - and you would also skip ""everything below"".To only disable the flaky test (https://github.com/blueyed/neovim/blob/055bfca30b9d58c68bcca74977ce590a0c052d0c/test/unit/viml/expressions/parser_tests.lua#L6329) we would need to pass through ""pending"" as-is, and use it for it then.  Would require to change the interface (but might be ok - but I do not think it's worth the extra effort, for something that likely indicates a bug anyway.. :/)).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10759,313783031,2019-08-14T09:25:03Z,test/functional/provider/python3_spec.lua,"@@ -90,6 +90,11 @@ describe('python3 provider', function()     eq({1, 2, {['key'] = 'val'}}, eval([[py3eval('[1, 2, {""key"": ""val""}]')]]))   end) +  it('pyxeval #10758', function()","could check `eq(0, eval([[&pyxversion]]))` as a precondition (setup did not use pyx by accident, or something)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10775,313957631,2019-08-14T16:05:04Z,ci/common/test.sh,"@@ -80,8 +80,8 @@ valgrind_check() {   check_logs ""${1}"" ""valgrind-*"" } -asan_check() {-  if test ""${CLANG_SANITIZER}"" = ""ASAN_UBSAN"" ; then+sanitizer_check() {","since we're renaming it let's put the verb first, similar to `check_logs`.```suggestioncheck_sanitizer() {```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10222,314021524,2019-08-14T18:30:48Z,runtime/autoload/lsp/completion.vim,"@@ -0,0 +1,43 @@+let s:last_location = -1++""""+"" Omni completion with LSP+function! lsp#completion#omni(findstart, base) abort+  "" If we haven't started, then don't return anything useful+  if !luaeval(""require('lsp.api').plugin.client_has_started(_A)"", &filetype)+    return a:findstart ? -1 : []+  endif++  if a:findstart == 1+    let s:last_location =  col('.')++    let line_to_cursor = strpart(getline('.'), 0, col('.') - 1)+    let [string_result, start_position, end_position] = matchstrpos(line_to_cursor, '\k\+$')+    let length = end_position - start_position++    return len(line_to_cursor) - length+  elseif a:findstart == 0+    let params = luaeval(""require('lsp.api').structures.CompletionParams(""","Rather than invoking multiple lua wrappers in sequence and needlessly convert data back and forth (which risks being lossy), we should just call one lua function that does what is needed ( `requests.textDocument.completion` maybe ? though the relation between the structures and requests modules looks a bit weird, I need to figure that out )",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10222,314028511,2019-08-14T18:47:21Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,191 @@+-- luacheck: globals vim++local lsp_util = require('lsp.util')++local protocol = require('lsp.protocol')++-- Helper functions+local check_table = function (t)+  if type(t) ~= 'table' then+    t = {}+  end++  return t+end++-- Structure definitions+local structures = {}++structures.EOL = function()+  if vim.api.nvim_buf_get_option(0, 'eol') then+    return ""\n""+  else+    return ''+  end+end++structures.DocumentUri = function(args)+  return args+    or 'file://' .. vim.api.nvim_buf_get_name(0)+end+structures.languageId = function(args)+  return args+     or vim.api.nvim_buf_get_option(0, 'filetype')+end+-- TODO: Increment somehow+local __version = 0+structures.version = function(args)+  __version = __version + 1+  return args+    or __version+end+structures.text = function(args)+  return args+    or lsp_util.get_buffer_text(0)+end+structures.TextDocumentIdentifier = function(args)+  args = check_table(args)++  return {+    uri = structures.DocumentUri(args.uri),+  }+end+structures.VersionedTextDocumentIdentifier = function(args)+  args = check_table(args)++  local result = structures.TextDocumentIdentifier(args)+  result.version = structures.version(args.version)++  return result+end+structures.TextDocumentItem = function(args)+  args = check_table(args)++  return {+    uri = structures.DocumentUri(args.uri),+    languageId = structures.languageId(args.languageId),+    version = structures.version(args.version),+    text = structures.text(args.text),+  }+end+structures.line = function(args)+  return args+    -- TODO: Check the conversion of some of these functions from nvim <-> lua+    or (vim.api.nvim_call_function('line', {'.'}) - 1)+end+structures.character = function(args)+  return args+    or (vim.api.nvim_call_function('col', {'.'}) - 1)+end++structures.Position = function(args)+  args = check_table(args)++  return {+    line = structures.line(args.line),+    character = structures.character(args.character),+  }+end+structures.TextDocumentPositionParams = function(args)+  args = check_table(args)++  return {+    textDocument = structures.TextDocumentIdentifier(args.textDocument),+    position = structures.Position(args.position),+  }+end+structures.ReferenceContext = function(args)+  args = check_table(args)++  return {+    includeDeclaration = args.includeDeclaration or true,+  }+end+structures.ReferenceParams = function(args)+  args = check_table(args)++  local positionParams = structures.TextDocumentPositionParams(args)+  positionParams.context = structures.ReferenceContext(args.context)++  return positionParams+end+structures.DidOpenTextDocumentParams = function(args)","I do not think it makes sense to both have `structures` methods for concrete messages like `structures.DidOpenTextDocumentParams` that then is only used in one method like `notifications.textDocument.didOpen` (which also commonly are completely empty except for the ""structures"" call) . This is just indirection and multiple naming schemes for the same thing, not encapsulation. Probably `structures` should only be for the reuseable structure bits, and we merge these duplicate methods into their respective request/notification handlers.",X
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/10777,314086820,2019-08-14T21:16:02Z,src/nvim/ex_getln.c,"@@ -1022,9 +1022,12 @@ static int command_line_execute(VimState *state, int key)    // <S-Tab> goes to last match, in a clumsy way   if (s->c == K_S_TAB && KeyTyped) {-    if (nextwild(&s->xpc, WILD_EXPAND_KEEP, 0, s->firstc != '@') == OK-        && nextwild(&s->xpc, WILD_PREV, 0, s->firstc != '@') == OK-        && nextwild(&s->xpc, WILD_PREV, 0, s->firstc != '@') == OK) {+    if (nextwild(&s->xpc, WILD_EXPAND_KEEP, 0, s->firstc != '@') == OK) {+      showmatches(&s->xpc, p_wmnu+                  && ((wim_flags[s->wim_index] & WIM_LIST) == 0));+      redrawcmd();",`<S-Tab>` seems to work without it but I decided to add it because the `<Tab>` path [also has one](https://github.com/neovim/neovim/blob/master/src/nvim/ex_getln.c#L990). It doesn't seem necessary either though (tests don't fail if I remove it). Should I amend my commit to remove both `redrawcmd()` calls?,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10222,314114571,2019-08-14T22:41:47Z,runtime/doc/lsp.txt,"@@ -0,0 +1,306 @@+*lsp.txt* The Language Server Protocol++        NVIM REFERENCE MANUAL+++Neovim Language Server Protocol (LSP) API++Neovim exposes a powerful API that conforms to Microsoft's published Language+Server Protocol specification. The documentation can be found here:++    https://microsoft.github.io/language-server-protocol/+++================================================================================+                                                                  *lsp-server*++Neovim only exposes a powerful API for the language server protocol. To get+the real benefits of this API, a language server must be installed. Many+examples can be found here:++  https://microsoft.github.io/language-server-protocol/implementors/servers/++After installing a language server to your machine, you must let Neovim know+how to start and interact with that language server. To do so, use the+following APIs:++                                                      *lsp#server_config#add()*+lsp#server_config#add({ftype}, {cmd}, {configuration}):+    Used to add a language server.++    This will add an autocmd that will start the server and handle any other+    startup activities whenever the |FileType| event is triggered for {ftype}.++    Parameters:~+        {ftype}: A string or list of strings of filetypes to associate with+        this server.++        {cmd}: See |jobstart()| for information on cmd.++        {configuration} (dictionary): Optional configuration for a server.+            `name`      (string):+              The name of the server++            `callbacks` (dict):+              A dictionary of callbacks to configure the server.++              Available callbacks are:++              `root_uri`: function(server) -> string.+                This function returns a string to populate the `root_uri`+                parameter in the initialize request for a server.++                Example:~+>+  "" Python example+  call lsp#server_config#add('python', 'pyls')++  "" Typescript configuration+  call lsp#server_config#add('typescript', {+      \ 'name': 'ts', ....+      \ 'callbacks': {+        \ 'root_uri': { server -> RootFinderFromPlugin() }+      \ }})++================================================================================+                                                                  *lsp-request*+Requests++To make a request of the language server client running in Nvim, the following+API is defined:+>+    :call lsp#request(method, arguments, callback, filetype)+    :call lsp#request_async(method, arguments, callback, filetype)+<++                                                                *lsp#request()*+lsp#request({method} [, {arguments} [, {callback} [, {filetype}]]])+    Creates and sends a request to the server for [filetype]. Will fill in any+    missing required arguments as defined by the language server protocol. Will+    call the built-in callback for the request (if you set that and it exists), unless an+    [callback] is specified, in which case that will be called upon completion+    of the request.++    Returns the request's response data.++        Parameters:~+            {method}: The name of the request, as specified by the+            language server protocol.+                Example: 'textDocument/hover'++            [arguments]: The arguments that should be passed to the language+            server. If any required keys are missing, Nvim will fill those in+            with reasonable default values.+                Example (with 'textDocument/hover'):+                    Passed in:+                        `{}` or |v:null|++                    Sent:+>+                        {+                            'textDocument': '/home/user/test/example.lua',+                            'position': { 'line': 13, 'character': 17 }+                        }+<+                Example (with 'textDocument/rename'):+                    Passed in:+>+                        {+                            'newName': 'exampleRename'+                        }+<+                    Sent:+>+                        {+                            'textDocument': '/home/user/test/rename.lua',+                            'position': { 'line': 16, 'character': 8 }+                            'newName': 'exampleRename'+                        }+<++            [callback]: An optional callback that will be executed+            once the response has been received. If this is passed and not+            |v:null|, then the |lsp-built-in-callback| will not be executed for+            this request. If you do not set |built-in-callbacks| or this request does not have a+            a specify filetype callback, then no callback will be executed upon receiving the request.++            The callback must be a string with the name of the vimscript+            function to call. The signature must be:++                `func_name({success}, {data})`++                where {success} is a boolean where true means successful request+                and false means the request failed.++                The parameter {data} is a dictionary containing the possible+                response data (or error) data as specified by the language",```suggestion                response data (or error) as specified by the language```,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10222,314116407,2019-08-14T22:48:46Z,runtime/doc/lsp.txt,"@@ -0,0 +1,306 @@+*lsp.txt* The Language Server Protocol++        NVIM REFERENCE MANUAL+++Neovim Language Server Protocol (LSP) API++Neovim exposes a powerful API that conforms to Microsoft's published Language+Server Protocol specification. The documentation can be found here:++    https://microsoft.github.io/language-server-protocol/+++================================================================================+                                                                  *lsp-server*++Neovim only exposes a powerful API for the language server protocol. To get+the real benefits of this API, a language server must be installed. Many+examples can be found here:++  https://microsoft.github.io/language-server-protocol/implementors/servers/++After installing a language server to your machine, you must let Neovim know+how to start and interact with that language server. To do so, use the+following APIs:++                                                      *lsp#server_config#add()*+lsp#server_config#add({ftype}, {cmd}, {configuration}):+    Used to add a language server.++    This will add an autocmd that will start the server and handle any other+    startup activities whenever the |FileType| event is triggered for {ftype}.++    Parameters:~+        {ftype}: A string or list of strings of filetypes to associate with+        this server.++        {cmd}: See |jobstart()| for information on cmd.++        {configuration} (dictionary): Optional configuration for a server.+            `name`      (string):+              The name of the server++            `callbacks` (dict):+              A dictionary of callbacks to configure the server.++              Available callbacks are:++              `root_uri`: function(server) -> string.+                This function returns a string to populate the `root_uri`+                parameter in the initialize request for a server.++                Example:~+>+  "" Python example+  call lsp#server_config#add('python', 'pyls')++  "" Typescript configuration+  call lsp#server_config#add('typescript', {+      \ 'name': 'ts', ....+      \ 'callbacks': {+        \ 'root_uri': { server -> RootFinderFromPlugin() }+      \ }})++================================================================================+                                                                  *lsp-request*+Requests++To make a request of the language server client running in Nvim, the following+API is defined:+>+    :call lsp#request(method, arguments, callback, filetype)+    :call lsp#request_async(method, arguments, callback, filetype)+<++                                                                *lsp#request()*+lsp#request({method} [, {arguments} [, {callback} [, {filetype}]]])+    Creates and sends a request to the server for [filetype]. Will fill in any+    missing required arguments as defined by the language server protocol. Will+    call the built-in callback for the request (if you set that and it exists), unless an+    [callback] is specified, in which case that will be called upon completion+    of the request.++    Returns the request's response data.++        Parameters:~+            {method}: The name of the request, as specified by the+            language server protocol.+                Example: 'textDocument/hover'++            [arguments]: The arguments that should be passed to the language+            server. If any required keys are missing, Nvim will fill those in+            with reasonable default values.+                Example (with 'textDocument/hover'):+                    Passed in:+                        `{}` or |v:null|++                    Sent:+>+                        {+                            'textDocument': '/home/user/test/example.lua',+                            'position': { 'line': 13, 'character': 17 }+                        }+<+                Example (with 'textDocument/rename'):+                    Passed in:+>+                        {+                            'newName': 'exampleRename'+                        }+<+                    Sent:+>+                        {+                            'textDocument': '/home/user/test/rename.lua',+                            'position': { 'line': 16, 'character': 8 }+                            'newName': 'exampleRename'+                        }+<++            [callback]: An optional callback that will be executed+            once the response has been received. If this is passed and not+            |v:null|, then the |lsp-built-in-callback| will not be executed for+            this request. If you do not set |built-in-callbacks| or this request does not have a+            a specify filetype callback, then no callback will be executed upon receiving the request.++            The callback must be a string with the name of the vimscript+            function to call. The signature must be:++                `func_name({success}, {data})`++                where {success} is a boolean where true means successful request+                and false means the request failed.++                The parameter {data} is a dictionary containing the possible+                response data (or error) data as specified by the language+                server protocol.++                The callback will be executed from lua running:++                    `vim.api.nvim_call_function('func_name', { success, data })`++            [filetype]: The filetype associated with the server.+            This will default to the current |filetype| if nothing is passed.++            Configuration for the default server can be found at+            |lsp-configuration|.++                                                          *lsp#request_async()*+lsp#request_async({method} [, {arguments} [, {callback} [, {filetype}]]])+    Creates and sends a request to the server for [filetype]. This request+    will not block and will call desired the [callback] upon completion.++    Returns the request ID.++    See |lsp#request()| for more information.++    Example:++autocmd CursorHold *+    \ :lua vim.lsp.plugin.request_async(+    \     'textDocument/hover',+    \     vim.lsp.util.get_text_document_params(),+    \     vim.lsp.util.get_filetype()+    \ )++================================================================================+                                                         *lsp-built-in-callback*++The following requests have built-in callbacks defined to handle the response+in an idiomatic vim fashion.++  textDocument/definition~+  textDocument/hover~+  textDocument/publishDiagnostics~+  textDocument/references~++vim.lsp.config.callbacks.set_all_builtin_callbacks()+  You can set all built-in callbaks++vim.lsp.config.callbacks.set_builtin_callback({method})+    You can set a specify built-in callback.+        Parameters:~+            {method}: The name of the request, as specified by the+            language server protocol.+                Example: 'textDocument/hover'++vim.lsp.config.callbacks.set_builtin_callbacks({methods})+    You can set specify built-in callbacks.+        Parameters:~+            {method}: The name of the request, as specified by the+            language server protocol.+                Example: {'textDocument/hover', 'textDocument/publishDiagnostics'}+++================================================================================+                                                         *lsp-common-behavior*++Many of the Language Server Protocol messages are similar to common commandds",```suggestionMany of the Language Server Protocol messages are similar to common commands```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10780,314200714,2019-08-15T07:28:22Z,src/nvim/CMakeLists.txt,"@@ -552,21 +552,24 @@ if(CLANG_ASAN_UBSAN)   else()     set(SANITIZE_RECOVER -fno-sanitize-recover)         # Clang 3.5-   endif()-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-DEXITFREE "")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""${SANITIZE_RECOVER} -fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=address -fsanitize=undefined -fsanitize-blacklist=${PROJECT_SOURCE_DIR}/src/.asan-blacklist"")+  set_property(TARGET nvim APPEND PROPERTY COMPILE_DEFINITIONS ""EXITFREE"")",����  since we bumped minimum CMake to 2.8.12 https://github.com/neovim/neovim/pull/4389 no longer applies.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10780,314202856,2019-08-15T07:37:35Z,src/nvim/CMakeLists.txt,"@@ -552,21 +552,24 @@ if(CLANG_ASAN_UBSAN)   else()     set(SANITIZE_RECOVER -fno-sanitize-recover)         # Clang 3.5-   endif()-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-DEXITFREE "")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""${SANITIZE_RECOVER} -fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=address -fsanitize=undefined -fsanitize-blacklist=${PROJECT_SOURCE_DIR}/src/.asan-blacklist"")+  set_property(TARGET nvim APPEND PROPERTY COMPILE_DEFINITIONS ""EXITFREE"")+  set_property(TARGET nvim APPEND PROPERTY COMPILE_OPTIONS ${SANITIZE_RECOVER} -fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=address -fsanitize=undefined)   set_property(TARGET nvim APPEND_STRING PROPERTY LINK_FLAGS ""-fsanitize=address -fsanitize=undefined "") elseif(CLANG_MSAN)   message(STATUS ""Enabling Clang memory sanitizer for nvim."")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-DEXITFREE "")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-fsanitize=memory -fsanitize-memory-track-origins -fno-omit-frame-pointer -fno-optimize-sibling-calls "")+  set_property(TARGET nvim APPEND PROPERTY COMPILE_DEFINITIONS EXITFREE)+  set_property(TARGET nvim APPEND PROPERTY COMPILE_OPTIONS -fsanitize=memory -fsanitize-memory-track-origins -fno-omit-frame-pointer -fno-optimize-sibling-calls)   set_property(TARGET nvim APPEND_STRING PROPERTY LINK_FLAGS ""-fsanitize=memory -fsanitize-memory-track-origins "") elseif(CLANG_TSAN)   message(STATUS ""Enabling Clang thread sanitizer for nvim."")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-DEXITFREE "")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-fsanitize=thread "")-  set_property(TARGET nvim APPEND_STRING PROPERTY COMPILE_FLAGS ""-fPIE "")+  set_property(TARGET nvim APPEND PROPERTY COMPILE_DEFINITIONS EXITFREE)+  set_property(TARGET nvim APPEND PROPERTY COMPILE_OPTIONS -fsanitize=thread)+  set_property(TARGET nvim APPEND PROPERTY COMPILE_OPTIONS -fPIE)   set_property(TARGET nvim APPEND_STRING PROPERTY LINK_FLAGS ""-fsanitize=thread "") endif()+if(CLANG_ASAN_UBSAN OR CLANG_MSAN OR CLANG_TSAN)+  set_property(TARGET nvim APPEND PROPERTY COMPILE_OPTIONS -fsanitize-blacklist=${PROJECT_SOURCE_DIR}/src/.sanitize-blacklist)","without the `[address]` or `[thread]` sections, I guess this will blacklist more than we want. However, it's fine for now.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10735,314243865,2019-08-15T09:51:21Z,src/nvim/api/vim.c,"@@ -1344,6 +1344,8 @@ Dictionary nvim_get_mode(void)    PUT(rv, ""mode"", STRING_OBJ(cstr_as_string(modestr)));   PUT(rv, ""blocking"", BOOLEAN_OBJ(blocked));+  // :help getcmdwintype()+  PUT(rv, ""wintype"", STRING_OBJ(cchar_to_string((char)cmdwin_type)));","> I think I'd prefer if we stuck to the standard plain : and / names, and these are simply understood (and documented) to mean ""cmdline window"".But there is no standard that says that one-letter chars identify cmdline window as opposed to other modal windows. We are defining this standard here and now, there is exactly nothing we have to ""stick"" to. One char strings are only used to distinguish the type of the _cmdline_ in something you already know is a cmdline window, for `getcmdwintype()` that already has ""cmdwin"" in the name.It would be useful for an async plugin to identify cmdline windows overall without caring which sort it is. Cmdline window overrides a bunch of behaviors consistently, regardless of what the `firstc` happens to be. Should they check if the string is one byte long? Do we want to rule out `firstc` from ever being a unicode char? Checking `wintype==""cmdwin""` is self-documenting, while `strlen(wintype)==1` looks fragile and obscure. The firstc can be just a separate field if it is needed, we do not have to invent new stringly typed composites like `""cmdline_/""`.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10797,314939128,2019-08-17T08:03:58Z,.builds/openbsd.yml,"@@ -31,3 +31,8 @@ tasks:     cmake -G Ninja ..     cmake --build . --config Debug     ./bin/nvim --version+- test: |+    export LC_CTYPE=en_US.UTF-8+    cd neovim+    # oldtests+    gmake -C src/nvim/testdir NVIM_PRG=`pwd`/build/bin/nvim","referencing the Windows (AppVeyor) [build.ps1](https://github.com/neovim/neovim/blob/master/ci/build.ps1#L121), this could be:    cmake --build . --config Debug --target oldtestSince bundled deps are being used on sourcehut, I guess we could also run the functional (Lua) tests.    cmake --build . --config Debug --target functionaltest",
604955,vext01,https://api.github.com/repos/neovim/neovim/pulls/10797,314975229,2019-08-18T08:57:58Z,.builds/openbsd.yml,"@@ -31,3 +31,8 @@ tasks:     cmake -G Ninja ..     cmake --build . --config Debug     ./bin/nvim --version+- test: |+    export LC_CTYPE=en_US.UTF-8+    cd neovim",Alas no.I don't think the old tests are CMakeified:```$ pwd             /home/edd/source/neovim$ find . -name 'CMake*' | xargs grep testdir $ ```Even the appveyor test you referenced earlier uses `make` for old tests:https://github.com/neovim/neovim/blob/e2ccf47b5e5e5acf19a74d928e367c7726d29ad3/ci/build.ps1#L137-L143,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10804,314988321,2019-08-18T14:28:34Z,test/functional/terminal/scrollback_spec.lua,"@@ -448,7 +448,7 @@ describe(""'scrollback' option"", function()     if iswin() then       feed_data('for /L %I in (1,1,40) do @(echo line%I)\r')     else-      feed_data('for i in $(seq 1 40); do echo ""line$i""; done\n')+      feed_data('awk ""BEGIN{for(n=1;n<=40;n++) print \\\""line\\\"" n}""\n')     end","i think we can use `shell-test` now, for all platforms including Windows. Example: https://github.com/neovim/neovim/blob/6b45e12d67ec01c8a/test/functional/ui/searchhl_spec.lua#L150    feed([[:terminal ""]]..nvim_dir..[[/shell-test"" REP 40 line<cr>]])",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/10222,315023910,2019-08-19T02:53:48Z,runtime/lua/nvim/log.lua,"@@ -59,19 +50,15 @@ log.create_functions = function(new_log, new_logger)          local info = debug.getinfo(2, ""Sl"")         local log_message = string.format(-          ""%s:%-4s %s"",+          ""%s:%s\t%s"",           info.short_src,           info.currentline,           message         ) -        if self.levels[name] >= logger.file_level then+        if self.levels[name] >= logger.log_level then",I would like to switch the log output condition to 'MIN_LOG_LEVEL'. Is there a way to get 'MIN_LOG_LEVEL'?,
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/10222,315024703,2019-08-19T03:00:22Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,191 @@+-- luacheck: globals vim++local lsp_util = require('lsp.util')++local protocol = require('lsp.protocol')++-- Helper functions+local check_table = function (t)+  if type(t) ~= 'table' then+    t = {}+  end++  return t+end++-- Structure definitions+local structures = {}++structures.EOL = function()+  if vim.api.nvim_buf_get_option(0, 'eol') then+    return ""\n""+  else+    return ''+  end+end++structures.DocumentUri = function(args)+  return args+    or 'file://' .. vim.api.nvim_buf_get_name(0)+end+structures.languageId = function(args)+  return args+     or vim.api.nvim_buf_get_option(0, 'filetype')+end+-- TODO: Increment somehow+local __version = 0+structures.version = function(args)+  __version = __version + 1+  return args+    or __version+end+structures.text = function(args)+  return args+    or lsp_util.get_buffer_text(0)+end+structures.TextDocumentIdentifier = function(args)+  args = check_table(args)++  return {+    uri = structures.DocumentUri(args.uri),+  }+end+structures.VersionedTextDocumentIdentifier = function(args)+  args = check_table(args)++  local result = structures.TextDocumentIdentifier(args)+  result.version = structures.version(args.version)++  return result+end+structures.TextDocumentItem = function(args)+  args = check_table(args)++  return {+    uri = structures.DocumentUri(args.uri),+    languageId = structures.languageId(args.languageId),+    version = structures.version(args.version),+    text = structures.text(args.text),+  }+end+structures.line = function(args)+  return args+    -- TODO: Check the conversion of some of these functions from nvim <-> lua+    or (vim.api.nvim_call_function('line', {'.'}) - 1)+end+structures.character = function(args)+  return args+    or (vim.api.nvim_call_function('col', {'.'}) - 1)+end++structures.Position = function(args)+  args = check_table(args)++  return {+    line = structures.line(args.line),+    character = structures.character(args.character),+  }+end+structures.TextDocumentPositionParams = function(args)+  args = check_table(args)++  return {+    textDocument = structures.TextDocumentIdentifier(args.textDocument),+    position = structures.Position(args.position),+  }+end+structures.ReferenceContext = function(args)+  args = check_table(args)++  return {+    includeDeclaration = args.includeDeclaration or true,+  }+end+structures.ReferenceParams = function(args)+  args = check_table(args)++  local positionParams = structures.TextDocumentPositionParams(args)+  positionParams.context = structures.ReferenceContext(args.context)++  return positionParams+end+structures.DidOpenTextDocumentParams = function(args)","@bfredl I would like to remove the `request / notification` validation and use structures only as a request parameter constructor to avoid duplication.Since validation has to keep up with changes in language server protocol, I think it is inconvenient for users to wait for neovim validation to be fixed before the release of neovim.What do you think about this?",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/10222,315065441,2019-08-19T07:13:55Z,runtime/lua/nvim/log.lua,"@@ -59,19 +50,15 @@ log.create_functions = function(new_log, new_logger)          local info = debug.getinfo(2, ""Sl"")         local log_message = string.format(-          ""%s:%-4s %s"",+          ""%s:%s\t%s"",           info.short_src,           info.currentline,           message         ) -        if self.levels[name] >= logger.file_level then+        if self.levels[name] >= logger.log_level then","I mean,https://github.com/neovim/neovim/blob/1852dfdf9aede9f3f8bc670e39c5830c644a9bbc/src/nvim/CMakeLists.txt#L177 , https://github.com/neovim/neovim/blob/master/src/nvim/log.c#L121 .That should be defined on build.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10768,315839274,2019-08-20T18:28:09Z,test/functional/eval/timer_spec.lua,"@@ -19,72 +19,85 @@ describe('timers', function()   end)    it('works one-shot', function()-    command(""call timer_start(50, 'MyHandler')"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(200))+    eq(0, eval(""[timer_start(10, 'MyHandler'), g:val][1]""))+    run(nil, nil, nil, load_adjust(100))     eq(1,eval(""g:val""))   end)    it('works one-shot when repeat=0', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 0})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(200))-    eq(1,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 0}), g:val][1]""))+    run(nil, nil, nil, load_adjust(100))+    eq(1, eval(""g:val""))   end) -   it('works with repeat two', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 2})"")-    eq(0,eval(""g:val""))","the reason for assertions like this is to make sure the editor doesn't accidentally have some variable defined that makes the test pass. (could be from a previous non-cleared session for example, or some new plugin, etc.)why remove it?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10768,315841263,2019-08-20T18:32:34Z,test/functional/eval/timer_spec.lua,"@@ -19,72 +19,85 @@ describe('timers', function()   end)    it('works one-shot', function()-    command(""call timer_start(50, 'MyHandler')"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(200))+    eq(0, eval(""[timer_start(10, 'MyHandler'), g:val][1]""))+    run(nil, nil, nil, load_adjust(100))     eq(1,eval(""g:val""))   end)    it('works one-shot when repeat=0', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 0})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(200))-    eq(1,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 0}), g:val][1]""))+    run(nil, nil, nil, load_adjust(100))+    eq(1, eval(""g:val""))   end) -   it('works with repeat two', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 2})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(300))-    eq(2,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 2}), g:val][1]""))+    run(nil, nil, nil, load_adjust(20))+    retry(nil, load_adjust(300), function()+      eq(2, eval(""g:val""))+    end)   end)    it('are triggered during sleep', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 2})"")+    source([[+      let g:val = -1+      func! MyHandler(timer)+        if g:val >= 0+          let g:val += 1+          if g:val == 2+            call timer_stop(a:timer)+          endif+        endif+      endfunc+    ]])+    eval(""timer_start(10, 'MyHandler', {'repeat': -1})"")     nvim_async(""command"", ""sleep 10"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(300))-    eq(2,eval(""g:val""))+    eq(-1, eval(""g:val""))  -- timer did nothing yet.+    nvim_async(""command"", ""let g:val = 0"")+    run(nil, nil, nil, load_adjust(20))+    retry(nil, nil, function()+      eq(2, eval(""g:val""))+    end)   end)    it('works with zero timeout', function()     -- timer_start does still not invoke the callback immediately-    eq(0,eval(""[timer_start(0, 'MyHandler', {'repeat': 1000}), g:val][1]""))-    run(nil, nil, nil, load_adjust(400))-    eq(1000,eval(""g:val""))+    eq(0, eval(""[timer_start(0, 'MyHandler', {'repeat': 1000}), g:val][1]""))+    retry(nil, nil, function()+      eq(1000, eval(""g:val""))+    end)   end)    it('can be started during sleep', function()     nvim_async(""command"", ""sleep 10"")     -- this also tests that remote requests works during sleep-    eval(""timer_start(50, 'MyHandler', {'repeat': 2})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(300))-    eq(2,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 2}), g:val][1]""))+    run(nil, nil, nil, load_adjust(20))+    retry(nil, load_adjust(300), function() eq(2,eval(""g:val"")) end)   end)    it('are paused when event processing is disabled', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': -1})"")-    run(nil, nil, nil, load_adjust(100))+    command(""call timer_start(5, 'MyHandler', {'repeat': -1})"")+    run(nil, nil, nil, load_adjust(10))     local count = eval(""g:val"")     -- shows two line error message and thus invokes the return prompt.     -- if we start to allow event processing here, we need to change this test.     feed(':throw ""fatal error""<CR>')-    run(nil, nil, nil, load_adjust(300))+    run(nil, nil, nil, load_adjust(30))     feed(""<cr>"")     local diff = eval(""g:val"") - count     assert(0 <= diff and diff <= 4,            'expected (0 <= diff <= 4), got: '..tostring(diff))   end)    it('are triggered in blocking getchar() call', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': -1})"")-    nvim_async(""command"", ""let g:c = getchar()"")-    run(nil, nil, nil, load_adjust(300))+    command(""call timer_start(5, 'MyHandler', {'repeat': -1})"")+    nvim_async(""command"", ""let g:val = 0 | let g:c = getchar()"")+    retry(nil, nil, function()+      ok(eval(""g:val"") >= 2)+      eq(0, eval(""getchar(1)""))+    end)     feed(""c"")-    local count = eval(""g:val"")-    assert(count >= 3, 'expected count >= 3, got: '..tostring(count))","the failure messages for `ok()` are useless, that's why assert() is used like that.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4448,315902587,2019-08-20T21:04:34Z,test/functional/terminal/tui_spec.lua,"@@ -197,26 +201,97 @@ describe('TUI', function()     ]])   end) -  it('can handle arbitrarily long bursts of input', function()-    -- Need extra time for this test, specially in ASAN.-    screen.timeout = 60000-    feed_command('set ruler')+  it('paste: big burst of input', function()","Cursor position should never depend on when a redraw is done. Forcing PUT_CURSEND in normal mode breaks using `nvim_put` to replace `call setreg(""x"", data, mode) | normal ""xp`, which I would hope it could do. Might better to have a flag for ""always cursend"" if this is needed for modelesslike TUI/GUI paste.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10768,315904175,2019-08-20T21:08:46Z,test/functional/eval/timer_spec.lua,"@@ -19,72 +19,85 @@ describe('timers', function()   end)    it('works one-shot', function()-    command(""call timer_start(50, 'MyHandler')"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(200))+    eq(0, eval(""[timer_start(10, 'MyHandler'), g:val][1]""))+    run(nil, nil, nil, load_adjust(100))     eq(1,eval(""g:val""))   end)    it('works one-shot when repeat=0', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 0})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(200))-    eq(1,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 0}), g:val][1]""))+    run(nil, nil, nil, load_adjust(100))+    eq(1, eval(""g:val""))   end) -   it('works with repeat two', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 2})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(300))-    eq(2,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 2}), g:val][1]""))+    run(nil, nil, nil, load_adjust(20))+    retry(nil, load_adjust(300), function()+      eq(2, eval(""g:val""))+    end)   end)    it('are triggered during sleep', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': 2})"")+    source([[+      let g:val = -1+      func! MyHandler(timer)+        if g:val >= 0+          let g:val += 1+          if g:val == 2+            call timer_stop(a:timer)+          endif+        endif+      endfunc+    ]])+    eval(""timer_start(10, 'MyHandler', {'repeat': -1})"")     nvim_async(""command"", ""sleep 10"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(300))-    eq(2,eval(""g:val""))+    eq(-1, eval(""g:val""))  -- timer did nothing yet.+    nvim_async(""command"", ""let g:val = 0"")+    run(nil, nil, nil, load_adjust(20))+    retry(nil, nil, function()+      eq(2, eval(""g:val""))+    end)   end)    it('works with zero timeout', function()     -- timer_start does still not invoke the callback immediately-    eq(0,eval(""[timer_start(0, 'MyHandler', {'repeat': 1000}), g:val][1]""))-    run(nil, nil, nil, load_adjust(400))-    eq(1000,eval(""g:val""))+    eq(0, eval(""[timer_start(0, 'MyHandler', {'repeat': 1000}), g:val][1]""))+    retry(nil, nil, function()+      eq(1000, eval(""g:val""))+    end)   end)    it('can be started during sleep', function()     nvim_async(""command"", ""sleep 10"")     -- this also tests that remote requests works during sleep-    eval(""timer_start(50, 'MyHandler', {'repeat': 2})"")-    eq(0,eval(""g:val""))-    run(nil, nil, nil, load_adjust(300))-    eq(2,eval(""g:val""))+    eq(0, eval(""[timer_start(10, 'MyHandler', {'repeat': 2}), g:val][1]""))+    run(nil, nil, nil, load_adjust(20))+    retry(nil, load_adjust(300), function() eq(2,eval(""g:val"")) end)   end)    it('are paused when event processing is disabled', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': -1})"")-    run(nil, nil, nil, load_adjust(100))+    command(""call timer_start(5, 'MyHandler', {'repeat': -1})"")+    run(nil, nil, nil, load_adjust(10))     local count = eval(""g:val"")     -- shows two line error message and thus invokes the return prompt.     -- if we start to allow event processing here, we need to change this test.     feed(':throw ""fatal error""<CR>')-    run(nil, nil, nil, load_adjust(300))+    run(nil, nil, nil, load_adjust(30))     feed(""<cr>"")     local diff = eval(""g:val"") - count     assert(0 <= diff and diff <= 4,            'expected (0 <= diff <= 4), got: '..tostring(diff))   end)    it('are triggered in blocking getchar() call', function()-    command(""call timer_start(50, 'MyHandler', {'repeat': -1})"")-    nvim_async(""command"", ""let g:c = getchar()"")-    run(nil, nil, nil, load_adjust(300))+    command(""call timer_start(5, 'MyHandler', {'repeat': -1})"")+    nvim_async(""command"", ""let g:val = 0 | let g:c = getchar()"")+    retry(nil, nil, function()+      ok(eval(""g:val"") >= 2)+      eq(0, eval(""getchar(1)""))+    end)     feed(""c"")-    local count = eval(""g:val"")-    assert(count >= 3, 'expected count >= 3, got: '..tostring(count))","> Should we discourage of ""ok"" then?Not sure. Maybe it could take an optional message parameter.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10824,316371980,2019-08-21T19:51:41Z,src/nvim/testdir/Makefile,"@@ -101,7 +101,10 @@ test1.out: $(NVIM_PRG) $(SCRIPTS): $(NVIM_PRG) test1.out  NO_PLUGINS = --noplugin --headless-NO_INITS = -U NONE $(NO_PLUGINS)+# In vim, if the -u command line option is specified, compatible is turned on+# and viminfo is not read. Unlike vim, neovim reads viminfo and requires the+# -i command line option.+NO_INITS = -U NONE -i viminfo $(NO_PLUGINS)","> > Ostensibly this change should not be necessary, because of this> > statement in runtest.vim: set viminfo+=nviminfo`viminfo+=nviminfo` is equivalent to `-i viminfo`, so I was only following that existing pattern.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10650,316543437,2019-08-22T08:00:09Z,Makefile,"@@ -122,6 +122,10 @@ else 	@# NOTE: supports TEST_FILE=test_foo.res to run test_foo actually 	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" $(patsubst %.res,%,$(TEST_FILE)) SCRIPTS= $(MAKEOVERRIDES) endif+# Build oldtest by specifying the .vim filename.+.PHONY: phony_force+src/nvim/testdir/%: phony_force+	$(MAKE) oldtest TEST_FILE=$(patsubst src/nvim/testdir/%.vim,%,$@)","The rule here handles ""src/���/test_foo.vim"" => TEST_FILE=test_foo (removing the .vim).The "".res"" above is substituted for B/C.`make src/nvim/testdir/test_environ.res` does not work.  It could be made to work, but it is better to not have it.I will change the pattern above to only handle `%.vim`.",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/10222,316952346,2019-08-23T02:14:07Z,runtime/lua/lsp/structures.lua,"@@ -0,0 +1,191 @@+-- luacheck: globals vim++local lsp_util = require('lsp.util')++local protocol = require('lsp.protocol')++-- Helper functions+local check_table = function (t)+  if type(t) ~= 'table' then+    t = {}+  end++  return t+end++-- Structure definitions+local structures = {}++structures.EOL = function()+  if vim.api.nvim_buf_get_option(0, 'eol') then+    return ""\n""+  else+    return ''+  end+end++structures.DocumentUri = function(args)+  return args+    or 'file://' .. vim.api.nvim_buf_get_name(0)+end+structures.languageId = function(args)+  return args+     or vim.api.nvim_buf_get_option(0, 'filetype')+end+-- TODO: Increment somehow+local __version = 0+structures.version = function(args)+  __version = __version + 1+  return args+    or __version+end+structures.text = function(args)+  return args+    or lsp_util.get_buffer_text(0)+end+structures.TextDocumentIdentifier = function(args)+  args = check_table(args)++  return {+    uri = structures.DocumentUri(args.uri),+  }+end+structures.VersionedTextDocumentIdentifier = function(args)+  args = check_table(args)++  local result = structures.TextDocumentIdentifier(args)+  result.version = structures.version(args.version)++  return result+end+structures.TextDocumentItem = function(args)+  args = check_table(args)++  return {+    uri = structures.DocumentUri(args.uri),+    languageId = structures.languageId(args.languageId),+    version = structures.version(args.version),+    text = structures.text(args.text),+  }+end+structures.line = function(args)+  return args+    -- TODO: Check the conversion of some of these functions from nvim <-> lua+    or (vim.api.nvim_call_function('line', {'.'}) - 1)+end+structures.character = function(args)+  return args+    or (vim.api.nvim_call_function('col', {'.'}) - 1)+end++structures.Position = function(args)+  args = check_table(args)++  return {+    line = structures.line(args.line),+    character = structures.character(args.character),+  }+end+structures.TextDocumentPositionParams = function(args)+  args = check_table(args)++  return {+    textDocument = structures.TextDocumentIdentifier(args.textDocument),+    position = structures.Position(args.position),+  }+end+structures.ReferenceContext = function(args)+  args = check_table(args)++  return {+    includeDeclaration = args.includeDeclaration or true,+  }+end+structures.ReferenceParams = function(args)+  args = check_table(args)++  local positionParams = structures.TextDocumentPositionParams(args)+  positionParams.context = structures.ReferenceContext(args.context)++  return positionParams+end+structures.DidOpenTextDocumentParams = function(args)","@bfredl I've forgotten handling server capabilities.In the original implementation, at the time of verifying the request parameter before requesting, for the function whose language server capability is false, only writing the log, but it was not actually requested.But now, I remove verifying the request parameter steps.I think we should leave only checking language server capabilities before requesting.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10382,317015174,2019-08-23T07:58:37Z,src/nvim/eval.c,"@@ -10929,6 +10929,89 @@ static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +// Dummy timer callback. Used by f_wait().+static void dummy_timer_due_cb(TimeWatcher *tw, void *data)+{+  if (!uv_timer_get_repeat(&tw->uv)) {+    time_watcher_start(tw, dummy_timer_due_cb, 0, 0);+  }+}++// Dummy timer close callback. Used by f_wait().+static void dummy_timer_close_cb(TimeWatcher *tw, void *data)+{+  multiqueue_free(tw->events);+  xfree(tw);+}++/// ""wait(timeout, condition[, interval])"" function+static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  rettv->v_type = VAR_NUMBER;+  rettv->vval.v_number = -1;++  if (argvars[0].v_type != VAR_NUMBER) {+    EMSG2(_(e_invarg2), ""First argument of wait() must be a number"");+    return;+  }++  int timeout = argvars[0].vval.v_number;+  typval_T expr = argvars[1];++  int interval = -1;+  typval_T *tv_interval = &argvars[2];++  TimeWatcher *tw = NULL;++  if (tv_interval->v_type == VAR_NUMBER) {+    interval = tv_interval->vval.v_number;+    if (interval < 0) {+      EMSG2(_(e_invarg2),+            ""Third argument of wait() must be a non-negative number"");+      return;+    }+    // Start dummy timer+    tw = xmalloc(sizeof(TimeWatcher));+    time_watcher_init(&main_loop, tw, NULL);+    tw->events = multiqueue_new_child(main_loop.events);","Can just use `tw->events = main_loop.events` and remove `multiqueue_free(tw->events)`. (`blockable=true` is still ok, because if there is another another event already on the loop the condition will be evaluated anyway).",
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/10382,317094791,2019-08-23T11:47:18Z,src/nvim/eval.c,"@@ -10929,6 +10929,89 @@ static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +// Dummy timer callback. Used by f_wait().+static void dummy_timer_due_cb(TimeWatcher *tw, void *data)+{+  if (!uv_timer_get_repeat(&tw->uv)) {",I supposed that `interval` can be zero (i.e.: evaluate the condition as soon as possible). There are test cases with that. Is it bad performance-wise?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10382,317103773,2019-08-23T12:17:11Z,src/nvim/eval.c,"@@ -10929,6 +10929,89 @@ static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)   } } +// Dummy timer callback. Used by f_wait().+static void dummy_timer_due_cb(TimeWatcher *tw, void *data)+{+  if (!uv_timer_get_repeat(&tw->uv)) {","It does not mean ""as soon as possible"" (we do that unconditionally already), but ""constantly spin the CPU"". Maybe it should be allowed, but certainly not recommended.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10839,317375286,2019-08-24T21:47:55Z,src/nvim/window.c,"@@ -2694,17 +2694,18 @@ void win_free_all(void)   while (first_tabpage->tp_next != NULL)     tabpage_close(TRUE); +  if (aucmd_win != NULL) {+    win_remove(aucmd_win, NULL);","No, I just mean the aucmd_win might already (actually typically) be removed before _this_ line. You have to check if it is in the list before calling `win_remove`.",
30594,andreypopp,https://api.github.com/repos/neovim/neovim/pulls/10844,317392356,2019-08-25T10:48:54Z,src/nvim/fileio.c,"@@ -7154,7 +7169,26 @@ char_u *getnextac(int c, void *cookie, int indent)     acp->nextcmd = ac->next;   } -  return retval;+  if (retval != NULL) {+    // Remove one-shot (""once"") autocmd in anticipation of its execution.+    if (ac->once) {+      XFREE_CLEAR(ac->cmd);+      au_need_clean = true;+    }+    return retval;+  } else {+    assert(ac->lua_cmd != LUA_NOREF);+    Array args = ARRAY_DICT_INIT;+    executor_exec_lua_cb(ac->lua_cmd, ""autocommand"", args, false);+    if (ac->once) {",That's slightly different semantics here ��� with VimL we mark command as removed before executing but here we are marking it as removed after we execute the callback.I think I'm confused how cleanup of aucmds works now.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10842,317410278,2019-08-25T18:48:55Z,src/nvim/channel.c,"@@ -626,8 +626,8 @@ static void channel_process_exit_cb(Process *proc, int status, void *data) {   Channel *chan = data;   if (chan->term) {-    char msg[sizeof(""\r\n[Process exited ]"") + NUMBUFLEN];-    snprintf(msg, sizeof msg, ""\r\n[Process exited %d]"", proc->status);+    char msg[sizeof(""\r\nexit status . Press ENTER to continue."") + NUMBUFLEN];+    snprintf(msg, sizeof msg, ""\r\nExit status %d. Press ENTER to continue."", proc->status);","Yes this was mainly a quick hack to get the ""resonable"" behavior specifically for `:!` working.  I would still like `:terminal` to display a message if the process exited non-zero or by a deadly signal, but maybe this will be possible with a (possibly default) autocmd rather than something hardcoded.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10842,317412132,2019-08-25T19:46:10Z,src/nvim/globals.h,"@@ -844,9 +844,22 @@ EXTERN char_u   *globaldir INIT(= NULL); EXTERN int km_stopsel INIT(= FALSE); EXTERN int km_startsel INIT(= FALSE); +typedef enum {+  kModalNone = 0,  ///< no modal window active+  kModalCmdwin,    ///< cmdline window+  kModalTerminal,  ///< modal terminal (:!)+  KModalUser       ///< window for modal()+} ModalType;+ EXTERN int cedit_key INIT(= -1);     ///< key value of 'cedit' option-EXTERN int cmdwin_type INIT(= 0);    ///< type of cmdline window or 0-EXTERN int cmdwin_result INIT(= 0);  ///< result of cmdline window or 0++//EXTERN bool modal_active INIT(= 0); ///< modal window is active+#define modal_active() (modal_type != kModalNone)+#define cmdwin_active() (modal_type == kModalCmdwin)+EXTERN ModalType modal_type INIT(= 0);  ///< type of modal window.+EXTERN int modal_result INIT(= 0);  ///< result of modal window or 0","since ""mode"" is pretty similar to ""modal"", maybe mention ""win"" in these new names. My reflex would be a prefix (`win_modal_active`, `win_cmdwin_active`, `win_modal_result`, `WinModalType`, ...) but I guess the prevalence of `cmdwin_xx` would justify `modalwin_xx` (this also complements `floatwin_xx`).",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10851,317513527,2019-08-26T08:58:45Z,src/nvim/testdir/runnvim.sh,"@@ -16,13 +16,15 @@ main() {(   export NVIM_TEST_ARGC=$#   local arg   local i=0+  # shellcheck disable=SC2034","""unused $arg"" (used in eval)",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10851,317518044,2019-08-26T09:10:07Z,src/nvim/testdir/runnvim.sh,"@@ -16,13 +16,15 @@ main() {(   export NVIM_TEST_ARGC=$#   local arg   local i=0+  # shellcheck disable=SC2034","No, but we can have a comment:> `# shellcheck disable=SC2034  # (unused ""arg"", used in ""eval"").`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10400,317975783,2019-08-27T09:15:47Z,src/nvim/highlight_defs.h,"@@ -146,6 +147,7 @@ EXTERN const char *hlf_names[] INIT(= {   [HLF_INACTIVE] = ""NormalNC"",   [HLF_MSGSEP] = ""MsgSeparator"",   [HLF_NFLOAT] = ""NormalFloat"",+  [HLF_MSG] = ""Message"",","how about `MsgArea`, for parallel with `MsgSeparator`/`ErrorMsg`/etc.  ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10888,319520878,2019-08-30T13:49:52Z,scripts/vim-patch.sh,"@@ -394,6 +394,22 @@ list_missing_vimpatches() {   local token vim_commit vim_tag patch_number   declare -A tokens   declare -A vim_commit_tags+  declare -a git_log_args++  # Massage arguments for git-log.+  declare -A git_log_replacements=(+    [^\(.*/\)?src/nvim/\(.*\)]=""\${BASH_REMATCH[1]}src/\${BASH_REMATCH[2]}""+    [^\(.*/\)?\.vim-src/\(.*\)]=""\${BASH_REMATCH[2]}""+  )+  for i in ""$@""; do+    for j in ""${!git_log_replacements[@]}""; do+      if [[ ""$i"" =~ $j ]]; then+        eval ""git_log_args+=(${git_log_replacements[$j]})""+        continue 2+      fi+    done+    git_log_args+=(""$i"")+  done","Yes, in theory.  But given that it changes an array it would need to set it in the function then, with the `local` before the call to it (a pattern you did not like the last time).Not sure though that it is worth it in general though - I think a code block with a comment on top is good enough.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10904,319768070,2019-09-01T17:14:01Z,runtime/pack/dist/opt/termdebug/plugin/termdebug.vim,"@@ -687,7 +687,7 @@ function! s:OpenHoverPreview(lines, filetype) abort             \   'height': height,             \ })","try adding `'style': 'minimal',` to the `nvim_open_win` ""config"" parameter. Then the `nvim_win_set_option` calls below aren't needed.```suggestion            \   'style': 'minimal',            \ })```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10910,319807143,2019-09-02T05:03:21Z,src/nvim/api/buffer.c,"@@ -453,6 +453,11 @@ void nvim_buf_set_lines(uint64_t channel_id,   aco_save_T aco;   aucmd_prepbuf(&aco, (buf_T *)buf); +  if (!MODIFIABLE(buf)) {+    api_set_error(err, kErrorTypeException, ""Buffer is not 'modifiable'"");+    goto end;+  }+   if (u_save((linenr_T)(start - 1), (linenr_T)end) == FAIL) {     api_set_error(err, kErrorTypeException, ""Failed to save undo information"");","Yes, I intentionally chose something that mentions ""buffer"". Anyways, API messages in general need to be revisited. 1. it would be nice to avoid duplicate validation when the editor already handles it (EXX messages)2. there should be more consistency/uniformity/standardization in the API messages 3. a ""validation module"" could avoid lots of redundant code in eval.c and the API",
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/10382,319872007,2019-09-02T09:12:51Z,test/functional/eval/wait_spec.lua,"@@ -0,0 +1,78 @@+local helpers = require('test.functional.helpers')(after_each)+local call = helpers.call+local clear = helpers.clear+local command = helpers.command+local eval = helpers.eval+local eq = helpers.eq+local expect_err = helpers.expect_err+local feed = helpers.feed+local feed_command = helpers.feed_command+local next_msg = helpers.next_msg+local nvim = helpers.nvim+local source = helpers.source++before_each(function()+  clear()+  local channel = nvim('get_api_info')[1]+  nvim('set_var', 'channel', channel)+end)++describe('wait()', function()+  it('waits and returns 0 when condition is satisfied', function()+    source([[+    let g:_awake = 0+    call timer_start(100, { -> nvim_command('let g:_awake = 1') })+    ]])+    eq(0, eval('g:_awake'))+    eq(0, eval('wait(1500, { -> g:_awake })'))+    eq(1, eval('g:_awake'))++    eq(0, eval('wait(0, 1)'))+  end)++  it('returns -1 on timeout', function()+    eq(-1, eval('wait(0, 0)'))+    eq(-1, eval('wait(50, 0)'))+  end)++  it('returns -2 when interrupted', function()+    feed_command('call rpcnotify(g:channel, ""ready"") | '..+                 'call rpcnotify(g:channel, ""wait"", wait(-1, 0))')+    eq({'notification', 'ready', {}}, next_msg())+    feed('<c-c>')+    eq({'notification', 'wait', {-2}}, next_msg())+  end)++  it('returns -3 on error', function()+    command('silent! let ret = wait(-1, ""error"")')+    eq(-3, eval('ret'))+    command('let ret = 0 | silent! let ret = wait(-1, { -> error })')+    eq(-3, eval('ret'))+  end)++  it('evaluates the condition on given interval', function()+    source([[+    function Count()+      let g:counter += 1+      return g:counter+    endfunction+    ]])++    nvim('set_var', 'counter', 0)+    eq(-1, call('wait', 20, 'Count() >= 5'))","> Failure on AppVeyor, timing issue?Weird, seems like it evaluated the condition at least five times in these 20 ms. My assumption here was that it's unlikely that the tests would raise like five events without any interaction, ~maybe increasing that `5` to something large (e.g.: `1000`) here and [there](https://github.com/neovim/neovim/pull/10382/files#diff-40765f886694def3efe2b0bd0ea82cf1R65) will do the trick?~ (Oops, no that misses the point of the test, and the timeout will not be enough in first place)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10914,319922629,2019-09-02T11:41:22Z,test/functional/terminal/scrollback_spec.lua,"@@ -403,12 +403,8 @@ describe(""'scrollback' option"", function()     end      curbufmeths.set_option('scrollback', 0)-    if iswin() then-      feed_data('for /L %I in (1,1,30) do @(echo line%I)\r')-    else-      feed_data('awk ""BEGIN{for(n=1;n<=30;n++) print \\\""line\\\"" n}""\n')-    end-    screen:expect{any='line30                        '}+    feed_data(nvim_dir..""/shell-test REP 31 line\n"")",```suggestion    feed_data(nvim_dir..'/shell-test REP 31 line'..(iswin() and '\r' or '\n'))```,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10914,319962662,2019-09-02T13:39:42Z,test/functional/terminal/scrollback_spec.lua,"@@ -403,12 +403,8 @@ describe(""'scrollback' option"", function()     end      curbufmeths.set_option('scrollback', 0)-    if iswin() then-      feed_data('for /L %I in (1,1,30) do @(echo line%I)\r')-    else-      feed_data('awk ""BEGIN{for(n=1;n<=30;n++) print \\\""line\\\"" n}""\n')-    end-    screen:expect{any='line30                        '}+    feed_data(nvim_dir..""/shell-test REP 31 line\n"")","@justinmk What do you think?There are not many usages of it now, so it's trivial to change, and makes it more sane in general I think.(I've also thought about requiring/supporting a printf pattern there, where %d would be replaced with the count then)",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/10914,319965494,2019-09-02T13:47:26Z,test/functional/terminal/scrollback_spec.lua,"@@ -403,12 +403,8 @@ describe(""'scrollback' option"", function()     end      curbufmeths.set_option('scrollback', 0)-    if iswin() then-      feed_data('for /L %I in (1,1,30) do @(echo line%I)\r')-    else-      feed_data('awk ""BEGIN{for(n=1;n<=30;n++) print \\\""line\\\"" n}""\n')-    end-    screen:expect{any='line30                        '}+    feed_data(nvim_dir..""/shell-test REP 31 line\n"")","Agreed with regard to churn, but we typically have to add/substract 1 currently, and it will become more tests using it in the future (i.e. more churn when changing it later only).A printf would have allowed to not change the expectations in these tests (i.e. less churn there).For simplicity it should require a pattern probably always, and would not use/replace the counter if there is no `%d` then.  For future extension of it it might be useful to explicitly replace `{lnum}`, but that is likely not trivial in C?!",
20467669,abdelhakeem,https://api.github.com/repos/neovim/neovim/pulls/10382,320345492,2019-09-03T15:44:49Z,test/functional/eval/wait_spec.lua,"@@ -0,0 +1,78 @@+local helpers = require('test.functional.helpers')(after_each)+local call = helpers.call+local clear = helpers.clear+local command = helpers.command+local eval = helpers.eval+local eq = helpers.eq+local expect_err = helpers.expect_err+local feed = helpers.feed+local feed_command = helpers.feed_command+local next_msg = helpers.next_msg+local nvim = helpers.nvim+local source = helpers.source++before_each(function()+  clear()+  local channel = nvim('get_api_info')[1]+  nvim('set_var', 'channel', channel)+end)++describe('wait()', function()+  it('waits and returns 0 when condition is satisfied', function()+    source([[+    let g:_awake = 0+    call timer_start(100, { -> nvim_command('let g:_awake = 1') })+    ]])+    eq(0, eval('g:_awake'))+    eq(0, eval('wait(1500, { -> g:_awake })'))+    eq(1, eval('g:_awake'))++    eq(0, eval('wait(0, 1)'))+  end)++  it('returns -1 on timeout', function()+    eq(-1, eval('wait(0, 0)'))+    eq(-1, eval('wait(50, 0)'))+  end)++  it('returns -2 when interrupted', function()+    feed_command('call rpcnotify(g:channel, ""ready"") | '..+                 'call rpcnotify(g:channel, ""wait"", wait(-1, 0))')+    eq({'notification', 'ready', {}}, next_msg())+    feed('<c-c>')+    eq({'notification', 'wait', {-2}}, next_msg())+  end)++  it('returns -3 on error', function()+    command('silent! let ret = wait(-1, ""error"")')+    eq(-3, eval('ret'))+    command('let ret = 0 | silent! let ret = wait(-1, { -> error })')+    eq(-3, eval('ret'))+  end)++  it('evaluates the condition on given interval', function()+    source([[+    function Count()+      let g:counter += 1+      return g:counter+    endfunction+    ]])++    nvim('set_var', 'counter', 0)+    eq(-1, call('wait', 20, 'Count() >= 5'))","I'm unable to reproduce the failure though :|Only with `eq(-1, call('wait', 20, 'Count() >= 2'))`:```INFO  2019-09-03T17:41:50.708 31709 main:564: starting main loopINFO  2019-09-03T17:41:50.710 31709 multiqueue_process_events:154: calling request_event [0x55ac682a3650]INFO  2019-09-03T17:41:50.710 31709 multiqueue_process_events:154: calling request_event [0x55ac682a3650]INFO  2019-09-03T17:41:50.710 31709 multiqueue_process_events:154: calling request_event [0x55ac682a3650]INFO  2019-09-03T17:41:50.711 31709 multiqueue_process_events:154: calling request_event [0x55ac682a3650]INFO  2019-09-03T17:41:50.711 31709 f_wait:10988: evaluating condition: eval_expr_typval(&expr, &argv, 0, &exprval) != OK || tv_get_number_chk(&exprval, &error) || called_emsg || error || got_intINFO  2019-09-03T17:41:50.730 31709 f_wait:10988: evaluating condition: eval_expr_typval(&expr, &argv, 0, &exprval) != OK || tv_get_number_chk(&exprval, &error) || called_emsg || error || got_intWARN  2019-09-03T17:41:50.732 31709 call_set_error:613: RPC: ch 1 was closed by the clientINFO  2019-09-03T17:41:50.732 31709 multiqueue_process_events:154: calling exit_event [0x55ac682a20f0]INFO  2019-09-03T17:41:50.732 31709 process_teardown:144: evaluating condition: kl_empty(loop->children) && multiqueue_empty(loop->events)INFO  2019-09-03T17:41:50.732 31709 multiqueue_process_events:154: calling free_channel_event [0x55ac68140840]INFO  2019-09-03T17:41:50.732 31709 process_teardown:144: evaluating condition: kl_empty(loop->children) && multiqueue_empty(loop->events)INFO  2019-09-03T17:41:50.732 31709 mch_exit:99: Nvim exit: 0```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10926,320692142,2019-09-04T10:45:19Z,test/functional/ui/screen_basic_spec.lua,"@@ -951,6 +951,46 @@ local function screen_tests(linegrid)                                                            |     ]])   end)++  describe('more prompt', function()","I don't think this belong in `screen_basic_spec.lua`. Perhaps a ""pager"" section of `ui/messages_spec.lua` . There will be more pager tests with #10930 .",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,320791138,2019-09-04T14:27:42Z,test/functional/plugin/lsp/structures_spec.lua,"@@ -0,0 +1,174 @@+local helpers = require('test.functional.helpers')(after_each)+local setpos = helpers.funcs.setpos+local getpos = helpers.funcs.getpos+local insert = helpers.insert+local clear = helpers.clear+local command = helpers.command++local funcs = helpers.funcs+local eq = helpers.eq+local dedent = helpers.dedent++describe('structures.lua', function()+  local old_file = dedent([[+  First line of text+  Second line of text+  Third line of text+  Fourth line of text+  ]])++  local current_file = dedent([[+    Line of text 1+    Line of text 2+    Line of text 3]])++  before_each(function()+    clear()+    command('let g:structure_test = v:null')+    insert(old_file)+    command('new')+    insert(current_file)+  end)++  local require_string = ""require('lsp.structures')""","I mentioned in the original PR that we should avoid hyper-granularity in the module hierarchy. Why should anyone need to do `require('lsp. structures'); require('lsp.callbacks'); ...` instead of just `require('lsp')`? It should be one module.We don't need a big complicated object-oriented API.Note: it's fine to have separate `lsp/foo_spec.lua` files for testing different, big concepts. But we don't need separate modules in the implementation.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,320797709,2019-09-04T14:39:17Z,runtime/lua/nvim/meta.lua,"@@ -0,0 +1,51 @@++local meta = {}++---+-- Provide a ""strongly typed"" dictionary in Lua.+--+-- Does not allow insertion or deletion after creation.+-- Only allows retrieval of created keys are allowed.+meta.Enum = {+  new = function(self, map)+    return setmetatable(map, self)+  end,++  __index = function(t, k)+    error(""attempt to get unknown enum "" .. k .. ""from "" .. tostring(t), 2)+  end,++  __newindex = function(t, k, v)+    error(+      string.format(""attempt to update enum table with %s, %s, %s"", t, k, v),+      2)+  end+}++---+-- Provide a dictionary that will continue providing empty dictionaries upon access.+--+-- This allows you to do something like:+--  local myEmpty =- meta.EmptyDictionary({a = 'b'})+--  if myEmpty.b.a.c.d.e.f.g.i == nil then+--      // Do some error stuff here+--  end+meta.EmptyDictionary = {","In python this is called `defaultdict`. It should be called `defaultmap`,  ""dictionary"" is too verbose, and in  existing Lua code we already mention ""map-like"" or ""list-like"" tables, so ""dictionary"" is new, unnecessary jargon.More generally I don't see `EmptyDictionary` features being used anywhere, so it is like a hidden ""feature"" that will have surprising behavior. We are introducing lots of new concepts/classes in this PR that should be done in separate PRs (or never). We should use ""plain Lua"" as much as possible, we should not introduce lots of new classes and object hierarchy.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,320811201,2019-09-04T15:02:52Z,runtime/lua/uri.lua,"@@ -0,0 +1,123 @@+--- TODO: This is implemented only for files now.+-- https://tools.ietf.org/html/rfc3986+-- https://tools.ietf.org/html/rfc2732+-- https://tools.ietf.org/html/rfc2396++local URI = {}++URI.__index = URI+URI.new = function(scheme, authority, path, query, fragment)+  local obj = setmetatable({+      scheme = scheme,+      authority = authority,+      path = path,+      query = query,+      fragment = fragment,+    }, URI)","This could just be a map-like table, not a class.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,320817203,2019-09-04T15:13:33Z,runtime/lua/nvim/util.lua,"@@ -0,0 +1,113 @@+local util = {+  quickfix = {},+}++util.tostring = function(obj)+  local stringified = ''+  if type(obj) == 'table' then+    stringified = stringified .. '{'+    for k, v in pairs(obj) do+      stringified = stringified .. util.tostring(k) .. '=' .. util.tostring(v) .. ','+    end+    stringified = stringified .. '}'+  else+    stringified = tostring(obj)+  end++  return stringified+end++util.handle_uri = function(uri)+  local file_prefix = 'file://'+  if string.sub(uri, 1, #file_prefix) == file_prefix then+    return string.sub(uri, #file_prefix + 1, #uri)+  end++  return uri+end++-- Determine whether a Lua table can be treated as an array.+-- Returns:+--  true    A non-empty array+--  false   A non-empty table+--  nil     An empty table+util.is_array = function(table)","This could live in `vim.lua`, rename to `vim.tbl_islist`. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10915,321027703,2019-09-05T00:09:45Z,test/functional/ui/wildmode_spec.lua,"@@ -98,8 +98,8 @@ describe(""'wildmenu'"", function()     ]]}      -- cmdline CTRL-D display should also be preserved.-    feed([[<C-\><C-N>]])-    feed([[:sign <C-D>]])   -- Invoke cmdline CTRL-D.+    feed([[<C-U>]])+    feed([[sign <C-D>]])   -- Invoke cmdline CTRL-D.     expect_stay_unchanged{grid=[[","[still failing](https://travis-ci.org/neovim/neovim/builds/580949539), although now it's the one before this (line 92). It's simply a race, we should probably use `any=...` combined with `screen: expect_unchanged()`. Next attempt: https://github.com/neovim/neovim/pull/10947```[  ERROR   ] test/functional/ui/wildmode_spec.lua @ 84: 'wildmenu' is preserved during :terminal activitytest/functional/ui/screen.lua:587: Row 1 did not match.Expected:  |*                         |  |                         |  |                         |  |define  jump  list  >    |  |:sign define^             |Actual:  |*0: !terminal_output!     |  |                         |  |                         |  |define  jump  list  >    |  |:sign define^             |To print the expect() call that would assert the current screen state, usescreen:snapshot_util(). In case of non-deterministic failures, usescreen:redraw_debug() to show all intermediate screen states.  stack traceback:	test/functional/ui/screen.lua:587: in function '_wait'	test/functional/ui/screen.lua:370: in function 'expect'	test/functional/ui/wildmode_spec.lua:22: in function 'expect_stay_unchanged'	test/functional/ui/wildmode_spec.lua:92: in function <test/functional/ui/wildmode_spec.lua:84>```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,321547960,2019-09-06T01:43:23Z,runtime/lua/uri.lua,"@@ -0,0 +1,123 @@+--- TODO: This is implemented only for files now.+-- https://tools.ietf.org/html/rfc3986+-- https://tools.ietf.org/html/rfc2732+-- https://tools.ietf.org/html/rfc2396++local URI = {}++URI.__index = URI+URI.new = function(scheme, authority, path, query, fragment)+  local obj = setmetatable({+      scheme = scheme,+      authority = authority,+      path = path,+      query = query,+      fragment = fragment,+    }, URI)+  return obj+end++URI.tostring = function(self)+  local res = ''+  local scheme = self.scheme+  local authority = self.authority+  local path = self.path++  res = res..scheme..':'++  if authority or scheme == 'file'then+    if URI.is_windows_filepath(path) then+      res = res..'///'+    else+      res = res..'//'+    end+  end++  return res..path+end++URI.from_filepath = function(path)","I mean `src/nvim/lua/vim.lua`, but `runtime/lua/vim/shared.lua` is fine as well. (The purpose of each is explained at [the top of vim.lua](https://github.com/neovim/neovim/blob/master/src/nvim/lua/vim.lua#L3-L7).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,321566433,2019-09-06T03:48:34Z,runtime/lua/uri.lua,"@@ -0,0 +1,123 @@+--- TODO: This is implemented only for files now.+-- https://tools.ietf.org/html/rfc3986+-- https://tools.ietf.org/html/rfc2732+-- https://tools.ietf.org/html/rfc2396++local URI = {}++URI.__index = URI+URI.new = function(scheme, authority, path, query, fragment)+  local obj = setmetatable({+      scheme = scheme,+      authority = authority,+      path = path,+      query = query,+      fragment = fragment,+    }, URI)+  return obj+end++URI.tostring = function(self)+  local res = ''+  local scheme = self.scheme+  local authority = self.authority+  local path = self.path++  res = res..scheme..':'++  if authority or scheme == 'file'then+    if URI.is_windows_filepath(path) then+      res = res..'///'+    else+      res = res..'//'+    end+  end++  return res..path+end++URI.from_filepath = function(path)","People waste time deciding which modules should have which functions, and in the end it doesn't help anything. Everything in `:help eval.txt` is in ""one module"", and it wouldn't help anything if they were spread around in 20 different modules. This applies to pretty much every project. It is _easier_ to find functions if you only need to search one file. Searching 20 files is more difficult than searching 1 file.Ruby people tend to be obsessed with this because that's what DDH did in Rails.Also, the tendency for these modules to become ""classes"" is another sign that this is a ""solution in search of a problem"". People start making classes out of everything instead of passing tables (dicts/maps) around, which means now we need special functions for printing the classes, iterating their properties, etc.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10960,321869713,2019-09-06T19:00:31Z,runtime/syntax/2html.vim,"@@ -1570,7 +1570,7 @@ while s:lnum <= s:end 	if s:settings.expand_tabs 	  let s:offset = 0 	  let s:idx = stridx(s:expandedtab, ""\t"")-	  let s:tablist = split(&vts,',')+	  let s:tablist = exists(""&vts"") ? split(&vts,',') : []","```suggestion	  let s:tablist = exists('+vts') ? split(&vts,',') : []```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10222,321989501,2019-09-08T02:38:27Z,runtime/lua/vim/lsp/builtin_callbacks.lua,"@@ -214,14 +214,16 @@ BuiltinCallbacks['textDocument/hover'] = {         end       -- string       else-        table.insert(contents, data.contents)+        for _, line in pairs(vim.api.nvim_call_function('split', { data.contents, '\\n' })) do+          table.insert(contents, line)",could use `:help vim.split()`. I also plan to make `tbl_extend()` work with list-like tables.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10905,322538262,2019-09-10T03:27:11Z,src/nvim/eval.c,"@@ -22796,6 +22886,23 @@ void call_user_func(ufunc_T *fp, int argcount, typval_T *argvars,       if (islambda) {         addlocal = true;       }++      // evaluate named argument default expression+      isdefault = ai + fp->uf_def_args.ga_len >= 0+        && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL+                              && argvars[i].vval.v_number == kSpecialVarNull));","We do not want `v:none` in any form. It is useless, and only exists to provide ""loose"" JSON in Vim, whereas the Nvim JSON parser only supports valid JSON.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10984,322545994,2019-09-10T04:16:56Z,src/nvim/eval.c,"@@ -12393,36 +12393,40 @@ static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr) }  // ""jobstop()"" function-static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)+// Returns 0, or -1 on error+static int f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   rettv->v_type = VAR_NUMBER;   rettv->vval.v_number = 0; +  int status = 0;  // zero or negative error code+   if (check_restricted() || check_secure()) {-    return;+    return status;   }    if (argvars[0].v_type != VAR_NUMBER) {     // Only argument is the job id     EMSG(_(e_invarg));-    return;+    return status;   }    Channel *data = find_job(argvars[0].vval.v_number, true);   if (!data) {-    return;+    return status;   }    const char *error = NULL;   if (data->is_rpc) {     // Ignore return code, but show error later.-    (void)channel_close(data->id, kChannelPartRpc, &error);+    if (channel_close(data->id, kChannelPartRpc, NULL) == false)) {+      status = -1;+    }   }   process_stop((Process *)&data->stream.proc);   rettv->vval.v_number = 1;-  if (error) {-    EMSG(error);-  }++  return status;","`f_xx` functions are VimL functions (`:help eval.txt`). They return things in the `rettv` out-parameter, so your change isn't going to have any effect. See other functions for examples. Try out your changes by `:echo jobstop()` after building. (Or better, write a test in `job_spec.lua`. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10986,322574419,2019-09-10T06:42:09Z,src/nvim/window.c,"@@ -969,8 +969,8 @@ bool parse_float_config(Dictionary config, FloatConfig *fconfig, bool reconf,   }    if (has_relative != has_row || has_row != has_col) {-    api_set_error(err, kErrorTypeValidation, ""All of 'relative', 'row', and ""-                  ""'col' has to be specified at once"");+    api_set_error(err, kErrorTypeValidation,+                  ""'relative' requires 'row'/'col' or 'bufpos'"");","Changed error message. Could be argued that ""bufpos"" is not actually required since technically it sets a default row/col, but that seems pedantic from a user perspective.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10382,323050619,2019-09-11T03:59:41Z,test/functional/eval/wait_spec.lua,"@@ -0,0 +1,78 @@+local helpers = require('test.functional.helpers')(after_each)+local call = helpers.call+local clear = helpers.clear+local command = helpers.command+local eval = helpers.eval+local eq = helpers.eq+local expect_err = helpers.expect_err+local feed = helpers.feed+local feed_command = helpers.feed_command+local next_msg = helpers.next_msg+local nvim = helpers.nvim+local source = helpers.source++before_each(function()+  clear()+  local channel = nvim('get_api_info')[1]+  nvim('set_var', 'channel', channel)+end)++describe('wait()', function()+  it('waits and returns 0 when condition is satisfied', function()+    source([[+    let g:_awake = 0+    call timer_start(100, { -> nvim_command('let g:_awake = 1') })+    ]])+    eq(0, eval('g:_awake'))+    eq(0, eval('wait(1500, { -> g:_awake })'))+    eq(1, eval('g:_awake'))++    eq(0, eval('wait(0, 1)'))+  end)++  it('returns -1 on timeout', function()+    eq(-1, eval('wait(0, 0)'))+    eq(-1, eval('wait(50, 0)'))+  end)++  it('returns -2 when interrupted', function()+    feed_command('call rpcnotify(g:channel, ""ready"") | '..+                 'call rpcnotify(g:channel, ""wait"", wait(-1, 0))')+    eq({'notification', 'ready', {}}, next_msg())+    feed('<c-c>')+    eq({'notification', 'wait', {-2}}, next_msg())+  end)++  it('returns -3 on error', function()+    command('silent! let ret = wait(-1, ""error"")')+    eq(-3, eval('ret'))+    command('let ret = 0 | silent! let ret = wait(-1, { -> error })')+    eq(-3, eval('ret'))+  end)++  it('evaluates the condition on given interval', function()+    source([[+    function Count()+      let g:counter += 1+      return g:counter+    endfunction+    ]])++    nvim('set_var', 'counter', 0)+    eq(-1, call('wait', 20, 'Count() >= 5'))","> > Failure on AppVeyor, timing issue?> > Weird, seems like it evaluated the condition at least five times in these 20 ms. My assumption here was that it's unlikely that the tests would raise like five events without any interaction, ~maybe increasing that `5` to something large (e.g.: `1000`) here and [there](https://github.com/neovim/neovim/pull/10382/files#diff-40765f886694def3efe2b0bd0ea82cf1R65) will do the trick?~ (Oops, no that misses the point of the test, and the timeout will not be enough in first place)I don't see why it misses the point of the tests?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10959,323118966,2019-09-11T08:30:52Z,src/nvim/ui.h,"@@ -66,4 +66,7 @@ struct ui_t { # include ""ui.h.generated.h"" # include ""ui_events_call.h.generated.h"" #endif+++EXTERN MultiQueue *resize_events;","`EXTERN` is the standard pattern used by `global.h` and some other places for globals. It is only strictly required together with `INIT()`, but I guess it is good to be consistent (""any global declared in a .h file is marked with EXTERN"").",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10984,323554671,2019-09-12T04:50:26Z,src/nvim/eval.c,"@@ -12419,10 +12419,7 @@ static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)     (void)channel_close(data->id, kChannelPartRpc, &error);   }   process_stop((Process *)&data->stream.proc);-  rettv->vval.v_number = 1;-  if (error) {-    EMSG(error);-  }+  rettv->vval.v_number = error == NULL ? 0 : 1;",still needs to return the exit status? That would be in `data->stream.proc.status` or something like that.,
52710349,dexterfhy,https://api.github.com/repos/neovim/neovim/pulls/10984,323608966,2019-09-12T08:10:58Z,src/nvim/eval.c,"@@ -12419,10 +12419,7 @@ static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)     (void)channel_close(data->id, kChannelPartRpc, &error);   }   process_stop((Process *)&data->stream.proc);-  rettv->vval.v_number = 1;-  if (error) {-    EMSG(error);-  }+  rettv->vval.v_number = error == NULL ? 0 : 1;","Oh sorry, I thought `rettv->vval.vnumber` was the status to be returned. ) I'm clearly over my head on this, thanks for being patient with me.Are you suggesting that `data->stream.proc.status` ought to be set to a certain value (and what value would that be for eg)? ",
52710349,dexterfhy,https://api.github.com/repos/neovim/neovim/pulls/10984,323609330,2019-09-12T08:11:56Z,test/functional/core/job_spec.lua,"@@ -875,6 +875,13 @@ describe('jobs', function()     end)   end) +  it('jobstop fails silently and returns exit status', function()+    nvim('command', ""let j = jobstart(['cat'], {'rpc': v:true})"")+    neq(0, eval('j'))+    nvim('command', ""let h = jobstop(j)"")+    eq(0, eval('h'))","Hmm, I changed it so that it tests the exception msg returned from `exc_exec('let h = jobstop(j)')` instead.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10984,323945697,2019-09-12T20:56:56Z,test/functional/core/job_spec.lua,"@@ -875,6 +875,13 @@ describe('jobs', function()     end)   end) +  it('jobstop fails silently and returns exit status', function()+    nvim('command', ""let j = jobstart(['cat'], {'rpc': v:true})"")+    neq(0, eval('j'))+    nvim('command', ""let h = jobstop(j)"")+    eq(0, eval('h'))","Why? The test will fail correctly if any exception/error is done, so there is no need to use exc_exec.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10984,323946227,2019-09-12T20:58:16Z,src/nvim/eval.c,"@@ -12419,10 +12419,7 @@ static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)     (void)channel_close(data->id, kChannelPartRpc, &error);   }   process_stop((Process *)&data->stream.proc);-  rettv->vval.v_number = 1;-  if (error) {-    EMSG(error);-  }+  rettv->vval.v_number = error == NULL ? 0 : 1;","I am suggesting     rettv->vval.v_number = error == NULL ? 0 : data->stream.proc.status;because that matches the semantics of your test case description (correct me if wrong):    jobstop fails silently and returns exit statusThus `0` means ""success"" and non-zero means ""failed with this exit code"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10971,323971997,2019-09-12T22:17:16Z,src/nvim/eval.c,"@@ -17593,6 +17593,8 @@ static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)     case 's': {       if (TOLOWER_ASC(what[1]) == 'p') {  // sp[#]         p = highlight_color(id, what, modec);+      } else if (TOLOWER_ASC(what[2]) == 'r') {  // strikethrough+        p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);",Would be worth having a test for this. There is a synIDattr() test in: https://github.com/neovim/neovim/blob/b78be5bd0843/test/functional/terminal/highlight_spec.lua#L211,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10753,324384821,2019-09-13T22:12:32Z,src/nvim/main.c,"@@ -1217,6 +1217,11 @@ static void command_line_scan(mparm_T *parmp)     }   } +  if (embedded_mode && exmode_active && silent_mode) {+    mch_errmsg(_(""Error: flags -es and -Es are incompatible with --embed.\n""));+    mch_exit(2);","- ""Error:"" prefix is not consistent with existing startup failure messages, cf. https://github.com/neovim/neovim/blob/3afb397407af/src/nvim/main.c#L136-L142-  other messages use the term ""arguments"", not ""flags"".- `mainerr()` should be used.- I don't think `exmode_active` needs to be checked, `silent_mode` is enough.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/9468,325245999,2019-09-17T15:46:20Z,runtime/autoload/health/provider.vim,"@@ -258,71 +258,56 @@ function! s:check_python(version) abort   call health#report_start('Python ' . a:version . ' provider (optional)')    let pyname = 'python'.(a:version == 2 ? '' : '3')-  let pyenv = resolve(exepath('pyenv'))-  let pyenv_root = exists('$PYENV_ROOT') ? resolve($PYENV_ROOT) : ''+  let python_exe = ''   let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''   let host_prog_var = pyname.'_host_prog'   let loaded_var = 'g:loaded_'.pyname.'_provider'-  let python_bin = ''","FWIW: I would also have liked to not have this renaming while investigating changes around that code.While you can ignore it in reviews, it shows up in blames still.. ;)",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11067,326753262,2019-09-20T18:32:49Z,src/nvim/tui/tui.c,"@@ -374,6 +375,14 @@ static void tui_terminal_stop(UI *ui)     ui->data = NULL;  // Flag UI as ""stopped"".     return;   }++  // Wait for terminal response for background.+  int maxwait = 20;  // 1s.+  while (data->input.waiting_for_bg_response && maxwait > 0) {+    maxwait -= 1;+    loop_poll_events(data->loop, 50);+  }",Could also use a single timeout maybe?  But I was not sure what happens with more data being available etc.,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11050,326882486,2019-09-22T04:27:34Z,src/nvim/os/env.c,"@@ -135,7 +135,20 @@ int os_setenv(const char *name, const char *value, int overwrite)   } #endif   uv_mutex_lock(&mutex);-  int r = uv_os_setenv(name, value);+  int r;+#ifdef WIN32+  // LC_ALL, LANG, LANGUAGE and LC_MESSAGES must be obtained using getenv()+  // in libintl, so we must use _putenv_s().","> Would it make sense to do both? I.e. _putenv_s and uv_os_setenv.I do not think so. This problem occurs because the value written by `SetEnvironmentVariable()` cannot be read by `getenv()`. But the values ������set with `putenv()`, `_putenv()` and `_putenv_s()` can be obtained with `GetEnvironmentVariable()`. So calling both will be useless.I think there are other following solutions to this problem:- Use `_wputenv_s()` and `_wgetenv_s()` instead of `uv_os_getenv()` and `uv_os_setenv()`.- Apply a patch to the library(`libintl` etc) that uses `getenv()`, Change to use `GetEnvironmentVariable()`.- I don't know if I can do it, but we rewrite `IAT` and replace `getenv()` itself with a function provided by neovim.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10124,326920382,2019-09-22T21:27:01Z,ci/build.ps1,"@@ -94,6 +94,28 @@ npm.cmd install -g neovim Get-Command -CommandType Application neovim-node-host.cmd npm.cmd link neovim +#npm.cmd install -g tree-sitter-cli+#npm.cmd link tree-sitter-cli++mkdir c:\treesitter+$env:TREE_SITTER_DIR = ""c:\treesitter""+#$env:PATH = ""c:\treesitter;$env:PATH""+$client = new-object System.Net.WebClient+cd c:\treesitter","creating things in root (`c:\`) is bad practice and might not work on non-CI machines (depending on user permissions). Although build.ps1 isn't fully usable for non-CI (yet), would be good to avoid making it less so. Could use `build/` or `.deps/` .",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10124,326921599,2019-09-22T22:02:35Z,ci/install.sh,"@@ -24,3 +24,23 @@ gem install --no-document --version "">= 0.8.0"" neovim echo ""Install neovim npm package"" npm install -g neovim npm link neovim++echo ""Install tree-sitter npm package""+npm install -g tree-sitter-cli+npm link tree-sitter-cli++echo ""Install tree-sitter c parser""+curl ""https://codeload.github.com/tree-sitter/tree-sitter-c/tar.gz/v0.15.0"" -o tree_sitter_c.tar.gz+tar xf tree_sitter_c.tar.gz+cd tree-sitter-c-0.15.0+export TREE_SITTER_DIR=$HOME/tree-sitter-build/+mkdir -p $TREE_SITTER_DIR/bin++if [[ ""$BUILD_32BIT"" != ""ON"" ]]; then+  # builds c parser in $HOME/tree-sitter-build/bin/c.(so|dylib)+  tree-sitter test+else+  # no tree-sitter binary for 32bit linux, so fake it (no tree-sitter unit tests)+  cd src/+  gcc -m32 -o $TREE_SITTER_DIR/bin/c.so -shared parser.c -I.+fi","The rest of the code does not use functions (including python setup and other specific sections which are substantially longer). So I do not know what style or naming convention such a function should use, or what the arguments would be etc. I just wrote code that did the necessary setup here, restructuring the ci setup code seems like a separate PR to me.",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10124,326921891,2019-09-22T22:10:37Z,ci/install.sh,"@@ -24,3 +24,23 @@ gem install --no-document --version "">= 0.8.0"" neovim echo ""Install neovim npm package"" npm install -g neovim npm link neovim++echo ""Install tree-sitter npm package""+npm install -g tree-sitter-cli+npm link tree-sitter-cli++echo ""Install tree-sitter c parser""+curl ""https://codeload.github.com/tree-sitter/tree-sitter-c/tar.gz/v0.15.0"" -o tree_sitter_c.tar.gz+tar xf tree_sitter_c.tar.gz+cd tree-sitter-c-0.15.0+export TREE_SITTER_DIR=$HOME/tree-sitter-build/+mkdir -p $TREE_SITTER_DIR/bin++if [[ ""$BUILD_32BIT"" != ""ON"" ]]; then+  # builds c parser in $HOME/tree-sitter-build/bin/c.(so|dylib)+  tree-sitter test+else+  # no tree-sitter binary for 32bit linux, so fake it (no tree-sitter unit tests)+  cd src/+  gcc -m32 -o $TREE_SITTER_DIR/bin/c.so -shared parser.c -I.+fi",[common/build.sh](https://github.com/neovim/neovim/blob/a7a747ef6948e902929b7bbde4d2140654e73824/ci/common/build.sh) might be a good place.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10124,326923491,2019-09-22T22:54:11Z,runtime/lua/vim/treesitter.lua,"@@ -0,0 +1,73 @@+local a = vim.api++local Parser = {}+Parser.__index = Parser++-- TODO(bfredl): currently we retain parsers for the lifetime of the buffer.+-- Consider use weak references to release parser if all plugins are done with+-- it.+local parsers = {}++function Parser:parse()+  if self.valid then+    return self.tree+  end+  self.tree = self._parser:parse_buf(self.bufnr)+  self.valid = true+  return self.tree+end++local function on_lines(self, bufnr, _, start_row, old_stop_row, stop_row, old_byte_size)+  local start_byte = a.nvim_buf_get_offset(bufnr,start_row)+  local stop_byte = a.nvim_buf_get_offset(bufnr,stop_row)+  local old_stop_byte = start_byte + old_byte_size+  self._parser:edit(start_byte,old_stop_byte,stop_byte,+                    start_row,0,old_stop_row,0,stop_row,0)+  self.valid = false+end++local function create_parser(bufnr, ft, id)+  if bufnr == 0 then+    bufnr = a.nvim_get_current_buf()+  end+  local self = setmetatable({bufnr=bufnr, valid=false}, Parser)+  self._parser = vim._create_ts_parser(ft)+  self:parse()+    -- TODO: use weakref to self, so that the parser is free'd is no plugin is+    -- using it.+  local function lines_cb(_, ...)+    return on_lines(self, ...)+  end+  local detach_cb = nil+  if id ~= nil then+    detach_cb = function()+      if parsers[id] == self then+        parsers[id] = nil+      end+    end+  end+  a.nvim_buf_attach(self.bufnr, false, {on_lines=lines_cb, on_detach=detach_cb})+  return self+end++local function get_parser(bufnr, ft)+  if bufnr == nil or bufnr == 0 then+    bufnr = a.nvim_get_current_buf()+  end+  if ft == nil then+    ft = a.nvim_buf_get_option(bufnr, ""filetype"")+  end+  local id = tostring(bufnr)..'_'..ft++  if parsers[id] == nil then+    parsers[id] = create_parser(bufnr, ft, id)+  end+  return parsers[id]+end++return {+  get_parser=get_parser,+  create_parser=create_parser,+  add_language=vim._ts_add_language,+  inspect_language=vim._ts_inspect_language,+}",nit: could use the module pattern instead  e4bd31dbaceefd21932b96f11e7f555d607ffd49 .,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11101,328546993,2019-09-26T10:26:09Z,src/nvim/screen.c,"@@ -2403,10 +2403,10 @@ win_line (   filler_todo = filler_lines;    // Cursor line highlighting for 'cursorline' in the current window.-  if (wp->w_p_cul && lnum == wp->w_cursor.lnum) {+  if (lnum == wp->w_cursor.lnum && win_cursorline_standout(wp)) {","Perhaps we can just update `wp->w_last_cursorline` unconditionally, I don't think anything is positively gained by keeping around the stale value even with no ""standout"" features active.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11101,328980181,2019-09-27T09:08:12Z,src/nvim/normal.c,"@@ -1236,8 +1236,9 @@ static void normal_redraw(NormalState *s)    // If the cursor moves horizontally when 'concealcursor' is active, then the   // current line needs to be redrawn in order to calculate the correct-  // cursor position.+  // cursor position.  The last line needs to be redrawn to prevent artifacts.   if (curwin->w_p_cole > 0 && conceal_cursor_line(curwin)) {+    redrawWinline(curwin, curwin->w_last_cursorline);","Does it reproduce for you with the instructions in an `xterm`? I would help to debug the missing condition, but I cannot see the glitch to start with...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11117,329334811,2019-09-29T02:32:29Z,scripts/build/update_version_stamp.lua,"@@ -0,0 +1,42 @@+#!/usr/bin/env lua+--+-- Helper script to update Git version stamp.",? It's a script that takes parameters. No one will be confused.,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11117,329334958,2019-09-29T02:38:27Z,scripts/build/update_version_stamp.lua,"@@ -0,0 +1,42 @@+#!/usr/bin/env lua+--+-- Helper script to update Git version stamp.","It is just similar to putting it in ""builds"" vs having it in ""scripts"" directly.. there are scripts that are meant to be run by users directly, and others which are run from the build.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11121,329370717,2019-09-29T21:03:40Z,runtime/doc/options.txt,"@@ -4583,6 +4583,14 @@ A jump table for the options with a short description can be found at |Q_op|. 		RedrawDebugRecompose guibg=Red    redraw generated by the 						  compositor itself, due to a 						  grid being moved or deleted.+	    nothrottle	Turn off throttling of the message grid. This is an+			optimization that joins many small scrolls to one+			larger scroll when drawing the message area (with+			'display' msgsep flag active).+	    invalid	Enable stricter checking (abort) of inconsistencies+			of the internal screen state. This is mosly+			useful when running nvim inside a debugger (and+			the test suite).","How about renaming 'redrawdebug' to 'debugredraw' (I assume you don't want to cram it into the existing 'debug' option, but at least all debug options could have the same ""debug"" prefix).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11129,329893643,2019-10-01T06:21:21Z,test/functional/terminal/tui_spec.lua,"@@ -1359,7 +1359,7 @@ describe('TUI background color', function()      -- Wait for the child Nvim to register the OptionSet handler.     feed_data('\027:autocmd OptionSet\n')-    screen:expect({any='--- Autocommands ---'})+    screen:expect({any='              echo ""did OptionSet, yay!""'}) ",I don't see how this helps anything. And it makes line 1361 useless...,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11151,331343677,2019-10-04T05:17:21Z,src/nvim/os/env.c,"@@ -67,22 +68,23 @@ const char *os_getenv(const char *name)     pmap_del2(envmap, name);   }   e = xmalloc(size);-  int r = uv_os_getenv(name, e, &size);+  r = uv_os_getenv(name, e, &size);   if (r == UV_ENOBUFS) {     e = xrealloc(e, size);     r = uv_os_getenv(name, e, &size);   }   if (r != 0 || size == 0 || e[0] == '\0') {     xfree(e);     e = NULL;-    if (r != 0 && r != UV_ENOENT && r != UV_UNKNOWN) {-      ELOG(""uv_os_getenv(%s) failed: %d %s"", name, r, uv_err_name(r));-    }     goto end;   }   pmap_put(cstr_t)(envmap, xstrdup(name), e); end:+  // Must do this before ELOG, log.c may call os_setenv.   uv_mutex_unlock(&mutex);+  if (r != 0 && r != UV_ENOENT && r != UV_UNKNOWN) {+    ELOG(""uv_os_getenv(%s) failed: %d %s"", name, r, uv_err_name(r));+  }   return (e == NULL || size == 0 || e[0] == '\0') ? NULL : e;",@justinmk Is this condition necessary? I think good with `return e;`.,
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/11113,331662296,2019-10-04T19:54:42Z,src/nvim/lua/treesitter.c,"@@ -782,3 +784,63 @@ static int query_tostring(lua_State *L)   lua_pushstring(L, ""<query>"");   return 1; }++static int query_inspect(lua_State *L)+{+  TSQuery *query = query_check(L, 1);+  if (!query) {+    return 0;+  }++  uint32_t n_pat = ts_query_pattern_count(query);+  lua_createtable(L, 0, 2); // [retval]+  lua_createtable(L, n_pat, 1); // [retval, patterns]+  for (size_t i = 0; i < n_pat; i++) {+    uint32_t len;+    const TSQueryPredicateStep *step = ts_query_predicates_for_pattern(query,+                                                                       i, &len);+    if (len == 0) {+      continue;+    }+    lua_createtable(L, len/4, 1);  // [retval, patterns, pat]+    lua_createtable(L, 3, 0);  // [retval, patterns, pat, pred]+    int nextpred = 1;+    int nextitem = 1;+    for (size_t k = 0; k < len; k++) {+      if (step[k].type == TSQueryPredicateStepTypeDone) {+        lua_rawseti(L, -2, nextpred++);  // [retval, patterns, pat]+        lua_createtable(L, 3, 0);  // [retval, patterns, pat, pred]+        nextitem = 1;+        continue;+      }++      if (step[k].type == TSQueryPredicateStepTypeString) {+        uint32_t strlen;+        const char *str = ts_query_string_value_for_id(query, step[k].value_id,+                                                       &strlen);+        lua_pushlstring(L, str, strlen);  // [retval, patterns, pat, pred, item]+      } else if (step[k].type == TSQueryPredicateStepTypeCapture) {+        lua_pushnumber(L, step[k].value_id+1);  // [retval, patterns, pat, pred, item]+      } else {+        abort();+      }+      lua_rawseti(L, -2, nextitem++);  // [retval, patterns, pat, pred]+    }+    // TODO: assumes last predicate ends with done???","One idea: I think this can be answered by whether the underlying parsing call is asynchronous or not. I had a look at `ts_query_parse_pattern` and it doesn't seem like it is, i.e. the function only releases control when the whole stream has been parsed. If that's correct then it can't be doing anything else at the time the call completes, therefore it's done and should end with done and/or error depending on the parser's definition.",
326587,maxbrunsfeld,https://api.github.com/repos/neovim/neovim/pulls/11113,331669404,2019-10-04T20:17:17Z,src/nvim/lua/treesitter.c,"@@ -782,3 +784,63 @@ static int query_tostring(lua_State *L)   lua_pushstring(L, ""<query>"");   return 1; }++static int query_inspect(lua_State *L)+{+  TSQuery *query = query_check(L, 1);+  if (!query) {+    return 0;+  }++  uint32_t n_pat = ts_query_pattern_count(query);+  lua_createtable(L, 0, 2); // [retval]+  lua_createtable(L, n_pat, 1); // [retval, patterns]+  for (size_t i = 0; i < n_pat; i++) {+    uint32_t len;+    const TSQueryPredicateStep *step = ts_query_predicates_for_pattern(query,+                                                                       i, &len);+    if (len == 0) {+      continue;+    }+    lua_createtable(L, len/4, 1);  // [retval, patterns, pat]+    lua_createtable(L, 3, 0);  // [retval, patterns, pat, pred]+    int nextpred = 1;+    int nextitem = 1;+    for (size_t k = 0; k < len; k++) {+      if (step[k].type == TSQueryPredicateStepTypeDone) {+        lua_rawseti(L, -2, nextpred++);  // [retval, patterns, pat]+        lua_createtable(L, 3, 0);  // [retval, patterns, pat, pred]+        nextitem = 1;+        continue;+      }++      if (step[k].type == TSQueryPredicateStepTypeString) {+        uint32_t strlen;+        const char *str = ts_query_string_value_for_id(query, step[k].value_id,+                                                       &strlen);+        lua_pushlstring(L, str, strlen);  // [retval, patterns, pat, pred, item]+      } else if (step[k].type == TSQueryPredicateStepTypeCapture) {+        lua_pushnumber(L, step[k].value_id+1);  // [retval, patterns, pat, pred, item]+      } else {+        abort();+      }+      lua_rawseti(L, -2, nextitem++);  // [retval, patterns, pat, pred]+    }+    // TODO: assumes last predicate ends with done???","Yeah, as part of tree-sitter/tree-sitter#444, in response to some good feedback from @bfredl, I updated [the docs](https://github.com/tree-sitter/tree-sitter/blob/6b322c5c2839314db0d6e7771f54a4f9419245c3/lib/include/tree_sitter/api.h#L693-L695) to explain this more clearly. Each predicate (including the last one) ends with `TSQueryPredicateStepTypeDone`. The code that does this is [here](https://github.com/tree-sitter/tree-sitter/blob/6b322c5c2839314db0d6e7771f54a4f9419245c3/lib/src/query.c#L422-L426).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/10222,331752034,2019-10-05T16:10:32Z,runtime/lua/vim/lsp/protocol.lua,"@@ -0,0 +1,437 @@+-- Protocol for the Microsoft Language Server Protocol (mslsp)++local util = require('vim.lsp.util')+local server_config = require('vim.lsp.server_config')+local protocol = {}+++protocol.DiagnosticSeverity = {+  [1] = 'Error',+  [2] = 'Warning',+  [3] = 'Information',+  [4] = 'Hint',+}++protocol.MessageType = {+  [1] = 'Error',+  [2] = 'Warning',+  [3] = 'Info',+  [4] = 'Log',+}++protocol.FileChangeType = {+  [1] = 'Created',+  [2] = 'Changed',+  [3] = 'Deleted',+}++protocol.CompletionItemKind = {+  [1] = 'Text',+  [2] = 'Method',+  [3] = 'Function',+  [4] = 'Constructor',+  [5] = 'Field',+  [6] = 'Variable',+  [7] = 'Class',+  [8] = 'Interface',+  [9] = 'Module',+  [10] = 'Property',+  [11] = 'Unit',+  [12] = 'Value',+  [13] = 'Enum',+  [14] = 'Keyword',+  [15] = 'Snippet',+  [16] = 'Color',+  [17] = 'File',+  [18] = 'Reference',+  [19] = 'Folder',+  [20] = 'EnumMember',+  [21] = 'Constant',+  [22] = 'Struct',+  [23] = 'Event',+  [24] = 'Operator',+  [25] = 'TypeParameter',+}++protocol.CompletionTriggerKind = {+  [1] = 'Invoked',+  [2] = 'TriggerCharacter',+}++protocol.DocumentHighlightKind = {+  [1] = 'Text',+  [2] = 'Read',+  [3] = 'Write',+}++protocol.SymbolKind = {+  [1] = 'File',+  [2] = 'Module',+  [3] = 'Namespace',+  [4] = 'Package',+  [5] = 'Class',+  [6] = 'Method',+  [7] = 'Property',+  [8] = 'Field',+  [9] = 'Constructor',+  [10] = 'Enum',+  [11] = 'Interface',+  [12] = 'Function',+  [13] = 'Variable',+  [14] = 'Constant',+  [15] = 'String',+  [16] = 'Number',+  [17] = 'Boolean',+  [18] = 'Array',+}++protocol.errorCodes = {+  -- Defined by JSON RPC+  [-32700] = 'Parse error',+  [-32600] = 'Invalid Request',+  [-32601] = 'Method not found',+  [-32602] = 'Invalid params',+  [-32603] = 'Internal error',+  [-32099] = 'Server Error Start',+  [-32000] = 'Server Error End',+  [-32002] = 'Server Not Initialized',+  [-32001] = 'Unknown Error Code',+  -- Defined by the protocol+  [-32800] = 'Request Cancelled',+}+++protocol.TextDocumentSaveReason = {+  [1] = 'Manual',+  [2] = 'AfterDelay',+  [3] = 'FocusOut',+}++-- Helper functions+local check_table = function (t)+  if type(t) ~= 'table' then","this could implicitly hide type/argument errors. Probably we should just allow converting `nil` (i e no arg) to empty dict, but nothing else. I e check `t == nil` instead.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11165,332332154,2019-10-08T04:31:29Z,test/functional/helpers.lua,"@@ -724,6 +724,10 @@ function module.pathroot()   return iswin() and (module.nvim_dir:sub(1,2)..pathsep) or '/' end +function module.getcwd()+  return os.getenv(""PWD"")","> Sounds good to me - mind if I skip the `eval` and call `getcwd()` itself from the imported functions?Sure, eval() is just me being lazy :)",
8412209,ffanzhang,https://api.github.com/repos/neovim/neovim/pulls/11140,333323884,2019-10-10T04:15:58Z,src/nvim/os/env.c,"@@ -359,8 +372,37 @@ void init_homedir(void)       }     } #endif-    homedir = xstrdup(var);   }++  // As a last resort, return the current working directory+  if (var == NULL && os_dirname((char_u *)os_buf, MAXPATHL) == OK) {+    var = (char *)os_buf;+  }++  set_homedir(var, MAXPATHL);+}++const char *os_homedir(void)+{+    size_t homedir_size = (size_t)MAXPATHL;+    int ret = uv_os_homedir((char *)os_buf, &homedir_size);+    if (ret == 0 && homedir_size > 0) {+        return xstrndup((char *)os_buf, homedir_size);","Looks like freeing memory is a bigger project than expected. Somehow, when I free var (guessed homedir) at the end, I'm failing functional tests. My theory is that var sometimes is pointing at things shared by other pointers.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11140,333484539,2019-10-10T12:16:17Z,src/nvim/os/env.c,"@@ -359,8 +372,37 @@ void init_homedir(void)       }     } #endif-    homedir = xstrdup(var);   }++  // As a last resort, return the current working directory+  if (var == NULL && os_dirname((char_u *)os_buf, MAXPATHL) == OK) {+    var = (char *)os_buf;+  }++  set_homedir(var, MAXPATHL);+}++const char *os_homedir(void)+{+    size_t homedir_size = (size_t)MAXPATHL;+    int ret = uv_os_homedir((char *)os_buf, &homedir_size);+    if (ret == 0 && homedir_size > 0) {+        return xstrndup((char *)os_buf, homedir_size);","My patch was incomplete. After `os_homedir()` is called, we must check `must_free` before assigning to `var` to free the memory, and change `must_free` after assignment.It may be easier to use a new `MAXPATHL` length buffer with auto variables in the following places and return `os_buf` in `os_homedir()`.https://github.com/neovim/neovim/blob/b24dc5a0f236f40783e1bde21d81cdabcb8a10ad/src/nvim/os/env.c#L385-L386",
205673,bobrippling,https://api.github.com/repos/neovim/neovim/pulls/11165,333728823,2019-10-10T20:49:30Z,test/functional/eval/fnamemodify_spec.lua,"@@ -42,14 +51,15 @@ describe('fnamemodify()', function()     local filename = ""src/version.c""     local cwd = getcwd() -    eq(cwd .. '/src/version.c', fnamemodify(filename, ':p'))-    eq('src/version.c', fnamemodify(filename, ':p:.'))-    eq(cwd .. '/src', fnamemodify(filename, ':p:h'))-    eq(cwd .. '', fnamemodify(filename, ':p:h:h'))-    eq('version.c', fnamemodify(filename, ':p:t'))-    eq(cwd .. '/src/version', fnamemodify(filename, ':p:r'))+    eq_slashconvert(cwd .. '/src/version.c', fnamemodify(filename, ':p'))++    eq_slashconvert('src/version.c', fnamemodify(filename, ':p:.'))+    eq_slashconvert(cwd .. '/src', fnamemodify(filename, ':p:h'))+    eq_slashconvert(cwd .. '', fnamemodify(filename, ':p:h:h'))+    eq_slashconvert('version.c', fnamemodify(filename, ':p:t'))+    eq_slashconvert(cwd .. '/src/version', fnamemodify(filename, ':p:r')) -    eq(cwd .. '/src/main.c', fnamemodify(filename, ':s?version?main?:p'))+    eq_slashconvert(cwd .. '/src/main.c', fnamemodify(filename, ':s?version?main?:p'))","Ah of course. Just to check, would you be okay with/are you saying that we can ignore the type of slash for all of these tests? I guess we're primarily testing the path components we end up with and the types of slashes aren't important to us, and would only clutter the test case with `iswin()` checks.I'll push up new tests with this change to kick off the test run - `alter_slashes` is exactly what I wanted, thanks!",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11182,334122597,2019-10-11T18:33:35Z,scripts/vim-patch.sh,"@@ -431,25 +439,43 @@ list_missing_vimpatches() {    # Get missing Vim commits   set +u  # Avoid ""unbound variable"" with bash < 4.4 below.-  for vim_commit in $(list_vim_commits ""${git_log_args[@]}""); do+  local vim_commit subject+  while IFS=' ' read -r line; do     # Check for vim-patch:<commit_hash> (usually runtime updates).-    token=""vim-patch:${vim_commit:0:7}""+    token=""vim-patch:${line:0:7}""     if [[ ""${tokens[$token]-}"" ]]; then       continue     fi +    if [[ ""$extended_format"" == 1 ]]; then+      vim_commit=${line%% *}+      subject=${line#* }+      # Remove ""patch 8.0.0902: "" prefixes.+      subject=""${subject#patch*: }""+    else+      vim_commit=$line+    fi+     vim_tag=""${vim_commit_tags[$vim_commit]-}""     if [[ -n ""$vim_tag"" ]]; then       # Check for vim-patch:<tag> (not commit hash).       patch_number=""vim-patch:${vim_tag:1}"" # ""v7.4.0001"" => ""7.4.0001""       if [[ ""${tokens[$patch_number]-}"" ]]; then         continue       fi-      echo ""$vim_tag""+      if [[ ""$extended_format"" == 1 ]]; then+        printf '%s: %s\n' ""$vim_tag"" ""$subject""+      else+        printf '%s\n' ""$vim_tag""+      fi     else-      echo ""$vim_commit""+      if [[ ""$extended_format"" == 1 ]]; then+        printf '%s: %s\n' ""$vim_commit"" ""$subject""+      else+        printf '%s\n' ""$vim_commit""+      fi     fi-  done+  done < <(list_vim_commits ""${git_log_args[@]}"")","I do not like this to be mangled into the same loop, but it is not too bad either I guess.Ideas?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11207,334254382,2019-10-12T21:43:22Z,scripts/vim-patch.sh,"@@ -85,11 +85,13 @@ clean_files() { get_vim_sources() {   require_executable git +  local update=$1+   if [[ ! -d ${VIM_SOURCE_DIR} ]]; then     echo ""Cloning Vim into: ${VIM_SOURCE_DIR}""     git clone https://github.com/vim/vim.git ""${VIM_SOURCE_DIR}""     cd ""${VIM_SOURCE_DIR}""-  else+  elif [[ ""$update"" == 1 ]]; then","I think ""update"" string is clearer pattern. And it's used elsewhere . ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11184,335877445,2019-10-17T08:40:28Z,test/functional/provider/nodejs_spec.lua,"@@ -6,12 +6,10 @@ local write_file = helpers.write_file local eval = helpers.eval local retry = helpers.retry -do-  clear()-  if missing_provider('node') then-    pending(""Missing nodejs host, or nodejs version is too old."", function()end)-    return-  end+local describe = describe+clear()+if missing_provider('node') then+  describe = function(desc, ...) pending(desc.."" (Missing nodejs host, or nodejs version is too old)"", ...) end","why is this better than the old code? `local describe = describe` is awkward, and in general the new pattern is less obvious/clear.",x
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11248,336754255,2019-10-19T21:19:40Z,test/functional/lua/utility_functions_spec.lua,"@@ -111,6 +111,40 @@ describe('lua stdlib', function()     eq(1, funcs.luaeval('vim.stricmp(""\\0C\\0"", ""\\0B\\0"")'))   end) +  it('vim.startswith', function()+    eq(true, funcs.luaeval('vim.startswith(""123"", ""1"")'))+    eq(true, funcs.luaeval('vim.startswith(""123"", """")'))+    eq(true, funcs.luaeval('vim.startswith(""123"", ""123"")'))+    eq(true, funcs.luaeval('vim.startswith("""", """")'))++    eq(false, funcs.luaeval('vim.startswith(""123"", "" "")'))+    eq(false, funcs.luaeval('vim.startswith(""123"", ""2"")'))+    eq(false, funcs.luaeval('vim.startswith(""123"", ""1234"")'))++		eq(""string"", type(pcall_err(funcs.luaeval, 'vim.startswith(""123"", nil)')))+		eq(""string"", type(pcall_err(funcs.luaeval, 'vim.startswith(nil, ""123"")')))++    eq(true, funcs.luaeval('string.startswith == vim.startswith'))+    eq(true, funcs.luaeval('(""123""):startswith(""123"")'))+  end)++  it('vim.endswith', function()+    eq(true, funcs.luaeval('vim.endswith(""123"", ""3"")'))+    eq(true, funcs.luaeval('vim.endswith(""123"", """")'))+    eq(true, funcs.luaeval('vim.endswith(""123"", ""123"")'))+    eq(true, funcs.luaeval('vim.endswith("""", """")'))++    eq(false, funcs.luaeval('vim.endswith(""123"", "" "")'))+    eq(false, funcs.luaeval('vim.endswith(""123"", ""2"")'))+    eq(false, funcs.luaeval('vim.endswith(""123"", ""1234"")'))++		eq(""string"", type(pcall_err(funcs.luaeval, 'vim.endswith(""123"", nil)')))+		eq(""string"", type(pcall_err(funcs.luaeval, 'vim.endswith(nil, ""123"")')))",spaces instead of tabs. similar case above.,x
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11248,336757307,2019-10-19T23:34:14Z,runtime/lua/vim/shared.lua,"@@ -188,6 +188,31 @@ local function pesc(s)   return s:gsub('[%(%)%.%%%+%-%*%?%[%]%^%$]', '%%%1') end +--- Test if `prefix` is a prefix of `s`+--+-- @tparam string s String to check+-- @tparam string prefix Potential prefix+-- @treturn boolean True if prefix is a prefix of s","> this would've been helpful for my own lua projectsShould be no problem, but it's somewhat hideous. We use the mentioned python script, plus doxygen, plus [this thing](https://github.com/neovim/neovim/blob/master/scripts/lua2dox.lua) which converts these Lua docstrings into something doxygen understands.We decided to avoid [penlight/ldoc](https://github.com/stevedonovan/LDoc) because (1) it's a big dependency, and (2) it still wouldn't help us convert the docstrings to Vim's `:help` format.`scripts/gen_vimdoc.py` consumes doxygen XML and generates `:help` files.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11140,336928281,2019-10-21T09:51:06Z,src/nvim/os/env.c,"@@ -317,10 +325,17 @@ void init_homedir(void)       }     }   }+   if (var == NULL) {     var = os_getenv(""USERPROFILE"");","`uv_os_homedir()` first checks `USERPROFILE` at [line 1133 of src/win/util.c](https://github.com/libuv/libuv/blob/747a0f34d7ed62f78103a444ef657db866dff3fd/src/win/util.c#L1133). Therefore, this can be deleted.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11140,337331040,2019-10-22T05:00:52Z,src/nvim/os/env.c,"@@ -346,21 +354,47 @@ void init_homedir(void)   } #endif -  if (var != NULL) { #ifdef UNIX+  if (var == NULL) {+    var = os_homedir();+  }++  if (var != NULL) {     // Change to the directory and get the actual path.  This resolves     // links.  Don't do it when we can't return.-    if (os_dirname((char_u *)os_buf, MAXPATHL) == OK && os_chdir(os_buf) == 0) {-      if (!os_chdir(var) && os_dirname(IObuff, IOSIZE) == OK) {+    if (os_dirname((char_u *)os_buf, sizeof(os_buf)) == OK+        && os_chdir(os_buf) == 0) {+      if (!os_chdir(var) && os_dirname(IObuff, sizeof(IObuff)) == OK) {         var = (char *)IObuff;       }       if (os_chdir(os_buf) != 0) {         EMSG(_(e_prev_dir));       }     }+  } #endif-    homedir = xstrdup(var);++  if ((var == NULL || *var == NUL)+      && os_dirname((char_u *)os_buf, sizeof(os_buf)) == OK) {+    var = os_buf;   }++  homedir = xstrdup(var);+}++static char homedir_buf[MAXPATHL];++char *os_homedir(void)+{+  uv_mutex_lock(&mutex);+  size_t homedir_size = sizeof(os_buf);+  if (uv_os_homedir(os_buf, &homedir_size) == 0) {+    xstrlcpy(homedir_buf, os_buf, homedir_size);+    uv_mutex_unlock(&mutex);+    return homedir_buf;","It should be safe to use `NameBuff`, since the callers of `init_homedir()` don't use it. Then we can eliminate `homedir_buf`. Although, this violates the separation of `os/`, which normally shouldn't use `NameBuff`.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11140,337343235,2019-10-22T06:19:27Z,src/nvim/os/env.c,"@@ -346,21 +354,50 @@ void init_homedir(void)   } #endif -  if (var != NULL) { #ifdef UNIX+  if (var == NULL) {+    var = os_homedir();+  }++  if (var != NULL) {     // Change to the directory and get the actual path.  This resolves     // links.  Don't do it when we can't return.-    if (os_dirname((char_u *)os_buf, MAXPATHL) == OK && os_chdir(os_buf) == 0) {-      if (!os_chdir(var) && os_dirname(IObuff, IOSIZE) == OK) {+    if (os_dirname((char_u *)os_buf, sizeof(os_buf)) == OK+        && os_chdir(os_buf) == 0) {+      if (!os_chdir(var) && os_dirname(IObuff, sizeof(IObuff)) == OK) {         var = (char *)IObuff;       }       if (os_chdir(os_buf) != 0) {         EMSG(_(e_prev_dir));       }     }+  } #endif-    homedir = xstrdup(var);++  if ((var == NULL || *var == NUL)+      && os_dirname((char_u *)os_buf, sizeof(os_buf)) == OK) {+    var = os_buf;+  }++  homedir = xstrdup(var);+}++static char homedir_buf[MAXPATHL];++char *os_homedir(void)+{+  uv_mutex_lock(&mutex);+  size_t homedir_size = sizeof(homedir_buf);+  int ret_value = uv_os_homedir(os_buf, &homedir_size);+  if (ret_value == 0) {+    xstrlcpy(homedir_buf, os_buf, homedir_size + 1);+    uv_mutex_unlock(&mutex);+    return homedir_buf;+  } else {+    ELOG(""uv_os_homedir() failed %d: %s"", ret_value, os_strerror(ret_value));","Do not put `ELOG` calls in critical sections. Because it may call `os_getenv()`, `os_setenv()` internally, there is a risk of deadlock. It is better to execute `uv_mutex_unlock(&������mutex);` immediately after calling `uv_os_homedir()`.",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/11248,337365962,2019-10-22T07:41:48Z,runtime/lua/vim/shared.lua,"@@ -188,6 +188,31 @@ local function pesc(s)   return s:gsub('[%(%)%.%%%+%-%*%?%[%]%^%$]', '%%%1') end +--- Test if `prefix` is a prefix of `s`+--+-- @tparam string s String to check+-- @tparam string prefix Potential prefix+-- @treturn boolean True if prefix is a prefix of s+local function startswith(s, prefix)+  assert(type(s) == 'string', 'Input must be a string')+  assert(type(prefix) == 'string', 'Prefix must be a string')+	return s:sub(1, #prefix) == prefix+end++--- Test if `suffix` is a suffix of `s`+--+-- @tparam string s String to check+-- @tparam string suffix Potential suffix+-- @treturn boolean True if suffix is a suffix of s+local function endswith(s, suffix)+  assert(type(s) == 'string', 'Input must be a string')+  assert(type(suffix) == 'string', 'Suffix must be a string')","Metalua is very interesting. But unfortunately, maintenance has stopped and it has been many years.The lua-resty-validation looks good, but it seems a bit too big to introduce just for this purpose.Can I make a function or module for type assertion in another PR and discuss it there?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11275,337835449,2019-10-23T03:26:11Z,ci/build.ps1,"@@ -98,27 +99,17 @@ npm.cmd install -g neovim Get-Command -CommandType Application neovim-node-host.cmd npm.cmd link neovim -#npm.cmd install -g tree-sitter-cli-#npm.cmd link tree-sitter-cli+npm.cmd install -g 'tree-sitter-cli@0.15.9' -mkdir c:\treesitter-$env:TREE_SITTER_DIR = ""c:\treesitter""-#$env:PATH = ""c:\treesitter;$env:PATH""+$env:TREE_SITTER_DIR = $env:USERPROFILE + ""\tree-sitter-build""+mkdir ""$env:TREE_SITTER_DIR\bin"" $client = new-object System.Net.WebClient-cd c:\treesitter -if ($bits -eq 32) {-  $client.DownloadFile(""https://github.com/tree-sitter/tree-sitter/releases/download/0.15.9/tree-sitter-windows-x86.gz"", ""c:\treesitter\tree-sitter-cli.gz"")-}-elseif ($bits -eq 64) {-  $client.DownloadFile(""https://github.com/tree-sitter/tree-sitter/releases/download/0.15.9/tree-sitter-windows-x64.gz"", ""c:\treesitter\tree-sitter-cli.gz"")-}-python -c ""import gzip, shutil; f1,f2 = gzip.open('tree-sitter-cli.gz', 'rb'), open('tree-sitter.exe', 'wb'); shutil.copyfileobj(f1, f2); f2.close()""--$client.DownloadFile(""https://codeload.github.com/tree-sitter/tree-sitter-c/zip/v0.15.2"",""c:\treesitter\tree_sitter_c.zip"")-Expand-Archive c:\treesitter\tree_sitter_c.zip -DestinationPath c:\treesitter\-cd c:\treesitter\tree-sitter-c-0.15.2-c:\treesitter\tree-sitter.exe test+$client.DownloadFile(""https://codeload.github.com/tree-sitter/tree-sitter-c/zip/v0.15.2"","".\tree_sitter_c.zip"")+Expand-Archive .\tree_sitter_c.zip -DestinationPath .+cd tree-sitter-c-0.15.2+tree-sitter.cmd test+Test-Path -PathType Leaf ""$env:TREE_SITTER_DIR\bin\c.dll""","- ~~is `uv_dlopen` is being strict about slashes?~~ No, a similar mixed-slashes path is constructed by `treesitter_spec.lua`, and it passes on master.- ~~does `c.dll` needs to be sibling to the `.exe` or some other files?~~ I don't see any changes here which would result in different contents of `bin/`.Perhaps it's worth trying the old `c:\treesitter` path.",
205673,bobrippling,https://api.github.com/repos/neovim/neovim/pulls/11280,338767301,2019-10-24T20:06:30Z,runtime/autoload/man.vim,"@@ -406,4 +419,19 @@ function! man#init_pager() abort   endif endfunction +function! man#goto_tag(pattern, flags, info) abort+  "" currently no support for section completion+  let sect = """"","I suppose here we could parse `a:pattern` for a section specifier, and if one isn't found, perhaps fallback to `b:man_sect`",
205673,bobrippling,https://api.github.com/repos/neovim/neovim/pulls/11280,338771639,2019-10-24T20:17:17Z,runtime/autoload/man.vim,"@@ -406,4 +419,19 @@ function! man#init_pager() abort   endif endfunction +function! man#goto_tag(pattern, flags, info) abort+  "" currently no support for section completion+  let sect = """"","Decided to go with this approach, except without falling back to `b:man_sect` - almost all man pages have `man(X)` references, so we'd be unlikely to need to fallback to a section, so I think it would be unnecessary complexity/code for no benefit.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/11286,339111267,2019-10-25T15:27:18Z,runtime/autoload/man.vim,"@@ -284,20 +284,16 @@ function! s:extract_sect_and_name_path(path) abort endfunction  function! s:find_man() abort-  if &filetype ==# 'man'-    return 1-  elseif winnr('$') ==# 1-    return 0-  endif-  let thiswin = winnr()-  while 1-    wincmd w-    if &filetype ==# 'man'+  let l:win = 1+  while l:win <= winnr('$')+    let l:buf = winbufnr(l:win)+    if getbufvar(l:buf, '&filetype', '') ==# 'man'+      execute l:win.'wincmd w'       return 1-    elseif thiswin ==# winnr()-      return 0     endif+    let l:win += 1   endwhile+  return 0","How about this? :)```vimfunction! s:find_man()  let wins = filter(tabpagebuflist(),        \ {_, bufnr -> getbufvar(bufnr, ""&filetype"") ==# ""man""})  if !empty(wins)    call win_gotoid(bufwinid(wins[0]))    return 1  endif  return 0endfunction```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11290,339286594,2019-10-26T05:07:20Z,src/nvim/tui/tui.c,"@@ -134,6 +136,7 @@ typedef struct { static bool volatile got_winch = false; static bool did_user_set_dimensions = false; static bool cursor_style_enabled = false;+static bool tmux = false;","normally we put this on `TUIData` struct, then access it in `tui_term_osc_cmd` via the `ui->data` pointer. Probably the other `static bool` items here could have that treatment, but not worth changing since https://github.com/neovim/neovim/pull/10071 will change this stuff.And then the assignment could be put in `terminfo_start`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11271,339290560,2019-10-26T07:37:29Z,test/functional/lua/utility_functions_spec.lua,"@@ -285,7 +289,15 @@ describe('lua stdlib', function()   end)    it('vim.pesc', function()-    eq('foo%-bar', exec_lua([[return vim.pesc('foo-bar')]]))-    eq('foo%%%-bar', exec_lua([[return vim.pesc(vim.pesc('foo-bar'))]]))+    local pesc = function(s)+      return exec_lua('return vim.pesc(...)', s)+    end++    eq('foo%-bar', pesc('foo-bar'))+    eq('foo%%%-bar', pesc(pesc('foo-bar')))++    -- type checked args+    local path_pattern = iswin() and '[a-zA-Z]:[^:]+:%d+:' or '[^:]+:%d+:'","After trying the PR locally, I see that the error message has the full path:    Error executing lua: /home/vagrant/neovim/runtime/lua/vim/shared.lua:186: Expected string, got numberI missed that in https://github.com/neovim/neovim/pull/11271#discussion_r337800132 (sorry). But `[^:]+:%d+:` seems too loose. Let's try this:```lua  -- From this:  --    Error executing lua: /very/long/foo.lua:186: Expected string, got number  -- to this:  --    Error executing lua: .../foo.lua:186: Expected string, got number  errmsg = errmsg:gsub([[lua: [^:]-([^:/\]+:%d+: )]], 'lua: .../%1')```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11276,339322897,2019-10-27T02:28:17Z,runtime/lua/vim/shared.lua,"@@ -4,34 +4,36 @@ -- test-suite. If, in the future, Nvim itself is used to run the test-suite -- instead of ""vanilla Lua"", these functions could move to src/nvim/lua/vim.lua +local shared = {}  --- Returns a deep copy of the given object. Non-table objects are copied as --- in a typical Lua assignment, whereas table objects are copied recursively. --- --@param orig Table to copy --@returns New table of copied keys and (nested) values.-local function deepcopy(orig)-  error(orig)-end","I think we still need a ""dummy"" definition. When I ran `gen_vimdoc.py` from this PR, `deepcopy` was missing from `runtime/doc/if_lua.txt`.```luafunction shared.deepcopy(orig) end  -- luacheck: no unusedshared.deepcopy = (function()  ...```This isn't common, so it's probably better than making `lua2dox.lua` more complicated...",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/11276,339323891,2019-10-27T03:35:40Z,runtime/lua/vim/shared.lua,"@@ -4,34 +4,36 @@ -- test-suite. If, in the future, Nvim itself is used to run the test-suite -- instead of ""vanilla Lua"", these functions could move to src/nvim/lua/vim.lua +local shared = {}","Maybe because of my little experience.But that module test file nema is `utility_funcitons_spec.lua`.So I was a bit confused.Excuse me, this is an off topic because there is no big commitment.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10955,339364279,2019-10-27T21:15:33Z,test/functional/helpers.lua,"@@ -577,8 +577,16 @@ function module.assert_alive() end  local function do_rmdir(path)-  if lfs.attributes(path, 'mode') ~= 'directory' then-    return  -- Don't complain.+  local mode, errmsg, errcode = lfs.attributes(path, 'mode')","For reference: older versions of lfs (before 1.7.0) did not have `errcode` retval, then the `string.format()` call below will fail.  - https://github.com/keplerproject/luafilesystem/commit/b37e88b3d6128b85586231200c6d1a2f05ecd0d6- https://github.com/keplerproject/luafilesystem/commit/81e5b165bf324689777b967143c751786c405ce4Also `errcode` is system-dependent, so the `errcode == 2` check below is best-effort I guess. ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11290,339561805,2019-10-28T13:29:50Z,src/nvim/terminal.c,"@@ -644,6 +653,57 @@ Buffer terminal_buf(const Terminal *term) // }}} // libvterm callbacks {{{ +#define STATIC_CSTR_AS_STRING(s) ((String) {.data = s, .size = sizeof(s) - 1})++static int term_unhandled_csi(const char *leader, const long args[], int argcount,+                              const char *intermed, char command, void *user)+{+  Array numbers = ARRAY_DICT_INIT;+  Array arguments = ARRAY_DICT_INIT;+  Error err = ERROR_INIT;++  for (int i = 0; i < argcount; i++) {+    ADD(numbers, INTEGER_OBJ(args[i]));+  }++  ADD(arguments, ARRAY_OBJ(numbers));+  ADD(arguments, STRING_OBJ(STATIC_CSTR_AS_STRING("";"")));++  Object rv = nvim_execute_lua(STATIC_CSTR_AS_STRING(""return table.concat(...)""),","The standard pattern for ""building up"" strings in C code is otherwise to use growarray, i e```garray_T ga;ga_init(&ga, (int)sizeof(char *), 10);// in a loop or somethingsnprintf((char *)IObuff, IOSIZE, ""%d"", idx);ga_concat(&ga, IObuff);ga_append(&ga, ';');```perhaps we should have `ga_printf` directly also, so it is easier to use.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11314,340413703,2019-10-30T03:08:00Z,src/nvim/os/fs.c,"@@ -85,10 +85,16 @@ int os_dirname(char_u *buf, size_t len)   FUNC_ATTR_NONNULL_ALL {   int error_number;+#ifdef WIN32+  size_t buf_len = len;+#endif   if ((error_number = uv_cwd((char *)buf, &len)) != kLibuvSuccess) {","if we use `len` here, that avoids a `#ifdef`. Then `path_to_long` below, can use `len`. This is better anyways, since it's bad practice to re-assign argument values.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/11318,341257408,2019-10-31T17:00:34Z,src/nvim/testdir/test_usercommands.vim,"@@ -360,7 +360,7 @@ func Test_addr_all()       break     endif   endfor-  call assert_equal(low, g:a1)+  "" call assert_equal(low, g:a1)","I looked through the patch and found no obvious typo.Then I added this to the test:```diffdiff --git i/src/nvim/testdir/test_usercommands.vim w/src/nvim/testdir/test_usercommands.vimindex 841c72382..ebadf8d8d 100644--- i/src/nvim/testdir/test_usercommands.vim+++ w/src/nvim/testdir/test_usercommands.vim@@ -360,6 +360,9 @@ func Test_addr_all()       break     endif   endfor+  call assert_equal(filter(range(1, bufnr('$')), 'buflisted(v:val)'), 999)+  call assert_equal(filter(range(1, bufnr('$')), 'bufloaded(v:val)'), 999)+  call assert_equal(g:a1, 999)   "" call assert_equal(low, g:a1)   call assert_equal(bufnr('$'), g:a2)```which resulted in:```        function RunTheTest[37]..Test_addr_all line 19: Expected [3, 4, 5] but got 999        function RunTheTest[37]..Test_addr_all line 20: Expected [3] but got 999        function RunTheTest[37]..Test_addr_all line 21: Expected 2 but got 999```So, `low` is correctly set to 3, but `g:a1` (and thus `<line1>`) is 2 for some reason, although the first listed (and loaded) buffer is 3.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/11319,341380974,2019-10-31T21:50:46Z,src/nvim/ex_getln.c,"@@ -1927,7 +1927,9 @@ static int command_line_changed(CommandLineState *s)     //       - Immediately undo the effects.     State |= CMDPREVIEW;     emsg_silent++;  // Block error reporting as the command may be incomplete+    msg_silent++;   // Block messages, namely ones that prompt","Are we sure there are no prompts that are mandatory? You gave the example of ""inverse range, are you sure"", which should probably be ignored indeed, but is there something else, that might have a bad effect when ignored?",
205673,bobrippling,https://api.github.com/repos/neovim/neovim/pulls/11319,341402555,2019-10-31T23:16:28Z,src/nvim/ex_getln.c,"@@ -1927,7 +1927,9 @@ static int command_line_changed(CommandLineState *s)     //       - Immediately undo the effects.     State |= CMDPREVIEW;     emsg_silent++;  // Block error reporting as the command may be incomplete+    msg_silent++;   // Block messages, namely ones that prompt","That could be the case for more critical errors - I had considered making a new global variable just for the inverse-range prompt, as there's ~100 uses of `msg_silent` in neovim, but I thought this would be too specific a use case.I've been through the reads of `msg_silent`, and in summary we have:- Messages:  - `'shortmess'` display  - File info display on buffer entry  - `'showmatch'` when inserting text  - Search progress / match numbers etc  - Delay for showing message when tag case mismatch, tag guesses, etc  - Generic output truncation prompt- Command output:  - `'verbose'` >= 15 command line handling  - Output from `:nmap` and friends  - `'showmode'`  - Syntax list output  - `:messages` history  - `:silent`- **Prompts**:  - Waiting for return on swap file messages  - Prompting the user for a number (spelling, tag, etc)  - **Backwards range given**  - Waiting for return on general commands- Warnings:  - File changed since reading (+ associated prompt)  - Changing a readonly file  - No write since last changethe rest are just saves, restores or increments/decrements of `msg_silent`. I reckon these are all okay to turn off during substitute interaction, but I'm open to adding a variable just for disabling the prompts.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11326,341823421,2019-11-02T19:39:09Z,src/nvim/main.c,"@@ -793,6 +893,9 @@ static void command_line_scan(mparm_T *parmp)           // ""--version"" give version message           // ""--noplugin[s]"" skip plugins           // ""--cmd <cmd>"" execute cmd before vimrc+          // ""--remote"" open file on remote instance+          // ""--server"" name of vim server to send to or name+          // of server to become","If we are going to introduce `--server` do we still need `--listen` ? Or is this the same thing as `--connect` in the remote-TUI PR? I think `--connect` describes the common case and thus is preferrable, even if it retains the ""become this server"" behavior of `--server`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11336,342501584,2019-11-05T11:02:13Z,runtime/lua/vim/lsp.lua,"@@ -0,0 +1,791 @@+local builtin_default_server_callbacks = require 'vim.lsp.builtin_callbacks'+local log = require 'vim.lsp.log'+local lsp_rpc = require 'vim.lsp.rpc'+local protocol = require 'vim.lsp.protocol'+local util = require 'vim.lsp.util'++local nvim_err_writeln, nvim_buf_get_lines, nvim_command, nvim_buf_get_option+  = vim.api.nvim_err_writeln, vim.api.nvim_buf_get_lines, vim.api.nvim_command, vim.api.nvim_buf_get_option++local lsp = {+  protocol = protocol;+}++-- TODO consider whether 'eol' or 'fixeol' should change the nvim_buf_get_lines that send.++local function resolve_bufnr(bufnr)+  if bufnr == nil or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++local function set_timeout(ms, fn)+  local timer = vim.loop.new_timer()+  timer:start(ms, 0, function()+    pcall(fn)+    timer:close()+  end)+  return timer+end++local VALID_ENCODINGS = {+  [""utf-8""] = 'utf-8'; [""utf-16""] = 'utf-16'; [""utf-32""] = 'utf-32';+  [""utf8""]  = 'utf-8'; [""utf16""]  = 'utf-16'; [""utf32""]  = 'utf-32';+  UTF8      = 'utf-8'; UTF16      = 'utf-16'; UTF32      = 'utf-32';+}++local CLIENT_INDEX = 0+local function next_client_id()+  CLIENT_INDEX = CLIENT_INDEX + 1+  return CLIENT_INDEX+end+local LSP_CLIENTS = {}+local BUFFER_CLIENT_IDS = {}++local function for_each_buffer_client(bufnr, callback)+  assert(type(callback) == 'function', ""callback must be a function"")+  bufnr = resolve_bufnr(bufnr)+  assert(type(bufnr) == 'number', ""bufnr must be a number"")+  local client_ids = BUFFER_CLIENT_IDS[bufnr]+  if not client_ids or vim.tbl_isempty(client_ids) then+    return+  end+  for client_id in pairs(client_ids) do+    local client = LSP_CLIENTS[client_id]+    -- This is unlikely to happen. Could only potentially happen in a race+    -- condition between literally a single statement.+    -- We could skip this error, but let's error for now.+    if not client then+      error(string.format("" Client %d has already shut down."", client_id))+    end+    callback(client, client_id)+  end+end++local function validate_encoding(encoding)+  assert(type(encoding) == 'string', ""encoding must be a string"")+  return VALID_ENCODINGS[encoding:lower()] or error(string.format(""Invalid offset encoding %q. Must be one of: 'utf-8', 'utf-16', 'utf-32'"", encoding))+end++local maxerrn = table.maxn(lsp_rpc.ERRORS)+local error_codes = vim.tbl_extend(""error"", lsp_rpc.ERRORS, vim.tbl_add_reverse_lookup {+  ON_INIT_CALLBACK_ERROR = maxerrn + 1;+})++--- Start a client and initialize it.+-- conf = {+--   cmd = string;+--   cmd_args = table;+--   cmd_cwd = string | nil;+--   cmd_end = table | nil;+--   offset_encoding = 'utf-8' | 'utf-16' | 'utf-32' | string;+--   name = string | nil;+--   trace = 'off' | 'messages' | 'verbose' | nil+--   default_server_callbacks = table | nil;+--   on_init = function | nil;+--   init_options = table | nil;+-- }+--+-- - `name` here is only used for logging/debugging.+-- - `trace` will be forwarded to the client.+-- - `default_server_callbacks` should be a table of functions which+-- defines:+--   - The handlers for notifications. These should be `function(params)`+--   - A default callback to use for `vim.lsp.buf_request` if one is not+--   provided at the time of calling `vim.lsp.buf_request`. These should be+--   `function(err, result)`+--   - By default, the functions from the module `vim.lsp.builtin_callbacks`+--   will be used. This parameter can override or extend it those builtin+--   callbacks.+--+-- You can use |vim.lsp.get_client_by_id()| to get the actual client.+--+-- NOTE: The client is only available *after* it has been initialized, which+-- may happen after a small delay (or never if there is an error).+-- For this reason, you may want to use `on_init` to do any actions once the+-- client has been initialized.+--+-- @return client_id+function lsp.start_client(conf)+  assert(type(conf.cmd) == 'string', ""conf.cmd must be a string"")+  assert(type(conf.cmd_args) == 'table', ""conf.cmd_args must be a table"")+  local offset_encoding = validate_encoding(conf.offset_encoding)+  -- TODO should I be using this for both notifications and request callbacks+  -- or separate those?+  local default_server_callbacks+  if conf.default_server_callbacks then+    assert(type(conf.default_server_callbacks) == 'table', ""conf.default_server_callbacks must be a table"")+    default_server_callbacks = vim.tbl_extend(""keep"", conf.default_server_callbacks, builtin_default_server_callbacks)+  else+    default_server_callbacks = builtin_default_server_callbacks+  end+  -- TODO keep vim.schedule here?+  for k, v in pairs(default_server_callbacks) do+    default_server_callbacks[k] = vim.schedule_wrap(v)+  end+  local capabilities = conf.capabilities or {}+  assert(type(capabilities) == 'table', ""conf.capabilities must be a table"")++  -- There are things sent by the server in the initialize response which+  -- contains capabilities that would be useful for completion engines, such as+  -- the character code triggers for completion and code action, so I'll expose this+  -- for now.+  if conf.on_init then+    assert(type(conf.on_init) == 'function', ""conf.on_init must be a function"")+  end+  if conf.on_exit then+    assert(type(conf.on_exit) == 'function', ""conf.on_exit must be a function"")+  end+  if conf.on_error then+    assert(type(conf.on_error) == 'function', ""conf.on_error must be a function"")+  end+  if conf.cmd_env then+    assert(type(conf.cmd_env) == 'table', ""conf.cmd_env must be a table"")+  end+  if conf.cmd_cwd then+    assert(type(conf.cmd_cwd) == 'string', ""conf.cmd_cwd must be a string"")+    local stat = vim.loop.fs_stat(conf.cmd_cwd)+    assert(stat and stat.type == 'directory', ""conf.cmd_cwd must be a directory"")+  end++  local client_id = next_client_id()++  local handlers = {}++  function handlers.notification(method, params)+    _ = log.debug() and log.debug('notification', method, params)+    local callback = default_server_callbacks[method]+    if callback then+      -- Method name is provided here for convenience.+      callback(params, method)+    end+  end++  function handlers.server_request(method, params)+    _ = log.debug() and log.debug('server_request', method, params)+    local request_callback = default_server_callbacks[method]+    if request_callback then+      return request_callback(params, method)+    end+    return nil, lsp_rpc.rpc_response_error(protocol.ErrorCodes.MethodNotFound)+  end++  local name = conf.name or tostring(client_id)+  assert(type(name) == 'string', ""conf.name must be a string"")+  local log_prefix = string.format(""LSP[%s]"", name)++  function handlers.on_error(code, err)+    _ = log.error() and log.error(log_prefix, ""on_error"", { code = error_codes[code], err = err })+    nvim_err_writeln(string.format('%s: Error %s: %q', log_prefix, error_codes[code], vim.inspect(err)))+    if conf.on_error then+      local status, usererr = pcall(conf.on_error, code, err)+      if not status then+        _ = log.error() and log.error(log_prefix, ""user on_error failed"", { err = usererr })+        nvim_err_writeln(log_prefix.."" user on_error failed: ""..tostring(usererr))+      end+    end+  end++  -- This is used because if there are outstanding timers (like for stop())+  -- they will block neovim exiting.+  local timers = {}+  function handlers.on_exit()+    for _, h in ipairs(timers) do+      h:stop()+      h:close()+    end+    LSP_CLIENTS[client_id] = nil+    for bufnr, client_ids in pairs(BUFFER_CLIENT_IDS) do+      client_ids[client_id] = nil+    end+    if conf.on_exit then pcall(conf.on_exit, client_id) end+  end++  local rpc = lsp_rpc.start(conf.cmd, conf.cmd_args, handlers, {+    cwd = conf.cmd_cwd;+    env = conf.cmd_env;+  })++  local client = {+    id = client_id;+    name = name;+    rpc = rpc;+    offset_encoding = offset_encoding;+    default_server_callbacks = default_server_callbacks;+    config = conf;+  }++  local function initialize()+    local valid_traces = {+      off = 'off'; messages = 'messages'; verbose = 'verbose';+    }+    local initialize_params = {+      -- The process Id of the parent process that started the server. Is null if+      -- the process has not been started by another process.  If the parent+      -- process is not alive then the server should exit (see exit notification)+      -- its process.+      processId = vim.loop.getpid();+      -- The rootPath of the workspace. Is null if no folder is open.+      --+      -- @deprecated in favour of rootUri.+      rootPath = nil;+      -- The rootUri of the workspace. Is null if no folder is open. If both+      -- `rootPath` and `rootUri` are set `rootUri` wins.+      rootUri = vim.uri_from_fname(vim.loop.cwd()); -- TODO which path to use?+--      rootUri = vim.uri_from_fname(vim.fn.expand(""%:p:h""));+      -- User provided initialization options.+      initializationOptions = conf.init_options;+      -- The capabilities provided by the client (editor or tool)+      capabilities = vim.tbl_deep_merge(protocol.make_client_capabilities(), capabilities);+      -- The initial trace setting. If omitted trace is disabled ('off').+      -- trace = 'off' | 'messages' | 'verbose';+      trace = valid_traces[conf.trace] or 'off';+      -- The workspace folders configured in the client when the server starts.+      -- This property is only available if the client supports workspace folders.+      -- It can be `null` if the client supports workspace folders but none are+      -- configured.+      --+      -- Since 3.6.0+      -- workspaceFolders?: WorkspaceFolder[] | null;+      -- export interface WorkspaceFolder {+      --  -- The associated URI for this workspace folder.+      --  uri+      --  -- The name of the workspace folder. Used to refer to this+      --  -- workspace folder in the user interface.+      --  name+      -- }+      workspaceFolders = nil;+    }+    _ = log.debug() and log.debug(log_prefix, ""initialize_params"", initialize_params)+    rpc.request('initialize', initialize_params, function(err, result)+      assert(not err, err)+      rpc.notify('initialized', {})+      client.initialized = true+      client.server_capabilities = assert(result.capabilities, ""initialize result doesn't contain capabilities"")+      client.resolved_capabilities = protocol.resolve_capabilities(client.server_capabilities)+      if conf.on_init then+        local status, err = pcall(conf.on_init, client, result)+        if not status then+          pcall(handlers.on_error, error_codes.ON_INIT_CALLBACK_ERROR, err)+        end+      end+      _ = log.debug() and log.debug(log_prefix, ""server_capabilities"", client.server_capabilities)+      _ = log.info() and log.info(log_prefix, ""initialized"", { resolved_capabilities = client.resolved_capabilities })++      -- Only assign after initialized?+      LSP_CLIENTS[client_id] = client+      -- If we had been registered before we start, then send didOpen This can+      -- happen if we attach to buffers before initialize finishes or if+      -- someone restarts a client.+      for bufnr, client_ids in pairs(BUFFER_CLIENT_IDS) do+        if client_ids[client_id] then+          client.text_document_did_open(bufnr)+        end+      end+    end)+  end++  local function unsupported_method(method)+    local msg = ""server doesn't support ""..method+    _ = log.warn() and log.warn(msg)+    vim.api.nvim_err_writeln(msg)+    return lsp_rpc.rpc_response_error(protocol.ErrorCodes.MethodNotFound, msg)+  end++  --- Checks capabilities before rpc.request-ing.+  function client.request(method, params, callback)+    _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, callback)+    -- TODO keep these checks or just let it go anyway?+    if (not client.resolved_capabilities.hover and method == 'textDocument/hover')+      or (not client.resolved_capabilities.signature_help and method == 'textDocument/signatureHelp')+      or (not client.resolved_capabilities.goto_definition and method == 'textDocument/definition')+      or (not client.resolved_capabilities.implementation and method == 'textDocument/implementation')+    then+      callback(unsupported_method(method))+      return+    end+    return rpc.request(method, params, callback)+  end++  function client.notify(...)+    return rpc.notify(...)+  end++  -- TODO Make sure these timeouts are ok or make configurable?+  function client.stop(force)+    local handle = rpc.handle+    if handle:is_closing() then+      return+    end+    if force then+      -- kill after 1s as a last resort.+      table.insert(timers, set_timeout(1e3, function() handle:kill(9) end))+      handle:kill(15)+      return+    end+    -- term after 100ms as a fallback+    table.insert(timers, set_timeout(1e2, function() handle:kill(15) end))+    -- kill after 1s as a last resort.+    table.insert(timers, set_timeout(1e3, function() handle:kill(9) end))+    -- Sending a signal after a process has exited is acceptable.+    rpc.request('shutdown', nil, function(err, result)+      if err == nil then+        rpc.notify('exit')+      else+        -- If there was an error in the shutdown request, then term to be safe.+        handle:kill(15)+      end+    end)+  end++  function client.text_document_did_open(bufnr)+    if not client.resolved_capabilities.text_document_open_close then+      return+    end+    local params = {+      textDocument = {+        version = 0;+        uri = vim.uri_from_bufnr(bufnr);+        -- TODO make sure our filetypes are compatible with languageId names.+        languageId = nvim_buf_get_option(bufnr, 'filetype');+        text = table.concat(nvim_buf_get_lines(bufnr, 0, -1, false), '\n');+      }+    }+    rpc.notify('textDocument/didOpen', params)+  end++  initialize()++  return client_id+end++local function once(fn)+  local value+  return function(...)+    if not value then value = fn(...) end+    return value+  end+end++local ENCODING_INDEX = { [""utf-8""] = 1; [""utf-16""] = 2; [""utf-32""] = 3; }+local function text_document_did_change_handler(_, bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size)+  _ = log.debug() and log.debug(""on_lines"", bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size)+  -- Don't do anything if there are no clients attached.+  if vim.tbl_isempty(BUFFER_CLIENT_IDS[bufnr] or {}) then+    return+  end+  local incremental_changes = once(function(client)+    -- TODO make sure this is correct. Sometimes this sends firstline = lastline and text = """"+    local size_index = ENCODING_INDEX[client.offset_encoding]+    local lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+    -- TODO The old implementation did this but didn't explain why.+    -- if new_lastline > firstline then+    --  table.insert(lines, '')+    -- end+    return {+      range = {+        start = { line = firstline, character = 0 };+        [""end""] = { line = lastline, character = 0 };+      };+      rangeLength = select(size_index, old_byte_size, old_utf16_size, old_utf32_size);+      text = table.concat(lines, '\n');+    };+  end)+  local full_changes = once(function()+    return {+      text = table.concat(nvim_buf_get_lines(bufnr, 0, -1, false), ""\n"");+    };+  end)+  local uri = vim.uri_from_bufnr(bufnr)+  for_each_buffer_client(bufnr, function(client, client_id)+    local text_document_did_change = client.resolved_capabilities.text_document_did_change+    local changes+    if text_document_did_change == protocol.TextDocumentSyncKind.None then+      return+    elseif text_document_did_change == protocol.TextDocumentSyncKind.Incremental then+      changes = incremental_changes(client)+    elseif text_document_did_change == protocol.TextDocumentSyncKind.Full then+      changes = full_changes(client)+    end+    client.notify(""textDocument/didChange"", {+      textDocument = {+        uri = uri;+        version = changedtick;+      };+      contentChanges = { changes; }+    })+  end)+end++-- Implements the textDocument/did* notifications required to track a buffer+-- for any language server.+--+-- This function could be implemented outside of the client function, since+-- it stands out alone as the only function which contains protocol+-- implementation details, but it's definitely easier to implement here.+function lsp.attach_to_buffer(bufnr, client_id)+  assert(type(client_id) == 'number', ""client_id must be a number"")+  bufnr = resolve_bufnr(bufnr)+  local buffer_client_ids = BUFFER_CLIENT_IDS[bufnr]+  -- This is our first time attaching to this buffer.+  if not buffer_client_ids then+    buffer_client_ids = {}+    BUFFER_CLIENT_IDS[bufnr] = buffer_client_ids++    nvim_command(string.format(""autocmd BufWritePost <buffer=%d> lua vim.lsp._text_document_did_save_handler(%d)"", bufnr, bufnr))+    local uri = vim.uri_from_bufnr(bufnr)++    -- First time, so attach and set up stuff.+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = text_document_did_change_handler;+      -- TODO this could be abstracted if on_detach passes the bufnr, but since+      -- there's no documentation, I have no idea if that happens.+      on_detach = function()+        local params = {+          textDocument = {+            uri = uri;+          }+        }+        for_each_buffer_client(bufnr, function(client, client_id)+          if client.resolved_capabilities.text_document_open_close then+            client.notify('textDocument/didClose', params)+          end+        end)+        BUFFER_CLIENT_IDS[bufnr] = nil+      end;+      -- TODO if we know all of the potential clients ahead of time, then we+      -- could conditionally set this.+      --      utf_sizes = size_index > 1;+      utf_sizes = true;+    })+  end+  if buffer_client_ids[client_id] then return end+  -- This is our first time attaching this client to this buffer.+  buffer_client_ids[client_id] = true++  local client = LSP_CLIENTS[client_id]+  -- Send didOpen for the client if it is initialized. If it isn't initialized+  -- then it will send didOpen on initialize.+  if client then+    client.text_document_did_open(bufnr)+  end+end++local LSP_CONFIGS = {}++function lsp.add_config(config)+  assert(type(config) == 'table', 'argument must be a table')+  assert(config.filetype, ""config must have 'filetype' key"")+  assert(config.cmd, ""config must have 'cmd' key"")+  assert(type(config.name) == 'string', ""config.name must be a string"")+  if LSP_CONFIGS[config.name] then+    -- If the client exists, then it is likely that they are doing some kind of+    -- reload flow, so let's not throw an error here.+    if LSP_CONFIGS[config.name].client_id then+      -- TODO log here? It might be unnecessarily annoying.+      return+    end+    error(string.format('A configuration with the name %q already exists. They must be unique', config.name))+  end+  local capabilities = config.capabilities or {}+  assert(type(capabilities) == 'table', ""config.capabilities must be a table"")++  local filetypes+  if type(config.filetype) == 'string' then+    filetypes = { config.filetype }+  elseif type(config.filetype) == 'table' then+    filetypes = config.filetype+  else+    error(""config.filetype must be a string or a list of strings"")+  end++  local offset_encoding = config.offset_encoding and validate_encoding(config.offset_encoding) or VALID_ENCODINGS.UTF16++  local cmd, cmd_args+  if type(config.cmd) == 'string' then+    -- Use a shell to execute the command if it is a string.+    cmd = vim.api.nvim_get_option('shell')+    cmd_args = {vim.api.nvim_get_option('shellcmdflag'), config.cmd}+  elseif vim.tbl_islist(config.cmd) then+    cmd = config.cmd[1]+    cmd_args = {}+    -- Don't mutate our input.+    for i, v in ipairs(config.cmd) do+      assert(type(v) == 'string', ""config.cmd arguments must be strings"")+      if i > 1 then+        table.insert(cmd_args, v)+      end+    end+  else+    error(""cmd type must be string or list."")+  end++  LSP_CONFIGS[config.name] = {+    user_config = config;+    name = config.name;+    offset_encoding = offset_encoding;+    filetypes = filetypes;+    cmd = cmd;+    cmd_args = cmd_args;+    cmd_env = config.cmd_env;+    cmd_cwd = config.cmd_cwd;+    capabilities = capabilities;+    init_options = config.init_options;+    on_init = config.on_init;+  }++  nvim_command(string.format(+    ""autocmd FileType %s ++once silent lua vim.lsp._start_client_by_name(%q)"",+    table.concat(filetypes, ','),+    config.name))+end++function lsp._start_client_by_name(name)+  local config = LSP_CONFIGS[name]+  -- If it exists and is running, don't make it again.+  if config.client_id and LSP_CLIENTS[config.client_id] then+    -- TODO log here?+    return+  end+  config.client_id = lsp.start_client(config)+  vim.lsp.attach_to_buffer(0, config.client_id)++  nvim_command(string.format(+    ""autocmd FileType %s silent lua vim.lsp.attach_to_buffer(0, %d)"",+    table.concat(config.filetypes, ','),+    config.client_id))+  return config.client_id+end++nvim_command(""autocmd VimLeavePre * lua vim.lsp.stop_all_clients()"")++function lsp.get_client_by_id(client_id)+  return LSP_CLIENTS[client_id]+end++function lsp.get_client_by_name(name)+  local config = LSP_CONFIGS[name]+  if config.client_id then+    return LSP_CLIENTS[config.client_id]+  end+end++function lsp.stop_client(client_id, force)+  local client = LSP_CLIENTS[client_id]+  if client then+    client.stop(force)+  end+end++function lsp.stop_all_clients(force)+  for client_id, client in pairs(LSP_CLIENTS) do+    client.stop(force)+  end+end++--- Send a request to a server and return the response+-- @param method [string]: Name of the request method+-- @param params [table] (optional): Arguments to send to the server+-- @param bufnr [number] (optional): The number of the buffer+-- @param filetype [string] (optional): The filetype associated with the server+-- @param server_name [string] (optional)+--+-- @returns: success?, request_id, cancel_fn+function lsp.buf_request(bufnr, method, params, callback)+  if callback then+    assert(type(callback) == 'function', ""buf_request callback must be a function"")+  end+  local client_request_ids = {}+  for_each_buffer_client(bufnr, function(client, client_id)+    local request_callback = callback+    if not request_callback then+      request_callback = client.default_server_callbacks[method]+        or error(string.format(""buf_request callback is empty and no default client was found for client %s"", client.name))+    end+    local request_success, request_id = client.request(method, params, function(err, result)+      -- TODO pass client here?+      request_callback(err, result, client_id)+    end)++    -- This could only fail if the client shut down in the time since we looked+    -- it up and we did the request, which should be rare.+    if request_success then+      client_request_ids[client_id] = request_id+    end+  end)++  local function cancel_request()+    for client_id, request_id in pairs(client_request_ids) do+      local client = LSP_CLIENTS[client_id]+      client.rpc.notify('$/cancelRequest', { id = request_id })+    end+  end++  return client_request_ids, cancel_request+end++--- Send a request to a server, but don't wait for the response+-- @param method [string]: Name of the request method+-- @param params [string]: Arguments to send to the server+-- @param cb [function|string] (optional): Either a function to call or a string to call in vim+-- @param bufnr [number] (optional): The number of the buffer+-- @param filetype [string] (optional): The filetype associated with the server+-- @param server_name [string] (optional)+--+-- @returns: The table of request id+function lsp.buf_request_sync(bufnr, method, params, timeout_ms)+  local request_results = {}+  local result_count = 0+  local function callback(err, result, client_id)+    _ = log.trace() and log.trace(""callback"", err, result, client_id)+    request_results[client_id] = { error = err, result = result }+    result_count = result_count + 1+  end+  local client_request_ids, cancel = lsp.buf_request(bufnr, method, params, callback)+  _ = log.trace() and log.trace(""client_request_ids"", client_request_ids)++  local expected_result_count = 0+  for _ in pairs(client_request_ids) do+    expected_result_count = expected_result_count + 1+  end+  _ = log.trace() and log.trace(""expected_result_count"", expected_result_count)+  local timeout = (timeout_ms or 100) + vim.loop.now()+  -- TODO is there a better way to sync this?+  while result_count < expected_result_count do+    _ = log.trace() and log.trace(""results"", result_count, request_results)+    if vim.loop.now() >= timeout then+      cancel()+      return nil, ""TIMEOUT""+    end+    -- TODO this really needs to be further looked at.+    nvim_command ""sleep 10m""",we have `vim.fn.wait(condition)` but it only works for vimL callbacks. Though exposing the same in lua with lua cb would be straightforward.,
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11336,342505129,2019-11-05T11:10:45Z,runtime/lua/vim/lsp.lua,"@@ -0,0 +1,791 @@+local builtin_default_server_callbacks = require 'vim.lsp.builtin_callbacks'+local log = require 'vim.lsp.log'+local lsp_rpc = require 'vim.lsp.rpc'+local protocol = require 'vim.lsp.protocol'+local util = require 'vim.lsp.util'++local nvim_err_writeln, nvim_buf_get_lines, nvim_command, nvim_buf_get_option+  = vim.api.nvim_err_writeln, vim.api.nvim_buf_get_lines, vim.api.nvim_command, vim.api.nvim_buf_get_option++local lsp = {+  protocol = protocol;+}++-- TODO consider whether 'eol' or 'fixeol' should change the nvim_buf_get_lines that send.++local function resolve_bufnr(bufnr)+  if bufnr == nil or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++local function set_timeout(ms, fn)+  local timer = vim.loop.new_timer()+  timer:start(ms, 0, function()+    pcall(fn)+    timer:close()+  end)+  return timer+end++local VALID_ENCODINGS = {+  [""utf-8""] = 'utf-8'; [""utf-16""] = 'utf-16'; [""utf-32""] = 'utf-32';+  [""utf8""]  = 'utf-8'; [""utf16""]  = 'utf-16'; [""utf32""]  = 'utf-32';+  UTF8      = 'utf-8'; UTF16      = 'utf-16'; UTF32      = 'utf-32';+}++local CLIENT_INDEX = 0+local function next_client_id()+  CLIENT_INDEX = CLIENT_INDEX + 1+  return CLIENT_INDEX+end+local LSP_CLIENTS = {}+local BUFFER_CLIENT_IDS = {}++local function for_each_buffer_client(bufnr, callback)+  assert(type(callback) == 'function', ""callback must be a function"")+  bufnr = resolve_bufnr(bufnr)+  assert(type(bufnr) == 'number', ""bufnr must be a number"")+  local client_ids = BUFFER_CLIENT_IDS[bufnr]+  if not client_ids or vim.tbl_isempty(client_ids) then+    return+  end+  for client_id in pairs(client_ids) do+    local client = LSP_CLIENTS[client_id]+    -- This is unlikely to happen. Could only potentially happen in a race+    -- condition between literally a single statement.+    -- We could skip this error, but let's error for now.+    if not client then+      error(string.format("" Client %d has already shut down."", client_id))+    end+    callback(client, client_id)+  end+end++local function validate_encoding(encoding)+  assert(type(encoding) == 'string', ""encoding must be a string"")+  return VALID_ENCODINGS[encoding:lower()] or error(string.format(""Invalid offset encoding %q. Must be one of: 'utf-8', 'utf-16', 'utf-32'"", encoding))+end++local maxerrn = table.maxn(lsp_rpc.ERRORS)+local error_codes = vim.tbl_extend(""error"", lsp_rpc.ERRORS, vim.tbl_add_reverse_lookup {+  ON_INIT_CALLBACK_ERROR = maxerrn + 1;+})++--- Start a client and initialize it.+-- conf = {+--   cmd = string;+--   cmd_args = table;+--   cmd_cwd = string | nil;+--   cmd_end = table | nil;+--   offset_encoding = 'utf-8' | 'utf-16' | 'utf-32' | string;+--   name = string | nil;+--   trace = 'off' | 'messages' | 'verbose' | nil+--   default_server_callbacks = table | nil;+--   on_init = function | nil;+--   init_options = table | nil;+-- }+--+-- - `name` here is only used for logging/debugging.+-- - `trace` will be forwarded to the client.+-- - `default_server_callbacks` should be a table of functions which+-- defines:+--   - The handlers for notifications. These should be `function(params)`+--   - A default callback to use for `vim.lsp.buf_request` if one is not+--   provided at the time of calling `vim.lsp.buf_request`. These should be+--   `function(err, result)`+--   - By default, the functions from the module `vim.lsp.builtin_callbacks`+--   will be used. This parameter can override or extend it those builtin+--   callbacks.+--+-- You can use |vim.lsp.get_client_by_id()| to get the actual client.+--+-- NOTE: The client is only available *after* it has been initialized, which+-- may happen after a small delay (or never if there is an error).+-- For this reason, you may want to use `on_init` to do any actions once the+-- client has been initialized.+--+-- @return client_id+function lsp.start_client(conf)+  assert(type(conf.cmd) == 'string', ""conf.cmd must be a string"")+  assert(type(conf.cmd_args) == 'table', ""conf.cmd_args must be a table"")+  local offset_encoding = validate_encoding(conf.offset_encoding)+  -- TODO should I be using this for both notifications and request callbacks+  -- or separate those?+  local default_server_callbacks+  if conf.default_server_callbacks then+    assert(type(conf.default_server_callbacks) == 'table', ""conf.default_server_callbacks must be a table"")+    default_server_callbacks = vim.tbl_extend(""keep"", conf.default_server_callbacks, builtin_default_server_callbacks)+  else+    default_server_callbacks = builtin_default_server_callbacks+  end+  -- TODO keep vim.schedule here?+  for k, v in pairs(default_server_callbacks) do+    default_server_callbacks[k] = vim.schedule_wrap(v)+  end+  local capabilities = conf.capabilities or {}+  assert(type(capabilities) == 'table', ""conf.capabilities must be a table"")++  -- There are things sent by the server in the initialize response which+  -- contains capabilities that would be useful for completion engines, such as+  -- the character code triggers for completion and code action, so I'll expose this+  -- for now.+  if conf.on_init then+    assert(type(conf.on_init) == 'function', ""conf.on_init must be a function"")+  end+  if conf.on_exit then+    assert(type(conf.on_exit) == 'function', ""conf.on_exit must be a function"")+  end+  if conf.on_error then+    assert(type(conf.on_error) == 'function', ""conf.on_error must be a function"")+  end+  if conf.cmd_env then+    assert(type(conf.cmd_env) == 'table', ""conf.cmd_env must be a table"")+  end+  if conf.cmd_cwd then+    assert(type(conf.cmd_cwd) == 'string', ""conf.cmd_cwd must be a string"")+    local stat = vim.loop.fs_stat(conf.cmd_cwd)+    assert(stat and stat.type == 'directory', ""conf.cmd_cwd must be a directory"")+  end++  local client_id = next_client_id()++  local handlers = {}++  function handlers.notification(method, params)+    _ = log.debug() and log.debug('notification', method, params)+    local callback = default_server_callbacks[method]+    if callback then+      -- Method name is provided here for convenience.+      callback(params, method)+    end+  end++  function handlers.server_request(method, params)+    _ = log.debug() and log.debug('server_request', method, params)+    local request_callback = default_server_callbacks[method]+    if request_callback then+      return request_callback(params, method)+    end+    return nil, lsp_rpc.rpc_response_error(protocol.ErrorCodes.MethodNotFound)+  end++  local name = conf.name or tostring(client_id)+  assert(type(name) == 'string', ""conf.name must be a string"")+  local log_prefix = string.format(""LSP[%s]"", name)++  function handlers.on_error(code, err)+    _ = log.error() and log.error(log_prefix, ""on_error"", { code = error_codes[code], err = err })+    nvim_err_writeln(string.format('%s: Error %s: %q', log_prefix, error_codes[code], vim.inspect(err)))+    if conf.on_error then+      local status, usererr = pcall(conf.on_error, code, err)+      if not status then+        _ = log.error() and log.error(log_prefix, ""user on_error failed"", { err = usererr })+        nvim_err_writeln(log_prefix.."" user on_error failed: ""..tostring(usererr))+      end+    end+  end++  -- This is used because if there are outstanding timers (like for stop())+  -- they will block neovim exiting.+  local timers = {}+  function handlers.on_exit()+    for _, h in ipairs(timers) do+      h:stop()+      h:close()+    end+    LSP_CLIENTS[client_id] = nil+    for bufnr, client_ids in pairs(BUFFER_CLIENT_IDS) do+      client_ids[client_id] = nil+    end+    if conf.on_exit then pcall(conf.on_exit, client_id) end+  end++  local rpc = lsp_rpc.start(conf.cmd, conf.cmd_args, handlers, {+    cwd = conf.cmd_cwd;+    env = conf.cmd_env;+  })++  local client = {+    id = client_id;+    name = name;+    rpc = rpc;+    offset_encoding = offset_encoding;+    default_server_callbacks = default_server_callbacks;+    config = conf;+  }++  local function initialize()+    local valid_traces = {+      off = 'off'; messages = 'messages'; verbose = 'verbose';+    }+    local initialize_params = {+      -- The process Id of the parent process that started the server. Is null if+      -- the process has not been started by another process.  If the parent+      -- process is not alive then the server should exit (see exit notification)+      -- its process.+      processId = vim.loop.getpid();+      -- The rootPath of the workspace. Is null if no folder is open.+      --+      -- @deprecated in favour of rootUri.+      rootPath = nil;+      -- The rootUri of the workspace. Is null if no folder is open. If both+      -- `rootPath` and `rootUri` are set `rootUri` wins.+      rootUri = vim.uri_from_fname(vim.loop.cwd()); -- TODO which path to use?+--      rootUri = vim.uri_from_fname(vim.fn.expand(""%:p:h""));+      -- User provided initialization options.+      initializationOptions = conf.init_options;+      -- The capabilities provided by the client (editor or tool)+      capabilities = vim.tbl_deep_merge(protocol.make_client_capabilities(), capabilities);+      -- The initial trace setting. If omitted trace is disabled ('off').+      -- trace = 'off' | 'messages' | 'verbose';+      trace = valid_traces[conf.trace] or 'off';+      -- The workspace folders configured in the client when the server starts.+      -- This property is only available if the client supports workspace folders.+      -- It can be `null` if the client supports workspace folders but none are+      -- configured.+      --+      -- Since 3.6.0+      -- workspaceFolders?: WorkspaceFolder[] | null;+      -- export interface WorkspaceFolder {+      --  -- The associated URI for this workspace folder.+      --  uri+      --  -- The name of the workspace folder. Used to refer to this+      --  -- workspace folder in the user interface.+      --  name+      -- }+      workspaceFolders = nil;+    }+    _ = log.debug() and log.debug(log_prefix, ""initialize_params"", initialize_params)+    rpc.request('initialize', initialize_params, function(err, result)+      assert(not err, err)+      rpc.notify('initialized', {})+      client.initialized = true+      client.server_capabilities = assert(result.capabilities, ""initialize result doesn't contain capabilities"")+      client.resolved_capabilities = protocol.resolve_capabilities(client.server_capabilities)+      if conf.on_init then+        local status, err = pcall(conf.on_init, client, result)+        if not status then+          pcall(handlers.on_error, error_codes.ON_INIT_CALLBACK_ERROR, err)+        end+      end+      _ = log.debug() and log.debug(log_prefix, ""server_capabilities"", client.server_capabilities)+      _ = log.info() and log.info(log_prefix, ""initialized"", { resolved_capabilities = client.resolved_capabilities })++      -- Only assign after initialized?+      LSP_CLIENTS[client_id] = client+      -- If we had been registered before we start, then send didOpen This can+      -- happen if we attach to buffers before initialize finishes or if+      -- someone restarts a client.+      for bufnr, client_ids in pairs(BUFFER_CLIENT_IDS) do+        if client_ids[client_id] then+          client.text_document_did_open(bufnr)+        end+      end+    end)+  end++  local function unsupported_method(method)+    local msg = ""server doesn't support ""..method+    _ = log.warn() and log.warn(msg)+    vim.api.nvim_err_writeln(msg)+    return lsp_rpc.rpc_response_error(protocol.ErrorCodes.MethodNotFound, msg)+  end++  --- Checks capabilities before rpc.request-ing.+  function client.request(method, params, callback)+    _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, callback)+    -- TODO keep these checks or just let it go anyway?+    if (not client.resolved_capabilities.hover and method == 'textDocument/hover')+      or (not client.resolved_capabilities.signature_help and method == 'textDocument/signatureHelp')+      or (not client.resolved_capabilities.goto_definition and method == 'textDocument/definition')+      or (not client.resolved_capabilities.implementation and method == 'textDocument/implementation')+    then+      callback(unsupported_method(method))+      return+    end+    return rpc.request(method, params, callback)+  end++  function client.notify(...)+    return rpc.notify(...)+  end++  -- TODO Make sure these timeouts are ok or make configurable?+  function client.stop(force)+    local handle = rpc.handle+    if handle:is_closing() then+      return+    end+    if force then+      -- kill after 1s as a last resort.+      table.insert(timers, set_timeout(1e3, function() handle:kill(9) end))+      handle:kill(15)+      return+    end+    -- term after 100ms as a fallback+    table.insert(timers, set_timeout(1e2, function() handle:kill(15) end))+    -- kill after 1s as a last resort.+    table.insert(timers, set_timeout(1e3, function() handle:kill(9) end))+    -- Sending a signal after a process has exited is acceptable.+    rpc.request('shutdown', nil, function(err, result)+      if err == nil then+        rpc.notify('exit')+      else+        -- If there was an error in the shutdown request, then term to be safe.+        handle:kill(15)+      end+    end)+  end++  function client.text_document_did_open(bufnr)+    if not client.resolved_capabilities.text_document_open_close then+      return+    end+    local params = {+      textDocument = {+        version = 0;+        uri = vim.uri_from_bufnr(bufnr);+        -- TODO make sure our filetypes are compatible with languageId names.+        languageId = nvim_buf_get_option(bufnr, 'filetype');+        text = table.concat(nvim_buf_get_lines(bufnr, 0, -1, false), '\n');+      }+    }+    rpc.notify('textDocument/didOpen', params)+  end++  initialize()++  return client_id+end++local function once(fn)+  local value+  return function(...)+    if not value then value = fn(...) end+    return value+  end+end++local ENCODING_INDEX = { [""utf-8""] = 1; [""utf-16""] = 2; [""utf-32""] = 3; }+local function text_document_did_change_handler(_, bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size)+  _ = log.debug() and log.debug(""on_lines"", bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size)+  -- Don't do anything if there are no clients attached.+  if vim.tbl_isempty(BUFFER_CLIENT_IDS[bufnr] or {}) then+    return+  end+  local incremental_changes = once(function(client)+    -- TODO make sure this is correct. Sometimes this sends firstline = lastline and text = """"+    local size_index = ENCODING_INDEX[client.offset_encoding]+    local lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+    -- TODO The old implementation did this but didn't explain why.+    -- if new_lastline > firstline then+    --  table.insert(lines, '')+    -- end+    return {+      range = {+        start = { line = firstline, character = 0 };+        [""end""] = { line = lastline, character = 0 };+      };+      rangeLength = select(size_index, old_byte_size, old_utf16_size, old_utf32_size);+      text = table.concat(lines, '\n');+    };+  end)+  local full_changes = once(function()+    return {+      text = table.concat(nvim_buf_get_lines(bufnr, 0, -1, false), ""\n"");+    };+  end)+  local uri = vim.uri_from_bufnr(bufnr)+  for_each_buffer_client(bufnr, function(client, client_id)+    local text_document_did_change = client.resolved_capabilities.text_document_did_change+    local changes+    if text_document_did_change == protocol.TextDocumentSyncKind.None then+      return+    elseif text_document_did_change == protocol.TextDocumentSyncKind.Incremental then+      changes = incremental_changes(client)+    elseif text_document_did_change == protocol.TextDocumentSyncKind.Full then+      changes = full_changes(client)+    end+    client.notify(""textDocument/didChange"", {+      textDocument = {+        uri = uri;+        version = changedtick;+      };+      contentChanges = { changes; }+    })+  end)+end++-- Implements the textDocument/did* notifications required to track a buffer+-- for any language server.+--+-- This function could be implemented outside of the client function, since+-- it stands out alone as the only function which contains protocol+-- implementation details, but it's definitely easier to implement here.+function lsp.attach_to_buffer(bufnr, client_id)+  assert(type(client_id) == 'number', ""client_id must be a number"")+  bufnr = resolve_bufnr(bufnr)+  local buffer_client_ids = BUFFER_CLIENT_IDS[bufnr]+  -- This is our first time attaching to this buffer.+  if not buffer_client_ids then+    buffer_client_ids = {}+    BUFFER_CLIENT_IDS[bufnr] = buffer_client_ids++    nvim_command(string.format(""autocmd BufWritePost <buffer=%d> lua vim.lsp._text_document_did_save_handler(%d)"", bufnr, bufnr))+    local uri = vim.uri_from_bufnr(bufnr)++    -- First time, so attach and set up stuff.+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = text_document_did_change_handler;+      -- TODO this could be abstracted if on_detach passes the bufnr, but since+      -- there's no documentation, I have no idea if that happens.+      on_detach = function()+        local params = {+          textDocument = {+            uri = uri;+          }+        }+        for_each_buffer_client(bufnr, function(client, client_id)+          if client.resolved_capabilities.text_document_open_close then+            client.notify('textDocument/didClose', params)+          end+        end)+        BUFFER_CLIENT_IDS[bufnr] = nil+      end;+      -- TODO if we know all of the potential clients ahead of time, then we+      -- could conditionally set this.+      --      utf_sizes = size_index > 1;+      utf_sizes = true;+    })+  end+  if buffer_client_ids[client_id] then return end+  -- This is our first time attaching this client to this buffer.+  buffer_client_ids[client_id] = true++  local client = LSP_CLIENTS[client_id]+  -- Send didOpen for the client if it is initialized. If it isn't initialized+  -- then it will send didOpen on initialize.+  if client then+    client.text_document_did_open(bufnr)+  end+end++local LSP_CONFIGS = {}++function lsp.add_config(config)+  assert(type(config) == 'table', 'argument must be a table')+  assert(config.filetype, ""config must have 'filetype' key"")+  assert(config.cmd, ""config must have 'cmd' key"")+  assert(type(config.name) == 'string', ""config.name must be a string"")+  if LSP_CONFIGS[config.name] then+    -- If the client exists, then it is likely that they are doing some kind of+    -- reload flow, so let's not throw an error here.+    if LSP_CONFIGS[config.name].client_id then+      -- TODO log here? It might be unnecessarily annoying.+      return+    end+    error(string.format('A configuration with the name %q already exists. They must be unique', config.name))+  end+  local capabilities = config.capabilities or {}+  assert(type(capabilities) == 'table', ""config.capabilities must be a table"")++  local filetypes+  if type(config.filetype) == 'string' then+    filetypes = { config.filetype }+  elseif type(config.filetype) == 'table' then+    filetypes = config.filetype+  else+    error(""config.filetype must be a string or a list of strings"")+  end++  local offset_encoding = config.offset_encoding and validate_encoding(config.offset_encoding) or VALID_ENCODINGS.UTF16++  local cmd, cmd_args+  if type(config.cmd) == 'string' then+    -- Use a shell to execute the command if it is a string.+    cmd = vim.api.nvim_get_option('shell')+    cmd_args = {vim.api.nvim_get_option('shellcmdflag'), config.cmd}+  elseif vim.tbl_islist(config.cmd) then+    cmd = config.cmd[1]+    cmd_args = {}+    -- Don't mutate our input.+    for i, v in ipairs(config.cmd) do+      assert(type(v) == 'string', ""config.cmd arguments must be strings"")+      if i > 1 then+        table.insert(cmd_args, v)+      end+    end+  else+    error(""cmd type must be string or list."")+  end++  LSP_CONFIGS[config.name] = {+    user_config = config;+    name = config.name;+    offset_encoding = offset_encoding;+    filetypes = filetypes;+    cmd = cmd;+    cmd_args = cmd_args;+    cmd_env = config.cmd_env;+    cmd_cwd = config.cmd_cwd;+    capabilities = capabilities;+    init_options = config.init_options;+    on_init = config.on_init;+  }++  nvim_command(string.format(+    ""autocmd FileType %s ++once silent lua vim.lsp._start_client_by_name(%q)"",+    table.concat(filetypes, ','),+    config.name))+end++function lsp._start_client_by_name(name)+  local config = LSP_CONFIGS[name]+  -- If it exists and is running, don't make it again.+  if config.client_id and LSP_CLIENTS[config.client_id] then+    -- TODO log here?+    return+  end+  config.client_id = lsp.start_client(config)+  vim.lsp.attach_to_buffer(0, config.client_id)++  nvim_command(string.format(+    ""autocmd FileType %s silent lua vim.lsp.attach_to_buffer(0, %d)"",+    table.concat(config.filetypes, ','),+    config.client_id))+  return config.client_id+end++nvim_command(""autocmd VimLeavePre * lua vim.lsp.stop_all_clients()"")++function lsp.get_client_by_id(client_id)+  return LSP_CLIENTS[client_id]+end++function lsp.get_client_by_name(name)+  local config = LSP_CONFIGS[name]+  if config.client_id then+    return LSP_CLIENTS[config.client_id]+  end+end++function lsp.stop_client(client_id, force)+  local client = LSP_CLIENTS[client_id]+  if client then+    client.stop(force)+  end+end++function lsp.stop_all_clients(force)+  for client_id, client in pairs(LSP_CLIENTS) do+    client.stop(force)+  end+end++--- Send a request to a server and return the response+-- @param method [string]: Name of the request method+-- @param params [table] (optional): Arguments to send to the server+-- @param bufnr [number] (optional): The number of the buffer+-- @param filetype [string] (optional): The filetype associated with the server+-- @param server_name [string] (optional)+--+-- @returns: success?, request_id, cancel_fn+function lsp.buf_request(bufnr, method, params, callback)+  if callback then+    assert(type(callback) == 'function', ""buf_request callback must be a function"")+  end+  local client_request_ids = {}+  for_each_buffer_client(bufnr, function(client, client_id)+    local request_callback = callback+    if not request_callback then+      request_callback = client.default_server_callbacks[method]+        or error(string.format(""buf_request callback is empty and no default client was found for client %s"", client.name))+    end+    local request_success, request_id = client.request(method, params, function(err, result)+      -- TODO pass client here?+      request_callback(err, result, client_id)+    end)++    -- This could only fail if the client shut down in the time since we looked+    -- it up and we did the request, which should be rare.+    if request_success then+      client_request_ids[client_id] = request_id+    end+  end)++  local function cancel_request()+    for client_id, request_id in pairs(client_request_ids) do+      local client = LSP_CLIENTS[client_id]+      client.rpc.notify('$/cancelRequest', { id = request_id })+    end+  end++  return client_request_ids, cancel_request+end++--- Send a request to a server, but don't wait for the response+-- @param method [string]: Name of the request method+-- @param params [string]: Arguments to send to the server+-- @param cb [function|string] (optional): Either a function to call or a string to call in vim+-- @param bufnr [number] (optional): The number of the buffer+-- @param filetype [string] (optional): The filetype associated with the server+-- @param server_name [string] (optional)+--+-- @returns: The table of request id+function lsp.buf_request_sync(bufnr, method, params, timeout_ms)+  local request_results = {}+  local result_count = 0+  local function callback(err, result, client_id)+    _ = log.trace() and log.trace(""callback"", err, result, client_id)+    request_results[client_id] = { error = err, result = result }+    result_count = result_count + 1+  end+  local client_request_ids, cancel = lsp.buf_request(bufnr, method, params, callback)+  _ = log.trace() and log.trace(""client_request_ids"", client_request_ids)++  local expected_result_count = 0+  for _ in pairs(client_request_ids) do+    expected_result_count = expected_result_count + 1+  end+  _ = log.trace() and log.trace(""expected_result_count"", expected_result_count)+  local timeout = (timeout_ms or 100) + vim.loop.now()+  -- TODO is there a better way to sync this?+  while result_count < expected_result_count do+    _ = log.trace() and log.trace(""results"", result_count, request_results)+    if vim.loop.now() >= timeout then+      cancel()+      return nil, ""TIMEOUT""+    end+    -- TODO this really needs to be further looked at.+    nvim_command ""sleep 10m""","As long as the semantics and side effects are the same, I���d probably yield in a coroutine and wait otherwise. Fair point either way. ",
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11336,342861981,2019-11-06T00:11:51Z,runtime/lua/vim/lsp.lua,"@@ -0,0 +1,791 @@+local builtin_default_server_callbacks = require 'vim.lsp.builtin_callbacks'+local log = require 'vim.lsp.log'+local lsp_rpc = require 'vim.lsp.rpc'+local protocol = require 'vim.lsp.protocol'+local util = require 'vim.lsp.util'++local nvim_err_writeln, nvim_buf_get_lines, nvim_command, nvim_buf_get_option+  = vim.api.nvim_err_writeln, vim.api.nvim_buf_get_lines, vim.api.nvim_command, vim.api.nvim_buf_get_option++local lsp = {+  protocol = protocol;+}++-- TODO consider whether 'eol' or 'fixeol' should change the nvim_buf_get_lines that send.++local function resolve_bufnr(bufnr)+  if bufnr == nil or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++local function set_timeout(ms, fn)+  local timer = vim.loop.new_timer()+  timer:start(ms, 0, function()+    pcall(fn)+    timer:close()+  end)+  return timer+end++local VALID_ENCODINGS = {+  [""utf-8""] = 'utf-8'; [""utf-16""] = 'utf-16'; [""utf-32""] = 'utf-32';+  [""utf8""]  = 'utf-8'; [""utf16""]  = 'utf-16'; [""utf32""]  = 'utf-32';+  UTF8      = 'utf-8'; UTF16      = 'utf-16'; UTF32      = 'utf-32';+}++local CLIENT_INDEX = 0+local function next_client_id()+  CLIENT_INDEX = CLIENT_INDEX + 1+  return CLIENT_INDEX+end+local LSP_CLIENTS = {}+local BUFFER_CLIENT_IDS = {}++local function for_each_buffer_client(bufnr, callback)+  assert(type(callback) == 'function', ""callback must be a function"")+  bufnr = resolve_bufnr(bufnr)+  assert(type(bufnr) == 'number', ""bufnr must be a number"")+  local client_ids = BUFFER_CLIENT_IDS[bufnr]+  if not client_ids or vim.tbl_isempty(client_ids) then+    return+  end+  for client_id in pairs(client_ids) do+    local client = LSP_CLIENTS[client_id]+    -- This is unlikely to happen. Could only potentially happen in a race+    -- condition between literally a single statement.+    -- We could skip this error, but let's error for now.+    if not client then+      error(string.format("" Client %d has already shut down."", client_id))+    end+    callback(client, client_id)+  end+end++local function validate_encoding(encoding)+  assert(type(encoding) == 'string', ""encoding must be a string"")+  return VALID_ENCODINGS[encoding:lower()] or error(string.format(""Invalid offset encoding %q. Must be one of: 'utf-8', 'utf-16', 'utf-32'"", encoding))+end++local maxerrn = table.maxn(lsp_rpc.ERRORS)+local error_codes = vim.tbl_extend(""error"", lsp_rpc.ERRORS, vim.tbl_add_reverse_lookup {+  ON_INIT_CALLBACK_ERROR = maxerrn + 1;+})++--- Start a client and initialize it.+-- conf = {+--   cmd = string;+--   cmd_args = table;+--   cmd_cwd = string | nil;+--   cmd_end = table | nil;+--   offset_encoding = 'utf-8' | 'utf-16' | 'utf-32' | string;+--   name = string | nil;+--   trace = 'off' | 'messages' | 'verbose' | nil+--   default_server_callbacks = table | nil;+--   on_init = function | nil;+--   init_options = table | nil;+-- }+--+-- - `name` here is only used for logging/debugging.+-- - `trace` will be forwarded to the client.+-- - `default_server_callbacks` should be a table of functions which+-- defines:+--   - The handlers for notifications. These should be `function(params)`+--   - A default callback to use for `vim.lsp.buf_request` if one is not+--   provided at the time of calling `vim.lsp.buf_request`. These should be+--   `function(err, result)`+--   - By default, the functions from the module `vim.lsp.builtin_callbacks`+--   will be used. This parameter can override or extend it those builtin+--   callbacks.+--+-- You can use |vim.lsp.get_client_by_id()| to get the actual client.+--+-- NOTE: The client is only available *after* it has been initialized, which+-- may happen after a small delay (or never if there is an error).+-- For this reason, you may want to use `on_init` to do any actions once the+-- client has been initialized.+--+-- @return client_id+function lsp.start_client(conf)+  assert(type(conf.cmd) == 'string', ""conf.cmd must be a string"")+  assert(type(conf.cmd_args) == 'table', ""conf.cmd_args must be a table"")+  local offset_encoding = validate_encoding(conf.offset_encoding)+  -- TODO should I be using this for both notifications and request callbacks+  -- or separate those?+  local default_server_callbacks+  if conf.default_server_callbacks then+    assert(type(conf.default_server_callbacks) == 'table', ""conf.default_server_callbacks must be a table"")+    default_server_callbacks = vim.tbl_extend(""keep"", conf.default_server_callbacks, builtin_default_server_callbacks)+  else+    default_server_callbacks = builtin_default_server_callbacks+  end+  -- TODO keep vim.schedule here?+  for k, v in pairs(default_server_callbacks) do+    default_server_callbacks[k] = vim.schedule_wrap(v)+  end+  local capabilities = conf.capabilities or {}+  assert(type(capabilities) == 'table', ""conf.capabilities must be a table"")++  -- There are things sent by the server in the initialize response which+  -- contains capabilities that would be useful for completion engines, such as+  -- the character code triggers for completion and code action, so I'll expose this+  -- for now.+  if conf.on_init then+    assert(type(conf.on_init) == 'function', ""conf.on_init must be a function"")+  end+  if conf.on_exit then+    assert(type(conf.on_exit) == 'function', ""conf.on_exit must be a function"")+  end+  if conf.on_error then+    assert(type(conf.on_error) == 'function', ""conf.on_error must be a function"")+  end+  if conf.cmd_env then+    assert(type(conf.cmd_env) == 'table', ""conf.cmd_env must be a table"")+  end+  if conf.cmd_cwd then+    assert(type(conf.cmd_cwd) == 'string', ""conf.cmd_cwd must be a string"")+    local stat = vim.loop.fs_stat(conf.cmd_cwd)+    assert(stat and stat.type == 'directory', ""conf.cmd_cwd must be a directory"")+  end++  local client_id = next_client_id()++  local handlers = {}++  function handlers.notification(method, params)+    _ = log.debug() and log.debug('notification', method, params)+    local callback = default_server_callbacks[method]+    if callback then+      -- Method name is provided here for convenience.+      callback(params, method)+    end+  end++  function handlers.server_request(method, params)+    _ = log.debug() and log.debug('server_request', method, params)+    local request_callback = default_server_callbacks[method]+    if request_callback then+      return request_callback(params, method)+    end+    return nil, lsp_rpc.rpc_response_error(protocol.ErrorCodes.MethodNotFound)+  end++  local name = conf.name or tostring(client_id)+  assert(type(name) == 'string', ""conf.name must be a string"")+  local log_prefix = string.format(""LSP[%s]"", name)++  function handlers.on_error(code, err)+    _ = log.error() and log.error(log_prefix, ""on_error"", { code = error_codes[code], err = err })+    nvim_err_writeln(string.format('%s: Error %s: %q', log_prefix, error_codes[code], vim.inspect(err)))+    if conf.on_error then+      local status, usererr = pcall(conf.on_error, code, err)+      if not status then+        _ = log.error() and log.error(log_prefix, ""user on_error failed"", { err = usererr })+        nvim_err_writeln(log_prefix.."" user on_error failed: ""..tostring(usererr))+      end+    end+  end++  -- This is used because if there are outstanding timers (like for stop())+  -- they will block neovim exiting.+  local timers = {}+  function handlers.on_exit()+    for _, h in ipairs(timers) do+      h:stop()+      h:close()+    end+    LSP_CLIENTS[client_id] = nil+    for bufnr, client_ids in pairs(BUFFER_CLIENT_IDS) do+      client_ids[client_id] = nil+    end+    if conf.on_exit then pcall(conf.on_exit, client_id) end+  end++  local rpc = lsp_rpc.start(conf.cmd, conf.cmd_args, handlers, {+    cwd = conf.cmd_cwd;+    env = conf.cmd_env;+  })++  local client = {+    id = client_id;+    name = name;+    rpc = rpc;+    offset_encoding = offset_encoding;+    default_server_callbacks = default_server_callbacks;+    config = conf;+  }++  local function initialize()+    local valid_traces = {+      off = 'off'; messages = 'messages'; verbose = 'verbose';+    }+    local initialize_params = {+      -- The process Id of the parent process that started the server. Is null if+      -- the process has not been started by another process.  If the parent+      -- process is not alive then the server should exit (see exit notification)+      -- its process.+      processId = vim.loop.getpid();+      -- The rootPath of the workspace. Is null if no folder is open.+      --+      -- @deprecated in favour of rootUri.+      rootPath = nil;+      -- The rootUri of the workspace. Is null if no folder is open. If both+      -- `rootPath` and `rootUri` are set `rootUri` wins.+      rootUri = vim.uri_from_fname(vim.loop.cwd()); -- TODO which path to use?+--      rootUri = vim.uri_from_fname(vim.fn.expand(""%:p:h""));+      -- User provided initialization options.+      initializationOptions = conf.init_options;+      -- The capabilities provided by the client (editor or tool)+      capabilities = vim.tbl_deep_merge(protocol.make_client_capabilities(), capabilities);+      -- The initial trace setting. If omitted trace is disabled ('off').+      -- trace = 'off' | 'messages' | 'verbose';+      trace = valid_traces[conf.trace] or 'off';+      -- The workspace folders configured in the client when the server starts.+      -- This property is only available if the client supports workspace folders.+      -- It can be `null` if the client supports workspace folders but none are+      -- configured.+      --+      -- Since 3.6.0+      -- workspaceFolders?: WorkspaceFolder[] | null;+      -- export interface WorkspaceFolder {+      --  -- The associated URI for this workspace folder.+      --  uri+      --  -- The name of the workspace folder. Used to refer to this+      --  -- workspace folder in the user interface.+      --  name+      -- }+      workspaceFolders = nil;+    }+    _ = log.debug() and log.debug(log_prefix, ""initialize_params"", initialize_params)+    rpc.request('initialize', initialize_params, function(err, result)+      assert(not err, err)+      rpc.notify('initialized', {})+      client.initialized = true+      client.server_capabilities = assert(result.capabilities, ""initialize result doesn't contain capabilities"")+      client.resolved_capabilities = protocol.resolve_capabilities(client.server_capabilities)+      if conf.on_init then+        local status, err = pcall(conf.on_init, client, result)+        if not status then+          pcall(handlers.on_error, error_codes.ON_INIT_CALLBACK_ERROR, err)+        end+      end+      _ = log.debug() and log.debug(log_prefix, ""server_capabilities"", client.server_capabilities)+      _ = log.info() and log.info(log_prefix, ""initialized"", { resolved_capabilities = client.resolved_capabilities })++      -- Only assign after initialized?+      LSP_CLIENTS[client_id] = client+      -- If we had been registered before we start, then send didOpen This can+      -- happen if we attach to buffers before initialize finishes or if+      -- someone restarts a client.+      for bufnr, client_ids in pairs(BUFFER_CLIENT_IDS) do+        if client_ids[client_id] then+          client.text_document_did_open(bufnr)+        end+      end+    end)+  end++  local function unsupported_method(method)+    local msg = ""server doesn't support ""..method+    _ = log.warn() and log.warn(msg)+    vim.api.nvim_err_writeln(msg)+    return lsp_rpc.rpc_response_error(protocol.ErrorCodes.MethodNotFound, msg)+  end++  --- Checks capabilities before rpc.request-ing.+  function client.request(method, params, callback)+    _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, callback)+    -- TODO keep these checks or just let it go anyway?+    if (not client.resolved_capabilities.hover and method == 'textDocument/hover')+      or (not client.resolved_capabilities.signature_help and method == 'textDocument/signatureHelp')+      or (not client.resolved_capabilities.goto_definition and method == 'textDocument/definition')+      or (not client.resolved_capabilities.implementation and method == 'textDocument/implementation')+    then+      callback(unsupported_method(method))+      return+    end+    return rpc.request(method, params, callback)+  end++  function client.notify(...)+    return rpc.notify(...)+  end++  -- TODO Make sure these timeouts are ok or make configurable?+  function client.stop(force)+    local handle = rpc.handle+    if handle:is_closing() then+      return+    end+    if force then+      -- kill after 1s as a last resort.+      table.insert(timers, set_timeout(1e3, function() handle:kill(9) end))+      handle:kill(15)+      return+    end+    -- term after 100ms as a fallback+    table.insert(timers, set_timeout(1e2, function() handle:kill(15) end))+    -- kill after 1s as a last resort.+    table.insert(timers, set_timeout(1e3, function() handle:kill(9) end))+    -- Sending a signal after a process has exited is acceptable.+    rpc.request('shutdown', nil, function(err, result)+      if err == nil then+        rpc.notify('exit')+      else+        -- If there was an error in the shutdown request, then term to be safe.+        handle:kill(15)+      end+    end)+  end++  function client.text_document_did_open(bufnr)+    if not client.resolved_capabilities.text_document_open_close then+      return+    end+    local params = {+      textDocument = {+        version = 0;+        uri = vim.uri_from_bufnr(bufnr);+        -- TODO make sure our filetypes are compatible with languageId names.+        languageId = nvim_buf_get_option(bufnr, 'filetype');+        text = table.concat(nvim_buf_get_lines(bufnr, 0, -1, false), '\n');+      }+    }+    rpc.notify('textDocument/didOpen', params)+  end++  initialize()++  return client_id+end++local function once(fn)+  local value+  return function(...)+    if not value then value = fn(...) end+    return value+  end+end++local ENCODING_INDEX = { [""utf-8""] = 1; [""utf-16""] = 2; [""utf-32""] = 3; }+local function text_document_did_change_handler(_, bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size)+  _ = log.debug() and log.debug(""on_lines"", bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size)+  -- Don't do anything if there are no clients attached.+  if vim.tbl_isempty(BUFFER_CLIENT_IDS[bufnr] or {}) then+    return+  end+  local incremental_changes = once(function(client)+    -- TODO make sure this is correct. Sometimes this sends firstline = lastline and text = """"+    local size_index = ENCODING_INDEX[client.offset_encoding]+    local lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+    -- TODO The old implementation did this but didn't explain why.+    -- if new_lastline > firstline then+    --  table.insert(lines, '')+    -- end+    return {+      range = {+        start = { line = firstline, character = 0 };+        [""end""] = { line = lastline, character = 0 };+      };+      rangeLength = select(size_index, old_byte_size, old_utf16_size, old_utf32_size);+      text = table.concat(lines, '\n');+    };+  end)+  local full_changes = once(function()+    return {+      text = table.concat(nvim_buf_get_lines(bufnr, 0, -1, false), ""\n"");+    };+  end)+  local uri = vim.uri_from_bufnr(bufnr)+  for_each_buffer_client(bufnr, function(client, client_id)+    local text_document_did_change = client.resolved_capabilities.text_document_did_change+    local changes+    if text_document_did_change == protocol.TextDocumentSyncKind.None then+      return+    elseif text_document_did_change == protocol.TextDocumentSyncKind.Incremental then+      changes = incremental_changes(client)+    elseif text_document_did_change == protocol.TextDocumentSyncKind.Full then+      changes = full_changes(client)+    end+    client.notify(""textDocument/didChange"", {+      textDocument = {+        uri = uri;+        version = changedtick;+      };+      contentChanges = { changes; }+    })+  end)+end++-- Implements the textDocument/did* notifications required to track a buffer+-- for any language server.+--+-- This function could be implemented outside of the client function, since+-- it stands out alone as the only function which contains protocol+-- implementation details, but it's definitely easier to implement here.+function lsp.attach_to_buffer(bufnr, client_id)+  assert(type(client_id) == 'number', ""client_id must be a number"")+  bufnr = resolve_bufnr(bufnr)+  local buffer_client_ids = BUFFER_CLIENT_IDS[bufnr]+  -- This is our first time attaching to this buffer.+  if not buffer_client_ids then+    buffer_client_ids = {}+    BUFFER_CLIENT_IDS[bufnr] = buffer_client_ids++    nvim_command(string.format(""autocmd BufWritePost <buffer=%d> lua vim.lsp._text_document_did_save_handler(%d)"", bufnr, bufnr))+    local uri = vim.uri_from_bufnr(bufnr)++    -- First time, so attach and set up stuff.+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = text_document_did_change_handler;+      -- TODO this could be abstracted if on_detach passes the bufnr, but since+      -- there's no documentation, I have no idea if that happens.+      on_detach = function()+        local params = {+          textDocument = {+            uri = uri;+          }+        }+        for_each_buffer_client(bufnr, function(client, client_id)+          if client.resolved_capabilities.text_document_open_close then+            client.notify('textDocument/didClose', params)+          end+        end)+        BUFFER_CLIENT_IDS[bufnr] = nil+      end;+      -- TODO if we know all of the potential clients ahead of time, then we+      -- could conditionally set this.+      --      utf_sizes = size_index > 1;+      utf_sizes = true;+    })+  end+  if buffer_client_ids[client_id] then return end+  -- This is our first time attaching this client to this buffer.+  buffer_client_ids[client_id] = true++  local client = LSP_CLIENTS[client_id]+  -- Send didOpen for the client if it is initialized. If it isn't initialized+  -- then it will send didOpen on initialize.+  if client then+    client.text_document_did_open(bufnr)+  end+end++local LSP_CONFIGS = {}++function lsp.add_config(config)+  assert(type(config) == 'table', 'argument must be a table')+  assert(config.filetype, ""config must have 'filetype' key"")+  assert(config.cmd, ""config must have 'cmd' key"")+  assert(type(config.name) == 'string', ""config.name must be a string"")+  if LSP_CONFIGS[config.name] then+    -- If the client exists, then it is likely that they are doing some kind of+    -- reload flow, so let's not throw an error here.+    if LSP_CONFIGS[config.name].client_id then+      -- TODO log here? It might be unnecessarily annoying.+      return+    end+    error(string.format('A configuration with the name %q already exists. They must be unique', config.name))+  end+  local capabilities = config.capabilities or {}+  assert(type(capabilities) == 'table', ""config.capabilities must be a table"")++  local filetypes+  if type(config.filetype) == 'string' then+    filetypes = { config.filetype }+  elseif type(config.filetype) == 'table' then+    filetypes = config.filetype+  else+    error(""config.filetype must be a string or a list of strings"")+  end++  local offset_encoding = config.offset_encoding and validate_encoding(config.offset_encoding) or VALID_ENCODINGS.UTF16++  local cmd, cmd_args+  if type(config.cmd) == 'string' then+    -- Use a shell to execute the command if it is a string.+    cmd = vim.api.nvim_get_option('shell')+    cmd_args = {vim.api.nvim_get_option('shellcmdflag'), config.cmd}+  elseif vim.tbl_islist(config.cmd) then+    cmd = config.cmd[1]+    cmd_args = {}+    -- Don't mutate our input.+    for i, v in ipairs(config.cmd) do+      assert(type(v) == 'string', ""config.cmd arguments must be strings"")+      if i > 1 then+        table.insert(cmd_args, v)+      end+    end+  else+    error(""cmd type must be string or list."")+  end++  LSP_CONFIGS[config.name] = {+    user_config = config;+    name = config.name;+    offset_encoding = offset_encoding;+    filetypes = filetypes;+    cmd = cmd;+    cmd_args = cmd_args;+    cmd_env = config.cmd_env;+    cmd_cwd = config.cmd_cwd;+    capabilities = capabilities;+    init_options = config.init_options;+    on_init = config.on_init;+  }++  nvim_command(string.format(+    ""autocmd FileType %s ++once silent lua vim.lsp._start_client_by_name(%q)"",+    table.concat(filetypes, ','),+    config.name))+end++function lsp._start_client_by_name(name)+  local config = LSP_CONFIGS[name]+  -- If it exists and is running, don't make it again.+  if config.client_id and LSP_CLIENTS[config.client_id] then+    -- TODO log here?+    return+  end+  config.client_id = lsp.start_client(config)+  vim.lsp.attach_to_buffer(0, config.client_id)++  nvim_command(string.format(+    ""autocmd FileType %s silent lua vim.lsp.attach_to_buffer(0, %d)"",+    table.concat(config.filetypes, ','),+    config.client_id))+  return config.client_id+end++nvim_command(""autocmd VimLeavePre * lua vim.lsp.stop_all_clients()"")++function lsp.get_client_by_id(client_id)+  return LSP_CLIENTS[client_id]+end++function lsp.get_client_by_name(name)+  local config = LSP_CONFIGS[name]+  if config.client_id then+    return LSP_CLIENTS[config.client_id]+  end+end++function lsp.stop_client(client_id, force)+  local client = LSP_CLIENTS[client_id]+  if client then+    client.stop(force)+  end+end++function lsp.stop_all_clients(force)+  for client_id, client in pairs(LSP_CLIENTS) do+    client.stop(force)+  end+end++--- Send a request to a server and return the response+-- @param method [string]: Name of the request method+-- @param params [table] (optional): Arguments to send to the server+-- @param bufnr [number] (optional): The number of the buffer+-- @param filetype [string] (optional): The filetype associated with the server+-- @param server_name [string] (optional)+--+-- @returns: success?, request_id, cancel_fn+function lsp.buf_request(bufnr, method, params, callback)","I'm not sure, but I thought it would make it very clear what it was doing. It is operating on the buffer, and it kind of follows other naming schemes for neovim functions.",
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/11336,344430922,2019-11-09T06:07:28Z,runtime/lua/vim/uri.lua,"@@ -29,7 +28,12 @@ do     -- https://tools.ietf.org/html/rfc3986#section-2.2     rfc3986 = ""^A-Za-z0-9%-._~!$&'()*+,;=:@/"";   }-  local tohex, sbyte = bit.tohex, string.byte+  local sbyte, tohex = string.byte+  if jit then+    tohex = require'bit'.tohex+  else+    tohex = function(b) return string.format(""%02x"", b) end+  end","I think this might not be necessary, if people chose to build neovim with another lua than luajit they're supposed to make the bitop package a dependency ( https://github.com/neovim/neovim/issues/11301#issuecomment-546668666 ).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11356,344509826,2019-11-10T19:26:53Z,runtime/doc/api.txt,"@@ -1747,6 +1783,78 @@ nvim_buf_get_mark({buffer}, {name})                      *nvim_buf_get_mark()*                 Return: ~                     (row, col) tuple +                                                *nvim_buf_get_extmark_by_id()*+nvim_buf_get_extmark_by_id({buffer}, {namespace}, {id})+                Returns position info for a given extmark id++                Parameters: ~+                    {buffer}     The buffer handle+                    {namespace}  a identifier returned previously with+                                 nvim_create_namespace+                    {id}         the extmark id++                Return: ~+                    (row, col) tuple or empty list () if extmark id was absent++                                                     *nvim_buf_get_extmarks()*+nvim_buf_get_extmarks({buffer}, {ns_id}, {start}, {end}, {amount})+                List extmarks in a range (inclusive)++                range ends can be specified as (row, col) tuples, as well as+                extmark ids in the same namespace. In addition, 0 and -1 works+                as shorthands for (0,0) and (-1,-1) respectively, so that all+                marks in the buffer can be quieried as:++                all_marks = nvim_buf_get_extmarks(0, my_ns, 0, -1, -1)++                If end is a lower position than start, then the range will be+                traversed backwards. This is mostly used with limited amount,+                to be able to get the first marks prior to a given position.++                Parameters: ~+                    {buffer}     The buffer handle+                    {namespace}  An id returned previously from",wrong parameter names (also other functions),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11307,344580808,2019-11-11T07:11:09Z,src/nvim/lua/vim.lua,"@@ -261,14 +261,13 @@ end   -- vim.fn.{func}(...)-local function fn_index(t, key)-  local function func(...)+local function _fn_index(t, key)+  t[key] = function(...)     return vim.call(key, ...)   end-  t[key] = func-  return func+  return t[key] end-local fn = setmetatable({}, {__index=fn_index})+local fn = setmetatable({}, {__index=_fn_index})","@bfredl JFI: renaming these so that `gen_vimdoc.py` does not think they're ""public"" (and it makes semantic sense anyway)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11159,345699732,2019-11-13T11:10:32Z,src/nvim/api/vim.c,"@@ -85,6 +86,54 @@ void api_vim_free_all_mem(void)   map_free(String, handle_T)(namespace_ids); } +void nvim_source(String command, Error *err) FUNC_API_SINCE(7)","Missing docstring. Doesn't need be long, just something like ""execute a multiline block of ex commands from a string"" and list the args.`command` arg should be renamed though, at it is probably not a single command. Maybe `src` ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11390,346170146,2019-11-14T08:06:37Z,src/nvim/os/os_win_conpty.c,"@@ -0,0 +1,181 @@+#include <uv.h>",not sure if PVS studio works at source level but maybe add [the header](https://github.com/neovim/neovim/blob/21fdfc87284d4f58bc17883429b0a152013c618a/src/nvim/os/tty.c#L1) anyways.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11390,346214077,2019-11-14T09:47:59Z,src/nvim/os/pty_process_win.c,"@@ -192,8 +229,18 @@ void pty_process_resize(PtyProcess *ptyproc, uint16_t width,                         uint16_t height)   FUNC_ATTR_NONNULL_ALL {-  if (ptyproc->winpty_object != NULL) {-    winpty_set_size(ptyproc->winpty_object, width, height, NULL);+  if (ptyproc->type == PTY_TYPE_CONPTY+      && ptyproc->pty_object.conpty_object != NULL) {+    assert(width <= SHRT_MAX);+    assert(height <= SHRT_MAX);+    COORD size = { (int16_t)width, (int16_t)height };+    if (pResizePseudoConsole(+        ptyproc->pty_object.conpty_object->pty, size) != S_OK) {+      ELOG(""ResizePseudoConsoel failed: error code: %d"",+           os_translate_sys_error((int)GetLastError()));+    }+  } else if (ptyproc->pty_object.winpty_object != NULL) {+    winpty_set_size(ptyproc->pty_object.winpty_object, width, height, NULL);","can we hide the win32 API code in something similar to `winpty_set_size` (preferably in `os_win_conpty.c` or similar isolated module)? We want to minimize the ""scattered"" changes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11390,346692485,2019-11-15T07:36:24Z,src/nvim/os/pty_process_win.c,"@@ -12,6 +12,7 @@ #include ""nvim/memory.h"" #include ""nvim/mbyte.h""  // for utf8_to_utf16, utf16_to_utf8 #include ""nvim/os/pty_process_win.h""+#include ""nvim/os/os_win_conpty.h""","Let's try to follow the naming pattern of other `os/*_win.{h,c}` files. Instead of `os/os_win_conpty.h`, I suggest:    os/pty_conpty_win.hThat helps discovery because `pty_*` files will sort next to each other.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11390,346693137,2019-11-15T07:38:53Z,src/nvim/os/pty_process_win.h,"@@ -6,12 +6,22 @@  #include ""nvim/event/process.h"" #include ""nvim/lib/queue.h""+#include ""nvim/os/os_win_conpty.h""++typedef enum {+  PTY_TYPE_WINPTY,+  PTY_TYPE_CONPTY+} pty_type_t;","normally we use this naming convention:```typedef enum {  kWinpty,  kConPty,} PtyType;```",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/11412,347150188,2019-11-17T18:03:21Z,third-party/cmake/BuildLuajit.cmake,"@@ -47,9 +47,18 @@ if(CMAKE_SYSTEM_NAME MATCHES ""OpenBSD"") else()   set(AMD64_ABI """") endif()+if(CMAKE_SYSTEM_NAME MATCHES ""Darwin"")+  check_c_compiler_flag(-fno-stack-check HAS_NO_STACK_CHECK)+  if(HAS_NO_STACK_CHECK)+    set(NO_STACK_CHECK ""CFLAGS+=-fno-stack-check"")+  endif()+else()+  set(NO_STACK_CHECK """")+endif()","My cmake-foo is bad. Do variables have to be defined before use or are they just empty in such cases (like in shell scripts)?In the latter case, the `else()` could be left away. In the former case, `NO_STACK_CHECK` won't be defined if `Darwin` and empty `HAS_NO_STACK_CHECK`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11290,347159229,2019-11-17T21:01:29Z,src/nvim/tui/tui.c,"@@ -134,6 +136,7 @@ typedef struct { static bool volatile got_winch = false; static bool did_user_set_dimensions = false; static bool cursor_style_enabled = false;+static bool tmux = false;","""Not worth changing"" was referring to `did_user_set_dimensions` et al. Whereas `tmux` is being changed already in this PR, so it should not continue the pattern. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11390,347201915,2019-11-18T05:00:10Z,src/nvim/option_defs.h,"@@ -645,6 +645,7 @@ EXTERN char_u *p_titleold;      ///< 'titleold' EXTERN char_u *p_titlestring;   ///< 'titlestring' EXTERN char_u *p_tsr;           ///< 'thesaurus' EXTERN int p_tgc;               ///< 'termguicolors'+EXTERN char_u *p_twt;           ///< 'termwintype'","I'm really not in favor of this. If it turns out to be a serious problem, we can revisit it later. The ""preview"" status of conpty is temporary. If it has any problems, they will go away as time goes on. Whereas the extra code and documentation we would add for the extra option, won't go away.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11375,348089055,2019-11-19T18:17:06Z,test/functional/helpers.lua,"@@ -23,28 +23,28 @@ local sleep = global_helpers.sleep local tbl_contains = global_helpers.tbl_contains local write_file = global_helpers.write_file -local module = {+local helper = {   NIL = mpack.NIL,   mkdir = lfs.mkdir, }  local start_dir = lfs.currentdir()-module.nvim_prog = (+helper.nvim_prog = (   os.getenv('NVIM_PRG')   or global_helpers.test_build_dir .. '/bin/nvim' ) -- Default settings for the test session.-module.nvim_set = (+helper.nvim_set = (","IIRC I've used `global_helpers` for `tests/helper.lua` initially (when adding the pattern) - not a much better name, but the idea was the it helps with generated tags.So here `functional_helpers` could be used.But I agree that ""helper"" is very generic.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11280,348342357,2019-11-20T08:23:21Z,runtime/ftplugin/man.vim,"@@ -20,13 +20,13 @@ setlocal wrap breakindent linebreak setlocal nonumber norelativenumber setlocal foldcolumn=0 colorcolumn=0 nolist nofoldenable +setlocal tagfunc=man#goto_tag+ if !exists('g:no_plugin_maps') && !exists('g:no_man_maps')   nnoremap <silent> <buffer> j          gj   nnoremap <silent> <buffer> k          gk   nnoremap <silent> <buffer> gO         :call man#show_toc()<CR>-  nnoremap <silent> <buffer> <C-]>      :Man<CR>   nnoremap <silent> <buffer> K          :Man<CR>-  nnoremap <silent> <buffer> <C-T>      :call man#pop_tag()<CR>","I suppose `K` should be mapped to `<C-]>` now? But I'll leave it as-is, since I noticed a difference: with e.g. `:Man git-notes`, cursor at the caret position:```GIT       Part of the git(1) suite                        ^````K` (mapped to `:Man<CR>`) follows the `git(1)` reference correctly ,whereas `<c-]>` searches for `suite`.Example 2: with the cursor on `glob(7)`:```pcrepattern(3), terminfo(5), glob(7), regex(7).````K` correctly goes to section 7, whereas `<c-]>` goes to section 3.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11428,348707534,2019-11-20T19:40:14Z,.travis.yml,"@@ -145,6 +144,33 @@ jobs:       env:         - CLANG_SANITIZER=TSAN         - *common-job-env+    - if: type != pull+      name: snap build","""build"" is redundant in a list of travis jobs.```suggestion      name: snap```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11442,349905855,2019-11-24T06:58:05Z,src/nvim/lua/vim.lua,"@@ -187,10 +189,9 @@ end ---                - 2: continues the paste (zero or more times) ---                - 3: ends the paste (exactly once) --@returns false if client should cancel the paste.-local function paste(lines, phase) end  -- luacheck: no unused","this was here for the doc generator...```suggestionfunction vim.paste(lines, phase) end  -- luacheck: no unused```",
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11442,349906221,2019-11-24T07:11:04Z,src/nvim/CMakeLists.txt,"@@ -53,6 +53,8 @@ set(UNICODE_DIR ${PROJECT_SOURCE_DIR}/unicode) set(GENERATED_UNICODE_TABLES ${GENERATED_DIR}/unicode_tables.generated.h) set(VIM_MODULE_FILE ${GENERATED_DIR}/lua/vim_module.generated.h) set(VIM_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/src/nvim/lua/vim.lua)+set(SHARED_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/shared.lua)+set(INSPECT_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/inspect.lua)",Personally I'm wondering why we can't just inline those into the area they're being used since they are only used once. But I agree about consistent naming otherwise,
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11442,349907036,2019-11-24T07:35:06Z,src/nvim/CMakeLists.txt,"@@ -317,11 +319,15 @@ add_custom_command(  add_custom_command(   OUTPUT ${VIM_MODULE_FILE}-  COMMAND ${LUA_PRG} ${CHAR_BLOB_GENERATOR} ${VIM_MODULE_SOURCE}-                     ${VIM_MODULE_FILE} vim_module+  COMMAND ${LUA_PRG} ${CHAR_BLOB_GENERATOR} ${VIM_MODULE_FILE}+      ${LUA_VIM_MODULE_SOURCE} vim_module+      ${LUA_SHARED_MODULE_SOURCE} shared_module+      ${LUA_INSPECT_MODULE_SOURCE} inspect_module",Yeah I accidentally left it. I have some changes committed but not pushed. Good catch though.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11442,349907281,2019-11-24T07:42:29Z,src/nvim/lua/vim.lua,"@@ -230,31 +231,42 @@ paste = (function()     end     return true  -- Paste will not continue if not returning `true`.   end-end)()+end  --- Defers callback `cb` until the Nvim API is safe to call. --- ---@see |lua-loop-callbacks| ---@see |vim.schedule()| ---@see |vim.in_fast_event()|-local function schedule_wrap(cb)+function vim.schedule_wrap(cb)   return (function (...)     local args = {...}     vim.schedule(function() cb(unpack(args)) end)   end) end +vim._update_package_paths = _update_package_paths+vim._os_proc_children = _os_proc_children+vim._os_proc_info = _os_proc_info+vim._system = _system","you mean to avoid search/replace churn? Would be better to do the search-replace, to avoid people accidentally copying this pattern.",
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11452,349966101,2019-11-25T01:41:27Z,runtime/lua/vim/lsp/util.lua,"@@ -303,6 +310,78 @@ function M.make_floating_popup_options(width, height, opts)   } end +-- local function update_tagstack()","tbh I don't know what this function does, so I'm hiding it but keeping it for reference in case someone wants to do something with it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11452,349966876,2019-11-25T01:48:49Z,runtime/lua/vim/lsp/util.lua,"@@ -303,6 +310,78 @@ function M.make_floating_popup_options(width, height, opts)   } end +-- local function update_tagstack()","If it actually works(ed) then following a tag (i.e. ""go to definition"") will update the list reported by `:tags`, and `ctrl-t` will go back in the ""history"" of go-to-definition actions.If it doesn't work, just remove it, but in the `-- update_tagstack` line in `jump_to_location`, mention the SHA so its impl can be found easily.In any case 'tagfunc' would probably be the preferred way to achieve this feature.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11452,350055027,2019-11-25T09:03:42Z,runtime/lua/vim/lsp/util.lua,"@@ -303,6 +310,55 @@ function M.make_floating_popup_options(width, height, opts)   } end +function M.jump_to_location(location)+  if location.uri == nil then return end+  local bufnr = vim.uri_to_bufnr(location.uri)+  -- TODO(ashkan) this function was removed because I didn't fully comprehend+  -- the tagstack and it was a holdover from the previous LSP efforts. If+  -- someone wants to work on this and enable it, they can find it in the+  -- commit d5aaad14ecdd2047089e1a018e97af1f790b3e42 in the file+  -- `runtime/lua/vim/lsp/buf.lua` at line 103.+  -- update_tagstack()",1-line comment (+ 12-char SHA) is enough (the longer explanation could be in the commit message):```suggestion  -- TODO(ashkan): see d5aaad14ecdd for impl  -- update_tagstack()```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11452,350061266,2019-11-25T09:16:44Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -0,0 +1,223 @@+local log = require 'vim.lsp.log'+local protocol = require 'vim.lsp.protocol'+local util = require 'vim.lsp.util'+local vim = vim+local api = vim.api++local M = {}++local function err_message(...)+  api.nvim_err_writeln(table.concat(vim.tbl_flatten{...}))+  api.nvim_command(""redraw"")+end++M['workspace/applyEdit'] = function(_, _, workspace_edit)+  if not workspace_edit then return end+  -- TODO(ashkan) Do something more with label?+  if workspace_edit.label then+    print(""Workspace edit"", workspace_edit.label)+  end+  util.apply_workspace_edit(workspace_edit.edit)+end++M['textDocument/publishDiagnostics'] = function(_, _, result)+  if not result then return end+  local uri = result.uri+  local bufnr = vim.uri_to_bufnr(uri)+  if not bufnr then+    err_message(""LSP.publishDiagnostics: Couldn't find buffer for "", uri)+    return+  end+  util.buf_clear_diagnostics(bufnr)+  util.buf_diagnostics_save_positions(bufnr, result.diagnostics)+  util.buf_diagnostics_underline(bufnr, result.diagnostics)+  util.buf_diagnostics_virtual_text(bufnr, result.diagnostics)+  -- util.set_loclist(result.diagnostics)+end++M['textDocument/references'] = function(_, _, result)+  if not result then return end+  util.set_qflist(result)+  api.nvim_command(""copen"")+  api.nvim_command(""wincmd p"")+end++M['textDocument/rename'] = function(_, _, result)+  if not result then return end+  util.apply_workspace_edit(result)+end++M['textDocument/rangeFormatting'] = function(_, _, result)+  if not result then return end+  util.apply_text_edits(result)+end++M['textDocument/formatting'] = function(_, _, result)+  if not result then return end+  util.apply_text_edits(result)+end++M['textDocument/completion'] = function(_, _, result)+  if vim.tbl_isempty(result or {}) then return end+  local row, col = unpack(api.nvim_win_get_cursor(0))+  local line = assert(api.nvim_buf_get_lines(0, row-1, row, false)[1])+  local line_to_cursor = line:sub(col+1)++  local matches = util.text_document_completion_list_to_complete_items(result, line_to_cursor)+  vim.fn.complete(col, matches)+end++M['textDocument/hover'] = function(_, method, result)+  util.focusable_preview(method, function()+    if not (result and result.contents) then+      return { 'No information available' }+    end+    local markdown_lines = util.convert_input_to_markdown_lines(result.contents)+    markdown_lines = util.trim_empty_lines(markdown_lines)+    if vim.tbl_isempty(markdown_lines) then+      return { 'No information available' }+    end+    return markdown_lines, util.try_trim_markdown_code_blocks(markdown_lines)+  end)+end++local function location_callback(_, method, result)+  if result == nil or vim.tbl_isempty(result) then+    local _ = log.info() and log.info(method, 'No location found')+    return nil+  end+  util.jump_to_location(result[1])+  if #result > 1 then+    util.set_qflist(result)+    api.nvim_command(""copen"")+    api.nvim_command(""wincmd p"")+  end+end++M['textDocument/declaration'] = location_callback+M['textDocument/definition'] = location_callback+M['textDocument/typeDefinition'] = location_callback+M['textDocument/implementation'] = location_callback++--- Convert SignatureHelp response to preview contents.+-- https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_signatureHelp+local function signature_help_to_preview_contents(input)+  if not input.signatures then+    return+  end+  --The active signature. If omitted or the value lies outside the range of+  --`signatures` the value defaults to zero or is ignored if `signatures.length+  --=== 0`. Whenever possible implementors should make an active decision about+  --the active signature and shouldn't rely on a default value.+  local contents = {}+  local active_signature = input.activeSignature or 0+  -- If the activeSignature is not inside the valid range, then clip it.+  if active_signature >= #input.signatures then+    active_signature = 0+  end+  local signature = input.signatures[active_signature + 1]+  if not signature then+    return+  end+  vim.list_extend(contents, vim.split(signature.label, '\n', true))+  if signature.documentation then+    util.convert_input_to_markdown_lines(signature.documentation, contents)+  end+  if input.parameters then+    local active_parameter = input.activeParameter or 0+    -- If the activeParameter is not inside the valid range, then clip it.+    if active_parameter >= #input.parameters then+      active_parameter = 0+    end+    local parameter = signature.parameters and signature.parameters[active_parameter]+    if parameter then+      --[=[+      --Represents a parameter of a callable-signature. A parameter can+      --have a label and a doc-comment.+      interface ParameterInformation {+        --The label of this parameter information.+        --+        --Either a string or an inclusive start and exclusive end offsets within its containing+        --signature label. (see SignatureInformation.label). The offsets are based on a UTF-16+        --string representation as `Position` and `Range` does.+        --+        --*Note*: a label of type string should be a substring of its containing signature label.+        --Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.+        label: string | [number, number];+        --The human-readable doc-comment of this parameter. Will be shown+        --in the UI but can be omitted.+        documentation?: string | MarkupContent;+      }+      --]=]+      -- TODO highlight parameter+      if parameter.documentation then+        util.convert_input_to_markdown_lines(parameter.documentation, contents)+      end+    end+  end+  return contents+end++M['textDocument/signatureHelp'] = function(_, method, result)+  util.focusable_preview(method, function()+    if not (result and result.signatures and result.signatures[1]) then+      return { 'No signature available' }+    end+    -- TODO show popup when signatures is empty?+    local lines = signature_help_to_preview_contents(result)+    lines = util.trim_empty_lines(lines)+    if vim.tbl_isempty(lines) then+      return { 'No signature available' }+    end+    return lines, util.try_trim_markdown_code_blocks(lines)+  end)+end++M['textDocument/peekDefinition'] = function(_, _, result, _)+  if not (result and result[1]) then return end+  local loc = result[1]+  local bufnr = vim.uri_to_bufnr(loc.uri) or error(""couldn't find file ""..tostring(loc.uri))","brevity, plus colon (:) is a good visual add/convention to let user guess the ""parameterized"" part of the message.```suggestion  local bufnr = vim.uri_to_bufnr(loc.uri) or error(""not found: ""..tostring(loc.uri))```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11452,350128900,2019-11-25T11:28:45Z,runtime/lua/vim/lsp/util.lua,"@@ -303,6 +310,55 @@ function M.make_floating_popup_options(width, height, opts)   } end +function M.jump_to_location(location)+  if location.uri == nil then return end+  local bufnr = vim.uri_to_bufnr(location.uri)+  -- TODO(ashkan) this function was removed because I didn't fully comprehend+  -- the tagstack and it was a holdover from the previous LSP efforts. If+  -- someone wants to work on this and enable it, they can find it in the+  -- commit d5aaad14ecdd2047089e1a018e97af1f790b3e42 in the file+  -- `runtime/lua/vim/lsp/buf.lua` at line 103.+  -- update_tagstack()","I think is correct that this should _not_ use the tagstack. For those that want to to use tag behavior with LSP, we should provide a 'tagfunc' implementation. But using a function like `update_tagstack()` to emulate tagstack behavior is an anti-pattern to start width.  So I think we can just delete this entire comment (or perhaps write ""a 'tagfunc' implementation would be a good complement"").",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11290,351733377,2019-11-28T11:36:06Z,test/functional/terminal/tui_spec.lua,"@@ -831,6 +831,22 @@ describe('TUI', function()       {3:-- TERMINAL --}                                    |     ]=])   end)++  it('forwards unknown DCS/OSC sequences to outer terminal', function()+    local received++    screen._handle_term_unhandled = function(command)+      received = command+    end++    local unknown_dcs_seq = '\033Pblah\033\\'+    feed_data(unknown_dcs_seq)+    eq(unknown_dcs_seq, received)","You must run the event loop in order for handlers to be called. So this needs to be ```screen:expect{condition=function()  eq(unknown_dcs_seq, received)end}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11428,351969073,2019-11-29T03:25:30Z,.travis.yml,"@@ -145,6 +158,35 @@ jobs:       env:         - CLANG_SANITIZER=TSAN         - *common-job-env+    - if: type != pull_request+      name: snap+      os: linux+      env:+        - LC_ALL: C.UTF-8+        - LANG: C.UTF-8+        - SNAPCRAFT_ENABLE_SILENT_REPORT: y+        - SNAPCRAFT_ENABLE_DEVELOPER_DEBUG: y+      addons:+        snaps:+          - name: snapcraft+            channel: stable+            classic: true+          - name: http+          - name: transfer+          - name: lxd+            channel: stable+      before_install: /bin/true",@hurricanehrndz can this `before_install` (and similar `before_cache`) be removed?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11473,351973070,2019-11-29T03:54:24Z,Makefile,"@@ -119,8 +119,14 @@ oldtest: | nvim build/runtime/doc/tags ifeq ($(strip $(TEST_FILE)),) 	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" $(MAKEOVERRIDES) else-	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" SCRIPTS= $(MAKEOVERRIDES) $(TEST_FILE)+	@# Handle TEST_FILE=test_foo{,.res,.vim}.+	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" \+	  $(patsubst %.vim,%,$(patsubst %.res,%,$(TEST_FILE))) SCRIPTS= $(MAKEOVERRIDES) endif+# Build oldtest by specifying the .vim filename.+.PHONY: phony_force+src/nvim/testdir/%.vim: phony_force+	$(MAKE) oldtest SCRIPTS= NEW_TESTS_RES=$(patsubst src/nvim/testdir/%.vim,%.res,$@)","> also goes into the direction of the `test/run.sh` script I suggested somewhere, and where you've said it would be better to have it in / via the Makefile.`test/run.sh` is yet more indirection... definitely better to keep things in the Makefile, if it's something that's really needed at all. But that's also a compromise because CMake is the build system, not make...I also am uncomfortable with gold-plating ""oldtest"" in general. `TEST_FILE=foo.vim` is good to have for parallel form with the Lua tests. That's the only reason. ",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11473,351975782,2019-11-29T04:17:17Z,Makefile,"@@ -119,8 +119,14 @@ oldtest: | nvim build/runtime/doc/tags ifeq ($(strip $(TEST_FILE)),) 	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" $(MAKEOVERRIDES) else-	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" SCRIPTS= $(MAKEOVERRIDES) $(TEST_FILE)+	@# Handle TEST_FILE=test_foo{,.res,.vim}.+	+$(SINGLE_MAKE) -C src/nvim/testdir NVIM_PRG=""$(realpath build/bin/nvim)"" \+	  $(patsubst %.vim,%,$(patsubst %.res,%,$(TEST_FILE))) SCRIPTS= $(MAKEOVERRIDES) endif+# Build oldtest by specifying the .vim filename.+.PHONY: phony_force+src/nvim/testdir/%.vim: phony_force+	$(MAKE) oldtest SCRIPTS= NEW_TESTS_RES=$(patsubst src/nvim/testdir/%.vim,%.res,$@)","> But that's also a compromise because CMake is the build system, not make...Not for oldtests though.  Here our main Makefile redirects to the local Makefile there.> I also am uncomfortable with gold-plating ""oldtest"" in general. `TEST_FILE=foo.vim` is good to have for parallel form with the Lua tests. That's the only reason.It's only done there first.  The same pattern would also work then for other tests in general.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11475,351983886,2019-11-29T05:19:12Z,.travis.yml,"@@ -158,7 +158,7 @@ jobs:       env:         - CLANG_SANITIZER=TSAN         - *common-job-env-    - if: false+    - if: type != pull_request","well, the plan is to also push to release channel. In theory, that's decided/controlled by https://github.com/neovim/neovim/blob/5c9063cf2d115b652ccdde6f72afc464b7085a18/ci/snap/deploy.sh . Not clear if it works yet.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11476,352038252,2019-11-29T09:13:02Z,test/functional/ui/float_spec.lua,"@@ -56,6 +58,31 @@ describe('floating windows', function()     eq(1000, funcs.win_getid())   end) +  it('closed immediately by autocmd #11383', function()+    eq('Error executing lua: [string ""<nvim>""]:4: Window was closed immediately',","Yes. I've tried to title-case Lua everywhere in our docs/messages, because that's more readable (`l` looks like capital `i`), and because that's how the project is named (similar to ""Vim"", ""Nvim"").",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11476,352082390,2019-11-29T10:58:55Z,test/functional/ui/float_spec.lua,"@@ -56,6 +58,31 @@ describe('floating windows', function()     eq(1000, funcs.win_getid())   end) +  it('closed immediately by autocmd #11383', function()+    eq('Error executing lua: [string ""<nvim>""]:4: Window was closed immediately',","Yeah, wouldn't be too bad probably, but it is also not clear if the above refers to the `:lua` command, or ""Lua code"" - it just reads like the latter, but comes from/via the first probably.",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11477,352095005,2019-11-29T11:34:00Z,.builds/freebsd.yml,"@@ -35,9 +35,6 @@ tasks: - unittest: |     cd neovim     gmake unittest-- oldtest: |-    cd neovim-    gmake oldtest","I've ran it manually from a build with a shell, and this is the result:```Executed:  1437 Tests Skipped:    52 Tests  FAILED:     2 TestsFailures:        From test_writefile.vim:        Found errors in Test_writefile_fails_conversion():        function RunTheTest[37]..Test_writefile_fails_conversion line 12: command did not fail: write ++enc=cp932        function RunTheTest[37]..Test_writefile_fails_conversion line 13: Expected ['line one', 'line two'] but got ['first line', 'cannot convert ', 'third line']        From test_alot.vim:        Found errors in Test_libcall_libcallnr():        Caught exception in Test_libcall_libcallnr(): Vim(call):dlerror = ""/usr/local/lib/: read error: Invalid argument"" @ function RunTheTest[37]..Test_libcall_libcallnr, line 32TEST FAILUREgmake[1]: *** [Makefile:94: report] Error 1gmake[1]: Leaving directory '/usr/home/build/neovim/src/nvim/testdir'gmake: *** [Makefile:119: oldtest] Error 2[build@build /usr/home/build/neovim]$ uname -aFreeBSD build 12.1-RELEASE-p1 FreeBSD 12.1-RELEASE-p1 GENERIC  amd64```For some reason (Sourcehut bug?) it does not generate a log for it apparently still though.(added ref as comment)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11483,352266927,2019-11-30T04:58:24Z,src/nvim/eval.c,"@@ -11503,6 +11503,9 @@ static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr) static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr) {   static const char *const has_list[] = {+#if defined(BSD) && !defined(__APPLE__)","> Should `has('bsd')` work on OSX?I'd say no, otherwise it makes `has('bsd')` useless...",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11495,352457064,2019-12-02T07:58:39Z,src/nvim/eval/typval.c,"@@ -1205,9 +1205,11 @@ void tv_dict_watcher_notify(dict_T *const dict, const char *const key,     DictWatcher *watcher = tv_dict_watcher_node_data(w);     if (!watcher->busy && tv_dict_watcher_matches(watcher, key)) {       rettv = TV_INITIAL_VALUE;+      dict->dv_refcount++;       watcher->busy = true;       callback_call(&watcher->callback, 3, argv, &rettv);       watcher->busy = false;+      dict->dv_refcount--;",Should maybe use `tv_dict_unref`?  https://github.com/neovim/neovim/blob/1a6efa4719c906fe67f2c21ec1a2b33ae92ca17b/src/nvim/eval/typval.c#L1419-L1424,
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11521,354584939,2019-12-05T22:40:52Z,runtime/lua/vim/lsp/util.lua,"@@ -313,6 +313,7 @@ end function M.jump_to_location(location)   if location.uri == nil then return end   local bufnr = vim.uri_to_bufnr(location.uri)+  vim.cmd ""norm m'""","```suggestion  -- Save position in jumplist  vim.cmd ""normal! m'""```",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/7202,355220035,2019-12-08T22:29:44Z,runtime/doc/eval.txt,"@@ -5451,6 +5451,9 @@ jobstart({cmd}[, {opts}])				*jobstart()* 		  |on_exit|  : exit event handler (function name or |Funcref|) 		  cwd      : Working directory of the job; defaults to 		             |current-directory|.+		  env      : A dict of strings to append (or replace see |clear_env|) to the","this line is longer than the standard length, add a newline after the closing parenthesis.",
58348703,butwerenotthereyet,https://api.github.com/repos/neovim/neovim/pulls/11530,355225781,2019-12-08T23:58:14Z,src/nvim/mark.c,"@@ -178,6 +178,48 @@ void setpcmark(void)     curwin->w_pcmark.lnum = 1;   } +  // When the jumplist mode is set to history, discard all subsequent +  // locations when setting the mark to a location that is different from the+  // previous next position.+  //+  // This behavior corresponds to the following situation in a web browser.+  // Navigate to first.com, second.com, third.com, fourth.com and then +  // fifth.com.  Then navigate backwards twice so that third.com is displayed.",Expanded and moved into the documentation for jumplist at the bottom.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11530,355246923,2019-12-09T03:05:51Z,src/nvim/mark.c,"@@ -1204,16 +1214,27 @@ void cleanup_jumplist(win_T *wp, bool checktail)         break;       }     }-    if (i >= wp->w_jumplistlen) {  // no duplicate+    bool mustfree = false;","this is a ""dead assignment"", static analysis will flag it.```suggestion    bool mustfree;```I would probably lean towards a ternary or some other way to be less verbose in the logic below, but I suppose that could turn out worse.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11530,355247321,2019-12-09T03:08:54Z,runtime/doc/motion.txt,"@@ -1083,6 +1083,93 @@ When you split a window, the jumplist will be copied to the new window. If you have included the ' item in the 'shada' option the jumplist will be stored in the ShaDa file and restored when starting Vim. +When jumpoptions includes ""stack"", the jumplist behaves like the history in a","Add a tag here, otherwise the wall-of-text just gets lost in the bigger wall-of-text.```suggestion							*jumplist-stack*When jumpoptions includes ""stack"", the jumplist behaves like the history in a```Is all of the text needed, or can it be explained with less words?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11530,355247429,2019-12-09T03:09:34Z,runtime/doc/options.txt,"@@ -3457,6 +3457,16 @@ A jump table for the options with a short description can be found at |Q_op|. 	Unprintable and zero-width Unicode characters are displayed as <xxxx>. 	There is no option to specify these characters. +						*'jumpoptions'* *'jop'*+'jumpoptions' 'jop'	string	(default """")+			global+	List of words that change the behavior of the |jumplist|.+	  stack         Make the jumplist behave like the tagstack or like a+	                web browser.  Relative location of entries in the+			jumplist is preserved at the cost of discarding+			subsequent entries when navigating backwards in the+			jumplist and then jumping to a location.",add a reference to `|jumplist-stack|````suggestion			jumplist and then jumping to a location. |jumplist-stack|```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11522,355250492,2019-12-09T03:29:51Z,runtime/lua/vim/lsp.lua,"@@ -844,6 +844,11 @@ function lsp.buf_notify(bufnr, method, params)   end) end +local line = nil;+local pos = nil;+local line_to_cursor = nil;+local textMatch = nil;","would be nice to put this in a ""state bag"" variable as a hint for readers.```local _state = {lines=nil, pos=nil, ...}```Then when these variables are used in the function it is a useful hint that this is some shared/long-lived state.```character = _state.pos[2]```It's also useful for debugging, one can inspect `_state` instead of juggling a bunch of variables.",
58348703,butwerenotthereyet,https://api.github.com/repos/neovim/neovim/pulls/11530,355251101,2019-12-09T03:34:12Z,src/nvim/mark.c,"@@ -1204,16 +1214,27 @@ void cleanup_jumplist(win_T *wp, bool checktail)         break;       }     }-    if (i >= wp->w_jumplistlen) {  // no duplicate+    bool mustfree = false;","Fixed the dead store in https://github.com/neovim/neovim/pull/11530/commits/7f294976248812aa102e1eb947b5e3f1694852c3 .  The less verbose versions I've been able to come up with so far have been less readable (highly subjective), but if there's a better way to write this let's do it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11530,355254858,2019-12-09T03:58:22Z,test/functional/normal/jump_spec.lua,"@@ -1,4 +1,7 @@ local helpers = require('test.functional.helpers')(after_each)+local clear, feed = helpers.clear, helpers.feed+local redir_exec = helpers.redir_exec+local eq = helpers.eq","linter is failing here because many of these are redundant (see lines 6, 8, etc.)```Checking test/functional/normal/jump_spec.lua     [0m[31m[1m6 warnings[0m    test/functional/normal/jump_spec.lua:2:7: unused variable [0m[1mclear[0m    test/functional/normal/jump_spec.lua:2:14: unused variable [0m[1mfeed[0m    test/functional/normal/jump_spec.lua:4:7: unused variable [0m[1meq[0m    test/functional/normal/jump_spec.lua:6:7: variable [0m[1mclear[0m was previously defined on line 2    test/functional/normal/jump_spec.lua:8:7: variable [0m[1meq[0m was previously defined on line 4    test/functional/normal/jump_spec.lua:10:7: variable [0m[1mfeed[0m was previously defined on line 2```",x
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11209,355255736,2019-12-09T04:04:37Z,src/nvim/api/private/defs.h,"@@ -107,7 +107,7 @@ typedef enum {   kObjectTypeLuaRef,   // EXT types, cannot be split or reordered, see #EXT_OBJECT_TYPE_SHIFT   kObjectTypeBuffer,-  kObjectTypeWindow,+  kObjectTypeNvimWindow,","could be just `kNvimWin`, I don't think there's any ambiguity there.",
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11568,359095891,2019-12-18T00:16:16Z,src/nvim/screen.c,"@@ -2017,58 +2016,73 @@ static void copy_text_attr(int off, char_u *buf, int len, int attr)   } } -/*- * Fill the foldcolumn at ""p"" for window ""wp"".- * Only to be called when 'foldcolumn' > 0.- */-static void-fill_foldcolumn (+/// Fills the foldcolumn at ""p"" for window ""wp"".+/// Only to be called when 'foldcolumn' > 0.+///+/// @param[out] p  Char array to write into+/// @param lnum    Absolute current line number+/// @param closed  Wether it is in foldcolumn mode+///+/// Assume monocell characters+/// @return number of chars added to \param p+static size_t+fill_foldcolumn(     char_u *p,     win_T *wp,-    int closed,                     /* TRUE of FALSE */-    linenr_T lnum                  /* current line number */+    int closed,+    linenr_T lnum ) {   int i = 0;   int level;   int first_level;-  int empty;-  int fdc = compute_foldcolumn(wp, 0);-+  int fdc = compute_foldcolumn(wp, 0);    // available cell width+  size_t char_counter = 0;+  int symbol = 0;+  int len = 0;   // Init to all spaces.-  memset(p, ' ', (size_t)fdc);+  memset(p, ' ', 6 * fdc + 1);    level = win_foldinfo.fi_level;-  if (level > 0) {-    // If there is only one column put more info in it.-    empty = (fdc == 1) ? 0 : 1;--    // If the column is too narrow, we start at the lowest level that-    // fits and use numbers to indicated the depth.-    first_level = level - fdc - closed + 1 + empty;-    if (first_level < 1) {-      first_level = 1;-    }--    for (i = 0; i + empty < fdc; i++) {-      if (win_foldinfo.fi_lnum == lnum-          && first_level + i >= win_foldinfo.fi_low_level) {-        p[i] = '-';-      } else if (first_level == 1) {-        p[i] = '|';-      } else if (first_level + i <= 9) {-        p[i] = '0' + first_level + i;-      } else {-        p[i] = '>';-      }-      if (first_level + i == level) {-        break;-      }++  // If the column is too narrow, we start at the lowest level that+  // fits and use numbers to indicated the depth.+  first_level = level - fdc - closed + 1;+  if (first_level < 1) {+    first_level = 1;+  }++  for (i = 0; i  < MIN(fdc, level); i++) {+    if (win_foldinfo.fi_lnum == lnum+        && first_level + i >= win_foldinfo.fi_low_level) {+      symbol = wp->w_p_fcs_chars.foldopen;+    } else if (first_level == 1) {+      symbol = wp->w_p_fcs_chars.foldsep;+    } else if (first_level + i <= 9) {+      symbol = '0' + first_level + i;+    } else {+      symbol = '>';+    }++    len = utf_char2bytes(symbol, &p[char_counter]);+    char_counter += len;+    if (first_level + i >= level) {+      i++;+      break;     }   }+   if (closed) {-    p[i >= fdc ? i - 1 : i] = '+';+    if (symbol != 0) {+      // rollback length+      char_counter -= len;+    }+    symbol = wp->w_p_fcs_chars.foldclosed;+    len = utf_char2bytes(symbol, &p[char_counter]);+    char_counter += len;   }++  return MAX(char_counter + (fdc-i), fdc);",This is the line that caused the build to fail because it is a comparison between an `unsigned long` and `int`,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11519,359376848,2019-12-18T14:35:24Z,test/functional/ui/cursor_spec.lua,"@@ -245,6 +245,26 @@ describe('ui/cursor', function()       eq('normal', screen.mode)     end) +    -- update the highlight again to hide cursor+    helpers.command('hi Cursor blend=100')++    for _, m in ipairs(expected_mode_info) do+      if m.hl_id then+          m.attr = {background = Screen.colors.Red, blend = 100}+      end+    end+    screen:expect(function()","can merge these two expects. use  `screen:expect{grid=..., condition=function() ... end}`",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11593,360699228,2019-12-22T11:26:27Z,scripts/gen_vimdoc.py,"@@ -141,7 +141,7 @@ def debug_this(cond, o):         try:             name = o.nodeName             o = o.toprettyxml(indent='  ', newl='\n')-        except:+        except Exception:             pass","This is still a bit ""ugly"" IMHO (should only handle expected exceptions probably).",
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11606,361128210,2019-12-24T10:19:10Z,runtime/lua/vim/lsp/rpc.lua,"@@ -1,3 +1,4 @@+local vim = vim","It brings vim into the local scope instead of the global scope which is more efficient. Looking up a global value means hitting the global table, whereas a local value is an upvalue captured by the functions. It also hides a lot of the errors I get from my Lua LSP.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11613,361331492,2019-12-25T18:21:40Z,src/nvim/ex_docmd.c,"@@ -5890,6 +5921,20 @@ static void do_ucmd(exarg_T *eap)   else     cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx); +  if (cmd->uc_argt & EX_LUA_CB) {+    lua_State* L = executor_enter_lua();+    nlua_pushref(L, cmd->lua_cb);+    lua_pushlstring(L, (const char*)eap->arg, STRLEN(eap->arg));+    lua_newtable(L);+    if (eap->forceit == 1) {+      lua_pushliteral(L, ""bang"");+      lua_pushboolean(L, eap->forceit == 1);+      lua_rawset(L, -3);+    }+    lua_pcall(L, 2, 0, 0);","I think the `nlua_error"" pattern can be used here:    if (lua_pcall(...)) {      nlua_error(L, ""E5108: Error executing lua: %.*s"");    }",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11612,361365999,2019-12-26T04:38:18Z,src/nvim/mouse.c,"@@ -479,7 +479,7 @@ win_T *mouse_find_win(int *gridp, int *rowp, int *colp) static win_T *mouse_find_grid_win(int *gridp, int *rowp, int *colp) {   if (*gridp == msg_grid.handle) {-    rowp += msg_grid_pos;+    // rowp += msg_grid_pos;",```suggestion    // rowp += msg_grid_pos;  // PVS: dead store #11612```,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11612,361366029,2019-12-26T04:38:34Z,src/nvim/api/vim.c,"@@ -335,7 +335,7 @@ void nvim_input_mouse(String button, String action, String modifier,     if (strequal(action.data, ""down"")) {       code = KE_MOUSEUP;     } else if (strequal(action.data, ""up"")) {-      code = KE_MOUSEDOWN;+      // pass",That assertion is always true because of the outer-if condition.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11612,361373820,2019-12-26T05:51:16Z,src/nvim/ops.c,"@@ -1672,17 +1672,6 @@ int op_delete(oparg_T *oap)       extmark_col_adjust_delete(curbuf, lnum, mincol, endcol,                                 kExtmarkUndo, 0);     }--  // Delete characters within one line,-  // The case with multiple lines is handled by do_join-  } else if (oap->motion_type == kMTCharWise && oap->line_count == 1) {","Ah, it's not dead code but the assignments are never used. Will just assume that this is a harmless oversight from the extmarks work...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11616,361374468,2019-12-26T05:56:36Z,src/nvim/screen.c,"@@ -121,7 +121,6 @@  #define MB_FILLER_CHAR '<'  /* character used when a double-width character                              * doesn't fit. */-#define W_ENDCOL(wp)   (wp->w_wincol + wp->w_width) #define W_ENDROW(wp)   (wp->w_winrow + wp->w_height)",i would perhaps move `W_ENDROW` along with `W_ENDCOL`..,
296363,norcalli,https://api.github.com/repos/neovim/neovim/pulls/11613,361466696,2019-12-26T14:28:28Z,src/nvim/ex_docmd.c,"@@ -5890,6 +5921,20 @@ static void do_ucmd(exarg_T *eap)   else     cmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx); +  if (cmd->uc_argt & EX_LUA_CB) {+    lua_State* L = executor_enter_lua();+    nlua_pushref(L, cmd->lua_cb);+    lua_pushlstring(L, (const char*)eap->arg, STRLEN(eap->arg));+    lua_newtable(L);+    if (eap->forceit == 1) {+      lua_pushliteral(L, ""bang"");+      lua_pushboolean(L, eap->forceit == 1);+      lua_rawset(L, -3);","It depends on how many places I expected to need lua. With bfredl's recommendation for using `executor_free_luaref()`, I would only need to use `executor_enter_lua()` once now, which means I could replace it with a single function.Architecturally, I don't find exposing the ability to do arbitrary Lua elsewhere to be terrible as long as it's used responsibly if it was the choice between that and a bunch of little utility functions.In this case I think it's fine, but I'm also looking at adding Lua functions for keymappings and autocmds (I know there's an existing PR out there which I'm hoping to pick up). So I'll say for sure after spending more time with that.But good point, nonetheless.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11616,361785126,2019-12-28T08:59:27Z,runtime/doc/options.txt,"@@ -4529,6 +4529,13 @@ A jump table for the options with a short description can be found at |Q_op|. 			global 	Determines the maximum number of items to show in the popup menu for 	Insert mode completion.  When zero as much space as available is used.+	|ins-completion-menu|.++						*'pumwidth'* *'pw'*+'pumwidth' 'pw'		number	(default 0)","technically this should go after 'pumblend', these entries are alphabetical.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11563,361848426,2019-12-29T12:52:27Z,src/nvim/marktree.c,"@@ -0,0 +1,1157 @@+#include <assert.h>","would be good to have a module description here similar to `multiqueue.c`, also mentioning common operations like `marktree_itr/del_get`.Anyways, really cool stuff!",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11633,362032593,2019-12-30T16:28:44Z,runtime/lua/vim/lsp.lua,"@@ -138,7 +138,7 @@ local function validate_command(input)       end     end   else-    error(""cmd type must be string or list."")+    error(string.format(""cmd type must be string or list, but given %q."", type(input)))","could remove this `else` block and use `vim.validate` at the beginning of `validate_command`. That will also ensure that the error message has a standard format.```vim.validate{input={  input,  function() return type(input) == 'string' or vim.tbl_islist(input) end}}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11626,362164745,2019-12-31T07:48:21Z,test/functional/normal/tab_spec.lua,"@@ -0,0 +1,230 @@+local helpers = require('test.functional.helpers')(after_each)++local clear = helpers.clear+local eq = helpers.eq+local feed = helpers.feed+local redir_exec = helpers.redir_exec++describe('tabpage/earlier', function()+  before_each(clear)+  it('switches to earlier after new tab creation at end', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the earlier (third) tab+    feed(':tabantecedent<cr>')+    eq(   '\n'+       .. '\n'+       .. 'Tab page 1\n'+       .. '    [No Name]\n'+       .. 'Tab page 2\n'+       .. '    [No Name]\n'+       .. 'Tab page 3\n'+       .. '>   [No Name]\n'+       .. 'Tab page 4\n'+       .. '    [No Name]',+       redir_exec('tabs')+    )+  end)++  it('switches to earlier after new tab creation in middle', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the second tab+    feed('2gt')+    -- Add a new tab after the second tab+    feed(':tabnew<cr>')+    -- Switch to the earlier (second) tab+    feed(':tabantecedent<cr>')+    eq(   '\n'+       .. '\n'+       .. 'Tab page 1\n'+       .. '    [No Name]\n'+       .. 'Tab page 2\n'+       .. '>   [No Name]\n'+       .. 'Tab page 3\n'+       .. '    [No Name]\n'+       .. 'Tab page 4\n'+       .. '    [No Name]\n'+       .. 'Tab page 5\n'+       .. '    [No Name]',+       redir_exec('tabs')+    )+  end)++  it('switches to earlier after switching to next tab', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the next (first) tab+    feed('gt')+    -- Switch to the earlier (fourth) tab+    feed(':tabantecedent<cr>')++    eq(   '\n'+       .. '\n'+       .. 'Tab page 1\n'+       .. '    [No Name]\n'+       .. 'Tab page 2\n'+       .. '    [No Name]\n'+       .. 'Tab page 3\n'+       .. '    [No Name]\n'+       .. 'Tab page 4\n'+       .. '>   [No Name]',+       redir_exec('tabs')+    )+  end)++  it('switches to earlier after switching to last tab', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the next (first) tab+    feed('gt')+    feed(':tablast<cr>')+    -- Switch to the earlier (second) tab+    feed(':tabantecedent<cr>')++    eq(   '\n'+       .. '\n'+       .. 'Tab page 1\n'+       .. '>   [No Name]\n'+       .. 'Tab page 2\n'+       .. '    [No Name]\n'+       .. 'Tab page 3\n'+       .. '    [No Name]\n'+       .. 'Tab page 4\n'+       .. '    [No Name]',+       redir_exec('tabs')+    )+  end)++  it('switches to earlier after switching to previous tab', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the previous (third) tab+    feed('gT')+    -- Switch to the earlier (fourth) tab+    feed(':tabantecedent<cr>')++    eq(   '\n'+       .. '\n'+       .. 'Tab page 1\n'+       .. '    [No Name]\n'+       .. 'Tab page 2\n'+       .. '    [No Name]\n'+       .. 'Tab page 3\n'+       .. '    [No Name]\n'+       .. 'Tab page 4\n'+       .. '>   [No Name]',+       redir_exec('tabs')+    )+  end)++  it('switches to earlier after switching to first tab', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the previous (third) tab+    feed('gT')+    -- Switch to the first tab+    feed(':tabfirst<cr>')+    -- Switch to the earlier (third) tab+    feed(':tabantecedent<cr>')++    eq(   '\n'+       .. '\n'+       .. 'Tab page 1\n'+       .. '    [No Name]\n'+       .. 'Tab page 2\n'+       .. '    [No Name]\n'+       .. 'Tab page 3\n'+       .. '>   [No Name]\n'+       .. 'Tab page 4\n'+       .. '    [No Name]',+       redir_exec('tabs')+    )+  end)++  it('switches to earlier after numbered tab switch', function()+    -- Add three tabs for a total of four+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    feed(':tabnew<cr>')+    -- Switch to the second tab+    feed('2gt')+    -- Switch to the earlier (fourth) tab+    feed(':tabantecedent<cr>')++    eq(   '\n'","@butwerenotthereyet to avoid such `]]` ambiguity, Lua allows any number of `=` between the brackets, thus `[=[ ... ]=]` instead of `[[ ... ]]`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11626,362165386,2019-12-31T07:53:55Z,src/nvim/quickfix.c,"@@ -3450,7 +3450,7 @@ static int qf_goto_cwindow(const qf_info_T *qi, bool resize, int sz, static int qf_open_new_cwindow(const qf_info_T *qi, int height) {   win_T *oldwin = curwin;-  const tabpage_T *const prevtab = curtab;+  const tabpage_T *const old_curtab = curtab;","this is a hint that a longer name should be used for the global (bigger scope), since short names are more typical/appropriate for smaller scopes. Even though you're right about `prevwin` as a precedent, I think `lastused_tabpage` is easier to understand and avoids potential conflicts like this (including when we merge upstream Vim patches). Or `prev_tabpage`.",
58348703,butwerenotthereyet,https://api.github.com/repos/neovim/neovim/pulls/11626,362246764,2019-12-31T16:47:14Z,src/nvim/quickfix.c,"@@ -3450,7 +3450,7 @@ static int qf_goto_cwindow(const qf_info_T *qi, bool resize, int sz, static int qf_open_new_cwindow(const qf_info_T *qi, int height) {   win_T *oldwin = curwin;-  const tabpage_T *const prevtab = curtab;+  const tabpage_T *const old_curtab = curtab;","Acknowledged, it would be very bad if a change from upstream in this function referred to `prevtab` intending to refer to the local variable defined here and instead ended up referring to the global variable that's being added.  This name change is now reverted, and the global is named `lastused_tabpage`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11604,362281421,2019-12-31T21:17:07Z,runtime/lua/vim/lsp.lua,"@@ -204,95 +204,155 @@ local function text_document_did_open_handler(bufnr, client)   client.notify('textDocument/didOpen', params) end +--- LSP client object.+---+--- - Methods:+---+---  - request(method, params, [callback])+---     Send a request to the server. If callback is not specified, it will use+---     {client.callbacks} to try to find a callback. If one is not found there,+---     then an error will occur.+---     This is a thin wrapper around {client.rpc.request} with some additional+---     checking.+---     Returns a boolean to indicate if the notification was successful. If it+---     is false, then it will always be false (the client has shutdown).+---     If it was successful, then it will return the request id as the second+---     result. You can use this with `notify(""$/cancel"", { id = request_id })`+---     to cancel the request. This helper is made automatically with+---     |vim.lsp.buf_request()|+---     Returns: status, [client_id]+---+---  - notify(method, params)+---     This is just {client.rpc.notify}()+---     Returns a boolean to indicate if the notification was successful. If it+---     is false, then it will always be false (the client has shutdown).+---     Returns: status+---+---  - cancel_request(id)+---     This is just {client.rpc.notify}(""$/cancelRequest"", { id = id })+---     Returns the same as `notify()`.+---+---  - stop([force])+---     Stop a client, optionally with force.+---     By default, it will just ask the server to shutdown without force.+---     If you request to stop a client which has previously been requested to+---     shutdown, it will automatically escalate and force shutdown.+---+---  - is_stopped()+---     Returns true if the client is fully stopped.+---+--- - Members+---  - id (number): The id allocated to the client.+---+---  - name (string): If a name is specified on creation, that will be+---    used. Otherwise it is just the client id. This is used for+---    logs and messages.+---+---  - offset_encoding (string): The encoding used for communicating+---    with the server. You can modify this in the `on_init` method+---    before text is sent to the server.+---+---  - callbacks (table): The callbacks used by the client as+---    described in |lsp-callbacks|.+---+---  - config (table): copy of the table that was passed by the user+---    to |vim.lsp.start_client()|.+---+---  - server_capabilities (table): Response from the server sent on+---    `initialize` describing the server's capabilities.+---+---  - resolved_capabilities (table): Normalized table of+---    capabilities that we have detected based on the initialize+---    response from the server in `server_capabilities`.+function lsp.client()","yucky hack until we add class/struct support to `lua2dox.lua`. I want to document the ""client object"".Alternative meanwhile would be to move this to `lsp/client.lua` . ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11626,362327003,2020-01-01T14:47:28Z,test/functional/autocmd/tabnewentered_spec.lua,"@@ -29,3 +37,351 @@ describe('TabNewEntered', function()     end)   end) end)++describe('tabpage/earlier', function()+  before_each(clear)+  local function switches_to_earlier_after_new_tab_creation_at_end(characters)+    return function()+        -- Add three tabs for a total of four+        command('tabnew')+        command('tabnew')+        command('tabnew')++        -- The earlier tab is now the third.+        eq(3, eval('tabpagenr(\'#\')'))++        -- Switch to the earlier (third) tab+        feed(characters)++        eq(dedent([=[+++          Tab page 1+              [No Name]+          Tab page 2+              [No Name]+          Tab page 3+          >   [No Name]+          Tab page 4+              [No Name]]=]),+           redir_exec('tabs')+        )++        -- The earlier tab is now the fourth.+        eq(4, eval('tabpagenr(\'#\')'))+    end+  end+  it('switches to earlier via g<Tab> after new tab creation at end', switches_to_earlier_after_new_tab_creation_at_end('g<Tab>'))","`switches_to_earlier_after_new_tab_creation_at_end` is longer than we name most functions, but if we're going to keep that name we would at least add a line break here:```suggestion  it('switches to earlier via g<Tab> after new tab creation at end',    switches_to_earlier_after_new_tab_creation_at_end('g<Tab>'))```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11641,362331094,2020-01-01T16:11:07Z,runtime/lua/vim/lsp/util.lua,"@@ -683,6 +684,52 @@ do       api.nvim_buf_set_virtual_text(bufnr, diagnostic_ns, line, virt_texts, {})     end   end+  function M.buf_diagnostics_statusline(bufnr, diagnostics)+    all_buffer_diagnostics_counts[bufnr] = { errors=0, warnings=0, hints=0, info=0 }+    for _, diagnostic in ipairs(diagnostics) do+      if diagnostic.severity == 1 then+        all_buffer_diagnostics_counts[bufnr]['errors'] = all_buffer_diagnostics_counts[bufnr]['errors'] + 1+      elseif diagnostic.severity == 2 then+        all_buffer_diagnostics_counts[bufnr]['warnings'] = all_buffer_diagnostics_counts[bufnr]['warnings'] + 1+      elseif diagnostic.severity == 3 then+        all_buffer_diagnostics_counts[bufnr]['info'] = all_buffer_diagnostics_counts[bufnr]['info'] + 1+      elseif diagnostic.severity == 4 then+        all_buffer_diagnostics_counts[bufnr]['hints'] = all_buffer_diagnostics_counts[bufnr]['hints'] + 1+      end+    end+  end+  function M.buf_diagnostics_error_count()+      local bufnr = vim.api.nvim_get_current_buf()+      if all_buffer_diagnostics_counts[bufnr] ~= nil then+          return all_buffer_diagnostics_counts[bufnr]['errors']+      else+          return '-'+      end+  end+  function M.buf_diagnostics_warning_count()"," 4 new functions is far too many. It increases the API size for little gain. Each function needs to be documented, etc. Seems pretty natural to have 1 function that takes a parameter instead, not to mention that would eliminate 20 lines of redundant code in this PR.",X
4317806,wchargin,https://api.github.com/repos/neovim/neovim/pulls/11639,362365607,2020-01-02T03:45:27Z,runtime/doc/provider.txt,"@@ -58,12 +58,14 @@ If you run into problems, uninstall _both_ then install ""pynvim"" again: > PYTHON PROVIDER CONFIGURATION ~ 						*g:python_host_prog* Command to start Python 2 (executable, not directory). Setting this makes-startup faster. Useful for working with virtualenvs.  >+startup faster. Useful for working with virtualenvs. Must be set before any+check for |has|(""python2"").  >","Done; thanks. (I���m not super familiar with this help file syntax; I���dassumed that it���d work because `:help has` resolves unambiguously, butwill happily defer to your expertise here.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11631,362475653,2020-01-02T13:40:18Z,runtime/lua/vim/shared.lua,"@@ -300,6 +300,29 @@ function vim.tbl_islist(t)   end end +--- Returns the first element from the table that matches the second argument.+---+--@param t table+--@param o Any object. If f is callable, apply the element to f, otherwise compare the element to f.+function vim.tbl_find(t, o) end -- luacheck: no unused+vim.tbl_find = (function()+  local function _apply(v, o)+    if vim.is_callable(o) then+      return o(v)+    else+      return v == o+    end+  end++  return function(t, o)+    vim.validate{t={t, 't'}}+    for _, v in pairs(t) do+      if _apply(v, o) then return v end+    end+    return nil+  end+end)()","I think we don't need this pattern here. And we can avoid `_apply`  checking  if o is callable for each comparison. Something like this (untested):```function vim.tbl_find(t, o)  vim.validate{t={t, 't'}}  local cmp = vim.is_callable(o) and o or function(v) o == v end  for _, v in pairs(t) do    if cmp(v) then return v end  end  return nilend```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11470,362558877,2020-01-02T17:31:10Z,runtime/doc/lua.txt,"@@ -717,6 +717,16 @@ vim.NIL								    *vim.NIL* 	is equivalent to a missing value: `{""foo"", nil}` is the same as  	`{""foo""}` +vim.empty_dict()					    *vim.empty_dict()*","I just simply wrote the documentation close to the other functions it belongs with (rpcrequest et al)? Or is there a way to write a docstring and still have it show up at a certain place in `|lua-builtin|` and not with unrelated `|lua-vim|` stuff? Or should `lua-builtin` and `lua-vim` be merged perhaps, the distinction might be quite arbitrary to the end user (both c and lua code inside the binary are ""builtin"").",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11470,362645440,2020-01-02T21:57:16Z,runtime/doc/lua.txt,"@@ -717,6 +717,16 @@ vim.NIL								    *vim.NIL* 	is equivalent to a missing value: `{""foo"", nil}` is the same as  	`{""foo""}` +vim.empty_dict()					    *vim.empty_dict()*",">  If `|lua-builtin|` cannot be defined by a docstring, then that answers your question why this couldn't be a docstring right now.Well, only if one cares about grouping it there. Otherwise it could be a docstring here: https://github.com/neovim/neovim/blob/0c436559dfba9e0bb7e6ce5a835ed8eee540205f/src/nvim/lua/vim.lua#L246`lua-builtin` is just a place for stuff that doesn't exist explicitly in `vim.lua`. But in this case, `empty_dict()` _does_ exist in `vim.lua`, so it could be doc'd there.> or I actually though of docs strings on the C impl functions inside executor.c directly, not sure what is simplest to implement.sure, that's fine too. We can add some ""routing"" to `gen_vimdoc.py` fairly easily.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11470,362651226,2020-01-02T22:18:03Z,runtime/doc/lua.txt,"@@ -717,6 +717,16 @@ vim.NIL								    *vim.NIL* 	is equivalent to a missing value: `{""foo"", nil}` is the same as  	`{""foo""}` +vim.empty_dict()					    *vim.empty_dict()*","> Well, only if one cares about grouping it there.If one does not care there is no reason to move it either way.> lua-builtin is just a place for stuff that doesn't exist explicitly in vim.lua. But in this case, empty_dict() does exist in vim.lua, so it could be doc'd there.Technically true but missing the point. `vim.empty_dict()` is _exactly_ as much a builtin concept as `vim.NIL`. This concept just happens to be named with a two-lined helper function in `vim.lua` that creates an instance (unlike `vim.NIL` which is a singleton). Even instances created by builtin functions will be represented by the string `""vim.empty_dict()""`. Segregating `vim.empty_dict()` away from the ""real"" builtin stuff just because it has a two-line ""shell"" apart from all the internal plumbing (which is the stuff that really makes it work as a ""type"") would be quite confusing. While merging would probably be the best, as long as the distinction still exists it does matter, and we shouldn't place stuff in the less optimal category just because it is technically possible to do so.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11470,362674891,2020-01-03T00:07:59Z,runtime/doc/lua.txt,"@@ -717,6 +717,16 @@ vim.NIL								    *vim.NIL* 	is equivalent to a missing value: `{""foo"", nil}` is the same as  	`{""foo""}` +vim.empty_dict()					    *vim.empty_dict()*","My point was only to use docstrings as much as possible, because1. It generates better formatted docs with less maintenance2. It is included in things like lua.mpackI know it's ugly that some things are separate, but I'm hoping that is a temporary situation and would like to avoid accumulating more non-docstring cases. That's all.",
125701,pwntester,https://api.github.com/repos/neovim/neovim/pulls/11638,363963424,2020-01-07T21:38:25Z,runtime/doc/lsp.txt,"@@ -158,6 +158,27 @@ name: >   vim.lsp.protocol.TextDocumentSyncKind.Full == 1   vim.lsp.protocol.TextDocumentSyncKind[1] == ""Full"" +================================================================================+LSP HIGHLIGHT GROUPS                                      *lsp-highlight-groups*++                                                        *hl-LspDiagnosticsError*+LspDiagnosticsError       used for 'Error' diagnostic virtual text+                                                      *hl-LspDiagnosticsWarning*+LspDiagnosticsWarning     used for 'Warning' diagnostic virtual text+                                                  *hl-LspDiagnosticsInformation*+LspDiagnosticInformation  used for 'Information' diagnostic virtual text+                                                         *hl-LspDiagnosticsHint*+LspDiagnosticHint         used for 'Hint' diagnostic virtual text+                                                    *hl-LspDiagnosticsUnderline*+LspDiagnosticsUnderline   used for text with diagnostic information+                                                           *hl-LspReferenceText*+LspReferenceText          used for highlighting 'text' references+                                                           *hl-LspReferenceRead*+LspReferenceRead          used for highlighting 'read' references+                                                          *hl-LspReferenceWrite*+LspReferenceWrite         used for highlighting 'write' references","This is used by the existing code, eg: https://github.com/neovim/neovim/blob/master/runtime/lua/vim/lsp/util.lua#L564the only ones that can be merged in my opinion are LspReferenceRead, LspReferenceWrite and LspReferenceText, but users may want to differentiate them",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11683,364081190,2020-01-08T06:35:33Z,ci/build.ps1,"@@ -13,6 +13,7 @@ $buildDir = [System.IO.Path]::GetFullPath(""$(pwd)"") $depsCmakeVars = @{   CMAKE_BUILD_TYPE = $cmakeBuildType; }+$cmakeExtraFlags = $env:CMAKE_EXTRA_FLAGS",don't need this variable.Also let's name it `CMAKE_FLAGS` . CMAKE_EXTRA_FLAGS is needlessly verbose and I was hoping to deprecate it in favor of `CMAKE_FLAGS` (which was already in use anyways).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11638,364272975,2020-01-08T14:57:29Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -195,6 +195,22 @@ M['textDocument/peekDefinition'] = function(_, _, result, _)   api.nvim_buf_add_highlight(headbuf, -1, 'Keyword', 0, -1) end +M['textDocument/documentHighlight'] = function(_, _, result, _)+  if not result then return end+  local bufnr = api.nvim_get_current_buf()+  for _, reference in ipairs(result) do+    local start_pos = {reference[""range""][""start""][""line""], reference[""range""][""start""][""character""]}+    local end_pos = {reference[""range""][""end""][""line""], reference[""range""][""end""][""character""]}+    if reference[""kind""] == protocol.DocumentHighlightKind.Text then+      util.highlight_range(bufnr, util.reference_ns, ""LspReferenceText"", start_pos, end_pos)+    elseif reference[""kind""] == protocol.DocumentHighlightKind.Read then+      util.highlight_range(bufnr, util.reference_ns, ""LspReferenceRead"", start_pos, end_pos)+    elseif reference[""kind""] == protocol.DocumentHighlightKind.Write then+      util.highlight_range(bufnr, util.reference_ns, ""LspReferenceWrite"", start_pos, end_pos)","Rather than expose `util.reference_ns`, this impl could go in `util`, similar to  `util.buf_diagnostics_underline`.That also avoids the need to expose `util.highlight_range`. ",
125701,pwntester,https://api.github.com/repos/neovim/neovim/pulls/11638,364354782,2020-01-08T17:35:11Z,runtime/lua/vim/lsp/util.lua,"@@ -568,10 +569,16 @@ do    function M.buf_clear_diagnostics(bufnr)     validate { bufnr = {bufnr, 'n', true} }-    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr+    bufnr = api.nvim_get_current_buf() or bufnr","sorry, my bad.  So if this function receives `nil`, it will be passed to `nvim_buf_clear_namespace`. Does this function handle `nil`?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11692,364569987,2020-01-09T05:58:20Z,test/functional/autocmd/tabnewentered_spec.lua,"@@ -480,4 +480,40 @@ describe('tabpage/previous', function()   --   does_not_switch_to_previous_after_entering_operator_pending('<C-W>g<Tab>'))   it('does not switch to previous via <C-Tab> after entering operator pending',     does_not_switch_to_previous_after_entering_operator_pending('<C-Tab>'))++  local function does_not_switch_to_previous_when_editing_command_line(characters, completion_visible)","Let's not continue these big function names, they are cumbersome to read. Same info can be communicated clearly without such long names. E.g. `cmdline_win_prevents_tab_switch` ( ""cmdline-win"" is the standard name for that mode)",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/11683,364864553,2020-01-09T17:20:30Z,Makefile,"@@ -9,19 +9,17 @@ all: nvim  CMAKE_PRG ?= $(shell (command -v cmake3 || echo cmake)) CMAKE_BUILD_TYPE ?= Debug-CMAKE_FLAGS := -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE)-# Extra CMake flags which extend the default set-CMAKE_EXTRA_FLAGS ?=+CMAKE_FLAGS := -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE) $(CMAKE_FLAGS)  # CMAKE_INSTALL_PREFIX-#   - May be passed directly or as part of CMAKE_EXTRA_FLAGS.+#   - May be passed directly or as part of CMAKE_FLAGS. #   - `checkprefix` target checks that it matches the CMake-cached value. #9615-ifneq (,$(CMAKE_INSTALL_PREFIX)$(CMAKE_EXTRA_FLAGS))-CMAKE_INSTALL_PREFIX := $(shell echo $(CMAKE_EXTRA_FLAGS) | 2>/dev/null \+ifneq (,$(CMAKE_INSTALL_PREFIX)$(CMAKE_FLAGS))","Ok, so what did this actually do? The body of the condition gets `CMAKE_INSTALL_PREFIX` from `CMAKE_EXTRA_FLAGS`, ok.But the condition just says that either `CMAKE_INSTALL_PREFIX` or `CMAKE_EXTRA_FLAGS` is nonempty. So if you set `CMAKE_INSTALL_PREFIX`, and then have it in `CMAKE_EXTRA_FLAGS`, the latter overrides, right?  And if you set `CMAKE_INSTALL_PREFIX`, but `CMAKE_EXTRA_FLAGS` is empty, then this results in an empty local `CMAKE_INSTALL_PREFIX`.That's intended? I'd have guessed the priorities are explizit > part of `CMAKE_EXTRA_FLAGS` > part of `CMAKE_FLAGS`, but changing it might break stuff. As far as I can see, setting `CMAKE_INSTALL_PREFIX` as part of `CMAKE_FLAGS` did not have any effect, so it shouldn't now?Confusing, to say the least. Viml really gives Makefiles a run for their money :P Please advice on the intended behavior.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11703,366163816,2020-01-14T06:00:09Z,test/functional/provider/perl_spec.lua,"@@ -0,0 +1,42 @@+local helpers = require('test.functional.helpers')(after_each)+local eq, clear = helpers.eq, helpers.clear+local missing_provider = helpers.missing_provider+local command = helpers.command+local write_file = helpers.write_file+local eval = helpers.eval+local retry = helpers.retry++do+  clear()+  local reason = missing_provider('perl')+  if reason then+    pending(string.format(""Missing perl host, or perl version is too old (%s)"", reason), function() end)+    return+  end+end++before_each(function()+  clear()+end)++describe('perl host', function()+  teardown(function ()+    os.remove('Xtest-perl-hello.pl')+  end)++  it('works', function()+    local fname = 'Xtest-perl-hello.pl'+    write_file(fname, [[+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      $nvim->command('let g:job_out = ""hello""');","@jacquesg What's the simplest plugin abstraction that does this within one file (no `rplugin/perl/`)? I can't figure out how to use the Plugin class for this without creating a new file. For reference, I want to do the equivalent of what's in the nodejs_spec.lua.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11713,366198878,2020-01-14T08:14:52Z,src/nvim/api/vim.c,"@@ -443,7 +443,7 @@ Object nvim_eval(String expr, Error *err)   if (!try_end(err)) {     if (ok == FAIL) {       // Should never happen, try_end() should get the error. #8371-      api_set_error(err, kErrorTypeException, ""Failed to evaluate expression"");+      api_set_error(err, kErrorTypeException, ""Failed to evaluate expression: %s"", expr.data);","perhaps truncate it (unless DEBUG_LOG_LEVEL)? E.g. (untested):```suggestion      api_set_error(err, kErrorTypeException, ""Failed to evaluate expression: ""%.*s"", 256, expr.data);```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11703,366684337,2020-01-15T03:43:41Z,test/functional/provider/perl_spec.lua,"@@ -0,0 +1,73 @@+local helpers = require('test.functional.helpers')(after_each)+local eq, clear = helpers.eq, helpers.clear+local missing_provider = helpers.missing_provider+local command = helpers.command+local write_file = helpers.write_file+local eval = helpers.eval+local retry = helpers.retry++do+  clear()+  local reason = missing_provider('perl')+  if reason then+    pending(string.format(""Missing perl host, or perl version is too old (%s)"", reason), function() end)+    return+  end+end++before_each(function()+  clear()+end)++describe('perl host', function()+  teardown(function ()+    os.remove('Xtest-perl-hello.pl')+    os.remove('Xtest-perl-hello-plugin.pl')+  end)++  it('works', function()+    local fname = 'Xtest-perl-hello.pl'+    write_file(fname, [[+      package main;+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      $nvim->command('let g:job_out = ""hello""');+      1;+    ]])+    command('let g:job_id = jobstart([""perl"", ""'..fname..'""])')+    retry(nil, 3000, function() eq('hello', eval('g:job_out')) end)+  end)++  it('plugin works', function()+    local fname = 'Xtest-perl-hello-plugin.pl'+    write_file(fname, [[+      package TestPlugin;+      use parent qw(Neovim::Ext::Plugin);++      @{TestPlugin::commands} = ();+      @{TestPlugin::specs} = ();+      sub test_command :nvim_command('TestCommand')+      {+        my ($this) = @_;+        $this->nvim->command('let g:job_out = ""hello-plugin""');+      }++      package main;+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      my $plugin = Neovim::Ext::Plugin::new('TestPlugin', $nvim);+      $plugin->test_command();",This should run `TestCommand` but it needs the Host class to start the event loop. I don't know how that works.,
3534453,jacquesg,https://api.github.com/repos/neovim/neovim/pulls/11703,367073480,2020-01-15T19:49:15Z,test/functional/provider/perl_spec.lua,"@@ -0,0 +1,73 @@+local helpers = require('test.functional.helpers')(after_each)+local eq, clear = helpers.eq, helpers.clear+local missing_provider = helpers.missing_provider+local command = helpers.command+local write_file = helpers.write_file+local eval = helpers.eval+local retry = helpers.retry++do+  clear()+  local reason = missing_provider('perl')+  if reason then+    pending(string.format(""Missing perl host, or perl version is too old (%s)"", reason), function() end)+    return+  end+end++before_each(function()+  clear()+end)++describe('perl host', function()+  teardown(function ()+    os.remove('Xtest-perl-hello.pl')+    os.remove('Xtest-perl-hello-plugin.pl')+  end)++  it('works', function()+    local fname = 'Xtest-perl-hello.pl'+    write_file(fname, [[+      package main;+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      $nvim->command('let g:job_out = ""hello""');+      1;+    ]])+    command('let g:job_id = jobstart([""perl"", ""'..fname..'""])')+    retry(nil, 3000, function() eq('hello', eval('g:job_out')) end)+  end)++  it('plugin works', function()+    local fname = 'Xtest-perl-hello-plugin.pl'+    write_file(fname, [[+      package TestPlugin;+      use parent qw(Neovim::Ext::Plugin);++      @{TestPlugin::commands} = ();+      @{TestPlugin::specs} = ();+      sub test_command :nvim_command('TestCommand')+      {+        my ($this) = @_;+        $this->nvim->command('let g:job_out = ""hello-plugin""');+      }++      package main;+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      my $plugin = Neovim::Ext::Plugin::new('TestPlugin', $nvim);+      $plugin->test_command();",A plugin should derive from ```Neovim::Ext::Plugin```https://github.com/jacquesg/p5-Neovim-Ext/blob/master/t/rplugin/perl/TestPlugin.pmTo start the host could be as simple as [start_host()](https://github.com/jacquesg/p5-Neovim-Ext/blob/master/lib/Neovim/Ext.pm#L59),
3534453,jacquesg,https://api.github.com/repos/neovim/neovim/pulls/11703,367256789,2020-01-16T06:55:11Z,test/functional/provider/perl_spec.lua,"@@ -0,0 +1,73 @@+local helpers = require('test.functional.helpers')(after_each)+local eq, clear = helpers.eq, helpers.clear+local missing_provider = helpers.missing_provider+local command = helpers.command+local write_file = helpers.write_file+local eval = helpers.eval+local retry = helpers.retry++do+  clear()+  local reason = missing_provider('perl')+  if reason then+    pending(string.format(""Missing perl host, or perl version is too old (%s)"", reason), function() end)+    return+  end+end++before_each(function()+  clear()+end)++describe('perl host', function()+  teardown(function ()+    os.remove('Xtest-perl-hello.pl')+    os.remove('Xtest-perl-hello-plugin.pl')+  end)++  it('works', function()+    local fname = 'Xtest-perl-hello.pl'+    write_file(fname, [[+      package main;+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      $nvim->command('let g:job_out = ""hello""');+      1;+    ]])+    command('let g:job_id = jobstart([""perl"", ""'..fname..'""])')+    retry(nil, 3000, function() eq('hello', eval('g:job_out')) end)+  end)++  it('plugin works', function()+    local fname = 'Xtest-perl-hello-plugin.pl'+    write_file(fname, [[+      package TestPlugin;+      use parent qw(Neovim::Ext::Plugin);++      @{TestPlugin::commands} = ();+      @{TestPlugin::specs} = ();+      sub test_command :nvim_command('TestCommand')+      {+        my ($this) = @_;+        $this->nvim->command('let g:job_out = ""hello-plugin""');+      }++      package main;+      use v5.22.1;+      use Neovim::Ext;+      use Neovim::Ext::MsgPack::RPC;++      my $session = Neovim::Ext::MsgPack::RPC::socket_session($ENV{NVIM_LISTEN_ADDRESS});+      my $nvim = Neovim::Ext::from_session($session);+      my $plugin = Neovim::Ext::Plugin::new('TestPlugin', $nvim);+      $plugin->test_command();",The syntax to instaniate the plugin isn't quite right. It should eithe be:```my $plugin = TestPlugin->new ($nvim)```or```my $plugin = new TestPlugin ($nvim)```;https://github.com/jacquesg/p5-Neovim-Ext/blob/master/lib/Neovim/Ext/Plugin.pm#L202It should also register the plugin like so:https://github.com/jacquesg/p5-Neovim-Ext/blob/master/t/rplugin/perl/TestPlugin.pm#L7,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11736,368298903,2020-01-19T14:40:11Z,src/nvim/options.lua,"@@ -2488,6 +2488,12 @@ return {       varname='p_tbidi',       defaults={if_true={vi=false}}     },+    {+      full_name='termencoding', abbreviation='tenc',+      type='string', scope={'global'},+      vi_def=true,+      defaults={if_true={vi=""""}}+    },","This is just the standard pattern for a disabled option ( i e something that vim only supports on some platforms). But perhaps a general comment could be made at the top of the file (i e if the p_varname is missing then the option is disabled, and &opt gives the default value).",
13122669,Billy4195,https://api.github.com/repos/neovim/neovim/pulls/11740,368844580,2020-01-21T07:28:49Z,src/nvim/eval.c,"@@ -12716,11 +12716,11 @@ static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)     // Ignore return code, but show error later.     (void)channel_close(data->id, kChannelPartRpc, &error);   }-  process_stop((Process *)&data->stream.proc);-  rettv->vval.v_number = 1;+  bool valid_proc = process_stop((Process *)&data->stream.proc);","From your suggestion* Remove the modification in process_stop(), using find_job(..., false) to check the valid job id* Return -1 for invalid id, 1 for valid id (or you think valid id should return 0)BTW, as changing to find_job(..., false) there are some functional tests failed, cause the previous test will throw out an error when the job id is non-existent or is stopped already.(failed cases: [non-existent](https://github.com/neovim/neovim/blob/master/test/functional/core/job_spec.lua#L309), [stopped](https://github.com/neovim/neovim/blob/master/test/functional/core/job_spec.lua#L314))I should change them to check the return value depending on this PR, right?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11740,368868014,2020-01-21T08:40:04Z,src/nvim/eval.c,"@@ -12716,11 +12716,11 @@ static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)     // Ignore return code, but show error later.     (void)channel_close(data->id, kChannelPartRpc, &error);   }-  process_stop((Process *)&data->stream.proc);-  rettv->vval.v_number = 1;+  bool valid_proc = process_stop((Process *)&data->stream.proc);","Fine with me, but...> a job id will become invalid ""soon"" after the job have been stopped (after one or two uv ticks)my understanding of https://github.com/neovim/neovim/issues/10943 was that we don't want jobstop() to fail loudly even if the job-id is now invalid. Because some plugin might hang onto some old job-id too long, but it shouldn't need to try/catch it. But maybe that's too ""sloppy"". Perhaps the common case is addressed by this PR, and that's all we want.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11764,371000431,2020-01-26T13:56:23Z,scripts/vim-patch.sh,"@@ -23,6 +23,7 @@ usage() {   echo ""    -h                 Show this message and exit.""   echo ""    -l [git-log opts]  List missing Vim patches.""   echo ""    -L [git-log opts]  List missing Vim patches (for scripts).""+  echo ""    -m {vim-revision}  List previous (older) missing Vim patches.""","the description doesn't really clarify anything vs `-l` and `-L`. Should it be:```suggestion  echo ""    -m {rev}  List missing patches older than {rev}.""```Also is it smart enough to only list patches that touched related files?",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/11764,371003189,2020-01-26T14:24:55Z,scripts/vim-patch.sh,"@@ -23,6 +23,7 @@ usage() {   echo ""    -h                 Show this message and exit.""   echo ""    -l [git-log opts]  List missing Vim patches.""   echo ""    -L [git-log opts]  List missing Vim patches (for scripts).""+  echo ""    -m {vim-revision}  List previous (older) missing Vim patches.""",> Also is it smart enough to only list patches that touched related files?Not yet. ���See https://github.com/neovim/neovim/pull/11514#issuecomment-568259051 and before/around.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11787,372215831,2020-01-29T07:01:12Z,third-party/cmake/BuildLuv.cmake,"@@ -106,7 +106,7 @@ elseif(MSVC)     # Same as Unix without fPIC     ""-DCMAKE_C_FLAGS:STRING=${CMAKE_C_COMPILER_ARG1} ${LUV_INCLUDE_FLAGS}""     # Make sure we use the same generator, otherwise we may-    # accidentaly end up using different MSVC runtimes+    # accidently end up using different MSVC runtimes",```suggestion    # accidentally end up using different MSVC runtimes```,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11802,373816156,2020-02-02T03:21:21Z,src/nvim/getchar.c,"@@ -1096,26 +1096,40 @@ void del_typebuf(int len, int offset)  * Write typed characters to script file.  * If recording is on put the character in the recordbuffer.  */-static void gotchars(char_u *chars, size_t len)+static void gotchars(const char_u *chars, size_t len)+  FUNC_ATTR_NONNULL_ALL {-  char_u      *s = chars;-  int c;+  const char_u *s = chars;+  static char_u buf[4] = { 0 };+  static size_t buflen = 0;+  size_t todo = len; -  // remember how many chars were last recorded-  if (reg_recording != 0) {-    last_recorded_len += len;-  }+  while (todo--) {+    buf[buflen++] = *s++;++    // When receiving a special key sequence, store it until we have all+    // the bytes and we can decide what to do with it.+    if (buflen == 1 && buf[0] == K_SPECIAL) {+      continue;+    }+    if (buflen == 2) {+      continue;+    }",Omitted the `buflen == 3` condition because Neovim doesn't support `K_FOCUS` pseudo keys.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11781,373887515,2020-02-03T00:13:10Z,runtime/autoload/health/provider.vim,"@@ -497,6 +485,74 @@ function! s:check_for_pyenv() abort   return [pyenv_path, pyenv_root] endfunction +"" Locate Python executable by running invocation and checking+"" sys.executable.+function! s:locate_pythonx(invocation) abort+  return s:normalize_path(system(a:invocation+    \ . ' -c ""import sys; sys.stdout.write(sys.executable)""'))+endfunction++"" If $VIRTUAL_ENV is set, check whether its Python executables will be+"" the first on the $PATH of both Neovim and subshells spawned from+"" Neovim.+function! s:check_active_virtualenv() abort+  call health#report_start('Python active virtualenv')+  let errors = []+  "" hints are kept as Dictionary keys in order to discard duplicates+  let hints = {}+  "" the virtualenv should contain some Python executables, and those+  "" executables should be first both on Neovim's path and on the path of+  "" subshells launched from Neovim","in technical sources and docs we always say ""Nvim"" or `nvim`, for consistency.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11803,373941332,2020-02-03T06:42:10Z,src/nvim/tui/tui.c,"@@ -1009,17 +1012,51 @@ static void tui_mouse_on(UI *ui) {   TUIData *data = ui->data;   if (!data->mouse_enabled) {+#ifdef WIN32+    const char *term = os_getenv(""TERM"");+    bool toggle_uv_vterm_state =+      term && (terminfo_is_term_family(term, ""conemu"")","After merging #11808, I would like to rewrite the condition using `uv_tty_get_vterm_state()`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/10379,374013368,2020-02-03T10:03:16Z,CMakeLists.txt,"@@ -98,6 +98,13 @@ else()   option(ENABLE_LTO ""enable link time optimization"" ON) endif() +if(CMAKE_SYSTEM_NAME MATCHES ""OpenBSD|NetBSD|Windows"")+  message(STATUS ""skipping libacl on this sytem: ${CMAKE_SYSTEM_NAME}"")+  option(ENABLE_LIBACL ""enable libacl"" OFF)+else()+  option(ENABLE_LIBACL ""enabled libacl"" ON)+endif()","ok. `libintl` and `libiconv` are that way because of history (Windows support). We will remove those options once we're confident that they are always working on Windows.In the case of ACL, there's no reason to make it an option: either we find the library or we don't.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11805,374438195,2020-02-04T01:53:07Z,src/nvim/eval.c,"@@ -20477,6 +20477,27 @@ void set_selfdict(typval_T *rettv, dict_T *selfdict)   } } +// Turn a typeval into a string.  Similar to tv_get_string_buf() but uses+// string() on Dict, List, etc.+static const char *tv_stringify(typval_T *varp, char *buf)+  FUNC_ATTR_NONNULL_ALL+{+  if (varp->v_type == VAR_LIST+      || varp->v_type == VAR_DICT+      || varp->v_type == VAR_FUNC+      || varp->v_type == VAR_PARTIAL+      || varp->v_type == VAR_FLOAT) {+    typval_T tmp;++    f_string(varp, &tmp, NULL);+    const char *const res = tv_get_string_buf(&tmp, buf);","Why not `return encode_tv2string(&varp[0], NULL)` to skip the temporary variables? End result is the same.```diffdiff --git a/src/nvim/eval.c b/src/nvim/eval.cindex fac0ad3..a7e3e84 100644--- a/src/nvim/eval.c+++ b/src/nvim/eval.c@@ -20487,13 +20487,7 @@ static const char *tv_stringify(typval_T *varp, char *buf)       || varp->v_type == VAR_FUNC       || varp->v_type == VAR_PARTIAL       || varp->v_type == VAR_FLOAT) {-    typval_T tmp;--    f_string(varp, &tmp, NULL);-    const char *const res = tv_get_string_buf(&tmp, buf);-    tv_clear(varp);-    *varp = tmp;-    return res;+    return encode_tv2string(&varp[0], NULL);   }   return tv_get_string_buf(varp, buf); }```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11805,374654584,2020-02-04T12:57:37Z,src/nvim/eval.c,"@@ -20477,6 +20477,21 @@ void set_selfdict(typval_T *rettv, dict_T *selfdict)   } } +// Turn a typeval into a string.  Similar to tv_get_string_buf() but uses+// string() on Dict, List, etc.+static const char *tv_stringify(typval_T *varp, char *buf)+  FUNC_ATTR_NONNULL_ALL+{+  if (varp->v_type == VAR_LIST+      || varp->v_type == VAR_DICT+      || varp->v_type == VAR_FUNC+      || varp->v_type == VAR_PARTIAL+      || varp->v_type == VAR_FLOAT) {+    return encode_tv2string(&varp[0], NULL);","I copy-pasted from `f_string`. `varp` is cleared at the bottom of the while loop.```c    // ex_execute while loop    ret = eval1_emsg(&arg, &rettv, !eap->skip);    if (ret == FAIL) {      break;    }    if (!eap->skip) {      char buf[NUMBUFLEN];      const char *const argstr = eap->cmdidx == CMD_execute        ? tv_get_string_buf(&rettv, buf)        : tv_stringify(&rettv, buf);      const size_t len = strlen(argstr);      ga_grow(&ga, len + 2);      if (!GA_EMPTY(&ga)) {        ((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';      }      memcpy((char_u *)(ga.ga_data) + ga.ga_len, argstr, len + 1);      ga.ga_len += len;    }    tv_clear(&rettv);    arg = skipwhite(arg);```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11803,375149471,2020-02-05T09:41:28Z,src/nvim/event/stream.c,"@@ -57,6 +60,11 @@ void stream_init(Loop *loop, Stream *stream, int fd, uv_stream_t *uvstream)       if (type == UV_TTY) {         uv_tty_init(&loop->uv, &stream->uv.tty, fd, 0);         uv_tty_set_mode(&stream->uv.tty, UV_TTY_MODE_RAW);+        DWORD dwMode;+        if (GetConsoleMode(stream->uv.tty.handle, &dwMode)) {+          dwMode |= ENABLE_VIRTUAL_TERMINAL_INPUT;",This is being done unconditionally?,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11803,375653546,2020-02-06T06:01:17Z,src/nvim/event/stream.c,"@@ -57,6 +60,11 @@ void stream_init(Loop *loop, Stream *stream, int fd, uv_stream_t *uvstream)       if (type == UV_TTY) {         uv_tty_init(&loop->uv, &stream->uv.tty, fd, 0);         uv_tty_set_mode(&stream->uv.tty, UV_TTY_MODE_RAW);+        DWORD dwMode;+        if (GetConsoleMode(stream->uv.tty.handle, &dwMode)) {+          dwMode |= ENABLE_VIRTUAL_TERMINAL_INPUT;","Like `ENABLE_VIRTUAL_TERMINAL_PROCESSING`, `ENABLE_VIRTUAL_TERMINAL_INPUT` cannot be determined if it is supported unless it is set with `SetConsoleMode()`. Therefore, set unconditionally.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11757,376263105,2020-02-07T08:19:52Z,src/nvim/api/vim.c,"@@ -703,6 +703,40 @@ ArrayOf(String) nvim_list_runtime_paths(void)   return rv; } +/// Find files in runtime directories+///+/// 'name' can contain wildcards. For example+/// nvim_get_runtime_file(""colors/*.vim"", true) will return all color+/// scheme files.+///+/// It is not an error to not find any files. An empty array is returned then.+///+/// @param name pattern of files to search for+/// @param all whether to return all matches or only the first+/// @return list of absolute paths to the found files+ArrayOf(String) nvim_get_runtime_file(String name, Boolean all)+  FUNC_API_SINCE(7)+{+  Array rv = ARRAY_DICT_INIT;+  if (!name.data) {+    return rv;+  }+  int flags = DIP_START | (all ? DIP_ALL : 0);+  do_in_runtimepath((char_u *)name.data, flags, find_runtime_cb, &rv);+  return rv;+}++static void find_runtime_cb(char_u *fname, void *cookie)+{+  Array *rv = (Array *)cookie;+  ADD(*rv, STRING_OBJ(cstr_to_string((char *)fname)));+}++String nvim__get_lib_dir(void)","Possibly but I don't think we should commit to it now. The Idea is that _any_ dir the user adds to &rtp will also work as libdir, so `&rtp` is already ""v:libdir"". It is separate from `$VIMRUNTIME` _only_ to not put binaries in a ""PREFIX/share"" dir which would be a big no-no. This function is just a cop-out for the sake of tests (the paths on CI do not behave as I expect, e.g. the VIMRUNTIME is suddenly `share/nvim` instead of `share/nvim/runtime/` and I do not want to stall all tree-sitter work indefinitely until I figure out why and how to write a formula to predict all the variation)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11638,376292599,2020-02-07T09:29:35Z,runtime/lua/vim/lsp/util.lua,"@@ -663,6 +662,26 @@ do     end   end +  function M.buf_clear_references(bufnr)+    validate { bufnr = {bufnr, 'n', true} }+    api.nvim_buf_clear_namespace(bufnr, reference_ns, 0, -1)+  end++  function M.buf_highlight_references(bufnr, references)+    validate { bufnr = {bufnr, 'n', true} }+    for _, reference in ipairs(references) do+      local start_pos = {reference[""range""][""start""][""line""], reference[""range""][""start""][""character""]}+      local end_pos = {reference[""range""][""end""][""line""], reference[""range""][""end""][""character""]}+      if reference[""kind""] == protocol.DocumentHighlightKind.Text then+        highlight_range(bufnr, reference_ns, ""LspReferenceText"", start_pos, end_pos)+      elseif reference[""kind""] == protocol.DocumentHighlightKind.Read then+        highlight_range(bufnr, reference_ns, ""LspReferenceRead"", start_pos, end_pos)+      elseif reference[""kind""] == protocol.DocumentHighlightKind.Write then+        highlight_range(bufnr, reference_ns, ""LspReferenceWrite"", start_pos, end_pos)+      end","yes, and then the if-else chain isn't needed at all. instead a temp map can be created and `protocol.DocumentHighlightKind` can be used as the lookup. Just like the other PR (which was merged before this one)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11830,376514999,2020-02-07T17:32:04Z,src/nvim/CMakeLists.txt,"@@ -546,7 +546,7 @@ else() endif() set_target_properties(nvim_runtime_deps PROPERTIES FOLDER deps) -file(COPY ${DEPS_PREFIX}/lib/nvim/parser DESTINATION ${PROJECT_BINARY_DIR}/lib/nvim/)","It would be better to just make this conditional on the existence of `${DEPS_PREFIX}/lib/nvim/parser`.  ""non-bundled"" C parser can just be copied to anywhere in &rtp, it doesn't need any care by build system.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11805,376670991,2020-02-08T00:55:29Z,test/functional/ex_cmds/echo_spec.lua,"@@ -11,31 +11,48 @@ local dedent = helpers.dedent local command = helpers.command local exc_exec = helpers.exc_exec local redir_exec = helpers.redir_exec+local pcall_err = helpers.pcall_err+local matches = helpers.matches -describe(':echo', function()+local function StringErr(str, quote)+  local ret = pcall_err(command, 'echoerr '..(quote and ""'""..str:gsub(""'"", ""''"")..""'"" or str))+  return ret:gsub('^Vim%(echoerr%):', '', 1)+end++describe(':echo :echomsg :echoerr', function()   before_each(function()     clear()     source([[       function String(s)         return execute('echo a:s')[1:]       endfunction+      function StringMsg(s)+        return execute('echomsg a:s')[1:]+      endfunction     ]])   end)    describe('used to represent floating-point values', function()     it('dumps NaN values', function()-      eq('str2float(\'nan\')', eval('String(str2float(\'nan\'))'))+      eq(""str2float('nan')"", eval(""String(str2float('nan'))""))+      eq(""str2float('nan')"", eval(""StringMsg(str2float('nan'))""))+      eq(""str2float('nan')"", StringErr(""str2float('nan')""))","Those asserts won't always work because of lambdas and that `:echo` and `echomsg`  output are not always the same. `f_string()` is non-recursive for self-referencing dicts, lists.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11819,376697526,2020-02-08T08:48:01Z,runtime/autoload/provider/pythonx.vim,"@@ -19,7 +19,11 @@ function! provider#pythonx#Require(host) abort     call add(args, plugin.path)   endfor -  return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')+  if has('win32')+    return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})","I thought I commented this already but maybe it got lost in the aether: `'overlapped': v:true` should just be silently ignored on unix, otherwise every plugin that uses it will need to perform this useless ritual. ""overlapped"" distinguishes between two modes of operation in win23 that are the same on unix: every unix pipe supports both non-overlapped and overlapped operations already! So specifying this is just redundant, but not an error.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/11866,378946439,2020-02-13T15:48:34Z,runtime/doc/lsp.txt,"@@ -543,8 +543,7 @@ start_client({config})                                *vim.lsp.start_client()*                     {root_dir}         (required, string) Directory where the                                        LSP server will base its rootUri on                                        initialization.-                    {cmd}              (required, string or list treated like-                                       |jobstart()|) Base command that+                    {cmd}              (required, list) Base command that","I thought the `treated like jobstart` referred to the support of both `string` and `list`. The `jobstart()` function documentation explains that if it is a string it will use the shell for evaluation. That part no longer applies, so I felt it is confusing to still refer to `jobstart` which now has different semantics.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/11866,378953730,2020-02-13T15:59:38Z,runtime/doc/lsp.txt,"@@ -543,8 +543,7 @@ start_client({config})                                *vim.lsp.start_client()*                     {root_dir}         (required, string) Directory where the                                        LSP server will base its rootUri on                                        initialization.-                    {cmd}              (required, string or list treated like-                                       |jobstart()|) Base command that+                    {cmd}              (required, list) Base command that","but it also explains how the list is treated, eg. collapsed etc...",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11864,379333781,2020-02-14T09:41:23Z,test/functional/lua/vim_spec.lua,"@@ -319,9 +319,43 @@ describe('lua stdlib', function()        return b.x[1] == 1 and b.x[2] == 2 and b.y == 5 and count == 2              and tostring(a) ~= tostring(b)-    ]])+    ]]))++    assert(exec_lua([[+      local a = {}+      local b = vim.deepcopy(a)++      local count = 0+      for _ in pairs(b) do count = count + 1 end++      return getmetatable(b) ~= vim._empty_dict_mt+        and count == 0+        and tostring(a) ~= tostring(b)+    ]]))++    assert(exec_lua([[+      local a = vim.empty_dict()+      local b = vim.deepcopy(a)++      local count = 0+      for _ in pairs(b) do count = count + 1 end -    assert(is_dc)+      return getmetatable(b) == vim._empty_dict_mt+        and count == 0+    ]]))++    assert(exec_lua([[+      local a = {x = vim.empty_dict(), y = {}}+      local b = vim.deepcopy(a)++      local count = 0+      for _ in pairs(b) do count = count + 1 end++      return getmetatable(b.x) == vim._empty_dict_mt","A more canonical way rather than checking `vim._empty_dict_mt` manually, is to use `vim.tbl_islist(b.x)`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11209,379865990,2020-02-16T00:37:39Z,src/nvim/api/private/defs.h,"@@ -107,7 +107,7 @@ typedef enum {   kObjectTypeLuaRef,   // EXT types, cannot be split or reordered, see #EXT_OBJECT_TYPE_SHIFT   kObjectTypeBuffer,-  kObjectTypeWindow,+  kObjectTypeNvimWindow,",^ suggestion still stands. Full list of suggested names:```kNvimWinkNvimTabkNvimBuf```and for the types:```REMOTE_TYPE(NvimBuf);REMOTE_TYPE(NvimWin);REMOTE_TYPE(NvimTab);```,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/11874,379870319,2020-02-16T02:33:56Z,runtime/autoload/health/provider.vim,"@@ -710,13 +710,27 @@ function! s:check_perl() abort    let latest_cpan_cmd = 'cpanm --info -q Neovim::Ext'   let latest_cpan = s:system(latest_cpan_cmd)-  if s:shell_error || empty(latest_cpan) || latest_cpan[0] ==# '!'+  if s:shell_error || empty(latest_cpan)     call health#report_error('Failed to run: '. latest_cpan_cmd,           \ [""Make sure you're connected to the internet."",           \  'Are you behind a firewall or proxy?'])     return+  elseif latest_cpan[0] ==# '!'+    let cpanm_errs = split(latest_cpan, '!')+    if cpanm_errs[0] =~# ""Can't write to ""+      call health#report_warn(cpanm_errs[0], cpanm_errs[1:-2])+      "" Last line is the package info+      let latest_cpan = cpanm_errs[-1]+    else+      call health#report_error('Unknown warning from command: ' . latest_cpan_cmd, cpanm_errs)+      return+    endif   endif   let latest_cpan = matchstr(latest_cpan, '\(\.\?\d\)\+')+  if empty(latest_cpan)+    call health#report_error('Cannot parse version number from cpanm output: ' . latest_cpan)",This is an empty string because of `empty(latest_cpan)` condition. Oops.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11873,380013984,2020-02-17T07:13:27Z,src/nvim/ex_docmd.c,"@@ -5151,62 +5150,96 @@ static void uc_list(char_u *name, size_t name_len)         continue;       } -      /* Put out the title first time */-      if (!found)-        MSG_PUTS_TITLE(_(""\n    Name        Args       Address   Complete  Definition""));-      found = TRUE;+      // Put out the title first time+      if (!found) {+        MSG_PUTS_TITLE(_(""\n    Name              Args Address ""+                         ""Complete   Definition""));+      }+      found = true;       msg_putchar('\n');       if (got_int)         break; -      /* Special cases */-      msg_putchar(a & BANG ? '!' : ' ');-      msg_putchar(a & REGSTR ? '""' : ' ');-      msg_putchar(gap != &ucmds ? 'b' : ' ');-      msg_putchar(' ');+      // Special cases+      int len = 4;+      if (a & BANG) {+        msg_putchar('!');+        len--;+      }+      if (a & REGSTR) {+        msg_putchar('""');+        len--;+      }+      if (gap != &ucmds) {+        msg_putchar('b');+        len--;+      }+      if (a & TRLBAR) {+        msg_putchar('|');+        len--;+      }+      while (len-- > 0) {+        msg_putchar(' ');+      }        msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));       len = (int)STRLEN(cmd->uc_name) + 4;        do {         msg_putchar(' ');-        ++len;-      } while (len < 16);+        len++;+      } while (len < 22); +      // ""over"" is how much longer the name is than the column width for+      // the name, we'll try to align what comes after.+      const int over = len - 22;       len = 0; -      /* Arguments */+      // Arguments       switch (a & (EXTRA|NOSPC|NEEDARG)) {-      case 0:                     IObuff[len++] = '0'; break;-      case (EXTRA):               IObuff[len++] = '*'; break;-      case (EXTRA|NOSPC):         IObuff[len++] = '?'; break;-      case (EXTRA|NEEDARG):       IObuff[len++] = '+'; break;-      case (EXTRA|NOSPC|NEEDARG): IObuff[len++] = '1'; break;+        case 0:+          IObuff[len++] = '0';+          break;",the old layout/formatting made the pattern very obvious. I think such style is acceptable in that case.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11890,380286904,2020-02-17T16:50:10Z,src/nvim/msgpack_rpc/channel.c,"@@ -41,6 +41,8 @@ static PMap(cstr_t) *event_strings = NULL; static msgpack_sbuffer out_buffer; +extern MultiQueue *ch_before_blocking_events;","This is a regression, now the sharing is implicit rather than explicit. Better to keep it in the `.h` file and use the EXTERN/INIT pattern (and make sure it is included in main.c to make the INIT work).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11900,381076624,2020-02-19T04:53:01Z,src/nvim/edit.c,"@@ -574,10 +574,8 @@ static int insert_check(VimState *state)     foldCheckClose();   } -  int cmdchar_todo = s->cmdchar;","yeah it looks useless, even in vim's source.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/11910,381499726,2020-02-19T19:36:59Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -37,6 +37,19 @@ end  M['textDocument/references'] = function(_, _, result)   if not result then return end+  for _, loc in ipairs(result) do",Wasn't sure if this could even be integrated in https://github.com/neovim/neovim/blob/ab12a229410c74e3bcc469bd34a3a4c40af8857c/runtime/lua/vim/lsp/util.lua#L736 there it would also affect other operations.,
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/11910,381633475,2020-02-20T00:55:44Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -37,6 +37,19 @@ end  M['textDocument/references'] = function(_, _, result)   if not result then return end+  for _, loc in ipairs(result) do",I think we should move this operation to `M.locations_to_items`.`M.locations_to_items` is used by only `M.set_loclist` and `M.set_qflist`.I think this operation is useful for both.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/11910,382154362,2020-02-20T17:40:23Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -37,6 +37,19 @@ end  M['textDocument/references'] = function(_, _, result)   if not result then return end+  for _, loc in ipairs(result) do+    if loc.uri and not loc.message then","I think I had anticipated to use this in `M.locations_to_items` which people can also use for diagnostics, where a message could already be present.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11918,382440936,2020-02-21T07:57:03Z,runtime/autoload/man.vim,"@@ -328,18 +328,29 @@ function! man#complete(arg_lead, cmd_line, cursor_pos) abort   return s:complete(sect, sect, name) endfunction -function! s:get_paths(sect, name) abort+function! s:get_paths(sect, name, do_fallback) abort+  "" callers must try-catch this, as some `man` implementations don't support `s:find_arg`   try     let mandirs = join(split(s:system(['man', s:find_arg]), ':\|\n'), ',')+    return globpath(mandirs,'man?/'.a:name.'*.'.a:sect.'*', 0, 1)   catch-    call s:error(v:exception)-    return+    if !a:do_fallback+      throw v:exception+    endif++    "" fallback to a single path, with the page we're trying to find+    let [l:sect, l:name, l:path] = s:verify_exists(a:sect, a:name)+    return [l:path]   endtry-  return globpath(mandirs,'man?/'.a:name.'*.'.a:sect.'*', 0, 1) endfunction  function! s:complete(sect, psect, name) abort-  let pages = s:get_paths(a:sect, a:name)+  try+    let pages = s:get_paths(a:sect, a:name, v:false)+  catch+    call s:error(v:exception)+    return","why neuter the exception like this? Since we're showing an error anyway, might as well let the actual exception raise.  stacktrace is useful.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/11910,382539781,2020-02-21T11:47:10Z,runtime/lua/vim/lsp/util.lua,"@@ -772,7 +772,7 @@ function M.locations_to_items(locations)             filename = fname,             lnum = row + 1,             col = col + 1;-            text = temp.msg;+            text = temp.msg or line;","I think the `message` field is related to having used `set_loclist` to populate diagnostics: https://github.com/neovim/neovim/blob/ff1730373c6139db14b8f2f9b24d4ccd7fcfb01d/runtime/lua/vim/lsp/callbacks.lua#L35I also use an override like:```lualocal default_diagnostics_callback = lsp.callbacks['textDocument/publishDiagnostics']local function diagnostics_callback(err, method, result, client_id)    default_diagnostics_callback(err, method, result, client_id)    if result and result.diagnostics and result.uri then        local current_buf = api.nvim_get_current_buf()        if vim.uri_to_bufnr(result.uri) == current_buf and myutil.exists(vim.uri_to_fname(result.uri)) then            for _, v in ipairs(result.diagnostics) do                v.uri = v.uri or result.uri            end            util.set_loclist(result.diagnostics)        end    endend```But I agree that a method called `locations_to_items` should not deal with turning diagnostics into items as well. But maybe removing the message can be a follow up in a separate PR?It probably makes sense to provide some kind of alternative for people who want to have the diagnostics in the location list.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/11910,382910471,2020-02-22T12:50:55Z,runtime/lua/vim/lsp/util.lua,"@@ -772,7 +772,7 @@ function M.locations_to_items(locations)             filename = fname,             lnum = row + 1,             col = col + 1;-            text = temp.msg;+            text = temp.msg or line;","I'll follow up on this. I already toyed around a bit to get an idea how the current diagnostics functions could be changed to make them more customizable & composable.  (https://github.com/mfussenegger/dotfiles/compare/lsp-diag?expand=1#diff-e9e37b70bcd90d6df21d11736e98c583R19) My thoughts right now go into the direction of:- Having the default publishDiagnostics callback as is- Provide access to the diagnostics (bufnr -> linenr -> list of diagnostics)- Make the logic that is currently invoked by the publishDiagnostics more composable, so users can replace the `publishDiagnostics` callback and easily re-use the parts they'd like to keep (e.g, store the diagnostics, active highlights)",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/11638,383525530,2020-02-24T21:29:37Z,runtime/doc/lsp.txt,"@@ -173,6 +158,25 @@ name: >   vim.lsp.protocol.TextDocumentSyncKind.Full == 1   vim.lsp.protocol.TextDocumentSyncKind[1] == ""Full"" +================================================================================","I am sorry to nitpick, but why rename *lsp-highlight*  to *lsp-highlight-groups* ? I guess it's fine as this hasn't been released yet but I would prefer to minimize changes as the naming may have been discussed in a previous pr, I see no reason to change/move it.",
125701,pwntester,https://api.github.com/repos/neovim/neovim/pulls/11638,383533103,2020-02-24T21:45:19Z,runtime/doc/lsp.txt,"@@ -173,6 +158,25 @@ name: >   vim.lsp.protocol.TextDocumentSyncKind.Full == 1   vim.lsp.protocol.TextDocumentSyncKind[1] == ""Full"" +================================================================================","No problem :) I realized it was duplicated so took the one with more context and details. But will rename that one to remove ""groups""",X
205673,bobrippling,https://api.github.com/repos/neovim/neovim/pulls/11918,384192442,2020-02-25T23:35:20Z,runtime/autoload/man.vim,"@@ -328,18 +328,29 @@ function! man#complete(arg_lead, cmd_line, cursor_pos) abort   return s:complete(sect, sect, name) endfunction -function! s:get_paths(sect, name) abort+function! s:get_paths(sect, name, do_fallback) abort+  "" callers must try-catch this, as some `man` implementations don't support `s:find_arg`   try     let mandirs = join(split(s:system(['man', s:find_arg]), ':\|\n'), ',')+    return globpath(mandirs,'man?/'.a:name.'*.'.a:sect.'*', 0, 1)   catch-    call s:error(v:exception)-    return+    if !a:do_fallback+      throw v:exception+    endif++    "" fallback to a single path, with the page we're trying to find+    let [l:sect, l:name, l:path] = s:verify_exists(a:sect, a:name)+    return [l:path]   endtry-  return globpath(mandirs,'man?/'.a:name.'*.'.a:sect.'*', 0, 1) endfunction  function! s:complete(sect, psect, name) abort-  let pages = s:get_paths(a:sect, a:name)+  try+    let pages = s:get_paths(a:sect, a:name, v:false)+  catch+    call s:error(v:exception)+    return","Ah, I'd moved this bit of code from the exception handler in `s:get_paths()` - this snippet was present [before all the tag changes](https://github.com/neovim/neovim/blob/53b025887e28888f8dba78ff57afc001d1a6428b/runtime/autoload/man.vim#L367). I'm happy to let the exception propagate through, as the [introducing PR](https://github.com/neovim/neovim/pull/5734/files#diff-2451f3ce2ccfcf4300067af16309cd75R285) for this doesn't seem to have had a strong reason for adding it.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/11918,384202484,2020-02-26T00:05:36Z,runtime/autoload/man.vim,"@@ -328,18 +328,29 @@ function! man#complete(arg_lead, cmd_line, cursor_pos) abort   return s:complete(sect, sect, name) endfunction -function! s:get_paths(sect, name) abort+function! s:get_paths(sect, name, do_fallback) abort+  "" callers must try-catch this, as some `man` implementations don't support `s:find_arg`   try     let mandirs = join(split(s:system(['man', s:find_arg]), ':\|\n'), ',')+    return globpath(mandirs,'man?/'.a:name.'*.'.a:sect.'*', 0, 1)   catch-    call s:error(v:exception)-    return+    if !a:do_fallback+      throw v:exception+    endif++    "" fallback to a single path, with the page we're trying to find+    let [l:sect, l:name, l:path] = s:verify_exists(a:sect, a:name)+    return [l:path]   endtry-  return globpath(mandirs,'man?/'.a:name.'*.'.a:sect.'*', 0, 1) endfunction  function! s:complete(sect, psect, name) abort-  let pages = s:get_paths(a:sect, a:name)+  try+    let pages = s:get_paths(a:sect, a:name, v:false)+  catch+    call s:error(v:exception)+    return","iirc I added this as if man did throw an error, it was a little nicer to properly write the error out versus throwing an exception. The stack trace while helpful, isn't necessary as the error message will clearly indicate what happened since the codebase is small.",X
629908,hrsh7th,https://api.github.com/repos/neovim/neovim/pulls/11949,384427312,2020-02-26T11:13:27Z,runtime/lua/vim/lsp/util.lua,"@@ -203,6 +203,11 @@ function M.text_document_completion_list_to_complete_items(result, prefix)       icase = 1,       dup = 1,       empty = 1,+      user_data = M.json_encode({+        lsp = {","I don't know the nvim's `user_data` key's policy.Currently, I choose `lsp` key but we can choose other candidates, I think.For example,- { nvim = { lsp = { ... } }- { nvim_lsp = { ... } }",
7908,urandom,https://api.github.com/repos/neovim/neovim/pulls/11927,385058881,2020-02-27T11:06:49Z,runtime/lua/vim/lsp/util.lua,"@@ -135,7 +135,7 @@ function M.apply_text_document_edit(text_document_edit)   local text_document = text_document_edit.textDocument   local bufnr = vim.uri_to_bufnr(text_document.uri)   -- TODO(ashkan) check this is correct.-  if api.nvim_buf_get_changedtick(bufnr) > text_document.version then+  if M.buf_versions[bufnr] > text_document.version then","This can produce nilsI added the following:`M.buf_versions[bufnr] ~= nil and`at the beginning of the if, and with that change and this pr, I no longer get this error when trying to rename stuff with gopls",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11716,386076578,2020-03-01T04:43:15Z,src/nvim/ex_cmds.c,"@@ -4482,8 +4482,9 @@ prepare_tagpreview (       curwin->w_p_wfh = TRUE;       RESET_BINDING(curwin);                /* don't take over 'scrollbind'                                                and 'cursorbind' */-      curwin->w_p_diff = FALSE;             /* no 'diff' */-      curwin->w_p_fdc = 0;                  /* no 'foldcolumn' */+      curwin->w_p_diff = false;             // no 'diff'+      set_string_option_direct((char_u *)""fdc"", -1,","might as well keep the doc, the parallel form is helpful.```suggestion      set_string_option_direct((char_u *)""fdc"", -1,  // no 'foldcolumn'```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11716,386078512,2020-03-01T05:28:01Z,src/nvim/window.c,"@@ -689,6 +694,24 @@ void win_check_anchored_floats(win_T *win)   } } +/// Return the number of requested fold columns, based on current+/// folds signs and on user configuration.+int win_fdccol_count(win_T *wp)+{+  const char *fdc = (const char *)wp->w_p_fdc;++  // auto:<NUM>+  if (strncmp(fdc, ""auto:"", 5) == 0) {+    int needed_fdccols;+    needed_fdccols = getDeepestNesting(wp);+    int maximum = fdc[5] - '0';+    return MIN(maximum, needed_fdccols);","""maximum"" is a pretty ceremonious name, why not just ""max""? (Not a big deal, but just mentioning  for future reference...). Or could just inline it, since being an argument of `MIN()` makes it fairly obvious.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11708,386090254,2020-03-01T09:05:53Z,runtime/doc/options.txt,"@@ -5783,7 +5776,7 @@ A jump table for the options with a short description can be found at |Q_op|.  			   *'statusline'* *'stl'* *E540* *E542* 'statusline' 'stl'	string	(default empty)-			global or local to window |global-local|+			global or local to buffer |global-local|","It used to be the _only_ window global-local option, but is no longer (should be 4-5 of them now). That's all that has been ""special"" about it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11929,386138347,2020-03-01T20:33:49Z,runtime/doc/starting.txt,"@@ -184,12 +184,17 @@ argument. 		the 'modifiable' and 'write' options can be set to enable 		changes and writing. -						*-Z* *restricted-mode* *E145*+					*-Z* *restricted-mode* *E145* *E981* -Z		Restricted mode.  All commands that make use of an external 		shell are disabled.  This includes suspending with CTRL-Z,-		"":sh"", filtering, the system() function, backtick expansion,-		delete(), rename(), mkdir(), writefile(), libcall(),-		jobstart(), etc.+		"":sh"", filtering, the system() function, backtick expansion+		and libcall().+		Also disallowed are delete(), rename(), mkdir(), jobstart(),+		etc.+		Interfaces, such as Python, Ruby and Lua, are also disabled,+		since they could be used to execute shell commands.+		Note that the user may still find a loophole to execute a+		shell command, it has only been made difficult.","`-Z` and sandbox has almost the same restrictions (shown by grepping `check_restricted()` and `check_secure()`). Though personally I would just remove the sandbox as well, or perhaps more realistically any pretence that it is a ""security"" feature. It should be seen more like a complement to ""textlock"" but for shell stuff (avoid doing anything dangerous by mistake) rather than a protection towards malicious plugins/modelines (which could exploit any bug in all the complex logic in eval.c and friends)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/11929,386228847,2020-03-02T07:22:28Z,runtime/doc/starting.txt,"@@ -184,12 +184,17 @@ argument. 		the 'modifiable' and 'write' options can be set to enable 		changes and writing. -						*-Z* *restricted-mode* *E145*+					*-Z* *restricted-mode* *E145* *E981* -Z		Restricted mode.  All commands that make use of an external 		shell are disabled.  This includes suspending with CTRL-Z,-		"":sh"", filtering, the system() function, backtick expansion,-		delete(), rename(), mkdir(), writefile(), libcall(),-		jobstart(), etc.+		"":sh"", filtering, the system() function, backtick expansion+		and libcall().+		Also disallowed are delete(), rename(), mkdir(), jobstart(),+		etc.+		Interfaces, such as Python, Ruby and Lua, are also disabled,+		since they could be used to execute shell commands.+		Note that the user may still find a loophole to execute a+		shell command, it has only been made difficult.","> has almost the same restrictions (shown by grepping `check_restricted()` and `check_secure()`).Right.> rather than a protection towards malicious plugins/modelines (which could exploit any bug in all the complex logic in eval.c and friends)If `nomodelineexpr` works without sandbox, then yes sandbox isn't needed.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/11949,386605523,2020-03-02T19:35:08Z,runtime/lua/vim/lsp/util.lua,"@@ -868,5 +873,24 @@ function M.character_offset(buf, row, col)   return str_utfindex(line, col) end +-- TODO replace with a better implementation.+function M.json_encode(data)+  local status, result = pcall(vim.fn.json_encode, data)+  if status then+    return result+  else+    return nil, result+  end+end++function M.json_decode(data)+  local status, result = pcall(vim.fn.json_decode, data)+  if status then+    return result","if we move these functions to utils, at least return the error message along with status (aka `result`)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11943,386875069,2020-03-03T08:56:04Z,src/nvim/popupmnu.c,"@@ -910,10 +910,18 @@ void pum_set_event_info(dict_T *dict)   if (!pum_visible()) {     return;   }-  tv_dict_add_nr(dict, S_LEN(""height""), pum_height);-  tv_dict_add_nr(dict, S_LEN(""width""), pum_width);-  tv_dict_add_nr(dict, S_LEN(""row""), pum_row);-  tv_dict_add_nr(dict, S_LEN(""col""), pum_col);+  int w,h,r,c;+  if (!ui_pum_get_pos(&w, &h, &r, &c)){",`ui_pum_get_pos` should probably return the pos for builtin pum as well. Then we don't need to duplicate the `dict_add` code.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11943,388182318,2020-03-05T09:48:42Z,src/nvim/api/ui.c,"@@ -340,7 +345,69 @@ void nvim_ui_pum_set_height(uint64_t channel_id, Integer height, Error *err)                   ""It must support the ext_popupmenu option"");     return;   }++  ui->pum_nlines = (int)height;+}++/// Tells Nvim the geometry of the popumenu, to align floating +/// windows with an external popup menu. Note that this method+/// is not to be confused with |nvim_ui_pum_set_height()|, which+/// sets the number of visible items in the popup menu, while+/// this function sets the bounding box of the popup menu, +/// including visual decorations such as boarders and sliders.+///+/// @param channel_id+/// @param width   Popupmenu width, must be greater than zero.+/// @param height  Popupmenu height, must be greater than zero.+/// @param row     Popupmenu row, must be greater or equal to zero.+/// @param col     Popupmenu height, must be greater or equal to zero.+/// @param[out] err Error details, if any. On error, suspend pum position reporting for the current UI.+void nvim_ui_pum_set_bounds(uint64_t channel_id, Integer width, Integer height, ","Hmm, ideally we should accept a msgpack int as a Float argument (we have similar rules for `bool` and handles already). it would be annoying if `ui_pum_set_bounds(1, ...)` in a dynamically typed client errors out.",
486807,dm1try,https://api.github.com/repos/neovim/neovim/pulls/12004,391620779,2020-03-12T13:30:19Z,src/nvim/tui/input.c,"@@ -390,9 +405,15 @@ static bool handle_bracketed_paste(TermInput *input)       // Paste phase: ""disabled"".       input->paste = 0;     }-    return true;+    return kComplete;+  } else if (buf_size < 6","`but_size < 6` looks like ""extra"" condition? or this is done intentionally, for readability?",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12004,392030152,2020-03-13T04:55:49Z,src/nvim/tui/input.c,"@@ -390,9 +405,15 @@ static bool handle_bracketed_paste(TermInput *input)       // Paste phase: ""disabled"".       input->paste = 0;     }-    return true;+    return kComplete;+  } else if (buf_size < 6","Without this condition, receiving an input like `""\x1b[20000""` will cause unnecessary delay. It is unlikely that you will receive such input, but it is possible that you will receive such input if you paste without bracketed paste.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11854,392419982,2020-03-13T19:09:44Z,src/nvim/move.c,"@@ -1349,8 +1361,8 @@ void scroll_cursor_top(int min_scroll, int always)   linenr_T old_topline = curwin->w_topline;   linenr_T old_topfill = curwin->w_topfill;   linenr_T new_topline;-  assert(p_so <= INT_MAX);-  int off = (int)p_so;+  int off = (int)get_scrolloff_value();+  assert(off <= INT_MAX);","This assert now doesn't do anything. But probably it should just be deleted, range checks are done when options are _set_, and need not be duplicated to every point an option is _used_.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11938,392656159,2020-03-15T09:28:01Z,src/nvim/window.c,"@@ -6988,3 +6993,15 @@ win_T *lastwin_nofloating(void) {   }   return res; }++/*+ * check if there is at least one unanchored floating window.+ */+bool check_unanchored_floats(void) {+  FOR_ALL_TAB_WINDOWS(tp, wp) {",this doesn't seem right. The relevant condition should be unanchored floats in the current tabpage.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/11938,392670965,2020-03-15T12:53:36Z,src/nvim/window.c,"@@ -2451,13 +2450,18 @@ int win_close(win_T *win, bool free_buf)     EMSG(_(""E814: Cannot close window, only autocmd window would remain""));     return FAIL;   }-  if ((firstwin == win && lastwin_nofloating() == win)-      && lastwin->w_floating) {-    // TODO(bfredl): we might close the float also instead+  if (win->w_floating && win->w_float_config.relative == kFloatRelativeWindow",> I used it for the case when the float that is being closed is itself related to the last non-floating window. We shouldn't close the float in that case.But it is not correct. There is no reason to stop closing a _floating window_ just because it is anchored. How would a plugin managing such a float close it? should it un-anchor the float before closing it? that would just be byzantine.,
20684720,yatli,https://api.github.com/repos/neovim/neovim/pulls/11943,396240105,2020-03-23T06:50:53Z,src/nvim/api/ui.c,"@@ -340,7 +345,56 @@ void nvim_ui_pum_set_height(uint64_t channel_id, Integer height, Error *err)                   ""It must support the ext_popupmenu option"");     return;   }-  ui->pum_height = (int)height;++  ui->pum_nlines = (int)height;+}++/// Tells Nvim the geometry of the popumenu, to align floating",Do you mean the help file? I split it into two lines because it doesn't fit into one. There are a few other functions with long signature that takes this two-line form so I adapted that.,X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12040,396689662,2020-03-23T19:04:56Z,src/nvim/CMakeLists.txt,"@@ -311,17 +312,21 @@ add_custom_command(OUTPUT ${GENERATED_UNICODE_TABLES} add_custom_command(   OUTPUT ${GENERATED_API_DISPATCH} ${GENERATED_FUNCS_METADATA}          ${API_METADATA} ${MSGPACK_LUA_C_BINDINGS}+         ${GENERATED_API_DOC_METADATA}   COMMAND ${LUA_PRG} ${API_DISPATCH_GENERATOR} ${CMAKE_CURRENT_LIST_DIR}                      ${GENERATED_API_DISPATCH}                      ${GENERATED_FUNCS_METADATA} ${API_METADATA}                      ${MSGPACK_LUA_C_BINDINGS}+                     ${GENERATED_API_DOC_METADATA}+                     ${PROJECT_SOURCE_DIR}/runtime/doc/api.mpack                      ${API_HEADERS}   DEPENDS     ${API_HEADERS}     ${MSGPACK_RPC_HEADERS}     ${API_DISPATCH_GENERATOR}     ${GENERATOR_C_GRAMMAR}     ${CMAKE_CURRENT_LIST_DIR}/api/dispatch_deprecated.lua+    ${PROJECT_SOURCE_DIR}/runtime/doc/api.mpack",checking in the mpack file is a bit unfortunate but I suppose it avoids adding python as a build dependency?,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/11932,398099395,2020-03-25T19:02:09Z,runtime/lua/vim/lsp/util.lua,"@@ -651,24 +673,26 @@ do     return popup_bufnr, winnr   end -  function M.buf_diagnostics_save_positions(bufnr, diagnostics)+  --- Saves the diagnostics (Diagnostic[]) into diagnostics_by_buf+  --+  function M.buf_diagnostics_save(bufnr, diagnostics)",I don't think it's much of a problem but probably we can avoid the renaming ?,
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/12081,403862705,2020-04-06T06:48:36Z,scripts/vim-patch.sh,"@@ -5,6 +5,12 @@ set -u # Use privileged mode, which e.g. skips using CDPATH. set -p +# Ensure that the user has a bash that supports -A+if [ ""${BASH_VERSION::1}"" -lt 4  ]; then","Should use `BASH_VERSINFO[0]` (""The major version number (the release)."", see `bash(1)`).Otherwise it fails for bash 10 in some years.Have not checked when `BASH_VERSINFO` was added though..If not available long enough it should split `BASH_VERSION` on `.`.",
13387304,xylix,https://api.github.com/repos/neovim/neovim/pulls/12081,403867695,2020-04-06T06:59:54Z,scripts/vim-patch.sh,"@@ -5,6 +5,12 @@ set -u # Use privileged mode, which e.g. skips using CDPATH. set -p +# Ensure that the user has a bash that supports -A+if [ ""${BASH_VERSION::1}"" -lt 4  ]; then","https://github.com/bminor/bash/blob/master/CHANGES#L9370Versinfo was added in bash 2.0, so 1996. Fixed now.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12098,406883379,2020-04-10T18:25:24Z,src/nvim/tui/terminfo.c,"@@ -34,6 +34,18 @@ bool terminfo_is_term_family(const char *term, const char *family)     && ('\0' == term[flen] || '-' == term[flen]); } +bool terminfo_is_screen_host_term_family(const char *term, const char *family)",isn't it possible to reuse terminfo_is_term_family passing `term[7]` instead of `term` as first parameter ?,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12005,407177777,2020-04-12T10:21:58Z,src/nvim/tui/terminfo.c,"@@ -31,7 +31,10 @@ bool terminfo_is_term_family(const char *term, const char *family)   return tlen >= flen     && 0 == memcmp(term, family, flen)     // Per commentary in terminfo, minus is the only valid suffix separator.-    && ('\0' == term[flen] || '-' == term[flen]);+    // The screen terminfo may have a terminal name like screen.xterm. By making","> At least on my distrib, screen goes by `TERM=screen`I think it probably depends on your environment (It could be a system-wide `screenrc`, but isn't it just an old `.screenrc` left over?). In the screen source(`termcap.c`), the part that decides the `TERM` is as follows (`tname` is the `TERM` of the host terminal. The `screenterm` is `""screen""`).```C        do {                strcpy(Term, ""TERM="");                p = Term + 5;                if (!aflag && strlen(screenterm) + strlen(tname) < MAXSTR - 1) {                        sprintf(p, ""%s.%s"", screenterm, tname);                        if (e_tgetent(buf, p) == 1)                                break;                }                ...        }        while (0);              /* Goto free programming... */```Therefore, if the concatnation of `""screen.""` and `TERM` of host terminal is passed to `tgetent`, it will be used as `TERM` if it succeeds. According to git's logs, I don't think it's changed since about 2005. So, I think it depends on the version of terminfo, but I think it's common to have something like `screen.xterm` set in `TERM`. In fact, when I checked with Ubuntu 18.04, Debian 10, and OpenSUSE Tumbleweed, the `TERM` was `screen.xterm-256color` when nothing was set. From #11998, Archlinux seems to be the same.In the `man 7 term`, the root name is written as follows. Therefore, including a dot, like `screen.xterm`, seems to be a legitimate root name. But it violates the requirement of no more than seven characters.> First,  choose  a  root  name.  The root will consist of a lower-case letter followed by up to seven lower-case letters or digits.  You need to avoid using punctuation characters in root names, because they are used and interpreted as filenames and shell meta-characters (such as !, $, *,  ?,  etc.) embedded  in them may cause odd and unhelpful behavior.  The slash (/), or any other character that may be interpreted by anyone's file system (\, $, [, ]), is especially dangerous (terminfo is platform-independent, and choosing names with special characters could someday make  life  difficult  for users  of a future port).  The dot (.) character is relatively safe as long as there is at most one per root name; some historical terminfo names use it.Taking all of the above into consideration, I think the change is justified, as some users are actually having problems with GNU Screen.",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12108,408825865,2020-04-15T13:06:12Z,src/nvim/event/stream.c,"@@ -16,6 +16,11 @@ # include ""event/stream.c.generated.h"" #endif +// For compatbility with libuv < 1.19.0 (tested on 1.18.0)+#ifndef uv_stream_get_write_queue_size",you would have to downgrade `find_package(LibUV 1.28.0 REQUIRED)` . Then you can use LibUV_VERSION_MINOR https://gitlab.kitware.com/cmake/cmake/commit/e56aa462976f80762712519a4cf653b8c45bf3db to conditionally add your define. (I am no cmake expert either so take it with a grain of salt).,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12130,410471328,2020-04-17T21:09:30Z,runtime/lua/vim/lsp/log.lua,"@@ -59,7 +83,7 @@ do         if arg == nil then           table.insert(parts, ""nil"")         else-          table.insert(parts, vim.inspect(arg, {newline=''}))","Yes, format func or similar would be good. Don't want to force people to have their log files get much bigger just due to pretty printing the log. Can be registered per logger.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/11579,410616965,2020-04-18T04:37:48Z,src/nvim/tui/tui.c,"@@ -1230,6 +1228,17 @@ static void show_termcap_event(void **argv)   verbose_stop();  // flush now } +/// Ask the terminal to send us the background color.+static void ask_for_terminal_bg(UI *ui)+{+  if (!option_was_set(""bg"") && !tui_is_stopped(ui)) {",Please do not call the function that accesses the global variables of the main thread from the TUI thread.https://github.com/neovim/neovim/blob/111d04fde64f8be8409cd3b1b96886aee2ac8ff5/src/nvim/tui/tui.c#L425Accessing the global variables of the main thread from the TUI thread after this `CONTINUE(bridge);` may result in a data race.,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12146,410707926,2020-04-18T14:53:40Z,src/nvim/tui/tui.c,"@@ -1973,7 +1973,23 @@ static void flush_buf(UI *ui)   uv_buf_t *bufp = &bufs[0];   TUIData *data = ui->data; -  if (data->bufpos <= 0 && data->busy == data->is_invisible) {+  // The content of the output for each condition is shown in the following+  // table. Therefore, if data->bufpos == 0 and N/A or invis + norm, there is+  // no need to output it.+  //+  //                         | is_invisible | !is_invisible+  // ------+-----------------+--------------+---------------+  // busy  | want_invisible  |     N/A      |    invis+  //       | !want_invisible |     N/A      |    invis+  // ------+-----------------+--------------+---------------+  // !busy | want_invisible  |     N/A      |    invis+  //       | !want_invisible |     norm     | invis + norm+  // ------+-----------------+--------------+---------------+  //+  if (data->bufpos <= 0+      && ((data->busy && data->is_invisible)+          || (data->is_invisible && !data->busy && data->want_invisible)+          || (!data->is_invisible && !data->busy && !data->want_invisible))) {","if I nitpick I would keep the order consistent between the different condition, and ideally with the table:(data->busy / is_invisible / want_invisible",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12146,410797895,2020-04-19T02:44:30Z,src/nvim/tui/tui.c,"@@ -1973,7 +1973,23 @@ static void flush_buf(UI *ui)   uv_buf_t *bufp = &bufs[0];   TUIData *data = ui->data; -  if (data->bufpos <= 0 && data->busy == data->is_invisible) {+  // The content of the output for each condition is shown in the following+  // table. Therefore, if data->bufpos == 0 and N/A or invis + norm, there is+  // no need to output it.+  //+  //                         | is_invisible | !is_invisible+  // ------+-----------------+--------------+---------------+  // busy  | want_invisible  |     N/A      |    invis+  //       | !want_invisible |     N/A      |    invis+  // ------+-----------------+--------------+---------------+  // !busy | want_invisible  |     N/A      |    invis+  //       | !want_invisible |     norm     | invis + norm+  // ------+-----------------+--------------+---------------+  //+  if (data->bufpos <= 0+      && ((data->busy && data->is_invisible)+          || (data->is_invisible && !data->busy && data->want_invisible)+          || (!data->is_invisible && !data->busy && !data->want_invisible))) {","It is corrected to the processing order ( is_invisible / data->busy / want_invisible. I think `busy` and  `want_invisible` are so closely related that it's better to have them next to each other. The table has not been modified because the number of columns exceeds 80 characters. Sure, it's a little hard to see, but if you read it vertically, it's not hard to read, so how about this?",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12164,412473055,2020-04-21T20:35:23Z,runtime/lua/vim/lsp/util.lua,"@@ -833,10 +833,18 @@ do     return count   end   function M.buf_diagnostics_signs(bufnr, diagnostics)-    vim.fn.sign_define('LspDiagnosticsErrorSign', {text=vim.g['LspDiagnosticsErrorSign'] or 'E', texthl='LspDiagnosticsError', linehl='', numhl=''})-    vim.fn.sign_define('LspDiagnosticsWarningSign', {text=vim.g['LspDiagnosticsWarningSign'] or 'W', texthl='LspDiagnosticsWarning', linehl='', numhl=''})-    vim.fn.sign_define('LspDiagnosticsInformationSign', {text=vim.g['LspDiagnosticsInformationSign'] or 'I', texthl='LspDiagnosticsInformation', linehl='', numhl=''})-    vim.fn.sign_define('LspDiagnosticsHintSign', {text=vim.g['LspDiagnosticsHintSign'] or 'H', texthl='LspDiagnosticsHint', linehl='', numhl=''})+    if not vim.fn.sign_getdefined('LspDiagnosticsErrorSign') then","can you make a local function in this file that looks something like:```lualocal function define_default_sign(name, properties)  if not sign_getdefined(...) then    ...  endend```I imagine we'll do some similar stuff later and I don't want people to forget not to constantly overwrite stuff.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/12163,412621529,2020-04-22T02:24:58Z,scripts/gen_vimdoc.py,"@@ -54,6 +59,18 @@     print(""requires Python 3.5+"")     sys.exit(1) +if not shutil.which('doxygen'):+    print(""Missing Requirement: doxygen"")","I realize this is following the existing pattern, but error messages should really be going to stderr.```suggestion    print(""Missing Requirement: doxygen"", file=sys.stderr)```",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/9094,415276120,2020-04-26T10:28:45Z,third-party/patches/unibilium-Add-fallback-func.patch,"@@ -0,0 +1,71 @@+diff --git a/unibilium.h b/unibilium.h+index 7d78fa1..67e704a 100644+--- a/unibilium.h++++ b/unibilium.h+@@ -627,4 +627,7 @@ void unibi_format(+ + size_t unibi_run(const char *, unibi_var_t [9], char *, size_t);+ ++typedef unibi_term *Unibi_Fallback_Func(const char*);++void unibi_set_fallback(Unibi_Fallback_Func *);+++ #endif /* GUARD_UNIBILIUM_H_ */+diff --git a/uniutil.c b/uniutil.c+index 2e266a7..e953787 100644+--- a/uniutil.c++++ b/uniutil.c+@@ -39,6 +39,12 @@ enum {MAX_BUF = 4096};+ + const char *const unibi_terminfo_dirs = TERMINFO_DIRS;+ ++static Unibi_Fallback_Func *fallback_func = NULL;++++void unibi_set_fallback(Unibi_Fallback_Func *func) {","I went through the code again and I don't think this is going to work. Because `unibi_destroy()` is called in [`load_terminfo()`](https://github.com/neovim/libtermkey/blob/b7fe3af141c53cce71a244282b69ea860452120a/driver-ti.c#L275) when calling [`termkey_start()`](https://github.com/neovim/libtermkey/blob/b7fe3af141c53cce71a244282b69ea860452120a/termkey.c#L492), `override_unibi` will be released. If we want to implement this, I think we need to deep copy `unibit_term`. As you can see from the beginning of [unibilium.c](https://github.com/neovim/unibilium/blob/0c5fa34f78503e23484da0294339ea1c209c4866/unibilium.c), deep-copying `unibi_term` seems a bit daunting. Or, it must be managed by a reference counter.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12186,415358978,2020-04-26T17:28:47Z,test/functional/plugin/lsp_spec.lua,"@@ -861,4 +861,29 @@ describe('LSP', function()       ]])     end)   end)+  describe('lsp.util.show_line_diagnostics', function()+    it('creates floating window and returns popup bufnr and winnr if current line contains diagnostics', function()+      eq(3, exec_lua [[+        BUFFER = vim.api.nvim_create_buf(false, true)","generally better to use `local` unless there is some technical reason a global is needed.```suggestion        local BUFFER = vim.api.nvim_create_buf(false, true)```All Lua scripts run in a closure, so they always have some form of ""local"" scope. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12096,416671756,2020-04-28T14:43:35Z,runtime/lua/vim/lsp/util.lua,"@@ -325,7 +325,13 @@ function M.jump_to_location(location)   local bufnr = vim.uri_to_bufnr(location.uri)   -- Save position in jumplist   vim.cmd ""normal! m'""-  -- TODO(ashkan) use tagfunc here to update tagstack.++  -- Push a new item into tagstack+  local items = {}+  table.insert(items, {tagname=vim.fn.expand(""<cword>""), from=vim.fn.getpos('.')})+  vim.fn.settagstack(vim.fn.bufnr('%'), {items=items}, 't')","> I have no idea how to add test case(s) for the project and run them. Is there any documentation to help to write test cases? If no, I will study it.See `test/functional/example_spec.lua` for example. You can [run the test](https://github.com/neovim/neovim/blob/master/test/README.md#running-tests) like this:    TEST_FILE=test/functional/example_spec.lua make functionaltestMore docs at https://github.com/neovim/neovim/blob/master/test/README.md",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12191,418629111,2020-05-01T16:50:56Z,test/functional/plugin/lsp_spec.lua,"@@ -813,6 +813,74 @@ describe('LSP', function()     end)   end) +  describe('apply_text_document_edit', function()+    before_each(function()+      insert(dedent([[+        First line of text+        Second line of text]]))+    end)+    it('correctly goes ahead with the edit when all is normal', function()+      local text_document_edit = {+        edits = {+          range = {+            start = { line = 1, character = 1 };+            [""end""] = { line = 1, character = 2 };+          },+          newText = ""bar""+        },+        textDocument = {+          uri = ""/fake/uri"";+          version = 5+        }+      }+      exec_lua('vim.lsp.util.apply_text_document_edit(...)', text_document_edit, 1)","Try printing the value returned by `bufnr = vim.uri_to_bufnr(text_document.uri)`. `vim.lsp.util.buf_versions={4,5}` fills the buf_versions with a list such that `buf_versions[1]= 4 buf_versions[2]=5`. If the printed value is not in that range 1-2 than the call would fail.",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12224,418920098,2020-05-02T06:24:19Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -62,6 +62,14 @@ M['textDocument/documentSymbol'] = function(_, _, result, _, bufnr)   api.nvim_command(""wincmd p"") end +M['workspace/symbol'] = function(_, _, result, _, bufnr)+  if not result or vim.tbl_isempty(result) then return end++  util.set_qflist(util.symbols_to_items(result, bufnr))+  api.nvim_command(""copen"")+  api.nvim_command(""wincmd p"")+end+","```suggestionlocal symbol_callback = function(_, _, result, _, bufnr)  if not result or vim.tbl_isempty(result) then return end  util.set_qflist(util.symbols_to_items(result, bufnr))  api.nvim_command(""copen"")  api.nvim_command(""wincmd p"")endM['textDocument/documentSymbol'] = symbol_callbackM['workspace/symbol'] = handle_symbol = symbol_callback```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/11607,419492761,2020-05-04T14:47:25Z,runtime/lua/vim/lsp/util.lua,"@@ -684,19 +684,27 @@ do     return severity_highlights[severity]   end -  function M.show_line_diagnostics()+  function M.get_line_diagnostics()     local bufnr = api.nvim_get_current_buf()     local line = api.nvim_win_get_cursor(0)[1] - 1++    local buffer_diagnostics = M.diagnostics_by_buf[bufnr]+    if not buffer_diagnostics then+      return {}+    end++    local line_diagnostics = buffer_diagnostics[line]","I think this is now outdated as the `diagnostics_by_buf` are no longer grouped by line by default, and there is also https://github.com/neovim/neovim/pull/12244 which will change the format further.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12232,419674660,2020-05-04T19:28:51Z,runtime/lua/vim/lsp/extensions.lua,"@@ -0,0 +1,50 @@+local vim = vim+local validate = vim.validate+local log = require 'vim.lsp.log'+local util = require 'vim.lsp.util'+local buf = require 'vim.lsp.buf'++local M = {}++-- copied from buf.lua+local function request(method, params, callback)","I was suggesting you just make this `request_peek` and remove the callback parameter, and then use that throughout this file. Remove the copied from buf.lua as well then when you do that.",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12253,420548146,2020-05-06T05:09:54Z,runtime/lua/vim/lsp/util.lua,"@@ -438,6 +438,7 @@ function M.jump_to_location(location)    --- Jump to new location   api.nvim_set_current_buf(bufnr)+  api.nvim_buf_set_option(bufnr, 'buflisted', true)","""0"" is faster, but it doesn't make a difference as much as I care about here, so I think either one is fine.https://github.com/neovim/neovim/blob/master/src/nvim/api/buffer.c#L929https://github.com/neovim/neovim/blob/master/src/nvim/api/private/helpers.c#L625-L631https://github.com/neovim/neovim/blob/master/src/nvim/api/private/handle.c#L16-L19",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12257,420741873,2020-05-06T12:12:55Z,runtime/lua/vim/lsp/util.lua,"@@ -203,6 +203,13 @@ local function remove_unmatch_completion_items(items, prefix)   end, items) end +-- Acording to LSP spec, if the client set ""completionItemKind.valueSet"",+-- the client must handle it properly even if it receives a value outside the specification.+-- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion+function M.get_completion_item_kind_name(completion_item_kind)","Well, it might be useful to allow for customizable kind names (per server)?(Since the built-in LSP is supposed to be low-level, having a larger, composable, API of small functions would be helpful.)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/12257,420780861,2020-05-06T13:16:09Z,runtime/lua/vim/lsp/util.lua,"@@ -203,6 +203,13 @@ local function remove_unmatch_completion_items(items, prefix)   end, items) end +-- Acording to LSP spec, if the client set ""completionItemKind.valueSet"",+-- the client must handle it properly even if it receives a value outside the specification.+-- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion+function M.get_completion_item_kind_name(completion_item_kind)","> Since the built-in LSP is supposed to be low-level, having a larger, composable, API of small functions would be helpfulI agree that it would be helpful, but it is a tradeoff. Once a method is public it becomes harder to change it because of BWC. (At least once 0.5 is out) - so I think being a bit conservative about exposing methods may be beneficial.Just my opinion, not sure how the maintainers see that.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/12264,421377417,2020-05-07T09:44:35Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -54,9 +54,10 @@ M['textDocument/references'] = function(_, _, result)   api.nvim_command(""wincmd p"") end -local symbol_callback = function(_, _, result, _, bufnr)","As far as I can tell `bufnr` isn't set. This was always `nil`.Maybe the better solution would be to actually set it, because I think the solution I went for now has a race condition (user switches buffer before the callback is triggered)",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12264,421457735,2020-05-07T12:16:20Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -54,9 +54,10 @@ M['textDocument/references'] = function(_, _, result)   api.nvim_command(""wincmd p"") end -local symbol_callback = function(_, _, result, _, bufnr)","@mfussenegger @clason I'm so sorry. I misunderstood various things.To avoid race conditions, I think it is better to investigate why `bufnr` becomes nil and fix it if possible.I think we can use either `fname` or `bufnr` for qlist.I thought that we should use `fname` because `workspace/symbol` does not always refer to a file that has already been opened, so we should use `fname`, but if the target file does not already have a buffer, `uri_to_bufnr` does `bufadd` so there should be no problem.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/12264,421738524,2020-05-07T19:22:54Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -198,12 +198,12 @@ end  -- Add boilerplate error validation and logging for all of these. for k, fn in pairs(M) do-  M[k] = function(err, method, params, client_id)-    local _ = log.debug() and log.debug('default_callback', method, { params = params, client_id = client_id, err = err })+  M[k] = function(err, method, params, client_id, bufnr)+    local _ = log.debug() and log.debug('default_callback', method, { params = params, client_id = client_id, err = err, bufnr = bufnr })",I think it's to avoid executing logic as part of the second `log.debug(..)` call. In this case it would be the table creation with all the parameters. Not sure if it's worth avoiding that in lua.I think if the decision is to avoid this style of logging then it would also make sense to remove the possibility to use the single args variant for a quick log-level check - otherwise this would be prune for personal-preference bike-shedding. (I don't mind either way - pushed a fixup to drop the call for now),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422209956,2020-05-08T15:30:02Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,26 @@+local api = vim.api++-- highlight the yanked region with highlight group higroup for timeout ms +-- use from init.vim via +--   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+return function(event, higroup, timeout)+    if event.operator ~= 'y' or event.regtype == '' then return end++    local bn = api.nvim_get_current_buf()+    local ns = api.nvim_create_namespace('hlyank')+    api.nvim_buf_clear_namespace(bn, ns, 0, -1)++    local pos1 = vim.fn.getpos(""'["")+    local lin1, col1, off1 = pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(""']"")+    local lin2, col2, off2 = pos2[2] - 1, pos2[3] - (event.inclusive and 0 or 1), pos2[4]+    for l = lin1, lin2 do+        local c1 = (l == lin1 or event.regtype:byte() == 22) and (col1 + off1) or 0+        local c2 = (l == lin2 or event.regtype:byte() == 22) and (col2 + off2) or -1+        api.nvim_buf_add_highlight(bn, ns, higroup, l, c1, c2)+    end","my plan was to extract this part to a generic function that takes a pair of marks and returns a ""region"" (list of row/col pairs). That's something that is sorely missed in Vimscript. can we do that here?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422211096,2020-05-08T15:32:06Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,26 @@+local api = vim.api++-- highlight the yanked region with highlight group higroup for timeout ms +-- use from init.vim via +--   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+return function(event, higroup, timeout)+    if event.operator ~= 'y' or event.regtype == '' then return end++    local bn = api.nvim_get_current_buf()+    local ns = api.nvim_create_namespace('hlyank')+    api.nvim_buf_clear_namespace(bn, ns, 0, -1)++    local pos1 = vim.fn.getpos(""'["")+    local lin1, col1, off1 = pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(""']"")+    local lin2, col2, off2 = pos2[2] - 1, pos2[3] - (event.inclusive and 0 or 1), pos2[4]+    for l = lin1, lin2 do+        local c1 = (l == lin1 or event.regtype:byte() == 22) and (col1 + off1) or 0+        local c2 = (l == lin2 or event.regtype:byte() == 22) and (col2 + off2) or -1+        api.nvim_buf_add_highlight(bn, ns, higroup, l, c1, c2)+    end","btw there were some [bugs](https://github.com/justinmk/config/blob/47ab07760d6b5eeb38164333931ac35963a64d41/.config/nvim/init.vim#L1104-L1107) in the original logic but we don't need to solve those initially, though it's certainly welcome.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422221444,2020-05-08T15:51:38Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,26 @@+local api = vim.api++-- highlight the yanked region with highlight group higroup for timeout ms +-- use from init.vim via +--   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+return function(event, higroup, timeout)+    if event.operator ~= 'y' or event.regtype == '' then return end++    local bn = api.nvim_get_current_buf()+    local ns = api.nvim_create_namespace('hlyank')+    api.nvim_buf_clear_namespace(bn, ns, 0, -1)++    local pos1 = vim.fn.getpos(""'["")+    local lin1, col1, off1 = pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(""']"")+    local lin2, col2, off2 = pos2[2] - 1, pos2[3] - (event.inclusive and 0 or 1), pos2[4]+    for l = lin1, lin2 do+        local c1 = (l == lin1 or event.regtype:byte() == 22) and (col1 + off1) or 0+        local c2 = (l == lin2 or event.regtype:byte() == 22) and (col2 + off2) or -1+        api.nvim_buf_add_highlight(bn, ns, higroup, l, c1, c2)+    end","invert was one case, but main case that bugs me is this:```text text texttext text texttext text```with `<c-v>$jjy` the highlighted ""region"" does not include the 3rd ""text"" column. Since the region is a rectangle (only 2 rol/col pairs), the far column  should perhaps be determined by the longest line of text, rather than where the cursor happens to be placed.~~Alternatively~~ (edit: this isn't ""alternative"", it's the main purpose...) the function could return a ""jagged"" region: _multiple_ rectangles. Then the caller would need to call `nvim_buf_add_highlight` for each rectangle. This would be useful for UIs and various plugins too.For highlighted yank it doesn't matter too much, so the ""multiple rectangles"" result could be opt-in via a parameter.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12279,422260106,2020-05-08T17:06:50Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,29 @@+local api = vim.api+local namespace = api.nvim_create_namespace('hlyank')++-- highlight the yanked region with highlight group higroup for timeout ms +-- use from init.vim via+--   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+return function(event, higroup, timeout)+    if event.operator ~= 'y' or event.regtype == '' then return end+    local event = event or vim.v.event+    local higroup = higroup or 'IncSearch'+    local timeout = timeout or 500++    local bufnr = api.nvim_get_current_buf()+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)++    local pos1 = vim.fn.getpos(""'["")+    local lin1, col1, off1 = pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(""']"")+    local lin2, col2, off2 = pos2[2] - 1, pos2[3] - (event.inclusive and 0 or 1), pos2[4]+    for l = lin1, lin2 do+        local c1 = (l == lin1 or event.regtype:byte() == 22) and (col1 + off1) or 0+        local c2 = (l == lin2 or event.regtype:byte() == 22) and (col2 + off2) or -1+        api.nvim_buf_add_highlight(bufnr, namespace, higroup, l, c1, c2)+    end++    vim.loop.new_timer():start(timeout, 0, vim.schedule_wrap(function() ",It looks like yeah: https://github.com/luvit/luv/blob/master/docs.md#uv_timer_t--timer-handle,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12279,422318743,2020-05-08T19:05:22Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,26 @@+local api = vim.api++-- highlight the yanked region with highlight group higroup for timeout ms +-- use from init.vim via +--   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+return function(event, higroup, timeout)+    if event.operator ~= 'y' or event.regtype == '' then return end++    local bn = api.nvim_get_current_buf()+    local ns = api.nvim_create_namespace('hlyank')+    api.nvim_buf_clear_namespace(bn, ns, 0, -1)++    local pos1 = vim.fn.getpos(""'["")+    local lin1, col1, off1 = pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(""']"")+    local lin2, col2, off2 = pos2[2] - 1, pos2[3] - (event.inclusive and 0 or 1), pos2[4]+    for l = lin1, lin2 do+        local c1 = (l == lin1 or event.regtype:byte() == 22) and (col1 + off1) or 0+        local c2 = (l == lin2 or event.regtype:byte() == 22) and (col2 + off2) or -1+        api.nvim_buf_add_highlight(bn, ns, higroup, l, c1, c2)+    end","Yeah, the problem is specifically the case of block visual selection where the end mark is on an EOL -- in this case `getpos` returns a useless (can't exactly say ""wrong"", there may be a good reason for it) result. Not sure how to deal with this :/",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12275,422446594,2020-05-09T03:14:04Z,src/nvim/ex_cmds2.c,"@@ -1045,9 +1045,10 @@ static void profile_reset(void)         uf->uf_tm_self      = profile_zero();         uf->uf_tm_children  = profile_zero(); -        XFREE_CLEAR(uf->uf_tml_count);-        XFREE_CLEAR(uf->uf_tml_total);-        XFREE_CLEAR(uf->uf_tml_self);+        for (int i = 0; i < uf->uf_lines.ga_len; i++) {+          uf->uf_tml_count[i] = 0;+          uf->uf_tml_total[i] = uf->uf_tml_self[i] = 0;+        }","The change by vim-patch:8.1.0130 (https://github.com/neovim/neovim/commit/7823b357812b06da7348a5b4f5a66afae8f1f71c) needs to be changed to clear the memory at zero instead of freeing it. We missed it. Therefore, this change does not result in the wrong profile result.There were other things that seemed to need fixing, so I fixed that too. I also added a test because I think the reason we missed this was that the test was incomplete.",
1372918,archseer,https://api.github.com/repos/neovim/neovim/pulls/12279,422468323,2020-05-09T08:17:59Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,26 @@+local api = vim.api++-- highlight the yanked region with highlight group higroup for timeout ms +-- use from init.vim via +--   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+return function(event, higroup, timeout)+    if event.operator ~= 'y' or event.regtype == '' then return end++    local bn = api.nvim_get_current_buf()+    local ns = api.nvim_create_namespace('hlyank')+    api.nvim_buf_clear_namespace(bn, ns, 0, -1)++    local pos1 = vim.fn.getpos(""'["")+    local lin1, col1, off1 = pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(""']"")+    local lin2, col2, off2 = pos2[2] - 1, pos2[3] - (event.inclusive and 0 or 1), pos2[4]+    for l = lin1, lin2 do+        local c1 = (l == lin1 or event.regtype:byte() == 22) and (col1 + off1) or 0+        local c2 = (l == lin2 or event.regtype:byte() == 22) and (col2 + off2) or -1+        api.nvim_buf_add_highlight(bn, ns, higroup, l, c1, c2)+    end","Yeah I have a similar function for coordinates/extmarks: https://github.com/archseer/snippets.nvim/blob/0f55f3477385a1a2a6dfa353541e438d40565981/lua/snippet/init.lua#L129-L139I think in the long run there will be extmark decorations (currently used for bufhl?) and extranges, so it'll just be a decoration on the extrange.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12279,422507113,2020-05-09T15:16:03Z,runtime/lua/hl-yank.lua,"@@ -0,0 +1,88 @@+local api = vim.api+local namespace = api.nvim_create_namespace('hlyank')++--- Get table of lines with start, end columns for given marks+---+-- @param mark1 mark of beginning of range+-- @param mark2 mark of end of range+-- @param regtype type of selection that is yanked (:help setreg)+-- @param boolean indicating whether the selection is end-inclusive+local function marks_to_region(mark1, mark2, regtype, inclusive)+    local pos1 = vim.fn.getpos(mark1)+    local buf1, lin1, col1, off1 = pos1[1], pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(mark2)+    local buf2, lin2, col2, off2 = pos2[1], pos2[2] - 1, pos2[3] - (inclusive and 0 or 1), pos2[4]++    -- in case of block selection, columns need to be adjusted for multibyte characters+    local bufline+    if regtype:byte() == 22 then+        bufline = api.nvim_buf_get_lines(0, lin1, lin1+1, true)[1]+        col1 = vim.str_utfindex(bufline, col1)+    end++    local region = {}+    for l = lin1, lin2 do+        local c1,c2+        if regtype:byte() == 22 then  -- block selection: take width from regtype+            c1 = col1 + off1+            c2 = c1 + regtype:sub(2) +            -- and adjust for multibyte characters+            bufline = api.nvim_buf_get_lines(0, l, l+1, true)[1]+            if c1 < #bufline then+                c1 = vim.str_byteindex(bufline, c1)+            end+            if c2 < #bufline then+                c2 = vim.str_byteindex(bufline, c2)+            end+        else+            c1 = (l == lin1) and (col1 + off1) or 0+            c2 = (l == lin2) and (col2 + off2) or -1+        end+        table.insert(region,l,{c1,c2})+    end+    return region+end++--- Defers calling `fn` until `timeout` ms passes.+---+--- Use to do a one-shot timer that calls `fn`+--@param fn Callback to call once `timeout` expires+--@param timeout Number of milliseconds to wait before calling `fn`+local function schedule_fn(fn, timeout)+    vim.validate { fn = { fn, 'f', true}; }+    local timer = vim.loop.new_timer()+    timer:start(timeout, 0, vim.schedule_wrap(function()+        timer:stop()+        timer:close()++        fn()+    end))++    return timer+end++--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'hl_yank'(vim.v.event, 'IncSearch', 500)+-- @param event event structure+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+return function(event, higroup, timeout)","Can we move event to the last parameter, since it's most likely not to be overridden?And then in the example above, you can show how to add it with the defaults or to override as well would be good. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12275,422520699,2020-05-09T17:05:58Z,test/functional/ex_cmds/profile_spec.lua,"@@ -23,6 +25,19 @@ local function assert_file_exists_not(filepath)   eq(nil, lfs.attributes(filepath, 'uid')) end +local function read_file(filepath)","looks similar to `test/helpers.lua:read_file()`. Perhaps that one could be changed to return `msg`, then we don't need this one?o(though it looks like we aren't using `msg` anyway)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422522914,2020-05-09T17:26:17Z,runtime/lua/hl_yank.lua,"@@ -0,0 +1,29 @@+--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'hl_yank'()+--- customize highlight group and timeout via+---   au TextYankPost * lua require'hl_yank'(""IncSearch"", 500)+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+-- @param event event structure+return function(higroup, timeout, event)","This limits potentially adding more API later. Shouldn't we stick with thesimple pattern of returning a table of functions, rather than making the modulecallable?IIRC `require(""inspect"")` works like you have done here, but we don't exposethat module offically, we expose it as `vim.inspect`.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12279,422523429,2020-05-09T17:31:00Z,runtime/lua/hl_yank.lua,"@@ -0,0 +1,29 @@+--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'hl_yank'()+--- customize highlight group and timeout via+---   au TextYankPost * lua require'hl_yank'(""IncSearch"", 500)+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+-- @param event event structure+return function(higroup, timeout, event)","If we want to change it later w/out breaking backwards compat, you can make this return a table, with a metamethod `__call` that does this (I think that's the right metamethod). So we can do it like this and then later expose more if we wanted to.I had suggested this initially because I liked doing `require('hl_yank')()` or similar.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12279,422524029,2020-05-09T17:36:30Z,src/nvim/lua/vim.lua,"@@ -386,4 +386,64 @@ do   vim.wo = new_win_opt_accessor(nil) end +--- Get table of lines with start, end columns for given marks+---+-- @param mark1 mark of beginning of range+-- @param mark2 mark of end of range+-- @param regtype type of selection that is yanked (:help setreg)+-- @param boolean indicating whether the selection is end-inclusive+function vim.marks_to_region(mark1, mark2, regtype, inclusive)+    local pos1 = vim.fn.getpos(mark1)+    local buf1, lin1, col1, off1 = pos1[1], pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(mark2)+    local buf2, lin2, col2, off2 = pos2[1], pos2[2] - 1, pos2[3] - (inclusive and 0 or 1), pos2[4]++    -- in case of block selection, columns need to be adjusted for multibyte characters+    local bufline+    if regtype:byte() == 22 then","Note that the regtype is longer in this case (`^V6`, for example, if the block is 6 columns wide), so you do need to match specifically on the first byte. (`byte()` without an argument returns the first byte.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422524119,2020-05-09T17:37:32Z,src/nvim/lua/vim.lua,"@@ -386,4 +386,64 @@ do   vim.wo = new_win_opt_accessor(nil) end +--- Get table of lines with start, end columns for given marks+---+-- @param mark1 mark of beginning of range+-- @param mark2 mark of end of range+-- @param regtype type of selection that is yanked (:help setreg)+-- @param boolean indicating whether the selection is end-inclusive+function vim.marks_to_region(mark1, mark2, regtype, inclusive)+    local pos1 = vim.fn.getpos(mark1)+    local buf1, lin1, col1, off1 = pos1[1], pos1[2] - 1, pos1[3] - 1, pos1[4]+    local pos2 = vim.fn.getpos(mark2)+    local buf2, lin2, col2, off2 = pos2[1], pos2[2] - 1, pos2[3] - (inclusive and 0 or 1), pos2[4]++    -- in case of block selection, columns need to be adjusted for multibyte characters+    local bufline+    if regtype:byte() == 22 then+        bufline = vim.api.nvim_buf_get_lines(buf1, lin1, lin1 + 1, true)[1]",if we accept `bufnr` parameter then we will need this somewhere in the function:```if not vim.api.nvim_buf_is_loaded(bufnr) then  vim.fn.bufload(bufnr)end```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422525800,2020-05-09T17:53:39Z,runtime/lua/hl_yank.lua,"@@ -0,0 +1,29 @@+--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'hl_yank'()+--- customize highlight group and timeout via+---   au TextYankPost * lua require'hl_yank'(""IncSearch"", 500)+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+-- @param event event structure+return function(higroup, timeout, event)",The difference is that we then have multiple conventions for modules. Why?> Not sure what this could be expanded with?That is never relevant. Trying to predict the future leads to bad APIs.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12279,422526091,2020-05-09T17:56:32Z,src/nvim/lua/vim.lua,"@@ -386,4 +386,64 @@ do   vim.wo = new_win_opt_accessor(nil) end +--- Get table of lines with start, end columns for given marks+---+-- @param mark1 mark of beginning of range+-- @param mark2 mark of end of range+-- @param regtype type of selection that is yanked (:help setreg)+-- @param boolean indicating whether the selection is end-inclusive+function vim.marks_to_region(mark1, mark2, regtype, inclusive)","Everything after line 399 is generic to any pair of `(row,col)` coordinates + region `type` + `inclusive` flag.""reg type"" is a misnomer, the `type` parameter is just a flag that decides (charwise, linewise, block).",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12279,422526486,2020-05-09T17:59:53Z,runtime/lua/hl_yank.lua,"@@ -0,0 +1,29 @@+--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'hl_yank'()+--- customize highlight group and timeout via+---   au TextYankPost * lua require'hl_yank'(""IncSearch"", 500)+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+-- @param event event structure+return function(higroup, timeout, event)","Agreed on trying to predict future = bad.I'm fine w/ returning a table, and exposing the function as `highlight_region` or something like that. Not to particular about the name.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12244,425868474,2020-05-15T15:11:27Z,runtime/lua/vim/lsp/util.lua,"@@ -759,25 +778,26 @@ do     return popup_bufnr, winnr   end -  --- Saves the diagnostics (Diagnostic[]) into diagnostics_by_buf+  --- Saves the diagnostics (Diagnostic[]) into diagnostics_by_buf_and_client_id   ---  function M.buf_diagnostics_save_positions(bufnr, diagnostics)+  function M.buf_diagnostics_save_positions(bufnr, client_id, diagnostics)","Can you make the new parameter at the end? Also, it should be optional, right? So we can set it to be -1 or whatever  want as a default.Otherwise this is not backwards compatible as well.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12319,426124015,2020-05-16T06:20:48Z,src/nvim/option.c,"@@ -6987,22 +6985,34 @@ static int opt_strings_flags( {   unsigned int new_flags = 0; -  while (*val) {+  if (*val == NUL) {","There seem to be some options with a string forms that allow the empty and some that don't. For example, the `ambw` option allows empty, so `set ambw=` is allowed. On the other hand, `set wak=` will give an `E474` error because `wak` does not allow empty.Until now, for the do not allow empty option, we had to check if the caller is empty, as shown in the code below. This PR change checks whether the `p_option_values` array contains a `""""` or not. Therefore, `if (*val == NUL) { return FAIL; }` is not sufficient.https://github.com/neovim/neovim/blob/f3d0a1741ef69222ab7893ce4f801d26b6b3fb00/src/nvim/option.c#L2747-L2750",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/11969,426258099,2020-05-17T12:52:47Z,runtime/lua/vim/shared.lua,"@@ -228,7 +219,9 @@ function vim.tbl_extend(behavior, ...)     vim.validate{[""after the second argument""] = {tbl,'t'}}     if tbl then       for k, v in pairs(tbl) do-        if behavior ~= 'force' and ret[k] ~= nil then+        if type(v) == 'table' and deep_extend and not vim.tbl_islist(v) then","Why `and not vim.tbl_islist(v)`?I would expect deep extend to also copy table elements?```luapoints = { { x = 1, y = 1}, { x = 3, y = 5} }```",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12342,427040653,2020-05-19T05:36:34Z,src/nvim/api/buffer.c,"@@ -126,6 +126,7 @@ String buffer_get_line(Buffer buffer, Integer index, Error *err) /// @param  opts  Optional parameters. ///             - on_lines: Lua callback invoked on change. ///               Return `true` to detach. Args:+///               - ""lines""",https://github.com/neovim/neovim/blob/f5c56f03bb9ee25c3d931034497dc76a5591b770/src/nvim/buffer_updates.c#L240,
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12342,427040937,2020-05-19T05:37:36Z,src/nvim/api/buffer.c,"@@ -136,9 +137,11 @@ String buffer_get_line(Buffer buffer, Integer index, Error *err) ///               - deleted_codeunits (if `utf_sizes` is true) ///             - on_changedtick: Lua callback invoked on changedtick ///               increment without text change. Args:+///               - ""changedtick""",https://github.com/neovim/neovim/blob/f5c56f03bb9ee25c3d931034497dc76a5591b770/src/nvim/buffer_updates.c#L279,
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12342,427040970,2020-05-19T05:37:40Z,src/nvim/api/buffer.c,"@@ -136,9 +137,11 @@ String buffer_get_line(Buffer buffer, Integer index, Error *err) ///               - deleted_codeunits (if `utf_sizes` is true) ///             - on_changedtick: Lua callback invoked on changedtick ///               increment without text change. Args:+///               - ""changedtick"" ///               - buffer handle ///               - b:changedtick ///             - on_detach: Lua callback invoked on detach. Args:+///               - ""detach""",https://github.com/neovim/neovim/blob/64cdf9f78a9bfd4d08a9d9bf2df48a4b2f296190/src/nvim/buffer_updates.c#L157,
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12118,428548365,2020-05-21T09:35:14Z,runtime/lua/vim/lsp/util.lua,"@@ -199,6 +199,66 @@ function M.get_current_line_to_cursor()   return line:sub(pos[2]+1) end +local function parse_snippet_rec(input, inner)+  local res = """"++  local close, closeend = nil, nil+  if inner then+    close, closeend = input:find(""}"", 1, true)+    while close ~= nil and input:sub(close-1,close-1) == ""\\"" do+      close, closeend = input:find(""}"", closeend+1, true)+    end+  end++  local didx = input:find('$',  1, true)+  if didx == nil and close == nil then+    return input, """"+  elseif close ~=nil and (didx == nil or close < didx) then+    -- No inner placeholders+    return input:sub(0, close-1), input:sub(closeend+1)+  end++  res = res .. input:sub(0, didx-1)+  input = input:sub(didx+1)++  local tabstop, tabstopend = input:find('^%d+')+  local placeholder, placeholderend = input:find('^{%d+:')+  local choice, choiceend = input:find('^{%d+|')++  if tabstop then+    input = input:sub(tabstopend+1)+  elseif choice then+    input = input:sub(choiceend+1)+    close, closeend = input:find(""|}"", 1, true)++    res = res .. input:sub(0, close-1)+    input = input:sub(closeend+1)+  elseif placeholder then+    -- TODO: add support for variables+    input = input:sub(placeholderend+1)++    -- placeholders and variables are recursive+    while input ~= """" do+      local r, tail = parse_snippet_rec(input, true)+      r = r:gsub(""\\}"", ""}"")++      res = res .. r+      input = tail+    end+  else+    res = res .. ""$""+  end++  return res, input+end++-- Parse completion entries, consuming snippet tokens+function M.parse_snippet(input)+  local res, _ = parse_snippet_rec(input, false)",`parse_snippet_rec` is a private function and used by only `M.parse_snippet`.Why should it have flag argument and return unused input?,X
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12118,429020753,2020-05-22T03:11:40Z,test/functional/plugin/lsp_spec.lua,"@@ -967,6 +972,9 @@ describe('LSP', function()         { abbr = 'foocar', dup = 1, empty = 1, icase = 1, info = ' ', kind = 'Unknown', menu = '', word = 'foobar', user_data = { nvim = { lsp = { completion_item = { label='foocar', insertText='foobar', textEdit={} } } } } },         { abbr = 'foocar', dup = 1, empty = 1, icase = 1, info = ' ', kind = 'Unknown', menu = '', word = 'foobar', user_data = { nvim = { lsp = { completion_item = { label='foocar', insertText='foodar', textEdit={newText='foobar'} } } } } },         { abbr = 'foocar', dup = 1, empty = 1, icase = 1, info = ' ', kind = 'Unknown', menu = '', word = 'foobar', user_data = { nvim = { lsp = { completion_item = { label='foocar', textEdit={newText='foobar'} } } } } },+        { abbr = 'foocar', dup = 1, empty = 1, icase = 1, info = ' ', kind = 'Unknown', menu = '', word = 'foobar(place holder, more ...holder{})', user_data = { nvim = { lsp = { completion_item = { label='foocar', insertText='foodar', textEdit={newText='foobar(${1:place holder}, ${2:more ...holder{\\}})'} } } } } },+        { abbr = 'foocar', dup = 1, empty = 1, icase = 1, info = ' ', kind = 'Unknown', menu = '', word = 'foodar(var1 typ1, var2 *typ2) {}', user_data = { nvim = { lsp = { completion_item = { label='foocar', insertText='foodar(${1:var1} typ1, ${2:var2} *typ2) {$0\\}', textEdit={} } } } } },+        { abbr = 'foocar', dup = 1, empty = 1, icase = 1, info = ' ', kind = 'Unknown', menu = '', word = 'foodar(var1 typ2,typ3 tail) {}', user_data = { nvim = { lsp = { completion_item = { label='foocar', insertText='foodar(${1:var1 ${2|typ2,typ3|} ${3:tail}}) {$0\\}', textEdit={} } } } } },","You may find it helpful to expand the parser test by referring to this.For that reason, it may be better to use the unit test of ""M.parse_snippet"".https://github.com/microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/test/snippetParser.test.ts",
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12348,429720250,2020-05-25T03:45:54Z,runtime/doc/lua.txt,"@@ -827,6 +827,61 @@ vim.schedule({callback})				*vim.schedule()*         Schedules {callback} to be invoked soon by the main event-loop. Useful         to avoid |textlock| or other temporary restrictions. ++vim.defer_fn({fn}, {timeout})                                    *vim.defer_fn*+    Defers calling {fn} until {timeout} ms passes.  Use to do a one-shot timer+    that calls {fn}.++    Parameters: ~+        {fn}        Callback to call once {timeout} expires+        {timeout}   Time in ms to wait before calling {fn}++    Returns: ~+        |vim.loop|.new_timer() object++vim.wait({time}, {callback} [, {interval}])                         *vim.wait()*+        Wait for {time} in milliseconds until {callback} returns `true`.++        Executes {callback} at approximately {interval} milliseconds+        (default 200). Nvim still processes other events during this time.","@teto http://docs.libuv.org/en/v1.x/timer.html?highlight=uv_timer_start#c.uv_timer_start> If timeout is zero, the callback fires on the next event loop iteration. If repeat is non-zero, the callback fires first after timeout milliseconds and then repeatedly after repeat milliseconds.And the default interval of 200ms seems to be good because it is aligned with `f_wait`.https://github.com/neovim/neovim/blob/master/src/nvim/eval/funcs.c#L3838-L3840",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12368,430362465,2020-05-26T12:07:34Z,runtime/lua/vim/lsp/util.lua,"@@ -481,6 +481,29 @@ function M.jump_to_location(location)   return true end +--- Preview a location in a floating windows+---+--- behavior depends on type of location:+---   - for Location, range is shown (e.g., function definition)+---   - for LocationLink, targetRange is shown (e.g., body of function definition)+---   - for an array of either, the first element is shown+---+--@param location Location, LocationLink, or array thereof+--@return bufnr,winnr buffer and window number of floating window or nil+function M.preview_location(location)",Does this actually handle a list of locations? It doesn't look like it from reading the source.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12368,430388406,2020-05-26T12:53:09Z,runtime/lua/vim/lsp/util.lua,"@@ -481,6 +481,29 @@ function M.jump_to_location(location)   return true end +--- Preview a location in a floating windows+---+--- behavior depends on type of location:+---   - for Location, range is shown (e.g., function definition)+---   - for LocationLink, targetRange is shown (e.g., body of function definition)+---   - for an array of either, the first element is shown+---+--@param location Location, LocationLink, or array thereof+--@return bufnr,winnr buffer and window number of floating window or nil+function M.preview_location(location)","I think it's fine to handle them here. LSP spec has this all over the place (which is annoying), where it passes `X or X[]`, so it goes more w/ the spirit of LSP IMO. Additionally, if someone wants the second one in the list... they can just parse the list and use only the second one. So I'd say handling a list would be helpful and in the spirit of spec.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12368,430395505,2020-05-26T13:04:23Z,runtime/lua/vim/lsp/util.lua,"@@ -481,6 +481,29 @@ function M.jump_to_location(location)   return true end +--- Preview a location in a floating windows+---+--- behavior depends on type of location:+---   - for Location, range is shown (e.g., function definition)+---   - for LocationLink, targetRange is shown (e.g., body of function definition)+---   - for an array of either, the first element is shown+---+--@param location Location, LocationLink, or array thereof+--@return bufnr,winnr buffer and window number of floating window or nil+function M.preview_location(location)","Nvm, chatted on gitter and it seems fine to just update docs to not take a list.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12252,431528868,2020-05-28T01:14:24Z,test/functional/lua/vim_spec.lua,"@@ -1066,4 +1066,48 @@ describe('lua stdlib', function()     eq({5,15}, exec_lua[[ return vim.region(0,{1,5},{1,14},'v',true)[1] ]])   end) -  end)+  do+    local function test_tabsize(tabsize, softtabstop, implicit_buf)+      local buf, arg+      if implicit_buf then",You can just always use `0` as the buffer list for this test. You don't need to have two tests for both explicit and implicit.,
4556097,h-michael,https://api.github.com/repos/neovim/neovim/pulls/12348,432237903,2020-05-29T03:36:04Z,src/nvim/lua/executor.c,"@@ -255,6 +257,117 @@ static struct luaL_Reg regex_meta[] = {   { NULL, NULL } }; +// Dummy timer callback. Used by f_wait().+static void dummy_timer_due_cb(TimeWatcher *tw, void *data)+{+}++// Dummy timer close callback. Used by f_wait().+static void dummy_timer_close_cb(TimeWatcher *tw, void *data)+{+  xfree(tw);+}++static bool nlua_wait_condition(lua_State *lstate, int *status,+                                bool *callback_result)+{+  lua_pushvalue(lstate, 2);+  *status = lua_pcall(lstate, 0, 1, 0);+  if (*status) {+    return true;  // break on error, but keep error on stack+  }+  *callback_result = lua_toboolean(lstate, -1);+  lua_pop(lstate, 1);+  return *callback_result;  // break if true+}++/// ""vim.wait(timeout, condition[, interval])"" function+static int nlua_wait(lua_State *lstate)+  FUNC_ATTR_NONNULL_ALL+{+  intptr_t timeout = luaL_checkinteger(lstate, 1);+  if (timeout < 0) {+    return luaL_error(lstate, ""timeout must be > 0"");+  }++  // Check if condition can be called.+  //   Only error if we got an error on calling.+  bool is_function = (lua_type(lstate, 2) == LUA_TFUNCTION);++  // Run `condition` once, if possible.+  int initial_status;+  bool initial_callback_result;++  nlua_wait_condition(lstate, &initial_status, &initial_callback_result);++  // If calling errored+  if (initial_status) {+    // TODO(tjdevries): If I could find a way to use `vim.is_callable`+    //        that'd be better. But I'm not sure how. Not a big deal atm.+    if (!is_function) {+      lua_pushliteral(lstate, ""vim.wait: condition must be a function"");+      return lua_error(lstate);+    }++    lua_pushliteral(lstate, ""vim.wait: `condition` callback raised error."");+    return lua_error(lstate);+  }++  // Don't wait if the callback has already returned true.+  if (initial_callback_result) {+    lua_pushboolean(lstate, 1);+    lua_pushnil(lstate);+    return 2;+  }","We can check if condition is a callable table without trying calling condition.```suggestion  // Check if condition is callable table  if (luaL_getmetafield(lstate, 2, ""__call"") != 0) {    is_function = (lua_type(lstate, -1) == LUA_TFUNCTION);    lua_pop(lstate, 1);  }  if (!is_function) {    lua_pushliteral(lstate, ""vim.wait: condition must be a function"");    return lua_error(lstate);  }```",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12376,432887284,2020-05-30T21:04:49Z,src/nvim/os/input.c,"@@ -188,8 +188,13 @@ size_t input_enqueue(String keys)   char *ptr = keys.data;   char *end = ptr + keys.size; -  while (rbuffer_space(input_buffer) >= 6 && ptr < end) {-    uint8_t buf[6] = { 0 };+  while (rbuffer_space(input_buffer) >= 19 && ptr < end) {+    // A ""<x>"" form occupies at least 1 characters, and produces up+    // to 19 characters (1 + 5 * 3 for the char and 3 for a modifier).+    // In the case of K_SPECIAL(0x80) or CSI(0x9B), 3 bytes are escaped and+    // needed, but since the keys are UTF-8, so the first byte cannot be+    // K_SPECIAL(0x80) or CSI(0x9B).+    uint8_t buf[19] = { 0 };",I believe we should use `MB_MAXBYTES + 1` as that's mandated by `add_char2buf`. You seem to know a lot about the encoding stuff and I fail at understanding in what situation we can have ` one 16-bit character of up to three bytes plus six following composing characters of three bytes each.` at https://github.com/neovim/neovim/blob/fc98f2d5815d8f7e671766db255edbb7365960b1/src/nvim/vim.h#L287 do you have any idea ?,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12321,434169643,2020-06-02T20:54:33Z,src/tree_sitter/alloc.h,"@@ -9,20 +9,7 @@ extern ""C"" { #include <stdbool.h> #include <stdio.h> -#include ""nvim/memory.h""--#if 1--static inline bool ts_toggle_allocation_recording(bool value) {-  return false;-}--#define ts_malloc xmalloc-#define ts_calloc xcalloc-#define ts_realloc xrealloc-#define ts_free xfree--#elif defined(TREE_SITTER_TEST)",Is this section no longer needed? It is confusing to me why it was there but no longer is.,
1813121,kdheepak,https://api.github.com/repos/neovim/neovim/pulls/12421,434235933,2020-06-02T23:53:04Z,runtime/lua/vim/lsp/protocol.lua,"@@ -923,6 +923,28 @@ function protocol.resolve_capabilities(server_capabilities)     error(""The server sent invalid codeActionProvider"")   end +  if server_capabilities.declarationProvider == nil then+    general_properties.declaration = false+  elseif type(server_capabilities.declarationProvider) == 'boolean' then+    general_properties.declaration = server_capabilities.declarationProvider+  elseif type(server_capabilities.declarationProvider) == 'table' then+    -- TODO: support more detailed declarationProvider options.+    general_properties.declaration = false","My understanding is that the blocks that deal with when `type(server_capabilities.${blank}Provider) == table` haven't been fully implemented yet. So maybe in a separate PR that can be redone properly.For the other branches, I think neovim should not ""default to `true` and see what happens"". As an example, LanguageServer.jl specifies it does not support some features and throws an exception and crashes if a request is made that is not supported: https://github.com/julia-vscode/LanguageServer.jl/issues/736. I'm sure other language server have similar undefined behavior when this occurs.",
1813121,kdheepak,https://api.github.com/repos/neovim/neovim/pulls/12421,434237001,2020-06-02T23:56:33Z,runtime/lua/vim/lsp/protocol.lua,"@@ -923,6 +923,28 @@ function protocol.resolve_capabilities(server_capabilities)     error(""The server sent invalid codeActionProvider"")   end +  if server_capabilities.declarationProvider == nil then+    general_properties.declaration = false+  elseif type(server_capabilities.declarationProvider) == 'boolean' then+    general_properties.declaration = server_capabilities.declarationProvider+  elseif type(server_capabilities.declarationProvider) == 'table' then+    -- TODO: support more detailed declarationProvider options.+    general_properties.declaration = false","See the following for when `type(server_capabilities.implementationProvider) == table`, where it defaults to `false`.https://github.com/neovim/neovim/blob/c37281f32fd49d1cada353d0b7ad95e42c1af0f2/runtime/lua/vim/lsp/protocol.lua#L954",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/12279,434611796,2020-06-03T14:29:44Z,runtime/lua/vim/highlight.lua,"@@ -0,0 +1,41 @@+local api = vim.api++local highlight = {}++--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'vim.highlight'.on_yank()+--- customize highlight group and timeout via+---   au TextYankPost * lua require'vim.highlight'.on_yank(""IncSearch"", 500)+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+-- @param event event structure+function highlight.on_yank(higroup, timeout, event)+  event = event or vim.v.event+  if event.operator ~= 'y' or event.regtype == '' then return end+  higroup = higroup or ""IncSearch""+  timeout = timeout or 500++  local bufnr = api.nvim_get_current_buf()+  local yank_ns = api.nvim_create_namespace('')+  api.nvim_buf_clear_namespace(bufnr, yank_ns, 0, -1)++  local pos1 = vim.fn.getpos(""'["")","Shouldn't this use ``""`[""`` (and similar for the end mark) instead since not all yanks are linewise?",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/12279,434622908,2020-06-03T14:44:48Z,runtime/lua/vim/highlight.lua,"@@ -0,0 +1,41 @@+local api = vim.api++local highlight = {}++--- Highlight the yanked region+--+--- use from init.vim via+---   au TextYankPost * lua require'vim.highlight'.on_yank()+--- customize highlight group and timeout via+---   au TextYankPost * lua require'vim.highlight'.on_yank(""IncSearch"", 500)+-- @param higroup highlight group for yanked region+-- @param timeout time in ms before highlight is cleared+-- @param event event structure+function highlight.on_yank(higroup, timeout, event)+  event = event or vim.v.event+  if event.operator ~= 'y' or event.regtype == '' then return end+  higroup = higroup or ""IncSearch""+  timeout = timeout or 500++  local bufnr = api.nvim_get_current_buf()+  local yank_ns = api.nvim_create_namespace('')+  api.nvim_buf_clear_namespace(bufnr, yank_ns, 0, -1)++  local pos1 = vim.fn.getpos(""'["")","You're right.  I was mistaking accessing the values with jumping to the mark.  That is, `'[` and `` `[`` jump to different positions but `getpos(""'["")` returns the correct data.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12413,435601523,2020-06-04T23:11:43Z,src/nvim/regexp_nfa.c,"@@ -1499,7 +1500,8 @@ static int nfa_regatom(void)         c = getchr();       while (ascii_isdigit(c)) {         if (n > (INT32_MAX - (c - '0')) / 10) {",8.2.0892 adds a temporary unsigned variable for overflow check but the current check should be sufficient because `n` has `int64_t` type.,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12376,436066391,2020-06-05T17:37:13Z,src/nvim/os/input.c,"@@ -188,8 +188,13 @@ size_t input_enqueue(String keys)   char *ptr = keys.data;   char *end = ptr + keys.size; -  while (rbuffer_space(input_buffer) >= 6 && ptr < end) {-    uint8_t buf[6] = { 0 };+  while (rbuffer_space(input_buffer) >= 19 && ptr < end) {+    // A ""<x>"" form occupies at least 1 characters, and produces up+    // to 19 characters (1 + 5 * 3 for the char and 3 for a modifier).+    // In the case of K_SPECIAL(0x80) or CSI(0x9B), 3 bytes are escaped and+    // needed, but since the keys are UTF-8, so the first byte cannot be+    // K_SPECIAL(0x80) or CSI(0x9B).+    uint8_t buf[19] = { 0 };","> You seem to know a lot about the encoding stuff and I fail at understanding in what situation we can have one 16-bit character of up to three bytes plus six following composing characters of three bytes each. at ... do you have any idea ?I'm not particularly familiar with encoding. I looked at the other parts of using MB_MAXBYTES, but I couldn't see when the situation would be similar to the one in the comment.",
2734517,dlukes,https://api.github.com/repos/neovim/neovim/pulls/12437,436194815,2020-06-05T22:38:58Z,runtime/autoload/health/provider.vim,"@@ -286,148 +251,74 @@ function! s:check_python(version) abort   call health#report_start('Python ' . a:version . ' provider (optional)')    let pyname = 'python'.(a:version == 2 ? '' : '3')-  let python_exe = ''   let venv = exists('$VIRTUAL_ENV') ? resolve($VIRTUAL_ENV) : ''   let host_prog_var = pyname.'_host_prog'-  let python_multiple = []    if s:disabled_via_loaded_var(pyname)     return   endif -  let [pyenv, pyenv_root] = s:check_for_pyenv()-   if exists('g:'.host_prog_var)     call health#report_info(printf('Using: g:%s = ""%s""', host_prog_var, get(g:, host_prog_var)))+  else+    call health#report_info(printf('g:%s is not set.  Searching for %s in the environment.', host_prog_var, pyname))   endif -  let [pyname, pythonx_errors] = provider#pythonx#Detect(a:version)+  let [python_exe, pyversion, pythonx_errors] = provider#pythonx#Detect(a:version) -  if empty(pyname)-    call health#report_warn('No Python executable found that can `import neovim`. '-            \ . 'Using the first available executable for diagnostics.')-  elseif exists('g:'.host_prog_var)-    let python_exe = pyname+  if empty(python_exe)+    call health#report_error('No Python '.a:version.' executable found that can `import neovim`.')   endif -  "" No Python executable could `import neovim`, or host_prog_var was used.+  "" No Python executable could `import neovim`, or host_prog_var was used and+  "" led to errors.   if !empty(pythonx_errors)-    call health#report_error('Python provider error:', pythonx_errors)--  elseif !empty(pyname) && empty(python_exe)-    if !exists('g:'.host_prog_var)-      call health#report_info(printf('`g:%s` is not set.  Searching for '-            \ . '%s in the environment.', host_prog_var, pyname))-    endif--    if !empty(pyenv)-      let python_exe = s:trim(s:system([pyenv, 'which', pyname], '', 1))--      if empty(python_exe)-        call health#report_warn(printf('pyenv could not find %s.', pyname))-      endif-    endif--    if empty(python_exe)-      let python_exe = exepath(pyname)--      if exists('$PATH')-        for path in split($PATH, has('win32') ? ';' : ':')-          let path_bin = s:normalize_path(path.'/'.pyname)-          if path_bin != s:normalize_path(python_exe)-                \ && index(python_multiple, path_bin) == -1-                \ && executable(path_bin)-            call add(python_multiple, path_bin)-          endif-        endfor--        if len(python_multiple)-          "" This is worth noting since the user may install something-          "" that changes $PATH, like homebrew.-          call health#report_info(printf('Multiple %s executables found.  '-                \ . 'Set `g:%s` to avoid surprises.', pyname, host_prog_var))-        endif--        if python_exe =~# '\<shims\>'-          call health#report_warn(printf('`%s` appears to be a pyenv shim.', python_exe), [-                      \ '`pyenv` is not in $PATH, your pyenv installation is broken. '-                      \ .'Set `g:'.host_prog_var.'` to avoid surprises.',-                      \ ])-        endif-      endif-    endif-  endif--  if !empty(python_exe) && !exists('g:'.host_prog_var)-    if empty(venv) && !empty(pyenv)-          \ && !empty(pyenv_root) && resolve(python_exe) !~# '^'.pyenv_root.'/'-      call health#report_warn('pyenv is not set up optimally.', [-            \ printf('Create a virtualenv specifically '-            \ . 'for Nvim using pyenv, and set `g:%s`.  This will avoid '-            \ . 'the need to install the pynvim module in each '-            \ . 'version/virtualenv.', host_prog_var)-            \ ])-    elseif !empty(venv)-      if !empty(pyenv_root)-        let venv_root = pyenv_root-      else-        let venv_root = fnamemodify(venv, ':h')-      endif--      if resolve(python_exe) !~# '^'.venv_root.'/'-        call health#report_warn('Your virtualenv is not set up optimally.', [-              \ printf('Create a virtualenv specifically '-              \ . 'for Nvim and use `g:%s`.  This will avoid '-              \ . 'the need to install the pynvim module in each '-              \ . 'virtualenv.', host_prog_var)-              \ ])-      endif-    endif+    call health#report_warn('Python provider troubleshooting messages:', pythonx_errors)   endif -  if empty(python_exe) && !empty(pyname)-    "" An error message should have already printed.-    call health#report_error(printf('`%s` was not found.', pyname))-  elseif !empty(python_exe) && !s:check_bin(python_exe)-    let python_exe = ''+  if !empty(python_exe) && !empty(venv) +    \ && s:python_exepath(python_exe) =~# '^'.venv.'/'+    \ && !exists('g:'.host_prog_var)+    call health#report_warn('Your virtualenv is not set up optimally.', [+          \ 'Set g:'.host_prog_var.' and install the pynvim module ONLY in that environment.',+          \ 'You can use a global environment, or a virtualenv created specifically for Nvim.',+          \ 'This will avoid the need to install the pynvim module in each virtualenv.'])   endif    "" Diagnostic output-  call health#report_info('Executable: ' . (empty(python_exe) ? 'Not found' : python_exe))+  call health#report_info('Python provider executable: ' . (empty(python_exe) ? 'Not found' : python_exe))+  let python_multiple = provider#pythonx#GetPythonCandidates(a:version, $PATH, v:true)   if len(python_multiple)+    "" This is worth noting since the user may install something that changes+    "" $PATH, like Homebrew.+    call health#report_info(printf('Multiple Python %d candidates found.  '+          \ . 'Set g:%s to avoid surprises.', a:version, host_prog_var))     for path_bin in python_multiple-      call health#report_info('Other python executable: ' . path_bin)+      if path_bin !=# python_exe+        call health#report_info(printf('Other Python %d candidate: %s', a:version, path_bin))+      endif     endfor   endif -  let pip = 'pip' . (a:version == 2 ? '' : '3')-   if empty(python_exe)     "" No Python executable can import 'neovim'. Check if any Python executable     "" can import 'pynvim'. If so, that Python failed to import 'neovim' as     "" well, which is most probably due to a failed pip upgrade:     "" https://github.com/neovim/neovim/wiki/Following-HEAD#20181118-    let [pynvim_exe, errors] = provider#pythonx#DetectByModule('pynvim', a:version)+    let [pynvim_exe, _, errors] = provider#pythonx#DetectByModule('pynvim', a:version)     if !empty(pynvim_exe)+      let pip = pynvim_exe . ' -m pip'       call health#report_error(             \ 'Detected pip upgrade failure: Python executable can import ""pynvim"" but '             \ . 'not ""neovim"": '. pynvim_exe,             \ ""Use that Python version to reinstall \""pynvim\"" and optionally \""neovim\"".\n""             \ . pip ."" uninstall pynvim neovim\n""             \ . pip ."" install pynvim\n""-            \ . pip ."" install neovim  # only if needed by third-party software"")+            \ . pip ."" install neovim  # only if needed by third-party software\n""+            \ . 'Retry with the --user flag if you get a permission error.')     endif   else-    let [pyversion, current, latest, status] = s:version_info(python_exe)--    if a:version != str2nr(pyversion)-      call health#report_warn('Unexpected Python version.' .-                  \ ' This could lead to confusing error messages.')-    endif--    if a:version == 3 && str2float(pyversion) < 3.3-      call health#report_warn('Python 3.3+ is recommended.')-    endif","These are some of the happy-go-lucky version checks I mentioned; they are no longer needed, `pythonx/provider` makes sure it only returns an appropriate Python 2 or 3 version that satisfies minimum version requirements.",
2734517,dlukes,https://api.github.com/repos/neovim/neovim/pulls/12437,436196684,2020-06-05T22:46:49Z,runtime/autoload/provider/pythonx.vim,"@@ -22,96 +24,122 @@ function! provider#pythonx#Require(host) abort   return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE') endfunction -function! s:get_python_executable_from_host_var(major_version) abort-  return expand(get(g:, 'python'.(a:major_version == 3 ? '3' : '').'_host_prog', ''))+"" Turn a path with a host-specific directory separator into Vim's+"" comma-separated format.+function! s:to_comma_separated_path(path) abort+  if has('win32')+    let path_sep = ';'+    "" remove backslashes at the end of path items, they would turn into \, and+    "" escape the , which globpath() expects as path separator+    let path = substitute(a:path, '\\\+;', ';', 'g')+  else+    let path_sep = ':'+    let path = a:path+  endif++  "" escape existing commas, so that they remain part of the individual paths+  let path = substitute(path, ',', '\\,', 'g')++  "" deduplicate path items, otherwise globpath() returns even more duplicate+  "" matches for some reason+  let already_seen = {}+  let path_list = []+  for item in split(path, path_sep)+    if !has_key(already_seen, item)+      let already_seen[item] = v:true+      call add(path_list, item)+    endif+  endfor++  return join(path_list, ',') endfunction -function! s:get_python_candidates(major_version) abort-  return {-        \ 2: ['python2', 'python2.7', 'python2.6', 'python'],-        \ 3: ['python3', 'python3.9', 'python3.8', 'python3.7', 'python3.6', 'python3.5',-        \     'python3.4', 'python3.3', 'python']-        \ }[a:major_version]+"" Returns a list of all Python executables found on path. a:convert specifies+"" whether the path to search needs to be converted from a host-specific+"" separator to the comma-separated format expected by globpath().+function! provider#pythonx#GetPythonCandidates(major_version, path, convert) abort+  let path = a:convert ? s:to_comma_separated_path(a:path) : a:path+  let starts_with_python = globpath(path, 'python*', v:true, v:true)+  let ext_pat = has('win32') ? '(\\.exe)?' : ''+  let matches_version = printf('v:val =~# ""\\v[\\/]python(%s)?(\\.[0-9]+)?%s$""', a:major_version, ext_pat)+  return filter(starts_with_python, matches_version) endfunction -"" Returns [path_to_python_executable, error_message]+"" Returns [path_to_python_executable, python_version, error_messages] function! provider#pythonx#Detect(major_version) abort   return provider#pythonx#DetectByModule('neovim', a:major_version) endfunction -"" Returns [path_to_python_executable, error_message]+"" Returns [path_to_python_executable, python_version, error_messages] function! provider#pythonx#DetectByModule(module, major_version) abort-  let python_exe = s:get_python_executable_from_host_var(a:major_version)+  let host_prog = 'python'.(a:major_version == 3 ? '3' : '').'_host_prog'+  let python_exe = get(g:, host_prog, '')+  let errors = []    if !empty(python_exe)-    return [exepath(expand(python_exe)), '']+    let candidates = [exepath(expand(python_exe))]+    call add(errors, 'The g:'.host_prog.' you set cannot be used.')+  else+    let candidates = provider#pythonx#GetPythonCandidates(a:major_version, $PATH, v:true)   endif -  let candidates = s:get_python_candidates(a:major_version)-  let errors = []+  if empty(candidates)+    call add(errors, 'No candidates for a Python '.a:major_version.' executable found on $PATH.')+  endif    for exe in candidates-    let [result, error] = provider#pythonx#CheckForModule(exe, a:module, a:major_version)+    let [result, python_version, error] = provider#pythonx#CheckForModule(exe, a:module, a:major_version)     if result-      return [exe, error]+      return [exe, python_version, error]     endif     "" Accumulate errors in case we don't find any suitable Python executable.     call add(errors, error)   endfor    "" No suitable Python executable found.-  return ['', 'provider/pythonx: Could not load Python '.a:major_version."":\n"".join(errors, ""\n"")]+  return ['', '', errors]","It's better to return a list of errors, the health check formats it prettily. And the ""provider/pythonx: Could not load Python etc."" message feels a bit redundant in the context that it's shown in.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,436394409,2020-06-07T19:33:00Z,runtime/lua/vim/lsp/actions.lua,"@@ -0,0 +1,343 @@+--[=[++actions.lua++Define common actions that can be taken on different LSP structures.++Module structure is:++  actions.<lsp_structure_name>.<action_name>++  Where:+    lsp_structure_name:+      Name of the structure as defined in the LSP specification.++      For example: Location, LocationLink, Hover, etc.++      All structures are assumed to be (wherever possible) to be either a singular or list of those items.+        The LSP spec often has something return either `Location` or `Location[]`.+        All callbacks here should be able to handle either of them.+++    action_name:+      Name of what the user can expect to happen when this function is called.+++  Example:+    actions.Location.jump_first will jump to the singular location passed or the first location in a list of locations.",Change working to `Location` or similar.Should probably add some documentation / links for these somewhere sensible.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,436394453,2020-06-07T19:33:26Z,runtime/lua/vim/lsp/actions.lua,"@@ -0,0 +1,343 @@+--[=[++actions.lua++Define common actions that can be taken on different LSP structures.++Module structure is:++  actions.<lsp_structure_name>.<action_name>++  Where:+    lsp_structure_name:+      Name of the structure as defined in the LSP specification.++      For example: Location, LocationLink, Hover, etc.++      All structures are assumed to be (wherever possible) to be either a singular or list of those items.+        The LSP spec often has something return either `Location` or `Location[]`.+        All callbacks here should be able to handle either of them.+++    action_name:+      Name of what the user can expect to happen when this function is called.+++  Example:+    actions.Location.jump_first will jump to the singular location passed or the first location in a list of locations.",Should mention that most functions should be able to take a single or list of items (where it makes sense).So `Location` or `Location[]`,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,436394819,2020-06-07T19:37:02Z,runtime/lua/vim/lsp/actions.lua,"@@ -0,0 +1,343 @@+--[=[++actions.lua++Define common actions that can be taken on different LSP structures.++Module structure is:++  actions.<lsp_structure_name>.<action_name>++  Where:+    lsp_structure_name:+      Name of the structure as defined in the LSP specification.++      For example: Location, LocationLink, Hover, etc.++      All structures are assumed to be (wherever possible) to be either a singular or list of those items.+        The LSP spec often has something return either `Location` or `Location[]`.+        All callbacks here should be able to handle either of them.+++    action_name:+      Name of what the user can expect to happen when this function is called.+++  Example:+    actions.Location.jump_first will jump to the singular location passed or the first location in a list of locations.+++All actions should return a function that returns a function of that has the structure of:+  function(err, method, params, client_id, bufnr)++All actions are wrapped in a metatable that allows two conveniences:++  1. When calling the `action` directly, it will perform the default action.++    You can write the code directly as a call (through the use of `__call` metamethod): >++      Location.jump_first(_, method, result)+<++  2. Allows for storing a callback with different configuration by using the `with` key: >++      local my_highlight = Location.highlight.with { higroup = 'Substitute', timeout = 100 }++<+++-- Don't make this a local variable if you want to use it in a mapping+-- it needs to be global to be accessed easily.+--+-- The convention is to prefix with `on` to differentiate from other Location objects+-- from other namespaces.+onLocation = require('vim.lsp.actions').Location++-- only `jump` to definition+vim.lsp.buf.defintion { callbacks = onLocation.jump_first }++-- `jump` to definition, and then `highlight` the item+vim.lsp.buf.definition { callbacks = { onLocation.jump_first, onLocation.highlight } }++-- `jump to definition, and then perform a `highlight` action with `higroup` set to 'Substitute' and timeout set to 2s+vim.lsp.buf.definition {+  callbacks = {+    onLocation.jump_first, onLocation.highlight.with { higroup = 'Substitute', timeout = 2000 }+  }+}+++To explain:+Actions should be composable+Actions should be chainable / consecutive+","TODO: Add ability to do something like `if isStructure(Location, object)` or similar to make it easier to define complex callbacks? Or at least give the building blocks to do so easily.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,436395308,2020-06-07T19:42:44Z,runtime/lua/vim/lsp/structures/diagnostic.lua,"@@ -0,0 +1,230 @@+local api = vim.api+local validate = vim.validate++local highlight = require('vim.highlight')+local protocol = require('vim.lsp.protocol')++local Position = require('vim.lsp.structures.position')++local underline_highlight_name = ""LspDiagnosticsUnderline""++local hlmap = {+  [protocol.DiagnosticSeverity.Error]       = underline_highlight_name .. 'Error',+  [protocol.DiagnosticSeverity.Warning]     = underline_highlight_name .. 'Warning',+  [protocol.DiagnosticSeverity.Information] = underline_highlight_name .. 'Information',+  [protocol.DiagnosticSeverity.Hint]        = underline_highlight_name .. 'Hint',+}++local diagnostic_severity_map = {+  [protocol.DiagnosticSeverity.Error] = ""LspDiagnosticsErrorSign"";+  [protocol.DiagnosticSeverity.Warning] = ""LspDiagnosticsWarningSign"";+  [protocol.DiagnosticSeverity.Information] = ""LspDiagnosticsInformationSign"";+  [protocol.DiagnosticSeverity.Hint] = ""LspDiagnosticsHintSign"";+}++local default_severity_highlight = {+  [protocol.DiagnosticSeverity.Error] = { guifg = ""Red"" };+  [protocol.DiagnosticSeverity.Warning] = { guifg = ""Orange"" };+  [protocol.DiagnosticSeverity.Information] = { guifg = ""LightBlue"" };+  [protocol.DiagnosticSeverity.Hint] = { guifg = ""LightGrey"" };+}++local severity_highlights = {}++-- Initialize default severity highlights+for severity, hi_info in pairs(default_severity_highlight) do+  local severity_name = protocol.DiagnosticSeverity[severity]+  local highlight_name = ""LspDiagnostics""..severity_name+  -- Try to fill in the foreground color with a sane default.+  local cmd_parts = {""highlight"", ""default"", highlight_name}+  for k, v in pairs(hi_info) do+    table.insert(cmd_parts, k..""=""..v)+  end+  api.nvim_command(table.concat(cmd_parts, ' '))+  api.nvim_command('highlight link ' .. highlight_name .. 'Sign ' .. highlight_name)+  severity_highlights[severity] = highlight_name+end++local default_diagnostic_ns = api.nvim_create_namespace(""vim_lsp_diagnostics"")+local default_sign_ns = 'vim_lsp_signs'++local diagnostic_cache = {}+local diagnostic_cache_lines = {}+local diagnostic_cache_counts = {}++local _bufs_waiting_to_update = {}++local Diagnostic = {}++Diagnostic.underline = function(diagnostics, bufnr, diagnostic_ns)+  diagnostic_ns = diagnostic_ns or default_diagnostic_ns++  for _, diagnostic in ipairs(diagnostics) do+    local start = diagnostic.range[""start""]+    local finish = diagnostic.range[""end""]++    highlight.range(+      bufnr,+      diagnostic_ns,+      hlmap[diagnostic.severity],+      Position.to_pos(start, bufnr),+      Position.to_pos(finish, bufnr)+    )+  end+end++local _diagnostic_lines = function(diagnostics)+  if not diagnostics then return end+  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local start = diagnostic.range.start+    local line_diagnostics = diagnostics_by_line[start.line]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[start.line] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++local _diagnostic_counts = function(diagnostics)+  if not diagnostics then return end++  local counts = {}+  for _, diagnostic in pairs(diagnostics) do+    if diagnostic.severity then+      if counts[diagnostic.severity] == nil then+        counts[diagnostic.severity] = 0+      end++      counts[diagnostic.severity] = counts[diagnostic.severity] + 1+    end+  end++  return counts+end++local set_diagnostic_cache = function(diagnostics, bufnr)+  diagnostic_cache[bufnr] = diagnostics+  diagnostic_cache_lines[bufnr] = _diagnostic_lines(diagnostics)+  diagnostic_cache_counts[bufnr] = _diagnostic_counts(diagnostics)+end++local clear_diagnostic_cache = function(bufnr)+  diagnostic_cache[bufnr] = nil+  diagnostic_cache_lines[bufnr] = nil+  diagnostic_cache_counts[bufnr] = nil+end++Diagnostic.save_buf_diagnostics = function(diagnostics, bufnr)+  validate {+    diagnostics = {diagnostics, 't', true};+    bufnr = {bufnr, 'n', true};+  }++  if not diagnostics then return end+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr++  if not diagnostic_cache[bufnr] then+    -- Clean up our data when the buffer unloads.+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(b)+        clear_diagnostic_cache(b)+      end+    })+  end++  set_diagnostic_cache(diagnostics, bufnr)+end++Diagnostic.set_virtual_text = function(diagnostics, bufnr, diagnostic_ns)+  if not diagnostics then+    return+  end++  diagnostic_ns = diagnostic_ns or default_diagnostic_ns++  local buffer_line_diagnostics = diagnostic_cache_lines[bufnr] or _diagnostic_lines(diagnostics)++  for line, line_diagnostics in pairs(buffer_line_diagnostics) do+    local virt_texts = {}+    for i = 1, #line_diagnostics - 1 do+      table.insert(virt_texts, {""���"", severity_highlights[line_diagnostics[i].severity]})+    end+    local last = line_diagnostics[#line_diagnostics]+    -- TODO(ashkan) use first line instead of subbing 2 spaces?+    table.insert(virt_texts, {""��� ""..last.message:gsub(""\r"", """"):gsub(""\n"", ""  ""), severity_highlights[last.severity]})+    api.nvim_buf_set_virtual_text(bufnr, diagnostic_ns, line, virt_texts, {})+  end+end++-- TODO: I don't like that this function is ""special"" in that doesn't take any diagnostics as first arg.+-- TODO: Rename to something like Diagnostic.get_saved_counts or similar+Diagnostic.get_counts = function(bufnr, kind)+  return (diagnostic_cache_counts[bufnr] or {})[protocol.DiagnosticSeverity[kind]]+end++Diagnostic.set_signs = function(diagnostics, bufnr, sign_ns)+  sign_ns = sign_ns or default_sign_ns+  for _, diagnostic in ipairs(diagnostics) do+    vim.fn.sign_place(+      0,+      sign_ns,+      diagnostic_severity_map[diagnostic.severity],+      bufnr,+      { lnum = diagnostic.range.start.line + 1 }+    )+  end+end++Diagnostic.buf_clear_saved_diagnostics = function(bufnr, diagnostic_ns, sign_ns)","Should really decide on a naming patter for these or some obvious way to say that ""buf_"" means the first argument will not be the type, but something else. I liked the pattern I had going before this module",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,436395373,2020-06-07T19:43:29Z,runtime/lua/vim/lsp/structures/init.lua,"@@ -0,0 +1,36 @@+--[[++structures.lua++structures is the location to put the handling of any of the structures as defined by+the language server protocol. Any function defined on a structure must take as the first+argument the structure itself and then any optional parameters required for determining+the behavior.++For example, all `Location.*` must be a function of the form:++  function(location, ...)++Additionally, within each `structure.*`, they can import only directly from other structures using:",This note should be for developers only (or noted somewhere in dev docs) but it useless for end users and I dont' want to show the wrong imports,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,436395405,2020-06-07T19:43:59Z,runtime/lua/vim/lsp/structures/init.lua,"@@ -0,0 +1,36 @@+--[[++structures.lua++structures is the location to put the handling of any of the structures as defined by+the language server protocol. Any function defined on a structure must take as the first+argument the structure itself and then any optional parameters required for determining+the behavior.++For example, all `Location.*` must be a function of the form:++  function(location, ...)++Additionally, within each `structure.*`, they can import only directly from other structures using:++  require('vim.lsp.structures.location')++Rather than:++  require('vim.lsp.structures').location+++However, from the rest of the project, they should be imported in the latter style.++--]]++local structures = {}","This is probably the place to add a function `is_type` or similar, for standardized checking of types.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12455,436409053,2020-06-07T22:45:31Z,src/nvim/option.c,"@@ -524,11 +524,15 @@ char *get_lib_dir(void) /// /// Windows: Uses ""���/nvim-data"" for kXDGDataHome to avoid storing /// configuration and data files in the same path. #4403-static void set_runtimepath_default(void)+///+/// If ""clean_arg"" is true, Nvim was started with --clean.+static void set_runtimepath_default(bool clean_arg) {   size_t rtp_size = 0;   char *const data_home = stdpaths_get_xdg_var(kXDGDataHome);-  char *const config_home = stdpaths_get_xdg_var(kXDGConfigHome);+  char *const config_home = clean_arg+    ? NULL+    : stdpaths_get_xdg_var(kXDGConfigHome);",This removes `stdpath('config')` from `&runtimepath`. Not sure if `stdpath('data')` and other directories should be excluded as well.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12437,436689382,2020-06-08T13:15:55Z,src/nvim/lua/vim.lua,"@@ -478,4 +478,105 @@ function vim.defer_fn(fn, timeout)   return timer end +--- Parse a version string into a table.+---+--@param ver (string): version string+--@param strict (optional bool): if true, a semver string is expected;+--       otherwise, just dotted numbers, possibly with junk at the end+--@return table with keys major, minor, patch, pre and build if strict,+--        otherwise with numerical indices+function vim.parse_version(ver, strict)+  local err_msg = string.format('invalid version string: ""%s""', ver)++  local numbers = {}+  local cursor, end_number, number+  repeat+    _, end_number, number = string.find(ver, '^(%d+)%.?', cursor)+    if number then+      cursor = end_number + 1+      table.insert(numbers, tonumber(number))+    end+  until not number++  if #numbers == 0 or (strict and #numbers > 3) then+    error(err_msg)+  elseif not strict then+    return numbers","I don't like that sometimes this function returns a nicely formatted, informative map of semver versions and other times just returns a list of numbers.I think we should just remove ""non-strict"" mode from this. If you just want to compare dotted numbers, it's fine to write the 4 lines of code you have above splitting the numbers. (Do we use non-strict mode anywhere internally)?",x
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12437,436690694,2020-06-08T13:17:22Z,src/nvim/lua/vim.lua,"@@ -478,4 +478,105 @@ function vim.defer_fn(fn, timeout)   return timer end +--- Parse a version string into a table.+---+--@param ver (string): version string+--@param strict (optional bool): if true, a semver string is expected;+--       otherwise, just dotted numbers, possibly with junk at the end+--@return table with keys major, minor, patch, pre and build if strict,+--        otherwise with numerical indices+function vim.parse_version(ver, strict)+  local err_msg = string.format('invalid version string: ""%s""', ver)++  local numbers = {}+  local cursor, end_number, number+  repeat+    _, end_number, number = string.find(ver, '^(%d+)%.?', cursor)+    if number then+      cursor = end_number + 1+      table.insert(numbers, tonumber(number))+    end+  until not number++  if #numbers == 0 or (strict and #numbers > 3) then+    error(err_msg)+  elseif not strict then+    return numbers+  end++  local _, end_pre, pre = string.find(ver, '^%-([0-9A-Za-z.-]+)', cursor)+  if pre then+    cursor = end_pre + 1+  end++  local _, end_build, build = string.find(ver, '^%+([0-9A-Za-z.-]+)', cursor)+  if build then+    cursor = end_build + 1+  end++  if cursor >= #ver then+    local major, minor, patch = unpack(numbers)+    return {major=major, minor=minor, patch=patch, pre=pre, build=build}+  else+    error(err_msg)+  end+end++--- Compare two version strings.+---+--@param ver1, ver2 (string): version strings+--@param strict (optional bool): if true, semver strings are expected;+--       otherwise, just dotted numbers, possibly with junk at the end+--@return (number) 1 if ver1 is greater, -1 if it's smaller, 0 otherwise+function vim.cmp_versions(ver1, ver2, strict)","The strict mode comments go here as well.One suggestion might be that there should be a ""minimum comparison"" key or similar. For example, most of the time I probably just want to check major, minor patch. If they are the same, then I'll call that ""equal"" -- even if they aren't strictly equal. I'm not sure exactly the best way to handle that though.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12333,436764488,2020-06-08T14:45:39Z,runtime/lua/vim/lsp/actions.lua,"@@ -0,0 +1,343 @@+--[=[++actions.lua++Define common actions that can be taken on different LSP structures.++Module structure is:++  actions.<lsp_structure_name>.<action_name>++  Where:+    lsp_structure_name:+      Name of the structure as defined in the LSP specification.++      For example: Location, LocationLink, Hover, etc.++      All structures are assumed to be (wherever possible) to be either a singular or list of those items.+        The LSP spec often has something return either `Location` or `Location[]`.+        All callbacks here should be able to handle either of them.+++    action_name:+      Name of what the user can expect to happen when this function is called.+++  Example:+    actions.Location.jump_first will jump to the singular location passed or the first location in a list of locations.+++All actions should return a function that returns a function of that has the structure of:+  function(err, method, params, client_id, bufnr)++All actions are wrapped in a metatable that allows two conveniences:++  1. When calling the `action` directly, it will perform the default action.++    You can write the code directly as a call (through the use of `__call` metamethod): >++      Location.jump_first(_, method, result)+<++  2. Allows for storing a callback with different configuration by using the `with` key: >++      local my_highlight = Location.highlight.with { higroup = 'Substitute', timeout = 100 }++<+++-- Don't make this a local variable if you want to use it in a mapping+-- it needs to be global to be accessed easily.+--+-- The convention is to prefix with `on` to differentiate from other Location objects+-- from other namespaces.+onLocation = require('vim.lsp.actions').Location++-- only `jump` to definition+vim.lsp.buf.defintion { callbacks = onLocation.jump_first }++-- `jump` to definition, and then `highlight` the item+vim.lsp.buf.definition { callbacks = { onLocation.jump_first, onLocation.highlight } }++-- `jump to definition, and then perform a `highlight` action with `higroup` set to 'Substitute' and timeout set to 2s+vim.lsp.buf.definition {+  callbacks = {+    onLocation.jump_first, onLocation.highlight.with { higroup = 'Substitute', timeout = 2000 }+  }+}+++To explain:+Actions should be composable+Actions should be chainable / consecutive++--]=]++local api = vim.api++local log = require('vim.lsp.log')+local structures = require('vim.lsp.structures')+local util = require('vim.lsp.util')++local wrap_generator = util.wrap_generator++local actions = {}++--- Location actions.+-- Supports both Location and LocationLink+actions.Location = {}++--- Jump to the first location. Accepts Location and Location[]+actions.Location.jump_first = function()+  return function(_, method, location, _, _)+    local success = structures.Location.jump(location)++    if success == false then+      log.info(method, 'No location found')+    end+  end+end++--- Jump to the first Location. If more than one Location is returned, quickfix list is populated+actions.Location.jump_and_quickfix = function()+  return function(_, method, result)+    if result == nil or vim.tbl_isempty(result) then+      log.info(method, 'No location found')+      return nil+    end++    -- textDocument/definition can return Location or Location[]+    -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_definition++    structures.Location.jump(result)+    if vim.tbl_islist(result) and #result > 1 then+      structures.Location.set_qflist(result, true)+    end+  end+end++--- Preview a location in a floating windows+--+--@param args: Config table: ~+--              lines_above: Number of lines to show above the location in the preview. Default 0+--              lines_below: Number of lines to show below the location in the preview. Default 0+actions.Location.preview = function(args)+  args = args or {}++  local lines_above = args.lines_above or 0+  local lines_below = args.lines_below or 0++  return function(_, method, location)+    local success = structures.Location.preview(location, lines_above, lines_below)++    if success == false then+      log.info(method, 'No location found')+      return false+    end+  end+end+++--- Highlight a location+--+--@param args: Config table: ~+--              higroup: Name of the highlight group+--              timeout: Number of ms before highlight is cleared.+actions.Location.highlight = function(args)+  args = args or {}++  local higroup = args.higroup or ""IncSearch""+  local timeout = args.timeout or 250++  return function(_, method, location)+    local success = structures.Location.highlight(location, higroup, timeout)++    if success == false then+      log.info(method, 'No location found')+      return false+    end+  end+end++--- Set the quickfix list for Location or Location[]+--+--@param args: Config table: ~+--              open_list: Whether to open list or not. Default true+actions.Location.set_qflist = function(args)+  args = args or {}++  local open_list = true+  if args.open_list ~= nil then+    open_list = args.open_list+  end++  return function(_, method, location)+    local success = structures.Location.set_qflist(location, open_list)++    if success == false then+      log.info(method, 'No locations found')+      return+    end+  end+end++--- Set the loc list for Location or Location[]+--+--@param args: Config table: ~+--              open_list: Whether to open list or not. Default true+actions.Location.set_loclist = function(args)+  args = args or {}++  local open_list = true+  if args.open_list ~= nil then+    open_list = args.open_list+  end++  return function(_, method, location)+    local success = structures.Location.set_loclist(location, open_list)++    if success == false then+      log.info(method, 'No locations found')+      return false+    end+  end+end++-- All actions for Location should work for LocationLink+actions.LocationLink = vim.deepcopy(actions.Location)+++actions.Diagnostic = {}++actions.Diagnostic.handle_publish_diagnostics = function(args)+  args = vim.tbl_extend(""force"", {+    should_underline = true,+    -- TODO: Should change to false before moving on+    update_in_insert = true,+  }, args)++  local should_underline = args.should_underline+  local update_in_insert = args.update_in_insert++  return function(_, method, notification)+    if notification.diagnostics == nil or vim.tbl_isempty(notification.diagnostics) then+      log.info(method, ""No diagnostics returned"")+    end++    local uri = notification.uri+    local bufnr = vim.uri_to_bufnr(uri)+    if not bufnr then+      return+    end++    if not api.nvim_buf_is_loaded(bufnr) then+      return+    end++    -- util.buf_clear_diagnostics(bufnr)+    -- TODO: Decide if this is actually what we want to call this.+    structures.Diagnostic.buf_clear_saved_diagnostics(bufnr)++    local diagnostics = notification.diagnostics++    -- util.buf_diagnostics_save_positions(bufnr, notification.diagnostics)+    structures.Diagnostic.save_buf_diagnostics(diagnostics, bufnr)++    if not update_in_insert then+      local mode = vim.fn.mode()++      if mode == 'i' then+        structures.Diagnostic.buf_schedule_display_on_insert_leave(bufnr)+        return+      end+    end++    if should_underline and false then+      util.buf_diagnostics_underline(diagnostics, bufnr)+    end++    -- util.buf_diagnostics_virtual_text(bufnr, notification.diagnostics)+    structures.Diagnostic.set_virtual_text(diagnostics, bufnr)++    -- util.buf_diagnostics_signs(bufnr, notification.diagnostics)+    structures.Diagnostic.set_signs(diagnostics, bufnr)++    vim.api.nvim_command(""doautocmd User LspDiagnosticsChanged"")+  end+end++actions.Symbol = {}++actions.Symbol.set_qflist = function(args)+  args = args or {}++  local open_list = true",Also add an option to _switch_ to the list?,
2734517,dlukes,https://api.github.com/repos/neovim/neovim/pulls/12437,437756423,2020-06-09T22:25:46Z,src/nvim/lua/vim.lua,"@@ -478,4 +478,105 @@ function vim.defer_fn(fn, timeout)   return timer end +--- Parse a version string into a table.+---+--@param ver (string): version string+--@param strict (optional bool): if true, a semver string is expected;+--       otherwise, just dotted numbers, possibly with junk at the end+--@return table with keys major, minor, patch, pre and build if strict,+--        otherwise with numerical indices+function vim.parse_version(ver, strict)+  local err_msg = string.format('invalid version string: ""%s""', ver)++  local numbers = {}+  local cursor, end_number, number+  repeat+    _, end_number, number = string.find(ver, '^(%d+)%.?', cursor)+    if number then+      cursor = end_number + 1+      table.insert(numbers, tonumber(number))+    end+  until not number++  if #numbers == 0 or (strict and #numbers > 3) then+    error(err_msg)+  elseif not strict then+    return numbers+  end++  local _, end_pre, pre = string.find(ver, '^%-([0-9A-Za-z.-]+)', cursor)+  if pre then+    cursor = end_pre + 1+  end++  local _, end_build, build = string.find(ver, '^%+([0-9A-Za-z.-]+)', cursor)+  if build then+    cursor = end_build + 1+  end++  if cursor >= #ver then+    local major, minor, patch = unpack(numbers)+    return {major=major, minor=minor, patch=patch, pre=pre, build=build}+  else+    error(err_msg)+  end+end++--- Compare two version strings.+---+--@param ver1, ver2 (string): version strings+--@param strict (optional bool): if true, semver strings are expected;+--       otherwise, just dotted numbers, possibly with junk at the end+--@return (number) 1 if ver1 is greater, -1 if it's smaller, 0 otherwise+function vim.cmp_versions(ver1, ver2, strict)","Re: strict mode, please see https://github.com/neovim/neovim/pull/12437#discussion_r437754800 and let's have that discussion there?> a ""minimum comparison"" key or similarThat's a good suggestion, thanks! I'll try and think of a way of incorporating it :)",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12461,438413583,2020-06-10T21:17:36Z,.github/ISSUE_TEMPLATE/lsp_bug_report.md,"@@ -0,0 +1,47 @@+---+name: Language server client bug report+about: Report a built-in lsp problem in Nvim+title: ''+labels:+  - bug+  - lsp+---++<!-- Before reporting: search existing issues and check the FAQ. -->++- `nvim --version`:+- language server name/version:+- Operating system/version:++<details>+<summary>`nvim -c "":checkhealth nvim nvim_lsp""`</summary>++<!-- Paste the results from `nvim -c "":checkhealth nvim nvim_lsp""` here. -->++</details>++<details>+<summary>lsp.log</summary>++<!--+Please paste the lsp log before and after the problem.++You can set log level like this.+`:lua vim.lsp.set_log_level(""debug"")`++You can find the location of the log with the following command.+`:lua print(vim.lsp.get_log_path())`+-->++</details>++### Steps to reproduce using `nvim -u NORC`",Most reports will have nvim_lsp involved so it may not make sense. Some plugins suggest a minimal.vim to recreate  https://github.com/lervag/vimtex/blob/master/test/issues/template/minimal.vim . This might be overkill here so don't let it stop you from merging.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12470,438695509,2020-06-11T10:39:05Z,test/functional/plugin/lsp_spec.lua,"@@ -1380,7 +1380,7 @@ describe('LSP', function()     end)   end) -  describe('lsp.util._make_floating_popup_size', function()+  it('lsp.util._make_floating_popup_size', function()","I think this should still be `describe`, but was incorrectly nested (my bad!)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/12470,438700174,2020-06-11T10:49:19Z,test/functional/plugin/lsp_spec.lua,"@@ -1380,7 +1380,7 @@ describe('LSP', function()     end)   end) -  describe('lsp.util._make_floating_popup_size', function()+  it('lsp.util._make_floating_popup_size', function()","Makes sense; I tried to follow the implicit pattern but obviously missed things.if each `eq` needs its own `it`, I'd suggest* `calculates size correctly`* `calculates size correctly with wrapping`",
653269,ms,https://api.github.com/repos/neovim/neovim/pulls/12333,439762505,2020-06-13T19:20:11Z,runtime/lua/vim/lsp/actions.lua,"@@ -0,0 +1,350 @@+--[=[++actions.lua++Define common actions that can be taken on different LSP structures.++Module structure is:++  actions.<lsp_structure_name>.<action_name>++  Where:+    lsp_structure_name:+      Name of the structure as defined in the LSP specification.++      For example: Location, LocationLink, Hover, etc.++      All structures are assumed to be (wherever possible) to be either a singular or list of those items.",```suggestion      All structures are assumed to be (wherever possible) either a singular or list of those items.```,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12468,439859639,2020-06-14T19:19:07Z,runtime/lua/vim/lsp.lua,"@@ -584,8 +584,9 @@ do   text_document_did_change_handler = function(_, bufnr, changedtick,       firstline, lastline, new_lastline, old_byte_size, old_utf32_size,       old_utf16_size)-    local _ = log.debug() and log.debug(""on_lines"", bufnr, changedtick, firstline,-    lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size, nvim_buf_get_lines(bufnr, firstline, new_lastline, true))+    local _ = log.debug() and log.debug(""on_lines bufnr: ""..bufnr.."", changedtick: ""..changedtick.."", firstline: ""..firstline..","Probably better to do string.format I would guess, than so many concatenations.Or, `vim.inspect({...})` or similar.",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12333,439872046,2020-06-14T22:05:19Z,runtime/lua/vim/lsp/structures/init.lua,"@@ -0,0 +1,36 @@+--[[++structures.lua++structures is the location to put the handling of any of the structures as defined by+the language server protocol. Any function defined on a structure must take as the first+argument the structure itself and then any optional parameters required for determining+the behavior.++For example, all `Location.*` must be a function of the form:++  function(location, ...)++Additionally, within each `structure.*`, they can import only directly from other structures using:","Yes, within the structures file, it will cause circular dependencies. This prevents that. But from outside of the module, you should import from the init in case there is any setup / teardown / etc. that needs to happen at the module level.Perhaps I will move them all to `structures._Location` for example. What do you think of that?",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12262,439919035,2020-06-15T03:58:36Z,runtime/lua/vim/lsp/util.lua,"@@ -423,27 +423,58 @@ function M.make_floating_popup_options(width, height, opts)   } end +local function is_new_item(item)+  local stack = gettagstack()++  -- Check if we're at the bottom of the tagstack.+  if stack.curidx <= 1 then return true end++  local top_item = stack.items[stack.curidx-1]++  -- Check if the item at the top of the tagstack is exactly the+  -- same as the one we want to push.+  if top_item.tagname ~= item.tagname then return true end+  for i, v in ipairs(top_item.from) do+    if v ~= item.from[i] then return true end+  end+  return false+end++local function add_tagstack(item)+  -- Check whether item is not already at the top of the tagstack.+  if not is_new_item(item) then return end+  local winid = vim.fn.win_getid()+  local items = {item}+  vim.fn.settagstack(winid, {items=items}, 't')+end","I don't agree with this ���� I think it's fine to write a function outside of the function, for clarity sake. This function gets redefined every time we call the function, which I don't think makes sense.I left a comment to either just inline it, or we can move it back out. The name could be clearer, or added w/in a `do` block to hide it's scope, but I am not a big fan of this style choice. Of course, if I'm outnumbered, I will acquiesce ���� ",X
653269,ms,https://api.github.com/repos/neovim/neovim/pulls/12333,440577025,2020-06-16T04:19:28Z,runtime/lua/vim/lsp/structures/versioned_text_document_identifier.lua,"@@ -0,0 +1,13 @@+local VersionedTextDocumentIdentifier = {}++local buf_versions = {}++VersionedTextDocumentIdentifier.buf_get_version = function(bufnr)+  return buf_versions[bufnr] or 0+end++VersionedTextDocumentIdentifier.buf_set_version = function(bufnr, version)+  buf_versions[bufnr] = version+end","I also thought that'd make sense and I was worried about a client with a lower version getting its edit messages discarded. But since we change the version on every buffer change (if I'm reading the following line of code correctly), a single version number seems to make sense, right? https://github.com/neovim/neovim/blob/570c60c6507e88addb9f131d3be4dd56949aff75/runtime/lua/vim/lsp.lua#L599 If client A changes version 1 of the buffer, we need to increment the version and send the `textDocument/didChange` to both servers through client A and B, right?",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12502,442160273,2020-06-18T11:34:24Z,src/nvim/extmark.c,"@@ -809,10 +809,10 @@ bool decorations_redraw_start(buf_T *buf, int top_row,       HlRange range;       if (mark.id&MARKTREE_END_FLAG) {         range = (HlRange){ altpos.row, altpos.col, mark.row, mark.col,-                           attr_id, vt };+                           attr_id, 0, vt };",`0` should maybe be `#define DEFAULT_HL_RANGE_PRIORITY 0` or similar,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/12502,442298815,2020-06-18T15:07:31Z,src/nvim/screen.c,"@@ -637,12 +637,26 @@ bool win_cursorline_standout(const win_T *wp) static DecorationRedrawState decorations; bool decorations_active = false; -void decorations_add_luahl_attr(int attr_id,+void decorations_add_luahl_attr(int attr_id, int prio,                                 int start_row, int start_col,                                 int end_row, int end_col) {-  kv_push(decorations.active,-          ((HlRange){ start_row, start_col, end_row, end_col, attr_id, NULL }));+  HlRange new = (HlRange){ start_row, start_col, end_row, end_col, prio, attr_id, NULL };++  for (size_t index = 0; index < kv_size(decorations.active); index++) {","Yes, but I really don't know how to fix that though.. The problem is that we want to know if there is actually another match here... Is there any data structure that we can use to mitigate that ?",
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12503,443151958,2020-06-20T18:51:58Z,test/functional/helpers.lua,"@@ -411,7 +411,6 @@ end function module.clear(...)   local argv, env = module.new_argv(...)   module.set_session(module.spawn(argv, nil, env))-  module.request('nvim_set_client_info', 'testclient', {}, 'remote', {}, {})",Removing this line from the code as it causes the `encoding` test given at [test/functional/ex_cmds/encoding_spec.lua:24](https://github.com/neovim/neovim/blob/master/test/functional/ex_cmds/encoding_spec.lua#L24) to wait indefinitely.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12536,446142959,2020-06-26T12:05:45Z,runtime/doc/options.txt,"@@ -3504,6 +3504,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	<PageUp> and <PageDown>. 	The 'keymodel' option is set by the |:behave| command. +					*'keystrokecallback'* *'kscb'*+'keystrokecallback' 'kscb'  boolean (default: false)","Oh, and change the name to `keystrokelog` or similar? Maybe `enableonkeystroke`? I can think of the name a bit more.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12507,446190026,2020-06-26T13:39:37Z,src/nvim/eval/userfunc.c,"@@ -162,6 +163,17 @@ static void register_closure(ufunc_T *fp)     [current_funccal->fc_funcs.ga_len++] = fp; } ++/// Get a name for a lambda.  Returned in static memory.+char_u * get_lambda_name(void)+{+    static char_u   name[30];","Oh, I think I see what you're saying. Instead of taking `void`, I should just pass in `char_u *` pointer and let it set there, so there's no problem with getting the wrong buffer or some other dumb race condition.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12262,446216360,2020-06-26T14:24:51Z,test/functional/plugin/lsp_spec.lua,"@@ -1378,6 +1378,33 @@ describe('LSP', function()       eq(4, pos.col)       eq('��', exec_lua[[return vim.fn.expand('<cword>')]])     end)++    it('pushes to tagstack without repeating items', function()+      local stack+      -- Jump to a location.+      jump(location(0, 9, 0, 9))+      stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(1, stack.length)+      eq({target_bufnr, 1, 1, 0}, stack.items[1].from)++      -- Jump to same location. This should not be added to the tagstack.+      jump(location(0, 9, 0, 9))+      stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(1, stack.length)++      -- Jump to a different location.+      jump(location(0, 10, 0, 9))+      stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(2, stack.length)+      eq({target_bufnr, 1, 10, 0}, stack.items[2].from)+    end)++    it('prevents pushing to tagstack when motionless', function()+      -- Jump to the same location the cursor is parked.+      jump(location(0, 0, 0, 0))+      local stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(0, stack.length)+    end)","So another test case I'd like to see is that you do something with `location` where you set a new `uri` to go to. You may have to extend: https://github.com/neovim/neovim/pull/12262/files#diff-2a259d96bc36492344afe33e6d418d83R1361-R1369 to allow for a new `uri` and to have it opened with text inside of it in this section:  https://github.com/neovim/neovim/pull/12262/files#diff-2a259d96bc36492344afe33e6d418d83R1352-R1359So basically, add another `uri`, like `fake/uri_2` or similar, and then jump there and back.Also, using something like using `<C-t>` would be pretty cool here to see see if it actually jumps back to where you were before.",
7577128,gbrlsnchs,https://api.github.com/repos/neovim/neovim/pulls/12262,446237527,2020-06-26T15:00:02Z,test/functional/plugin/lsp_spec.lua,"@@ -1378,6 +1378,33 @@ describe('LSP', function()       eq(4, pos.col)       eq('��', exec_lua[[return vim.fn.expand('<cword>')]])     end)++    it('pushes to tagstack without repeating items', function()+      local stack+      -- Jump to a location.+      jump(location(0, 9, 0, 9))+      stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(1, stack.length)+      eq({target_bufnr, 1, 1, 0}, stack.items[1].from)++      -- Jump to same location. This should not be added to the tagstack.+      jump(location(0, 9, 0, 9))+      stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(1, stack.length)++      -- Jump to a different location.+      jump(location(0, 10, 0, 9))+      stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(2, stack.length)+      eq({target_bufnr, 1, 10, 0}, stack.items[2].from)+    end)++    it('prevents pushing to tagstack when motionless', function()+      -- Jump to the same location the cursor is parked.+      jump(location(0, 0, 0, 0))+      local stack = exec_lua[[return vim.fn.gettagstack()]]+      eq(0, stack.length)+    end)","Good point, I'd love to organize the whole test.> So basically, add another uri, like fake/uri_2 or similar, and then jump there and back.I tried that but unfortunately the test threw an error saying it couldn't switch to another buffer. :crying_cat_face: Basically, inside a `test` context, I can only call `nvim_set_current_buf` once. If I try to call it again (so I can jump between buffers), it throws that error. I have no clue whether I'm doing something wrong or it's a limitation of the test itself.> Also, using something like using <C-t> would be pretty cool here to see see if it actually jumps back to where you were before.This makes total sense, we need to prove whether we're properly pushing items to the tagstack. I need two things to make this possible:- Solve the issue I cited above- Learn how to trigger `<C-t>` (is it via `execute normal!`?)",
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/12556,446689143,2020-06-28T19:34:03Z,runtime/lua/vim/lsp/buf.lua,"@@ -136,6 +136,39 @@ function M.document_symbol()   request('textDocument/documentSymbol', params) end +local function pick_call_hierarchy_item(call_hierarchy_items)+  if not call_hierarchy_items then return end+  if #call_hierarchy_items == 1 then+    return call_hierarchy_items[1]+  end+  local items = {}+  for i, item in ipairs(call_hierarchy_items) do+    local entry = item.detail or item.name+    table.insert(items, string.format(""%d. %s"", i, entry))+  end+  local choice = vim.fn.inputlist(items)+  if choice < 1 or choice > #items then+    return+  end+  return choice+end++function M.incoming_calls()+  local params = util.make_position_params()+  request('textDocument/prepareCallHierarchy', params, function(_, _, result)","There may be multiple servers running for a given language. Currently neovim sends the request to all servers and you get a list of responses in the callback (most methods look at the first result), I think.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12549,446727444,2020-06-29T01:25:33Z,runtime/doc/lua.txt,"@@ -698,25 +698,26 @@ VIM.HIGHLIGHT                  				*lua-highlight* Nvim includes a function for highlighting a selection on yank (see for example https://github.com/machakann/vim-highlightedyank). To enable it, add >- au TextYankPost * silent! lua require'vim.highlight'.on_yank()+ au TextYankPost * silent! vim.highlight.on_yank() < to your `init.vim`. You can customize the highlight group and the duration of the highlight via >- au TextYankPost * silent! lua require'vim.highlight'.on_yank(""IncSearch"", 500)+ au TextYankPost * silent! vim.highlight.on_yank {higroup=""IncSearch"", timeout=250} < If you want to exclude visual selections from highlighting on yank, use >-au TextYankPost * silent! lua return (not vim.v.event.visual) and require'vim.highlight'.on_yank()+ au TextYankPost * silent! vim.highlight.on_yank {on_visual=false} < -vim.highlight.on_yank([{higroup}, {timeout}, {event}]) -                                                    *vim.highlight.on_yank()*-        Highlights the yanked text. Optional arguments are the highlight group-        to use ({higroup}, default `""IncSearch""`), the duration of highlighting-        in milliseconds ({timeout}, default `500`), and the event structure -        that is fired ({event}, default `vim.v.event`).-+vim.highlight.on_yank({opts})                         *vim.highlight.on_yank()*+        Highlights the yanked text. The fields of the optional dict {opts}+        control the highlight: the highlight group to use ({higroup}, default+        `""IncSearch""`), the duration of highlighting in milliseconds+        ({timeout}, default `250`), whether to highlight a visual selection+        ({on_visual}, default `true`), whether to highlight when executing a+        macro ({on_macro}, default `false`), and the {event} (struct, default+        `vim.v.event`).",I think this section should just be listed out like how you have it in the doc string.It's easier to grok each of the keys that way IMO,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12491,447246808,2020-06-29T20:52:24Z,test/functional/lua/treesitter_spec.lua,"@@ -404,4 +404,57 @@ static int nlua_schedule(lua_State *const lstate)     end     eq({true,true}, {has_named,has_anonymous})   end)+  it('allows to set ranges', function()+    if not check_parser() then return end++    insert(test_text)++    local res = exec_lua([[+    parser = vim.treesitter.get_parser(0, ""c"")+    return { parser:parse():root():range() }+    ]])++    eq({0, 0, 19, 0}, res)++    local res = exec_lua([[+    local root = parser:parse():root()+    parser:set_included_ranges({{root:child(0), root:child(0)}})"," @vigoux and I were discussing the API of `set_included_ranges` which is now called as an array of tuple `{ {node_start, node_end},  .., {node_start, node_end}` . I was triggered by the use of the same node here `root:child(0), root:child(0)}` and proposed to either pass a list of ranges like `set_included_ranges( {create_range(node_start,node_end),  create_range(node_start2,node_end2)} )` or just pass a list of node and use their ranges as done in https://tree-sitter.github.io/tree-sitter/using-parsers#multi-language-documents. @tjdevries what do you think ? ",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/12491,447253574,2020-06-29T21:05:34Z,test/functional/lua/treesitter_spec.lua,"@@ -404,4 +404,57 @@ static int nlua_schedule(lua_State *const lstate)     end     eq({true,true}, {has_named,has_anonymous})   end)+  it('allows to set ranges', function()+    if not check_parser() then return end++    insert(test_text)++    local res = exec_lua([[+    parser = vim.treesitter.get_parser(0, ""c"")+    return { parser:parse():root():range() }+    ]])++    eq({0, 0, 19, 0}, res)++    local res = exec_lua([[+    local root = parser:parse():root()+    parser:set_included_ranges({{root:child(0), root:child(0)}})","As discussed, we are going for a `table of nodes` solution, as it seems to be simpler on both implementation and usage. More complex ranges will in any case be easy to generate by iterating over each intermediate node between two nodes.Something else to note is that this is used mainly for language injection, and most of the parsers, have clearly identified nodes that needs language injection on them.",
287744,prabirshrestha,https://api.github.com/repos/neovim/neovim/pulls/12569,447340516,2020-06-30T00:43:10Z,src/nvim/lua/vim.lua,"@@ -296,6 +296,40 @@ setmetatable(vim, { -- An easier alias for commands. vim.cmd = vim.api.nvim_command +-- VIM_COMPAT: vim.command+vim.command = vim.api.nvim_command++-- VIM_COMPAT: vim.eval+vim.eval = vim.api.nvim_eval++-- VIM_COMPAT: vim.list+vim.list = function(list)",list metatable can be found here.https://github.com/prabirshrestha/vim/blob/566cc8c72bb8036f015a435800f28ef9f6a9a3b6/src/if_lua.c#L994-L995Setting it to `nil` seems to remove.https://github.com/prabirshrestha/vim/blob/566cc8c72bb8036f015a435800f28ef9f6a9a3b6/src/if_lua.c#L929-L933Don't ask me why there was no `remove` method :),
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12518,447771279,2020-06-30T15:24:32Z,runtime/lua/vim/lsp.lua,"@@ -810,23 +811,38 @@ nvim_command(""autocmd VimLeavePre * lua vim.lsp._vim_exit_handler()"") ---  - Map of client-id:request-id pairs for all successful requests. ---  - Function which can be used to cancel all the requests. You could instead ---    iterate all clients and call their `cancel_request()` methods.-function lsp.buf_request(bufnr, method, params, callback)+function lsp.buf_request(bufnr, method, params, callback, unsupported_callback)",I do not really like passing this parameter. Does this allow overriding of what to do with the error? (it's missing documentation),X
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/12518,447829744,2020-06-30T16:44:51Z,runtime/lua/vim/lsp.lua,"@@ -810,23 +811,38 @@ nvim_command(""autocmd VimLeavePre * lua vim.lsp._vim_exit_handler()"") ---  - Map of client-id:request-id pairs for all successful requests. ---  - Function which can be used to cancel all the requests. You could instead ---    iterate all clients and call their `cancel_request()` methods.-function lsp.buf_request(bufnr, method, params, callback)+function lsp.buf_request(bufnr, method, params, callback, unsupported_callback)","Yes, the idea is to override what to do with the error, so we don't get an error say `prepareRename` is not supported or something like that. The way rename works is:1. call prepareRename2. if prepareRename returns null, abort the process3. if prepareRename, returns a valid response, use that to control how rename is called4. if prepareRename is not supported, fallback to the previous behavior of calling rename with I added a separate callback to properly identify (4) because the default behavior is to log an error message, and in this case the message is non-actionable, so we don't want to log it. I agree that adding a new callback isn't the best solution.A better solution would be to not call `err_message()` from the library function [here](https://github.com/neovim/neovim/blob/554b21261ec0ad1eaac7afc21d9a1ba7fb7cabf1/runtime/lua/vim/lsp.lua#L494). What do you think?We still need a way to signal to rename that no clients implement prepareRename though, so we could have rename be aware of all the clients and count the callbacks, or have a new overall callback from buf_request.What do you mean by registering at the buffer level? It sounds like that could work too, as long as we can update that registry on_attach or something like that.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/12549,448114326,2020-07-01T04:53:16Z,runtime/doc/lua.txt,"@@ -698,25 +698,26 @@ VIM.HIGHLIGHT                  				*lua-highlight* Nvim includes a function for highlighting a selection on yank (see for example https://github.com/machakann/vim-highlightedyank). To enable it, add >- au TextYankPost * silent! lua require'vim.highlight'.on_yank()+ au TextYankPost * silent! lua vim.highlight.on_yank() < to your `init.vim`. You can customize the highlight group and the duration of the highlight via >- au TextYankPost * silent! lua require'vim.highlight'.on_yank(""IncSearch"", 500)+ au TextYankPost * silent! lua vim.highlight.on_yank {higroup=""IncSearch"", timeout=250}",Thoughts on defaulting this timeout to 150 ms? The default of 500 ms is quite long and feels clunky to me.Love this feature btw!,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/12531,449058193,2020-07-02T14:50:27Z,src/nvim/aucmd.c,"@@ -50,12 +52,46 @@ void aucmd_schedule_focusgained(bool gained) static void do_autocmd_focusgained(bool gained) {   static bool recursive = false;+  static Timestamp last_time = (time_t)0;+  bool need_redraw = false;    if (recursive) {     return;  // disallow recursion   }   recursive = true;-  apply_autocmds((gained ? EVENT_FOCUSGAINED : EVENT_FOCUSLOST),-                 NULL, NULL, false, curbuf);+  need_redraw |= apply_autocmds((gained ? EVENT_FOCUSGAINED : EVENT_FOCUSLOST),+                                NULL, NULL, false, curbuf);++  // When activated: Check if any file was modified outside of Vim.+  // Only do this when not done within the last two seconds (could get+  // several events in a row).+",FAT32 has a 2 second granularity for modification time.  Most contemporary file systems are much more granular.,
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12531,449166582,2020-07-02T17:25:42Z,test/functional/autoread/focus_spec.lua,"@@ -0,0 +1,64 @@+local helpers = require('test.functional.helpers')(after_each)+local thelpers = require('test.functional.terminal.helpers')+local clear = helpers.clear+local retry = helpers.retry+local nvim_prog = helpers.nvim_prog+local feed_command = helpers.feed_command+local feed_data = thelpers.feed_data++if helpers.pending_win32(pending) then return end++describe('autoread TUI FocusGained/FocusLost', function()+  local screen++  before_each(function()+    clear()+    screen = thelpers.screen_setup(0, '[""'..nvim_prog+      ..'"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""--cmd"", ""set noswapfile noshowcmd noruler""]')+    feed_command('set autoread')+    feed_data(""\034\016"")",You're right. I don't think we need the `feed_command` or `feed_data` lines here. I will remove them in the next commit :),
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12531,449168089,2020-07-02T17:28:38Z,test/functional/autoread/focus_spec.lua,"@@ -0,0 +1,64 @@+local helpers = require('test.functional.helpers')(after_each)+local thelpers = require('test.functional.terminal.helpers')+local clear = helpers.clear+local retry = helpers.retry+local nvim_prog = helpers.nvim_prog+local feed_command = helpers.feed_command+local feed_data = thelpers.feed_data++if helpers.pending_win32(pending) then return end++describe('autoread TUI FocusGained/FocusLost', function()+  local screen++  before_each(function()+    clear()+    screen = thelpers.screen_setup(0, '[""'..nvim_prog+      ..'"", ""-u"", ""NONE"", ""-i"", ""NONE"", ""--cmd"", ""set noswapfile noshowcmd noruler""]')+    feed_command('set autoread')+    feed_data(""\034\016"")+  end)++  it('external file change', function()+    local path = 'xtest-foo'+    local expected_addition = [[+    line 1+    line 2+    line 3+    line 4+    ]]++    helpers.write_file(path, '')+    feed_command('edit '..path)+    retry(2, 3 * screen.timeout, function()",This is something that I saw in the [tui_spec.lua#L914](https://github.com/neovim/neovim/blob/master/test/functional/terminal/tui_spec.lua#L914) file and thought that it must be because the function `feed_data` might not always be successful. I remember reading that 0 can be returned  (via chansend) for the cases when no bytes are written. So I thought we retry to ensure that the specified key was received by the child nvim instance. Although in that case I think I should leave the expect calls inside the retry block. I shouldn't have moved them out.**EDIT:** Quite honestly I copied quite a bit from the tests at `tui_spec.lua` for these tests. It was late at night when I was writing these and I had some other issues to resolve for this PR so I decided not to remove the retry calls as I didn't fully understand what they did.,
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12531,449170696,2020-07-02T17:33:46Z,test/functional/autoread/focus_spec.lua,"@@ -0,0 +1,64 @@+local helpers = require('test.functional.helpers')(after_each)+local thelpers = require('test.functional.terminal.helpers')+local clear = helpers.clear+local retry = helpers.retry+local nvim_prog = helpers.nvim_prog+local feed_command = helpers.feed_command+local feed_data = thelpers.feed_data++if helpers.pending_win32(pending) then return end++describe('autoread TUI FocusGained/FocusLost', function()+  local screen++  before_each(function()+    clear()+    screen = thelpers.screen_setup(0, '[""'..nvim_prog","I don't think I can, since we open a child neovim instance and trigger the `FocusGained` and `FocusLost` event in this child instance, and see if the file was reloaded. The defualt command for `screen_setup` is `nvim_dir/tty-test`. I wasn't too sure of whether this is what was required and also saw that this was what was already being used in [tui_spec.lua#L906](https://github.com/neovim/neovim/blob/master/test/functional/terminal/tui_spec.lua#L906) so decided using this.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12555,449171136,2020-07-02T17:34:36Z,test/functional/plugin/lsp_spec.lua,"@@ -987,46 +987,147 @@ describe('LSP', function()     end)   end)   describe('completion_list_to_complete_items', function()+    local function create_compl_item(opt)+        return {+          abbr = opt.abbr,+          dup = opt.dup or 1,+          empty = opt.empty or 1,+          icase = opt.icase or 1,+          info = opt.info or ' ',+          kind = opt.kind or 'Unknown',+          menu = opt.menu or '',+          word = opt.word,+          user_data = {+            nvim = {+              lsp = {+                completion_item = {+                  label = opt.label,+                  insertText = opt.insertText,+                  insertTextFormat = opt.insertTextFormat,+                  textEdit = opt.textEdit,+                }+              }+            }+          },+        }+    end+    local function get_completion_list(completion_list, prefix)+      return exec_lua([[return vim.lsp.util.text_document_completion_list_to_complete_items(...)]], completion_list, prefix)+    end     -- Completion option precedence:     -- textEdit.newText > insertText > label     -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion-    it('should choose right completion option', function ()+    it('should choose right completion option for label', function ()       local prefix = 'foo'       local completion_list = {         -- resolves into label         { label='foobar' },         { label='foobar', textEdit={} },+      }+      local completion_list_items = {items=completion_list}+      local expected = {+        create_compl_item { abbr = 'foobar', word = 'foobar', label = 'foobar' },+        create_compl_item { abbr = 'foobar', word = 'foobar', label = 'foobar', textEdit = {} },+      }++      eq(expected, get_completion_list(completion_list, prefix))+      eq(expected, get_completion_list(completion_list_items, prefix))+      eq({}, get_completion_list({}, prefix))","I find this test somewhat useless. Of course if there are no options to complete, there won't be any results.What I'd like to see is the behavior for something that has a label of ""abc"" instead of ""foo"" as the starting point. Does it still show it as an option? ",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12555,449171763,2020-07-02T17:35:52Z,test/functional/plugin/lsp_spec.lua,"@@ -987,46 +987,147 @@ describe('LSP', function()     end)   end)   describe('completion_list_to_complete_items', function()+    local function create_compl_item(opt)+        return {+          abbr = opt.abbr,+          dup = opt.dup or 1,+          empty = opt.empty or 1,+          icase = opt.icase or 1,+          info = opt.info or ' ',+          kind = opt.kind or 'Unknown',+          menu = opt.menu or '',+          word = opt.word,+          user_data = {+            nvim = {+              lsp = {+                completion_item = {+                  label = opt.label,+                  insertText = opt.insertText,+                  insertTextFormat = opt.insertTextFormat,+                  textEdit = opt.textEdit,+                }+              }+            }+          },+        }+    end+    local function get_completion_list(completion_list, prefix)+      return exec_lua([[return vim.lsp.util.text_document_completion_list_to_complete_items(...)]], completion_list, prefix)+    end     -- Completion option precedence:     -- textEdit.newText > insertText > label     -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion-    it('should choose right completion option', function ()+    it('should choose right completion option for label', function ()       local prefix = 'foo'       local completion_list = {         -- resolves into label         { label='foobar' },         { label='foobar', textEdit={} },+      }+      local completion_list_items = {items=completion_list}+      local expected = {+        create_compl_item { abbr = 'foobar', word = 'foobar', label = 'foobar' },+        create_compl_item { abbr = 'foobar', word = 'foobar', label = 'foobar', textEdit = {} },+      }++      eq(expected, get_completion_list(completion_list, prefix))+      eq(expected, get_completion_list(completion_list_items, prefix))+      eq({}, get_completion_list({}, prefix))+    end)+    it('should choose right completion option for insertText', function ()+      local prefix = 'foo'+      local completion_list = {         -- resolves into insertText         { label='foocar', insertText='foobar' },         { label='foocar', insertText='foobar', textEdit={} },+      }+      local completion_list_items = {items=completion_list}+      local expected = {+        create_compl_item { abbr = 'foocar', word = 'foobar', label='foocar', insertText = 'foobar' },+        create_compl_item { abbr = 'foocar', word = 'foobar', label='foocar', insertText='foobar', textEdit={} },+      }++      eq(expected, get_completion_list(completion_list, prefix))+      eq(expected, get_completion_list(completion_list_items, prefix))","I don't love that every test has this same idea here, as well as the `completion_list_items = {...}` stuff. is there any way to make this more clear what is happening?",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12575,449714144,2020-07-03T22:33:45Z,src/nvim/eval/typval.c,"@@ -638,6 +638,57 @@ list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig,   return NULL; } +/// Flatten ""list"" in place to depth ""maxdepth"".+/// Does nothing if ""maxdepth"" is 0.+///+/// @param[in] list       List to flatten+/// @param[in] maxdepth   Maximum depth that will be flattened+///+/// @return OK or FAIL+int tv_list_flatten(list_T *list, long maxdepth)",Can you add function attributes so that `list` cannot be null?,
629908,hrsh7th,https://api.github.com/repos/neovim/neovim/pulls/12249,449789273,2020-07-04T17:08:32Z,src/nvim/api/buffer.c,"@@ -663,6 +672,222 @@ void nvim_buf_set_lines(uint64_t channel_id,   try_end(err); } +/// Sets (replaces) a range in the buffer.+///+/// Indexing is zero-based, end-exclusive.+///+/// To insert text at a given index, set `start` and `end` ranges to the same+/// index. To delete a range, set `replacement` to an empty array.+///+/// Prefer nvim_buf_set_lines when modifying entire lines.+///+/// @param channel_id+/// @param buffer           Buffer handle, or 0 for current buffer+/// @param start_row        First line index+/// @param start_column     Last column+/// @param end_row          Last line index (exclusive)+/// @param end_column       Last column+/// @param replacement      Array of lines to use as replacement+/// @param[out] err         Error details, if any+void nvim_buf_set_text(uint64_t channel_id,+                       Buffer buffer,+                       Integer start_row,+                       Integer start_col,+                       Integer end_row,+                       Integer end_col,+                       ArrayOf(String) replacement,+                       Error *err)+  FUNC_API_SINCE(7)+{+  // TODO: treat [] as [''] for convenience+  assert(replacement.size > 0);+  buf_T *buf = find_buffer_by_handle(buffer, err);+  if (!buf) {+    return;+  }++  bool oob = false;++  // check range is ordered and everything!+  // start_row, end_row within buffer len (except add text past the end?)+  start_row = normalize_index(buf, start_row, &oob);+  if (oob) {+    api_set_error(err, kErrorTypeValidation, ""start_row out of bounds"");+    return;+  }++  end_row = normalize_index(buf, end_row, &oob);+  /* if (oob) { */+  /*   api_set_error(err, kErrorTypeValidation, ""end_row out of bounds""); */+  /*   return; */+  /* } */++  char *str_at_start = (char *)ml_get_buf(buf, start_row, false);+  if (start_col < 0 || (size_t)start_col > strlen(str_at_start)) {+    api_set_error(err, kErrorTypeValidation, ""start_col out of bounds"");+    return;+  }++  char *str_at_end = (char *)ml_get_buf(buf, end_row, false);+  size_t len_at_end = strlen(str_at_end);+  if (end_col < 0 || (size_t)end_col > len_at_end) {+    api_set_error(err, kErrorTypeValidation, ""end_col out of bounds"");+    return;+  }++  if (start_row > end_row || (end_row == start_row && start_col > end_col)) {+    api_set_error(err, kErrorTypeValidation, ""start is higher than end"");+    return;+  }++  bool disallow_nl = (channel_id != VIML_INTERNAL_CALL);+  if (!check_string_array(replacement, disallow_nl, err)) {+    return;+  }++  size_t new_len = replacement.size;++  String first_item = replacement.items[0].data.string;+  String last_item = replacement.items[replacement.size-1].data.string;+  size_t firstlen = (size_t)start_col+first_item.size;+  size_t last_part_len = strlen(str_at_end) - (size_t)end_col;+  if (replacement.size == 1) {+    firstlen += last_part_len;+  }+  char *first = xmallocz(firstlen), *last = NULL;+  memcpy(first, str_at_start, (size_t)start_col);+  memcpy(first+start_col, first_item.data, first_item.size);+  memchrsub(first+start_col, NUL, NL, first_item.size);+  if (replacement.size == 1) {+    memcpy(first+start_col+first_item.size, str_at_end+end_col, last_part_len);+  } else {+    last = xmallocz(last_item.size+last_part_len);+    memcpy(last, last_item.data, last_item.size);+    memchrsub(last, NUL, NL, last_item.size);+    memcpy(last+last_item.size, str_at_end+end_col, last_part_len);+  }++  char **lines = (new_len != 0) ? xcalloc(new_len, sizeof(char *)) : NULL;+  lines[0] = first;+  for (size_t i = 1; i < new_len-1; i++) {+    const String l = replacement.items[i].data.string;++    // Fill lines[i] with l's contents. Convert NULs to newlines as required by+    // NL-used-for-NUL.+    lines[i] = xmemdupz(l.data, l.size);+    memchrsub(lines[i], NUL, NL, l.size);+    /* lines[i] = replacement.items[i].data.string.data; */+  }+  if (replacement.size > 1) {+    lines[replacement.size-1] = last;+  }++  try_start();+  aco_save_T aco;+  aucmd_prepbuf(&aco, (buf_T *)buf);++  if (!MODIFIABLE(buf)) {+    api_set_error(err, kErrorTypeException, ""Buffer is not 'modifiable'"");+    goto end;+  }++  if (u_save((linenr_T)start_row - 1, (linenr_T)end_row) == FAIL) {+    api_set_error(err, kErrorTypeException, ""Failed to save undo information"");+    goto end;+  }++  ptrdiff_t extra = 0;  // lines added to text, can be negative+  size_t old_len = (size_t)(end_row-start_row+1);++  // If the size of the range is reducing (ie, new_len < old_len) we+  // need to delete some old_len. We do this at the start, by+  // repeatedly deleting line ""start"".+  size_t to_delete = (new_len < old_len) ? (size_t)(old_len - new_len) : 0;+  for (size_t i = 0; i < to_delete; i++) {+    if (ml_delete((linenr_T)start_row, false) == FAIL) {+      api_set_error(err, kErrorTypeException, ""Failed to delete line"");+      goto end;+    }+  }++  if (to_delete > 0) {+    extra -= (ptrdiff_t)to_delete;+  }++  // For as long as possible, replace the existing old_len with the+  // new old_len. This is a more efficient operation, as it requires+  // less memory allocation and freeing.+  size_t to_replace = old_len < new_len ? old_len : new_len;+  for (size_t i = 0; i < to_replace; i++) {+    int64_t lnum = start_row + (int64_t)i;++    if (lnum >= MAXLNUM) {+      api_set_error(err, kErrorTypeValidation, ""Index value is too high"");+      goto end;+    }++    if (ml_replace((linenr_T)lnum, (char_u *)lines[i], false) == FAIL) {+      api_set_error(err, kErrorTypeException, ""Failed to replace line"");+      goto end;+    }+    // Mark lines that haven't been passed to the buffer as they need+    // to be freed later+    lines[i] = NULL;+  }++  // Now we may need to insert the remaining new old_len+  for (size_t i = to_replace; i < new_len; i++) {+    int64_t lnum = start_row + (int64_t)i - 1;++    if (lnum >= MAXLNUM) {+      api_set_error(err, kErrorTypeValidation, ""Index value is too high"");+      goto end;+    }++    if (ml_append((linenr_T)lnum, (char_u *)lines[i], 0, false) == FAIL) {+      api_set_error(err, kErrorTypeException, ""Failed to insert line"");+      goto end;+    }++    // Same as with replacing, but we also need to free lines+    xfree(lines[i]);+    lines[i] = NULL;+    extra++;+  }++  // Adjust marks. Invalidate any which lie in the+  // changed range, and move any in the remainder of the buffer.+  // Only adjust marks if we managed to switch to a window that holds+  // the buffer, otherwise line numbers will be invalid.+  mark_adjust((linenr_T)start_row,+              (linenr_T)end_row,+              MAXLNUM,+              (long)extra,+              kExtmarkNOOP);++  colnr_T col_extent = (colnr_T)(end_col+                                 - ((end_col > start_col) ? start_col : 0));",Thanks for your great work!I have implemented [a similar feature](https://github.com/neovim/neovim/pull/12594/files#diff-d2f9bc382d51d2e37999b2e5ce880750R169) in Lua.Sorry if it does not relate to here.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12593,449920255,2020-07-05T21:24:24Z,runtime/autoload/fswatch.vim,"@@ -0,0 +1,43 @@+if exists('g:loaded_watcher_provider')+  finish+endif++let s:save_cpo = &cpo "" save user coptions+set cpo&vim "" reset them to vim defaults++command! -nargs=1 Watch call fswatch#watch_file(expand('<args>'))+command! -nargs=1 Stop call fswatch#stop_watch(expand('<args>'))++"" function to prompt the user for a reload+function! fswatch#PromptReload()+  let choice = confirm(""File changed. Would you like to reload?"", ""&Yes\n&No"", 1)+  if choice == 1+    edit!+  endif+endfunction++function! fswatch#PrintWatchers()+  call luaeval(""vim.fswatch.print_all()"")",Perhaps these would be better as `v:lua.vim.fswatch.print_all()` or similar. i don't know if we have a style preference for that or not.,
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,450282617,2020-07-06T15:00:02Z,runtime/lua/vim/fswatch/fswatch.lua,"@@ -0,0 +1,140 @@+--[[+  Create a file watcher, each watcher is identified by the name of the file that it+  watches. We can use a lua table to store all watchers indexed by their filenames+  so that we can close the required watcher during the callback to on_change to+  debounce the watcher.+--]]++local uv = vim.loop++local Watcher = {+  fname = '',+  ffname = '',+  handle = nil,+  paused = false,+  pending_notifs = false,+}+local WatcherList = {}++-- idle handle to check for any pending notifications in a watcher.+-- Only displays the notifications if neovim is in focus, and the buffer+-- is the current buffer.++-- Callback for the idle handle+function check_notifications()+  for f, watcher in pairs(WatcherList) do+    if watcher.pending_notifs and watcher.paused == false then+      if uv.fs_stat(watcher.ffname) ~= nil then+        vim.api.nvim_command('call fswatch#PromptReload()')+      else+        print(""ERR: File ""..watcher.fname.."" removed"")+      end+      watcher.pending_notifs = false+    end+  end+end++local check_handle = uv.new_check()+check_handle:start(vim.schedule_wrap(check_notifications))++function Watcher:new(fname)+  assert(fname ~= '', 'Watcher.new: Error: fname is an empty string')+  -- get full path name for the file+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {fname = fname, ffname = ffname, handle = nil}+  setmetatable(w, self)+  self.__index = self+  return w+end++function Watcher:start()+  assert(self.fname ~= '', 'Watcher.start: Error: no file to watch')+  assert(self.ffname ~= '', 'Watcher.start: Error: full path for file not available')+  -- get a new handle+  self.handle = uv.new_fs_event()+  self.handle:start(self.ffname, {}, self.on_change)+end++function Watcher:stop()+  assert(self.fname ~= '', 'Watcher.stop: Error: no file being watched')+  assert(self.handle ~= nil, 'Watcher.stop: Error: no handle watching the file')+  self.handle:stop()+  -- close the handle altogether, for windows.+  if self.handle:is_closing() then+    return+  end+  self.handle:close()+end++function Watcher.on_change(err, fname, event)+  WatcherList[fname].pending_notifs = true++  WatcherList[fname]:stop()+  WatcherList[fname]:start()",When neovim writes files it does it by moving the original file to somewhere else and moving a new temporary file in its place. Thus the old watcher becomes invalid. We do this so that we can start the watcher again on the same file after it has been replaced.,
62146989,cbarrete,https://api.github.com/repos/neovim/neovim/pulls/12556,450420236,2020-07-06T18:58:18Z,runtime/lua/vim/lsp/buf.lua,"@@ -136,6 +136,39 @@ function M.document_symbol()   request('textDocument/documentSymbol', params) end +local function pick_call_hierarchy_item(call_hierarchy_items)+  if not call_hierarchy_items then return end+  if #call_hierarchy_items == 1 then+    return call_hierarchy_items[1]+  end+  local items = {}+  for i, item in ipairs(call_hierarchy_items) do+    local entry = item.detail or item.name+    table.insert(items, string.format(""%d. %s"", i, entry))+  end+  local choice = vim.fn.inputlist(items)+  if choice < 1 or choice > #items then+    return+  end+  return choice+end++function M.incoming_calls()+  local params = util.make_position_params()+  request('textDocument/prepareCallHierarchy', params, function(_, _, result)","Probably not, getting the list of all calls can easily take over 10 seconds on large projects in CLion and it might be worse for some servers.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/12593,450774529,2020-07-07T10:47:02Z,runtime/lua/vim/fswatch/fswatch.lua,"@@ -0,0 +1,140 @@+--[[+  Create a file watcher, each watcher is identified by the name of the file that it+  watches. We can use a lua table to store all watchers indexed by their filenames+  so that we can close the required watcher during the callback to on_change to+  debounce the watcher.+--]]++local uv = vim.loop++local Watcher = {+  fname = '',+  ffname = '',+  handle = nil,+  paused = false,+  pending_notifs = false,+}+local WatcherList = {}++-- idle handle to check for any pending notifications in a watcher.+-- Only displays the notifications if neovim is in focus, and the buffer+-- is the current buffer.++-- Callback for the idle handle+function check_notifications()+  for f, watcher in pairs(WatcherList) do+    if watcher.pending_notifs and watcher.paused == false then+      if uv.fs_stat(watcher.ffname) ~= nil then+        vim.api.nvim_command('call fswatch#PromptReload()')+      else+        print(""ERR: File ""..watcher.fname.."" removed"")+      end+      watcher.pending_notifs = false+    end+  end+end++local check_handle = uv.new_check()+check_handle:start(vim.schedule_wrap(check_notifications))++function Watcher:new(fname)+  assert(fname ~= '', 'Watcher.new: Error: fname is an empty string')+  -- get full path name for the file+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {fname = fname, ffname = ffname, handle = nil}+  setmetatable(w, self)+  self.__index = self+  return w+end++function Watcher:start()+  assert(self.fname ~= '', 'Watcher.start: Error: no file to watch')+  assert(self.ffname ~= '', 'Watcher.start: Error: full path for file not available')+  -- get a new handle+  self.handle = uv.new_fs_event()+  self.handle:start(self.ffname, {}, self.on_change)+end++function Watcher:stop()+  assert(self.fname ~= '', 'Watcher.stop: Error: no file being watched')+  assert(self.handle ~= nil, 'Watcher.stop: Error: no handle watching the file')+  self.handle:stop()+  -- close the handle altogether, for windows.+  if self.handle:is_closing() then+    return+  end+  self.handle:close()+end++function Watcher.on_change(err, fname, event)+  WatcherList[fname].pending_notifs = true++  WatcherList[fname]:stop()+  WatcherList[fname]:start()",> When neovim writes files it does it by moving the original file to somewhere else and moving a new temporary file in its place.That depends on how [`'backupcopy'`](https://neovim.io/doc/user/options.html#'backupcopy') is configured.,
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,451098992,2020-07-07T19:39:44Z,runtime/lua/vim/fswatch/fswatch.lua,"@@ -0,0 +1,140 @@+--[[+  Create a file watcher, each watcher is identified by the name of the file that it+  watches. We can use a lua table to store all watchers indexed by their filenames+  so that we can close the required watcher during the callback to on_change to+  debounce the watcher.+--]]++local uv = vim.loop++local Watcher = {+  fname = '',+  ffname = '',+  handle = nil,+  paused = false,+  pending_notifs = false,+}+local WatcherList = {}++-- idle handle to check for any pending notifications in a watcher.+-- Only displays the notifications if neovim is in focus, and the buffer+-- is the current buffer.++-- Callback for the idle handle+function check_notifications()+  for f, watcher in pairs(WatcherList) do+    if watcher.pending_notifs and watcher.paused == false then+      if uv.fs_stat(watcher.ffname) ~= nil then+        vim.api.nvim_command('call fswatch#PromptReload()')+      else+        print(""ERR: File ""..watcher.fname.."" removed"")+      end+      watcher.pending_notifs = false+    end+  end+end++local check_handle = uv.new_check()+check_handle:start(vim.schedule_wrap(check_notifications))++function Watcher:new(fname)+  assert(fname ~= '', 'Watcher.new: Error: fname is an empty string')+  -- get full path name for the file+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {fname = fname, ffname = ffname, handle = nil}+  setmetatable(w, self)+  self.__index = self+  return w+end++function Watcher:start()+  assert(self.fname ~= '', 'Watcher.start: Error: no file to watch')+  assert(self.ffname ~= '', 'Watcher.start: Error: full path for file not available')+  -- get a new handle+  self.handle = uv.new_fs_event()+  self.handle:start(self.ffname, {}, self.on_change)+end++function Watcher:stop()+  assert(self.fname ~= '', 'Watcher.stop: Error: no file being watched')+  assert(self.handle ~= nil, 'Watcher.stop: Error: no handle watching the file')+  self.handle:stop()+  -- close the handle altogether, for windows.+  if self.handle:is_closing() then+    return+  end+  self.handle:close()+end++function Watcher.on_change(err, fname, event)+  WatcherList[fname].pending_notifs = true++  WatcherList[fname]:stop()+  WatcherList[fname]:start()","Yes, if `backupcopy` is `yes` it simply copies the file instead of renaming it.",
486807,dm1try,https://api.github.com/repos/neovim/neovim/pulls/12235,453833779,2020-07-13T18:05:28Z,test/unit/path_spec.lua,"@@ -603,4 +603,21 @@ describe('path.c', function()       eq(FAIL, path_is_absolute('not/in/my/home~/directory'))     end)   end)++  describe('path_with_extension', function()+    local function path_with_extension(filename, extension)+      local c_filename = to_cstr(filename)+      local c_extension = to_cstr(extension)+      return cimp.path_with_extension(c_filename, c_extension)+    end",this helper function is not needed actually because of using `const char*`(according to http://luajit.org/ext_ffi_semantics.html#convert_fromlua) but I used the example from `path_is_absolute`,
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/12621,454375095,2020-07-14T13:56:23Z,src/nvim/testdir/test_signs.vim,"@@ -6,6 +6,8 @@ endif  source screendump.vim +set noswapfile","I don't pass... Because```Found errors in Test_sign():Caught exception in Test_sign(): Vim(new):E325: ATTENTION @ function RunTheTest[44]..Test_sign, line 42Found errors in Test_sign_group():Caught exception in Test_sign_group(): Vim(split):E325: ATTENTION @ function RunTheTest[44]..Test_sign_group, line 207Found errors in Test_sign_jump_func():Caught exception in Test_sign_jump_func(): Vim(edit):E325: ATTENTION @ function RunTheTest[44]..Test_sign_jump_func, line 5```I think swapfile is on in neovim default.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/12638,454610465,2020-07-14T20:02:16Z,runtime/lua/vim/lsp/protocol.lua,"@@ -700,6 +700,9 @@ function protocol.make_client_capabilities()     workspace = {       symbol = {         dynamicRegistration = false;+        didChangeConfiguration =  {+          dynamicRegistration = true;","Not sure what this does, but I'm wondering if it's necessary for adding/removing workspace components. Can remove",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12639,455736599,2020-07-16T12:06:52Z,runtime/doc/lua.txt,"@@ -574,6 +574,15 @@ retained for the lifetime of a buffer but this is subject to change. A plugin should keep a reference to the parser object as long as it wants incremental updates. +Required runtime files					*lua-treesitter-files*","I worry about naming this section ""lua-treesitter-files"", since the files aren't just for lua.I don't know that we always have to prefix everything with `lua` for tree-sitter stuff.End users don't care what language we implemented it in.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12639,455738052,2020-07-16T12:09:42Z,runtime/doc/lua.txt,"@@ -678,10 +687,16 @@ supported match predicate is `eq?` (both comparing a capture against a string and two captures against each other).  vim.treesitter.parse_query(lang, query)-						*vim.treesitter.parse_query(()*+						*vim.treesitter.parse_query()* 	Parse the query as a string. (If the query is in a file, the caller         should read the contents into a string before calling). +vim.treesitter.get_query(lang, query_name)","These usually go like `vim.treesitter.get_query({lang}, {query_name})`And then below you can reference them the same way to make them look parameter style for the docs.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12639,455748531,2020-07-16T12:28:54Z,runtime/lua/vim/treesitter/query.lua,"@@ -0,0 +1,176 @@+local a = vim.api+local lang = require'vim.treesitter.language'++-- query: pattern matching on trees+-- predicate matching is implemented in lua+local Query = {}+Query.__index = Query++local M = {}++local magic_prefixes = {['\\v']=true, ['\\m']=true, ['\\M']=true, ['\\V']=true}+local function check_magic(str)+  if string.len(str) < 2 or magic_prefixes[string.sub(str,1,2)] then+    return str+  end+  return '\\v'..str+end++-- Some treesitter grammars extend others.+-- We can use that to import the queries of the base language+M.base_language_map = {","And with that, then maybe hide this map as well (like, just make it a local variable and access it with some helper functions outside of the module).",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12639,455751460,2020-07-16T12:34:20Z,runtime/lua/vim/treesitter/query.lua,"@@ -0,0 +1,176 @@+local a = vim.api+local lang = require'vim.treesitter.language'++-- query: pattern matching on trees+-- predicate matching is implemented in lua+local Query = {}+Query.__index = Query++local M = {}++local magic_prefixes = {['\\v']=true, ['\\m']=true, ['\\M']=true, ['\\V']=true}+local function check_magic(str)+  if string.len(str) < 2 or magic_prefixes[string.sub(str,1,2)] then+    return str+  end+  return '\\v'..str+end++-- Some treesitter grammars extend others.+-- We can use that to import the queries of the base language+M.base_language_map = {+  cpp = {'c'},+  typescript = {'javascript'},+  tsx = {'typescript', 'javascript'},+}++function M.parse_query(language, query)+  lang.require_language(language)+  local self = setmetatable({}, Query)+  self.query = vim._ts_parse_query(language, vim.fn.escape(query,'\\'))+  self.info = self.query:inspect()+  self.captures = self.info.captures+  self.regexes = {}+  for id,preds in pairs(self.info.patterns) do+    local regexes = {}+    for i, pred in ipairs(preds) do+      if (pred[1] == ""match?"" and type(pred[2]) == ""number""+          and type(pred[3]) == ""string"") then+        regexes[i] = vim.regex(check_magic(pred[3]))+      end+    end+    if next(regexes) then+      self.regexes[id] = regexes+    end+  end+  return self+end++-- TODO(vigoux): support multiline nodes too+local function get_node_text(node, bufnr)+  local start_row, start_col, end_row, end_col = node:range()+  if start_row ~= end_row then+    return nil+  end+  local line = a.nvim_buf_get_lines(bufnr, start_row, start_row+1, true)[1]+  return string.sub(line, start_col+1, end_col)+end++function Query:match_preds(match, pattern, bufnr)+  local preds = self.info.patterns[pattern]+  if not preds then+    return true+  end+  local regexes = self.regexes[pattern]+  for i, pred in pairs(preds) do+    -- Here we only want to return if a predicate DOES NOT match, and+    -- continue on the other case. This way unknown predicates will not be considered,+    -- which allows some testing and easier user extensibility (#12173).+    -- Also, tree-sitter strips the leading # from predicates for us.+    if pred[1] == ""eq?"" then","This should go along with the same idea that I had mentioned before with the predicate handlers. I don't want to have a huge if-else statement here. We can dispatch to the predicates if we have one using a table, and it will be much more obvious IMO what is happening.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12639,456572675,2020-07-17T17:19:25Z,runtime/lua/vim/treesitter/language.lua,"@@ -0,0 +1,26 @@+local a = vim.api++local M = {}++function M.require_language(lang, path)+  if vim._ts_has_language(lang) then+    return true+  end+  if path == nil then+    local fname = 'parser/' .. lang .. '.*'","It should probably be like `string.format(""parser/%s\\..*"", lang)`  or similar. It should be <language>.<extension>",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12593,456938225,2020-07-19T18:12:34Z,src/nvim/options.lua,"@@ -745,6 +745,14 @@ return {       varname='p_exrc',       defaults={if_true={vi=false}}     },+    {+      full_name='filechangenotify', abbreviation='fcnotify',+      type='string', scope={'buffer'},","it may be more forward compatible to add `list=""comma""` (like the `belloff` option) so that one can add options later on (""showdiff"", ""autoreadfallback"" etc). ",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12646,458257107,2020-07-21T17:11:07Z,src/nvim/ops.c,"@@ -1709,7 +1709,14 @@ static void mb_adjust_opend(oparg_T *oap) static inline void pbyte(pos_T lp, int c) {   assert(c <= UCHAR_MAX);-  *(ml_get_buf(curbuf, lp.lnum, true) + lp.col) = (char_u)c;++  char_u * line = ml_get_buf(curbuf, lp.lnum, true);+  ssize_t old_len = (ssize_t)STRLEN(line);++  line[lp.col] = (char_u)c;++  ml_add_deleted_len(line, old_len);","since old_byte_size has to be lines anyway, shouldn't it be updated here https://github.com/neovim/neovim/blob/master/src/nvim/memline.c#L1879 instead ? There are some other calls of `ml_get_buf(_, _, true)` that won't be taken care of otherwise (I could find examples throughout the code. This can be revisited in the bytetrack PR (maybe add it as a comment so that we don't forget). ",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12593,458283612,2020-07-21T17:54:36Z,runtime/autoload/fcnotify.vim,"@@ -0,0 +1,46 @@+if exists('g:loaded_watcher_provider')+  finish+endif++let s:save_cpo = &cpo "" save user coptions+set cpo&vim "" reset them to vim defaults++command! -nargs=1 Watch call v:lua.vim.fcnotify.start_watch(expand('<args>'))+command! -nargs=1 Stop call v:lua.vim.fcnotify.start_watch(expand('<args>'))","`Stop` ifs too generic, both commands should feel similar: WatchStart / WatchStop for instance or ",
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12639,458357540,2020-07-21T20:08:42Z,runtime/lua/vim/treesitter.lua,"@@ -108,6 +108,20 @@ function M.create_parser(bufnr, lang, id)   return self end +--- Gets the parser for this bufnr / ft combination.+--+-- If needed this will create the parser.+-- In any case, the provided callbacks will be attached to the buffer.",what if there are already callbacks ? `unconditionnally attach the provided callback`,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12547,463167544,2020-07-30T17:47:57Z,runtime/lua/vim/lsp/util.lua,"@@ -1353,6 +1353,39 @@ function M.character_offset(buf, row, col)   return str_utfindex(line, col) end +-- for use with `formatexpr` if called without parms+-- @param start_line 1-indexed line+-- @param end_line 1-indexed line+-- @param timeout_ms optional+function M.formatexpr(start_line, end_line, timeout_ms)+  if not start_line or not end_line then+    if vim.fn.mode() == 'i' or vim.fn.mode() == 'R' then+      -- `formatexpr` is also called when exceding+      -- `textwidth` in insert mode+      -- fall back to internal formatting+      return 1+    end+    start_line = vim.v.lnum+    end_line = start_line + vim.v.count - 1+  end+  if start_line > 0 and end_line > 0 then+    local params = {+      textDocument = { uri = vim.uri_from_bufnr(0) };+      range = {+        start = { line = start_line - 1; character = 0; };+        [""end""] = { line = end_line - 1; character = 0; };+      };+    };+    local result = vim.lsp.buf_request_sync(0, ""textDocument/rangeFormatting"", params, timeout_ms)+    if result then+      result = result[1].result+      vim.lsp.util.apply_text_edits(result)+    end",Should this return 1 if the LSP did not have a result?Will the result always be a list?Can you not re-set the value `result` to be something different from what it is originally?,
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/12639,463228094,2020-07-30T19:40:45Z,runtime/lua/vim/treesitter.lua,"@@ -108,6 +108,20 @@ function M.create_parser(bufnr, lang, id)   return self end +--- Gets the parser for this bufnr / ft combination.+--+-- If needed this will create the parser.+-- Unconditionnally attach the provided callback",Typo:Unconditionnally => Unconditionally,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/12593,464081725,2020-08-02T14:00:50Z,runtime/autoload/fcnotify.vim,"@@ -0,0 +1,46 @@+if exists('g:loaded_watcher_provider')+  finish+endif++let s:save_cpo = &cpo "" save user coptions+set cpo&vim "" reset them to vim defaults++command! -nargs=1 Watch call v:lua.vim.fcnotify.start_watch(expand('<args>'))+command! -nargs=1 Stop call v:lua.vim.fcnotify.start_watch(expand('<args>'))++"" function to prompt the user for a reload+function! fcnotify#PromptReload(buf)+  let choice = confirm(""File "".bufname(a:buf)."" changed. Would you like to reload?"",""&Yes\n&Show diff\n&No"", 1)+  if choice == 1+    call fcnotify#Reload(a:buf)+  elseif choice == 2+    call fcnotify#DiffOrig(a:buf)",Ok I don't want to add too much complexity for now. Just looking at ways to make it more user-friendly.For instance recover.vim detects when there are no changes and it also explicitly differentiates between the on-disk file and inmemory buffer https://github.com/chrisbra/Recover.vim/blob/master/autoload/recover.vim#L299,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12638,467481939,2020-08-08T16:37:42Z,runtime/lua/vim/lsp/buf.lua,"@@ -202,6 +202,65 @@ function M.outgoing_calls()   end) end +--- List workspace folders.+function M.list_workspace_folders()","Should return a list of the folders, users can print if they want.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12593,467504457,2020-08-08T21:09:35Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,224 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+local w = {}+local WatcherList = {}+local commence = nil++--- Callback for the check handle, checks if there are pending notifications+--- for any watcher, and handles them as per the value of the `fcnotify`+--- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    local option = vim.api.nvim_buf_get_option(watcher.bufnr, 'filechangenotify')+    if watcher.pending_notifs and watcher.paused == false and option ~= 'off' then+      if uv.fs_stat(watcher.ffname) ~= nil then+        vim.api.nvim_command('checktime '..watcher.bufnr)+        watcher.pending_notifs = false+      else+        error(""ERR: File ""..watcher.fname.."" removed"")+      end+    end+  end+end++--- Checks if a buffer should have a watcher attached to it.+--- Ignores all the buffers that aren't listed, or have a buf id+--- less than 0.+--- Ignores the [NO NAME] buffer.+---+--@param fname: The validity of this buffer will be checked.+local function valid_buf(fname)+  if fname == '' then+    return false+  end++  local bufnr = vim.api.nvim_call_function('bufnr', {fname})++  if bufnr < 0 then+    return false+  end++  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')+  local buftype = vim.api.nvim_buf_get_option(bufnr, 'buftype')++  if not buflisted or buftype == 'nofile' or buftype == 'quickfix' then+    return false+  end+  return true+end++local check_handle = uv.new_check()+check_handle:start(vim.schedule_wrap(check_notifications))++--- Creates and initializes a new watcher object with the given filename.+---+--@param fname: (required, string) The path that the watcher should watch.+function Watcher:new(fname)+  vim.validate{fname = {fname, 'string', false}}+  -- get full path name for the file+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {bufnr = vim.api.nvim_call_function('bufnr', {fname}),+       fname = fname, ffname = ffname, handle = nil,+       paused = false, pending_notifs = false}+  setmetatable(w, self)+  self.__index = self+  return w+end++local function start_poll(fname)+  WatcherList[fname].handle = uv.new_fs_poll()+  WatcherList[fname].handle:start(WatcherList[fname].ffname, 200, function(...)+    WatcherList[fname]:poll_change(...)+  end)+end++--- Starts the watcher+---+--@param self: (required, table) The watcher object on which start was called.+local function start_watch(fname)+  WatcherList[fname].handle = uv.new_fs_event()+  WatcherList[fname].handle:start(WatcherList[fname].ffname, {}, function(...)+    WatcherList[fname]:watch_change(...)+  end)+end++function Watcher:start()+  if self.handle and not self.handle:is_closing() then+    self.handle:close()+  end++  commence(self.fname)+end++function Watcher.init_poll()+  commence = start_poll+end++function Watcher.init_watcher()+  commence = start_watch+end++--- Stops the watcher and closes the handle.+---+--@param self: (required, table) The watcher object on which stop was called.+function Watcher:stop()+  self.handle:stop()++  -- close the handle altogether, for windows.+  if self.handle:is_closing() then+    return+  end+  self.handle:close()+end++--- Callback for watcher handle. Marks a watcher as having pending+--- notifications. The nature of notification is determined while+--- responding to the notification.+---+--@param err: (string) Error if any occured during the execution of the callback.+---+--@param fname: (string) The file for which the notification was received. (Not+---             very reliable.)+---+--@param event: (table) The type of event recieved for a file.+function Watcher:watch_change(err, fname, event)+  -- To satisfy the lua linter.",You can just put the param name as `_` to silence warnings about unused args if you don't want them.,
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,467507577,2020-08-08T21:49:24Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,224 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+local w = {}+local WatcherList = {}+local commence = nil++--- Callback for the check handle, checks if there are pending notifications+--- for any watcher, and handles them as per the value of the `fcnotify`+--- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    local option = vim.api.nvim_buf_get_option(watcher.bufnr, 'filechangenotify')+    if watcher.pending_notifs and watcher.paused == false and option ~= 'off' then+      if uv.fs_stat(watcher.ffname) ~= nil then+        vim.api.nvim_command('checktime '..watcher.bufnr)+        watcher.pending_notifs = false+      else+        error(""ERR: File ""..watcher.fname.."" removed"")+      end+    end+  end+end++--- Checks if a buffer should have a watcher attached to it.+--- Ignores all the buffers that aren't listed, or have a buf id+--- less than 0.+--- Ignores the [NO NAME] buffer.+---+--@param fname: The validity of this buffer will be checked.+local function valid_buf(fname)+  if fname == '' then+    return false+  end++  local bufnr = vim.api.nvim_call_function('bufnr', {fname})++  if bufnr < 0 then+    return false+  end++  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')+  local buftype = vim.api.nvim_buf_get_option(bufnr, 'buftype')++  if not buflisted or buftype == 'nofile' or buftype == 'quickfix' then+    return false+  end+  return true+end++local check_handle = uv.new_check()+check_handle:start(vim.schedule_wrap(check_notifications))++--- Creates and initializes a new watcher object with the given filename.+---+--@param fname: (required, string) The path that the watcher should watch.+function Watcher:new(fname)+  vim.validate{fname = {fname, 'string', false}}+  -- get full path name for the file+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {bufnr = vim.api.nvim_call_function('bufnr', {fname}),+       fname = fname, ffname = ffname, handle = nil,+       paused = false, pending_notifs = false}+  setmetatable(w, self)+  self.__index = self+  return w+end++local function start_poll(fname)+  WatcherList[fname].handle = uv.new_fs_poll()+  WatcherList[fname].handle:start(WatcherList[fname].ffname, 200, function(...)+    WatcherList[fname]:poll_change(...)+  end)+end++--- Starts the watcher+---+--@param self: (required, table) The watcher object on which start was called.+local function start_watch(fname)+  WatcherList[fname].handle = uv.new_fs_event()+  WatcherList[fname].handle:start(WatcherList[fname].ffname, {}, function(...)+    WatcherList[fname]:watch_change(...)+  end)+end++function Watcher:start()+  if self.handle and not self.handle:is_closing() then+    self.handle:close()+  end++  commence(self.fname)+end++function Watcher.init_poll()","i discussed this with @teto and decided that I'll add polling handle after this PR is merged.(PS: The naming really got me on this one. I had never been so confused. When I will add this later on, I'll probably spread things out between different files. There were so many starts in this one that I had to resolve to `commence` for a function name xD)",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12739,467625739,2020-08-09T20:32:00Z,runtime/lua/vim/treesitter/query.lua,"@@ -0,0 +1,149 @@+local a = vim.api+local lang = require'vim.treesitter.language'++-- query: pattern matching on trees+-- predicate matching is implemented in lua+local Query = {}+Query.__index = Query++local M = {}++--- Parses a query.+--+-- @param language The language+-- @param query A string containing the query (s-expr syntax)+--+-- @returns The query+function M.parse_query(language, query)+  lang.require_language(language)+  local self = setmetatable({}, Query)+  self.query = vim._ts_parse_query(language, vim.fn.escape(query,'\\'))+  self.info = self.query:inspect()+  self.captures = self.info.captures+  for id, preds in pairs(self.info.patterns) do+    local regexes = {}+  end+  return self+end++-- TODO(vigoux): support multiline nodes too+local function get_node_text(node, bufnr)+  local start_row, start_col, end_row, end_col = node:range()+  if start_row ~= end_row then+    return nil+  end+  local line = a.nvim_buf_get_lines(bufnr, start_row, start_row+1, true)[1]+  return string.sub(line, start_col+1, end_col)+end++-- Predicate handler receive the following arguments+-- (match, pattern, bufnr, regexes, index, predicate)+local predicate_handlers = {+  [""eq?""] = function(match, _, bufnr, predicate)+      local node = match[predicate[2]]+      local node_text = get_node_text(node, bufnr)++      local str+      if type(predicate[3]) == ""string"" then+        -- (#eq? @aa ""foo"")+        str = predicate[3]+      else+        -- (#eq? @aa @bb)+        str = get_node_text(match[predicate[3]], bufnr)+      end++      if node_text ~= str or str == nil then+        return false+      end++      return true+  end,+  [""match?""] = function(match, _, bufnr, predicate)+      local node = match[predicate[2]]+      local regex = predicate[3]+      local start_row, start_col, end_row, end_col = node:range()+      if start_row ~= end_row then+        return false+      end++      return string.find(get_node_text(node, bufnr), regex)+  end,+}++function M.add_predicate(name, handler)+  predicate_handlers[name] = handler","May want to warn if name already exists (overwriting built-in could have bad side effects, for example). Or even prevent overriding the defaults, for example.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12739,471058406,2020-08-16T03:07:55Z,runtime/lua/vim/treesitter.lua,"@@ -38,48 +46,39 @@ function Parser:_on_lines(bufnr, changed_tick, start_row, old_stop_row, stop_row   end end +--- Sets the included ranges for the current parser+--+-- @param ranges A table of nodes that will be used as the ranges the parser should include. function Parser:set_included_ranges(ranges)   self._parser:set_included_ranges(ranges)   -- The buffer will need to be parsed again later   self.valid = false end -local M = {-  parse_query = vim._ts_parse_query,-}+local M = vim.tbl_extend(""error"", query, language)  setmetatable(M, {   __index = function (t, k)       if k == ""TSHighlighter"" then-        t[k] = require'vim.tshighlighter'+        a.nvim_err_writeln(""vim.TSHighlighter is deprecated, please use vim.treesitter.highlighter"")+        t[k] = require'vim.treesitter.highlighter'+        return t[k]+      elseif k == ""highlighter"" then+        t[k] = require'vim.treesitter.highlighter'         return t[k]       end    end  }) -function M.require_language(lang, path)-  if vim._ts_has_language(lang) then-    return true-  end-  if path == nil then-    local fname = 'parser/' .. lang .. '.*'-    local paths = a.nvim_get_runtime_file(fname, false)-    if #paths == 0 then-      -- TODO(bfredl): help tag?-      error(""no parser for '""..lang..""' language"")-    end-    path = paths[1]-  end-  vim._ts_add_language(path, lang)-end--function M.inspect_language(lang)-  M.require_language(lang)-  return vim._ts_inspect_language(lang)-end--function M.create_parser(bufnr, lang, id)-  M.require_language(lang)+--- Creates a new parser.+--+-- It is not recommended to use this, use vim.treesitter.get_parser() instead.+--+-- @param bufnr The buffer the parser will be tied to+-- @param lang The language of the parser.+-- @param id The id the parser will have","(If you're interested, I'm also working on https://github.com/tjdevries/tree-sitter-nlua this to generate the docs using tree-sitter for Lua so that it is semantically correct and will give us much more control over how it works.)",
7951510,aufarg,https://api.github.com/repos/neovim/neovim/pulls/12721,471074667,2020-08-16T06:54:48Z,src/nvim/testdir/test_search.vim,"@@ -346,25 +346,90 @@ func Test_searchc()   bw! endfunc -func Test_search_cmdline3()+func Cmdline3_prep()   throw 'skipped: Nvim does not support test_override()'-  if !exists('+incsearch')-    return-  endif   "" need to disable char_avail,   "" so that expansion of commandline works   call test_override(""char_avail"", 1)   new   call setline(1, ['  1', '  2 the~e', '  3 the theother'])   set incsearch+endfunc++func Incsearch_cleanup()+  throw 'skipped: Nvim does not support test_override()'+  set noincsearch+  call test_override(""char_avail"", 0)+  bw!+endfunc++func Test_search_cmdline3()+  throw 'skipped: Nvim does not support test_override()'+  if !exists('+incsearch')+    return+  endif+  call Cmdline3_prep()   1   "" first match   call feedkeys(""/the\<c-l>\<cr>"", 'tx')   call assert_equal('  2 the~e', getline('.'))-  "" clean up-  set noincsearch-  call test_override(""char_avail"", 0)-  bw!++  call Incsearch_cleanup()+endfunc++func Test_search_cmdline3s()+  throw 'skipped: Nvim does not support test_override()'+  if !exists('+incsearch')+    return+  endif+  call Cmdline3_prep()+  1+  call feedkeys("":%s/the\<c-l>/xxx\<cr>"", 'tx')+  call assert_equal('  2 xxxe', getline('.'))+","For this hunk:```diff --git a/src/nvim/testdir/test_search.vim b/src/nvim/testdir/test_search.vimindex 71de172dc..7e8ddbe64 100644--- a/src/nvim/testdir/test_search.vim+++ b/src/nvim/testdir/test_search.vim@@ -516,11 +522,11 @@ func Test_search_cmdline7()   endif   "" need to disable char_avail,   "" so that expansion of commandline works   call test_override(""char_avail"", 1)   new-  let @/='b'+  let @/ = 'b'   call setline(1, [' bbvimb', ''])   set incsearch   "" first match   norm! gg0   "" moves to next match of previous search pattern, just like /<cr>/```It changes the line on `Test_search_cmdline7`, which was not ported from mainline. It was introduced in patch 8.0.1250. Should I port the whole test? Should it be part of this changeset or should I make another PR?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12040,471238315,2020-08-17T05:26:29Z,src/nvim/api/vim.c,"@@ -2615,3 +2616,29 @@ void nvim__put_attr(Integer id, Integer start_row, Integer start_col,   decorations_add_luahl_attr(attr, (int)start_row, (colnr_T)start_col,                              (int)end_row, (colnr_T)end_col); }++/// Gets api function documentation+//+// @return Dictionary of the form+// { ""nvim_win_set_option"": {...}, ""nvim_win_get_option"": {...}, ... }+Dictionary nvim_doc_get_api(void)","was hoping to instead introduce `nvim_get_api` which will deprecate `nvim_get_api_info`.    nvim_get_api(Dict options)works like the old `nvim_get_api_info`, except:- `options.doc = true` (default=false) includes docstrings with the API metadata - the `functions` and `ui_events` elements are maps instead of a list  - feel free to make this a TODO for this PR, if you don't want to do it ",
762115,meck,https://api.github.com/repos/neovim/neovim/pulls/12547,475195517,2020-08-23T09:23:26Z,runtime/lua/vim/lsp/util.lua,"@@ -1353,6 +1353,39 @@ function M.character_offset(buf, row, col)   return str_utfindex(line, col) end +-- for use with `formatexpr` if called without parms+-- @param start_line 1-indexed line+-- @param end_line 1-indexed line+-- @param timeout_ms optional+function M.formatexpr(start_line, end_line, timeout_ms)+  if not start_line or not end_line then+    if vim.fn.mode() == 'i' or vim.fn.mode() == 'R' then+      -- `formatexpr` is also called when exceding+      -- `textwidth` in insert mode+      -- fall back to internal formatting+      return 1+    end+    start_line = vim.v.lnum+    end_line = start_line + vim.v.count - 1+  end+  if start_line > 0 and end_line > 0 then+    local params = {+      textDocument = { uri = vim.uri_from_bufnr(0) };+      range = {+        start = { line = start_line - 1; character = 0; };+        [""end""] = { line = end_line - 1; character = 0; };+      };+    };+    local result = vim.lsp.buf_request_sync(0, ""textDocument/rangeFormatting"", params, timeout_ms)+    if result then+      result = result[1].result+      vim.lsp.util.apply_text_edits(result)+    end","It took a while to get back to this...I took the usage from [here](https://github.com/neovim/neovim/blob/8c49e3d50959e24dadd688f56a18f104bd5fd934/runtime/lua/vim/lsp/buf.lua#L99l)From `lsp.buf_request_sync`:```@returns Map of client_id:request_result. On timeout, cancel or error,-        returns `(nil, err)` where `err` is a string describing the failure-        reason.```If we return 1 it will run the builtin formatter instead, I don't think that's good behavior.How do you mean, what should `result` be set to?",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12547,476470652,2020-08-25T13:59:23Z,runtime/lua/vim/lsp/util.lua,"@@ -1353,6 +1353,39 @@ function M.character_offset(buf, row, col)   return str_utfindex(line, col) end +-- for use with `formatexpr` if called without parms+-- @param start_line 1-indexed line+-- @param end_line 1-indexed line+-- @param timeout_ms optional+function M.formatexpr(start_line, end_line, timeout_ms)+  if not start_line or not end_line then+    if vim.fn.mode() == 'i' or vim.fn.mode() == 'R' then+      -- `formatexpr` is also called when exceding+      -- `textwidth` in insert mode+      -- fall back to internal formatting+      return 1+    end+    start_line = vim.v.lnum+    end_line = start_line + vim.v.count - 1+  end+  if start_line > 0 and end_line > 0 then+    local params = {+      textDocument = { uri = vim.uri_from_bufnr(0) };+      range = {+        start = { line = start_line - 1; character = 0; };+        [""end""] = { line = end_line - 1; character = 0; };+      };+    };+    local result = vim.lsp.buf_request_sync(0, ""textDocument/rangeFormatting"", params, timeout_ms)+    if result then+      result = result[1].result+      vim.lsp.util.apply_text_edits(result)+    end","Sorry, I wasn't super clear.I was asking about the structure of the result (like, could it return a single item, rather than a list of items). As in, the result we get from the LSP.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12624,479736699,2020-08-30T07:57:39Z,third-party/CMakeLists.txt,"@@ -161,8 +161,8 @@ set(UNIBILIUM_SHA256 29815283c654277ef77a3adcc8840db79ddbb20a0f0b0c8f648bd8cd49a set(LIBTERMKEY_URL http://www.leonerd.org.uk/code/libtermkey/libtermkey-0.22.tar.gz) set(LIBTERMKEY_SHA256 6945bd3c4aaa83da83d80a045c5563da4edd7d0374c62c0d35aec09eb3014600) -set(LIBVTERM_URL https://github.com/neovim/libvterm/archive/65dbda3ed214f036ee799d18b2e693a833a0e591.tar.gz)-set(LIBVTERM_SHA256 95d3c7e86336fbd40dfd7a0aa0a795320bb71bc957ea995ea0e549c96d20db3a)+set(LIBVTERM_URL http://www.leonerd.org.uk/code/libvterm/libvterm-0.1.4.tar.gz)+set(LIBVTERM_SHA256 bc70349e95559c667672fc8c55b9527d9db9ada0fb80a3beda533418d782d3dd)",> What is the issue with the hashes? That they have to be recomputed manually?somehow git-bzr changes the hashes every time we update the mirror: https://github.com/neovim/bot-ci/blob/c799c16b003db67e353542ee7f1494731931dc6b/ci/sync-mirrors.sh#L46not sure if we're using git-bzr wrong or if bzr just sucks.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12775,479740607,2020-08-30T08:36:47Z,runtime/doc/provider.txt,"@@ -222,6 +222,23 @@ For example this configuration integrates the tmux clipboard: >           \   'cache_enabled': 1,           \ } +Commands can also be specified with lists, which is useful for arguments",could you instead just change the above example to use lists? the string form is a bad idea anyways.good to keep the docs concise.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12775,479741276,2020-08-30T08:42:55Z,runtime/autoload/provider/clipboard.vim,"@@ -122,17 +129,23 @@ function! provider#clipboard#Executable() abort     let s:paste['+'] = win32yank.' -o --lf'     let s:copy['*'] = s:copy['+']     let s:paste['*'] = s:paste['+']-    return 'win32yank'+    let name = 'win32yank'   elseif exists('$TMUX') && executable('tmux')     let s:copy['+'] = 'tmux load-buffer -'     let s:paste['+'] = 'tmux save-buffer -'     let s:copy['*'] = s:copy['+']     let s:paste['*'] = s:paste['+']-    return 'tmux'+    let name = 'tmux'+  else+    let s:err = 'clipboard: No clipboard tool. :help clipboard'+    return ''   endif -  let s:err = 'clipboard: No clipboard tool. :help clipboard'-  return ''+  let s:copy['+'] = s:split_cmd(get(s:copy, '+', v:null))+  let s:paste['+'] = s:split_cmd(get(s:paste, '+', v:null))+  let s:copy['*'] = s:split_cmd(get(s:copy, '*', v:null))+  let s:paste['*'] = s:split_cmd(get(s:paste, '*', v:null))","would prefer to update all the cases to lists instead of setting them as strings and then immediately splitting them. that also eliminates the need for s:split_cmd(), the rework of the `return` statements, and having many `let s:foo` cases which are then immediately overwritten in the same scope.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12811,479801028,2020-08-30T18:28:03Z,src/nvim/cursor_shape.c,"@@ -99,11 +99,23 @@ char_u *parse_shape_opt(int what)    // First round: check for errors; second round: do it for real.   for (round = 1; round <= 2; round++) {+    // Set the defaults, for the missing parts","""for the missing parts"" is no longer relevant, right?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12798,479833128,2020-08-31T00:01:49Z,test/functional/lua/buffer_updates_spec.lua,"@@ -216,4 +216,23 @@ describe('lua: buffer event callbacks', function()     eq(1, meths.get_var('listener_cursor_line'))   end) +  it('does not SEGFAULT when calling win_findbuf in on_detach', function()++    exec_lua[[+      local buf = vim.api.nvim_create_buf(false, false)++      vim.cmd""split""+      vim.api.nvim_win_set_buf(0, buf)++      vim.api.nvim_buf_attach(buf, false, {+        on_detach = function(_, buf)+          vim.fn.win_findbuf(buf)+        end+      })+    ]]++    feed('ZQ')","nit: is there a reason not to use `command('qa!')` here? The benefit of `command()` is that it's synchronouse, whereas feed() just sends input to the nvim server and doesn't (can't) wait for nvim to process it.if you are not intentionally looking for that asynchronous behavior of feed(), then `command('qa!')` is preferred since that's the typical pattern in most other tests.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/12483,479891205,2020-08-31T05:12:22Z,test/functional/plugin/man_spec.lua,"@@ -11,7 +19,8 @@ describe(':Man', function()       clear()       command('syntax on')       command('set filetype=man')-      command('syntax off')  -- Ignore syntax groups+      command('syntax off')  -- Ignore syntax groups.+      command('unlet b:man_pager') -- Allow  man#init_pager to rerun.","I'll give it a shot but why would this be causing the crash, and why only on windows/big endian.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12736,480109646,2020-08-31T12:53:44Z,src/nvim/lua/treesitter.c,"@@ -646,6 +654,36 @@ static int node_symbol(lua_State *L)   return 1; } +static int node_field(lua_State *L)+{+  TSNode node;+  if (!node_check(L, 1, &node)) {+    return 0;+  }++  size_t name_len;+  const char *field_name = luaL_checklstring(L, 2, &name_len);++  TSTreeCursor cursor = ts_tree_cursor_new(node);++  lua_newtable(L);  // [table]+  unsigned int curr_index = 0;++  if (ts_tree_cursor_goto_first_child(&cursor)) {+    // TODO(vigoux): It seems that multiple fields with the same name+    //  are possible, but is that really a good practice ?","Do we need this TODO here?If you're sure you only need one, we could optionally pass in another variable (`find_first`) and then it doesn't return a list, it just returns the node. And it quits out earlier.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12819,480564293,2020-09-01T01:39:21Z,src/nvim/eval.c,"@@ -10386,6 +10386,12 @@ void script_host_eval(char *name, typval_T *argvars, typval_T *rettv)   *rettv = eval_call_provider(name, ""eval"", args); } +void eval_call_provider_discard(char *provider, char *method, list_T *arguments)+{+  typval_T rettv = eval_call_provider(provider, method, arguments);+  tv_clear(&rettv);+}+ typval_T eval_call_provider(char *provider, char *method, list_T *arguments)","can we do it as a param instead?```suggestion/// @param discard  Clears the value returned by the provider and returns empty typval_T. typval_T eval_call_provider(char *provider, char *method, list_T *arguments, bool discard)```",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/12826,481074234,2020-09-01T11:41:32Z,runtime/lua/vim/treesitter/query.lua,"@@ -127,25 +130,38 @@ function M.add_predicate(name, handler, force)   predicate_handlers[name] = handler end +local function xor(a, b)",Is there a list of the available modules somewhere ?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12825,481619185,2020-09-02T03:42:32Z,runtime/lua/vim/lsp/util.lua,"@@ -1437,6 +1437,9 @@ local function make_position_param()   local row, col = unpack(api.nvim_win_get_cursor(0))   row = row - 1   local line = api.nvim_buf_get_lines(0, row, row+1, true)[1]+  if not line then","Ah I read https://github.com/neovim/neovim/issues/12623#issuecomment-675360894 , that makes sense, it happens during startup. (helps to mention this in the commit message)Sure enough, `source_startup_scripts` is done before `edit_buffers`:https://github.com/neovim/neovim/blob/9bb552875d205d2f869c66137563f93b77a6d08e/src/nvim/main.c#L362https://github.com/neovim/neovim/blob/9bb552875d205d2f869c66137563f93b77a6d08e/src/nvim/main.c#L480",
2245664,Xuyuanp,https://api.github.com/repos/neovim/neovim/pulls/11950,481651343,2020-09-02T04:15:49Z,runtime/lua/vim/lsp/util.lua,"@@ -275,6 +275,65 @@ function M.convert_input_to_markdown_lines(input, contents)   return contents end +--- Convert SignatureHelp response to markdown lines.+-- https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_signatureHelp+function M.convert_signature_help_to_markdown_lines(signature_help)+  if not signature_help.signatures then+    return+  end+  --The active signature. If omitted or the value lies outside the range of+  --`signatures` the value defaults to zero or is ignored if `signatures.length+  --=== 0`. Whenever possible implementors should make an active decision about+  --the active signature and shouldn't rely on a default value.+  local contents = {}+  local active_signature = signature_help.activeSignature or 0+  -- If the activeSignature is not inside the valid range, then clip it.+  if active_signature >= #signature_help.signatures then+    active_signature = 0+  end+  local signature = signature_help.signatures[active_signature + 1]+  if not signature then+    return+  end+  vim.list_extend(contents, vim.split(signature.label, '\n', true))+  if signature.documentation then+    M.convert_input_to_markdown_lines(signature.documentation, contents)+  end+  if signature_help.parameters then",here should be ```luaif signature.parameters then```,
2245664,Xuyuanp,https://api.github.com/repos/neovim/neovim/pulls/11950,481660238,2020-09-02T04:24:39Z,runtime/lua/vim/lsp/util.lua,"@@ -275,6 +275,65 @@ function M.convert_input_to_markdown_lines(input, contents)   return contents end +--- Convert SignatureHelp response to markdown lines.+-- https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_signatureHelp+function M.convert_signature_help_to_markdown_lines(signature_help)+  if not signature_help.signatures then+    return+  end+  --The active signature. If omitted or the value lies outside the range of+  --`signatures` the value defaults to zero or is ignored if `signatures.length+  --=== 0`. Whenever possible implementors should make an active decision about+  --the active signature and shouldn't rely on a default value.+  local contents = {}+  local active_signature = signature_help.activeSignature or 0+  -- If the activeSignature is not inside the valid range, then clip it.+  if active_signature >= #signature_help.signatures then+    active_signature = 0+  end+  local signature = signature_help.signatures[active_signature + 1]+  if not signature then+    return+  end+  vim.list_extend(contents, vim.split(signature.label, '\n', true))+  if signature.documentation then+    M.convert_input_to_markdown_lines(signature.documentation, contents)+  end+  if signature_help.parameters then+    local active_parameter = signature_help.activeParameter or 0+    -- If the activeParameter is not inside the valid range, then clip it.+    if active_parameter >= #signature_help.parameters then+      active_parameter = 0+    end+    local parameter = signature.parameters and signature.parameters[active_parameter]",```lualocal parameter = signature.parameters and signature.parameters[active_parameter+1]```,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12721,483966418,2020-09-05T16:35:42Z,src/nvim/ex_docmd.c,"@@ -1369,29 +1264,43 @@ static char_u * do_one_cmd(char_u **cmdlinep,    */   save_cmdmod = cmdmod; -  parse_state_from_global(&parsed);-  parsed.eap = &ea;-  parsed.verbose_save = -1;-  parsed.save_msg_silent = -1;-  parsed.did_esilent = 0;-  parsed.did_sandbox = false;-  bool parse_success = parse_one_cmd(cmdlinep, &parsed, cstack, fgetline, cookie);",Is this removed because `parse_one_cmd` doesn't do as documented or it is useless or it makes it harder to port other patches?There is no context for the removal in the commit description.,
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/12802,484043601,2020-09-06T09:04:14Z,test/helpers.lua,"@@ -202,10 +202,18 @@ function module.check_logs()         fd:close()         os.remove(file)         if #lines > 0 then-          local out = io.stdout+          local out+          if os.getenv('SYMBOLIZER') ~= nil then+            out = io.popen(os.getenv('SYMBOLIZER'), 'w')+          else+            out = io.stdout","I have bad experiences with this sort of logic shortening in lua (is there a name for it?). I'd at least add braces:```lualocal out = (os.getenv('SYMBOLIZER') == nil and io.stdout) or io.popen(os.getenv('SYMBOLIZER'), 'w')```",
23156099,kyazdani42,https://api.github.com/repos/neovim/neovim/pulls/12858,484070669,2020-09-06T13:32:07Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -98,7 +98,12 @@ function TSHighlighter:get_hl_from_capture(capture)     return vim.split(name, '.', true)[1]   else     -- Default to false to avoid recomputing-    return a.nvim_get_hl_id_by_name(TSHighlighter.hl_map[name])+    local hl = TSHighlighter.hl_map[name]+    if hl then","badly read the comment, indeed your version is better. We'll forget about outputting information for now, unless you wish to do it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12826,484096777,2020-09-06T17:48:51Z,runtime/doc/lua.txt,"@@ -756,14 +756,15 @@ Here is a list of built-in predicates : 			((node1) @left (node2) @right (#eq? @left @right)) < 	`match?`					*ts-predicate-match?*-		This will match if the provived lua regex matches the text+	`vim-match?`					*ts-predicate-vim-match?*+		This will match if the provived vim regex matches the text 		corresponding to a node : > 			((idenfitier) @constant (#match? @constant ""^[A-Z_]+$"")) <		Note: the `^` and `$` anchors will respectively match the 			start and end of the node's text. -	`vim-match?`					*ts-predicate-vim-match?*-		This will match the same way than |match?| but using vim+	`lua-match?`					*ts-predicate-lua-match?*+		This will match the same way than |match?| but using lua 		regexes.","I tend to write ""pattern"" in the docs when referring to Lua ""regex"". AFAIK that is what Lua calls them.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/12568,485836925,2020-09-09T18:45:48Z,src/nvim/fold.c,"@@ -1742,10 +1742,9 @@ static void foldDelMarker(       assert(p >= line);       memcpy(newline, line, (size_t)(p - line));       STRCPY(newline + (p - line), p + len);-      ml_replace_buf(buf, lnum, newline, false);+      ml_replace(lnum, newline, false);       extmark_splice_cols(buf, (int)lnum-1, (int)(p - line),-                          (int)len,-                          0, kExtmarkUndo);+                          (int)len, 0, kExtmarkUndo);",`ml_replace` should be `ml_replace_buf` sorry for the bad range comment.,
4458174,ThePrimeagen,https://api.github.com/repos/neovim/neovim/pulls/12878,486024880,2020-09-10T02:26:13Z,runtime/lua/vim/lsp/util.lua,"@@ -674,7 +674,10 @@ function M.focusable_float(unique_name, fn)       return     end   end-  local pbufnr, pwinnr = fn()+  local ok, pbufnr, pwinnr = pcall(fn())","awesome!  Does this mean that the commit is useless or should we ""protect"" the function call?  Its quite cumbersome when things are not working.Side note, a better logging system in general would be nice for this kind of work.  It would be really nice to know that your function is throwing, but not display red messages to the end user. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12053,488092544,2020-09-14T17:10:05Z,test/functional/lua/vim_spec.lua,"@@ -579,19 +598,19 @@ describe('lua stdlib', function()       return vim.tbl_islist(c) and count == 0     ]])) -    eq('Error executing lua: .../shared.lua: invalid ""behavior"": nil',+    eq('.../helpers.lua:0: Error executing lua: shared.lua:0: invalid ""behavior"": nil',","- It's kinda ugly that helpers.lua is here, but that's what is actually happening so no point in hiding it. - The `.../shared.lua` was wrong, there was no full path to `shared.lua`. The new form is correct.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12921,489242387,2020-09-16T08:03:19Z,src/nvim/api/vim.c,"@@ -2767,3 +2768,29 @@ void nvim__set_luahl(DictionaryOf(LuaRef) opts, Error *err) error:   clear_luahl(true); }++/// Search the helptags for a pattern+///+/// @param pattern the pattern to search+/// @param[out] err error if any+Array nvim_get_helptags(String pattern, Error *err)","Do we want this to be `nvim_get_tags` already? Supporting only helptags is OK for now, but should it be spelled as `nvim_get_tags(""pattern"", {source=""help""})` or something like that, so it is easier to extend later?",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/12921,489243823,2020-09-16T08:05:45Z,src/nvim/api/vim.c,"@@ -2767,3 +2768,29 @@ void nvim__set_luahl(DictionaryOf(LuaRef) opts, Error *err) error:   clear_luahl(true); }++/// Search the helptags for a pattern+///+/// @param pattern the pattern to search+/// @param[out] err error if any+Array nvim_get_helptags(String pattern, Error *err)","That sounds like a good idea.The thing that needs to be adressed too is the return value of the function.After some discussion with @tjdevries we thought that a `taglist()`-like return value can be great, looking like this :```[  {    tag : String,    fname : String,    lnum : Integer  }]```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12939,491447452,2020-09-19T14:09:21Z,test/functional/lua/buffer_updates_spec.lua,"@@ -438,6 +438,20 @@ describe('lua: nvim_buf_attach on_bytes', function()         { ""test1"", ""bytes"", 1, 4, 1, 0, 1, 3, 0, 48, 0, 0, 0 };       }     end)++    it(""visual charwise paste"", function()+      local check_events = setup_eventcheck(verify, {'1234567890'})+      funcs.setreg('a', '___')++      feed '1G1|vll'+      check_events {}++      feed '""ap'+      check_events {+        { ""test1"", ""bytes"", 1, 3, 0, 0, 0, 0, 3, 3, 0, 0, 0 };","Note: this should ideally be collapsed into one event (to save some bandwidth). There is nothing ""wrong"" with the current events semantically though.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12696,492443514,2020-09-22T02:26:23Z,src/nvim/eval/funcs.c,"@@ -3507,6 +3507,29 @@ static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)   get_qf_loc_list(false, wp, &argvars[1], rettv); } ++/// ""getmarklist()"" function+static void f_getmarklist(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  buf_T *buf = NULL;",buf is set to an unused value. Declare and initialize the variable on the same line below.,
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/12956,492502253,2020-09-22T06:37:41Z,runtime/lua/vim/uri.lua,"@@ -51,23 +51,31 @@ end   --@private-local function is_windows_file_uri(uri)-  return uri:match('^file:///[a-zA-Z]:') ~= nil+-- For test cases, uri is hard-coded.+-- So control the return value through a variable parameter+-- If we test a windows uri param is 0+local function is_windows(...)",Then we don't need to pass in any parameters. Everything will also become cheaper.,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12968,493963753,2020-09-24T00:00:37Z,src/nvim/undo.c,"@@ -3029,15 +3029,14 @@ u_header_T *u_force_get_undo_header(buf_T *buf)     curbuf = buf;     // Args are tricky: this means replace empty range by empty range..     u_savecommon(0, 1, 1, true);-    curbuf = save_curbuf;-     uhp = buf->b_u_curhead;     if (!uhp) {       uhp = buf->b_u_newhead;       if (get_undolevel() > 0 && !uhp) {         abort();       }     }+    curbuf = save_curbuf;","In the absence of this change, the following steps can cause a crash similar to #12873.```vimnvim -u NORC:vsplit file:let bufnr = 1:call nvim_buf_set_option(bufnr, ""undofile"", v:false):call nvim_buf_set_option(bufnr, ""undolevels"", -1):let g:mark_ns = nvim_create_namespace('myns'):let g:mark_id = nvim_buf_set_extmark(1, g:mark_ns, 0, 0, {})```",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12968,493971412,2020-09-24T00:27:12Z,src/nvim/undo.c,"@@ -3029,15 +3029,14 @@ u_header_T *u_force_get_undo_header(buf_T *buf)     curbuf = buf;     // Args are tricky: this means replace empty range by empty range..     u_savecommon(0, 1, 1, true);-    curbuf = save_curbuf;-     uhp = buf->b_u_curhead;     if (!uhp) {       uhp = buf->b_u_newhead;       if (get_undolevel() > 0 && !uhp) {         abort();       }     }+    curbuf = save_curbuf;","Since `uhp` cannot be `NULL` except when `undoleves` is -1, shouldn't the interior of the following `if` clause never be executed? Doesn't the internal execution of the `if` clause below imply that the creation or deletion of the `extmark`, without editing, creates an entry for undo/redo?https://github.com/neovim/neovim/blob/4f8d98e583beb4c1abd5d57b9898548396633030/src/nvim/undo.c#L3024-L3041",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/12955,494059930,2020-09-24T06:09:12Z,src/nvim/spell.c,"@@ -362,6 +362,8 @@ size_t spell_check(   size_t wrongcaplen = 0;   int lpi;   bool count_word = docount;+  bool use_camel_case = *wp->w_s->b_p_spo != NUL;+  bool camel_case = 0;",Lol I am so lazy sometimes...,
1740244,BigPeet,https://api.github.com/repos/neovim/neovim/pulls/12696,495569026,2020-09-27T12:40:16Z,src/nvim/mark.c,"@@ -1552,3 +1552,92 @@ void mark_mb_adjustpos(buf_T *buf, pos_T *lp)     }   } }+++// Add information about mark 'mname' to list 'l'+static int add_mark(list_T *l, char *mname, pos_T *pos, int bufnr, char *fname)","Sorry, I'm not yet familiar with nvim's function attributes. (that's also the reason for the useless NULL checks, etc.)Is there some documentation about what the attributes mean?What do you mean with your comment about `fname`?",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12696,495574049,2020-09-27T13:38:55Z,src/nvim/mark.c,"@@ -1552,3 +1552,92 @@ void mark_mb_adjustpos(buf_T *buf, pos_T *lp)     }   } }+++// Add information about mark 'mname' to list 'l'+static int add_mark(list_T *l, char *mname, pos_T *pos, int bufnr, char *fname)",I can't find the docs for it so get by with the macro definitions in https://github.com/neovim/neovim/blob/master/src/nvim/func_attr.h for now. Enforce nonnull function params via `FUNC_ATTR_NONNULL_ARG`.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12696,495574982,2020-09-27T13:48:32Z,src/nvim/mark.c,"@@ -1552,3 +1552,92 @@ void mark_mb_adjustpos(buf_T *buf, pos_T *lp)     }   } }+++// Add information about mark 'mname' to list 'l'+static int add_mark(list_T *l, char *mname, pos_T *pos, int bufnr, char *fname)",`l` cannot be null because of `tv_list_append_dict`.`mname` is the name of the mark so it is always nonnull even though `tv_dict_add_str`  allows NULL.`pos->lnum` forces `pos` to be nonnull.`bufnr` is not a pointer. You can skip this in `FUNC_ATTR_NONNULL_ARG`.`fname` can be NULL because of `get_buf_local_marks`.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12696,495575676,2020-09-27T13:55:04Z,src/nvim/mark.c,"@@ -1552,3 +1552,92 @@ void mark_mb_adjustpos(buf_T *buf, pos_T *lp)     }   } }+++// Add information about mark 'mname' to list 'l'+static int add_mark(list_T *l, char *mname, pos_T *pos, int bufnr, char *fname)",Check if some parameters can use `const`. https://neovim.io/develop/style-guide.xml#Use_of_const,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/13007,497586194,2020-09-30T15:07:08Z,runtime/lua/vim/lsp/util.lua,"@@ -800,13 +800,15 @@ function M.fancy_floating_markdown(contents, opts)   local width, height = M._make_floating_popup_size(stripped, opts)    -- Insert blank line separator after code block-  local insert_separator = opts.separator or true+  local insert_separator = opts.separator","That's exactly what the next line is for :) We could change the API, though (which would be breaking), but the semantics should be the same, right? ",
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/12764,499103419,2020-10-03T01:29:42Z,runtime/lua/vim/lsp.lua,"@@ -25,13 +25,40 @@ local lsp = {   -- format_rpc_error = lsp_rpc.format_rpc_error; } +-- maps request name to the required resolved_capability in the client.+local req_to_capability = {+  ['textDocument/hover'] = 'hover';+  ['textDocument/signatureHelp'] = 'signature_help';+  ['textDocument/definition'] = 'goto_definition';+  ['textDocument/implementation'] = 'implementation';+  ['textDocument/declaration'] = 'declaration';+  ['textDocument/typeDefinition'] = 'type_definition';+  ['textDocument/documentSymbol'] = 'document_symbol';+  ['textDocument/workspaceSymbol'] = 'workspace_symbol';+  ['textDocument/prepareCallHierarchy'] = 'call_hierarchy';+  ['textDocument/rename'] = 'rename';+  ['textDocument/codeAction'] = 'code_action';+  ['workspace/executeCommand'] = 'execute_command';+  ['textDocument/references'] = 'find_references';+  ['textDocument/rangeFormatting'] = 'document_range_formatting';+  ['textDocument/formatting'] = 'document_formatting';+  ['textDocument/completion'] = 'completion';+  ['textDocument/documentHighlight'] = 'document_highlight';+}+ -- TODO improve handling of scratch buffers with LSP attached.  local function err_message(...)   nvim_err_writeln(table.concat(vim.tbl_flatten{...}))   nvim_command(""redraw"") end +local function unsupported_method(method)+  local msg = string.format(""server doesn't support '%s'"", method)","With this change, this is only being called if none of the servers support the method. Should we list all servers?I've updated the message to be more explicit, let me know if that's too verbose.",
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/12764,499103447,2020-10-03T01:29:50Z,runtime/lua/vim/lsp/buf.lua,"@@ -141,7 +142,7 @@ end --- Renames all references to the symbol under the cursor. If {new_name} is not --- provided, the user will be prompted for a new name using |input()|. function M.rename(new_name)-  -- TODO(ashkan) use prepareRename+ -- TODO(ashkan) use prepareRename",my bad. fixed,
108725,fsouza,https://api.github.com/repos/neovim/neovim/pulls/12764,499103590,2020-10-03T01:31:20Z,runtime/lua/vim/lsp.lua,"@@ -25,13 +25,40 @@ local lsp = {   -- format_rpc_error = lsp_rpc.format_rpc_error; } +-- maps request name to the required resolved_capability in the client.+local req_to_capability = {","not sure if I follow the comment, sorry about that. Do you mean introducing some shared variables for the method names or something like that? Or if the protocol itself already declares that dependency-mapping? Or something else? x)",
125701,pwntester,https://api.github.com/repos/neovim/neovim/pulls/13051,499887631,2020-10-05T21:39:56Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -89,6 +92,8 @@ M['textDocument/publishDiagnostics'] = function(_, _, result)   -- In particular, this stops a ton of spam when first starting a server for current   -- unloaded buffers.   if not api.nvim_buf_is_loaded(bufnr) then+    -- since buffer was loaded by uri_to_bufnr, wipe it out to leave a clean buffer list+    vim.cmd(string.format('%dbw!', bufnr))","yep, the first line only prevents buffers with no diagnostics from being loaded. this other line closes the ones that were not loaded by the user (`nvim_buf_is_loaded`). So for example, given the above configuration for Sumneko, all your lua config files and all lua files in `VIMRUNTIME/lua` are processed, many will have no diagnostics and will make the callback return on the new first line. But other will have diagnostics and will be processed, remaining as loaded unlisted buffers. The point is, if the user opens a single lua file, why should it have dozens of unlisted buffers of non-related files just because they have some diagnostics and happened to be processed by sumneko. I use a different LSP server with similar behavior. All the ones using LSP workspaces (similar to VisualCode ones), will suffer from this, since the LSP server will process all the files in the workspace and nvim will add a buffer for all of them containing diagnostics.You can try it on your own. Open a single lua file and then do `ls!`",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/13059,500226447,2020-10-06T12:15:01Z,runtime/lua/vim/treesitter/query.lua,"@@ -8,6 +8,102 @@ Query.__index = Query  local M = {} +-- Some treesitter grammars extend others.+-- We can use that to import the queries of the base language+local base_language_map = {}++-- Filter the runtime query files, the spec is like regular runtime files but in the new `queries`+-- diretory. They resemble ftplugins, that is that you can override queries by adding things in the+-- `queries` directory, and extend using the `after/queries` directory.+local function filter_files(file_list)+  local main = {}+  local after = {}++  for _, fname in ipairs(file_list) do+    -- Only get the name of the directory containing the queries directory+    if vim.fn.fnamemodify(fname, "":p:h:h:h:t"") == ""after"" then+      table.insert(after, fname)+    -- The first one is the one with most priority+    elseif #main == 0 then+      main = { fname }+    end+  end++  vim.list_extend(main, after)++  return main+end++local function runtime_query_path(lang, query_name)+  return string.format('queries/%s/%s.scm', lang, query_name)+end++local function filtered_runtime_queries(lang, query_name)+  return filter_files(a.nvim_get_runtime_file(runtime_query_path(lang, query_name), true) or {})+end++local function get_query_files(lang, query_name)+  local query_files = {}++  local lang_files = filtered_runtime_queries(lang, query_name)+  vim.list_extend(query_files, lang_files)++  for _, base_lang in ipairs(base_language_map[lang] or {}) do+    local base_files = filtered_runtime_queries(base_lang, query_name)+    vim.list_extend(query_files, base_files)+  end++  return query_files+end++local function read_query_files(filenames)+  local contents = {}++  for _,filename in ipairs(filenames) do+    vim.list_extend(contents, vim.fn.readfile(filename))+  end++  return table.concat(contents, '\n')+end++--- Returns the runtime query {query_name} for {lang}.+--+-- @param lang The language to use for the query+-- @param query_name The name of the query (i.e. ""highlights"")+--+-- @return The corresponding query, parsed.+function M.get_query(lang, query_name)+  local query_files = get_query_files(lang, query_name)+  local query_string = read_query_files(query_files)++  if #query_string > 0 then+    return M.parse_query(lang, query_string)+  end+end++--- Adds an base language for a given language.+--+-- @param extension The extension language.+-- @param base The language to use as a base.+function M.add_base_language(extension, base)+  if not base_language_map[extension] then+    base_language_map[extension] = {}+  end",maybe add to the documentation how to create multiple base languages like we do for tsx e.g. in which order `add_base_language` should be called with the chain of base languages.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12593,501195561,2020-10-07T17:42:32Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,225 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+Watcher.__index = Watcher+local w = {}+local WatcherList = {}+local check_handle = nil++-- Callback for the check handle, checks if there are pending notifications+-- for any watcher, and handles them as per the value of the `fcnotify`+-- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    if watcher.pending_notifs == true then+      vim.api.nvim_command('checktime '..watcher.bufnr)+      watcher.pending_notifs = false+    end+  end+end++local function fs_event_start(bufnr)+  WatcherList[bufnr].handle = uv.new_fs_event()+  WatcherList[bufnr].handle:start(WatcherList[bufnr].ffname, {}, vim.schedule_wrap(function(...)+    WatcherList[bufnr]:on_change(...)+  end))+end++local function check_handle_start()+  check_handle = uv.new_check()+  check_handle:start(vim.schedule_wrap(check_notifications))+end++local function set_mechanism(option_type, bufnr)+  if option_type == 'global' then+    local option = vim.api.nvim_get_option('filechangenotify')+    if option:find('watcher') then+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = fs_event_start+      end+      Watcher.start_notifications = check_handle_start+    else+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = function(_) end+      end+      Watcher.start_notifications = function(_) end+    end+  elseif option_type == 'local' then+    bufnr = bufnr or vim.api.nvim_get_current_buf()+    local status, option = pcall(vim.api.nvim_buf_get_option, bufnr, 'filechangenotify')+    if not status then+      option = vim.api.nvim_get_option('filechangenotify')+    end+    if option:find('watcher') then+      WatcherList[bufnr]._start_handle = fs_event_start+      Watcher.start_notifications = check_handle_start+    else+      WatcherList[bufnr]._start_handle = function(_) end+    end+  end+  Watcher.stop_notifications()+  Watcher.start_notifications()+end++-- Checks if a buffer should have a watcher attached to it.+local function valid_buf(bufnr)+  if bufnr < 0 then+    return false+  end++  local fname = vim.api.nvim_buf_get_name(bufnr)+  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')+  local buftype = vim.api.nvim_buf_get_option(bufnr, 'buftype')++  if not buflisted or buftype == 'nofile' or buftype == 'quickfix'+    or not fname then+    return false+  end+  return true","You change just return the condition, rather than doing an if statement here.`return buflisted or ...`",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/12593,501195958,2020-10-07T17:43:10Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,225 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+Watcher.__index = Watcher+local w = {}+local WatcherList = {}+local check_handle = nil++-- Callback for the check handle, checks if there are pending notifications+-- for any watcher, and handles them as per the value of the `fcnotify`+-- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    if watcher.pending_notifs == true then+      vim.api.nvim_command('checktime '..watcher.bufnr)+      watcher.pending_notifs = false+    end+  end+end++local function fs_event_start(bufnr)+  WatcherList[bufnr].handle = uv.new_fs_event()+  WatcherList[bufnr].handle:start(WatcherList[bufnr].ffname, {}, vim.schedule_wrap(function(...)+    WatcherList[bufnr]:on_change(...)+  end))+end++local function check_handle_start()+  check_handle = uv.new_check()+  check_handle:start(vim.schedule_wrap(check_notifications))+end++local function set_mechanism(option_type, bufnr)+  if option_type == 'global' then+    local option = vim.api.nvim_get_option('filechangenotify')+    if option:find('watcher') then+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = fs_event_start+      end+      Watcher.start_notifications = check_handle_start+    else+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = function(_) end+      end+      Watcher.start_notifications = function(_) end+    end+  elseif option_type == 'local' then+    bufnr = bufnr or vim.api.nvim_get_current_buf()+    local status, option = pcall(vim.api.nvim_buf_get_option, bufnr, 'filechangenotify')+    if not status then+      option = vim.api.nvim_get_option('filechangenotify')+    end+    if option:find('watcher') then+      WatcherList[bufnr]._start_handle = fs_event_start+      Watcher.start_notifications = check_handle_start+    else+      WatcherList[bufnr]._start_handle = function(_) end+    end+  end+  Watcher.stop_notifications()+  Watcher.start_notifications()+end++-- Checks if a buffer should have a watcher attached to it.+local function valid_buf(bufnr)+  if bufnr < 0 then+    return false+  end++  local fname = vim.api.nvim_buf_get_name(bufnr)+  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')+  local buftype = vim.api.nvim_buf_get_option(bufnr, 'buftype')++  if not buflisted or buftype == 'nofile' or buftype == 'quickfix'+    or not fname then+    return false+  end+  return true+end++--- Creates and initializes a new watcher object with the given filename.+---+--@param bufnr: (required, number) The buffer number of the buffer that+--- is to be watched.+function Watcher:new(bufnr)+  vim.validate{bufnr = {bufnr, 'number', false}}+  -- get full path name for the file+  local fname = vim.api.nvim_buf_get_name(bufnr)+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {bufnr = bufnr, fname = fname, ffname = ffname,","why keep `fname` and `ffname`.Also, I think `ffname` would be better as `filepath` or similar (to say it's the whole path)",
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,501472198,2020-10-08T06:17:42Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,225 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+Watcher.__index = Watcher+local w = {}+local WatcherList = {}+local check_handle = nil++-- Callback for the check handle, checks if there are pending notifications+-- for any watcher, and handles them as per the value of the `fcnotify`+-- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    if watcher.pending_notifs == true then+      vim.api.nvim_command('checktime '..watcher.bufnr)+      watcher.pending_notifs = false+    end+  end+end++local function fs_event_start(bufnr)+  WatcherList[bufnr].handle = uv.new_fs_event()+  WatcherList[bufnr].handle:start(WatcherList[bufnr].ffname, {}, vim.schedule_wrap(function(...)+    WatcherList[bufnr]:on_change(...)+  end))+end++local function check_handle_start()+  check_handle = uv.new_check()+  check_handle:start(vim.schedule_wrap(check_notifications))+end++local function set_mechanism(option_type, bufnr)+  if option_type == 'global' then+    local option = vim.api.nvim_get_option('filechangenotify')+    if option:find('watcher') then",`fcnotify` became a comma separated list of strings :),
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,501475718,2020-10-08T06:26:54Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,225 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+Watcher.__index = Watcher+local w = {}+local WatcherList = {}+local check_handle = nil++-- Callback for the check handle, checks if there are pending notifications+-- for any watcher, and handles them as per the value of the `fcnotify`+-- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    if watcher.pending_notifs == true then+      vim.api.nvim_command('checktime '..watcher.bufnr)+      watcher.pending_notifs = false+    end+  end+end++local function fs_event_start(bufnr)+  WatcherList[bufnr].handle = uv.new_fs_event()+  WatcherList[bufnr].handle:start(WatcherList[bufnr].ffname, {}, vim.schedule_wrap(function(...)+    WatcherList[bufnr]:on_change(...)+  end))+end++local function check_handle_start()+  check_handle = uv.new_check()+  check_handle:start(vim.schedule_wrap(check_notifications))+end++local function set_mechanism(option_type, bufnr)+  if option_type == 'global' then+    local option = vim.api.nvim_get_option('filechangenotify')+    if option:find('watcher') then+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = fs_event_start+      end+      Watcher.start_notifications = check_handle_start+    else+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = function(_) end+      end+      Watcher.start_notifications = function(_) end+    end+  elseif option_type == 'local' then+    bufnr = bufnr or vim.api.nvim_get_current_buf()+    local status, option = pcall(vim.api.nvim_buf_get_option, bufnr, 'filechangenotify')+    if not status then+      option = vim.api.nvim_get_option('filechangenotify')+    end+    if option:find('watcher') then+      WatcherList[bufnr]._start_handle = fs_event_start+      Watcher.start_notifications = check_handle_start+    else+      WatcherList[bufnr]._start_handle = function(_) end+    end+  end+  Watcher.stop_notifications()+  Watcher.start_notifications()+end++-- Checks if a buffer should have a watcher attached to it.+local function valid_buf(bufnr)+  if bufnr < 0 then+    return false+  end++  local fname = vim.api.nvim_buf_get_name(bufnr)+  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')+  local buftype = vim.api.nvim_buf_get_option(bufnr, 'buftype')++  if not buflisted or buftype == 'nofile' or buftype == 'quickfix'+    or not fname then+    return false+  end+  return true+end++--- Creates and initializes a new watcher object with the given filename.+---+--@param bufnr: (required, number) The buffer number of the buffer that+--- is to be watched.+function Watcher:new(bufnr)+  vim.validate{bufnr = {bufnr, 'number', false}}+  -- get full path name for the file+  local fname = vim.api.nvim_buf_get_name(bufnr)+  local ffname = vim.api.nvim_call_function('fnamemodify', {fname, ':p'})+  w = {bufnr = bufnr, fname = fname, ffname = ffname,","That's something I read in `fileio.c`. I think it stands for ""full fname""? Don't know for sure though. Just wanted to keep similar names everywhere. ",
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,504424408,2020-10-14T06:11:28Z,runtime/lua/vim/fcnotify.lua,"@@ -0,0 +1,225 @@+-- Create a file watcher, each watcher is identified by the name of the file that it+-- watches.++local uv = vim.loop+local Watcher = {}+Watcher.__index = Watcher+local w = {}+local WatcherList = {}+local check_handle = nil++-- Callback for the check handle, checks if there are pending notifications+-- for any watcher, and handles them as per the value of the `fcnotify`+-- option.+local function check_notifications()+  for _, watcher in pairs(WatcherList) do+    if watcher.pending_notifs == true then+      vim.api.nvim_command('checktime '..watcher.bufnr)+      watcher.pending_notifs = false+    end+  end+end++local function fs_event_start(bufnr)+  WatcherList[bufnr].handle = uv.new_fs_event()+  WatcherList[bufnr].handle:start(WatcherList[bufnr].ffname, {}, vim.schedule_wrap(function(...)+    WatcherList[bufnr]:on_change(...)+  end))+end++local function check_handle_start()+  check_handle = uv.new_check()+  check_handle:start(vim.schedule_wrap(check_notifications))+end++local function set_mechanism(option_type, bufnr)+  if option_type == 'global' then+    local option = vim.api.nvim_get_option('filechangenotify')+    if option:find('watcher') then+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = fs_event_start+      end+      Watcher.start_notifications = check_handle_start+    else+      for _, watcher in pairs(WatcherList) do+        watcher._start_handle = function(_) end+      end+      Watcher.start_notifications = function(_) end+    end+  elseif option_type == 'local' then+    bufnr = bufnr or vim.api.nvim_get_current_buf()+    local status, option = pcall(vim.api.nvim_buf_get_option, bufnr, 'filechangenotify')+    if not status then+      option = vim.api.nvim_get_option('filechangenotify')+    end+    if option:find('watcher') then+      WatcherList[bufnr]._start_handle = fs_event_start+      Watcher.start_notifications = check_handle_start+    else+      WatcherList[bufnr]._start_handle = function(_) end+    end+  end+  Watcher.stop_notifications()+  Watcher.start_notifications()+end++-- Checks if a buffer should have a watcher attached to it.+local function valid_buf(bufnr)+  if bufnr < 0 then+    return false+  end++  local fname = vim.api.nvim_buf_get_name(bufnr)+  local buflisted = vim.api.nvim_buf_get_option(bufnr, 'buflisted')+  local buftype = vim.api.nvim_buf_get_option(bufnr, 'buftype')++  if not buflisted or buftype == 'nofile' or buftype == 'quickfix'",I don't think `prompt` is a separate buftype. (`:h buftype` doesn't list it.) I've changed it to only accept 'acwrite' and normal buffers.,
16873158,skippi,https://api.github.com/repos/neovim/neovim/pulls/13116,507512622,2020-10-19T06:55:27Z,src/nvim/generators/gen_options.lua,"@@ -144,6 +144,9 @@ local dump_option = function(i, o)   if o.enable_if then     w('#endif')   end+  if o.enable_if then","Without these changes, ASAN errors around [here](https://github.com/skippi/neovim/blob/a266d9ec92e0e8d809f73539034873466fd98ce6/src/nvim/option.c#L1025). To the best of my ability, I added these changes in merit of matching the option codegen as closely as possible.  If there's a better workaround, I'm all hands.",
16873158,skippi,https://api.github.com/repos/neovim/neovim/pulls/13116,507517395,2020-10-19T07:06:17Z,runtime/doc/options.txt,"@@ -1386,6 +1386,21 @@ A jump table for the options with a short description can be found at |Q_op|. 	This option cannot be set from a |modeline| or in the |sandbox|, for 	security reasons. +						*'completeslash'* *'csl'*+'completeslash' 'csl'	string	(default: """")+			local to buffer+			{not in Vi}  {only for MS-Windows}","For what it's worth, the rest of the options list ""Windows"" instead of ""MS-Windows"". Is there a precedent for fixing these sorts of things when porting patches?",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/13051,510379172,2020-10-22T18:42:22Z,runtime/lua/vim/lsp/callbacks.lua,"@@ -89,6 +92,8 @@ M['textDocument/publishDiagnostics'] = function(_, _, result)   -- In particular, this stops a ton of spam when first starting a server for current   -- unloaded buffers.   if not api.nvim_buf_is_loaded(bufnr) then+    -- since buffer was loaded by uri_to_bufnr, wipe it out to leave a clean buffer list+    vim.cmd(string.format('%dbw!', bufnr))","If you wait one or two days, we can use the new API in https://github.com/neovim/neovim/pull/13077 :) However, I'm not 100% confident that we actually want to do this... especially given something like this: https://github.com/neovim/neovim/pull/13103 which I think we should merge.Perhaps a better change would be in vim.uri_to_bufnr, perhaps we can do something else instead of using `vim.fn.bufadd`. Maybe a better option would be adding a new `nvim_add_buf`...? And we could make it so that we don't add that buffer to the buflist when we create it? I'm not 100% sure.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13116,511272315,2020-10-24T02:47:21Z,src/nvim/generators/gen_options.lua,"@@ -144,6 +144,9 @@ local dump_option = function(i, o)   if o.enable_if then     w('#endif')   end+  if o.enable_if then",Your fix is correct. `gen_options.lua` is not doing enough to handle the cases when `enable_if` is defined. I see what I can do to reduce `enable_if` and add default values for for struct members in `#else`.Ideal case is that adding the condition from  `enable_if` is done once.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13117,511484578,2020-10-24T15:35:34Z,src/nvim/buffer_defs.h,"@@ -1204,6 +1204,9 @@ struct window_S {   colnr_T w_skipcol;                // starting column when a single line                                     // doesn't fit in the window +  linenr_T w_last_topline;          ///< last known value for topline",it would surprise me if these vars actually are needed. the condition for `win_viewport` should be more or less the same.,
73424763,taylan97,https://api.github.com/repos/neovim/neovim/pulls/13164,512342561,2020-10-27T00:13:57Z,runtime/doc/lua.txt,"@@ -968,16 +968,35 @@ paste({lines}, {phase})                                          *vim.paste()*                     |paste|  schedule_wrap({cb})                                      *vim.schedule_wrap()*-                Defers callback `cb` until the Nvim API is safe to call.+                Wraps callback `cb` in a function which will defer the execution+                of `cb` until the Nvim API is safe to call.++                The user must call the returned function themselves if it is not+                being used as an argument to a function that will call it for them,+                such as `vim.fn_defer`.++                Example: Using as an argument >++                 local safe = vim.schedule_wrap(function()+		   vim.api.nvim_command('echomsg ""test""')+                 end)+                 vim.defer_fn(safe, 100)++                Example: Using on it's own >","I followed the capitalization example from other examples,https://github.com/taylan97/neovim/blob/959349b688c282bbead31067d62507d63d1732e6/runtime/doc/lua.txt#L498https://github.com/taylan97/neovim/blob/959349b688c282bbead31067d62507d63d1732e6/runtime/doc/lua.txt#L942Though others do not capitalize after the colon,https://github.com/taylan97/neovim/blob/959349b688c282bbead31067d62507d63d1732e6/runtime/doc/lua.txt#L480For datas sake, more examples start with a capital than do not.```~/neovim/runtime/doc $ rg --no-heading ""Example: [A-Z]"" | wc -l26 (-3, three of these are ""TCP"", ""ISO"" and ""UTF"")~/neovim/runtime/doc $ rg --no-heading ""Example: [a-z]"" | wc -l17```(do not fret about the lack of examples, there are 456 examples that simply read  ""Example: >"")I do not say this to be pedantic to ""win the argument"", only to point out perhaps another potential (very minor) doc style fault (can open another pull request but maybe it would conflict too much with upstream vim I don't know how that works).I will alter it to be lower cased, most online rules seem to say this is most accepted as ""correct, or at least 'not incorrect'"".",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13167,515443969,2020-10-31T02:16:49Z,src/nvim/buffer.c,"@@ -3540,14 +3534,45 @@ int build_stl_str_hl(   // Proceed character by character through the statusline format string   // fmt_p is the current positon in the input buffer   for (char_u *fmt_p = usefmt; *fmt_p; ) {-    if (curitem == STL_MAX_ITEM) {-      // There are too many items.  Add the error code to the statusline-      // to give the user a hint about what went wrong.-      if (out_p + 5 < out_end_p) {-        memmove(out_p, "" E541"", (size_t)5);-        out_p += 5;-      }-      break;+    if (curitem == (int)stl_items_len) {+        size_t new_len = stl_items_len * 3 / 2;++        stl_item_t *new_items =+          xrealloc(stl_items, sizeof(stl_item_t) * new_len);+        if (new_items == NULL) {+          break;+        }+        stl_items = new_items;++        int *new_groupitems =",Are these temporary variables for `NULL` checks only?,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13182,516418179,2020-11-03T04:05:55Z,src/nvim/vim.h,"@@ -316,8 +316,60 @@ enum { FOLD_TEXT_LEN = 51 };  //!< buffer size for get_foldtext() #define LOWEST_WIN_ID 1000  // BSD is supposed to cover FreeBSD and similar systems.-#if (defined(BSD) || defined(__FreeBSD_kernel__)) && defined(S_ISCHR)-# define OPEN_CHR_FILES+#if (defined(BSD) || defined(__FreeBSD_kernel__)) \+    && (defined(S_ISCHR) || defined(S_IFCHR))+#define OPEN_CHR_FILES+#endif++// stat macros+#ifndef S_ISDIR",These were previously defined in `src/nvim/os/os_defs.h` but moved to `src/nvim/os/win_defs.h` in  07265d22. That was a mistake. Move these ifndefs to `os_defs.h` and remove the duplicates in `win_defs.h`.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/13164,519264537,2020-11-08T06:46:24Z,runtime/doc/lua.txt,"@@ -968,16 +968,35 @@ paste({lines}, {phase})                                          *vim.paste()*                     |paste|  schedule_wrap({cb})                                      *vim.schedule_wrap()*-                Defers callback `cb` until the Nvim API is safe to call.+                Wraps callback `cb` in a function which will defer the execution+                of `cb` until the Nvim API is safe to call.++                The user must call the returned function themselves if it is not+                being used as an argument to a function that will call it for them,+                such as |nvim_buf_attach()|.","I think you could say something more along the lines of: ""{cb} is not called after being wrapped. To automatically call, use |vim.schedule()|""Or something like that?I think this is too wordy.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13205,519631608,2020-11-09T08:34:29Z,src/nvim/buffer.c,"@@ -97,6 +97,13 @@ typedef enum {   kBffInitChangedtick = 2, } BufFreeFlags; +/// Allocate new buf structure and initialize it.+buf_T *buf_alloc(void) {+  buf_T *buf = xcalloc(1, sizeof(buf_T));+  buf->b_changed_notified = true;",This should just be below `buf->b_signcols_max = -1;` in `buflist_new` ( a bit weirdly named function but it is already the only entry point for allocating buffers.),
1423607,romgrk,https://api.github.com/repos/neovim/neovim/pulls/12995,519726734,2020-11-09T11:07:40Z,src/nvim/search.c,"@@ -5106,3 +5106,527 @@ bool search_was_last_used(void) {   return last_idx == 0; }+++// Fuzzy string matching+//+// Ported from the lib_fts library authored by Forrest Smith.+// https://github.com/forrestthewoods/lib_fts/tree/master/code+//+// Blog describing the algorithm:+// https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/+//+// Each matching string is assigned a score. The following factors are checked:+//   Matched letter+//   Unmatched letter+//   Consecutively matched letters+//   Proximity to start+//   Letter following a separator (space, underscore)+//   Uppercase letter following lowercase (aka CamelCase)+//+// Matched letters are good. Unmatched letters are bad. Matching near the start+// is good. Matching the first letter in the middle of a phrase is good.+// Matching the uppercase letters in camel case entries is good.+//+// The score assigned for each factor is explained below.+// File paths are different from file names. File extensions may be ignorable.+// Single words care about consecutive matches but not separators or camel+// case.+//   Score starts at 0+//   Matched letter: +0 points+//   Unmatched letter: -1 point+//   Consecutive match bonus: +5 points+//   Separator bonus: +10 points+//   Camel case bonus: +10 points+//   Unmatched leading letter: -3 points (max: -9)+//+// There is some nuance to this. Scores don���t have an intrinsic meaning. The+// score range isn���t 0 to 100. It���s roughly [-50, 50]. Longer words have a+// lower minimum score due to unmatched letter penalty. Longer search patterns+// have a higher maximum score due to match bonuses.+//+// Separator and camel case bonus is worth a LOT. Consecutive matches are worth+// quite a bit.+//+// There is a penalty if you DON���T match the first three letters. Which+// effectively rewards matching near the start. However there���s no difference+// in matching between the middle and end.+//+// There is not an explicit bonus for an exact match. Unmatched letters receive+// a penalty. So shorter strings and closer matches are worth more.++typedef struct+{+    listitem_T *item;+    int score;+    list_T *lmatchpos;+} fuzzyItem_T;++// bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that+// matching a whole word is preferred.+#define SEQUENTIAL_BONUS 40+// bonus if match occurs after a separator+#define SEPARATOR_BONUS 30+// bonus if match is uppercase and prev is lower+#define CAMEL_BONUS 30+// bonus if the first letter is matched+#define FIRST_LETTER_BONUS 15+// penalty applied for every letter in str before the first match+#define LEADING_LETTER_PENALTY -5+// maximum penalty for leading letters+#define MAX_LEADING_LETTER_PENALTY -15+// penalty for every letter that doesn't match+#define UNMATCHED_LETTER_PENALTY -1+// Score for a string that doesn't fuzzy match the pattern+#define SCORE_NONE -9999++#define FUZZY_MATCH_RECURSION_LIMIT 10+// Maximum number of characters that can be fuzzy matched+#define MAXMATCHES 256++// compute a score for a fuzzy matched string. the matching character locations+// are in 'matches'.+static int fuzzy_match_compute_score(+    char *str,+    int strsize,+    matchidx_T *matches,+    int nummatches)+{+  int score;+  int penalty;+  int unmatched;+  int i;+  char *const p = str;+  matchidx_T sidx = 0;++  // initialize score+  score = 100;++  // apply leading letter penalty+  penalty = LEADING_LETTER_PENALTY * matches[0];+  if (penalty < MAX_LEADING_LETTER_PENALTY) {+    penalty = MAX_LEADING_LETTER_PENALTY;+  }+  score += penalty;++  // apply unmatched penalty+  unmatched = strsize - nummatches;+  score += UNMATCHED_LETTER_PENALTY * unmatched;++  // apply ordering bonuses+  for (i = 0; i < nummatches; i++) {+    matchidx_T curridx = matches[i];++    if (i > 0) {+      matchidx_T previdx = matches[i - 1];++      // sequential+      if (curridx == (previdx + 1)) {+        score += SEQUENTIAL_BONUS;+      }+    }++    // check for bonuses based on neighbor character value+    if (curridx > 0) {+      // camel case+      int neighbor;+      int curr;+      int neighborseparator;++      while (sidx < curridx) {+        neighbor = (*utf_ptr2char)((char_u *const)p);+        (void)mb_ptr2char_adv((const char_u **const)&p);+        sidx++;+      }+      curr = (*utf_ptr2char)((char_u *const)p);++      if (mb_islower(neighbor) && mb_isupper(curr)) {+        score += CAMEL_BONUS;+      }++      // separator+      neighborseparator = neighbor == '_' || neighbor == ' ';+      if (neighborseparator) {+        score += SEPARATOR_BONUS;+      }+    } else {+      // first letter+      score += FIRST_LETTER_BONUS;+    }+  }+  return score;+}++static bool fuzzy_match_recursive(+    char *fuzpat,+    char *str,+    matchidx_T strIdx,+    int *outScore,+    char *strBegin,+    int strLen,+    matchidx_T *srcMatches,+    matchidx_T *matches,+    int maxMatches,+    int nextMatch,+    int *recursionCount)+{+  // Recursion params+  bool recursiveMatch = false;+  matchidx_T bestRecursiveMatches[MAXMATCHES];+  int bestRecursiveScore = 0;+  bool first_match;+  bool matched;++  // Count recursions+  (*recursionCount)++;+  if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT) {+    return false;+  }++  // Detect end of strings+  if (*fuzpat == NUL || *str == NUL) {+    return false;+  }++  // Loop through fuzpat and str looking for a match+  first_match = true;+  while (*fuzpat != NUL && *str != NUL) {+    int c1;+    int c2;++    c1 = utf_ptr2char((char_u *const)fuzpat);+    c2 = utf_ptr2char((char_u *const)str);++    // Found match+    if (mb_tolower(c1) == mb_tolower(c2)) {+      matchidx_T recursiveMatches[MAXMATCHES];+      int recursiveScore = 0;+      char *next_char;++      // Supplied matches buffer was too short+      if (nextMatch >= maxMatches) {+        return true;+      }++      // ""Copy-on-Write"" srcMatches into matches+      if (first_match && srcMatches) {+        memcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));+        first_match = false;+      }++      // Recursive call that ""skips"" this match+      next_char = str + (*utf_ptr2len)((char_u *const)str);++      if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,+                                &recursiveScore, strBegin, strLen, matches,+                                recursiveMatches,+                                sizeof(recursiveMatches)+                                / sizeof(recursiveMatches[0]),+                                nextMatch, recursionCount)) {+        // Pick best recursive score+        if (!recursiveMatch || recursiveScore > bestRecursiveScore) {+          memcpy(bestRecursiveMatches, recursiveMatches,+                 MAXMATCHES * sizeof(recursiveMatches[0]));+          bestRecursiveScore = recursiveScore;+        }+        recursiveMatch = true;+      }++      // Advance+      matches[nextMatch++] = strIdx;+      (void)mb_ptr2char_adv((const char_u **const)&fuzpat);+    }+    (void)mb_ptr2char_adv((const char_u **const)&str);+  }++  // Determine if full fuzpat was matched+  matched = *fuzpat == NUL ? true : false;++  // Calculate score+  if (matched) {+    *outScore = fuzzy_match_compute_score(strBegin, strLen, matches,+                                          nextMatch);+  }++  // Return best result+  if (recursiveMatch && (!matched || bestRecursiveScore > *outScore)) {+    // Recursive score is better than ""this""+    memcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));+    *outScore = bestRecursiveScore;+    return true;+  } else if (matched) {+    return true;  // ""this"" score is better than recursive+  }++  return false;  // no match+}++// fuzzy_match()+//+// Performs exhaustive search via recursion to find all possible matches and+// match with highest score.+// Scores values have no intrinsic meaning.  Possible score range is not+// normalized and varies with pattern.+// Recursion is limited internally (default=10) to prevent degenerate cases+// (fuzpat=""aaaaaa"" str=""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"").+// Uses char_u for match indices. Therefore patterns are limited to MAXMATCHES+// characters.+//+// Returns true if 'fuzpat' matches 'str'. Also returns the match score in+// 'outScore' and the matching character positions in 'matches'.+static int fuzzy_match(+    char *str,+    char *fuzpat,+    int *outScore,+    matchidx_T *matches,+    int maxMatches)+{+  int recursionCount = 0;+  int len = utf_char2len(*str);++  *outScore = 0;++  return fuzzy_match_recursive(+      fuzpat, str, 0, outScore, str, len, NULL,+      matches, maxMatches, 0, &recursionCount);+}++// Sort the fuzzy matches in the descending order of the match score.+static int fuzzy_item_compare(const void *s1, const void *s2)+{+  int v1 = ((fuzzyItem_T *)s1)->score;+  int v2 = ((fuzzyItem_T *)s2)->score;++  return v1 == v2 ? 0 : v1 > v2 ? -1 : 1;+}++// Fuzzy search the string 'str' in a list of 'items' and return the matching+// strings in 'fmatchlist'.+// If 'items' is a list of strings, then search for 'str' in the list.+// If 'items' is a list of dicts, then either use 'key' to lookup the string+// for each item or use 'item_cb' Funcref function to get the string.+// If 'retmatchpos' is true, then return a list of positions where 'str'+// matches for each item.+static void match_fuzzy(+    list_T *items,+    char *str,+    char *key,+    Callback *item_cb,+    int retmatchpos,+    list_T *fmatchlist)+{+  long len;+  fuzzyItem_T *ptrs;+  long i = 0;+  bool found_match = false;+  matchidx_T matches[MAXMATCHES];++  len = tv_list_len(items);+  if (len == 0) {+    return;+  }++  ptrs = xcalloc(sizeof(fuzzyItem_T), len);+  if (ptrs == NULL) {+    return;+  }++  // For all the string items in items, get the fuzzy matching score+  TV_LIST_ITER(items, li, {+    int score;+    char *itemstr;+    typval_T rettv;+    typval_T *tv_li = TV_LIST_ITEM_TV(li);++    ptrs[i].item = li;+    ptrs[i].score = SCORE_NONE;+    itemstr = NULL;+    rettv.v_type = VAR_UNKNOWN;++    if (tv_check_str(tv_li)) {  // list of strings+      itemstr = (char *)tv_li->vval.v_string;+    } else if (tv_is_dict(*tv_li) && key != NULL) {+      // For a dict, either use the specified key to lookup the string or+      // use the specified callback function to get the string.+      if (key != NULL) {+        itemstr = tv_dict_get_string(tv_li->vval.v_dict,+                                     key, false);+      } else {+        typval_T argv[2];++        // Invoke the supplied callback (if any) to get the dict item+        tv_li->vval.v_dict->dv_refcount++;+        argv[0].v_type = VAR_DICT;+        argv[0].vval.v_dict = tv_li->vval.v_dict;+        argv[1].v_type = VAR_UNKNOWN;+        if (callback_call(item_cb, 1, argv, &rettv)) {+          if (rettv.v_type == VAR_STRING) {+            itemstr = (char *)tv_get_string(&rettv);+          }+        }+        tv_dict_unref(tv_li->vval.v_dict);+      }+    }++    if (itemstr != NULL+        && fuzzy_match(itemstr, str, &score, matches,+                       sizeof(matches) / sizeof(matches[0]))) {+      // Copy the list of matching positions in itemstr to a list, if+      // 'retmatchpos' is set.+      if (retmatchpos) {+        int j;+        int strsz;++        ptrs[i].lmatchpos = tv_list_alloc(kListLenMayKnow);+        if (ptrs[i].lmatchpos == NULL) {+          goto done;+        }+        strsz = MB_CHARLEN((char_u *)str);+        for (j = 0; j < strsz; j++) {+          tv_list_append_number(ptrs[i].lmatchpos, matches[j]);+        }+      }+      ptrs[i].score = score;+      found_match = true;+    }+    i++;+    tv_clear(&rettv);+  });++  if (found_match) {+    typval_T *tv_li;+    list_T *l;+    listitem_T *li;++    // Sort the list by the descending order of the match score+    qsort((void *)ptrs, (size_t)len, sizeof(fuzzyItem_T), fuzzy_item_compare);++    // For matchfuzzy(), return a list of matched strings.+    //    ['str1', 'str2', 'str3']+    // For matchfuzzypos(), return a list with two items.+    // The first item is a list of matched strings. The second item+    // is a list of lists where each list item is a list of matched+    // character positions.+    //    [['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]+    if (retmatchpos) {+      li = tv_list_find(fmatchlist, 0);+      tv_li = TV_LIST_ITEM_TV(li);+      if (li == NULL || tv_li->vval.v_list == NULL) {+        goto done;+      }+      l = tv_li->vval.v_list;+    } else {+      l = fmatchlist;+    }++    // Copy the matching strings with a valid score to the return list+    for (i = 0; i < len; i++) {+      if (ptrs[i].score == SCORE_NONE) {+        break;+      }+      tv_list_append_tv(l, TV_LIST_ITEM_TV(ptrs[i].item));+    }++    // next copy the list of matching positions+    if (retmatchpos) {+      li = tv_list_find(fmatchlist, -1);+      tv_li = TV_LIST_ITEM_TV(li);+      if (li == NULL || tv_li->vval.v_list == NULL) {+        goto done;+      }+      l = tv_li->vval.v_list;++      for (i = 0; i < len; i++) {+        if (ptrs[i].score == SCORE_NONE) {+          break;+        }+        if (ptrs[i].lmatchpos != NULL) {+          tv_list_append_list(l, ptrs[i].lmatchpos);+        }+      }+    }+  }++done:+  xfree(ptrs);+}++// Do fuzzy matching. Returns the list of matched strings in 'rettv'.+// If 'retmatchpos' is TRUE, also returns the matching character positions.+void do_fuzzymatch(typval_T *argvars, typval_T *rettv, int retmatchpos)+{+  Callback cb = CALLBACK_NONE;+  char *key = NULL;++  // validate and get the arguments+  if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL) {+    EMSG2(_(e_listreq), retmatchpos ? ""matchfuzzypos()"" : ""matchfuzzy()"");+    return;+  }+  if (argvars[1].v_type != VAR_STRING+      || argvars[1].vval.v_string == NULL) {+    EMSG2(_(e_invarg2), tv_get_string(&argvars[1]));+    return;+  }++  if (argvars[2].v_type != VAR_UNKNOWN) {+    dict_T *d;+    dictitem_T *di;++    if (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == NULL) {+      EMSG(_(e_dictreq));+      return;+    }++    // To search a dict, either a callback function or a key can be+    // specified.+    d = argvars[2].vval.v_dict;+    if ((di = tv_dict_find(d, ""key"", -1)) != NULL) {+      if (di->di_tv.v_type != VAR_STRING+          || di->di_tv.vval.v_string == NULL+          || *di->di_tv.vval.v_string == NUL) {+        EMSG2(_(e_invarg2), tv_get_string(&di->di_tv));+        return;+      }+      key = (char *)tv_get_string(&di->di_tv);+    } else if ((di = tv_dict_find(d, ""text_cb"", -1)) != NULL) {+      if (callback_from_typval(&cb, &di->di_tv)) {+        EMSG2(_(e_invargval), ""text_cb"");+        return;+      }+    }+  }++  // get the fuzzy matches+  tv_list_alloc_ret(rettv, kListLenMayKnow);++  if (retmatchpos) {+    list_T *l;++    // For matchfuzzypos(), a list with two items are returned. First item+    // is a list of matching strings and the second item is a list of+    // lists with matching positions within each string.+    l = tv_list_alloc(kListLenShouldKnow);+    if (l == NULL) {+      goto done;+    }++    tv_list_append_list(rettv->vval.v_list, l);++    l = tv_list_alloc(kListLenShouldKnow);+    if (l == NULL) {+      goto done;+    }++    tv_list_append_list(rettv->vval.v_list, l);+  }++  char buf[NUMBUFLEN];+  if (tv_get_string_buf_chk(&argvars[1], buf)) {",Source says that you must use the return value:https://github.com/neovim/neovim/blob/4e6f00dd29332ce549006e8df1b1392ed4209954/src/nvim/eval/typval.c#L2967-L2980,
12900252,lukas-reineke,https://api.github.com/repos/neovim/neovim/pulls/12655,521927575,2020-11-12T08:37:16Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -0,0 +1,1193 @@+local api = vim.api+local validate = vim.validate++local highlight = vim.highlight+local log = require('vim.lsp.log')+local protocol = require('vim.lsp.protocol')+local util = require('vim.lsp.util')++local if_nil = vim.F.if_nil++--@class DiagnosticSeverity+local DiagnosticSeverity = protocol.DiagnosticSeverity++local to_severity = function(severity)+  if not severity then return nil end+  return type(severity) == 'string' and DiagnosticSeverity[severity] or severity+end++local to_position = function(position, bufnr)+  vim.validate { position = {position, 't'} }++  return {+    position.line,+    util._get_line_byte_from_position(bufnr, position)+  }+end+++---@brief lsp-diagnostic+---+--@class Diagnostic+--@field range Range+--@field message string+--@field severity DiagnosticSeverity|nil+--@field code number | string+--@field source string+--@field tags DiagnosticTag[]+--@field relatedInformation DiagnosticRelatedInformation[]++local M = {}++-- Diagnostic Highlights {{{++-- TODO(tjdevries): Determine how to generate documentation for these+--                  and how to configure them to be easy for users.+--+--                  For now, just use the following script. It should work pretty good.+--[[+local levels = {""Error"", ""Warning"", ""Information"", ""Hint"" }++local all_info = {+  { ""Default"", ""Used as the base highlight group, other highlight groups link to"", },+  { ""VirtualText"", 'Used for ""%s"" diagnostic virtual text.\n  See |vim.lsp.diagnostic.set_virtual_text()|', },+  { ""Underline"", 'Used to underline ""%s"" diagnostics.\n  See |vim.lsp.diagnostic.set_underline()|', },+  { ""Floating"", 'Used to color ""%s"" diagnostic messages in diagnostics float.\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },+  { ""Sign"", 'Used for ""%s"" signs in sing column.\n  See |vim.lsp.diagnostic.set_signs()|', },+}++local results = {}+for _, info in ipairs(all_info) do+  for _, level in ipairs(levels) do+    local name = info[1]+    local description = info[2]+    local fullname = string.format(""Lsp%s%s"", name, level)+    table.insert(results, string.format(+      ""%78s"", string.format(""*hl-%s*"", fullname))+    )++    table.insert(results, fullname)+    table.insert(results, string.format(""  %s"", description))+    table.insert(results, """")+  end+end++-- print(table.concat(results, '\n'))+vim.fn.setreg(""*"", table.concat(results, '\n'))+--]]++local diagnostic_severities = {+  [DiagnosticSeverity.Error]       = { guifg = ""Red"" };+  [DiagnosticSeverity.Warning]     = { guifg = ""Orange"" };+  [DiagnosticSeverity.Information] = { guifg = ""LightBlue"" };+  [DiagnosticSeverity.Hint]        = { guifg = ""LightGrey"" };+}++-- Make a map from DiagnosticSeverity -> Highlight Name+local make_highlight_map = function(base_name)+  local result = {}+  for k, _ in pairs(diagnostic_severities) do+    result[k] = ""LspDiagnostics"" .. base_name .. DiagnosticSeverity[k]+  end++  return result+end++local default_highlight_map = make_highlight_map(""Default"")+local virtual_text_highlight_map = make_highlight_map(""VirtualText"")+local underline_highlight_map = make_highlight_map(""Underline"")+local floating_highlight_map = make_highlight_map(""Floating"")+local sign_highlight_map = make_highlight_map(""Sign"")++-- }}}+-- Diagnostic Namespaces {{{+local DEFAULT_CLIENT_ID = -1+local get_client_id = function(client_id)+  if client_id == nil then+    client_id = DEFAULT_CLIENT_ID+  end++  return client_id+end++local get_bufnr = function(bufnr)+  if not bufnr then+    return api.nvim_get_current_buf()+  elseif bufnr == 0 then+    return api.nvim_get_current_buf()+  end++  return bufnr+end+++--- Create a namespace table, used to track a client's buffer local items+local _make_namespace_table = function(namespace, api_namespace)+  vim.validate { namespace = { namespace, 's' } }++  return setmetatable({+    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)+  }, {+    __index = function(t, client_id)+      client_id = get_client_id(client_id)++      if rawget(t, client_id) == nil then+        local value = string.format(""%s:%s"", namespace, client_id)++        if api_namespace then+          value = api.nvim_create_namespace(value)+        end++        rawset(t, client_id, value)+      end++      return rawget(t, client_id)+    end+  })+end++local _diagnostic_namespaces = _make_namespace_table(""vim_lsp_diagnostics"", true)+local _sign_namespaces = _make_namespace_table(""vim_lsp_signs"", false)++--@private+function M._get_diagnostic_namespace(client_id)+  return _diagnostic_namespaces[client_id]+end++--@private+function M._get_sign_namespace(client_id)+  return _sign_namespaces[client_id]+end+-- }}}+-- Diagnostic Buffer & Client metatables {{{+local bufnr_and_client_cacher_mt = {+  __index = function(t, bufnr)+    if bufnr == 0 or bufnr == nil then+      bufnr = vim.api.nvim_get_current_buf()+    end++    if rawget(t, bufnr) == nil then+      rawset(t, bufnr, {})+    end++    return rawget(t, bufnr)+  end,++  __newindex = function(t, bufnr, v)+    if bufnr == 0 or bufnr == nil then+      bufnr = vim.api.nvim_get_current_buf()+    end++    rawset(t, bufnr, v)+  end,+}+-- }}}+-- Diagnostic Saving & Caching {{{+local _diagnostic_cleanup = setmetatable({}, bufnr_and_client_cacher_mt)+local diagnostic_cache = setmetatable({}, bufnr_and_client_cacher_mt)+local diagnostic_cache_lines = setmetatable({}, bufnr_and_client_cacher_mt)+local diagnostic_cache_counts = setmetatable({}, bufnr_and_client_cacher_mt)++local _bufs_waiting_to_update = setmetatable({}, bufnr_and_client_cacher_mt)++--- Store Diagnostic[] by line+---+---@param diagnostics Diagnostic[]+---@return table<number, Diagnostic[]>+local _diagnostic_lines = function(diagnostics)+  if not diagnostics then return end++  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local start = diagnostic.range.start+    local line_diagnostics = diagnostics_by_line[start.line]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[start.line] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++--- Get the count of M by Severity+---+---@param diagnostics Diagnostic[]+---@return table<DiagnosticSeverity, number>+local _diagnostic_counts = function(diagnostics)+  if not diagnostics then return end++  local counts = {}+  for _, diagnostic in pairs(diagnostics) do+    if diagnostic.severity then+      local val = counts[diagnostic.severity]+      if val == nil then+        val = 0+      end++      counts[diagnostic.severity] = val + 1+    end+  end++  return counts+end++--@private+--- Set the different diagnostic cache after `textDocument/publishDiagnostics`+---@param diagnostics Diagnostic[]+---@param bufnr number+---@param client_id number+---@return nil+local function set_diagnostic_cache(diagnostics, bufnr, client_id)+  client_id = get_client_id(client_id)++  -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#diagnostic+  --+  -- The diagnostic's severity. Can be omitted. If omitted it is up to the+  -- client to interpret diagnostics as error, warning, info or hint.+  -- TODO: Replace this with server-specific heuristics to infer severity.+  for _, diagnostic in ipairs(diagnostics) do+    if diagnostic.severity == nil then+      diagnostic.severity = DiagnosticSeverity.Error+    end+  end++  diagnostic_cache[bufnr][client_id] = diagnostics+  diagnostic_cache_lines[bufnr][client_id] = _diagnostic_lines(diagnostics)+  diagnostic_cache_counts[bufnr][client_id] = _diagnostic_counts(diagnostics)+end+++--@private+--- Clear the cached diagnostics+---@param bufnr number+---@param client_id number+local function clear_diagnostic_cache(bufnr, client_id)+  client_id = get_client_id(client_id)++  diagnostic_cache[bufnr][client_id] = nil+  diagnostic_cache_lines[bufnr][client_id] = nil+  diagnostic_cache_counts[bufnr][client_id] = nil+end++--- Save diagnostics to the current buffer.+---+--- Handles saving diagnostics from multiple clients in the same buffer.+---@param diagnostics Diagnostic[]+---@param bufnr number+---@param client_id number+function M.save(diagnostics, bufnr, client_id)+  validate {+    diagnostics = {diagnostics, 't'},+    bufnr = {bufnr, 'n'},+    client_id = {client_id, 'n', true},+  }++  if not diagnostics then return end++  bufnr = get_bufnr(bufnr)+  client_id = get_client_id(client_id)++  if not _diagnostic_cleanup[bufnr][client_id] then+    _diagnostic_cleanup[bufnr][client_id] = true++    -- Clean up our data when the buffer unloads.+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(b)+        clear_diagnostic_cache(b, client_id)+        _diagnostic_cleanup[bufnr][client_id] = nil+      end+    })+  end++  set_diagnostic_cache(diagnostics, bufnr, client_id)+end+-- }}}+-- Diagnostic Retrieval {{{++--- Return associated diagnostics for bufnr+---+---@param bufnr number+---@param client_id number|nil If nil, then return all of the diagnostics.+---                            Else, return just the diagnostics associated with the client_id.+function M.get(bufnr, client_id)+  if client_id == nil then+    local all_diagnostics = {}+    for iter_client_id, _ in pairs(diagnostic_cache[bufnr]) do+      local iter_diagnostics = M.get(bufnr, iter_client_id)++      for _, diagnostic in ipairs(iter_diagnostics) do+        table.insert(all_diagnostics, diagnostic)+      end+    end++    return all_diagnostics+  end++  return diagnostic_cache[bufnr][client_id] or {}+end++--- Get the diagnostics by line+---+---@param bufnr number The buffer number+---@param line_nr number The line number+---@param opts table|nil Configuration keys+---         - severity: (DiagnosticSeverity, default nil)+---             - Only return diagnostics with this severity. Overrides severity_limit+---         - severity_limit: (DiagnosticSeverity, default nil)+---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.+---@param client_id number the client id+---@return table Table with map of line number to list of diagnostics.+--               Structured: { [1] = {...}, [5] = {.... } }+function M.get_line_diagnostics(bufnr, line_nr, opts, client_id)+  opts = opts or {}++  bufnr = bufnr or vim.api.nvim_get_current_buf()+  line_nr = line_nr or vim.api.nvim_win_get_cursor(0)[1] - 1++  local client_get_diags = function(iter_client_id)+    return (diagnostic_cache_lines[bufnr][iter_client_id] or {})[line_nr] or {}+  end++  local line_diagnostics+  if client_id == nil then+    line_diagnostics = {}+    for iter_client_id, _ in pairs(diagnostic_cache_lines[bufnr]) do+      for _, diagnostic in ipairs(client_get_diags(iter_client_id)) do+        table.insert(line_diagnostics, diagnostic)+      end+    end+  else+    line_diagnostics = vim.deepcopy(client_get_diags(client_id))+  end++  if opts.severity then+    local filter_level = to_severity(opts.severity)+    line_diagnostics = vim.tbl_filter(function(t) return t.severity == filter_level end, line_diagnostics)+  elseif opts.severity_limit then+    local filter_level = to_severity(opts.severity_limit)+    line_diagnostics = vim.tbl_filter(function(t) return t.severity <= filter_level end, line_diagnostics)+  end++  if opts.severity_sort then+    table.sort(line_diagnostics, function(a, b) return a.severity < b.severity end)+  end++  return line_diagnostics+end++--- Get the counts for a particular severity+---+--- Useful for showing diagnostic counts in statusline. eg:+---+--- <pre>+--- function! LspStatus() abort+---   let sl = ''+---   if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')+---     let sl.='%#MyStatuslineLSP#E:'+---     let sl.='%#MyStatuslineLSPErrors#%{luaeval(""vim.lsp.diagnostic.get_count([[Error]])"")}'+---     let sl.='%#MyStatuslineLSP# W:'+---     let sl.='%#MyStatuslineLSPWarnings#%{luaeval(""vim.lsp.diagnostic.get_count([[Warning]])"")}'+---   else+---       let sl.='%#MyStatuslineLSPErrors#off'+---   endif+---   return sl+--- endfunction+--- let &l:statusline = '%#MyStatuslineLSP#LSP '.LspStatus()+--- </pre>+---+---@param bufnr number The buffer number+---@param severity DiagnosticSeverity+---@param client_id number the client id+function M.get_count(bufnr, severity, client_id)+  if client_id == nil then+    local total = 0+    for iter_client_id, _ in pairs(diagnostic_cache_counts[bufnr]) do+      total = total + M.get_count(bufnr, severity, iter_client_id)+    end++    return total+  end++  return (diagnostic_cache_counts[bufnr][client_id] or {})[DiagnosticSeverity[severity]] or 0+end+++-- }}}+-- Diagnostic Movements {{{++--- Helper function to iterate through all of the diagnostic lines+---@return table list of diagnostics+local _iter_diagnostic_lines = function(start, finish, step, bufnr, opts, client_id)+  if bufnr == nil then+    bufnr = vim.api.nvim_get_current_buf()+  end++  local wrap = if_nil(opts.wrap, true)++  local search = function(search_start, search_finish, search_step)+    for line_nr = search_start, search_finish, search_step do+      local line_diagnostics = M.get_line_diagnostics(bufnr, line_nr, opts, client_id)+      if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then+        return line_diagnostics+      end+    end+  end++  local result = search(start, finish, step)++  if wrap then+    local wrap_start, wrap_finish+    if step == 1 then+      wrap_start, wrap_finish = 1, start+    else+      wrap_start, wrap_finish = vim.api.nvim_buf_line_count(bufnr), start+    end++    if not result then+      result = search(wrap_start, wrap_finish, step)+    end+  end++  return result+end++--@private+--- Helper function to ierate through diagnostic lines and return a position+---+---@return table {row, col}+local function _iter_diagnostic_lines_pos(opts, line_diagnostics)+  opts = opts or {}++  local win_id = opts.win_id or vim.api.nvim_get_current_win()+  local bufnr = vim.api.nvim_win_get_buf(win_id)++  if line_diagnostics == nil or vim.tbl_isempty(line_diagnostics) then+    return false+  end++  local iter_diagnostic = line_diagnostics[1]+  return to_position(iter_diagnostic.range.start, bufnr)+end++--@private+-- Move to the diagnostic position+local function _iter_diagnostic_move_pos(name, opts, pos)+  opts = opts or {}++  local enable_popup = if_nil(opts.enable_popup, true)+  local win_id = opts.win_id or vim.api.nvim_get_current_win()++  if not pos then+    print(string.format(""%s: No more valid diagnostics to move to."", name))+    return+  end++  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})++  if enable_popup then+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.+    vim.schedule(function()+      M.show_line_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))+    end)+  end+end++--- Get the previous diagnostic closest to the cursor_position+---+---@param opts table See |vim.lsp.diagnostics.goto_next()|+---@return table Previous diagnostic+function M.get_prev(opts)+  opts = opts or {}++  local win_id = opts.win_id or vim.api.nvim_get_current_win()+  local bufnr = vim.api.nvim_win_get_buf(win_id)+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)++  return _iter_diagnostic_lines(cursor_position[1] - 2, 0, -1, bufnr, opts, opts.client_id)+end++--- Return the pos, {row, col}, for the prev diagnostic in the current buffer.+---@param opts table See |vim.lsp.diagnostics.goto_next()|+---@return table Previous diagnostic position+function M.get_prev_pos(opts)+  return _iter_diagnostic_lines_pos(+    opts,+    M.get_prev(opts)+  )+end++--- Move to the previous diagnostic+---@param opts table See |vim.lsp.diagnostics.goto_next()|+function M.goto_prev(opts)+  return _iter_diagnostic_move_pos(+    ""DiagnosticPrevious"",+    opts,+    M.get_prev_pos(opts)+  )+end++--- Get the previous diagnostic closest to the cursor_position+---@param opts table See |vim.lsp.diagnostics.goto_next()|+---@return table Next diagnostic+function M.get_next(opts)+  opts = opts or {}++  local win_id = opts.win_id or vim.api.nvim_get_current_win()+  local bufnr = vim.api.nvim_win_get_buf(win_id)+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)++  return _iter_diagnostic_lines(cursor_position[1], vim.api.nvim_buf_line_count(bufnr), 1, bufnr, opts, opts.client_id)+end++--- Return the pos, {row, col}, for the next diagnostic in the current buffer.+---@param opts table See |vim.lsp.diagnostics.goto_next()|+---@return table Next diagnostic position+function M.get_next_pos(opts)+  return _iter_diagnostic_lines_pos(+    opts,+    M.get_next(opts)+  )+end++--- Move to the next diagnostic+---@param opts table|nil Configuration table. Keys:+---         - {client_id}: (number)+---             - If nil, will consider all clients attached to buffer.+---         - {cursor_position}: (Position, default current position)+---             - See |nvim_win_get_cursor()|+---         - {wrap}: (boolean, default true)+---             - Whether to loop around file or not. Similar to 'wrapscan'+---         - {severity}: (DiagnosticSeverity)+---             - Exclusive severity to consider. Overrides {severity_limit}+---         - {severity_limit}: (DiagnosticSeverity)+---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.+---         - {enable_popup}: (boolean, default true)+---             - Call |vim.lsp.diagnostic.show_line_diagnostics()| on jump+---         - {popup_opts}: (table)+---             - Table to pass as {opts} parameter to |vim.lsp.diagnostic.show_line_diagnostics()|+---         - {win_id}: (number, default 0)+---             - Window ID+function M.goto_next(opts)+  return _iter_diagnostic_move_pos(+    ""DiagnosticNext"",+    opts,+    M.get_next_pos(opts)+  )+end+-- }}}+-- Diagnostic Setters {{{++--- Set signs for given diagnostics+---+--- Sign characters can be customized with the following commands:+---+--- <pre>+--- sign define LspDiagnosticsErrorSign text=E texthl=LspDiagnosticsError linehl= numhl=+--- sign define LspDiagnosticsWarningSign text=W texthl=LspDiagnosticsWarning linehl= numhl=+--- sign define LspDiagnosticsInformationSign text=I texthl=LspDiagnosticsInformation linehl= numhl=+--- sign define LspDiagnosticsHintSign text=H texthl=LspDiagnosticsHint linehl= numhl=+--- </pre>+---@param diagnostics Diagnostic[]+---@param bufnr number The buffer number+---@param client_id number the client id+---@param sign_ns number|nil+---@param opts table Configuration for signs. Keys:+---             - priority: Set the priority of the signs.+function M.set_signs(diagnostics, bufnr, client_id, sign_ns, opts)+  opts = opts or {}+  sign_ns = sign_ns or M._get_sign_namespace(client_id)++  if not diagnostics then+    diagnostics = diagnostic_cache[bufnr][client_id]+  end++  if not diagnostics then+    return+  end++  bufnr = get_bufnr(bufnr)++  local ok = true+  for _, diagnostic in ipairs(diagnostics) do+    ok = ok and pcall(vim.fn.sign_place,+      0,+      sign_ns,+      sign_highlight_map[diagnostic.severity],+      bufnr,+      {+        priority = opts.priority,+        lnum = diagnostic.range.start.line + 1+      }+    )+  end++  if not ok then+    log.debug(""Failed to place signs:"", diagnostics)+  end+end++--- Set underline for given diagnostics+---+--- Underline highlights can be customized by changing the following |:highlight| groups.+---+--- <pre>+--- LspDiagnosticsUnderlineError+--- LspDiagnosticsUnderlineWarning+--- LspDiagnosticsUnderlineInformation+--- LspDiagnosticsUnderlineHint+--- </pre>+---+---@param diagnostics Diagnostic[]+---@param bufnr number The buffer number+---@param client_id number the client id+---@param diagnostic_ns number|nil+---@param opts table Currently unused.+function M.set_underline(diagnostics, bufnr, client_id, diagnostic_ns, opts)+  opts = opts or {}+  assert(opts) -- lint++  diagnostic_ns = diagnostic_ns or M._get_diagnostic_namespace(client_id)++  for _, diagnostic in ipairs(diagnostics) do+    local start = diagnostic.range[""start""]+    local finish = diagnostic.range[""end""]+    local higroup = underline_highlight_map[diagnostic.severity]++    if higroup == nil then+      -- Default to error if we don't have a highlight associated+      higroup = underline_highlight_map[DiagnosticSeverity.Error]+    end++    highlight.range(+      bufnr,+      diagnostic_ns,+      higroup,+      to_position(start, bufnr),+      to_position(finish, bufnr)+    )+  end+end++-- Virtual Text {{{+--- Set virtual text given diagnostics+---+--- Virtual text highlights can be customized by changing the following |:highlight| groups.+---+--- <pre>+--- LspDiagnosticsVirtualTextError+--- LspDiagnosticsVirtualTextWarning+--- LspDiagnosticsVirtualTextInformation+--- LspDiagnosticsVirtualTextHint+--- </pre>+---+---@param diagnostics Diagnostic[]+---@param bufnr number+---@param client_id number+---@param diagnostic_ns number+---@param opts table Options on how to display virtual text. Keys:+---             - prefix (string): Prefix to display before virtual text on line+---             - spacing (number): Number of spaces to insert before virtual text+function M.set_virtual_text(diagnostics, bufnr, client_id, diagnostic_ns, opts)+  opts = opts or {}++  client_id = get_client_id(client_id)+  diagnostic_ns = diagnostic_ns or M._get_diagnostic_namespace(client_id)++  local buffer_line_diagnostics+  if diagnostics then+    buffer_line_diagnostics = _diagnostic_lines(diagnostics)+  else+    buffer_line_diagnostics = diagnostic_cache_lines[bufnr][client_id]+  end++  if not buffer_line_diagnostics then+    return nil+  end++  for line, line_diagnostics in pairs(buffer_line_diagnostics) do+    local virt_texts = M.get_virtual_text_chunks_for_line(bufnr, line, line_diagnostics, opts)++    if virt_texts then+      api.nvim_buf_set_virtual_text(bufnr, diagnostic_ns, line, virt_texts, {})+    end+  end+end++--- Default function to get text chunks to display using `nvim_buf_set_virtual_text`.+---@param bufnr number The buffer to display the virtual text in+---@param line number The line number to display the virtual text on+---@param line_diags Diagnostic[] The diagnostics associated with the line+---@param opts table See {opts} from |vim.lsp.diagnostic.set_virtual_text()|+---@return table chunks, as defined by |nvim_buf_set_virtual_text()|+function M.get_virtual_text_chunks_for_line(bufnr, line, line_diags, opts)+  assert(bufnr or line)++  if #line_diags == 0 then+    return nil+  end++  opts = opts or {}+  local prefix = opts.prefix or ""���""+  local spacing = opts.spacing or 4++  -- Create a little more space between virtual text and contents+  local virt_texts = {{string.rep("" "", spacing)}}++  for i = 1, #line_diags - 1 do+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})+  end+  local last = line_diags[#line_diags]++  -- TODO(tjdevries): Allow different servers to be shown first somehow?+  -- TODO(tjdevries): Display server name associated with these?+  if last.message then+    table.insert(+      virt_texts,+      {+        string.format(""%s %s"", prefix, last.message:gsub(""\r"", """"):gsub(""\n"", ""  "")),+        virtual_text_highlight_map[last.severity]+      }+    )++    return virt_texts+  end+end+-- }}}+-- }}}+-- Diagnostic Clear {{{+--- Clears the currently displayed diagnostics+---@param bufnr number The buffer number+---@param client_id number the client id+---@param diagnostic_ns number|nil Associated diagnostic namespace+---@param sign_ns number|nil Associated sign namespace+function M.clear(bufnr, client_id, diagnostic_ns, sign_ns)+  validate { bufnr = { bufnr, 'n' } }++  bufnr = (bufnr == 0 and api.nvim_get_current_buf()) or bufnr++  if client_id == nil then+    return vim.lsp.for_each_buffer_client(bufnr, function(_, iter_client_id, _)+      return M.clear(bufnr, iter_client_id)+    end)+  end++  diagnostic_ns = diagnostic_ns or M._get_diagnostic_namespace(client_id)+  sign_ns = sign_ns or M._get_sign_namespace(client_id)++  assert(bufnr, ""bufnr is required"")+  assert(diagnostic_ns, ""Need diagnostic_ns, got nil"")+  assert(sign_ns, string.format(""Need sign_ns, got nil %s"", sign_ns))++  -- clear sign group+  vim.fn.sign_unplace(sign_ns, {buffer=bufnr})++  -- clear virtual text namespace+  api.nvim_buf_clear_namespace(bufnr, diagnostic_ns, 0, -1)+end+-- }}}+-- Diagnostic Insert Leave Handler {{{++--- Callback scheduled for after leaving insert mode+---+--- Used to handle+--@private+function M._execute_scheduled_display(bufnr, client_id)+  local args = _bufs_waiting_to_update[bufnr][client_id]+  if not args then+    return+  end++  -- Clear the args so we don't display unnecessarily.+  _bufs_waiting_to_update[bufnr][client_id] = nil++  M.display(nil, bufnr, client_id, args)+end++local registered = {}++local make_augroup_key = function(bufnr, client_id)+  return string.format(""LspDiagnosticInsertLeave:%s:%s"", bufnr, client_id)+end++--- Table of autocmd events to fire the update for displaying new diagnostic information+M.insert_leave_auto_cmds = { ""InsertLeave"", ""CursorHoldI"" }++--- Used to schedule diagnostic updates upon leaving insert mode.+---+--- For parameter description, see |M.display()|+function M._schedule_display(bufnr, client_id, args)+  _bufs_waiting_to_update[bufnr][client_id] = args++  local key = make_augroup_key(bufnr, client_id)+  if not registered[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(+      string.format(+        [[autocmd %s <buffer=%s> :lua vim.lsp.diagnostic._execute_scheduled_display(%s, %s)]],+        table.concat(M.insert_leave_auto_cmds, "",""),+        bufnr,+        bufnr,+        client_id+      )+    )+    vim.cmd(""augroup END"")++    registered[key] = true+  end+end+++--- Used in tandem with+---+--- For parameter description, see |M.display()|+function M._clear_scheduled_display(bufnr, client_id)+  local key = make_augroup_key(bufnr, client_id)++  if registered[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(""augroup END"")++    registered[key] = nil+  end+end+-- }}}++-- Diagnostic Private Highlight Utilies {{{+--- Get the severity highlight name+--@private+function M._get_severity_highlight_name(severity)+  return virtual_text_highlight_map[severity]+end++--- Get floating severity highlight name+--@private+function M._get_floating_severity_highlight_name(severity)+  return floating_highlight_map[severity]+end++--- This should be called to update the highlights for the LSP client.+function M._define_default_signs_and_highlights()+  --@private+  local function define_default_sign(name, properties)+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then+      vim.fn.sign_define(name, properties)+    end+  end++  -- Initialize default diagnostic highlights+  for severity, hi_info in pairs(diagnostic_severities) do+    local default_highlight_name = default_highlight_map[severity]+    highlight.create(default_highlight_name, hi_info, true)++    -- Default link all corresponding highlights to the default highlight+    highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)+    highlight.link(floating_highlight_map[severity], default_highlight_name, false)+    highlight.link(sign_highlight_map[severity], default_highlight_name, false)+  end++  -- Create all signs+  for severity, sign_hl_name in pairs(sign_highlight_map) do+    local severity_name = DiagnosticSeverity[severity]++    define_default_sign(sign_hl_name, {+      text = (severity_name or 'U'):sub(1, 1),+      texthl = sign_hl_name,+      linehl = '',+      numhl = '',+    })+  end++  -- Initialize Underline highlights+  for severity, underline_highlight_name in pairs(underline_highlight_map) do+    highlight.create(underline_highlight_name, {+      cterm = 'underline',+      gui   = 'underline',+      guisp = diagnostic_severities[severity].guifg+    }, true)+  end+end+-- }}}+-- Diagnostic Display {{{++--- |lsp-handler| for the method ""textDocument/publishDiagnostics""+---+---@note Each of the configuration options accepts:+---         - `false`: Disable this feature+---         - `true`: Enable this feature, use default settings.+---         - `table`: Enable this feature, use overrides.+---         - `function`: Function with signature (bufnr, client_id) that returns any of the above.+--- <pre>+--- vim.lsp.handlers[""textDocument/publishDiagnostics""] = vim.lsp.with(+---   vim.lsp.diagnostic.on_publish_diagnostics, {+---     -- Enable underline, use default values+---     underline = true,+---     -- Enable virtual text, override spacing to 4+---     virtual_text = {+---       spacing = 4,+---     },+---     -- Use a function to dynamically turn signs off+---     -- and on, using buffer local variables+---     signs = function(bufnr, client_id)+---       return vim.bo[bufnr].show_signs == false+---     end,+---     -- Disable a feature+---     update_in_insert = false,+---   }+--- )+--- </pre>+---+---@param config table Configuration table.+---     - underline:        (default=true)+---         - Apply underlines to diagnostics.+---         - See |vim.lsp.diagnostic.set_underline()|+---     - virtual_text:     (default=true)+---         - Apply virtual text to line endings.+---         - See |vim.lsp.diagnostic.set_virtual_text()|+---     - signs:            (default=true)+---         - Apply signs for diagnostics.+---         - See |vim.lsp.diagnostic.set_signs()|+---     - update_in_insert: (default=false)+---         - Update diagnostics in InsertMode or wait until InsertLeave+function M.on_publish_diagnostics(_, _, params, client_id, _, config)+  local uri = params.uri+  local bufnr = vim.uri_to_bufnr(uri)++  if not bufnr then+    return+  end++  local diagnostics = params.diagnostics++  -- Always save the diagnostics, even if the buf is not loaded.+  -- Language servers may report compile or build errors via diagnostics+  -- Users should be able to find these, even if they're in files which+  -- are not loaded.+  M.save(diagnostics, bufnr, client_id)++  -- Unloaded buffers should not handle diagnostics.+  --    When the buffer is loaded, we'll call on_attach, which sends textDocument/didOpen.+  --    This should trigger another publish of the diagnostics.+  --+  -- In particular, this stops a ton of spam when first starting a server for current+  -- unloaded buffers.+  if not api.nvim_buf_is_loaded(bufnr) then+    return+  end++  M.display(diagnostics, bufnr, client_id, config)+end++--@private+--- Display diagnostics for the buffer, given a configuration.+function M.display(diagnostics, bufnr, client_id, config)+  config = vim.lsp._with_extend('vim.lsp.diagnostic.on_publish_diagnostics', {+    signs = true,+    underline = true,+    virtual_text = true,+    update_in_insert = false,+  }, config)++  if diagnostics == nil then+    diagnostics = M.get(bufnr, client_id)+  end++  -- TODO(tjdevries): Consider how we can make this a ""standardized"" kind of thing for |lsp-handlers|.+  --    It seems like we would probably want to do this more often as we expose more of them.+  --    It provides a very nice functional interface for people to override configuration.+  local resolve_optional_value = function(option)+    local enabled_val = {}++    if not option then+      return false+    elseif option == true then+      return enabled_val+    elseif type(option) == 'function' then+      local val = option(bufnr, client_id)+      if val == true then+        return enabled_val+      else+        return val+      end+    elseif type(option) == 'table' then+      return option+    else+      error(""Unexpected option type: "" .. vim.inspect(option))+    end+  end++  if resolve_optional_value(config.update_in_insert) then+    M._clear_scheduled_display(bufnr, client_id)+  else+    local mode = vim.api.nvim_get_mode()++    if string.sub(mode.mode, 1, 1) == 'i' then+      M._schedule_display(bufnr, client_id, config)+      return+    end+  end++  M.clear(bufnr, client_id)++  diagnostics = diagnostics or diagnostic_cache[bufnr][client_id]++  if not diagnostics or vim.tbl_isempty(diagnostics) then+    return+  end++  local underline_opts = resolve_optional_value(config.underline)+  if underline_opts then+    M.set_underline(diagnostics, bufnr, client_id, nil, underline_opts)+  end++  local virtual_text_opts = resolve_optional_value(config.virtual_text)+  if virtual_text_opts then+    M.set_virtual_text(diagnostics, bufnr, client_id, nil, virtual_text_opts)+  end++  local signs_opts = resolve_optional_value(config.signs)+  if signs_opts then+    M.set_signs(diagnostics, bufnr, client_id, nil, signs_opts)+  end++  vim.api.nvim_command(""doautocmd User LspDiagnosticsChanged"")+end+-- }}}+-- Diagnostic User Functions {{{++--- Open a floating window with the diagnostics from {line_nr}+---+--- The floating window can be customized with the following highlight groups:+--- <pre>+--- LspDiagnosticsFloatingError+--- LspDiagnosticsFloatingWarning+--- LspDiagnosticsFloatingInformation+--- LspDiagnosticsFloatingHint+--- </pre>+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header.+---@param bufnr number The buffer number+---@param line_nr number The line number+---@param client_id number|nil the client id+---@return {popup_bufnr, win_id}+function M.show_line_diagnostics(opts, bufnr, line_nr, client_id)+  opts = opts or {}+  opts.severity_sort = if_nil(opts.severity_sort, true)++  local show_header = if_nil(opts.show_header, true)++  bufnr = bufnr or 0+  line_nr = line_nr or (vim.api.nvim_win_get_cursor(0)[1] - 1)++  local lines = {}+  local highlights = {}+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  local line_diagnostics = M.get_line_diagnostics(bufnr, line_nr, opts, client_id)+  if vim.tbl_isempty(line_diagnostics) then return end++  for i, diagnostic in ipairs(line_diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = M._get_floating_severity_highlight_name(diagnostic.severity)+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix + 1, hiname})+    for j = 2, #message_lines do+      table.insert(lines, message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  local popup_bufnr, winnr = util.open_floating_preview(lines, 'plaintext')+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end++local loclist_type_map = {+  [DiagnosticSeverity.Error] = 'E',+  [DiagnosticSeverity.Warning] = 'W',+  [DiagnosticSeverity.Information] = 'I',+  [DiagnosticSeverity.Hint] = 'I',+}++--- Sets the location list+---@param opts table|nil Configuration table. Keys:+---         - {open_loclist}: (boolean, default true)+---             - Open loclist after set+---         - {client_id}: (number)+---             - If nil, will consider all clients attached to buffer.+---         - {severity}: (DiagnosticSeverity)+---             - Exclusive severity to consider. Overrides {severity_limit}+---         - {severity_limit}: (DiagnosticSeverity)+---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.+function M.set_loclist(opts)+  opts = opts or {}++  local open_loclist = if_nil(opts.open_loclist, true)++  local bufnr = vim.api.nvim_get_current_buf()+  local buffer_diags = M.get(bufnr, opts.client_id)++  local severity = to_severity(opts.severity)+  local severity_limit = to_severity(opts.severity_limit)++  local items = {}+  local insert_diag = function(diag)+    if severity then+      -- Handle missing severities+      if not diag.severity then+        return+      end++      if severity ~= diag.severity then+        return+      end+    elseif severity_limit then+      if not diag.severity then+        return+      end++      if severity_limit < diag.severity then+        return+      end+    end++    local pos = diag.range.start+    local row = pos.line+    local col = util.character_offset(bufnr, row, pos.character)++    local line = (api.nvim_buf_get_lines(bufnr, row, row + 1, false) or {""""})[1]++    table.insert(items, {+      bufnr = bufnr,+      lnum = row + 1,+      col = col + 1,+      text = line .. "" | "" .. diag.message,+      type = loclist_type_map[diag.severity or DiagnosticSeverity.Error] or 'E',+    })+  end++  for _, diag in ipairs(buffer_diags) do+    insert_diag(diag)+  end","This is not sorted by default.And a unsorted loclist breaks `labove` and `lbelow`.Can you add sorting here (or earlier in the chain, not sure if it is relevant anywhere else)```table.sort(items, function(a,b) return a.lnum < b.lnum end)```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13079,522657627,2020-11-13T05:17:39Z,src/nvim/ex_cmds.lua,"@@ -15,3288 +15,3277 @@ local COUNT      =    0x400 local NOTRLCOM   =    0x800 local ZEROR      =   0x1000 local USECTRLV   =   0x2000-local NOTADR     =   0x4000-local EDITCMD    =   0x8000-local BUFNAME    =  0x10000-local BUFUNL     =  0x20000-local ARGOPT     =  0x40000-local SBOXOK     =  0x80000-local CMDWIN     = 0x100000-local MODIFY     = 0x200000-local EXFLAGS    = 0x400000-local RESTRICT   = 0x800000+local EDITCMD    =   0x4000+local BUFNAME    =   0x8000+local BUFUNL     =  0x10000+local ARGOPT     =  0x20000+local SBOXOK     =  0x40000+local CMDWIN     =  0x80000+local MODIFY     = 0x100000+local EXFLAGS    = 0x200000+local RESTRICT   = 0x400000",https://github.com/neovim/neovim/pull/11996 removed restricted mode so `RESTRICT` is now dead code. Maybe comment it out and update affected ex commands.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12378,522834169,2020-11-13T09:38:33Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,271 @@+#include <stdbool.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/fileio.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define FOREACH_KEY_VALUE(d, k, v, code) \+  for (size_t i = 0; i < d.size; i++) { \+    String k = d.items[i].key; \+    Object *v = &d.items[i].value; \+    code; \+  }++#define FOREACH_ITEM(a, item, code) \+  for (size_t i = 0; i < a.size; i++) { \+    Object item = a.items[i]; \+    code; \+  }++#define UNPACK_EVENTS(event_array, v, goto_name) \+  if (v->type == kObjectTypeString) { \+    ADD(event_array, copy_object(*v)); \+  } else if (v->type == kObjectTypeArray) { \+    for (size_t j = 0; j < event_array.size; j++) { \+      Object item = event_array.items[j]; \+      if (item.type != kObjectTypeString) { \+        api_set_error( \+            err, \+            kErrorTypeValidation, \+            ""All entries in 'event' must be strings""); \+        goto goto_name; \+      } \+    } \+    event_array = copy_array(v->data.array); \+  } else { \+    api_set_error( \+        err, \+        kErrorTypeValidation, \+        ""'event' must be an array or a string.""); \+    goto goto_name; \+  }++#define GET_ONE_EVENT(event_nr, event_str, goto_name) \+  char_u *next_ev; \+  event_T event_nr = event_name2nr((char_u *)event_str.data.string.data, &next_ev); \+  if (event_nr >= NUM_EVENTS) { \+    api_set_error(err, kErrorTypeValidation, ""unexpected event""); \+    goto goto_name; \+  }+++/// Define an autocmd.+/// @param opts Dictionary+///          Required keys:+///              event: string | ArrayOf(string)+void nvim_autocmd_define(+    DictionaryOf(LuaRef) opts,+    Error *err)+  FUNC_API_SINCE(7)+{+  char_u *rhs;+  char_u *pattern = NULL;++  bool is_once = false;+  bool is_nested = false;+  int au_group = AUGROUP_ALL;++  LuaCallable command_callback = nlua_init_callable();+  Array event_array = ARRAY_DICT_INIT;++  bool found_command = false;++  FOREACH_KEY_VALUE(opts, k, v, {+    if (strequal(""command"", k.data)) {+      found_command = true;++      if (v->type == kObjectTypeLuaRef) {+        command_callback.func_ref = v->data.luaref;+        v->data.luaref = LUA_NOREF;+      } else if (v->type == kObjectTypeString) {+        rhs = (char_u *)v->data.string.data;+      } else {+        api_set_error(+            err,+            kErrorTypeValidation,+            ""'on_event' must be a string or LuaRef"");+        goto cleanup;+      }+    } else if (strequal(""pattern"", k.data)) {+      if (v->type == kObjectTypeString) {+        pattern = (char_u *)v->data.string.data;+      } else {+        api_set_error(+            err,+            kErrorTypeValidation,+            ""'pattern' must be a string"");+        goto cleanup;+      }+    } else if (strequal(""event"", k.data)) {+      UNPACK_EVENTS(event_array, v, cleanup)+    } else if (strequal(""once"", k.data)) {+      is_once = api_object_to_bool(*v, ""once"", true, err);+    } else if (strequal(""nested"", k.data)) {+      is_nested = api_object_to_bool(*v, ""nested"", true, err);+    } else if (strequal(""group"", k.data)) {+      if (v->type != kObjectTypeString) {+        api_set_error(err, kErrorTypeValidation, ""'group' must be a string"");+        goto cleanup;+      }++      au_group = au_find_group((char_u *)v->data.string.data);++      if (au_group == AUGROUP_ERROR) {+        api_set_error(err, kErrorTypeException, ""invalid augroup: %s"", v->data.string.data);+        goto cleanup;+      }+    } else {+      api_set_error(err, kErrorTypeValidation, ""unexpected key: %s"", k.data);+      goto cleanup;+    }+  })++  if (!found_command) {+    api_set_error(err, kErrorTypeValidation, ""'command' is a required key"");+    goto cleanup;+  }++  if (pattern == NULL) {","`pattern` should be optional and default to `*`, I think.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13278,523271689,2020-11-13T22:46:07Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -103,7 +103,16 @@ function TSHighlighter:get_hl_from_capture(capture)   else     -- Default to false to avoid recomputing     local hl = TSHighlighter.hl_map[name]-    return hl and a.nvim_get_hl_id_by_name(hl) or 0++    if not hl then return 0 end++    local scoped_hl = vim.fn.hlID(self.parser.lang .. hl)",hmm Treesitter is a bit of a special case but in general it is considered bad style to check for the existence of highlight groups like this. What typically should be done is `hi default link PythonComment Comment` (or an API equivalent that I could introduce). This command is a no-op if `PythonComment` already exist or a default has been defined elsewhere.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13278,523271929,2020-11-13T22:46:57Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -103,7 +103,16 @@ function TSHighlighter:get_hl_from_capture(capture)   else     -- Default to false to avoid recomputing     local hl = TSHighlighter.hl_map[name]-    return hl and a.nvim_get_hl_id_by_name(hl) or 0++    if not hl then return 0 end++    local scoped_hl = vim.fn.hlID(self.parser.lang .. hl)","concretely, even if `PythonComment` does not exist the _metadata_ that it was a PythonComment will be preserved for downstream consumers (like hlstate ui:s and the yet nonexisting libnvim)",
41671631,glepnir,https://api.github.com/repos/neovim/neovim/pulls/13283,523385713,2020-11-14T06:46:55Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -739,17 +742,32 @@ function M.get_virtual_text_chunks_for_line(bufnr, line, line_diags, opts)   end   local last = line_diags[#line_diags] -  -- TODO(tjdevries): Allow different servers to be shown first somehow?-  -- TODO(tjdevries): Display server name associated with these?   if last.message then+    local server_name = ''++    if show_server_name then+      local active_clients = vim.lsp.get_active_clients()+      if not vim.tbl_isempty(active_clients) then+        for _,client in ipairs(active_clients) do+          if diagnostic_cache_lines[bufnr][client.id][line] ~= nil then+            server_name = client.config.cmd[1]:match('[^\\/]+$')+          end+        end+      end","hmmm the function will receive five arguments ,It's too long?",X
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/13367,529686970,2020-11-24T16:04:16Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -314,6 +321,32 @@ function LanguageTree:_get_injections()         end       end +      for _, pred in pairs(preds or {}) do+        -- Shifts the column range of the injected node and uses+        -- the new range as the injection point. This should be used+        -- when the offset is known (stripping quotes, for example).+        -- Example: (#offset! @_node 0 1 0 -1)+        if pred[1] == ""offset!"" then+          local offset_node = match[pred[2]]+          local range = {offset_node:range()}+          local start_row_offset = pred[3] or 0","Wouldn't be better if we could also use this predicate in other queries (not only injections)? This directive could also just replace the node by a range table (or save the processed result some where else in `info`) and by that be useful for other applications that need to specify an offset on their query.Wouldn't it make sense to also allow strings as offset or more general Lua expressions? E.g. `(offset! 0 4 0 0)` could also be written as `(offset! 0 "">>> "" 0 0)` or `(offset! 0 ""#'>>> '"" 0 0)`? But probably just numbers is the fastest and simplest even if you need to document and count letter in longer strings.Would be nice if pred could `gmatch` on a node range to get all relevant subranges e.g. to find all `>>> (.*)$` in Python docstrings? I assume most users won't want to implement their on tree-sitter parser for tiny things like this. Also this is a concept that should not be specific to injections only.",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,529697761,2020-11-24T16:13:18Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -314,6 +321,32 @@ function LanguageTree:_get_injections()         end       end +      for _, pred in pairs(preds or {}) do+        -- Shifts the column range of the injected node and uses+        -- the new range as the injection point. This should be used+        -- when the offset is known (stripping quotes, for example).+        -- Example: (#offset! @_node 0 1 0 -1)+        if pred[1] == ""offset!"" then+          local offset_node = match[pred[2]]+          local range = {offset_node:range()}+          local start_row_offset = pred[3] or 0","It could be made more general but this use case is very specific to injections. we don't have anywhere to put the resulting range that this generates currently... I'm not opposed to storing the results in `info` but it needs something more generic.This predicate is meant to be a fixed offset. Only really used when the offset is known by the user, and is meant to be as fast as possible. Any pattern matching should be done in a separate predicate to keep this one fast and not overloaded.Also, stripping content from the lines of the captured node isn't supported in this PR. That will come at a later time. This covers about 80% of use cases when it comes to stripping unneeded characters from language injection.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/13357,530224833,2020-11-25T09:28:37Z,test/functional/ui/bufhl_spec.lua,"@@ -534,6 +534,44 @@ describe('Buffer highlighting', function()     ]]}   end) +  it('respects priority', function()+    local set_extmark = curbufmeths.set_extmark+    local id = meths.create_namespace('')+    insert [[foobar]]++    set_extmark(id, 0, 0, {+      end_line = 0,+      end_col = 6,+      hl_group = ""Normal"",+      priority = 100+    })+    set_extmark(id, 0, 3, {+      end_line = 0,+      end_col = 6,+      hl_group = ""String"",+      priority = 1+    })++    screen:expect { unchanged = true }",Adding a proper test helped : priority was not working at all because I am bad at writing C,
1362750,acomagu,https://api.github.com/repos/neovim/neovim/pulls/13288,531222794,2020-11-26T21:00:44Z,runtime/lua/vim/lsp/rpc.lua,"@@ -139,17 +139,26 @@ local function request_parser_loop()       -- TODO(ashkan) I'd like to remove this, but it seems permanent :(       local buffer_start = buffer:find(header_start_pattern)       local headers = parse_headers(buffer:sub(buffer_start, start-1))-      buffer = buffer:sub(finish+1)       local content_length = headers.content_length+      local body_chunks = {buffer:sub(finish+1)}+      local body_length = #body_chunks[1]       -- Keep waiting for data until we have enough.-      while #buffer < content_length do-        buffer = buffer..(coroutine.yield()-            or error(""Expected more data for the body. The server may have died."")) -- TODO hmm.+      while body_length < content_length do+        local chunk = coroutine.yield()+            or error(""Expected more data for the body. The server may have died."") -- TODO hmm.+        table.insert(body_chunks, chunk)+        body_length = body_length + #chunk       end-      local body = buffer:sub(1, content_length)-      buffer = buffer:sub(content_length + 1)+      local last_chunk = body_chunks[#body_chunks]++      body_chunks[#body_chunks] = last_chunk:sub(1, content_length - body_length - 1)+      local rest = ''+      if body_length > content_length then+        rest = last_chunk:sub(content_length - body_length)+      end+      local body = table.concat(body_chunks)       -- Yield our data.-      buffer = buffer..(coroutine.yield(headers, body)+      buffer = rest..(coroutine.yield(headers, body)           or error(""Expected more data for the body. The server may have died."")) -- TODO hmm.     else       -- Get more data since we don't have enough.","Yes, one reason is that the header will be small enough. Another is, I thought finding the border between header part and body part(actually double CRLFs) will be too complicated task for string chunks table.(currently [this line](https://github.com/neovim/neovim/blob/09c237c13c20f4df7b1a06f353574e910408da46/runtime/lua/vim/lsp/rpc.lua#L131))",
73705427,shade-of-noon,https://api.github.com/repos/neovim/neovim/pulls/13383,531242926,2020-11-26T22:34:41Z,runtime/ftplugin/man.vim,"@@ -23,7 +23,7 @@ setlocal foldcolumn=0 colorcolumn=0 nolist nofoldenable  setlocal tagfunc=man#goto_tag -if !exists('g:no_plugin_maps') && !exists('g:no_man_maps')+if !get(g:, 'no_plugin_maps', 0) && !get(g:, 'no_man_maps', 0)","You are right. I thought it was a bug, because despite setting `g:no_man_maps = 0` the condition would evaluate to false and hence no local mappings contrary to the value of `g:no_man_maps`. I'll fix it, apparently Vim doesn't like double negatives :smile:.",
73705427,shade-of-noon,https://api.github.com/repos/neovim/neovim/pulls/13383,531254164,2020-11-26T23:38:51Z,runtime/autoload/man.vim,"@@ -181,36 +202,28 @@ endfunction "" attempt to extract the name and sect out of 'name(sect)' "" otherwise just return the largest string of valid characters in ref function! s:extract_sect_and_name_ref(ref) abort-  if a:ref[0] ==# '-' "" try ':Man -pandoc' with this disabled.-    throw 'manpage name cannot start with ''-'''+  if empty(a:ref)+    throw 'Empty argument.'   endif-  let ref = matchstr(a:ref, '[^()]\+([^()]\+)')-  if empty(ref)-    let name = matchstr(a:ref, '[^()]\+')-    if empty(name)-      throw 'manpage reference cannot contain only parentheses'-    endif-    return ['', name]-  endif-  let left = split(ref, '(')++  let ml = matchlist(a:ref, '^\(.\{-1,}\)\((\(.\{-1,}\))\|\.\([^.]\{-1,}\)\)\?$')","man deals with Unix names: pretty much any (ASCII?) character is valid in a Unix (file)name. So I updated the matching to accept, e.g., ""`--a_bad_idea(9BadIdeas)`"" as `name = '--a_bad_idea'` and `sect = '9BadIdeas'`. That's why I needed to add `--` to the arguments of the `s:system()` / `s:run_man()` function.The regex matches man refs of the form `foo(bar)` and `foo.bar`, and if neither matches then it matches the whole string (which was checked to be non-empty). Here `foo` and `bar` are valid Unix characters for (file)names (except for NULL and new lines).",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,532759519,2020-11-30T17:11:21Z,runtime/lua/vim/treesitter/query.lua,"@@ -244,8 +244,11 @@ local function xor(x, y)   return (x or y) and not (x and y) end -function Query:match_preds(match, pattern, source)+function Query:match_preds(match, pattern, source, opts)+  opts = opts or {}+   local preds = self.info.patterns[pattern]+  local ignore_unknown_predicates = opts.ignore_unknown_predicates",This is no longer relevant. There is now an API to add directives instead.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/13367,532893156,2020-11-30T20:47:11Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -289,18 +289,17 @@ function LanguageTree:_get_injections()       -- You can specify the content and language together       -- using a tag with the language, for example       -- @javascript-      for id, node in pairs(match) do+      for id, node, data in match:iter() do         local name = self._injection_query.captures[id]-        -- TODO add a way to offset the content passed to the parser.-        -- Needed to shave off leading quotes and things of that nature.+        local offset_range = data and data.offset","How would this work if one match would produce more than one range (currently not possible with only one `offset!`)? Will there be more data objects or is there only one data?Ok, now I get it. A data is tied to node. Wouldn't it then be better to have `offset!` produce a array offsets with only one element. Then, it could be directly inserted into injections and one could have another thing returning multiple offsets (not necessary offsets, could be a generic name `ranges`).But maybe this is too complicated. I'm just trying to follow.  ",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,532900481,2020-11-30T21:00:48Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -289,18 +289,17 @@ function LanguageTree:_get_injections()       -- You can specify the content and language together       -- using a tag with the language, for example       -- @javascript-      for id, node in pairs(match) do+      for id, node, data in match:iter() do         local name = self._injection_query.captures[id]-        -- TODO add a way to offset the content passed to the parser.-        -- Needed to shave off leading quotes and things of that nature.+        local offset_range = data and data.offset","A match would only have a single injection node, which is where the offset would apply to. The metadata here is for that capture id in the match, so it's specific to that node. The only way it would collide is if you were to add multiple offsets for the same capture and node (which wouldn't really make sense).```scheme(pair  left: ((idenitifier) @left (#offset! @left 0 1 0 -1))  right: ((identifier) @right (#offset! @right 2 2 2 2)))```These would be perfectly fine as they both reference different captures in the match.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/13367,532906356,2020-11-30T21:12:15Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -289,18 +289,17 @@ function LanguageTree:_get_injections()       -- You can specify the content and language together       -- using a tag with the language, for example       -- @javascript-      for id, node in pairs(match) do+      for id, node, data in match:iter() do         local name = self._injection_query.captures[id]-        -- TODO add a way to offset the content passed to the parser.-        -- Needed to shave off leading quotes and things of that nature.+        local offset_range = data and data.offset","Thanks for the explanation! Yeah, for offset it's natural to produce one data attached to the node.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/13367,532911588,2020-11-30T21:21:35Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -289,18 +289,17 @@ function LanguageTree:_get_injections()       -- You can specify the content and language together       -- using a tag with the language, for example       -- @javascript-      for id, node in pairs(match) do+      for id, node, data in match:iter() do         local name = self._injection_query.captures[id]-        -- TODO add a way to offset the content passed to the parser.-        -- Needed to shave off leading quotes and things of that nature.+        local offset_range = data and data.offset",I'm not wanting to produce multiple results with `offset!`. I'm rather saying that injections might require something that produces multiple ranges in future.Would the implementation then be `data and data.offset` then have a single range to insert to the injections and if `data and data.ranges` (or subranges) then insert multiple injections? We could also have `node_iter` for data to abstract later on all kind of directives and now only have `offset`,
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,533380438,2020-12-01T12:44:52Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -289,18 +289,17 @@ function LanguageTree:_get_injections()       -- You can specify the content and language together       -- using a tag with the language, for example       -- @javascript-      for id, node in pairs(match) do+      for id, node, data in match:iter() do         local name = self._injection_query.captures[id]-        -- TODO add a way to offset the content passed to the parser.-        -- Needed to shave off leading quotes and things of that nature.+        local offset_range = data and data.offset","I see what you are saying. This is the plan for another PR where you the injection can be multiple ranges... This would be another directive (almost like a strip! directive) since the logic would be more complex and a little heavier. Offset is the quicker way of just stripping a known amount of characters and/or lines. So, I see this getting slightly adjusted in the future.",
620981,runiq,https://api.github.com/repos/neovim/neovim/pulls/12720,535410389,2020-12-03T16:56:31Z,runtime/lua/vim/lsp/util.lua,"@@ -684,7 +684,20 @@ end ---floating window should be created function M.focusable_preview(unique_name, fn)   return M.focusable_float(unique_name, function()-    return M.open_floating_preview(fn())+    local contents, filetype, opts = fn()+    if opts == nil or opts.close.events == nil then+      -- Provide default autocommand events for closing the preview window+      opts = opts or {}+      opts.close_events = {""CursorMoved"", ""CursorMovedI"", ""BufHidden""}+    else+      -- The ""BufLeave"" and ""WinLeave"" events make the preview non-focusable,+      -- remove them+      opts.close_events = vim.tbl_filter(+        function(i) return i ~= 'BufLeave' and i ~= 'WinLeave' end,+        opts.close_events)+    end++    return M.open_floating_preview(contents, filetype, opts)","I've written this comment ~5 times now because I don't really know how to phrase the questions I'm having, so I'll just be blunt: Wouldn't adding another `focusable` check to this already confusing stack of functions (`focusable_preview()`, `open_floating_preview()`, `focusable_float()`, and another ad-hoc closure) make it *even more* confusing?To be perfectly honest this entire thing feels like a big ball of mud with cross-cutting concerns for no particular gain, and I'd be in favor of simplifying it (@clason also [mentioned that in chat](https://gitter.im/neovim/neovim?at=5fad259dc10273610aff2756)). It's used in only two places in the neovim codebase (`textDocument/hover` uses `focusable_float()`, `textDocument/signatureHelp` uses `focusable_preview()`) and in two corresponding places in completion-nvim. The reason why I haven't attempted simplifying is that I'm not sure how much it is used in plugins and whatnot. It *is* exposed in `lsp.util` now, after all. Then again, this is nightly, so��� I don't know.Any input on how I should go about this is appreciated. :-/Edit: For the record, @clason [suggested in chat](https://gitter.im/neovim/neovim?at=5fc91a16f46e24660986f9e1) that a full refactor should include `fancy_floating_markdown()` and take into consideration plenary's `popup` module. Both good ideas, but it'll take a while. I'll see what I can do.",
1501680,tkonolige,https://api.github.com/repos/neovim/neovim/pulls/13441,537105893,2020-12-06T19:24:19Z,src/nvim/lua/vim.lua,"@@ -123,7 +123,7 @@ function vim._load_package(name)     local path = ""lua/""..trail:gsub('?',basename)     local found = vim.api.nvim_get_runtime_file(path, false)     if #found > 0 then-      return package.loadlib(found[1])+      return package.loadlib(found[1], ""luaopen_"" .. name)",Good point. I've fixed this and also made the naming more in line with what lua does by default.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/13165,537663041,2020-12-07T16:53:00Z,runtime/lua/vim/lsp/codelens.lua,"@@ -0,0 +1,134 @@+local util = require('vim.lsp.util')+local api = vim.api+--- bufnr -> client_id -> lenses+local lens_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end+})+local active_requests = {}+local M = {}+local namespaces = setmetatable({}, {+  __index = function(t, key)+    local value = api.nvim_create_namespace('vim_lsp_codelens:' .. key)+    rawset(t, key, value)+    return value+  end;+})+++--- Return all lenses for the given buffer+-- TODO: add client_id filter?+function M.get(bufnr)+  local lenses_by_client = lens_cache_by_buf[bufnr]+  if not lenses_by_client then return {} end+  local lenses = {}+  for _, client_lenses in pairs(lenses_by_client) do+    vim.list_extend(lenses, client_lenses)+  end+  return lenses+end+++-- todo: expose get_all() ?++--- Run the code lens in the current line+function M.run()+  local line = api.nvim_win_get_cursor(0)[1]+  local options = vim.tbl_filter(+    function(lens) return lens.range.start.line == (line - 1) end,+    M.get(api.nvim_get_current_buf())+  )+  if #options == 0 then+    print('No executable codelens found at current line')+  elseif #options == 1 then+    vim.lsp.buf.execute_command(options[1].command)+  else+    local options_strings = {""Code lenses:""}+    for i, option in ipairs(options) do+       table.insert(options_strings, string.format('%d. %s', i, option.command.title))+    end+    local choice = vim.fn.inputlist(options_strings)+    if choice < 1 or choice > #options then+      return+    end+    vim.lsp.buf.execute_command(options[choice].command)+  end+end+++local function resolve_lens(cache, idx, lens)+  -- If the chandler should be overridable in vim.lsp.handlers the structure of the cache would need to change+  -- So that the closure is not necessary+  -- Maybe {bufnr -> client_id -> linenr -> lenses}?+  local _, cancel = vim.lsp.buf_request(0, 'codeLens/resolve', lens, function(err, _, result, client_id, bufnr)+    assert(not err, vim.inspect(err))+    if not result then return end+    if result.command then+      local line = result.range.start.line+      local chunks = { {result.command.title, 'LspCodeLens'} }+      local ns = namespaces[client_id]+      api.nvim_buf_set_virtual_text(bufnr, ns, line, chunks, {})+    end+    cache[idx] = result+  end)+  table.insert(active_requests, cancel)+end+++function M.on_codelens(err, _, result, client_id, bufnr)+  assert(not err, vim.inspect(err))+  -- todo, window could have changed, retrieve window using bufnr?+  local wininfo = vim.fn.getwininfo(api.nvim_get_current_win())[1]+  local lenses = {}+  local ns = namespaces[client_id]+  -- Can we avoid flickering? should we track which lens disappeared somehow?+  api.nvim_buf_clear_namespace(bufnr, ns, 1, -1)+  for idx, lens in pairs(result or {}) do+    lenses[idx] = lens+    if lens.command then+      local line = lens.range.start.line+      local chunks = { {lens.command.title, 'LspCodeLens'} }+      api.nvim_buf_set_virtual_text(bufnr, ns, line, chunks, {})+    else+      -- todo: Should there be a different logic to decide whether to resolve the codelens?","I did that in a first version as well, but it doesn't really work for unresolved lenses.If the lens isn't resolved already there isn't anything sensible that could be displayed to the user.For example, language servers like eclipse.jdt.ls provide the option to enable reference counts via code lens.The response just contains lens like this:```data = { ""file:///path/to/file.java"", {        character = 13,        line = 145      }, ""references"" },    range = {      end = {        character = 20,        line = 145      },      start = {        character = 13,        line = 145      }```The `data` part is arbitrary.Once resolved it receives the `command` part in addition:```{  command = {    arguments = { ""file:///path/to/file.java"", {        character = 16,        line = 557      }, { {          range = {            end = {              character = 64,              line = 55            },            start = {              character = 23,              line = 55            }          },          uri = ""file:///path/to/file.java""        } } },    command = ""java.show.references"",    title = ""1 reference""  }}```![image](https://user-images.githubusercontent.com/38700/101379742-e6a87300-38b4-11eb-8b3c-a14cd9f5bb7c.png)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13367,538795485,2020-12-08T20:49:24Z,runtime/lua/vim/treesitter/query.lua,"@@ -92,6 +92,77 @@ local function read_query_files(filenames)   return table.concat(contents, '\n') end +local QueryMatch = {}++-- Creates a query match.+-- Contains metadata for the whole match or each individual capture in the match.+-- Match nodes can be accessed by capture id.+-- All nodes can be iterated over using the `iter()` method.+function QueryMatch.new(match)","hmm nothing about this class seems particular to queries or to matches. I have the suspicion that you could just pass in /return both the `match` and `metadata` tables instead of this ""object"" (and thus make `metadata` optional)",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,538812018,2020-12-08T21:14:11Z,runtime/lua/vim/treesitter/query.lua,"@@ -92,6 +92,77 @@ local function read_query_files(filenames)   return table.concat(contents, '\n') end +local QueryMatch = {}++-- Creates a query match.+-- Contains metadata for the whole match or each individual capture in the match.+-- Match nodes can be accessed by capture id.+-- All nodes can be iterated over using the `iter()` method.+function QueryMatch.new(match)",I don't understand quite what you mean exactly. Could you clarify? This object holds match nodes and match metadata for a node or the whole match from a query result. It also adds an api for setting/getting metadata on the match table.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13367,538896628,2020-12-08T23:49:35Z,runtime/lua/vim/treesitter/query.lua,"@@ -92,6 +92,77 @@ local function read_query_files(filenames)   return table.concat(contents, '\n') end +local QueryMatch = {}++-- Creates a query match.+-- Contains metadata for the whole match or each individual capture in the match.+-- Match nodes can be accessed by capture id.+-- All nodes can be iterated over using the `iter()` method.+function QueryMatch.new(match)","> This object holds match nodes and match metadata for a node or the whole match from a query result. It also adds an api for setting/getting metadata on the match table.This what I meant. you could just pass/return these two values, the match (as it was before), and the metadata table.",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,539277850,2020-12-09T12:47:31Z,runtime/lua/vim/treesitter/query.lua,"@@ -92,6 +92,77 @@ local function read_query_files(filenames)   return table.concat(contents, '\n') end +local QueryMatch = {}++-- Creates a query match.+-- Contains metadata for the whole match or each individual capture in the match.+-- Match nodes can be accessed by capture id.+-- All nodes can be iterated over using the `iter()` method.+function QueryMatch.new(match)","If we go that route we need some way to get the metadata out to the consumer. We would have to emit it from the iterator as a third return value instead of having the data attached to the match.```luafor pattern, match, metadata in query:iter_matches(...) doend```This would also require directives to take an additional metadata table to write to instead of using the api on the match. If these changes are fine, I will implement them.",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/13367,540142925,2020-12-10T12:50:16Z,runtime/lua/vim/treesitter/query.lua,"@@ -92,6 +92,77 @@ local function read_query_files(filenames)   return table.concat(contents, '\n') end +local QueryMatch = {}++-- Creates a query match.+-- Contains metadata for the whole match or each individual capture in the match.+-- Match nodes can be accessed by capture id.+-- All nodes can be iterated over using the `iter()` method.+function QueryMatch.new(match)",@vigoux Should we separate the metadata from the match that I mentioned above?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13367,540252386,2020-12-10T15:17:42Z,runtime/lua/vim/treesitter/query.lua,"@@ -92,6 +92,77 @@ local function read_query_files(filenames)   return table.concat(contents, '\n') end +local QueryMatch = {}++-- Creates a query match.+-- Contains metadata for the whole match or each individual capture in the match.+-- Match nodes can be accessed by capture id.+-- All nodes can be iterated over using the `iter()` method.+function QueryMatch.new(match)","I think is better as then a plugin that don't care about metadata (as the plugin does its own filtering from the matches) can just get matches as a simple table. The alternative would be a table with both `nodes` and `metadata` attribute but secret metatable with secret upvales is an anti-pattern. lua objects do not have ""slots"" and we should not pretend they do.",
486807,dm1try,https://api.github.com/repos/neovim/neovim/pulls/13482,541648646,2020-12-12T16:23:02Z,test/functional/lua/vim_spec.lua,"@@ -1453,3 +1453,25 @@ describe('lua stdlib', function()     end)   end) end)++describe('vim._load_package', function()+  describe('with a script that contains a syntax error', function()++    before_each(function()+      command('set rtp+=test/functional/fixtures')+    end)++    after_each(function()+      command('set rtp-=test/functional/fixtures')+    end)++    it('raises an error', function()+      local syntax_error_msg = exec_lua [[+        _, err = pcall(vim._load_package, ""syntax_error"")","> This is completely missing the context. ""searcher function"" is a public interface of liblua. The actual public interface that neovim expects its plugins/users to use is require, alternatively vim.api.nvim_get_runtime_file to bypass the package system (needed to load non-.lua files, like fennel). vim._load_package is an implementation detail as it could be changed/removed from 0.5 to 0.6 and plugins should not depend on it, which is that the vim._ prefix indicates.there is no ""actual"" public interface(does the ""actual"" mean the thing that **you** want to test here?), there are just public interfaces from different components in the stack. the test suite can contain tests for the any component(its public interface) in the stack. A part of test suite can cover client requirements for neovim plugin users but it does not mean that each test should do it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13482,541737257,2020-12-12T19:11:22Z,test/functional/lua/vim_spec.lua,"@@ -1453,3 +1453,25 @@ describe('lua stdlib', function()     end)   end) end)++describe('vim._load_package', function()+  describe('with a script that contains a syntax error', function()++    before_each(function()+      command('set rtp+=test/functional/fixtures')+    end)++    after_each(function()+      command('set rtp-=test/functional/fixtures')+    end)++    it('raises an error', function()+      local syntax_error_msg = exec_lua [[+        _, err = pcall(vim._load_package, ""syntax_error"")","> there is no ""actual"" public interface(does the ""actual"" mean the thing that you want to test here?), there are just public interfaces from different components in the stack.Maybe my wording was sub-optimal but the distinction I mention does make *actual* sense once you consider stability over multiple versions. Plugins are of course perfectly free to exploit any interface of any level of the implementation stack, but there **must** be a distinction of what interfaces it becomes **neovim's** problem if we break them in the future, as opposed to the plugins (or a dependency fucking up, though from the users POV that is also neovim's problem to deal with). In this case: we say `require` is a recommended interface we want to continue to work even given potential heavy further refactors in the future (same with the runtime API functions), but `vim._load_package` is a implementation detail that can change or be removed at any given moment.  Now you can of course unit test it but the primary focus of functional tests should be user/plugin observable behaviour that neovim considers itself responsible to preserve (within reasonable effort).",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/13540,544442605,2020-12-16T16:30:59Z,ci/build.ps1,"@@ -113,16 +87,16 @@ elseif ($compiler -eq 'MSVC') {  if (-not $NoTests) {   # Setup python (use AppVeyor system python)-  C:\Python27\python.exe -m pip install pynvim ; exitIfFailed-  C:\Python35\python.exe -m pip install pynvim ; exitIfFailed++  C:\hostedtoolcache\windows\Python\2.7.18\x64\python.exe -m pip install pynvim ; exitIfFailed",Might be better to use [Get-ToolcacheToolDirectory](https://github.com/actions/virtual-environments/blob/fc8402e007bc3b7ae4a449edd57dee7a151a331e/images/win/scripts/ImageHelpers/InstallHelpers.ps1#L297-L301) or `$env:AGENT_TOOLSDIRECTORY`.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13561,546275103,2020-12-19T19:41:23Z,runtime/doc/options.txt,"@@ -2438,7 +2438,6 @@ A jump table for the options with a short description can be found at |Q_op|. 'foldcolumn' 'fdc'	string (default ""0"") 			local to window 	When and how to draw the foldcolumn. Valid values are:-	    ""auto"":       resize to the maximum amount of folds to display.",I know. I'm going to update the code to alias it to `auto:9`. Useful to hide the internal limit because max foldcolumns was reduced from 12 to 9.,
3149669,CalinLeafshade,https://api.github.com/repos/neovim/neovim/pulls/13414,546372055,2020-12-20T12:43:01Z,runtime/lua/vim/lsp.lua,"@@ -1110,6 +1111,30 @@ function lsp.buf_notify(bufnr, method, params)   return resp end ++--- Get the details of the completion item+function lsp.on_complete_done()+  local bufnr = resolve_bufnr()+  local completed_item_var = vim.v.completed_item+  if+    completed_item_var and+    completed_item_var.user_data and+    completed_item_var.user_data.nvim and","I'm not sure if this path is universally correct.In my ts-server setup the correct path is `completed_item_var.user_data.lsp.completion_item` (without the ""nvim"" prop)",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13561,546392240,2020-12-20T15:34:12Z,runtime/doc/options.txt,"@@ -2438,7 +2438,6 @@ A jump table for the options with a short description can be found at |Q_op|. 'foldcolumn' 'fdc'	string (default ""0"") 			local to window 	When and how to draw the foldcolumn. Valid values are:-	    ""auto"":       resize to the maximum amount of folds to display.",https://github.com/neovim/neovim/blob/master/src/nvim/option.c#L7097-L7128`set signcolumn=auto` behaves as `set signcolumn=auto:1`.,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/13294,546435444,2020-12-20T20:57:57Z,runtime/lua/vim/lsp/handlers.lua,"@@ -24,6 +24,48 @@ M['workspace/executeCommand'] = function(err, _)   end end +-- @msg of type ProgressParams+-- Basically a token of type number/string+local function progress_callback(_, _, params, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    err_message(""LSP["", client_id, ""] client has shut down after sending the message"")+  end+  local val = params.value    -- unspecified yet+  local token = params.token  -- string or number+++  if val.kind then+    if val.kind == 'begin' then+      client.messages.progress[token] = {+        title = val.title,+        message = val.message,+        percentage = val.percentage,+        -- spinner = 1",I test with this crude https://github.com/teto/home/blob/master/config/nvim/lua/statusline.lua . The spinner could be added later on.,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/12080,546579388,2020-12-21T08:48:05Z,runtime/doc/options.txt,"@@ -6280,6 +6280,29 @@ A jump table for the options with a short description can be found at |Q_op|. 	attributes instead of ""cterm"" attributes. |highlight-guifg| 	Requires an ISO-8613-3 compatible terminal. +						*'termpastefilter'* *'tpf'*+'termpastefilter' 'tpf'	string	(default: """")","This is to prevent problems such as `\x1b[201~` being included in the text to be pasted, which would cause the bracketed paste mode to complete. As far as I know, `xterm` and `mintty` have such an option. Also, although I couldn't find the option in the manual, `tmux` also converts `\x1b` to `^[` when pasting.  #### man xterm```disallowedPasteControls (class DisallowedPasteControls)               The allowPasteControls resource is normally used to prevent pasting C1 controls, as well as non-formatting C0 controls such as the ASCII               escape character.  Those characters are simply ignored.  This resource further extends the set of control characters which cannot be pasted,               converting each into a space.```#### man mintty```Filtering pasted text (FilterPasteControls=)         With this setting, pasted text can be filtered for selected control characters which are then replaced by space. Filtering is not applied when         Control is held while pasting. The option is a comma-separated list of character tags:```",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/10848,548938214,2020-12-26T03:37:24Z,test/functional/ui/searchhl_spec.lua,"@@ -159,7 +160,15 @@ describe('search highlighting', function()     ]])     feed('/foo')     helpers.poke_eventloop()-    screen:expect_unchanged()+    screen:expect{grid=[[",This is what I expect after `/foo`. Maybe the current behavior is a longstanding bug.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13607,549025709,2020-12-26T19:55:09Z,src/nvim/testdir/test_cmdline.vim,"@@ -51,6 +51,19 @@ func Test_complete_wildmenu()   call feedkeys("":e Xdir1/\<Tab>\<Down>\<Up>\<Right>\<CR>"", 'tx')   call assert_equal('testfile1', getline(1)) +  +  "" <C-J>/<C-K> mappings to go up/down directories when 'wildcharm' is+  "" different than 'wildchar'.+  set wildcharm=<C-Z>",bed9839 should always work as it is enabled unconditionally.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/13649,550436371,2020-12-31T09:13:40Z,runtime/lua/vim/lsp/handlers.lua,"@@ -149,6 +149,28 @@ M['workspace/applyEdit'] = function(_, _, workspace_edit)   } end +--@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_configuration+M['workspace/configuration'] = function(err, _, params, client_id)+  local client = vim.lsp.get_client_by_id(client_id)",Should there also be a `nil` check for the `client` similar to how it's done here?https://github.com/neovim/neovim/commit/fb90b6ec9803fdbd603b1d5f1685583218c18909#diff-728d3ae352b52f16b51a57055a3b20efc4e992efacbf1c34426dfccbba30037cR73,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/13658,550753366,2021-01-01T10:08:44Z,runtime/lua/vim/lsp/util.lua,"@@ -31,6 +31,36 @@ local function split_lines(value)   return split(value, '\n', true) end +function M.add_hook_after(func, new_fn)+  if func then+    return function(...)+      -- TODO which result?+      func(...)+      return new_fn(...)+    end+  else+    return new_fn+  end+end++function M.wrap_on_init(config)+  return M.add_hook_after(config.on_init,","Based on the discussion in the other issue, I wonder if Neovim should just always send the `didChangeConfiguration` notification by default? It sounded as if there isn't really a scenario where a user would want to opt-out of it.If not and we leave that up to users to opt-in, then I'm not sure if this is the right trade-off between coupling `on_init`/`didChangeConfiguration` and convenience sugar for users.Currently users would have to add:```luaconfig.on_init = function(client, initialize_result)  client.notify('workspace/didChangeConfiguration', {settings = client.config.settings})`  ...end```Instead of:```luaconfig = vim.lsp.util.wrap_on_init(config)```I think that the first variant is already simple enough.But if we wanted to make it even easier and keep the validation aspect we could add something like `vim.lsp.util.make_validated_settings_params()` or `vim.lsp.util.make_configuration_params()` to create the payload. That would follow the existing pattern of having `util` functions to create request params, and it would split up the IO related parts and the pure function parts.Or remove the `on_init` coupling and create something like this:```luaconfig.on_init = vim.lsp.util.add_did_change_configuration_notify(config.on_init)```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/13649,550753585,2021-01-01T10:12:20Z,runtime/lua/vim/lsp/handlers.lua,"@@ -149,6 +149,32 @@ M['workspace/applyEdit'] = function(_, _, workspace_edit)   } end +--@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_configuration+M['workspace/configuration'] = function(err, _, params, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  local client_name = client and client.name or string.format(""id=%d"", client_id)+  if not client then+    err_message(""LSP["", client_name, ""] client has shut down after sending the message"")+  end",My suggestion still keeps the same error reporting format as there was before - it just removed the `client and client.name` case which is dead code. `client.name` is never used. If the `client` is available then the `if` branch is skipped.,X
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13642,550799954,2021-01-01T19:43:53Z,runtime/lua/vim/lsp/handlers.lua,"@@ -101,6 +101,30 @@ M['window/showMessageRequest'] = function(_, _, params)   end end +--@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#client_registerCapability+M['client/registerCapability'] = function(_, _, params, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  local registrations = params['registrations']+  for _, registration in pairs(registrations) do+    local method = registration.method+    local server_capability = vim.lsp._request_name_to_server_capability[method]+    if server_capability then+      client.resolved_server_capabilities[server_capability] = true;","If this was the case, then `client.resolved_server_capabilities[server_capability]` would just add a new entry to the table, but since `vim.lsp._request_name_to_server_capability[method]` always maps to a key already supported in the table, this should always work.  I think any logging hook that fires when `server_capability != nil` *should* be dead code.There's another, bigger problem that I just realized. `client.resolved_server_capabilities[server_capability]` is not always a boolean, it can also take the form of a table.See this example from the spec.```json{	""method"": ""client/registerCapability"",	""params"": {		""registrations"": [			{				""id"": ""79eee87c-c409-4664-8102-e03263673f6f"",				""method"": ""textDocument/willSaveWaitUntil"",				""registerOptions"": {					""documentSelector"": [						{ ""language"": ""javascript"" }					]				}			}		]	}}```In this particular example, this PR has the correct behavior as textDocument/willSaveWaitUnti is not in  `vim.lsp._request_name_to_server_capability`, so the conditional fails. However, type_definition can be of type `boolean | TypeDefinitionOptions | TypeDefinitionRegistrationOptions`, so this PR would overwrite whatever value with true, and ignore registerOptions which is undesirable.I need to double check that it's always ok to just replace whatever is in client.resolved_server_capabilities[server_capability] with the table returned by register options",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13649,550801991,2021-01-01T20:07:47Z,runtime/lua/vim/lsp/handlers.lua,"@@ -149,6 +149,31 @@ M['workspace/applyEdit'] = function(_, _, workspace_edit)   } end +--@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_configuration+M['workspace/configuration'] = function(err, _, params, client_id)+  local client = vim.lsp.get_client_by_id(client_id)+  if not client then+    err_message(""LSP[id="", client_id, ""] client has shut down after sending the message"")+  end+  if err then error(vim.inspect(err)) end+  if not params.items then+    return {}+  end++  local result = {}+  for _, item in ipairs(params.items) do+    if item.section then+      local value = util.lookup_section(client.config.settings, item.section) or vim.NIL+      -- For empty sections with no explicit '' key, return settings as is+      if value == vim.NIL and item.section == '' then+        value = client.config.settings or vim.NIL","I guess there is the corner case to worry about, where in the array of ConfigurationParams.items, the first item requests an section that is empty  ('') (adding client.config.settings to the table), and the second item requests one that is not empty (adding a specific setting to the table).something like:```luaparams = {    items = {         { section = ''}        { section = 'python.analysis.autoSearchPaths'}    }}```I don't know if there *is* a server that does this (it would probably be a bug), but I think we should respond to the entire list of items to comply with the spec.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13652,550817093,2021-01-01T22:59:10Z,runtime/lua/vim/lsp/handlers.lua,"@@ -28,8 +28,9 @@ end -- Basically a token of type number/string local function progress_callback(_, _, params, client_id)   local client = vim.lsp.get_client_by_id(client_id)+  local client_name = client and client.name or string.format(""id=%d"", client_id)   if not client then-    err_message(""LSP["", client_id, ""] client has shut down after sending the message"")+    err_message(""LSP["", client_name, ""] client has shut down after sending the message"")","This is dead code, I will fix in another PR, but in the cases where`if not client` is true, triggering the error handler, client_name will always equal `string.format(""id=%d"", client_id)`",X
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13657,550902086,2021-01-02T17:24:06Z,src/nvim/os/env.c,"@@ -395,9 +395,16 @@ void os_get_hostname(char *hostname, size_t size)  /// To get the ""real"" home directory: ///   - get value of $HOME+/// For Windows:",Rewrite the function description to use an ordered list in order to disambiguate each step.,
13974112,ckipp01,https://api.github.com/repos/neovim/neovim/pulls/13659,550984279,2021-01-03T10:04:10Z,runtime/doc/lsp.txt,"@@ -758,6 +758,11 @@ start_client({config})                                *vim.lsp.start_client()*                     {init_options}     Values to pass in the initialization                                        request as `initializationOptions` .                                        See `initialize` in the LSP spec.+                    {settings}         User-specified settings to be passed to +                                       server via `workspace/didChangeConfiguration`.+                    {send_settings}    (default=true) Send settings via ","I don't believe I've ever seen a setting like this before in other clients. Out of curiosity, what would be a situation where it'd be bad to send these, and a user would want to set this to `false`?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13673,551004039,2021-01-03T13:08:49Z,src/nvim/api/vim.c,"@@ -990,6 +990,42 @@ void nvim_set_option(uint64_t channel_id, String name, Object value, Error *err)   set_option_to(channel_id, NULL, SREQ_GLOBAL, name, value, err); } +/// Echo a message.+///+/// @param str Message+/// @param opts Optional parameters. Keys:+///          - hl_group: name of the highlight group used to highlight.+///          - history: if true, add to |message-history|.+void nvim_echo(String str, Dictionary opts, Error *err)","I would like to eventually support full highlighting similar to virt text i e  `[[""text"", hl_1], ["" more text"", hl_2]]` , not sure if we should prepare for that here or better to make a separate function.",x
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13673,551023781,2021-01-03T16:04:35Z,src/nvim/api/vim.c,"@@ -990,6 +990,42 @@ void nvim_set_option(uint64_t channel_id, String name, Object value, Error *err)   set_option_to(channel_id, NULL, SREQ_GLOBAL, name, value, err); } +/// Echo a message.+///+/// @param str Message+/// @param opts Optional parameters. Keys:+///          - hl_group: name of the highlight group used to highlight.+///          - history: if true, add to |message-history|.+void nvim_echo(String str, Dictionary opts, Error *err)","I'm leaning toward the last option (we want an option dict regardless, i e for more metadata for external UI:s later on).",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/13697,552182337,2021-01-05T20:42:17Z,runtime/lua/vim/lsp/util.lua,"@@ -121,50 +121,61 @@ local function get_line_byte_from_position(bufnr, position) end  --- Process and return progress reports from lsp server-function M.get_progress_messages()+function M.get_progress_messages(bufnr)    local new_messages = {}   local msg_remove = {}   local progress_remove = {} +  local uri = vim.uri_from_bufnr(bufnr)++  -- TODO: add function argument to specify a client id   for _, client in ipairs(vim.lsp.get_active_clients()) do-      local messages = client.messages-      local data = messages-      for token, ctx in pairs(data.progress) do--        local new_report = {-          name = data.name,-          title = ctx.title or ""empty title"",-          message = ctx.message,-          percentage = ctx.percentage,-          progress = true,-        }-        table.insert(new_messages, new_report)+    local messages = client.messages+    local data = messages++    for token, ctx in pairs(data.progress) do+      local new_report = {+        name = client.name,+        id = client.id,","This is the function that processes _all_ of the clients attached the buffer and returns a single list of normalized message objects that are parseable by status line formatters. To your point about the log messaging, I thought it would be useful to provide callers with the client id of the client that produced the message.",
36219739,chentoast,https://api.github.com/repos/neovim/neovim/pulls/13719,554514251,2021-01-10T05:31:37Z,src/nvim/ex_getln.c,"@@ -3928,6 +3929,7 @@ nextwild (   i = (int)(xp->xp_pattern - ccline.cmdbuff);   assert(ccline.cmdpos >= i);   xp->xp_pattern_len = (size_t)ccline.cmdpos - (size_t)i;+  xp->xp_offset = 0;","Do you know of other expansion contexts where this happens? `EXPAND_LUA` is special as far as I can tell in that the context needed for the completion (`xp->xp_pattern`) is longer than the actual part of `ccline.cmdlinebuff` that we are completing. This is primarily due to the completion of nested dicts. Other cases don't seem to have this problem, and built-in vimscript completion doesn't even try to address it: if you evaluate `:let b:tmp = {""a"": {""b"": {""hello"": 5, ""halla"": 6}}}`, and try to complete `:echo b:tmp.a.b.h`, vim simply sets `xp->xp_pattern` to ""h"", and so looks up completion in the global namespace instead of in `b:tmp.a.b`. Similarly, if you try to complete `:echo g:`, vim sets `xp->xp_pattern` to ""g:"", and so all completion results will have a ""g:"" appended in front.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13739,555597259,2021-01-12T08:41:07Z,src/nvim/os/stdpaths.c,"@@ -108,6 +108,34 @@ char *get_xdg_home(const XDGVarType idx)   return dir; } +/// Return nvim log directory+///+/// @return [allocated] ""$XDG_CACHE_HOME/nvim/logs""+char *get_nvim_logpath(void)+  FUNC_ATTR_WARN_UNUSED_RESULT+{+  char *dir = stdpaths_get_xdg_var(kXDGCacheHome);+  if (dir) {+    dir = concat_fnames_realloc(dir, ""nvim"", true);+    dir = concat_fnames_realloc(dir, ""logs"", true);+  }+  else {+    dir = """";+  }+  return dir;",I feel like in retrospect this is dumb and I should have just hardcoded this. Are there any exceptions to the pathing other than windows? I'm not super familiar with the bsds.,x
13974112,ckipp01,https://api.github.com/repos/neovim/neovim/pulls/13757,557681206,2021-01-14T20:32:57Z,runtime/lua/vim/lsp.lua,"@@ -588,6 +588,12 @@ function lsp.start_client(config)       -- process is not alive then the server should exit (see exit notification)       -- its process.       processId = uv.getpid();+      -- Information about the client+      -- since 3.15.0+      clientInfo = {+        name = 'Neovim',+        version = vim.fn.matchstr(vim.fn.execute('version'), [[NVIM \zs[^\n]\+]]) or vim.Nil","lol it's ironic you bring this up because I looked through the file to see if there was a pattern of single or double, and I saw both so just picked single. I can totally change them.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13758,559013754,2021-01-16T19:22:31Z,runtime/doc/starting.txt,"@@ -1338,12 +1338,12 @@ DATA DIRECTORY (DEFAULT) ~ Note: Throughout the user manual these defaults are used as placeholders, e.g. ""~/.config"" is understood to mean ""$XDG_CONFIG_HOME or ~/.config"". -LOG FILE					*$NVIM_LOG_FILE*+LOG FILE					*$NVIM_LOG_FILE* *E5010* Besides 'debug' and 'verbose', Nvim keeps a general log file for internal debugging, plugins and RPC clients. > 	:echo $NVIM_LOG_FILE-Usually the file is ~/.cache/nvim/log unless that path is inaccessible-or if $NVIM_LOG_FILE was set before |startup|.+By default, the file is located at $XDG_CACHE_HOME/nvim/log unless that path ",Also added a note that logs are stored at the standard location now (along with data),
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/13728,559630541,2021-01-18T15:08:22Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -782,10 +783,23 @@ function M.get_virtual_text_chunks_for_line(bufnr, line, line_diags, opts)   -- TODO(tjdevries): Allow different servers to be shown first somehow?   -- TODO(tjdevries): Display server name associated with these?   if last.message then+    local stripped_msg = last.message:gsub(""\r"", """")+    local newline_index, _ = string.find(stripped_msg, ""\n"")+    local diagnostic_msg+    if newline_index then+      if opts.truncated then+        diagnostic_msg = string.sub(stripped_msg, 1, newline_index - 1)+      else+        diagnostic_msg = stripped_msg:gsub(""\n"", "" "")+      end+    else+      diagnostic_msg = stripped_msg+    end+","maybe a better solution would be to expose a option that is a function that takes in the `function(client, message) -> message`. This way people can do whatever they want with the message and we don't have a multiplication of all the possible configurations someone could have.What do you think about doing that?(Also, I'd be fine with changing our  default to only show the first line and a `...` if there is more text on other lines or something, since otherwise the virtual text can be way too big).",X
13974112,ckipp01,https://api.github.com/repos/neovim/neovim/pulls/13728,559647374,2021-01-18T15:33:53Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -782,10 +783,23 @@ function M.get_virtual_text_chunks_for_line(bufnr, line, line_diags, opts)   -- TODO(tjdevries): Allow different servers to be shown first somehow?   -- TODO(tjdevries): Display server name associated with these?   if last.message then+    local stripped_msg = last.message:gsub(""\r"", """")+    local newline_index, _ = string.find(stripped_msg, ""\n"")+    local diagnostic_msg+    if newline_index then+      if opts.truncated then+        diagnostic_msg = string.sub(stripped_msg, 1, newline_index - 1)+      else+        diagnostic_msg = stripped_msg:gsub(""\n"", "" "")+      end+    else+      diagnostic_msg = stripped_msg+    end+","> maybe a better solution would be to expose a option that is a function that takes in the function(client, message) -> message. This way people can do whatever they want with the message and we don't have a multiplication of all the possible configurations someone could have.In some way I can see the benefit of that for sure, but the negative side of this would be that there still isn't an easy way to have a sane default. It's either, you get everything (even though they may be insanely long), or you write your own function to deal with it. The reason I liked this approach was it was just a simple `truncated = true` that would be required.I'd be way more inclined to do your second suggestion:> (Also, I'd be fine with changing our default to only show the first line and a ... if there is more text on other lines or something, since otherwise the virtual text can be way too big).Since I think this is way more sane. If you're ok with doing this, I'm ok with making the change.",X
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12378,559735201,2021-01-18T18:17:10Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,359 @@+#include <stdbool.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/fileio.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define FOREACH_KEY_VALUE(d, k, v, code) \+  for (size_t i = 0; i < d.size; i++) { \+    String k = d.items[i].key; \+    Object *v = &d.items[i].value; \+    code; \+  }++#define FOREACH_ITEM(a, item, code) \",`i` variable name should be a parameter here as order is relevant to lists.,X
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13798,562835253,2021-01-22T18:44:16Z,test/functional/plugin/lsp_spec.lua,"@@ -304,6 +309,7 @@ describe('LSP', function()       }     end)     it('workspace/configuration returns NIL per section if client was started without config.settings', function()+      clear()       fake_lsp_server_setup('workspace/configuration no settings')",Your call! I personally leans towards just using the test RPC class for consistency,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13719,563044137,2021-01-23T09:39:23Z,src/nvim/lua/vim.lua,"@@ -527,4 +527,143 @@ function vim._log_keystroke(char)   end end +--- Generate a list of possible completions for the string.+--- String starts with ^ and then has the pattern.+---+---     1. Can we get it to just return things in the global namespace with that name prefix+---     2. Can we get it to return things from global namespace even with `print(` in front.+function vim._expand_pat(pat, env)+  env = env or _G++  pat = string.sub(pat, 2, #pat)++  if pat == '' then+    local result = vim.tbl_keys(env)+    table.sort(result)+    return result, 0+  end++  -- TODO: We can handle spaces in [] ONLY.+  --    We should probably do that at some point, just for cooler completion.+  -- TODO: We can suggest the variable names to go in []+  --    This would be difficult as well.+  --    Probably just need to do a smarter match than just `:match`++  -- Get the last part of the pattern+  local last_part = pat:match(""[%w.:_%[%]'\""]+$"")+  if not last_part then return {}, 0 end++  local parts, search_index = vim._expand_pat_get_parts(last_part)++  local match_pat = '^' .. string.sub(last_part, search_index, #last_part)+  local prefix_match_pat = string.sub(pat, 1, #pat - #match_pat + 1) or ''++  local final_env = env+  for _, part in ipairs(parts) do+    if type(final_env) ~= 'table' then+      return {}, 0+    end++    -- Normally, we just have a string+    -- Just attempt to get the string directly from the environment+    if type(part) == ""string"" then+      final_env = rawget(final_env, part)+    else+      -- However, sometimes you want to use a variable, and complete on it+      --    With this, you have the power.++      -- MY_VAR = ""api""+      -- vim[MY_VAR]+      -- -> _G[MY_VAR] -> ""api""+      local result_key = part[1]+      if not result_key then+        return {}, 0+      end++      local result = rawget(env, result_key)++      if result == nil then+        return {}, 0+      end++      final_env = rawget(final_env, result)+    end++    if not final_env then","this needs to be `type(final_env) ~= 'table'`, otherwise it won't catch last component not being a table (and it can just as well be outside the `for` loop)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13719,563072240,2021-01-23T10:25:50Z,src/nvim/lua/vim.lua,"@@ -527,4 +527,143 @@ function vim._log_keystroke(char)   end end +--- Generate a list of possible completions for the string.+--- String starts with ^ and then has the pattern.+---+---     1. Can we get it to just return things in the global namespace with that name prefix+---     2. Can we get it to return things from global namespace even with `print(` in front.+function vim._expand_pat(pat, env)+  env = env or _G++  pat = string.sub(pat, 2, #pat)++  if pat == '' then+    local result = vim.tbl_keys(env)+    table.sort(result)+    return result, 0+  end++  -- TODO: We can handle spaces in [] ONLY.+  --    We should probably do that at some point, just for cooler completion.+  -- TODO: We can suggest the variable names to go in []+  --    This would be difficult as well.+  --    Probably just need to do a smarter match than just `:match`++  -- Get the last part of the pattern+  local last_part = pat:match(""[%w.:_%[%]'\""]+$"")+  if not last_part then return {}, 0 end++  local parts, search_index = vim._expand_pat_get_parts(last_part)++  local match_pat = '^' .. string.sub(last_part, search_index, #last_part)+  local prefix_match_pat = string.sub(pat, 1, #pat - #match_pat + 1) or ''++  local final_env = env+  for _, part in ipairs(parts) do+    if type(final_env) ~= 'table' then+      return {}, 0+    end++    -- Normally, we just have a string+    -- Just attempt to get the string directly from the environment+    if type(part) == ""string"" then+      final_env = rawget(final_env, part)+    else+      -- However, sometimes you want to use a variable, and complete on it+      --    With this, you have the power.++      -- MY_VAR = ""api""+      -- vim[MY_VAR]+      -- -> _G[MY_VAR] -> ""api""+      local result_key = part[1]+      if not result_key then+        return {}, 0+      end++      local result = rawget(env, result_key)++      if result == nil then+        return {}, 0+      end++      final_env = rawget(final_env, result)+    end++    if not final_env then","disregard this, we actually want to support final object to be userdata with metatable (my commit below does the proper checks)",
13317164,nghialm269,https://api.github.com/repos/neovim/neovim/pulls/13803,563262538,2021-01-24T09:17:27Z,runtime/lua/vim/lsp/util.lua,"@@ -514,7 +514,8 @@ function M.convert_input_to_markdown_lines(input, contents)        -- Some servers send input.value as empty, so let's ignore this :(       -- assert(type(input.value) == 'string')-      list_extend(contents, split_lines(input.value or ''))+      local stripped_message = string.gsub(input.value or '', ""\\"", """")","Look at the [link](https://github.com/golang/tools/blob/7e51fbd4c416938b4e68e04220e3d47bf6ec33d2/internal/lsp/source/comment.go#L93-L106) provided by @owarai aboved, there aren't too much characters that get escaped.I think we could make a dictionary of them instead. Something like:```lualocal unescapedMap = {  ['\\\\'] = '\\',  ['\\`'] = '`',  ['\\*'] = '*',-- etc.}local stripped_message = input.value or ''for k,v in pairs(unescapedMap) do   stripped_message = string.gsub(stripped_message, k, v)end```(don't know if that's correct lua code)Or we can use some regex magic:```'\\([\\`*{}[\]()#+\-.!_>~|""$%&'\/:;<=?@^])'  -->  '$1'```(cmiir, I don't know regex in lua)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13803,563263106,2021-01-24T09:22:18Z,runtime/lua/vim/lsp/util.lua,"@@ -514,7 +514,8 @@ function M.convert_input_to_markdown_lines(input, contents)        -- Some servers send input.value as empty, so let's ignore this :(       -- assert(type(input.value) == 'string')-      list_extend(contents, split_lines(input.value or ''))+      local stripped_message = string.gsub(input.value or '', ""\\"", """")","I did, in fact, look at their link. Lua doesn't have a regex library (a full regex library would be larger than LuaJIT's entire source code).If you're interested, you can find details about lua pattern matching here: https://www.lua.org/manual/5.1/manual.html#5.4.1",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13842,566677680,2021-01-29T09:11:28Z,src/nvim/ops.c,"@@ -3398,7 +3398,7 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)         bcount_t totsize = 0;         int lastsize = 0;         if (y_type == kMTCharWise-            || (y_type == kMTLineWise && flags & PUT_LINE_SPLIT)) {","hmm this looks messy and weird, and this if condition is not correct (need to duplicate the new check, not remove this one).Can't the issue be solved just by adjusting the if-statement around `mark_adjust` below, which seems like the real root case? ""Skip mark_adjust when adding lines after the last one""",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13842,566704090,2021-01-29T09:55:47Z,src/nvim/ops.c,"@@ -3398,7 +3398,7 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)         bcount_t totsize = 0;         int lastsize = 0;         if (y_type == kMTCharWise-            || (y_type == kMTLineWise && flags & PUT_LINE_SPLIT)) {","Yes, just try loosen the condition, i see no reason it wouldn't work.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13854,567376145,2021-01-31T06:52:50Z,src/nvim/api/vim.c,"@@ -2851,3 +2852,117 @@ void nvim_set_decoration_provider(Integer ns_id, DictionaryOf(LuaRef) opts, error:   clear_provider(p); }++///+/// Set matches and start insert completion: see |complete()|.+///+/// @param startcol: Byte offset where the completed text starts.+///                     Any text between startcol and the current+///                     cursor col is replaced by the completion.+/// @param matches: A list of string matches.+/// @param opts: Dictionary. Possible keys:+///                 filterfunc: function used for filtering the+///                     matches. See |nvim_register_filterfunc|.+//+// todo: completefunc with refresh: always+// todo: figure out what to do with ctrl_e and ctrl_l+// todo: what to do if filterfunc != NULL AND completion entry+// has icase/equal set.+String nvim_complete(Integer startcol,+                   Object matches,+                   DictionaryOf(LuaRef) opts,+                   Error *err)+  FUNC_API_SINCE(7)+{+  typval_T tv;+  extern LuaRef *user_filterfunc;+  extern LuaRef *active_filterfunc;+  LuaRef filterfunc;++  if (matches.type != kObjectTypeArray) {+    api_set_error(err, kErrorTypeValidation,+              ""wrong type"");+  }++  if ((State & INSERT) == 0) {+    api_set_error(err, kErrorTypeValidation,+            ""complete() can only be used in Insert mode"");+    goto error;+  }++  // Check for undo allowed here, because if something was already inserted+  // the line was already saved for undo and this check isn't done.+  if (!undo_allowed())+      goto error;++  if (startcol <= 0) {+      goto error;+  }++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object *v = &opts.items[i].value;++    if (strequal(k.data, ""filterfunc"")){+      if (v->type != kObjectTypeLuaRef) {+        api_set_error(err, kErrorTypeValidation,+                ""expected lua function"");+        goto error;+      }+      filterfunc = api_new_luaref(v->data.luaref);",the canonical pattern is `filterfunc = v->data.luaref; v->data.luaref = LUA_NOREF`,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13854,567376716,2021-01-31T06:58:43Z,src/nvim/api/vim.c,"@@ -2851,3 +2852,117 @@ void nvim_set_decoration_provider(Integer ns_id, DictionaryOf(LuaRef) opts, error:   clear_provider(p); }++///+/// Set matches and start insert completion: see |complete()|.+///+/// @param startcol: Byte offset where the completed text starts.+///                     Any text between startcol and the current+///                     cursor col is replaced by the completion.+/// @param matches: A list of string matches.+/// @param opts: Dictionary. Possible keys:+///                 filterfunc: function used for filtering the+///                     matches. See |nvim_register_filterfunc|.+//+// todo: completefunc with refresh: always+// todo: figure out what to do with ctrl_e and ctrl_l+// todo: what to do if filterfunc != NULL AND completion entry+// has icase/equal set.+String nvim_complete(Integer startcol,+                   Object matches,+                   DictionaryOf(LuaRef) opts,+                   Error *err)+  FUNC_API_SINCE(7)+{+  typval_T tv;+  extern LuaRef *user_filterfunc;+  extern LuaRef *active_filterfunc;+  LuaRef filterfunc;++  if (matches.type != kObjectTypeArray) {",do we intend `matches` to change type later? because otherwise we can just declare `Array` in the arg list,
36219739,chentoast,https://api.github.com/repos/neovim/neovim/pulls/13854,567389829,2021-01-31T08:43:43Z,src/nvim/api/vim.c,"@@ -2851,3 +2852,117 @@ void nvim_set_decoration_provider(Integer ns_id, DictionaryOf(LuaRef) opts, error:   clear_provider(p); }++///+/// Set matches and start insert completion: see |complete()|.+///+/// @param startcol: Byte offset where the completed text starts.+///                     Any text between startcol and the current+///                     cursor col is replaced by the completion.+/// @param matches: A list of string matches.+/// @param opts: Dictionary. Possible keys:+///                 filterfunc: function used for filtering the+///                     matches. See |nvim_register_filterfunc|.+//+// todo: completefunc with refresh: always+// todo: figure out what to do with ctrl_e and ctrl_l+// todo: what to do if filterfunc != NULL AND completion entry+// has icase/equal set.+String nvim_complete(Integer startcol,+                   Object matches,+                   DictionaryOf(LuaRef) opts,+                   Error *err)+  FUNC_API_SINCE(7)+{+  typval_T tv;+  extern LuaRef *user_filterfunc;+  extern LuaRef *active_filterfunc;+  LuaRef filterfunc;++  if (matches.type != kObjectTypeArray) {","I just took matches to be an object just for convenience, since we can then just use `object_to_vim` to convert to a vim list.",
36219739,chentoast,https://api.github.com/repos/neovim/neovim/pulls/13854,567391605,2021-01-31T08:51:35Z,src/nvim/edit.c,"@@ -3311,7 +3465,7 @@ static int ins_compl_bs(void)   // Respect the 'backspace' option.   if ((int)(p - line) - (int)compl_col < 0       || ((int)(p - line) - (int)compl_col == 0-          && ctrl_x_mode != CTRL_X_OMNI) || ctrl_x_mode == CTRL_X_EVAL","For some reason, pressing backspace cancels `complete()` based completion, instead of simply refreshing the list of candidates. The test in test_popup.vim references changing this behavior as a todo, so I thought I'd just do a drive by change.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13854,567403512,2021-01-31T10:22:20Z,src/nvim/api/vim.c,"@@ -2851,3 +2852,117 @@ void nvim_set_decoration_provider(Integer ns_id, DictionaryOf(LuaRef) opts, error:   clear_provider(p); }++///+/// Set matches and start insert completion: see |complete()|.+///+/// @param startcol: Byte offset where the completed text starts.+///                     Any text between startcol and the current+///                     cursor col is replaced by the completion.+/// @param matches: A list of string matches.+/// @param opts: Dictionary. Possible keys:+///                 filterfunc: function used for filtering the+///                     matches. See |nvim_register_filterfunc|.+//+// todo: completefunc with refresh: always+// todo: figure out what to do with ctrl_e and ctrl_l+// todo: what to do if filterfunc != NULL AND completion entry+// has icase/equal set.+String nvim_complete(Integer startcol,+                   Object matches,+                   DictionaryOf(LuaRef) opts,+                   Error *err)+  FUNC_API_SINCE(7)+{+  typval_T tv;+  extern LuaRef *user_filterfunc;+  extern LuaRef *active_filterfunc;+  LuaRef filterfunc;++  if (matches.type != kObjectTypeArray) {",you can do this anyway by using `ARRAY_OBJ` macro. Better to use `Array` in signature to get correct metadata.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/13863,568108245,2021-02-01T20:11:04Z,runtime/lua/vim/ui/float.lua,"@@ -0,0 +1,214 @@+local Border = require('vim.ui.border')+local tbl = require('vim.ui.ui_table')","`tbl` can probably just be moved to `ui._utils` or something, and then you can do `tbl_apply_defaults` or something. I think this makes it seem like a much larger module than anticipated.I would not consider `_utils` something that we would necessarily expose for awhile.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13903,572657435,2021-02-09T07:46:19Z,src/nvim/misc1.c,"@@ -798,6 +798,9 @@ int prompt_for_number(int *mouse_used)     cmdline_row = save_cmdline_row;   }   State = save_State;++  ui_call_msg_clear();","too early, doing something equivalent to `echo inputlist([""aa"",""bb""]) + inputlist([""cc"", ""dd""])` should not hide the message after first input. If the issue is specific to spell better fix it in `spell_suggest()`",
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/13903,572847291,2021-02-09T12:33:33Z,src/nvim/misc1.c,"@@ -798,6 +798,9 @@ int prompt_for_number(int *mouse_used)     cmdline_row = save_cmdline_row;   }   State = save_State;++  ui_call_msg_clear();","As far as I could tell, `echo inputlist([""aa"", ""bb""]) + inputlist([""cc"", ""dd""])` had the same behavior with and without my patch.I've changed it and forced-pushed your suggestion anyway :).",
35564679,88maomao,https://api.github.com/repos/neovim/neovim/pulls/11226,575633771,2021-02-13T07:24:35Z,src/nvim/message.c,"@@ -264,6 +264,10 @@ bool msg_attr_keep(char_u *s, int attr, bool keep, bool multiline)   int retval;   char_u *buf = NULL; +  if (quit_more) {",no. we did not bother reading long output till the end and pressed `q`,
24480985,VVKot,https://api.github.com/repos/neovim/neovim/pulls/13851,575699866,2021-02-13T18:47:47Z,src/nvim/edit.c,"@@ -8668,9 +8674,16 @@ static bool ins_tab(void)     can_cindent = false;   } -  // When nothing special, insert TAB like a normal character+  // When nothing special, insert TAB like a normal character.+  bool ts_not_equal_sw = (tabstop_count(curbuf->b_p_vts_array) > 1)","Yeah, I just got too annoyed formatting this fancy condition. Reverting.",
24480985,VVKot,https://api.github.com/repos/neovim/neovim/pulls/13851,575700862,2021-02-13T18:57:44Z,src/nvim/ops.c,"@@ -332,8 +332,9 @@ static void shift_block(oparg_T *oap, int amount)   const int oldstate = State;   char_u *newp;   const int oldcol = curwin->w_cursor.col;-  const int p_sw = get_sw_value(curbuf);-  const int p_ts = (int)curbuf->b_p_ts;+  int p_sw = (int)get_sw_value_indent(curbuf);+  long *p_vts = curbuf->b_p_vts_array;+  const long p_ts = curbuf->b_p_ts;","As mentioned, I moved some variables from int to long to remove compiler warnings. This variable was declared just above as `int` before. I'll remove the ordering change to make it clearer.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13939,575881105,2021-02-14T23:20:51Z,runtime/doc/pi_netrw.txt,"@@ -2745,8 +2745,7 @@ your browsing preferences.  (see also: |netrw-settings|) 				history are saved (as .netrwbook and 				.netrwhist). 				Netrw uses |expand()|on the string.-				 default: the first directory on the-				         |'runtimepath'|+				 default: ~/.local/share/nvim/ (|xdg|)",This is the wrong directory if not using xdg. Stick to `stdpath('data')`.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13951,576631294,2021-02-16T08:27:51Z,src/nvim/ugrid.h,"@@ -20,15 +20,27 @@ struct ugrid {   UCell **cells; }; +static inline UCell *ugrid_get_cell(UGrid *grid, int row, int col)","I don't like this API change at all. I would rather just add the missing check where it causes a crash as an `if` condition,  without complicating the other array accesses for no reason.",
486807,dm1try,https://api.github.com/repos/neovim/neovim/pulls/13744,577878334,2021-02-17T19:16:59Z,test/functional/core/startup_spec.lua,"@@ -458,7 +458,7 @@ describe('user config init', function()    it('loads init.lua from XDG config home by default', function()     clear{ args_rm={'-u' }, env={ XDG_CONFIG_HOME=xconfig }}-+    feed('<cr>') -- confirm ""Conflicting config ..."" message",">  any news ?@teto I checked the assumption above(about `XDG_CONFIG_HOME`) but didn't find anything suspicious.> Error is triggered when neovim sees both an init.lua and init.vim but I haven't looked into why it finds both (leftover from previous state ? )if this is still reproducible , could you re-check if `XDG_CONFIG_HOME` points to ""Xhome/Xconfig""and is this directory removed on each test run(maybe there is some os-specific behavior and [this setup](https://github.com/neovim/neovim/blob/2dd383c943ea31abf30ec1e39fbeb5f5971131aa/test/functional/core/startup_spec.lua#L442-L457) does not work as expected) also, maybe the tests are run in parallel somehow?)",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/13377,579598642,2021-02-20T05:21:08Z,runtime/lua/vim/lsp.lua,"@@ -273,12 +273,13 @@ local function text_document_did_open_handler(bufnr, client)   if not vim.api.nvim_buf_is_loaded(bufnr) then     return   end+  local filetype = nvim_buf_get_option(bufnr, 'filetype')+  local languageId = client.config.languageId(filetype)","We should call this `language_id` or `get_language_id`, since that's the naming convention for lua.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13979,579680539,2021-02-20T16:56:36Z,runtime/lua/vim/lsp.lua,"@@ -811,78 +811,119 @@ local function once(fn)   end end +local function buf_range_to_text(bufnr, range) +  local lines = vim.api.nvim_buf_get_lines(bufnr, range.start_row, range.start_row+range.old_end_row+ 1, false)+  vim.notify(vim.inspect({lines, range.start_row, range.start_row+range.old_end_row+1}))+  if #lines > 1 then+    lines[1] = lines[1]:sub(range.start_column)+    lines[1] = lines[-1]:sub(range.old_end_column)+  else+    lines[1] = lines[1]:sub(range.start_column+1, (range.old_end_column + range.start_column)+1)+  end+  return table.concat(lines, '\n')+end --@private --@fn text_document_did_change_handler(_, bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size) --- Notify all attached clients that a buffer has changed. local text_document_did_change_handler do-  local encoding_index = { [""utf-8""] = 1; [""utf-16""] = 2; [""utf-32""] = 3; }-  text_document_did_change_handler = function(_, bufnr, changedtick,-      firstline, lastline, new_lastline, old_byte_size, old_utf32_size,-      old_utf16_size)+  -- on_bytes handler.+  -- See nvim_buf_attach() -> on_bytes+  text_document_did_change_handler = function(+      _, bufnr, changedtick,+      start_row, start_column, byte_offset,+      old_end_row, old_end_column, old_end_byte_length,+      new_end_row, new_end_column, new_end_byte_length)++    -- TODO: New logging      local _ = log.debug() and log.debug(-      string.format(""on_lines bufnr: %s, changedtick: %s, firstline: %s, lastline: %s, new_lastline: %s, old_byte_size: %s, old_utf32_size: %s, old_utf16_size: %s"",-      bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size),-      nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      string.format(""on_bytes bufnr: %s, changedtick: %s, start_row: %s, "" .. +                    ""start_column: %s, byte_offset: %s, old_end_row: %s, "" ..+                    ""old_end_column: %s, old_end_byte_length: %s, "" ..+                    ""new_end_row: %s, new_end_column: %s, new_end_byte_length: %s"",+                    bufnr, changedtick, start_row, start_column, byte_offset,+                    old_end_row, old_end_column, old_end_byte_length, new_end_row, +                    new_end_column, new_end_byte_length),+      buf_range_to_text(bufnr, {+          start_row = start_row,+          start_column = start_column,+          old_end_row=old_end_row,+          old_end_column = old_end_column,+          })     )      -- Don't do anything if there are no clients attached.     if tbl_isempty(all_buffer_active_clients[bufnr] or {}) then       return     end -    util.buf_versions[bufnr] = changedtick-    -- Lazy initialize these because clients may not even need them.     local incremental_changes = once(function(client)-      local size_index = encoding_index[client.offset_encoding]-      local length = select(size_index, old_byte_size, old_utf16_size, old_utf32_size)-      local lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      local text = buf_range_to_text(bufnr, {+                      start_row = start_row, +                      start_column = start_column,+                      old_end_row=old_end_row,+                      old_end_column = old_end_column,+                      })++      vim.notify(vim.inspect({+        range = {+          -- TODO: UTF??+          -- TODO: Is it old end or new end?+          start = { line = start_row, character = start_column - 1 };+          [""end""] = { line = start_row+old_end_row, character = start_column+old_end_column - 1};+        };+        text = text;+      }))        -- This is necessary because we are specifying the full line including the       -- newline in range. Therefore, we must replace the newline as well.-      if #lines > 0 then-       table.insert(lines, '')-      end+      -- if #lines > 0 then+      --  table.insert(lines, '')+      -- end       return {         range = {-          start = { line = firstline, character = 0 };-          [""end""] = { line = lastline, character = 0 };+          -- TODO: UTF??+          -- TODO: Is it old end or new end?+          start = { line = start_row, character = start_column - 1 };+          [""end""] = { line = start_row+old_end_row, character = start_column+old_end_column - 1};         };-        rangeLength = length;",That was recently deprecated https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_didChange,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13979,579680680,2021-02-20T16:57:40Z,runtime/lua/vim/lsp.lua,"@@ -811,78 +811,119 @@ local function once(fn)   end end +local function buf_range_to_text(bufnr, range) +  local lines = vim.api.nvim_buf_get_lines(bufnr, range.start_row, range.start_row+range.old_end_row+ 1, false)+  vim.notify(vim.inspect({lines, range.start_row, range.start_row+range.old_end_row+1}))+  if #lines > 1 then+    lines[1] = lines[1]:sub(range.start_column)+    lines[1] = lines[-1]:sub(range.old_end_column)+  else+    lines[1] = lines[1]:sub(range.start_column+1, (range.old_end_column + range.start_column)+1)+  end+  return table.concat(lines, '\n')+end --@private --@fn text_document_did_change_handler(_, bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size) --- Notify all attached clients that a buffer has changed. local text_document_did_change_handler do-  local encoding_index = { [""utf-8""] = 1; [""utf-16""] = 2; [""utf-32""] = 3; }-  text_document_did_change_handler = function(_, bufnr, changedtick,-      firstline, lastline, new_lastline, old_byte_size, old_utf32_size,-      old_utf16_size)+  -- on_bytes handler.+  -- See nvim_buf_attach() -> on_bytes+  text_document_did_change_handler = function(+      _, bufnr, changedtick,+      start_row, start_column, byte_offset,+      old_end_row, old_end_column, old_end_byte_length,+      new_end_row, new_end_column, new_end_byte_length)++    -- TODO: New logging      local _ = log.debug() and log.debug(-      string.format(""on_lines bufnr: %s, changedtick: %s, firstline: %s, lastline: %s, new_lastline: %s, old_byte_size: %s, old_utf32_size: %s, old_utf16_size: %s"",-      bufnr, changedtick, firstline, lastline, new_lastline, old_byte_size, old_utf32_size, old_utf16_size),-      nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      string.format(""on_bytes bufnr: %s, changedtick: %s, start_row: %s, "" .. +                    ""start_column: %s, byte_offset: %s, old_end_row: %s, "" ..+                    ""old_end_column: %s, old_end_byte_length: %s, "" ..+                    ""new_end_row: %s, new_end_column: %s, new_end_byte_length: %s"",+                    bufnr, changedtick, start_row, start_column, byte_offset,+                    old_end_row, old_end_column, old_end_byte_length, new_end_row, +                    new_end_column, new_end_byte_length),+      buf_range_to_text(bufnr, {+          start_row = start_row,+          start_column = start_column,+          old_end_row=old_end_row,+          old_end_column = old_end_column,+          })     )      -- Don't do anything if there are no clients attached.     if tbl_isempty(all_buffer_active_clients[bufnr] or {}) then       return     end -    util.buf_versions[bufnr] = changedtick-    -- Lazy initialize these because clients may not even need them.     local incremental_changes = once(function(client)-      local size_index = encoding_index[client.offset_encoding]-      local length = select(size_index, old_byte_size, old_utf16_size, old_utf32_size)-      local lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      local text = buf_range_to_text(bufnr, {+                      start_row = start_row, +                      start_column = start_column,+                      old_end_row=old_end_row,+                      old_end_column = old_end_column,+                      })++      vim.notify(vim.inspect({+        range = {+          -- TODO: UTF??+          -- TODO: Is it old end or new end?+          start = { line = start_row, character = start_column - 1 };+          [""end""] = { line = start_row+old_end_row, character = start_column+old_end_column - 1};+        };+        text = text;+      }))        -- This is necessary because we are specifying the full line including the       -- newline in range. Therefore, we must replace the newline as well.-      if #lines > 0 then-       table.insert(lines, '')-      end+      -- if #lines > 0 then+      --  table.insert(lines, '')+      -- end       return {         range = {-          start = { line = firstline, character = 0 };-          [""end""] = { line = lastline, character = 0 };+          -- TODO: UTF??+          -- TODO: Is it old end or new end?+          start = { line = start_row, character = start_column - 1 };+          [""end""] = { line = start_row+old_end_row, character = start_column+old_end_column - 1};         };-        rangeLength = length;",```	/**	 * The optional length of the range that got replaced.	 *	 * @deprecated use range instead.	 */	rangeLength?: uinteger;```,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13973,579718626,2021-02-20T22:38:54Z,src/nvim/undo.c,"@@ -928,9 +939,129 @@ static u_header_T *unserialize_uhp(bufinfo_T *bi,     return NULL;   } +  // Unserialize all extmark undo information+  ExtmarkUndoObject *extup;+  extmark_undo_vec_t uh_extmark;+  kv_init(uh_extmark);++  while ((c = undo_read_2c(bi)) == UF_ENTRY_MAGIC) {+    bool error = false;+    extup = unserialize_extmark(bi, &error, file_name);+    if (error) {+      kv_destroy(uh_extmark);+      return NULL;+    }+    kv_push(uh_extmark, *extup);+  }++  uhp->uh_extmark = uh_extmark;+   return uhp; } +static bool serialize_extmark(bufinfo_T *bi, ExtmarkUndoObject extup)+{+  ILOG(""-------------------------"");++  undo_write_bytes(bi, (uintmax_t)extup.type, 4);+  ILOG(""%d"", (int)extup.type);++  if (extup.type == kExtmarkSplice) {+      ILOG(""Splicing:"");+    if (!undo_write(bi, (uint8_t *)&(extup.data.splice), sizeof(ExtmarkSplice))) {+        return false;+    }+  } else if (extup.type == kExtmarkMove) {+      ILOG(""Moving:"");+    if (!undo_write(bi, (uint8_t *)&(extup.data.move), sizeof(ExtmarkMove))) {+      return false;+    }+  } else if (extup.type == kExtmarkUpdate) {+      ILOG(""Updating:"");+    if (!undo_write(bi, (uint8_t *)&(extup.data.savepos), sizeof(ExtmarkSavePos))) {+      return false;+    }+  } else if (extup.type == kExtmarkSavePos) {+      ILOG(""Saving Position:"");+    if (!undo_write(bi, (uint8_t *)&(extup.data.savepos), sizeof(ExtmarkSavePos))) {+      return false;+    }+  }","those are dead definitions, you can delete them.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/13793,585741038,2021-03-02T16:58:43Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -212,12 +212,15 @@ local _bufs_waiting_to_update = setmetatable({}, bufnr_and_client_cacher_mt) --- ---@param diagnostics Diagnostic[] ---@return table<number, Diagnostic[]>-local _diagnostic_lines = function(diagnostics)+local _diagnostic_lines = function(diagnostics, bufnr)   if not diagnostics then return end +  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)   local diagnostics_by_line = {}   for _, diagnostic in ipairs(diagnostics) do     local start = diagnostic.range.start+    -- Account for servers that place diagnostics on terminal newline+    start.line = math.min(start.line, buf_line_count - 1)",What do you think of moving this into the loop here https://github.com/neovim/neovim/blob/c1fbc2ddf15b2f44b615f90b2511349ab974cb83/runtime/lua/vim/lsp/diagnostic.lua#L267-L271 so that there's only a single place where we mutate the diagnostics?,X
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/13793,585772369,2021-03-02T17:38:33Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -212,12 +212,15 @@ local _bufs_waiting_to_update = setmetatable({}, bufnr_and_client_cacher_mt) --- ---@param diagnostics Diagnostic[] ---@return table<number, Diagnostic[]>-local _diagnostic_lines = function(diagnostics)+local _diagnostic_lines = function(diagnostics, bufnr)   if not diagnostics then return end +  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)   local diagnostics_by_line = {}   for _, diagnostic in ipairs(diagnostics) do     local start = diagnostic.range.start+    -- Account for servers that place diagnostics on terminal newline+    start.line = math.min(start.line, buf_line_count - 1)","Yeah, I initially did this to save the cost of getting the line count of the buffer, but I realize now it's a super bad idea for the line count in the line cache and the per buffer cache to not match",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14047,587781688,2021-03-04T20:00:02Z,runtime/lua/vim/lsp.lua,"@@ -542,6 +542,12 @@ function lsp.start_client(config)       client_ids[client_id] = nil     end +    if signal ~= 0 then","Yes sorry, I  should've been more verbose.I think the normal graceful exit case is signal 15 (sigterm) with exit code 0.Currently the `or signal ~= 0` condition would lead to a notification in that scenario as well.  I don't think that's what a user wants. Convention is that if code ~= 0, then there was an error.  I  don't think the signal should be part of the condition",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14020,588876548,2021-03-06T12:28:31Z,src/nvim/window.c,"@@ -681,6 +681,9 @@ void win_config_float(win_T *wp, FloatConfig fconfig)     wp->w_hl_needs_update = true;     redraw_later(wp, NOT_VALID);   }++  wp->w_grid.pending_Rows = wp->w_height;","set them in `ui_comp_put_grid` together with the row/col offset, already has the parameter. (think of it telling the compositor the full rectangle instead of just one corner)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14079,589237880,2021-03-08T08:16:24Z,runtime/lua/vim/lsp.lua,"@@ -669,6 +669,15 @@ function lsp.start_client(config)         if client_ids[client_id] then           client._on_attach(bufnr)         end+        -- vim.notify(vim.inspect(client.config.flags))+        -- local allow_incremental_sync = if_nil(client.config.flags.allow_incremental_sync, false)","I have no idea why this check fails here, but right now I'm jut unconditionally storing the last buffer",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14079,589544825,2021-03-08T16:09:08Z,runtime/lua/vim/lsp.lua,"@@ -669,6 +669,13 @@ function lsp.start_client(config)         if client_ids[client_id] then           client._on_attach(bufnr)         end+        -- local allow_incremental_sync = if_nil(client.config.flags.allow_incremental_sync, false)+        -- if allow_incremental_sync then+        if not client.cached_buffers then+          client.cached_buffers = {}+        end+        client.cached_buffers[bufnr] = nvim_buf_get_lines(bufnr, 0, -1, true)","Re: performance, I don't know. It seems fine on smaller files (not sure if you noticed differently). I think when using start/end_line to filter, it's just finding the difference (on average) over probably 160 characters (unless people are using incredibly long lines), so I think it's likely fine? Debouncing would be very tricky.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14079,589596424,2021-03-08T17:10:22Z,runtime/lua/vim/lsp.lua,"@@ -669,6 +669,13 @@ function lsp.start_client(config)         if client_ids[client_id] then           client._on_attach(bufnr)         end+        -- local allow_incremental_sync = if_nil(client.config.flags.allow_incremental_sync, false)+        -- if allow_incremental_sync then+        if not client.cached_buffers then+          client.cached_buffers = {}+        end+        client.cached_buffers[bufnr] = nvim_buf_get_lines(bufnr, 0, -1, true)","> performance, I don't know. It seems fine on smaller files (not sure if you noticed differently). I think when using start/end_line to filter, it's just finding the difference (on average) over probably 160 characters (unless people are using incredibly long lines), so I think it's likely fine?Yes I think you're right. If it's only computing the diff on the lines affected it should be fast enough.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14020,590194034,2021-03-09T10:32:15Z,src/nvim/screen.c,"@@ -6284,6 +6286,9 @@ void grid_alloc(ScreenGrid *grid, int rows, int columns, bool copy, bool valid)   new.Rows = rows;   new.Columns = columns; +  new.comp_height = rows;","not needed, also `comp_` fields should only be modified by compositior ( think of it as the compositor has a struct for attached floats but as a micro-optimization we keep them in the same physical struct as long as compositor runs in the same thread)",X
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14079,590942020,2021-03-10T02:27:46Z,runtime/lua/vim/lsp/util.lua,"@@ -226,6 +226,165 @@ end -- function M.glob_to_regex(glob) -- end +--@private+--- Finds the first line and column of the difference between old and new lines+--@param old_lines table list of lines+--@param new_lines table list of lines+--@returns (int, int) start_line_idx and start_col_idx of range+local function first_difference(old_lines, new_lines, start_line_idx)+  local line_count = math.min(#old_lines, #new_lines)+  if line_count == 0 then return 1, 1 end+  if not start_line_idx then+    for i = 1, line_count do+      start_line_idx = i+      if old_lines[start_line_idx] ~= new_lines[start_line_idx] then+        break+      end+    end+  end+  local old_line = old_lines[start_line_idx]+  local new_line = new_lines[start_line_idx]+  local length = math.min(#old_line, #new_line)+  local start_col_idx = 1+  while start_col_idx <= length do+    if string.sub(old_line, start_col_idx, start_col_idx) ~= string.sub(new_line, start_col_idx, start_col_idx) then+      break+    end+    start_col_idx  = start_col_idx  + 1+  end+  return start_line_idx, start_col_idx+end+++--@private+--- Finds the last line and column of the differences between old and new lines+--@param old_lines table list of lines+--@param new_lines table list of lines+--@param start_char integer First different character idx of range+--@returns (int, int) end_line_idx and end_col_idx of range+local function last_difference(old_lines, new_lines, start_char, end_line_idx)+  local line_count = math.min(#old_lines, #new_lines)+  if line_count == 0 then return 0,0 end+  if not end_line_idx then+    end_line_idx = -1+  end+  for i = end_line_idx, -line_count, -1  do+    if old_lines[#old_lines + i + 1] ~= new_lines[#new_lines + i + 1] then+      end_line_idx = i+      break+    end+  end+  local old_line+  local new_line+  if end_line_idx <= -line_count then+    end_line_idx = -line_count+    old_line  = string.sub(old_lines[#old_lines + end_line_idx + 1], start_char)+    new_line  = string.sub(new_lines[#new_lines + end_line_idx + 1], start_char)+  else+    old_line  = old_lines[#old_lines + end_line_idx + 1]+    new_line  = new_lines[#new_lines + end_line_idx + 1]+  end+  local old_line_length = #old_line+  local new_line_length = #new_line+  local length = math.min(old_line_length, new_line_length)+  local end_col_idx = -1+  while end_col_idx >= -length do+    local old_char =  string.sub(old_line, old_line_length + end_col_idx + 1, old_line_length + end_col_idx + 1)+    local new_char =  string.sub(new_line, new_line_length + end_col_idx + 1, new_line_length + end_col_idx + 1)+    if old_char ~= new_char then+      break+    end+    end_col_idx = end_col_idx - 1+  end+  return end_line_idx, end_col_idx++end++--@private+--- Get the text of the range defined by start and end line/column+--@param lines table list of lines+--@param start_char integer First different character idx of range+--@param end_char integer Last different character idx of range+--@param start_line integer First different line idx of range+--@param end_line integer Last different line idx of range+--@returns string text extracted from defined region+local function extract_text(lines, start_line, start_char, end_line, end_char)+  if start_line == #lines + end_line + 1 then+    if end_line == 0 then return '' end+    local line = lines[start_line]+    local length = #line + end_char - start_char+    return string.sub(line, start_char, start_char + length + 1)+  end+  local result = string.sub(lines[start_line], start_char) .. '\n'+  for line_idx = start_line + 1, #lines + end_line do+    result = result .. lines[line_idx] .. '\n'+  end+  if end_line ~= 0 then+    local line = lines[#lines + end_line + 1]+    local length = #line + end_char + 1+    result = result .. string.sub(line, 1, length)+  end+  return result+end++--@private+--- Compute the length of the substituted range+--@param lines table list of lines+--@param start_char integer First different character idx of range+--@param end_char integer Last different character idx of range+--@param start_line integer First different line idx of range+--@param end_line integer Last different line idx of range+--@returns (int, int) end_line_idx and end_col_idx of range+local function compute_length(lines, start_line, start_char, end_line, end_char)+  local adj_end_line = #lines + end_line + 1+  local adj_end_char+  if adj_end_line > #lines then+    adj_end_char =  end_char - 1+  else+    adj_end_char = #lines[adj_end_line] + end_char+  end+  if start_line == adj_end_line then+    return adj_end_char - start_char + 1+  end+  local result = #lines[start_line] - start_char + 1+  for line = start_line + 1, adj_end_line -1 do+    result = result + #lines[line] + 1+  end+  result = result + adj_end_char + 1+  return result+end++--- Returns the range table for the difference between old and new lines+--@param old_lines table list of lines+--@param new_lines table list of lines+--@returns table start_line_idx and start_col_idx of range+function M.compute_diff(old_lines, new_lines, start_line_idx, end_line_idx)+  local start_line, start_char = first_difference(old_lines, new_lines, start_line_idx)+  local end_line, end_char = last_difference(vim.list_slice(old_lines, start_line, #old_lines, end_line_idx),",you're passing 4 things to `vim.list_slice` here?,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14091,591015159,2021-03-10T04:19:02Z,test/functional/api/window_spec.lua,"@@ -347,4 +347,32 @@ describe('API/win', function()       eq('', funcs.getcmdwintype())     end)   end)++  describe('hide', function()+    it('can hide current window', function()+      local oldwin = meths.get_current_win()+      command('split')+      local newwin = meths.get_current_win()+      meths.win_hide(newwin)+      eq({oldwin}, meths.list_wins())+    end)+    it('can hide noncurrent window', function()+      local oldwin = meths.get_current_win()+      command('split')+      local newwin = meths.get_current_win()+      meths.win_hide(oldwin)+      eq({newwin}, meths.list_wins())+    end)+    it('does not close the buffer', function()+      local oldwin = meths.get_current_win()+      local oldbuf = meths.get_current_buf()+      local buf = meths.create_buf(true, false)+      local newwin = meths.open_win(buf, true, {+        relative='win', row=3, col=3, width=12, height=3+      })+      meths.win_hide(newwin)+      eq({oldwin}, meths.list_wins())+      eq({oldbuf, buf}, meths.list_bufs())+    end)",can you add a test where you set `bufhidden` for the buffer to be `wipe` and then make sure it wipes it when you hide the window? I think that's the expected behavior.,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14046,591909167,2021-03-10T22:10:43Z,test/functional/treesitter/parser_spec.lua,"@@ -572,28 +600,5 @@ int x = INT_MAX;         eq(result, ""value"")       end)     end)--    describe(""when setting for a capture match"", function()","Is this no longer possible to do, is that why the test is removed?",
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/14046,592374937,2021-03-11T13:50:16Z,test/functional/treesitter/parser_spec.lua,"@@ -572,28 +600,5 @@ int x = INT_MAX;         eq(result, ""value"")       end)     end)--    describe(""when setting for a capture match"", function()",The old implementation had the concept of storing data per node in the metadata strictly for the way offset was storing data. This was removed since we only need the metadata for the match instead of on a capture basis. So this is no longer used and was removed.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13851,592865251,2021-03-12T02:22:37Z,src/nvim/ops.c,"@@ -3061,14 +3061,17 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)     if (gchar_cursor() == TAB) {       /* Don't need to insert spaces when ""p"" on the last position of a        * tab or ""P"" on the first position. */+      int viscol = getviscol();       if (dir == FORWARD-          ? (int)curwin->w_cursor.coladd < curbuf->b_p_ts - 1-          : curwin->w_cursor.coladd > 0)-        coladvance_force(getviscol());-      else+          ? tabstop_padding(viscol, curbuf->b_p_ts, curbuf->b_p_vts_array) != 1+          : curwin->w_cursor.coladd > 0) {+        coladvance_force(viscol);+      } else {         curwin->w_cursor.coladd = 0;-    } else if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)-      coladvance_force(getviscol() + (dir == FORWARD));+      }+    } else if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL) {+        coladvance_force(getviscol() + (dir == FORWARD));",https://github.com/neovim/neovim/blob/master/src/clint.py cannot format so `make lint` cannot not autofix lint errors. https://github.com/neovim/neovim/pull/13289 is WIP for clang-format.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13851,592871156,2021-03-12T02:41:14Z,src/nvim/indent.c,"@@ -396,11 +451,16 @@ int get_breakindent_win(win_T *wp, const char_u *line)    // used cached indent, unless pointer or 'tabstop' changed   if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts-      || prev_tick != buf_get_changedtick(wp->w_buffer)) {+      || prev_tick != buf_get_changedtick(wp->w_buffer)+      || prev_vts != wp->w_buffer->b_p_vts_array) {     prev_line = line;     prev_ts = wp->w_buffer->b_p_ts;     prev_tick = buf_get_changedtick(wp->w_buffer);-    prev_indent = get_indent_str(line, (int)wp->w_buffer->b_p_ts, wp->w_p_list);+    prev_vts = wp->w_buffer->b_p_vts_array;+    prev_indent = get_indent_str_vtab(line,+                                      (int)wp->w_buffer->b_p_ts,","2nd arg is `long`, not int. Why cast b_p_ts? Same issue with the other `get_indent_` function calls.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13851,592871434,2021-03-12T02:42:06Z,src/nvim/indent.c,"@@ -82,6 +91,30 @@ int get_indent_str(const char_u *ptr, int ts, int list)   return count; } +// Count the size (in window cells) of the indent in line ""ptr"", using+// variable tabstops.+// if ""list"" is TRUE, count only screen size for tabs.","`list` is a boolean. Use `bool`, not `int`.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14115,593829189,2021-03-14T02:19:00Z,runtime/lua/vim/lsp.lua,"@@ -1313,5 +1313,29 @@ end -- Define the LspDiagnostics signs if they're not defined already. require('vim.lsp.diagnostic')._define_default_signs_and_highlights() ++--- Registry for client side code action commands.+---+--- This is an extension point for plugins to handle custom commands which are+--- not part of the core language server protocol specification.+---+--- The codeAction response contains commands which are either executed with a+--- function from this registry, or via `vim.lsp.buf.execute_command` if there is+--- no entry for a given command.+---+--- This is a table where the key must be a command name and the value must be+--- function with two arguments.+---+--- The first argument to the function will be the `Command`:+--    Command+--      title: String+--      command: String+--      arguments?: any[]+--+--- The second argument are the params which were sent as payload with the+--- original codeAction request.+lsp.commands = {}","I'm thinking that I'd like to add things to `commands` via a function that can validate the function/object/whatever at registration time (not 100% sure though).Another thing  to consider would be that some commands may want to be registered directly on the client, so we might want to provide a way to do that -- similar to how we do that with handlers.",
24480985,VVKot,https://api.github.com/repos/neovim/neovim/pulls/13851,593876835,2021-03-14T10:19:29Z,src/nvim/indent.c,"@@ -396,11 +451,16 @@ int get_breakindent_win(win_T *wp, const char_u *line)    // used cached indent, unless pointer or 'tabstop' changed   if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts-      || prev_tick != buf_get_changedtick(wp->w_buffer)) {+      || prev_tick != buf_get_changedtick(wp->w_buffer)+      || prev_vts != wp->w_buffer->b_p_vts_array) {     prev_line = line;     prev_ts = wp->w_buffer->b_p_ts;     prev_tick = buf_get_changedtick(wp->w_buffer);-    prev_indent = get_indent_str(line, (int)wp->w_buffer->b_p_ts, wp->w_p_list);+    prev_vts = wp->w_buffer->b_p_vts_array;+    prev_indent = get_indent_str_vtab(line,+                                      (int)wp->w_buffer->b_p_ts,","I just never fixed that after turning args to long. There were `int`s in the original PR, hence we needed casts here.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/13851,593949914,2021-03-14T19:37:35Z,src/nvim/indent.c,"@@ -396,11 +451,16 @@ int get_breakindent_win(win_T *wp, const char_u *line)    // used cached indent, unless pointer or 'tabstop' changed   if (prev_line != line || prev_ts != wp->w_buffer->b_p_ts-      || prev_tick != buf_get_changedtick(wp->w_buffer)) {+      || prev_tick != buf_get_changedtick(wp->w_buffer)+      || prev_vts != wp->w_buffer->b_p_vts_array) {     prev_line = line;     prev_ts = wp->w_buffer->b_p_ts;     prev_tick = buf_get_changedtick(wp->w_buffer);-    prev_indent = get_indent_str(line, (int)wp->w_buffer->b_p_ts, wp->w_p_list);+    prev_vts = wp->w_buffer->b_p_vts_array;+    prev_indent = get_indent_str_vtab(line,+                                      (int)wp->w_buffer->b_p_ts,","```cint get_indent_str_vtab(const char_u *ptr, long ts, long *vts, bool list)```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14115,594579309,2021-03-15T18:20:08Z,runtime/lua/vim/lsp.lua,"@@ -1313,5 +1313,29 @@ end -- Define the LspDiagnostics signs if they're not defined already. require('vim.lsp.diagnostic')._define_default_signs_and_highlights() ++--- Registry for client side code action commands.+---+--- This is an extension point for plugins to handle custom commands which are+--- not part of the core language server protocol specification.+---+--- The codeAction response contains commands which are either executed with a+--- function from this registry, or via `vim.lsp.buf.execute_command` if there is+--- no entry for a given command.+---+--- This is a table where the key must be a command name and the value must be+--- function with two arguments.+---+--- The first argument to the function will be the `Command`:+--    Command+--      title: String+--      command: String+--      arguments?: any[]+--+--- The second argument are the params which were sent as payload with the+--- original codeAction request.+lsp.commands = {}","> I'm thinking that I'd like to add things to commands via a function that can validate the function/object/whatever at registration time (not 100% sure though).Added some basic validation logicPeople could still override the commands completely, not sure if we want to prevent that as well?`handlers` are currently entirely open too.> Another thing to consider would be that some commands may want to be registered directly on the client, so we might want to provide a way to do that -- similar to how we do that with handlers.Would you be okay to follow up on that once somebody asks for it? I think it would be a non-breaking extension",
6456191,DerekStride,https://api.github.com/repos/neovim/neovim/pulls/14046,596867457,2021-03-18T13:29:07Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -297,33 +297,54 @@ function LanguageTree:_get_injections()      for pattern, match, metadata in self._injection_query:iter_matches(root_node, self._source, start_line, end_line+1) do       local lang = nil-      local injection_node = nil+      local ranges = {}       local combined = false +      -- Directives can configure how injections are captured as well as actual node captures.+      -- This allows more advanced processing for determining ranges and language resolution.+      if metadata.content then+        local content = metadata.content++        -- Allow for captured nodes to be used+        if type(content) == ""number"" then+          content = {match[content]}+        end++        if content then+          vim.list_extend(ranges, content)+        end+      end++      if metadata.language then+        lang = metadata.language+      end",I think this is great work allowing the directive's to have control over the language and content of injected nodes. I suggested a similar idea here https://github.com/neovim/neovim/pull/14152 but without the ability to modify the content.Merging this would enable a functioning `downcase!` / `lowercase!` directive in my PR as an example.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/12483,597385204,2021-03-19T03:35:39Z,runtime/autoload/man.vim,"@@ -402,6 +402,13 @@ function! s:format_candidate(path, psect) abort endfunction  function! man#init_pager() abort+  if exists('b:man_pager')+    "" Already inited, occurs as init_pager is called in syntax/man.vim+    "" and ftplugin/man.vim+    return+  endif+  let b:man_pager = 1","Since `b:man_pager` is local to buffer, I guess the mapping will not longer exist after jumping to another man page. Should it be changed to `w:man_pager` instead?",
6655373,andymass,https://api.github.com/repos/neovim/neovim/pulls/14178,599166261,2021-03-23T00:38:53Z,src/nvim/tag.c,"@@ -975,7 +975,8 @@ add_llist_tags(             if (cmd_len > (CMDBUFFSIZE - 5)) {                 cmd_len = CMDBUFFSIZE - 5;             }-            xstrlcat((char *)cmd, (char *)cmd_start, cmd_len);+            snprintf((char *)cmd + len, CMDBUFFSIZE + 1 - len,",Thanks for reviewing and merging.  Oh wow.. you're right about STRNCAT.  I thought for sure it was deprecated and would fail lint. ����,
2062154,steelsojka,https://api.github.com/repos/neovim/neovim/pulls/14252,604067917,2021-03-30T12:52:56Z,runtime/lua/vim/treesitter/query.lua,"@@ -90,13 +90,38 @@ local function new_match_metadata()   return setmetatable({}, match_metatable) end +--- The explicitly set queries from |vim.treesitter.query.set_query()|+local explicit_queries = setmetatable({}, {+  __index = function(t, k)+    local lang_queries = {}+    rawset(t, k, lang_queries)++    return lang_queries+  end,+})++--- Sets the runtime query {query_name} for {lang}+---+--- This allows users to override any runtime files and/or configuration+--- set by plugins.+---@param lang string: The language to use for the query+---@param query_name string: The name of the query (i.e. ""highlights"")+---@param text string: The query text (unparsed).+function M.set_query(lang, query_name, text)+  explicit_queries[lang][query_name] = M.parse_query(lang, text)+end+ --- Returns the runtime query {query_name} for {lang}. -- -- @param lang The language to use for the query -- @param query_name The name of the query (i.e. ""highlights"") -- -- @return The corresponding query, parsed. function M.get_query(lang, query_name)+  if explicit_queries[lang][query_name] then",So this would not run through the inheritance (modeline) logic that the built in queries go through correct?,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14046,604091020,2021-03-30T13:22:30Z,runtime/lua/vim/treesitter/languagetree.lua,"@@ -12,23 +12,23 @@ LanguageTree.__index = LanguageTree -- @param source Can be a bufnr or a string of text to parse -- @param lang The language this tree represents -- @param opts Options table--- @param opts.queries A table of language to injection query strings.---                     This is useful for overriding the built-in runtime file---                     searching for the injection language query per language.+-- @param opts.injections A table of language to injection query strings.+--                        This is useful for overriding the built-in runtime file+--                        searching for the injection language query per language. function LanguageTree.new(source, lang, opts)   language.require_language(lang)   opts = opts or {} -  local custom_queries = opts.queries or {}+  local injections = opts.injections or {}","What do you think about doing someting like `assert(not opts.queries, ""'queries' is no longer supported. Use 'injections' now"")` or something like that?",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14252,604288806,2021-03-30T17:19:17Z,runtime/lua/vim/treesitter/query.lua,"@@ -90,13 +90,38 @@ local function new_match_metadata()   return setmetatable({}, match_metatable) end +--- The explicitly set queries from |vim.treesitter.query.set_query()|+local explicit_queries = setmetatable({}, {+  __index = function(t, k)+    local lang_queries = {}+    rawset(t, k, lang_queries)++    return lang_queries+  end,+})++--- Sets the runtime query {query_name} for {lang}+---+--- This allows users to override any runtime files and/or configuration+--- set by plugins.+---@param lang string: The language to use for the query+---@param query_name string: The name of the query (i.e. ""highlights"")+---@param text string: The query text (unparsed).+function M.set_query(lang, query_name, text)+  explicit_queries[lang][query_name] = M.parse_query(lang, text)+end+ --- Returns the runtime query {query_name} for {lang}. -- -- @param lang The language to use for the query -- @param query_name The name of the query (i.e. ""highlights"") -- -- @return The corresponding query, parsed. function M.get_query(lang, query_name)+  if explicit_queries[lang][query_name] then",This is also what I was thinking of when you submitted your hl-overwrite PR. Which is still useful since you can have your dependent-on-parent language overwrites.,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/14252,604572457,2021-03-31T03:41:49Z,runtime/lua/vim/treesitter/query.lua,"@@ -90,13 +90,38 @@ local function new_match_metadata()   return setmetatable({}, match_metatable) end +--- The explicitly set queries from |vim.treesitter.query.set_query()|+local explicit_queries = setmetatable({}, {+  __index = function(t, k)+    local lang_queries = {}+    rawset(t, k, lang_queries)++    return lang_queries+  end,+})++--- Sets the runtime query {query_name} for {lang}+---+--- This allows users to override any runtime files and/or configuration+--- set by plugins.+---@param lang string: The language to use for the query+---@param query_name string: The name of the query (i.e. ""highlights"")+---@param text string: The query text (unparsed).+function M.set_query(lang, query_name, text)+  explicit_queries[lang][query_name] = M.parse_query(lang, text)+end+ --- Returns the runtime query {query_name} for {lang}. -- -- @param lang The language to use for the query -- @param query_name The name of the query (i.e. ""highlights"") -- -- @return The corresponding query, parsed. function M.get_query(lang, query_name)+  if explicit_queries[lang][query_name] then","I think it's woerd to not go through the inheritance logic here, as one might still want to inherit things anyway, and also because it is ""explicit"" in the modeline when you inherit a query.I am not sure if I am clear but that feels a bit like ""non-standard"" if we don't use the modeline in the overriden queries. ",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14252,604942673,2021-03-31T14:21:51Z,runtime/lua/vim/treesitter/query.lua,"@@ -90,13 +90,38 @@ local function new_match_metadata()   return setmetatable({}, match_metatable) end +--- The explicitly set queries from |vim.treesitter.query.set_query()|+local explicit_queries = setmetatable({}, {+  __index = function(t, k)+    local lang_queries = {}+    rawset(t, k, lang_queries)++    return lang_queries+  end,+})++--- Sets the runtime query {query_name} for {lang}+---+--- This allows users to override any runtime files and/or configuration+--- set by plugins.+---@param lang string: The language to use for the query+---@param query_name string: The name of the query (i.e. ""highlights"")+---@param text string: The query text (unparsed).+function M.set_query(lang, query_name, text)+  explicit_queries[lang][query_name] = M.parse_query(lang, text)+end+ --- Returns the runtime query {query_name} for {lang}. -- -- @param lang The language to use for the query -- @param query_name The name of the query (i.e. ""highlights"") -- -- @return The corresponding query, parsed. function M.get_query(lang, query_name)+  if explicit_queries[lang][query_name] then","I want it to be literally: I pass in a string, please do not do anything else with it.That seems the most straightforward interpretation of `set_query`. You can still construct your query using the modelines and what not, by re-using some of the code we already have, but I'd prefer not to do this magic in `set_query`.We could add a `literal` parameter to it, but I think that would just complicate things more than necessary.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14302,609084233,2021-04-07T21:34:02Z,runtime/doc/lsp.txt,"@@ -1467,6 +1467,25 @@ progress_handler({_}, {_}, {params}, {client_id})                 See also: ~                     https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand +                                           *vim.lsp.handlers.signature_help()*+signature_help({_}, {method}, {result}, {_}, {bufnr}, {config})+                Parameters: ~+                    {config}  table Configuration table.+                              ��� border: (default=nil)+                                ��� Add borders to the floating window+                                ��� See |vim.api.nvim_open_win()|++                See also: ~+                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_declaration@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_definition@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_typeDefinition@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_implementation|lsp-handler| for the method ""textDocument/signatureHelp"">",this line a little long :),
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14344,611093609,2021-04-10T21:09:11Z,runtime/lua/vim/treesitter/query.lua,"@@ -249,7 +249,32 @@ local predicate_handlers = {     end      return false-  end+  end,++  [""in-plain-string-set?""] = (function()+    local sets = {}++    return function(match, _, source, predicate)+      local node = match[predicate[2]]+      local start_row, start_col, end_row, end_col = node:range()+      if start_row ~= end_row then+        return false+      end++      local node_text = M.get_node_text(node, source)+      local set_id = predicate[3]","```{  captures = <1>{ ""variable"", ""keyword"", ""repeat"", ""conditional"", ""constant.macro"", ""include"", ""operator"", ""boolean"", ""punctuation.delimiter"", ""punctuation.bracket"", ""string"", ""constant.builtin"", ""number"", ""function"", ""function.macro"", ""property"", ""_parent"", ""label"", ""type"", ""constant"", ""_u"", ""comment"", ""parameter"", ""error"", ""field"", ""method"", ""namespace"", ""constructor"", ""variable.builtin"", ""exception"", ""keyword.operator"", ""attribute"" },  info = {    captures = <table 1>,    patterns = {      [23] = { { ""not-has-parent?"", 17, ""template_method"", ""function_declarator"", ""call_expression"" } },      [24] = { { ""has-ancestor?"", 16, ""field_declaration"" }, { ""not-has-ancestor?"", 16, ""function_declarator"" } },      [30] = { { ""match?"", 20, ""^[A-Z][A-Z0-9_]+$"" } },      [32] = { { ""eq?"", 21, ""#undef"" } },      [38] = { { ""match?"", 25, ""^_"" } },      [39] = { { ""match?"", 25, ""^m_"" } },      [40] = { { ""match?"", 25, ""_$"" } },      [45] = { { ""has-parent?"", 17, ""template_method"", ""function_declarator"", ""call_expression"" } },      [49] = { { ""match?"", 19, ""^[A-Z]"" }, { ""not-has-parent?"", 19, ""function_declarator"" } },      [51] = { { ""match?"", 19, ""^[A-Z]"" } },      [52] = { { ""match?"", 20, ""^[A-Z][A-Z_0-9]*$"" } },      [56] = { { ""match?"", 28, ""^[A-Z]"" } },      [60] = { { ""match?"", 28, ""^[A-Z]"" } },      [61] = { { ""match?"", 28, ""^[A-Z]"" } },      [62] = { { ""match?"", 28, ""^[A-Z]"" } },      [63] = { { ""match?"", 28, ""^[A-Z]"" } },      [74] = { { ""vim-match?"", 32, ""[?[.*]]?.*$"" } }    }  },```I guess these ids im patterns stay constant for each occurrence of predicate ",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14344,611094873,2021-04-10T21:23:31Z,runtime/lua/vim/treesitter/query.lua,"@@ -249,7 +249,32 @@ local predicate_handlers = {     end      return false-  end+  end,++  [""in-plain-string-set?""] = (function()+    local sets = {}++    return function(match, _, source, predicate)+      local node = match[predicate[2]]+      local start_row, start_col, end_row, end_col = node:range()+      if start_row ~= end_row then+        return false+      end++      local node_text = M.get_node_text(node, source)+      local set_id = predicate[3]",I guess the ID you need is just the parameter that you ignored. Can't say for sure. They ID is at least unique per query file so it needs to be combined with the query file.I think you could even use the predicate table directly```local foo = {'da'}foo[foo] = 'as'print(vim.inspect(foo))```I think the table will not change and it will use the memory address of this table as hash. Can't tell whether this is allowed in Lua or something one can rely on.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14344,611226219,2021-04-11T18:16:19Z,runtime/lua/vim/treesitter/query.lua,"@@ -249,7 +249,32 @@ local predicate_handlers = {     end      return false-  end+  end,++  [""any-of?""] = (function()+    local sets = {}++    return function(match, _, source, predicate)+      local node = match[predicate[2]]+      local node_text = M.get_node_text(node, source)+      local start_row, _, end_row, _ = node:range()+      if start_row ~= end_row then+        return false+      end++      local k = predicate+      local set = sets[k]",But one would need a marker entry to see whether a table miss is because it's not in the table or whether the look-up has not been constructed yet. So it would be pretty similar to the set implementation right now.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14311,611553726,2021-04-12T11:39:44Z,src/nvim/ex_cmds.c,"@@ -3723,32 +3718,53 @@ static buf_T *do_sub(exarg_T *eap, proftime_T timeout,            */           while (subflags.do_ask) {             if (exmode_active) {-              char_u      *resp;-              colnr_T sc, ec;+              if (ex_normal_busy) {",It doesn't work by overriding the filled char below to be `'\n'` when in ex mode confirm mode? it would be good to avoid an extra loop for such a particular special case upfront.https://github.com/neovim/neovim/blob/2e156a3b7d7e25e56b03683cc6228c531f4c91ef/src/nvim/getchar.c#L2242,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12593,611581087,2021-04-12T12:24:21Z,runtime/doc/options.txt,"@@ -2186,6 +2186,26 @@ A jump table for the options with a short description can be found at |Q_op|. 	This option is reset when the 'paste' option is set and restored when 	the 'paste' option is reset. +				*'filechangenotify'* *'fcnotify'*+'filechangenotify' 'fcnotify'	string (default ""off"")","Why are we adding an option for this? If users want/need to deal with these low-level details beyond simply setting 'autoread', they can do that by adding/deleting autocmds (which we can document if needed). I don't see why we would want to crystallize this in a new option (which is largely redundant with 'autoread').",
847299,dtcaciuc,https://api.github.com/repos/neovim/neovim/pulls/14349,612004246,2021-04-12T22:52:28Z,runtime/doc/options.txt,"@@ -5205,11 +5205,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=+		set shellquote= shellxquote= 		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command 		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellpipe=2>&1\ \|\ Out-File\ -Encoding\ UTF8","I omitted it because I was under impression that, for filtering commands, we should not be including error text together with the filtered data that comes out of standard output. However, reading the manual again, it says ```For Win32, the Unix checks are done and additionally ""cmd"" is checked for, which makes the default "">%s 2>&1```So, to be consistent, I will change that to capture error stream as well.I also noticed that, even with `shellredir` configured, I still can't run stuff like `!Select-String` because Vim turns it into `SelectString < filename`. Looks like that pattern is [hardcoded](https://github.com/neovim/neovim/blob/ce976bf3559edca6d3a649c9053fab88959de6cf/src/nvim/ex_cmds.c#L1541), but I don't think it works with PowerShell.",
36219739,chentoast,https://api.github.com/repos/neovim/neovim/pulls/13260,613752834,2021-04-15T04:46:19Z,runtime/lua/vim/treesitter.lua,"@@ -25,12 +25,12 @@ setmetatable(M, {  })  --- Creates a new parser.------ It is not recommended to use this, use vim.treesitter.get_parser() instead.------ @param bufnr The buffer the parser will be tied to--- @param lang The language of the parser--- @param opts Options to pass to the language tree+---+--- It is not recommended to use this, use vim.treesitter.get_parser() instead.+---+--- @param bufnr The buffer the parser will be tied to+--- @param lang The language of the parser+--- @param opts Options to pass to the created language tree function M._create_parser(bufnr, lang, opts)","This isn't that big of a deal, but when I was first trying to read through the source code, I found it confusing that `{create, get}_parser` actually returns a languagetree, which may have multiple parsers. Maybe in the future, a better distinction between language trees and treesitter parsers could be added to the docs.",
29245744,BK1603,https://api.github.com/repos/neovim/neovim/pulls/12593,613781065,2021-04-15T06:09:26Z,runtime/doc/options.txt,"@@ -2186,6 +2186,26 @@ A jump table for the options with a short description can be found at |Q_op|. 	This option is reset when the 'paste' option is set and restored when 	the 'paste' option is reset. +				*'filechangenotify'* *'fcnotify'*+'filechangenotify' 'fcnotify'	string (default ""off"")","One of the reasons were that we might want to support different backends for watching the files. (Some backends support remote filesystems, while libuv doesn't.)Also, we can either have a libuv based watcher for watching the files, or we could check for the changes on `FocusGained` (which came from: https://github.com/neovim/neovim/pull/12531). There's no point in having both of them active at the same time, and I don't think it is possible to verify if the watcher is working, so that we can turn the autoread tui pr ""off"". We can not decide what we should use if we have autoread set. Since the watcher might not work on some filesystems, (like remote filesystems,) setting autoread on those systems would render the option useless. It would be better if we could simply use your autoread tui PR for remote filesystems.Autoread was, before the autoread-tui PR was merged, an option that dictated the behavior of `checktime`. I don't think we ever automatically reloaded a file just because it was changed outside neovim. That is what the issue was all about. What I feel is, autoread currently is supposed to do two separate things:1. Checking for if a file was changed outside of neovim.2. In case the file was changed, seeing if we want to notify the user or if we want to reload the buffer.What autoread has been doing initially is only number 2, although the documentation says it will be doing both 1 & 2, which is where the confusion and false expectations from autoread came from. I think we need to have 2 separate options for these since these are 2 separate things.A user might not want to watch a file using the fs_watch handle at all, but might still want to reload the buffer everytime `:checktime` is executed, because of old configs. Or a user might want to watch a file using `fs_watch`, but might not want it to be reloaded automatically. He would like to be notified for the changes so that he could decide if he wants the file to be reloaded or not. Both of these things can not be controlled by autoread alone.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/13260,613973609,2021-04-15T11:05:12Z,runtime/lua/vim/treesitter.lua,"@@ -25,12 +25,12 @@ setmetatable(M, {  })  --- Creates a new parser.------ It is not recommended to use this, use vim.treesitter.get_parser() instead.------ @param bufnr The buffer the parser will be tied to--- @param lang The language of the parser--- @param opts Options to pass to the language tree+---+--- It is not recommended to use this, use vim.treesitter.get_parser() instead.+---+--- @param bufnr The buffer the parser will be tied to+--- @param lang The language of the parser+--- @param opts Options to pass to the created language tree function M._create_parser(bufnr, lang, opts)","Indeed this is confusing... We will deprecate those functions in a later pr then, and have function like `setup` to simplify things. ",X
847299,dtcaciuc,https://api.github.com/repos/neovim/neovim/pulls/14349,614151650,2021-04-15T15:04:20Z,runtime/doc/options.txt,"@@ -5205,11 +5205,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=+		set shellquote= shellxquote= 		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command 		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellpipe=2>&1\ \|\ Out-File\ -Encoding\ UTF8","I found another potential issue where both `powershell` and `pwsh` seem to have a couple of behavioral quirks:Both `powershell` and `pwsh` considers a binary to have failed if it writes anything to stderr and if `2>&1` is used (it appears that `$?=True` is a ""success"" flag and is equivalent to Unix's `$?=0`)```# Writes to stdout; returns 0PS C:\Users\dtcaciuc\code\neovim\build> .\bin\shell-test.exe REP 3 hello 2>&1; $?0: hello1: hello2: helloTrue# Writes to stderr; returns 0PS C:\Users\dtcaciuc\code\neovim\build> .\bin\shell-test.exe 2>&1; $?ready $False```This results in nvim printing `shell returned 1`. This is also happening only when `2>&1` is used (which is might be the reason why the original config example didn't have it for `shellredir`?)```PS C:\Users\dtcaciuc\code\neovim\build> .\bin\shell-test.exe; $?ready $ True```Additionall, `powershell` also writes out an exception object alongside with the program output an so running `r !bin/shell-test` results in the following, which is not ideal:```bin\shell-test.exe : ready $At line:1 char:1+ bin\shell-test.exe 2>&1 | Out-File -Encoding UTF8 C:\Users\dtcaciuc\A ...+ ~~~~~~~~~~~~~~~~~~~~~~~    + CategoryInfo          : NotSpecified: (ready $ :String) [], RemoteException    + FullyQualifiedErrorId : NativeCommandError```I'm still going through docs to try to see if there's a way to reconcile these.",
847299,dtcaciuc,https://api.github.com/repos/neovim/neovim/pulls/14349,614559212,2021-04-16T04:55:45Z,runtime/doc/options.txt,"@@ -5205,11 +5205,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=+		set shellquote= shellxquote= 		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command 		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellpipe=2>&1\ \|\ Out-File\ -Encoding\ UTF8","Ok, so after digging in this some more, my take on this is that Powershell 5 that comes bundled with Windows has two problematic behaviors* Redirect commands seem to write data in odd encoding as reported in the issue* Whenever caller redirects error stream with 2> and if the executed binary writes anything to error stream, it always turns into an error object (even if the content is a warning), which in turn results in an ugly error trace that I'm not able to silence. I can set ` $ErrorActionPreference = 'SilentlyContinue'` but then it completely discards the error  stream output together with the error object.Unless there's some trick I could not find, I do not think that it's possible to come up with a good config. The error object behaviour be seen in this simple example and I can't figure out how to work around it.```PS C:\Users\dtcaciuc\code\neovim\build> powershell -Command '.\bin\shell-test.exe FOO >out.txt 2>&1'PS C:\Users\dtcaciuc\code\neovim\build> cat .\out.txt.\bin\shell-test.exe : Unknown first argument: FOOAt line:1 char:1+ .\bin\shell-test.exe FOO >out.txt 2>&1+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    + CategoryInfo          : NotSpecified: (Unknown first argument: FOO:String) [], RemoteException    + FullyQualifiedErrorId : NativeCommandError```On the other hand, PowerShell Core (in my case, 7.1.3) seems to behave as expected by default. It produces encoding that Vim understands as-is and it also doesn't seem to automatically turn any error stream content into an error object. Now, the confusing part about this is from what I can gather, it still SHOULD. There's an [experimental feature](https://docs.microsoft.com/en-us/powershell/scripting/learn/experimental-features?view=powershell-7.1#psnotapplyerroractiontostderr) that supposedly needs to be enabled explicitly , but in my case it's off, so I'm not sure what is happening here. Here's an illustration ```PS C:\Users\dtcaciuc\code\neovim\build> pwsh -Command 'Get-ExperimentalFeature PSNotApplyErrorActionToStderr'Name                                Enabled Source                              Description----                                ------- ------                              -----------PSNotApplyErrorActionToStderr         False PSEngine                            Don't have $ErrorActionPreference affect stderr ���PS C:\Users\dtcaciuc\code\neovim\build> pwsh -Command '.\bin\shell-test.exe FOO >out.txt 2>&1'PS C:\Users\dtcaciuc\code\neovim\build> cat .\out.txtUnknown first argument: FOO```Overall, the following is the configuration that works for both PS and PS Core. For PS, this does not tee make output to command window and it produces ugly error traces, but it's functional. For PS Core, it improves on PS behaviour by not printing error objects to output. ```"" PowerShelllet &shell = 'powershell'set shellquote= shellxquote=set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Commandset shellredir=2>&1\ \|\ Out-File\ -Encoding\ UTF8\ %s;\ exit\ $LastExitCodeset shellpipe=2>&1\ \|\ Out-File\ -Encoding\ UTF8\ %s;\ exit\ $LastExitCode```Furthermore, here's a configuration that works even better on PS Core. It causes `:make` and `:r  !<executable>` commands behave identically in my Windows and WSL environments.```"" PowerShell Corelet shell = 'pwsh'set shellquote= shellxquote=set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Commandset shellredir=2>&1\ \|\ Out-File\ %s;\ exit\ $LastExitCodeset shellpipe=2>&1\ \|\ Tee-Object\ %s;\ exit\ $LastExitCode```I intend to modify the test config and help doc to include the first PowerShell config because I assume that's what's available on base Windows machines and test hosts. Please let me know if I should add the additional PowerShell Core config to help document as well.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14411,617162232,2021-04-21T02:44:23Z,test/functional/legacy/prompt_buffer_spec.lua,"@@ -4,150 +4,203 @@ local feed= helpers.feed local source = helpers.source local clear = helpers.clear local feed_command = helpers.feed_command+local call = helpers.call+local meths = helpers.meths+local eq = helpers.eq  describe('prompt buffer', function()-  local screen--  before_each(function()-    clear()-    screen = Screen.new(25, 10)-    screen:attach()-    source([[-      func TextEntered(text)-        if a:text == ""exit""-          set nomodified-          stopinsert-          close-        else-          call append(line(""$"") - 1, 'Command: ""' . a:text . '""')-          set nomodfied-          call timer_start(20, {id -> TimerFunc(a:text)})-        endif-      endfunc--      func TimerFunc(text)-        call append(line(""$"") - 1, 'Result: ""' . a:text .'""')-      endfunc-    ]])-    feed_command(""set noshowmode | set laststatus=0"")-    feed_command(""call setline(1, 'other buffer')"")-    feed_command(""new"")-    feed_command(""set buftype=prompt"")-    feed_command(""call prompt_setcallback(bufnr(''), function('TextEntered'))"")-  end)+  before_each(clear) -  after_each(function()-    screen:detach()-  end)+  describe('(screen test)', function()+    local screen++    before_each(function()+      screen = Screen.new(25, 10)+      screen:attach()+      source([[+        func TextEntered(text)+          if a:text == ""exit""+            set nomodified+            stopinsert+            close+          else+            call append(line(""$"") - 1, 'Command: ""' . a:text . '""')+            set nomodfied+            call timer_start(20, {id -> TimerFunc(a:text)})+          endif+        endfunc++        func TimerFunc(text)+          call append(line(""$"") - 1, 'Result: ""' . a:text .'""')+        endfunc+      ]])+      feed_command(""set noshowmode | set laststatus=0"")+      feed_command(""call setline(1, 'other buffer')"")+      feed_command(""new"")+      feed_command(""set buftype=prompt"")+      feed_command(""call prompt_setcallback(bufnr(''), function('TextEntered'))"")+    end) -  it('works', function()-    screen:expect([[-      ^                         |-      ~                        |-      ~                        |-      ~                        |-      [Prompt]                 |-      other buffer             |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])-    feed(""i"")-    feed(""hello\n"")-    screen:expect([[-      % hello                  |-      Command: ""hello""         |-      Result: ""hello""          |-      % ^                       |-      [Prompt] [+]             |-      other buffer             |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])-    feed(""exit\n"")-    screen:expect([[-      ^other buffer             |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])+    after_each(function()+      screen:detach()+    end)++    it('works', function()+      screen:expect([[+        ^                         |+        ~                        |+        ~                        |+        ~                        |+        [Prompt]                 |+        other buffer             |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+      feed(""i"")+      feed(""hello\n"")+      screen:expect([[+        % hello                  |+        Command: ""hello""         |+        Result: ""hello""          |+        % ^                       |+        [Prompt] [+]             |+        other buffer             |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+      feed(""exit\n"")+      screen:expect([[+        ^other buffer             |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+    end)++    it('editing', function()+      screen:expect([[+        ^                         |+        ~                        |+        ~                        |+        ~                        |+        [Prompt]                 |+        other buffer             |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+      feed(""i"")+      feed(""hello<BS><BS>"")+      screen:expect([[+        % hel^                    |+        ~                        |+        ~                        |+        ~                        |+        [Prompt] [+]             |+        other buffer             |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+      feed(""<Left><Left><Left><BS>-"")+      screen:expect([[+        % -^hel                   |+        ~                        |+        ~                        |+        ~                        |+        [Prompt] [+]             |+        other buffer             |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+      feed(""<End>x"")+      screen:expect([[+        % -helx^                  |+        ~                        |+        ~                        |+        ~                        |+        [Prompt] [+]             |+        other buffer             |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+      feed(""<C-U>exit\n"")+      screen:expect([[+        ^other buffer             |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+        ~                        |+                                 |+      ]])+    end)   end) -  it('editing', function()-    screen:expect([[-      ^                         |-      ~                        |-      ~                        |-      ~                        |-      [Prompt]                 |-      other buffer             |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])-    feed(""i"")-    feed(""hello<BS><BS>"")-    screen:expect([[-      % hel^                    |-      ~                        |-      ~                        |-      ~                        |-      [Prompt] [+]             |-      other buffer             |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])-    feed(""<Left><Left><Left><BS>-"")-    screen:expect([[-      % -^hel                   |-      ~                        |-      ~                        |-      ~                        |-      [Prompt] [+]             |-      other buffer             |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])-    feed(""<End>x"")-    screen:expect([[-      % -helx^                  |-      ~                        |-      ~                        |-      ~                        |-      [Prompt] [+]             |-      other buffer             |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])-    feed(""<C-U>exit\n"")-    screen:expect([[-      ^other buffer             |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-      ~                        |-                               |-    ]])+  describe('(legacy test)', function()+    before_each(function()+      source([=[+        func Test_prompt_buffer_getbufinfo()","In the long run, it would be easier if you ported the entire `Test_prompt_buffer.vim` and modified it to run this test only. I don't mind if you literred most of the test cases there with `throw ""skipped: TODO""`.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/14417,619093704,2021-04-23T09:53:29Z,.github/workflows/release.yml,"@@ -137,6 +137,8 @@ jobs:   publish:     needs: [linux, appimage, macOS, windows]     runs-on: ubuntu-20.04+    permissions:+      contents: write","> Where/how?https://github.com/neovim/neovim/settings/actions> Isn't the default for contents ""read"" anyway (from the link I've posted above)?Nope, almost all scopes are `read/write` by default:https://docs.github.com/en/actions/reference/authentication-in-a-workflow#permissions-for-the-github_tokenAnd important here to note:_When the `permissions` key is used, all unspecified permissions are set to no access, with the exception of the metadata scope, which always gets read access._",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/14418,619244384,2021-04-23T14:00:45Z,runtime/lua/vim/treesitter/query.lua,"@@ -253,7 +253,11 @@ local directive_handlers = {   [""set!""] = function(_, _, _, pred, metadata)     if #pred == 4 then       -- (#set! @capture ""key"" ""value"")-      metadata[pred[2]][pred[3]] = pred[4]+      local capture = pred[2]+      if metadata[capture] == nil then",```suggestion      if not metadata[capture] then```,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14349,621809062,2021-04-28T04:43:51Z,runtime/doc/options.txt,"@@ -5205,11 +5205,25 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=+		set shellquote= shellxquote= 		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command-		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellredir=2>&1\ \|\ Out-File\ -Encoding\ UTF8;\ exit\ $LastExitCode+		set shellpipe=2>&1\ \|\ Out-File\ -Encoding\ UTF8;\ exit\ $LastExitCode++< 	The above should work for all versions of PowerShell, but may result+	in superfluous error object traces with PowerShell 5.1 due to how it+	reacts when a running program writes anything to standard error stream.+	This seems to be fixed in PowerShell versions 7.1 and above. The following",Make your commits atomic such that each commit has a single purpose and passes the build.Squashing everything to 1 commit is fine as long as you can describe every change in 1 commit message.,
29653149,Sh3Rm4n,https://api.github.com/repos/neovim/neovim/pulls/14455,622907294,2021-04-29T10:04:08Z,src/nvim/ex_cmds2.c,"@@ -2719,16 +2719,19 @@ static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)   while (!(p->buf[i] == '\n' || p->buf[i] == '\0')) {     i++;   }-  char buf[2046];-  char *dst;-  dst = xstpncpy(buf, (char *)p->buf + p->offset, i - p->offset);-  if ((uint32_t)(dst - buf) != i - p->offset) {+  size_t line_length = i - p->offset;+  garray_T ga;+  ga_init(&ga, (int)sizeof(char_u), (int)line_length);+  ga_concat_len(&ga, (char *)p->buf + p->offset, line_length);+  if (ga.ga_len != (int)line_length) {","I left that check, but isn't this no longer needed?",
29653149,Sh3Rm4n,https://api.github.com/repos/neovim/neovim/pulls/14455,622908191,2021-04-29T10:05:21Z,src/nvim/ex_cmds2.c,"@@ -2719,16 +2719,19 @@ static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)   while (!(p->buf[i] == '\n' || p->buf[i] == '\0')) {     i++;   }-  char buf[2046];-  char *dst;-  dst = xstpncpy(buf, (char *)p->buf + p->offset, i - p->offset);-  if ((uint32_t)(dst - buf) != i - p->offset) {+  size_t line_length = i - p->offset;+  garray_T ga;+  ga_init(&ga, (int)sizeof(char_u), (int)line_length);+  ga_concat_len(&ga, (char *)p->buf + p->offset, line_length);+  if (ga.ga_len != (int)line_length) {     smsg(_("":source error parsing command %s""), p->buf);     return NULL;   }-  buf[i - p->offset] = '\0';+  ga_append(&ga, '\0');   p->offset = i + 1;-  return (char_u *)xstrdup(buf);+  char_u *line = (char_u *)xstrdup(ga.ga_data);","I'm not sure, if this extra copy is needed, or if I could've just returned `ga.ga_data` directly to avoid a copy. ",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/14455,623825505,2021-04-30T12:05:23Z,src/nvim/ex_cmds2.c,"@@ -2719,16 +2719,19 @@ static char_u *get_str_line(int c, void *cookie, int indent, bool do_concat)   while (!(p->buf[i] == '\n' || p->buf[i] == '\0')) {     i++;   }-  char buf[2046];-  char *dst;-  dst = xstpncpy(buf, (char *)p->buf + p->offset, i - p->offset);-  if ((uint32_t)(dst - buf) != i - p->offset) {+  size_t line_length = i - p->offset;+  garray_T ga;+  ga_init(&ga, (int)sizeof(char_u), (int)line_length);+  ga_concat_len(&ga, (char *)p->buf + p->offset, line_length);+  if (ga.ga_len != (int)line_length) {     smsg(_("":source error parsing command %s""), p->buf);     return NULL;   }-  buf[i - p->offset] = '\0';+  ga_append(&ga, '\0');   p->offset = i + 1;-  return (char_u *)xstrdup(buf);+  char_u *line = (char_u *)xstrdup(ga.ga_data);","Yeah, you can just return `ga.ga_data`.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/14450,624306801,2021-04-30T23:44:24Z,runtime/doc/lua.txt,"@@ -841,10 +841,18 @@ vim.call({func}, {...})					*vim.call()*             vim.fn[func]({...})  vim.cmd({cmd})                                          *vim.cmd()*-        Invokes an Ex command (the "":"" commands, Vimscript statements).+        Executes multiple lines of Vimscript at once. It is an alias to+        |nvim_exec()|, where `output` is set to false. Thus it works identical+        to `|:source|`.","One last thing (my bad, I wrote it in my comment), but the backticks are wrong here. Should be just `|:source|`.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14456,624531970,2021-05-01T16:24:15Z,runtime/lua/vim/lsp/handlers.lua,"@@ -7,6 +7,8 @@ local buf = require 'vim.lsp.buf'  local M = {} +local ns = api.nvim_create_namespace(""lsp/popup"")","I'd recommend making `ns` more descriptive, and `lsp/popup` is ambiguous, maybe `lsp/signature_help`",
32982619,zacmar,https://api.github.com/repos/neovim/neovim/pulls/14456,624670917,2021-05-02T10:28:13Z,runtime/lua/vim/lsp/handlers.lua,"@@ -333,25 +335,41 @@ M['textDocument/implementation'] = location_handler ---     - border:     (default=nil) ---         - Add borders to the floating window ---         - See |vim.api.nvim_open_win()|+---     - parametersOnly: (default=false)+---         - Display only a list of parameters+---     - suppressPrint: (default=false)+---         - Stop printing a message if no signature is available function M.signature_help(_, method, result, _, bufnr, config)   config = config or {}   -- When use `autocmd CompleteDone <silent><buffer> lua vim.lsp.buf.signature_help()` to call signatureHelp handler   -- If the completion item doesn't have signatures It will make noise. Change to use `print` that can use `<silent>` to ignore   if not (result and result.signatures and result.signatures[1]) then-    print('No signature help available')+    if not config.suppressPrint then+      print('No signature help available')+    end     return   end-  local lines = util.convert_signature_help_to_markdown_lines(result)+  local lines, highlights = util.get_signature_help_with_highlights(result, config.parametersOnly or false)   lines = util.trim_empty_lines(lines)   if vim.tbl_isempty(lines) then-    print('No signature help available')+    if not config.suppressPrint then+      print('No signature help available')+    end     return   end   local syntax = api.nvim_buf_get_option(bufnr, 'syntax')+  if syntax == """" then","I have also been experiencing something similar (see also [https://github.com/ray-x/lsp_signature.nvim/issues/13](https://github.com/ray-x/lsp_signature.nvim/issues/13)). Turns out, if I enable treesitter highlighting, I lose the markdown highlighting in the signature help.`init.lua````luavim.cmd('packadd! nvim-lsp')vim.cmd('packadd! nvim-treesitter')vim.api.nvim_set_keymap(""n"", ""gk"", ""<cmd>lua vim.lsp.buf.signature_help()<CR>"", {})require'lspconfig'.gopls.setup{}require'nvim-treesitter.configs'.setup {    highlight = {        enable = true,    },}````nvim -u init.lua test.go`![2021-05-02-122439_859x195_scrot](https://user-images.githubusercontent.com/32982619/116809973-61fb1180-ab41-11eb-97b1-9a1a02f3baa6.png)`init_.lua````luavim.cmd('packadd! nvim-lsp')vim.api.nvim_set_keymap(""n"", ""gk"", ""<cmd>lua vim.lsp.buf.signature_help()<CR>"", {})require'lspconfig'.gopls.setup{}````nvim -u init_.lua test.go`![2021-05-02-122722_837x165_scrot](https://user-images.githubusercontent.com/32982619/116810043-c28a4e80-ab41-11eb-8780-52277d808e84.png)Not sure what the problem is here, of if this is intendet behavior. But I would be interested in how this is resolved.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14462,624687796,2021-05-02T12:35:30Z,runtime/lua/vim/lsp.lua,"@@ -890,6 +890,42 @@ function lsp.start_client(config)     end)   end +  --@private+  --- Sends a request to the server and synchronously waits for the response.+  ---+  --- This is a wrapper around {client.request}+  ---+  --@param method (string) LSP method name.+  --@param params (table) LSP request params.+  --@param timeout_ms (number, optional, default=100) Maximum time in+  ---milliseconds to wait for a result.+  --@param bufnr (number) Buffer handle (0 for current).+  --@returns { err, result }, where `err` and `result` come from the |lsp-handler|.","```suggestion  --@returns { err, result }, where `err` and `result` come from the |lsp-handler|.```By reading the docs I thought this would be a list where the first item is the error and the second item is the result. But reading the code I figured it is a dictionary with `err` and `result` as keys. Maybe that could be clarified in the docs?",X
7303830,kabouzeid,https://api.github.com/repos/neovim/neovim/pulls/14462,624690787,2021-05-02T12:56:15Z,runtime/lua/vim/lsp/buf.lua,"@@ -134,14 +170,58 @@ end --- --@param options Table with valid `FormattingOptions` entries --@param timeout_ms (number) Request timeout+--@see |vim.lsp.buf.formatting_seq_sync| function M.formatting_sync(options, timeout_ms)+  local client = get_formatting_client()+  if client == nil then return end+   local params = util.make_formatting_params(options)-  local result = vim.lsp.buf_request_sync(0, ""textDocument/formatting"", params, timeout_ms)-  if not result or vim.tbl_isempty(result) then return end-  local _, formatting_result = next(result)-  result = formatting_result.result-  if not result then return end-  vim.lsp.util.apply_text_edits(result)+  local result = client.request_sync(""textDocument/formatting"", params, timeout_ms)+  if result and result.result then+    util.apply_text_edits(result.result)+  end",Makes sense to me. Probably a good idea for any API function that has a `timeout_ms` parameter.,
7908,urandom,https://api.github.com/repos/neovim/neovim/pulls/14456,624704422,2021-05-02T14:33:14Z,runtime/lua/vim/lsp/util.lua,"@@ -822,43 +926,30 @@ function M.convert_signature_help_to_markdown_lines(signature_help)   if not signature then     return   end-  vim.list_extend(contents, vim.split(signature.label, '\n', true))-  if signature.documentation then-    M.convert_input_to_markdown_lines(signature.documentation, contents)++  local active_parameter = signature.activeParameter or signature_help.activeParameter or 0","If -1 is meant as a value that indicates no active parameter, then the code will not fail, but instead not highlight any parameter, which would be the intended behaviour.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14406,628813704,2021-05-09T00:37:04Z,src/nvim/search.c,"@@ -4347,121 +4348,288 @@ int linewhite(linenr_T lnum) }  // Add the search count ""[3/19]"" to ""msgbuf"".-// When ""recompute"" is true Always recompute the numbers.-static void search_stat(int dirc, pos_T *pos,-                        bool show_top_bot_msg, char_u *msgbuf, bool recompute)+// See update_search_stat() for other arguments.+static void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos,+                                int show_top_bot_msg, char_u  *msgbuf,+                                int recompute, int maxcount, long timeout)","`bool recompute` is correct.In general, don't change `bool` (or TriState) to `int` unless int values are used.If int values are used, then always use int values even if Vim uses `FALSE` and `TRUE` for int parameters.",
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/14516,628819270,2021-05-09T01:46:06Z,src/nvim/buffer.c,"@@ -4004,6 +4006,28 @@ int build_stl_str_hl(           itemisflag = false;         }       }++      // If the output of the expression needs to be evaluated+      // replace the %{} block with the result of evaluation+      if (str != NULL && *str != 0 && strchr((const char *)str, '%') != NULL) {",I don't think it's necessary as calling something recursively without any end condition is always a bad idea and never ends well .Even currently ```vimfunc Hang()    return Hang()endfuncset stl=%!Hang()```will hang undefinatly. Also since currently the expressions are just expanded . I'm not sure how to add a limit . looking back or forword for recursive calls will surely add overhead,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14490,629018201,2021-05-10T02:45:11Z,src/nvim/quickfix.c,"@@ -3983,17 +4000,54 @@ static int qf_buf_add_line(buf_T *buf, linenr_T lnum, const qfline_T *qfp,   return OK; } +static list_T *call_qftf_func(qf_list_T *qfl,+                              int qf_winid,+                              long start_idx,+                              long end_idx)",Vim uses `long` for the values passed to `dict_add_number` but casting to long is not required for `tv_dict_add_nr` in Neovim.,
364912,sakhnik,https://api.github.com/repos/neovim/neovim/pulls/14537,630892227,2021-05-12T09:47:40Z,src/nvim/diff.c,"@@ -1733,25 +1743,713 @@ void diff_clear(tabpage_T *tp)   diff_T *next_p;   for (p = tp->tp_first_diff; p != NULL; p = next_p) {     next_p = p->df_next;+    if (!p->df_redraw) {","I'd suggest removing the conditions at all. Either p->df_comparisonlines is NULL and xfree() will do nothing, or it's not NULL and free() will release the memory.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/14537,631873315,2021-05-13T14:55:12Z,src/nvim/diff.c,"@@ -1733,25 +1743,713 @@ void diff_clear(tabpage_T *tp)   diff_T *next_p;   for (p = tp->tp_first_diff; p != NULL; p = next_p) {     next_p = p->df_next;+    if (!p->df_redraw) {+      xfree(p->df_comparisonlines);+    }     xfree(p);   }   tp->tp_first_diff = NULL; } +///+/// return true if the options are set to use diff linematch+///+bool diff_linematch(diff_T *dp)+{+  if (!(diff_flags & DIFF_LINEMATCH)) {+        return 0;+  }+  // are there more than three diff buffers?+  int diffbuffers = 0;+  int tsize = 0;+  for (int i = 0; i < DB_COUNT; i++) {+    if ( curtab->tp_diffbuf[i] != NULL ) {+      diffbuffers++;+      tsize += dp->df_count[i];+    }+  }+  // avoid allocating a huge array because it will lag+  if (tsize > linematch_lines) {+    return 0;+  }+  if (diffbuffers <= 3) {  // can diff up to 3 buffers+    return 1;+  }+  return 0;+}++///+/// Count the number of virtual (filler + non filler) lines between ""start"" and+/// ""endline"" in ""win""+///+/// @param win+/// @param start+/// @param endline+int count_virtual_lines(win_T *win, linenr_T start, linenr_T endline)+{+  int virtual_lines = 0;+  for (int k = start; k <= endline; k++) {+    int n = diff_check(win, k, NULL);+    if (n > 0) {+        virtual_lines+=n;  // filler lines+    }+    virtual_lines++;+  }+  return virtual_lines;+}+/// in ""win"" window, move from ""lnum"" down by the amount ""virtual_lines""+/// and return the number of real lines moved. if a non null pointer is+/// passed to ""line_new_virtualp"", it will be set to the number of virtual+/// lines moved+///+/// @param win+/// @param lnum+/// @param virtual_lines+/// @param line_new_virtualp+int count_virtual_to_real(win_T *win, const linenr_T lnum,+                          const int virtual_lines, int *line_new_virtualp )+{+  int real_offset = 0;+  int virtual_offset = 0;+  while (1) {+    int n = diff_check(win, lnum+real_offset, NULL);+    virtual_offset++;+    if (n > 0) {+        virtual_offset+=n;  // filler lines+    }+    if (virtual_offset > virtual_lines) {+        break;+    }+    real_offset++;+  }+  if ( line_new_virtualp != NULL ) {+    (*line_new_virtualp)=virtual_offset;+  }+  return real_offset;+}++/// return the number of matching characters between two strings+///+/// @param s1+/// @param s2+long count_matched_chars(const char_u *s1, const char_u *s2)+{+  long l1=(long)STRLEN(s1), l2=(long)STRLEN(s2);+  if ( diff_flags & DIFF_IWHITE || diff_flags & DIFF_IWHITEALL+      || diff_flags & DIFF_ICASE ) {+    bool iwhite=(diff_flags & DIFF_IWHITEALL || diff_flags & DIFF_IWHITE);+    // the newly processed strings that will be compared+    char_u *s1_proc = xmalloc(STRLEN(s1) * sizeof(char_u));+    char_u *s2_proc = xmalloc(STRLEN(s2) * sizeof(char_u));+    // delete the white space characters,+    // and/or replace all upper case with lower+    char_u *strsproc[2] = { s1_proc, s2_proc };+    const char_u *strsorig[2] = { s1, s2 };+    long slen[2] = { l1, l2 };+    for (int k = 0; k < 2; k++) {+      int d = 0, i = 0;+      while (d+i < slen[k]) {+        if ((iwhite)?(strsorig[k][i+d] != ' ' && strsorig[k][i+d] != '\t'):1) {+          strsproc[k][i] = (diff_flags & DIFF_ICASE)?+           (tolower(strsorig[k][i+d])):(strsorig[k][i+d]);+          i++;+        } else { d++; }+      }+      strsproc[k][i]='\0';+    }+    long l1_nowhite=(long)STRLEN(s1_proc);+    long l2_nowhite=(long)STRLEN(s2_proc);+    long maxlength = l1_nowhite > l2_nowhite?l1_nowhite:l2_nowhite;+    long lev = levenshtein(s1_proc, s2_proc);+    xfree(s1_proc), xfree(s2_proc);+    return maxlength-lev;+  }+  // compare strings without considering the white space+  long maxlength = l1 > l2?l1:l2;+  return maxlength - levenshtein(s1, s2);+}+/// helper function for the diff alignment algorithm copy the newly found+/// optimal path to an index in the tensor for more detailed algorith+/// description, see ""linematch_3buffers"" for the current diff hunk ""dp"",+/// the ""score"" and path at index ""i"",""j"",""k"" is updated from the path+/// from ""_i"",""_j"",""_k"" choice is represented by enum value ""choice""+///+/// @param dp+/// @param df_pathmatrix3+/// @param score+/// @param i+/// @param j+/// @param k+/// @param _i+/// @param _j+/// @param _k+/// @param choice+void update_path3(diff_T *dp, diffcomparisonpath3_T ***df_pathmatrix3,+                  int score, int i, int j, int k, int _i, int _j, int _k,+                  enum path3_choice choice)+{+  df_pathmatrix3[i][j][k].df_lev_score = score;+  for (int __k = 0; __k <= df_pathmatrix3[_i][_j][_k].path_index; __k++) {+    df_pathmatrix3[i][j][k].df_path3[__k]=+      df_pathmatrix3[_i][_j][_k].df_path3[__k]; }+  df_pathmatrix3[i][j][k].path_index = df_pathmatrix3[_i][_j][_k].path_index;+  df_pathmatrix3[i][j][k].df_path3+    [df_pathmatrix3[i][j][k].path_index] = choice;  // this choice+  df_pathmatrix3[i][j][k].path_index++;+}+/// helper function for the diff alignment algorithm copy the newly found+/// optimal path to an index in the tensor for more detailed algorith+/// description, see ""linematch_2buffers"" for the current diff hunk ""dp"",+/// the ""score"" and path at index ""i"",""j""is updated from the path from+/// ""_i"",""_j"",choice is represented by enum value ""choice""+///+/// @param dp+/// @param df_pathmatrix2+/// @param score+/// @param i+/// @param j+/// @param _i+/// @param _j+/// @param choice+void update_path2(diff_T *dp, diffcomparisonpath2_T **df_pathmatrix2,+                  int score, int i, int j, int _i, int _j,+                  enum path2_choice choice)+{+  df_pathmatrix2[i][j].df_lev_score = score;+  for (int k = 0; k <= df_pathmatrix2[_i][_j].path_index; k++) {+    df_pathmatrix2[i][j].df_path2[k]=+      df_pathmatrix2[_i][_j].df_path2[k]; }+  df_pathmatrix2[i][j].path_index = df_pathmatrix2[_i][_j].path_index;+  df_pathmatrix2[i][j].df_path2+    [df_pathmatrix2[i][j].path_index] = choice;  // this choice+  df_pathmatrix2[i][j].path_index++;+}+/// helper function for the calculation of the levenshtein distance+///+/// @param s1+/// @param s2+long levmin(long a, long b, long c)+{+        if (a <= b && a <= c) {+                return a;+        } else if (b <= a && b <= c) {+                return b;+        } else if (c <= a && c <= b) {+                return c;+        }+        return 0;+}+/// levenshtein distance calculation. Return the calculated levenshtein distance+/// between string ""s1"" and ""s2"".+///+/// @param s1+/// @param s2+long levenshtein(const char_u *s1, const char_u *s2)+{+    long x, y;+    long s1len=(long)STRLEN(s1), s2len=(long)STRLEN(s2);+    unsigned long **matrix = xmalloc(sizeof( long * ) * (s2len+1));+    for (long i = 0; i < (s2len+1); i++) {+        matrix[i]=xmalloc(sizeof(long) * (s1len+1));+    }++    matrix[0][0] = 0;+    for (x = 1; x <= s2len; x++) {+        matrix[x][0] = matrix[x-1][0] + 1; }+    for (y = 1; y <= s1len; y++) {+        matrix[0][y] = matrix[0][y-1] + 1; }+    for (x = 1; x <= s2len; x++) {+        for (y = 1; y <= s1len; y++) {+            matrix[x][y] = levmin(matrix[x-1][y] + 1,+                                  matrix[x][y-1] + 1,+                                  matrix[x-1][y-1] + (s1[y-1] ==+                                                      s2[x-1] ? 0 : 1));+        }+    }+    long rvalue = matrix[s2len][s1len];+    for (long i = 0; i < (s2len+1); i++) {+        xfree(matrix[i]);+    }+    xfree(matrix);+    return(rvalue);+}+/// Helper function for the diff alignment algorithm.+/// ""dp->df_comparisonlines"" represents a 2d array. indexed as+/// [buffer][line number] where the line number index represents the+/// offset from the start of the diff block indicated by dp->lnum[id]. The+/// comparison line in the other buffers is initialized to -1. It may+/// remain as -1 if the line is not compared.+///+/// @param dp+/// @param thisb+/// @param thisp+/// @param otherb1+/// @param otherb2+void initialize_compareline3(diff_T *dp, int thisb, int thisp,+                             int otherb1, int otherb2)+{+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb1]=-1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb2]=-1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].newline = false;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].filler = 0;+}+/// Helper function for the diff alignment algorithm.+/// ""dp->df_comparisonlines"" represents a 2d array. indexed as+/// [buffer][line number] where the line number index represents the+/// offset from the start of the diff block indicated by dp->lnum[id]. The+/// comparison line in the other buffers is initialized to -1. It may+/// remain as -1 if the line is not compared.+///+/// @param dp+/// @param thisb+/// @param thisp+/// @param otherb+void initialize_compareline2(diff_T *dp, int thisb, int thisp, int otherb)+{+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb] = -1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].newline = false;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].filler = 0;+}+/// the 2d (for two buffers) implementation of the linematch diff+/// algorithm for aligning the most similar lines when constructing diff+/// views. For a general description of the algorithm, see+/// linematch_3buffers+///+/// @param dp+void linematch_2buffers(diff_T *dp)+{+  int b0 = dp->df_valid_buffers[0];+  int b1 = dp->df_valid_buffers[1];+  diffcomparisonpath2_T **df_pathmatrix2 =+    // for previous and next row+    xmalloc( (2) * sizeof( diffcomparisonpath2_T * ));+  for (int i = 0; i < (2); i++) {+    df_pathmatrix2[i]=+      xmalloc((dp->df_count[b1]+1) * sizeof(diffcomparisonpath2_T));+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      df_pathmatrix2[i][j].df_path2=+        xmalloc((dp->df_count[b0]+dp->df_count[b1]) *+                sizeof(enum path2_choice));+    }+  }+  bool icur = 1;+  int score;+  for (int i = 0; i <= dp->df_count[b0]; i++) {+    icur=!icur;+    for (int j = 0; j <= dp->df_count[b1]; j++) {+      if (i == 0 && j == 0) {+        df_pathmatrix2[0][0].df_lev_score = 0;+        df_pathmatrix2[0][0].path_index = 0;+      } else if (i == 0) {+        score = df_pathmatrix2[0][j-1].df_lev_score;+        update_path2(dp, df_pathmatrix2, score, 0, j,  // to+                     0, j-1,  // from+                     DFPATH2_SKIP1);  // choice+      } else if (j == 0) {+        score = df_pathmatrix2[!icur][0].df_lev_score;+        update_path2(dp, df_pathmatrix2, score, icur, 0,  // to+                     !icur, 0,  // from+                     DFPATH2_SKIP0);  // choice+      } else {+         df_pathmatrix2[icur][j].df_lev_score = -1;+        score =+          df_pathmatrix2[!icur][j-1].df_lev_score++          count_matched_chars(+              ml_get_buf(curtab->tp_diffbuf[b0], dp->df_lnum[b0]+i-1, false),+              ml_get_buf(curtab->tp_diffbuf[b1], dp->df_lnum[b1]+j-1, false));+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       !icur, j-1,  // from+                       DFPATH2_COMPARE01);  // choice+        }+        score = df_pathmatrix2[!icur][j].df_lev_score;+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       !icur, j,  // from+                       DFPATH2_SKIP0);  // choice+        }+        score = df_pathmatrix2[icur][j-1].df_lev_score;+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       icur, j-1,  // from+                       DFPATH2_SKIP1);  // choice+        }+      }+    }+  }+  int p0 = 0, p1 = 0;  // i, j+  int maxlines = 0;+  if (dp->df_count[b0] > maxlines) { maxlines = dp->df_count[b0]; }+  if (dp->df_count[b1] > maxlines) { maxlines = dp->df_count[b1]; }+  dp->df_arr_col_size = maxlines+1;+  dp->df_comparisonlines=+  xmalloc(DB_COUNT * (dp->df_arr_col_size) * sizeof(df_linecompare_T));+  initialize_compareline2(dp, b0, p0, b1);+  initialize_compareline2(dp, b1, p1, b0);+  for (int i = 0; i < df_pathmatrix2+       [icur][dp->df_count[b1]].path_index; i++) {+    int p = df_pathmatrix2[icur][dp->df_count[b1]].df_path2[i];+    if (p == DFPATH2_SKIP0) {+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].newline = true;+      p0++;+      initialize_compareline2(dp, b0, p0, b1);+    } else if (p == DFPATH2_COMPARE01) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b1]=p1;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b0]=p0;+      p1++, p0++;+      initialize_compareline2(dp, b0, p0, b1);+      initialize_compareline2(dp, b1, p1, b0);+    } else if (p == DFPATH2_SKIP1) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].newline = true;+      p1++;+      initialize_compareline2(dp, b1, p1, b0);+    }+  }+  for (int i = 0; i < 2; i++) {+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      xfree(df_pathmatrix2[i][j].df_path2);+    }+    xfree(df_pathmatrix2[i]);+  }+  xfree(df_pathmatrix2);+}++/// The 3d case (for 3 buffers) of the algorithm implemented when diffopt+/// 'linematch' is enabled. The algorithm constructs a 3d tensor to+/// compare a diff between 3 buffers. The dimmensions of the tensor are+/// the length of the diff in each buffer plus 1 A path is constructed by+/// moving from one edge of the cube/3d tensor to the opposite edge.+/// Motions from one cell of the cube to the next represent decisions. In+/// a 3d cube, there are a total of 7 decisions that can be made,+/// represented by the enum path3_choice which is defined in+/// buffer_defs.h a comparison of buffer 0 and 1 represents a motion+/// toward the opposite edge of the cube with components along the 0 and+/// 1 axes.  a comparison of buffer 0, 1, and 2 represents a motion+/// toward the opposite edge of the cube with components along the 0, 1,+/// and 2 axes. A skip of buffer 0 represents a motion along only the 0+/// axis. For each action, a point value is awarded, and the path is+/// saved for reference later, if it is found to have been the optimal+/// path. The optimal path has the highest score.  The score is+/// calculated as the summation of the total characters matching between+/// all of the lines which were compared. The structure of the algorithm+/// is that of a dynamic programming problem.  We can calculate a point+/// i,j,k in the cube as a function of i-1, j-1, and k-1. To find the+/// score and path at point i,j,k, we must determine which path we want+/// to use, this is done by looking at the possibilities and choosing+/// the one which results in the local highest score.  The total highest+/// scored path is, then in the end represented by the cell in the+/// opposite corner from the start location.  The entire algorithm+/// consits of populating the 3d cube with the optimal paths from which+/// it may have came.  However, we cannot apply the general 3d case+/// before first populating the edges and the surfaces of the cube.+/// Therefore, there are several sets of if / else statements inside the+/// main loops which determine which case to evaluate.+/// @param dp+void linematch_3buffers(diff_T * dp)+{+  int b0 = dp->df_valid_buffers[0];+  int b1 = dp->df_valid_buffers[1];+  int b2 = dp->df_valid_buffers[2];+  diffcomparisonpath3_T ***df_pathmatrix3=+    xmalloc(sizeof(diffcomparisonpath3_T **) * (2));+  for (int i = 0; i < (2); i++) {+    df_pathmatrix3[i] =+      xmalloc(sizeof(diffcomparisonpath3_T *) * (dp->df_count[b1]+1));+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      df_pathmatrix3[i][j] =+        xmalloc(sizeof(diffcomparisonpath3_T) * (dp->df_count[b2]+1));+      for (int k = 0; k < (dp->df_count[b2]+1); k++) {+        df_pathmatrix3[i][j][k].df_path3 =+            xmalloc(+                (dp->df_count[b0]+dp->df_count[b1]+dp->df_count[b2]) *+                sizeof(enum path3_choice));+      }+    }+  }+  // memory for avoiding repetitive calculations of score+  int *mem12 = xmalloc(+      ((dp->df_count[b1]+1) * (dp->df_count[b2]+1)) * sizeof(int));+  int *mem01 = xmalloc(+      ((dp->df_count[b0]+1) * (dp->df_count[b1]+1)) * sizeof(int));+  int *mem02 = xmalloc(+      ((dp->df_count[b0]+1) * (dp->df_count[b2]+1)) * sizeof(int));+  bool icur = 1;+  int score;+  for (int i = 0; i <= dp->df_count[b0]; i++) {+    icur=!icur;+    for (int j = 0; j <= dp->df_count[b1]; j++) {+      for (int k = 0; k<= dp->df_count[b2]; k++) {+        if (i == 0 && j == 0 && k == 0) {+          df_pathmatrix3[0][0][0].df_lev_score = 0;+          df_pathmatrix3[0][0][0].path_index = 0;+        } else if (j == 0 && k == 0) {+         score = df_pathmatrix3[!icur][0][0].df_lev_score;+         update_path3(+             dp, df_pathmatrix3, score, icur, 0, 0,+             !icur, 0, 0,+             DFPATH3_SKIP0);+        } else if (i == 0 && k == 0) {+          score = df_pathmatrix3[0][j-1][0].df_lev_score;+          update_path3(+              dp, df_pathmatrix3, score, 0, j, 0,+              0, j-1, 0,+              DFPATH3_SKIP1);+        } else if (i == 0 && j == 0) {+          score = df_pathmatrix3[0][0][k-1].df_lev_score;+          update_path3(+              dp, df_pathmatrix3, score, 0, 0, k,+              0, 0, k-1,+              DFPATH3_SKIP2);+        } else if (k == 0) {+          df_pathmatrix3[icur][j][k].df_lev_score = -1;+          long matched_chars = count_matched_chars(+              ml_get_buf(curtab->tp_diffbuf[b0], dp->df_lnum[b0]+i-1, false),+              ml_get_buf(curtab->tp_diffbuf[b1], dp->df_lnum[b1]+j-1, false));+          mem01[i * (dp->df_count[b1]+1) + j] = matched_chars;+          score = df_pathmatrix3[!icur][j-1][k].df_lev_score+matched_chars;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j-1, k,  // from+                DFPATH3_COMPARE01);  // choice+          }+          score = df_pathmatrix3[!icur][j][k].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j, k,  // from+                DFPATH3_SKIP0);  // choice+          }+          score = df_pathmatrix3[icur][j-1][k].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j-1, k,  // from+                DFPATH3_SKIP1);  // choice+          }+        } else if (j == 0) {+          df_pathmatrix3[icur][j][k].df_lev_score = -1;+          long matched_chars = count_matched_chars(+              ml_get_buf(curtab->tp_diffbuf[b0], dp->df_lnum[b0]+i-1, false),+              ml_get_buf(curtab->tp_diffbuf[b2], dp->df_lnum[b2]+k-1, false));+          mem02[i * (dp->df_count[b2]+1) + k] = matched_chars;+          score = df_pathmatrix3[!icur][j][k-1].df_lev_score+matched_chars;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j, k-1,  // from+                DFPATH3_COMPARE02);  // choice+          }+          score = df_pathmatrix3[!icur][j][k].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j, k,  // from+                DFPATH3_SKIP0);  // choice+          }+          score = df_pathmatrix3[icur][j][k-1].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j, k-1,  // from+                DFPATH3_SKIP2);  // choice+          }+        } else if ( i == 0 ) {+          df_pathmatrix3[icur][j][k].df_lev_score = -1;+          long matched_chars = count_matched_chars(+              ml_get_buf(curtab->tp_diffbuf[b1], dp->df_lnum[b1]+j-1, false),+              ml_get_buf(curtab->tp_diffbuf[b2], dp->df_lnum[b2]+k-1, false));+          // store in memory for later+          mem12[j * (dp->df_count[b2]+1) + k] = matched_chars;+          score = df_pathmatrix3[icur][j-1][k-1].df_lev_score + matched_chars;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j-1, k-1,  // from+                DFPATH3_COMPARE12);  // choice+          }+          score = df_pathmatrix3[icur][j-1][k].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j-1, k,  // from+                DFPATH3_SKIP1);  // choice+          }+          score = df_pathmatrix3[icur][j][k-1].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j, k-1,  // from+                DFPATH3_SKIP2);  // choice+          }+        } else {+          df_pathmatrix3[icur][j][k].df_lev_score = -1;+          long matched_01 = mem01[i * (dp->df_count[b1]+1) + j];+          score = df_pathmatrix3[!icur][j-1][k].df_lev_score+matched_01;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j-1, k,  // from+                DFPATH3_COMPARE01);  // choice+          }+          long matched_02 = mem02[i * (dp->df_count[b2]+1) + k];+          score = df_pathmatrix3[!icur][j][k-1].df_lev_score+matched_02;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j, k-1,  // from+                DFPATH3_COMPARE02);  // choice+          }+          long matched_12 = mem12[j * (dp->df_count[b2]+1) + k];+          score = df_pathmatrix3[icur][j-1][k-1].df_lev_score+matched_12;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j-1, k-1,  // from+                DFPATH3_COMPARE12);  // choice+          }+          long matched_012 = matched_01+matched_02+matched_12;+          // prioritize equally to a 2 line match+          matched_012 *= 2, matched_012 /= 3;+          score = df_pathmatrix3[!icur][j-1][k-1].df_lev_score+matched_012;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j-1, k-1,  // from+                DFPATH3_COMPARE012);  // choice+          }+          score = df_pathmatrix3[!icur][j][k].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                !icur, j, k,  // from+                DFPATH3_SKIP0);  // choice+          }+          score = df_pathmatrix3[icur][j-1][k].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j-1, k,  // from+                DFPATH3_SKIP1);  // choice+          }+          score = df_pathmatrix3[icur][j][k-1].df_lev_score;+          if (score > df_pathmatrix3[icur][j][k].df_lev_score) {+            update_path3(+                dp, df_pathmatrix3, score, icur, j, k,+                icur, j, k-1,  // from+                DFPATH3_SKIP2);  // choice+          }+        }+      }+    }+  }+  int p0 = 0, p1 = 0, p2 = 0;  // i, j, k+  int maxlines = 0;+  if (dp->df_count[b0] > maxlines) { maxlines = dp->df_count[b0]; }+  if (dp->df_count[b1] > maxlines) { maxlines = dp->df_count[b1]; }+  if (dp->df_count[b2] > maxlines) { maxlines = dp->df_count[b2]; }+  dp->df_arr_col_size = maxlines+1;+  dp->df_comparisonlines =+    xmalloc(DB_COUNT *(dp->df_arr_col_size) * sizeof(df_linecompare_T));+  initialize_compareline3(dp, b0, p0, b1, b2);+  initialize_compareline3(dp, b1, p1, b0, b2);+  initialize_compareline3(dp, b2, p2, b0, b1);+  for (int i = 0; i < df_pathmatrix3+       [icur][dp->df_count[b1]][dp->df_count[b2]].path_index; i++) {+    int p = df_pathmatrix3+      [icur][dp->df_count[b1]][dp->df_count[b2]].df_path3[i];+    if (p == DFPATH3_COMPARE01) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b1] = p1;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b0] = p0;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].filler++;+      p0++, p1++;+      initialize_compareline3(dp, b0, p0, b1, b2);+      initialize_compareline3(dp, b1, p1, b0, b2);+    } else if (p == DFPATH3_COMPARE02) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b2] = p2;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].compare[b0] = p0;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].filler++;+      p0++, p2++;+      initialize_compareline3(dp, b0, p0, b1, b2);+      initialize_compareline3(dp, b2, p2, b0, b1);+    } else if (p == DFPATH3_COMPARE12) {+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b2] = p2;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].compare[b1] = p1;+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].filler++;+      p1++, p2++;+      initialize_compareline3(dp, b1, p1, b0, b2);+      initialize_compareline3(dp, b2, p2, b0, b1);+    } else if (p == DFPATH3_COMPARE012) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b1] = p1;+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b2] = p2;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b0] = p0;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b2] = p2;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].compare[b0] = p0;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].compare[b1] = p1;+      p0++, p1++, p2++;+      initialize_compareline3(dp, b0, p0, b1, b2);+      initialize_compareline3(dp, b1, p1, b0, b2);+      initialize_compareline3(dp, b2, p2, b0, b1);+    } else if  (p == DFPATH3_SKIP0) {+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].newline = true;+      p0++;+      initialize_compareline3(dp, b0, p0, b1, b2);+    } else if (p == DFPATH3_SKIP1) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].newline = true;+      p1++;+      initialize_compareline3(dp, b1, p1, b0, b2);+    } else if (p == DFPATH3_SKIP2) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b2 + p2].newline = true;+      p2++;+      initialize_compareline3(dp, b2, p2, b0, b1);+    }+  }+  for (int i = 0; i < (2); i++) {+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      for (int k = 0; k < (dp->df_count[b2]+1); k++) {+        xfree(df_pathmatrix3[i][j][k].df_path3);+      }+      xfree(df_pathmatrix3[i][j]);+    }+    xfree(df_pathmatrix3[i]);+  }+  xfree(df_pathmatrix3);+  xfree(mem12), xfree(mem01), xfree(mem02);+}++ /// Check diff status for line ""lnum"" in buffer ""buf"": ///-/// Returns 0 for nothing special-/// Returns -1 for a line that should be highlighted as changed.-/// Returns -2 for a line that should be highlighted as added/deleted.-/// Returns > 0 for inserting that many filler lines above it (never happens-/// when 'diffopt' doesn't contain ""filler"").-/// This should only be used for windows where 'diff' is set.+/// Returns 0 for nothing special Returns -1 for a line that should be+/// highlighted as changed.  Returns -2 for a line that should be+/// highlighted as added/deleted.  Returns > 0 for inserting that many+/// filler lines above it (never happens when 'diffopt' doesn't contain+///     ""filler"").  This should only be used for windows where 'diff' is+/// set.  When diffopt contains linematch, a changed/added/deleted line",You broke the formatting here and made it harder to read. I'm guessing this was accidental using `gq`?,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14490,632177492,2021-05-14T00:15:53Z,src/nvim/quickfix.c,"@@ -3983,17 +4000,54 @@ static int qf_buf_add_line(buf_T *buf, linenr_T lnum, const qfline_T *qfp,   return OK; } +static list_T *call_qftf_func(qf_list_T *qfl,+                              int qf_winid,+                              long start_idx,+                              long end_idx)+{+  char_u *qftf = p_qftf;+  list_T *qftf_list = NULL;++  // If 'quickfixtextfunc' is set, then use the user-supplied function to get+  // the text to display. Use the local value of 'quickfixtextfunc' if it is+  // set.+  if (qfl->qf_qftf != NULL) {+    qftf = qfl->qf_qftf;+  }+  if (qftf != NULL && *qftf != NUL) {+    typval_T args[1];+    dict_T *const dict = tv_dict_alloc();","It's necessary because that's what in the vim patch. If the PR you're referring to diverged from the vim patch without explanation (ie. not locking the dictionary that should be locked), then that is the fault of the porter. Stick to the vim patch as much as possible and document any necessary divergences in the commit message.If existing code or test fails, then an unmerged vim patch is likely missing and it should be ported in the same PR if possible.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14490,632178520,2021-05-14T00:19:21Z,src/nvim/quickfix.c,"@@ -4026,8 +4080,20 @@ static void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last)       }       lnum = buf->b_ml.ml_line_count;     }++    qftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),+                               (long)qfl->qf_count);",`qf_count` is int.`lnum` uses `linenr_T` type which is `long`.,
7908,urandom,https://api.github.com/repos/neovim/neovim/pulls/14511,632531014,2021-05-14T13:33:59Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1196,42 +1196,54 @@ end ---             - Exclusive severity to consider. Overrides {severity_limit} ---         - {severity_limit}: (DiagnosticSeverity) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.+---         - {workspace}: (boolean, default false)+---             - Set the list with workspace diagnostics function M.set_loclist(opts)   opts = opts or {}    local open_loclist = if_nil(opts.open_loclist, true) -  local bufnr = vim.api.nvim_get_current_buf()-  local buffer_diags = M.get(bufnr, opts.client_id)--  if opts.severity then-    buffer_diags = filter_to_severity_limit(opts.severity, buffer_diags)-  elseif opts.severity_limit then-    buffer_diags = filter_by_severity_limit(opts.severity_limit, buffer_diags)-  end+  local current_bufnr = vim.api.nvim_get_current_buf()+  local diags = opts.workspace and M.get_all() or {+    [current_bufnr] = M.get(current_bufnr, opts.client_id)+  }    local items = {}-  local insert_diag = function(diag)+  local insert_diag = function(bufnr, diag)     local pos = diag.range.start     local row = pos.line-    local col = util.character_offset(bufnr, row, pos.character)      local line = (api.nvim_buf_get_lines(bufnr, row, row + 1, false) or {""""})[1]+    local col = line and util.character_offset(bufnr, row, pos.character) or 0","@mjlbach I did some experiments calling every possibly buf* function I could think of when the line is null:```{  col = 20,  exists = 1,  listed = 0,  load = 0,  loaded = 1,  name = ""some/file_test.go"",  row = 70}```That file has content on line 71 col 21, so I'm not sure why nvim_buf_get_lines returns null",
7908,urandom,https://api.github.com/repos/neovim/neovim/pulls/14511,632591848,2021-05-14T15:03:52Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1196,42 +1196,54 @@ end ---             - Exclusive severity to consider. Overrides {severity_limit} ---         - {severity_limit}: (DiagnosticSeverity) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.+---         - {workspace}: (boolean, default false)+---             - Set the list with workspace diagnostics function M.set_loclist(opts)   opts = opts or {}    local open_loclist = if_nil(opts.open_loclist, true) -  local bufnr = vim.api.nvim_get_current_buf()-  local buffer_diags = M.get(bufnr, opts.client_id)--  if opts.severity then-    buffer_diags = filter_to_severity_limit(opts.severity, buffer_diags)-  elseif opts.severity_limit then-    buffer_diags = filter_by_severity_limit(opts.severity_limit, buffer_diags)-  end+  local current_bufnr = vim.api.nvim_get_current_buf()+  local diags = opts.workspace and M.get_all() or {+    [current_bufnr] = M.get(current_bufnr, opts.client_id)+  }    local items = {}-  local insert_diag = function(diag)+  local insert_diag = function(bufnr, diag)     local pos = diag.range.start     local row = pos.line-    local col = util.character_offset(bufnr, row, pos.character)      local line = (api.nvim_buf_get_lines(bufnr, row, row + 1, false) or {""""})[1]+    local col = line and util.character_offset(bufnr, row, pos.character) or 0","Most of the buffers seem to return null here. The only consequence of that with this change will be that the list will not include the relevant text from the buffer, but will still include the description.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/14538,632680389,2021-05-14T17:20:35Z,scripts/vim-patch.sh,"@@ -578,7 +578,7 @@ list_missing_previous_vimpatches_for_patch() {   local -a fnames   while IFS= read -r line ; do     fnames+=(""$line"")-  done < <(git -C ""${VIM_SOURCE_DIR}"" diff-tree --no-commit-id --name-only -r ""${vim_commit}"")+  done < <(git -C ""${VIM_SOURCE_DIR}"" diff-tree --no-commit-id --name-only -r ""${vim_commit}"" -- ':!src/version.c')","```suggestion  done < <(git -C ""${VIM_SOURCE_DIR}"" diff-tree --no-commit-id --name-only -r ""${vim_commit}"" -- . ':!src/version.c')``````$ ~/local/git/bin/git --versiongit version 2.7.4.dirty$ ~/local/git/bin/git diff-tree -r v8.1.1378 -- ':!src/version.c'fatal: There is nothing to exclude from by :(exclude) patterns.Perhaps you forgot to add either ':/' or '.' ?$ ~/local/git/bin/git diff-tree -r v8.1.1378 -- .701ff0a3e53d253d7300c385e582659bbff7860d:100644 100644 5631795e35c91c27f3b5f71f2dcb9ffc72cd0c33 6ffd1a1abfe3e6140a3a25f4a558052b7c90e7dc M      src/evalfunc.c:100644 100644 c9387cecd127f8adc3808d7cfd932fc667756b4f b6a37f522a56bf62d395a9a6d6c548588f84cc5b M      src/fileio.c:100644 100644 1844924fdb3ff68c60e7b956b5469990c32d8fc6 bff6640730805bdde3394f316c5e4861d0b24326 M      src/proto/fileio.pro:100644 100644 b9520c7ee6a39e3a79d9df8cf804118d82b7c9af 3e4c03cdbe9523b99a0d1c0eec962419911800c0 M      src/testdir/test_functions.vim:100644 100644 b2278ed02ac4eec7e52f4814f14203f8d7b5cdf5 e544f9bd34aba852bd98e3edcda07f0c8a378040 M      src/version.c$ ~/local/git/bin/git diff-tree -r v8.1.1378 -- . ':!src/version.c'701ff0a3e53d253d7300c385e582659bbff7860d:100644 100644 5631795e35c91c27f3b5f71f2dcb9ffc72cd0c33 6ffd1a1abfe3e6140a3a25f4a558052b7c90e7dc M      src/evalfunc.c:100644 100644 c9387cecd127f8adc3808d7cfd932fc667756b4f b6a37f522a56bf62d395a9a6d6c548588f84cc5b M      src/fileio.c:100644 100644 1844924fdb3ff68c60e7b956b5469990c32d8fc6 bff6640730805bdde3394f316c5e4861d0b24326 M      src/proto/fileio.pro:100644 100644 b9520c7ee6a39e3a79d9df8cf804118d82b7c9af 3e4c03cdbe9523b99a0d1c0eec962419911800c0 M      src/testdir/test_functions.vim```",
17562139,kevinhwang91,https://api.github.com/repos/neovim/neovim/pulls/14490,632895683,2021-05-15T04:53:55Z,src/nvim/quickfix.c,"@@ -4026,8 +4080,20 @@ static void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last)       }       lnum = buf->b_ml.ml_line_count;     }++    qftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),+                               (long)qfl->qf_count);",redefine `call_qftf_func` and use `int` instead of `long`  or just change `(long)(lnum + 1)` to `lnum + 1` directly?,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/14537,633126086,2021-05-16T18:59:44Z,src/nvim/diff.c,"@@ -1733,25 +1743,713 @@ void diff_clear(tabpage_T *tp)   diff_T *next_p;   for (p = tp->tp_first_diff; p != NULL; p = next_p) {     next_p = p->df_next;+    if (!p->df_redraw) {+      xfree(p->df_comparisonlines);+    }     xfree(p);   }   tp->tp_first_diff = NULL; } +///+/// return true if the options are set to use diff linematch+///+bool diff_linematch(diff_T *dp)+{+  if (!(diff_flags & DIFF_LINEMATCH)) {+        return 0;+  }+  // are there more than three diff buffers?+  int diffbuffers = 0;+  int tsize = 0;+  for (int i = 0; i < DB_COUNT; i++) {+    if ( curtab->tp_diffbuf[i] != NULL ) {+      diffbuffers++;+      tsize += dp->df_count[i];+    }+  }+  // avoid allocating a huge array because it will lag+  if (tsize > linematch_lines) {+    return 0;+  }+  if (diffbuffers <= 3) {  // can diff up to 3 buffers+    return 1;+  }+  return 0;+}++///+/// Count the number of virtual (filler + non filler) lines between ""start"" and+/// ""endline"" in ""win""+///+/// @param win+/// @param start+/// @param endline+int count_virtual_lines(win_T *win, linenr_T start, linenr_T endline)+{+  int virtual_lines = 0;+  for (int k = start; k <= endline; k++) {+    int n = diff_check(win, k, NULL);+    if (n > 0) {+        virtual_lines+=n;  // filler lines+    }+    virtual_lines++;+  }+  return virtual_lines;+}+/// in ""win"" window, move from ""lnum"" down by the amount ""virtual_lines""+/// and return the number of real lines moved. if a non null pointer is+/// passed to ""line_new_virtualp"", it will be set to the number of virtual+/// lines moved+///+/// @param win+/// @param lnum+/// @param virtual_lines+/// @param line_new_virtualp+int count_virtual_to_real(win_T *win, const linenr_T lnum,+                          const int virtual_lines, int *line_new_virtualp )+{+  int real_offset = 0;+  int virtual_offset = 0;+  while (1) {+    int n = diff_check(win, lnum+real_offset, NULL);+    virtual_offset++;+    if (n > 0) {+        virtual_offset+=n;  // filler lines+    }+    if (virtual_offset > virtual_lines) {+        break;+    }+    real_offset++;+  }+  if ( line_new_virtualp != NULL ) {+    (*line_new_virtualp)=virtual_offset;+  }+  return real_offset;+}++/// return the number of matching characters between two strings+///+/// @param s1+/// @param s2+long count_matched_chars(const char_u *s1, const char_u *s2)+{+  long l1=(long)STRLEN(s1), l2=(long)STRLEN(s2);+  if ( diff_flags & DIFF_IWHITE || diff_flags & DIFF_IWHITEALL+      || diff_flags & DIFF_ICASE ) {+    bool iwhite=(diff_flags & DIFF_IWHITEALL || diff_flags & DIFF_IWHITE);+    // the newly processed strings that will be compared+    char_u *s1_proc = xmalloc(STRLEN(s1) * sizeof(char_u));+    char_u *s2_proc = xmalloc(STRLEN(s2) * sizeof(char_u));+    // delete the white space characters,+    // and/or replace all upper case with lower+    char_u *strsproc[2] = { s1_proc, s2_proc };+    const char_u *strsorig[2] = { s1, s2 };+    long slen[2] = { l1, l2 };+    for (int k = 0; k < 2; k++) {+      int d = 0, i = 0;+      while (d+i < slen[k]) {+        if ((iwhite)?(strsorig[k][i+d] != ' ' && strsorig[k][i+d] != '\t'):1) {+          strsproc[k][i] = (diff_flags & DIFF_ICASE)?+           (tolower(strsorig[k][i+d])):(strsorig[k][i+d]);+          i++;+        } else { d++; }+      }+      strsproc[k][i]='\0';+    }+    long l1_nowhite=(long)STRLEN(s1_proc);+    long l2_nowhite=(long)STRLEN(s2_proc);+    long maxlength = l1_nowhite > l2_nowhite?l1_nowhite:l2_nowhite;+    long lev = levenshtein(s1_proc, s2_proc);+    xfree(s1_proc), xfree(s2_proc);+    return maxlength-lev;+  }+  // compare strings without considering the white space+  long maxlength = l1 > l2?l1:l2;+  return maxlength - levenshtein(s1, s2);+}+/// helper function for the diff alignment algorithm copy the newly found+/// optimal path to an index in the tensor for more detailed algorith+/// description, see ""linematch_3buffers"" for the current diff hunk ""dp"",+/// the ""score"" and path at index ""i"",""j"",""k"" is updated from the path+/// from ""_i"",""_j"",""_k"" choice is represented by enum value ""choice""+///+/// @param dp+/// @param df_pathmatrix3+/// @param score+/// @param i+/// @param j+/// @param k+/// @param _i+/// @param _j+/// @param _k+/// @param choice+void update_path3(diff_T *dp, diffcomparisonpath3_T ***df_pathmatrix3,+                  int score, int i, int j, int k, int _i, int _j, int _k,+                  enum path3_choice choice)+{+  df_pathmatrix3[i][j][k].df_lev_score = score;+  for (int __k = 0; __k <= df_pathmatrix3[_i][_j][_k].path_index; __k++) {+    df_pathmatrix3[i][j][k].df_path3[__k]=+      df_pathmatrix3[_i][_j][_k].df_path3[__k]; }+  df_pathmatrix3[i][j][k].path_index = df_pathmatrix3[_i][_j][_k].path_index;+  df_pathmatrix3[i][j][k].df_path3+    [df_pathmatrix3[i][j][k].path_index] = choice;  // this choice+  df_pathmatrix3[i][j][k].path_index++;+}+/// helper function for the diff alignment algorithm copy the newly found+/// optimal path to an index in the tensor for more detailed algorith+/// description, see ""linematch_2buffers"" for the current diff hunk ""dp"",+/// the ""score"" and path at index ""i"",""j""is updated from the path from+/// ""_i"",""_j"",choice is represented by enum value ""choice""+///+/// @param dp+/// @param df_pathmatrix2+/// @param score+/// @param i+/// @param j+/// @param _i+/// @param _j+/// @param choice+void update_path2(diff_T *dp, diffcomparisonpath2_T **df_pathmatrix2,+                  int score, int i, int j, int _i, int _j,+                  enum path2_choice choice)+{+  df_pathmatrix2[i][j].df_lev_score = score;+  for (int k = 0; k <= df_pathmatrix2[_i][_j].path_index; k++) {+    df_pathmatrix2[i][j].df_path2[k]=+      df_pathmatrix2[_i][_j].df_path2[k]; }+  df_pathmatrix2[i][j].path_index = df_pathmatrix2[_i][_j].path_index;+  df_pathmatrix2[i][j].df_path2+    [df_pathmatrix2[i][j].path_index] = choice;  // this choice+  df_pathmatrix2[i][j].path_index++;+}+/// helper function for the calculation of the levenshtein distance+///+/// @param s1+/// @param s2+long levmin(long a, long b, long c)+{+        if (a <= b && a <= c) {+                return a;+        } else if (b <= a && b <= c) {+                return b;+        } else if (c <= a && c <= b) {+                return c;+        }+        return 0;+}+/// levenshtein distance calculation. Return the calculated levenshtein distance+/// between string ""s1"" and ""s2"".+///+/// @param s1+/// @param s2+long levenshtein(const char_u *s1, const char_u *s2)+{+    long x, y;+    long s1len=(long)STRLEN(s1), s2len=(long)STRLEN(s2);+    unsigned long **matrix = xmalloc(sizeof( long * ) * (s2len+1));+    for (long i = 0; i < (s2len+1); i++) {+        matrix[i]=xmalloc(sizeof(long) * (s1len+1));+    }++    matrix[0][0] = 0;+    for (x = 1; x <= s2len; x++) {+        matrix[x][0] = matrix[x-1][0] + 1; }+    for (y = 1; y <= s1len; y++) {+        matrix[0][y] = matrix[0][y-1] + 1; }+    for (x = 1; x <= s2len; x++) {+        for (y = 1; y <= s1len; y++) {+            matrix[x][y] = levmin(matrix[x-1][y] + 1,+                                  matrix[x][y-1] + 1,+                                  matrix[x-1][y-1] + (s1[y-1] ==+                                                      s2[x-1] ? 0 : 1));+        }+    }+    long rvalue = matrix[s2len][s1len];+    for (long i = 0; i < (s2len+1); i++) {+        xfree(matrix[i]);+    }+    xfree(matrix);+    return(rvalue);+}+/// Helper function for the diff alignment algorithm.+/// ""dp->df_comparisonlines"" represents a 2d array. indexed as+/// [buffer][line number] where the line number index represents the+/// offset from the start of the diff block indicated by dp->lnum[id]. The+/// comparison line in the other buffers is initialized to -1. It may+/// remain as -1 if the line is not compared.+///+/// @param dp+/// @param thisb+/// @param thisp+/// @param otherb1+/// @param otherb2+void initialize_compareline3(diff_T *dp, int thisb, int thisp,+                             int otherb1, int otherb2)+{+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb1]=-1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb2]=-1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].newline = false;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].filler = 0;+}+/// Helper function for the diff alignment algorithm.+/// ""dp->df_comparisonlines"" represents a 2d array. indexed as+/// [buffer][line number] where the line number index represents the+/// offset from the start of the diff block indicated by dp->lnum[id]. The+/// comparison line in the other buffers is initialized to -1. It may+/// remain as -1 if the line is not compared.+///+/// @param dp+/// @param thisb+/// @param thisp+/// @param otherb+void initialize_compareline2(diff_T *dp, int thisb, int thisp, int otherb)+{+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb] = -1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].newline = false;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].filler = 0;+}+/// the 2d (for two buffers) implementation of the linematch diff+/// algorithm for aligning the most similar lines when constructing diff+/// views. For a general description of the algorithm, see+/// linematch_3buffers+///+/// @param dp+void linematch_2buffers(diff_T *dp)+{+  int b0 = dp->df_valid_buffers[0];+  int b1 = dp->df_valid_buffers[1];+  diffcomparisonpath2_T **df_pathmatrix2 =+    // for previous and next row+    xmalloc( (2) * sizeof( diffcomparisonpath2_T * ));+  for (int i = 0; i < (2); i++) {+    df_pathmatrix2[i]=+      xmalloc((dp->df_count[b1]+1) * sizeof(diffcomparisonpath2_T));+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      df_pathmatrix2[i][j].df_path2=+        xmalloc((dp->df_count[b0]+dp->df_count[b1]) *+                sizeof(enum path2_choice));+    }+  }+  bool icur = 1;+  int score;+  for (int i = 0; i <= dp->df_count[b0]; i++) {+    icur=!icur;+    for (int j = 0; j <= dp->df_count[b1]; j++) {+      if (i == 0 && j == 0) {+        df_pathmatrix2[0][0].df_lev_score = 0;+        df_pathmatrix2[0][0].path_index = 0;+      } else if (i == 0) {+        score = df_pathmatrix2[0][j-1].df_lev_score;+        update_path2(dp, df_pathmatrix2, score, 0, j,  // to+                     0, j-1,  // from+                     DFPATH2_SKIP1);  // choice+      } else if (j == 0) {+        score = df_pathmatrix2[!icur][0].df_lev_score;+        update_path2(dp, df_pathmatrix2, score, icur, 0,  // to+                     !icur, 0,  // from+                     DFPATH2_SKIP0);  // choice+      } else {+         df_pathmatrix2[icur][j].df_lev_score = -1;+        score =+          df_pathmatrix2[!icur][j-1].df_lev_score++          count_matched_chars(+              ml_get_buf(curtab->tp_diffbuf[b0], dp->df_lnum[b0]+i-1, false),+              ml_get_buf(curtab->tp_diffbuf[b1], dp->df_lnum[b1]+j-1, false));+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       !icur, j-1,  // from+                       DFPATH2_COMPARE01);  // choice+        }+        score = df_pathmatrix2[!icur][j].df_lev_score;+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       !icur, j,  // from+                       DFPATH2_SKIP0);  // choice+        }+        score = df_pathmatrix2[icur][j-1].df_lev_score;+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       icur, j-1,  // from+                       DFPATH2_SKIP1);  // choice+        }+      }+    }+  }+  int p0 = 0, p1 = 0;  // i, j+  int maxlines = 0;+  if (dp->df_count[b0] > maxlines) { maxlines = dp->df_count[b0]; }+  if (dp->df_count[b1] > maxlines) { maxlines = dp->df_count[b1]; }+  dp->df_arr_col_size = maxlines+1;+  dp->df_comparisonlines=+  xmalloc(DB_COUNT * (dp->df_arr_col_size) * sizeof(df_linecompare_T));+  initialize_compareline2(dp, b0, p0, b1);+  initialize_compareline2(dp, b1, p1, b0);+  for (int i = 0; i < df_pathmatrix2+       [icur][dp->df_count[b1]].path_index; i++) {+    int p = df_pathmatrix2[icur][dp->df_count[b1]].df_path2[i];+    if (p == DFPATH2_SKIP0) {+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].newline = true;+      p0++;+      initialize_compareline2(dp, b0, p0, b1);+    } else if (p == DFPATH2_COMPARE01) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b1]=p1;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b0]=p0;+      p1++, p0++;+      initialize_compareline2(dp, b0, p0, b1);+      initialize_compareline2(dp, b1, p1, b0);+    } else if (p == DFPATH2_SKIP1) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].newline = true;+      p1++;+      initialize_compareline2(dp, b1, p1, b0);+    }+  }+  for (int i = 0; i < 2; i++) {+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      xfree(df_pathmatrix2[i][j].df_path2);+    }+    xfree(df_pathmatrix2[i]);+  }+  xfree(df_pathmatrix2);+}++/// The 3d case (for 3 buffers) of the algorithm implemented when diffopt+/// 'linematch' is enabled. The algorithm constructs a 3d tensor to+/// compare a diff between 3 buffers. The dimmensions of the tensor are+/// the length of the diff in each buffer plus 1 A path is constructed by+/// moving from one edge of the cube/3d tensor to the opposite edge.+/// Motions from one cell of the cube to the next represent decisions. In+/// a 3d cube, there are a total of 7 decisions that can be made,+/// represented by the enum path3_choice which is defined in+/// buffer_defs.h a comparison of buffer 0 and 1 represents a motion+/// toward the opposite edge of the cube with components along the 0 and+/// 1 axes.  a comparison of buffer 0, 1, and 2 represents a motion+/// toward the opposite edge of the cube with components along the 0, 1,+/// and 2 axes. A skip of buffer 0 represents a motion along only the 0+/// axis. For each action, a point value is awarded, and the path is+/// saved for reference later, if it is found to have been the optimal+/// path. The optimal path has the highest score.  The score is+/// calculated as the summation of the total characters matching between+/// all of the lines which were compared. The structure of the algorithm+/// is that of a dynamic programming problem.  We can calculate a point+/// i,j,k in the cube as a function of i-1, j-1, and k-1. To find the+/// score and path at point i,j,k, we must determine which path we want+/// to use, this is done by looking at the possibilities and choosing+/// the one which results in the local highest score.  The total highest+/// scored path is, then in the end represented by the cell in the+/// opposite corner from the start location.  The entire algorithm+/// consits of populating the 3d cube with the optimal paths from which+/// it may have came.  However, we cannot apply the general 3d case+/// before first populating the edges and the surfaces of the cube.+/// Therefore, there are several sets of if / else statements inside the+/// main loops which determine which case to evaluate.+/// @param dp+void linematch_3buffers(diff_T * dp)","FFI allows lua plugins to call C functions. Currently [gitsigns](https://github.com/lewis6991/gitsigns.nvim) uses it to call `xdl_diff` (which is also called in `diff.c`) to run diffs in-process (as opposed to spawning an external diff process).It would be desirable if a function could be provided similar to `xdl_diff` that gets the benefits of linewise diffs. That way the signs from gitsigns will align with linewise diffs. Note `diff.c` uses `xdl_diff` with the `outf` callback but gitsigns uses it with the `hunk_func` callback which gets called a lot less since it omits context lines which aren't necessary for gitsigns as it already knows the buffer contents; it just needs to know the line numbers of the generated hunks.Here's the full [implemenation](https://github.com/lewis6991/gitsigns.nvim/blob/main/lua/gitsigns/diff.lua) in gitsigns that uses FFI to call `xdl_diff`. It wraps it up into `function M.run_diff(fa, fb, diff_algo)` where `fa` and `fb` are the file contents you want to diff and returns an array of all the hunks.There is also this [PR](https://github.com/neovim/neovim/pull/14536) that attempts to provide Lua C bindings for xdiff.  A linewised xdl_diff like function would help with that too.",
32371757,jwhite510,https://api.github.com/repos/neovim/neovim/pulls/14537,633719958,2021-05-17T17:25:40Z,src/nvim/diff.c,"@@ -1733,25 +1743,713 @@ void diff_clear(tabpage_T *tp)   diff_T *next_p;   for (p = tp->tp_first_diff; p != NULL; p = next_p) {     next_p = p->df_next;+    if (!p->df_redraw) {+      xfree(p->df_comparisonlines);+    }     xfree(p);   }   tp->tp_first_diff = NULL; } +///+/// return true if the options are set to use diff linematch+///+bool diff_linematch(diff_T *dp)+{+  if (!(diff_flags & DIFF_LINEMATCH)) {+        return 0;+  }+  // are there more than three diff buffers?+  int diffbuffers = 0;+  int tsize = 0;+  for (int i = 0; i < DB_COUNT; i++) {+    if ( curtab->tp_diffbuf[i] != NULL ) {+      diffbuffers++;+      tsize += dp->df_count[i];+    }+  }+  // avoid allocating a huge array because it will lag+  if (tsize > linematch_lines) {+    return 0;+  }+  if (diffbuffers <= 3) {  // can diff up to 3 buffers+    return 1;+  }+  return 0;+}++///+/// Count the number of virtual (filler + non filler) lines between ""start"" and+/// ""endline"" in ""win""+///+/// @param win+/// @param start+/// @param endline+int count_virtual_lines(win_T *win, linenr_T start, linenr_T endline)+{+  int virtual_lines = 0;+  for (int k = start; k <= endline; k++) {+    int n = diff_check(win, k, NULL);+    if (n > 0) {+        virtual_lines+=n;  // filler lines+    }+    virtual_lines++;+  }+  return virtual_lines;+}+/// in ""win"" window, move from ""lnum"" down by the amount ""virtual_lines""+/// and return the number of real lines moved. if a non null pointer is+/// passed to ""line_new_virtualp"", it will be set to the number of virtual+/// lines moved+///+/// @param win+/// @param lnum+/// @param virtual_lines+/// @param line_new_virtualp+int count_virtual_to_real(win_T *win, const linenr_T lnum,+                          const int virtual_lines, int *line_new_virtualp )+{+  int real_offset = 0;+  int virtual_offset = 0;+  while (1) {+    int n = diff_check(win, lnum+real_offset, NULL);+    virtual_offset++;+    if (n > 0) {+        virtual_offset+=n;  // filler lines+    }+    if (virtual_offset > virtual_lines) {+        break;+    }+    real_offset++;+  }+  if ( line_new_virtualp != NULL ) {+    (*line_new_virtualp)=virtual_offset;+  }+  return real_offset;+}++/// return the number of matching characters between two strings+///+/// @param s1+/// @param s2+long count_matched_chars(const char_u *s1, const char_u *s2)+{+  long l1=(long)STRLEN(s1), l2=(long)STRLEN(s2);+  if ( diff_flags & DIFF_IWHITE || diff_flags & DIFF_IWHITEALL+      || diff_flags & DIFF_ICASE ) {+    bool iwhite=(diff_flags & DIFF_IWHITEALL || diff_flags & DIFF_IWHITE);+    // the newly processed strings that will be compared+    char_u *s1_proc = xmalloc(STRLEN(s1) * sizeof(char_u));+    char_u *s2_proc = xmalloc(STRLEN(s2) * sizeof(char_u));+    // delete the white space characters,+    // and/or replace all upper case with lower+    char_u *strsproc[2] = { s1_proc, s2_proc };+    const char_u *strsorig[2] = { s1, s2 };+    long slen[2] = { l1, l2 };+    for (int k = 0; k < 2; k++) {+      int d = 0, i = 0;+      while (d+i < slen[k]) {+        if ((iwhite)?(strsorig[k][i+d] != ' ' && strsorig[k][i+d] != '\t'):1) {+          strsproc[k][i] = (diff_flags & DIFF_ICASE)?+           (tolower(strsorig[k][i+d])):(strsorig[k][i+d]);+          i++;+        } else { d++; }+      }+      strsproc[k][i]='\0';+    }+    long l1_nowhite=(long)STRLEN(s1_proc);+    long l2_nowhite=(long)STRLEN(s2_proc);+    long maxlength = l1_nowhite > l2_nowhite?l1_nowhite:l2_nowhite;+    long lev = levenshtein(s1_proc, s2_proc);+    xfree(s1_proc), xfree(s2_proc);+    return maxlength-lev;+  }+  // compare strings without considering the white space+  long maxlength = l1 > l2?l1:l2;+  return maxlength - levenshtein(s1, s2);+}+/// helper function for the diff alignment algorithm copy the newly found+/// optimal path to an index in the tensor for more detailed algorith+/// description, see ""linematch_3buffers"" for the current diff hunk ""dp"",+/// the ""score"" and path at index ""i"",""j"",""k"" is updated from the path+/// from ""_i"",""_j"",""_k"" choice is represented by enum value ""choice""+///+/// @param dp+/// @param df_pathmatrix3+/// @param score+/// @param i+/// @param j+/// @param k+/// @param _i+/// @param _j+/// @param _k+/// @param choice+void update_path3(diff_T *dp, diffcomparisonpath3_T ***df_pathmatrix3,+                  int score, int i, int j, int k, int _i, int _j, int _k,+                  enum path3_choice choice)+{+  df_pathmatrix3[i][j][k].df_lev_score = score;+  for (int __k = 0; __k <= df_pathmatrix3[_i][_j][_k].path_index; __k++) {+    df_pathmatrix3[i][j][k].df_path3[__k]=+      df_pathmatrix3[_i][_j][_k].df_path3[__k]; }+  df_pathmatrix3[i][j][k].path_index = df_pathmatrix3[_i][_j][_k].path_index;+  df_pathmatrix3[i][j][k].df_path3+    [df_pathmatrix3[i][j][k].path_index] = choice;  // this choice+  df_pathmatrix3[i][j][k].path_index++;+}+/// helper function for the diff alignment algorithm copy the newly found+/// optimal path to an index in the tensor for more detailed algorith+/// description, see ""linematch_2buffers"" for the current diff hunk ""dp"",+/// the ""score"" and path at index ""i"",""j""is updated from the path from+/// ""_i"",""_j"",choice is represented by enum value ""choice""+///+/// @param dp+/// @param df_pathmatrix2+/// @param score+/// @param i+/// @param j+/// @param _i+/// @param _j+/// @param choice+void update_path2(diff_T *dp, diffcomparisonpath2_T **df_pathmatrix2,+                  int score, int i, int j, int _i, int _j,+                  enum path2_choice choice)+{+  df_pathmatrix2[i][j].df_lev_score = score;+  for (int k = 0; k <= df_pathmatrix2[_i][_j].path_index; k++) {+    df_pathmatrix2[i][j].df_path2[k]=+      df_pathmatrix2[_i][_j].df_path2[k]; }+  df_pathmatrix2[i][j].path_index = df_pathmatrix2[_i][_j].path_index;+  df_pathmatrix2[i][j].df_path2+    [df_pathmatrix2[i][j].path_index] = choice;  // this choice+  df_pathmatrix2[i][j].path_index++;+}+/// helper function for the calculation of the levenshtein distance+///+/// @param s1+/// @param s2+long levmin(long a, long b, long c)+{+        if (a <= b && a <= c) {+                return a;+        } else if (b <= a && b <= c) {+                return b;+        } else if (c <= a && c <= b) {+                return c;+        }+        return 0;+}+/// levenshtein distance calculation. Return the calculated levenshtein distance+/// between string ""s1"" and ""s2"".+///+/// @param s1+/// @param s2+long levenshtein(const char_u *s1, const char_u *s2)+{+    long x, y;+    long s1len=(long)STRLEN(s1), s2len=(long)STRLEN(s2);+    unsigned long **matrix = xmalloc(sizeof( long * ) * (s2len+1));+    for (long i = 0; i < (s2len+1); i++) {+        matrix[i]=xmalloc(sizeof(long) * (s1len+1));+    }++    matrix[0][0] = 0;+    for (x = 1; x <= s2len; x++) {+        matrix[x][0] = matrix[x-1][0] + 1; }+    for (y = 1; y <= s1len; y++) {+        matrix[0][y] = matrix[0][y-1] + 1; }+    for (x = 1; x <= s2len; x++) {+        for (y = 1; y <= s1len; y++) {+            matrix[x][y] = levmin(matrix[x-1][y] + 1,+                                  matrix[x][y-1] + 1,+                                  matrix[x-1][y-1] + (s1[y-1] ==+                                                      s2[x-1] ? 0 : 1));+        }+    }+    long rvalue = matrix[s2len][s1len];+    for (long i = 0; i < (s2len+1); i++) {+        xfree(matrix[i]);+    }+    xfree(matrix);+    return(rvalue);+}+/// Helper function for the diff alignment algorithm.+/// ""dp->df_comparisonlines"" represents a 2d array. indexed as+/// [buffer][line number] where the line number index represents the+/// offset from the start of the diff block indicated by dp->lnum[id]. The+/// comparison line in the other buffers is initialized to -1. It may+/// remain as -1 if the line is not compared.+///+/// @param dp+/// @param thisb+/// @param thisp+/// @param otherb1+/// @param otherb2+void initialize_compareline3(diff_T *dp, int thisb, int thisp,+                             int otherb1, int otherb2)+{+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb1]=-1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb2]=-1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].newline = false;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].filler = 0;+}+/// Helper function for the diff alignment algorithm.+/// ""dp->df_comparisonlines"" represents a 2d array. indexed as+/// [buffer][line number] where the line number index represents the+/// offset from the start of the diff block indicated by dp->lnum[id]. The+/// comparison line in the other buffers is initialized to -1. It may+/// remain as -1 if the line is not compared.+///+/// @param dp+/// @param thisb+/// @param thisp+/// @param otherb+void initialize_compareline2(diff_T *dp, int thisb, int thisp, int otherb)+{+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].compare[otherb] = -1;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp+                         ].newline = false;+  dp->df_comparisonlines[dp->df_arr_col_size * thisb + thisp].filler = 0;+}+/// the 2d (for two buffers) implementation of the linematch diff+/// algorithm for aligning the most similar lines when constructing diff+/// views. For a general description of the algorithm, see+/// linematch_3buffers+///+/// @param dp+void linematch_2buffers(diff_T *dp)+{+  int b0 = dp->df_valid_buffers[0];+  int b1 = dp->df_valid_buffers[1];+  diffcomparisonpath2_T **df_pathmatrix2 =+    // for previous and next row+    xmalloc( (2) * sizeof( diffcomparisonpath2_T * ));+  for (int i = 0; i < (2); i++) {+    df_pathmatrix2[i]=+      xmalloc((dp->df_count[b1]+1) * sizeof(diffcomparisonpath2_T));+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      df_pathmatrix2[i][j].df_path2=+        xmalloc((dp->df_count[b0]+dp->df_count[b1]) *+                sizeof(enum path2_choice));+    }+  }+  bool icur = 1;+  int score;+  for (int i = 0; i <= dp->df_count[b0]; i++) {+    icur=!icur;+    for (int j = 0; j <= dp->df_count[b1]; j++) {+      if (i == 0 && j == 0) {+        df_pathmatrix2[0][0].df_lev_score = 0;+        df_pathmatrix2[0][0].path_index = 0;+      } else if (i == 0) {+        score = df_pathmatrix2[0][j-1].df_lev_score;+        update_path2(dp, df_pathmatrix2, score, 0, j,  // to+                     0, j-1,  // from+                     DFPATH2_SKIP1);  // choice+      } else if (j == 0) {+        score = df_pathmatrix2[!icur][0].df_lev_score;+        update_path2(dp, df_pathmatrix2, score, icur, 0,  // to+                     !icur, 0,  // from+                     DFPATH2_SKIP0);  // choice+      } else {+         df_pathmatrix2[icur][j].df_lev_score = -1;+        score =+          df_pathmatrix2[!icur][j-1].df_lev_score++          count_matched_chars(+              ml_get_buf(curtab->tp_diffbuf[b0], dp->df_lnum[b0]+i-1, false),+              ml_get_buf(curtab->tp_diffbuf[b1], dp->df_lnum[b1]+j-1, false));+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       !icur, j-1,  // from+                       DFPATH2_COMPARE01);  // choice+        }+        score = df_pathmatrix2[!icur][j].df_lev_score;+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       !icur, j,  // from+                       DFPATH2_SKIP0);  // choice+        }+        score = df_pathmatrix2[icur][j-1].df_lev_score;+        if (score > df_pathmatrix2[icur][j].df_lev_score) {+          update_path2(dp, df_pathmatrix2, score, icur, j,+                       icur, j-1,  // from+                       DFPATH2_SKIP1);  // choice+        }+      }+    }+  }+  int p0 = 0, p1 = 0;  // i, j+  int maxlines = 0;+  if (dp->df_count[b0] > maxlines) { maxlines = dp->df_count[b0]; }+  if (dp->df_count[b1] > maxlines) { maxlines = dp->df_count[b1]; }+  dp->df_arr_col_size = maxlines+1;+  dp->df_comparisonlines=+  xmalloc(DB_COUNT * (dp->df_arr_col_size) * sizeof(df_linecompare_T));+  initialize_compareline2(dp, b0, p0, b1);+  initialize_compareline2(dp, b1, p1, b0);+  for (int i = 0; i < df_pathmatrix2+       [icur][dp->df_count[b1]].path_index; i++) {+    int p = df_pathmatrix2[icur][dp->df_count[b1]].df_path2[i];+    if (p == DFPATH2_SKIP0) {+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].newline = true;+      p0++;+      initialize_compareline2(dp, b0, p0, b1);+    } else if (p == DFPATH2_COMPARE01) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].compare[b1]=p1;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].compare[b0]=p0;+      p1++, p0++;+      initialize_compareline2(dp, b0, p0, b1);+      initialize_compareline2(dp, b1, p1, b0);+    } else if (p == DFPATH2_SKIP1) {+      dp->df_comparisonlines[dp->df_arr_col_size * b0 + p0].filler++;+      dp->df_comparisonlines[dp->df_arr_col_size * b1 + p1].newline = true;+      p1++;+      initialize_compareline2(dp, b1, p1, b0);+    }+  }+  for (int i = 0; i < 2; i++) {+    for (int j = 0; j < (dp->df_count[b1]+1); j++) {+      xfree(df_pathmatrix2[i][j].df_path2);+    }+    xfree(df_pathmatrix2[i]);+  }+  xfree(df_pathmatrix2);+}++/// The 3d case (for 3 buffers) of the algorithm implemented when diffopt+/// 'linematch' is enabled. The algorithm constructs a 3d tensor to+/// compare a diff between 3 buffers. The dimmensions of the tensor are+/// the length of the diff in each buffer plus 1 A path is constructed by+/// moving from one edge of the cube/3d tensor to the opposite edge.+/// Motions from one cell of the cube to the next represent decisions. In+/// a 3d cube, there are a total of 7 decisions that can be made,+/// represented by the enum path3_choice which is defined in+/// buffer_defs.h a comparison of buffer 0 and 1 represents a motion+/// toward the opposite edge of the cube with components along the 0 and+/// 1 axes.  a comparison of buffer 0, 1, and 2 represents a motion+/// toward the opposite edge of the cube with components along the 0, 1,+/// and 2 axes. A skip of buffer 0 represents a motion along only the 0+/// axis. For each action, a point value is awarded, and the path is+/// saved for reference later, if it is found to have been the optimal+/// path. The optimal path has the highest score.  The score is+/// calculated as the summation of the total characters matching between+/// all of the lines which were compared. The structure of the algorithm+/// is that of a dynamic programming problem.  We can calculate a point+/// i,j,k in the cube as a function of i-1, j-1, and k-1. To find the+/// score and path at point i,j,k, we must determine which path we want+/// to use, this is done by looking at the possibilities and choosing+/// the one which results in the local highest score.  The total highest+/// scored path is, then in the end represented by the cell in the+/// opposite corner from the start location.  The entire algorithm+/// consits of populating the 3d cube with the optimal paths from which+/// it may have came.  However, we cannot apply the general 3d case+/// before first populating the edges and the surfaces of the cube.+/// Therefore, there are several sets of if / else statements inside the+/// main loops which determine which case to evaluate.+/// @param dp+void linematch_3buffers(diff_T * dp)","It looks like this could be accomplished with a wrapper function around xdl_diff that calls xdl_diff, collects the necessary output (diff hunk line numbers and count in each buffer, the same information collected by ""emit_cb.outf"" for constructing the diff hunks in ""diff_read"" diff.c), then using this information to call ""linematch_2buffers"".problems to overcome: ""linematch_2buffers"" depends on a diff hunk struct ""diff_T"" being already constructed before the algorithm runs, and it depends on ""ml_get_buf"" to retrieve the lines to generate the comparison scores with the levenshtein distance. Ideally, there may be a way to create a temporary diff_T struct, and set of temporary buffers to retrieve this same information without significantly modifying ""linematch_2buffers"" to achieve this.""linematch_2buffers"" / ""linematch_3buffers"" algorithm is only called when the diff is scrolled into view (or file is edited). This is done by calling the function inside ""diff_check"", which is called when drawing the lines on the screen. By only running the algorithm when a diff is scrolled into view or if it is updated, the algorithm runs only when necessary. If there was a huge file with hundreds of diffs, and every time the file is updated, the ""linematch_2buffers"" would run hundreds of times each time just one part of the file is changed, and this might get laggy. The simple wrapper function idea I suggested would depend on calling the ""linematch_2buffers"" on every diff hunk, no matter if it is scrolled into view or not, then passing the information on to your lua code, so this may be very laggy.I'm not sure exactly the difference in output from your lua code that uses the ""hunk_func"" callback of xdl_diff instead of ""outf"", used in diff.c. What is the difference exactly? I've noticed in ""xdiff_out"", the function passed as ""outf"" for xdl_diff, only the first line (header) is actually used, the rest of the output in the subsequent function calls which contains the text lines of the file and + and - signs is ignored. you say that calling hunk_func omits these context lines? it seems that in that case hunk_func should be used in xdiff_out also, because it ignores the context lines anyway.Do you have suggestions on how to proceed? Do you recommend trying to solve these problems in the same pull request or a new one?",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14583,634989098,2021-05-19T07:41:06Z,runtime/lua/vim/lsp/buf.lua,"@@ -297,26 +297,30 @@ local function pick_call_hierarchy_item(call_hierarchy_items)   return choice end +local function call_hierarchy(method)+  local params = util.make_position_params()+  request('textDocument/prepareCallHierarchy', params, function(err_message, _, result)","minor nit, can you change the callback to use `err` instead of `err_message` like in https://github.com/neovim/neovim/blob/91cdc11984465287539ed8f63716bb371f440ea1/runtime/lua/vim/lsp/handlers.lua#L161`err_message` is also the name of a function we use for error handling: https://github.com/neovim/neovim/blob/91cdc11984465287539ed8f63716bb371f440ea1/runtime/lua/vim/lsp/handlers.lua#L15-L18",
22454918,akinsho,https://api.github.com/repos/neovim/neovim/pulls/14584,635892245,2021-05-20T08:35:41Z,test/functional/plugin/lsp_spec.lua,"@@ -926,6 +926,49 @@ describe('LSP', function()         end;       }     end)++    it('should handle return nil when decoding a list', function()","@mjlbach sorry to be a bother but in the interest of time/trying to get this in for 0.5 I wonder if you could help. The testing helpers for the lsp presume a much better understanding of neovim's client than I have and I'd like to avoid losing too much time trying to wrangle with it.I'm essentially just trying to send a request back and forth from the fake server and assert that `vim.NIL` is kept if the params contains a list but my test keeps failing because the expected callbacks are in the wrong order ���� . There's kind of a lot going on across the various test helpersIs this the kind of test you had in mind, should it be something simpler that just checks the behaviour of `handle_body`?",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14596,636459339,2021-05-20T20:47:31Z,runtime/lua/vim/lsp/util.lua,"@@ -1155,16 +1163,20 @@ function M.fancy_floating_markdown(contents, opts)     if not pcall(vim.cmd, string.format(""syntax include %s syntax/%s.vim"", lang, ft)) then       return     end-    vim.cmd(string.format(""syntax region %s start=+\\%%%dl+ end=+\\%%%dl+ contains=%s"", name, start, finish + 1, lang))+    vim.cmd(string.format(""syntax region %s start=+\\%%%dl+ end=+\\%%%dl+ contains=%s keepend"", name, start, finish + 1, lang))   end   -- Previous highlight region.-  -- TODO(ashkan): this wasn't working for some reason, but I would like to-  -- make sure that regions between code blocks are definitely markdown.-  -- local ph = {start = 0; finish = 1;}+  local ph = 1   for _, h in ipairs(highlights) do-    -- apply_syntax_to_region('markdown', ph.finish, h.start)+    if ph <= h.start - 1 then+      apply_syntax_to_region('lsp_markdown', ph, h.start - 1)","The fix to make the different syn regions work, was to remove the `ownsyntax`, so the buffer has no syntax loaded.The `highlights` list only contains markdown code blocks.So before and after code blocks, we apply the `lsp_markdown` syntax",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14596,636489263,2021-05-20T21:39:50Z,runtime/lua/vim/lsp/util.lua,"@@ -1143,28 +1152,31 @@ function M.fancy_floating_markdown(contents, opts)   api.nvim_win_set_option(winnr, 'conceallevel', 2)   api.nvim_win_set_option(winnr, 'concealcursor', 'n') -  vim.cmd(""ownsyntax lsp_markdown"")   local idx = 1   --@private   local function apply_syntax_to_region(ft, start, finish)-    if ft == '' then return end+    if ft == '' then ft = ""lsp_markdown"" end","The main point of lsp_markdown is to apply conceal rules not offered by markdown to hide escaped characters. In the case of there not being a language tag, there shouldn't be a difference between markdown and plaintex. If there isn't a tag probably plaintex is fine, I doubt there's a noticeable perf difference.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14604,636752968,2021-05-21T08:54:20Z,runtime/lua/vim/lsp/handlers.lua,"@@ -341,17 +341,21 @@ function M.signature_help(_, method, result, _, bufnr, config)     print('No signature help available')     return   end-  local lines = util.convert_signature_help_to_markdown_lines(result)-  lines = util.trim_empty_lines(lines)-  if vim.tbl_isempty(lines) then-    print('No signature help available')-    return-  end-  local syntax = api.nvim_buf_get_option(bufnr, 'syntax')-  local p_bufnr, _ = util.focusable_preview(method, function()-    return lines, util.try_trim_markdown_code_blocks(lines), config+  local p_bufnr, winnr = util.focusable_float(method, function()+    local ft = api.nvim_buf_get_option(bufnr, 'filetype')+    local lines = util.convert_signature_help_to_markdown_lines(result, ft)+    lines = util.trim_empty_lines(lines)+    if vim.tbl_isempty(lines) then+      print('No signature help available')+      return+    end+    local p_bufnr, p_winnr = util.fancy_floating_markdown(lines, {+      border = config.border","If you do that, maybe you can also adapt https://github.com/neovim/neovim/blob/75992f2ad9189a5f39b3e2ae7962c68d3af815a4/runtime/lua/vim/lsp/util.lua#L946-L966 while you're at it? ���� (If it's not too much work.)",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14604,637060806,2021-05-21T16:40:41Z,runtime/lua/vim/lsp/util.lua,"@@ -824,7 +825,12 @@ function M.convert_signature_help_to_markdown_lines(signature_help)   if not signature then     return   end-  vim.list_extend(contents, vim.split(signature.label, '\n', true))+  local label = signature.label+  if ft then+    -- wrap inside a code block so fancy_markdown can render it properly+    label = (""```%s\n%s\n```""):format(ft, label)+  end+  vim.list_extend(contents, vim.split(label, '\n', true))","I dont understand what you mean about changing the buffer contents in relation to the gui rendering?This method already existed and creates the markdown for the signature. The only change here is dat we wrap the label in a code block for better rendering, similar to hover docs etc",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14604,637063314,2021-05-21T16:45:05Z,runtime/lua/vim/lsp/util.lua,"@@ -1154,34 +1163,29 @@ function M.fancy_floating_markdown(contents, opts)   api.nvim_win_set_option(winnr, 'conceallevel', 2)   api.nvim_win_set_option(winnr, 'concealcursor', 'n') +  vim.cmd(""ownsyntax lsp_markdown"")+   local idx = 1   --@private   local function apply_syntax_to_region(ft, start, finish)     if ft == """" then-      vim.cmd(string.format(""syntax region markdownCodeBlock start=+\\%%%dl+ end=+\\%%%dl+ keepend extend"", start, finish + 1))+      vim.cmd(string.format(""syntax region markdownCode start=+\\%%%dl+ end=+\\%%%dl+ keepend extend"", start, finish + 1))       return     end     local name = ft..idx     idx = idx + 1     local lang = ""@""..ft:upper()+    -- HACK: reset current_syntax, since some syntax files like markdown won't load if it is already set","ah no, the issue is not just with `markdown`. Most syntax files wont load if there's already a `current_syntax` set.See the javacript syntax for exanmple:   https://github.com/neovim/neovim/blob/75992f2ad9189a5f39b3e2ae7962c68d3af815a4/runtime/syntax/javascript.vim#L19So loading any other syntax file to apply to a region, might skip loading that syntax altogether",
22454918,akinsho,https://api.github.com/repos/neovim/neovim/pulls/14584,637227647,2021-05-21T20:55:11Z,test/functional/plugin/lsp_spec.lua,"@@ -926,6 +926,49 @@ describe('LSP', function()         end;       }     end)++    it('should handle return nil when decoding a list', function()","@mjlbach I've spent more time plugging away at this now and I'm not really sure how specifically to test this based on the examples in `lsp_spec.lua`. It doesn't have any docs so it's mostly been trial and error/reading through some of the helper implementations.What should the flow be within my test case be? I tried basing it on the issue I saw i.e. I've tried triggering and responding to a code action which should trigger an `executeCommand` if this command contained a list with a `nil` value then if this change was working we'd expect it to get through to the test in `fake_lsp_server.lua` with the `vim.NIL` intact?Trying to trigger the `vim.lsp.buf.code_action()` doesn't seem to do anything i.e. the `textDocument/codeAction` isn't sent to the fake lsp server and none of the subsequent commands are executed, I also can't tell whether it getting through would correctly validate that `NIL` was no longer being filtered out. Just passing notifications through using `client.notify` doesn't seems to make a difference whether I comment out my changes or not.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14615,637392835,2021-05-22T11:38:10Z,runtime/lua/vim/lsp/util.lua,"@@ -1361,6 +1362,45 @@ local position_sort = sort_by_key(function(v)   return {v.start.line, v.start.character} end) +-- Gets the zero-indexed line from the given uri.+-- For non-file uris, we load the buffer and get the line+-- If a loaded buffer exists, then that is used.+-- Otherwise we get the line using libuv which is a lot faster than loading the buffer.+--@param uri string uri of the resource to get the line from+--@param row number zero-indexed line number+--@return string the line at row in filename+function M.get_line(uri, row)+  -- load the buffer if this is not a file uri+  -- NOTE: when does this happen?+  if uri:sub(1, 4) ~= ""file"" then+    local bufnr = vim.uri_to_bufnr(uri)+    vim.fn.bufload(bufnr)+    return (vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false) or { """" })[1]+  end++  local filename = vim.uri_to_fname(uri)++  -- use loaded buffers if available+  if vim.fn.bufloaded(filename) == 1 then+    local bufnr = vim.fn.bufnr(filename, false)+    return (vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false) or { """" })[1]+  end++  local fd = uv.fs_open(filename, ""r"", 438)+  -- TODO: what should we do in this case?+  if not fd then return """" end+  local stat = uv.fs_fstat(fd)+  local data = uv.fs_read(fd, stat.size, 0)+  uv.fs_close(fd)++  local lnum = 0+  for line in string.gmatch(data, ""([^\n]*)\n?"") do","I tried multiple methods to get the line and this was the simplest / fastest. Other methods I tried:* use string.find loop with `plain`. was slower* use `vim.split` slower and actually also lua* using `vim.fn.split` was much slower* match one regex with an endline pattern repeated for `row` times: was a bit faster, but failed for large filesIf anyone has other ideas I might try, let me know :)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14511,637400043,2021-05-22T12:47:18Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1196,42 +1196,62 @@ end ---             - Exclusive severity to consider. Overrides {severity_limit} ---         - {severity_limit}: (DiagnosticSeverity) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.+---         - {workspace}: (boolean, default false)+---             - Set the list with workspace diagnostics function M.set_loclist(opts)   opts = opts or {}    local open_loclist = if_nil(opts.open_loclist, true) -  local bufnr = vim.api.nvim_get_current_buf()-  local buffer_diags = M.get(bufnr, opts.client_id)--  if opts.severity then-    buffer_diags = filter_to_severity_limit(opts.severity, buffer_diags)-  elseif opts.severity_limit then-    buffer_diags = filter_by_severity_limit(opts.severity_limit, buffer_diags)-  end+  local current_bufnr = vim.api.nvim_get_current_buf()+  local diags = opts.workspace and M.get_all() or {+    [current_bufnr] = M.get(current_bufnr, opts.client_id)+  }    local items = {}-  local insert_diag = function(diag)+  local insert_diag = function(bufnr, diag)     local pos = diag.range.start     local row = pos.line-    local col = util.character_offset(bufnr, row, pos.character) -    local line = (api.nvim_buf_get_lines(bufnr, row, row + 1, false) or {""""})[1]+    local line, col, text+    if api.nvim_buf_is_loaded(bufnr) then+      line = (api.nvim_buf_get_lines(bufnr, row, row + 1, false) or {""""})[1]+      col = util.character_offset(bufnr, row, pos.character) or 0+      text = line .. "" | "" .. diag.message+    else+      col = pos.character+      text = diag.message+    end+      table.insert(items, {       bufnr = bufnr,       lnum = row + 1,       col = col + 1,-      text = line .. "" | "" .. diag.message,+      text = text,       type = loclist_type_map[diag.severity or DiagnosticSeverity.Error] or 'E',     })   end -  for _, diag in ipairs(buffer_diags) do-    insert_diag(diag)+  for bufnr, diagnostic in pairs(diags) do+    if opts.severity then+      diagnostic = filter_to_severity_limit(opts.severity, diagnostic)+    elseif opts.severity_limit then+      diagnostic = filter_by_severity_limit(opts.severity_limit, diagnostic)+    end++    for _, diag in ipairs(diagnostic) do+      insert_diag(bufnr, diag)+    end   end -  table.sort(items, function(a, b) return a.lnum < b.lnum end)+  table.sort(items, function(a, b)+    if a.bufnr == b.bufnr then+      return a.lnum < b.lnum+    else+      return a.bufnr < b.bufnr+    end+  end)    util.set_loclist(items)","Do you think it would make sense to split `set_loclist` into a function that returns the diagnostics in loclist/qflist format, so that users could also easily populate the quickfix list instead of the locationlist with the result?The quickfix list might make more sense for diagnostics that are not specific to the buffer in the current window.",
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/14540,637625301,2021-05-24T00:34:32Z,test/functional/legacy/011_autocommands_spec.lua,"@@ -67,10 +67,15 @@ describe('file reading, writing and bufnew and filter autocommands', function()      it('FileReadPost (using gzip)', function()       prepare_gz_file('Xtestfile', text1)-      feed_command('let $GZIP = """"')       --execute('au FileChangedShell * echo ""caught FileChangedShell""')       feed_command('set bin')-      feed_command(""au FileReadPost    *.gz   '[,']!gzip -d"")+      if iswin() then+          feed_command('let $GZIP = """"')","Unfortunately, it does not work for me.So I cannot accept the suggestion.```stack traceback:	test/helpers.lua:73: in function 'expect'	test/functional/legacy/011_autocommands_spec.lua:76: in function <test/functional/legacy/011_autocommands_spec.lua:68> 1 ERROR-- Tests exited non-zero: 1-- Output to stderr:gzip: warning: GZIP environment variable is deprecated; use an alias or scriptXtestfile:	 73.9% -- replaced with Xtestfile.gzgzip: warning: GZIP environment variable is deprecated; use an alias or scriptXtestfile:	 73.9% -- replaced with Xtestfile.gzgzip: warning: GZIP environment variable is deprecated; use an alias or scriptXtestfile:	 73.9% -- replaced with Xtestfile.gz```",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14630,637844195,2021-05-24T10:22:51Z,runtime/lua/vim/lsp/util.lua,"@@ -207,6 +207,7 @@ end --@param text_edits (table) list of `TextEdit` objects --@param buf_nr (number) Buffer id function M.apply_text_edits(text_edits, bufnr)+  bufnr = bufnr or api.nvim_get_current_buf()","I noticed that `bufnr` is `nil` when called though `vim.lsp.buf.formatting_sync()`Most functions accept `0` as the current buffer, but not all functions (like `getmarklist`) accept `nil`",
46855713,smolck,https://api.github.com/repos/neovim/neovim/pulls/12040,639825380,2021-05-26T15:13:41Z,src/nvim/api/private/helpers.c,"@@ -1258,11 +1259,30 @@ Dictionary api_metadata(void)     init_ui_event_metadata(&metadata);     init_error_type_metadata(&metadata);     init_type_metadata(&metadata);+    if (with_docs) {+      init_docs_metadata(&metadata);+    }","I have no idea why, but this doesn't work at all. Running the following Lua code:```lualocal info = vim.api.nvim_get_api {  docs = true}for k, _ in pairs(info) do  print(k)end````info` should contain the docs and thus `docstrings` should be one of the keys printed, but it isn't even in the table: no docstrings. That makes no sense to me, because I did some logging in `nvim_get_api` that confirmed that `api_metadata` _is_ getting a `true` value. What am I missing?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12040,639846371,2021-05-26T15:34:15Z,src/nvim/api/private/helpers.c,"@@ -1258,11 +1259,30 @@ Dictionary api_metadata(void)     init_ui_event_metadata(&metadata);     init_error_type_metadata(&metadata);     init_type_metadata(&metadata);+    if (with_docs) {+      init_docs_metadata(&metadata);+    }",because of static initialization `static Dictionary metadata`,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12040,639850006,2021-05-26T15:35:57Z,src/nvim/api/private/helpers.c,"@@ -1258,11 +1259,30 @@ Dictionary api_metadata(void)     init_ui_event_metadata(&metadata);     init_error_type_metadata(&metadata);     init_type_metadata(&metadata);+    if (with_docs) {+      init_docs_metadata(&metadata);+    }",i e you need to run `init_docs_metadata(&metadata)` and add to the dict _after_ `copy_dictionary`,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14649,641743585,2021-05-28T18:42:38Z,runtime/lua/vim/lsp/util.lua,"@@ -1304,27 +1324,64 @@ function M.open_floating_preview(contents, syntax, opts)     opts = { opts, 't', true };   }   opts = opts or {}+  opts.fancy_markdown = opts.fancy_markdown == nil and true or opts.fancy_markdown+  opts.close_events = opts.close_events or {""CursorMoved"", ""CursorMovedI"", ""BufHidden"", ""InsertCharPre""}++  local bufnr = api.nvim_get_current_buf()++  -- check if this popup is focusable and we need to focus+  if opts.focus_id then+    -- Go back to previous window if we are in a focusable one+    local current_winnr = api.nvim_get_current_win()+    if npcall(api.nvim_win_get_var, current_winnr, opts.focus_id) then+      api.nvim_command(""wincmd p"")+      return bufnr, current_winnr+    end+    do+      local win = find_window_by_var(opts.focus_id, bufnr)+      if win and api.nvim_win_is_valid(win) and vim.fn.pumvisible() == 0 then+        -- focus and return the existing buf, win+        api.nvim_set_current_win(win)+        api.nvim_command(""stopinsert"")+        return api.nvim_win_get_buf(win), win+      end+    end+  end++  local floating_bufnr = api.nvim_create_buf(false, true)+  local is_fancy_markdown = syntax == ""markdown"" and opts.fancy_markdown","Yeah, I guess I'm saying the function argument ""syntax"" seems a bit overloaded to me, as syntax ""markdown""/""lsp_markdown"" conditionally change a lot of paths in the code in the ways that aren't expected. I would say opts.sytlize_markdown = true (defaults to false) + a check that markdown/lsp_markdown are the set syntax if stylize_markdown = true. does that make sense?",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14649,641770616,2021-05-28T19:20:08Z,runtime/lua/vim/lsp/util.lua,"@@ -1304,27 +1324,64 @@ function M.open_floating_preview(contents, syntax, opts)     opts = { opts, 't', true };   }   opts = opts or {}+  opts.fancy_markdown = opts.fancy_markdown == nil and true or opts.fancy_markdown+  opts.close_events = opts.close_events or {""CursorMoved"", ""CursorMovedI"", ""BufHidden"", ""InsertCharPre""}++  local bufnr = api.nvim_get_current_buf()++  -- check if this popup is focusable and we need to focus+  if opts.focus_id then+    -- Go back to previous window if we are in a focusable one+    local current_winnr = api.nvim_get_current_win()+    if npcall(api.nvim_win_get_var, current_winnr, opts.focus_id) then+      api.nvim_command(""wincmd p"")+      return bufnr, current_winnr+    end+    do+      local win = find_window_by_var(opts.focus_id, bufnr)+      if win and api.nvim_win_is_valid(win) and vim.fn.pumvisible() == 0 then+        -- focus and return the existing buf, win+        api.nvim_set_current_win(win)+        api.nvim_command(""stopinsert"")+        return api.nvim_win_get_buf(win), win+      end+    end+  end++  local floating_bufnr = api.nvim_create_buf(false, true)+  local is_fancy_markdown = syntax == ""markdown"" and opts.fancy_markdown+    -- Clean up input: trim empty lines from the end, pad   contents = M._trim(contents, opts) +  if is_fancy_markdown then+    contents = M.format_fancy_markdown(floating_bufnr, contents, opts)+  elseif syntax then+    api.nvim_buf_set_option(floating_bufnr, 'syntax', syntax)+  end+   -- Compute size of float needed to show (wrapped) lines   opts.wrap_at = opts.wrap_at or (vim.wo[""wrap""] and api.nvim_win_get_width(0))   local width, height = M._make_floating_popup_size(contents, opts) -  local floating_bufnr = api.nvim_create_buf(false, true)-  if syntax then-    api.nvim_buf_set_option(floating_bufnr, 'syntax', syntax)-  end   local float_option = M.make_floating_popup_options(width, height, opts)   local floating_winnr = api.nvim_open_win(floating_bufnr, false, float_option)-  if syntax == 'markdown' then+  if syntax == 'markdown' or syntax == ""lsp_markdown"" then","sgtm, if you make the changes we discussed re naming I think we're good after that.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14649,641909780,2021-05-29T08:30:44Z,runtime/lua/vim/lsp/util.lua,"@@ -1304,27 +1324,72 @@ function M.open_floating_preview(contents, syntax, opts)     opts = { opts, 't', true };   }   opts = opts or {}+  opts.stylize_markdown = opts.stylize_markdown == nil and true or opts.stylize_markdown+  opts.close_events = opts.close_events or {""CursorMoved"", ""CursorMovedI"", ""BufHidden"", ""InsertCharPre""}++  local bufnr = api.nvim_get_current_buf()++  -- check if this popup is focusable and we need to focus+  if opts.focus_id then+    -- Go back to previous window if we are in a focusable one+    local current_winnr = api.nvim_get_current_win()+    if npcall(api.nvim_win_get_var, current_winnr, opts.focus_id) then+      api.nvim_command(""wincmd p"")+      return bufnr, current_winnr+    end+    do+      local win = find_window_by_var(opts.focus_id, bufnr)+      if win and api.nvim_win_is_valid(win) and vim.fn.pumvisible() == 0 then+        -- focus and return the existing buf, win+        api.nvim_set_current_win(win)+        api.nvim_command(""stopinsert"")+        return api.nvim_win_get_buf(win), win+      end+    end+  end++  local floating_bufnr = api.nvim_create_buf(false, true)+  local do_stylize = syntax == ""markdown"" and opts.stylize_markdown+    -- Clean up input: trim empty lines from the end, pad   contents = M._trim(contents, opts) +  if do_stylize then+    contents = M.stylize_markdown(floating_bufnr, contents, opts)+  elseif syntax then+    api.nvim_buf_set_option(floating_bufnr, 'syntax', syntax)+    api.nvim_buf_set_lines(floating_bufnr, 0, -1, true, contents)+  end+   -- Compute size of float needed to show (wrapped) lines   opts.wrap_at = opts.wrap_at or (vim.wo[""wrap""] and api.nvim_win_get_width(0))   local width, height = M._make_floating_popup_size(contents, opts) -  local floating_bufnr = api.nvim_create_buf(false, true)-  if syntax then-    api.nvim_buf_set_option(floating_bufnr, 'syntax', syntax)-  end   local float_option = M.make_floating_popup_options(width, height, opts)   local floating_winnr = api.nvim_open_win(floating_bufnr, false, float_option)-  if syntax == 'markdown' then+  if do_stylize then     api.nvim_win_set_option(floating_winnr, 'conceallevel', 2)+    api.nvim_win_set_option(floating_winnr, 'concealcursor', 'n')   end-  api.nvim_buf_set_lines(floating_bufnr, 0, -1, true, contents)+  -- disable folding+  api.nvim_win_set_option(floating_winnr, 'foldenable', false)+  -- soft wrapping+  api.nvim_win_set_option(floating_winnr, 'wrap', true)+  api.nvim_win_set_option(floating_winnr, 'linebreak', true)+  api.nvim_win_set_option(floating_winnr, 'breakindent', true)+  api.nvim_win_set_option(floating_winnr, 'breakindentopt', ""shift:2"")",Philosophically I think it's ok to be opinionated on these windows and not add too many options (which increases complexity) as a lot of people are just going to copy/past and override the handler anyways.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14649,641910569,2021-05-29T08:38:08Z,runtime/lua/vim/lsp/util.lua,"@@ -1304,27 +1324,72 @@ function M.open_floating_preview(contents, syntax, opts)     opts = { opts, 't', true };   }   opts = opts or {}+  opts.stylize_markdown = opts.stylize_markdown == nil and true or opts.stylize_markdown+  opts.close_events = opts.close_events or {""CursorMoved"", ""CursorMovedI"", ""BufHidden"", ""InsertCharPre""}++  local bufnr = api.nvim_get_current_buf()++  -- check if this popup is focusable and we need to focus+  if opts.focus_id then+    -- Go back to previous window if we are in a focusable one+    local current_winnr = api.nvim_get_current_win()+    if npcall(api.nvim_win_get_var, current_winnr, opts.focus_id) then+      api.nvim_command(""wincmd p"")+      return bufnr, current_winnr+    end+    do+      local win = find_window_by_var(opts.focus_id, bufnr)+      if win and api.nvim_win_is_valid(win) and vim.fn.pumvisible() == 0 then+        -- focus and return the existing buf, win+        api.nvim_set_current_win(win)+        api.nvim_command(""stopinsert"")+        return api.nvim_win_get_buf(win), win+      end+    end+  end++  local floating_bufnr = api.nvim_create_buf(false, true)+  local do_stylize = syntax == ""markdown"" and opts.stylize_markdown+    -- Clean up input: trim empty lines from the end, pad   contents = M._trim(contents, opts) +  if do_stylize then+    contents = M.stylize_markdown(floating_bufnr, contents, opts)+  elseif syntax then+    api.nvim_buf_set_option(floating_bufnr, 'syntax', syntax)+    api.nvim_buf_set_lines(floating_bufnr, 0, -1, true, contents)+  end+   -- Compute size of float needed to show (wrapped) lines   opts.wrap_at = opts.wrap_at or (vim.wo[""wrap""] and api.nvim_win_get_width(0))   local width, height = M._make_floating_popup_size(contents, opts) -  local floating_bufnr = api.nvim_create_buf(false, true)-  if syntax then-    api.nvim_buf_set_option(floating_bufnr, 'syntax', syntax)-  end   local float_option = M.make_floating_popup_options(width, height, opts)   local floating_winnr = api.nvim_open_win(floating_bufnr, false, float_option)-  if syntax == 'markdown' then+  if do_stylize then     api.nvim_win_set_option(floating_winnr, 'conceallevel', 2)+    api.nvim_win_set_option(floating_winnr, 'concealcursor', 'n')   end-  api.nvim_buf_set_lines(floating_bufnr, 0, -1, true, contents)+  -- disable folding+  api.nvim_win_set_option(floating_winnr, 'foldenable', false)+  -- soft wrapping+  api.nvim_win_set_option(floating_winnr, 'wrap', true)+  api.nvim_win_set_option(floating_winnr, 'linebreak', true)+  api.nvim_win_set_option(floating_winnr, 'breakindent', true)+  api.nvim_win_set_option(floating_winnr, 'breakindentopt', ""shift:2"")","(Sorry, was typing while you commented; didn't want to beat a dead horse. Now it's fine, thank you!)",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14694,642836713,2021-06-01T07:08:44Z,runtime/lua/vim/lsp/util.lua,"@@ -44,10 +44,20 @@ local function get_border_size(opts)     height = 2     width = 2   else-    height = height + vim.fn.strdisplaywidth(border[2][1])  -- top-    height = height + vim.fn.strdisplaywidth(border[6][1])  -- bottom-    width  = width  + vim.fn.strdisplaywidth(border[4][1])  -- right-    width  = width  + vim.fn.strdisplaywidth(border[8][1])  -- left+    local function border_width(id)+      if type(border[id]) == ""table"" then+        -- border specified as a table of <character, highlight group>+        return vim.fn.strdisplaywidth(border[id][1])+      elseif type(border[id]) == ""table"" then",fixed in the meantime :),
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/14615,643846794,2021-06-02T10:55:11Z,runtime/lua/vim/lsp/util.lua,"@@ -1361,6 +1362,45 @@ local position_sort = sort_by_key(function(v)   return {v.start.line, v.start.character} end) +-- Gets the zero-indexed line from the given uri.+-- For non-file uris, we load the buffer and get the line.+-- If a loaded buffer exists, then that is used.+-- Otherwise we get the line using libuv which is a lot faster than loading the buffer.+--@param uri string uri of the resource to get the line from+--@param row number zero-indexed line number+--@return string the line at row in filename+function M.get_line(uri, row)+  -- load the buffer if this is not a file uri+  -- Custom language server protocol extensions can result in servers sending URIs with custom schemes. Plugins are able to load these via `BufReadCmd` autocmds.+  if uri:sub(1, 4) ~= ""file"" then+    local bufnr = vim.uri_to_bufnr(uri)+    vim.fn.bufload(bufnr)+    return (vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false) or { """" })[1]+  end++  local filename = vim.uri_to_fname(uri)++  -- use loaded buffers if available+  if vim.fn.bufloaded(filename) == 1 then+    local bufnr = vim.fn.bufnr(filename, false)+    return (vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false) or { """" })[1]+  end++  local fd = uv.fs_open(filename, ""r"", 438)+  -- TODO: what should we do in this case?+  if not fd then return """" end+  local stat = uv.fs_fstat(fd)+  local data = uv.fs_read(fd, stat.size, 0)","This still reads the entire file in memory, which may be prohibitive if the file is large. I do realize the libuv approach makes streaming harder, but it's something to consider for the future.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/14615,644087784,2021-06-02T15:39:30Z,runtime/lua/vim/lsp/util.lua,"@@ -1361,6 +1362,45 @@ local position_sort = sort_by_key(function(v)   return {v.start.line, v.start.character} end) +-- Gets the zero-indexed line from the given uri.+-- For non-file uris, we load the buffer and get the line.+-- If a loaded buffer exists, then that is used.+-- Otherwise we get the line using libuv which is a lot faster than loading the buffer.+--@param uri string uri of the resource to get the line from+--@param row number zero-indexed line number+--@return string the line at row in filename+function M.get_line(uri, row)+  -- load the buffer if this is not a file uri+  -- Custom language server protocol extensions can result in servers sending URIs with custom schemes. Plugins are able to load these via `BufReadCmd` autocmds.+  if uri:sub(1, 4) ~= ""file"" then+    local bufnr = vim.uri_to_bufnr(uri)+    vim.fn.bufload(bufnr)+    return (vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false) or { """" })[1]+  end++  local filename = vim.uri_to_fname(uri)++  -- use loaded buffers if available+  if vim.fn.bufloaded(filename) == 1 then+    local bufnr = vim.fn.bufnr(filename, false)+    return (vim.api.nvim_buf_get_lines(bufnr, row, row + 1, false) or { """" })[1]+  end++  local fd = uv.fs_open(filename, ""r"", 438)+  -- TODO: what should we do in this case?+  if not fd then return """" end+  local stat = uv.fs_fstat(fd)+  local data = uv.fs_read(fd, stat.size, 0)","I did it with reading chunks as well, but that was actually slower, since there can then be multiple reads. Probably for very large files it would be faster or course, but figured the added complexity wasn't worth it in the end. ",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/14686,644117187,2021-06-02T16:14:32Z,test/functional/lua/runtime_spec.lua,"@@ -0,0 +1,224 @@+local helpers = require('test.functional.helpers')(after_each)++local clear = helpers.clear+local eq = helpers.eq+local eval = helpers.eval+local exec = helpers.exec+local mkdir_p = helpers.mkdir_p+local rmdir = helpers.rmdir+local write_file = helpers.write_file++describe('runtime:', function()+  local xhome = 'Xhome'+  local pathsep = helpers.get_pathsep()+  local xconfig = xhome .. pathsep .. 'Xconfig'++  before_each(function()+    clear()+    mkdir_p(xconfig .. pathsep .. 'nvim')+  end)++  after_each(function()+    rmdir(xhome)+  end)++  describe('plugin', function()+    before_each(clear)+    it('loads plugin/*.lua from XDG config home', function()+      local plugin_folder_path = table.concat({xconfig, 'nvim', 'plugin'}, pathsep)+      local plugin_file_path = table.concat({plugin_folder_path, 'plugin.lua'}, pathsep)+      mkdir_p(plugin_folder_path)+      write_file(plugin_file_path, [[ vim.g.lua_plugin = 1 ]])++      clear{ args_rm={'-u' }, env={ XDG_CONFIG_HOME=xconfig }}","I don't like using `clear` here to set a new nvim instance in the middle of a test -- it's a bit weird that `mkdir_p` communicates with the firts nvim, then you clear, and then now it's a new nvim as the session.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14730,646050847,2021-06-06T00:00:39Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1202,6 +1202,8 @@ function M.set_loclist(opts)    local open_loclist = if_nil(opts.open_loclist, true) +  local win_id = vim.api.nvim_get_current_win()+   local bufnr = vim.api.nvim_get_current_buf()",Between what two lines? I don't see any race condition here.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14736,646116087,2021-06-06T11:08:54Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1187,24 +1187,29 @@ function M.reset(client_id, buffer_client_map)   end) end ---- Sets the location list----@param opts table|nil Configuration table. Keys:----         - {open_loclist}: (boolean, default true)----             - Open loclist after set++--- Gets the diagnostics in a format that is compatible with the+--- quickfix-/locationlist+---+--- To populate the quickfix list, you can use this function like so:+---+---     vim.fn.setqflist({}, 'r', {+---       title = 'Language Server';+---       items = vim.lsp.diagnostic.get_as_qfitems { workspace = true }+---     })+---+---@param opts table|nil Configuration table. ---         - {client_id}: (number) ---             - If nil, will consider all clients attached to buffer. ---         - {severity}: (DiagnosticSeverity) ---             - Exclusive severity to consider. Overrides {severity_limit} ---         - {severity_limit}: (DiagnosticSeverity) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid. ---         - {workspace}: (boolean, default false)----             - Set the list with workspace diagnostics-function M.set_loclist(opts)+---             - Include workspace diagnostics. If false (default) only+---               diagnostics for the current buffer are included.+function M.get_as_qfitems(opts)","Maybe something like `locations_to_items` would be more descriptive? And possibly put it in `util.lua`? (Depending on how specific it is to diagnostics)As an aside, I see the LSP API as basically having three layers:1. the server-facing layer, which in naming, data structures and handling should follow LSP terminology as closely as possible (talking about `Locations` and `Tokens` and whatnot) -- these are functions in `lsp.lua` etc.2. the vim-facing layer, which should ""speak vim"" -- `clist`, `loclist` etc. -- these are functions in `buf.lua` and `diagnostic.lua`3. a set of (exposed) utility functions that translate between the two and live in `util.lua` ",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14736,646117777,2021-06-06T11:22:29Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1187,24 +1187,29 @@ function M.reset(client_id, buffer_client_map)   end) end ---- Sets the location list----@param opts table|nil Configuration table. Keys:----         - {open_loclist}: (boolean, default true)----             - Open loclist after set++--- Gets the diagnostics in a format that is compatible with the+--- quickfix-/locationlist+---+--- To populate the quickfix list, you can use this function like so:+---+---     vim.fn.setqflist({}, 'r', {+---       title = 'Language Server';+---       items = vim.lsp.diagnostic.get_as_qfitems { workspace = true }+---     })+---+---@param opts table|nil Configuration table. ---         - {client_id}: (number) ---             - If nil, will consider all clients attached to buffer. ---         - {severity}: (DiagnosticSeverity) ---             - Exclusive severity to consider. Overrides {severity_limit} ---         - {severity_limit}: (DiagnosticSeverity) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid. ---         - {workspace}: (boolean, default false)----             - Set the list with workspace diagnostics-function M.set_loclist(opts)+---             - Include workspace diagnostics. If false (default) only+---               diagnostics for the current buffer are included.+function M.get_as_qfitems(opts)","Yes I was considering a `diagnostic_to_items` in `util.lua` first. It's also what I have in my dotfiles https://github.com/mfussenegger/dotfiles/blob/579ab91da5b14ba20766f2acc11d855a56aa0a5f/vim/.config/nvim/lua/me/lsp/diagnostic.lua#L5-L25 it takes the diagnostic grouped by bufnr and a predicate -  you can use it like this:```  local items = diagnostics_to_items(    vim.lsp.diagnostic.get_all(),    function(d) return d.severity == vim.lsp.protocol.DiagnosticSeverity.Error end  )```I'd prefer that variant (and trimming the amount of supported options). The reason I went with this `get_as_qfitems` is mostly because of how `set_loclist` already supports a lot of options.I'll wait and see what the others have to say.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14736,646134724,2021-06-06T13:40:43Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1187,24 +1187,29 @@ function M.reset(client_id, buffer_client_map)   end) end ---- Sets the location list----@param opts table|nil Configuration table. Keys:----         - {open_loclist}: (boolean, default true)----             - Open loclist after set++--- Gets the diagnostics in a format that is compatible with the+--- quickfix-/locationlist+---+--- To populate the quickfix list, you can use this function like so:+---+---     vim.fn.setqflist({}, 'r', {+---       title = 'Language Server';+---       items = vim.lsp.diagnostic.get_as_qfitems { workspace = true }+---     })+---+---@param opts table|nil Configuration table. ---         - {client_id}: (number) ---             - If nil, will consider all clients attached to buffer. ---         - {severity}: (DiagnosticSeverity) ---             - Exclusive severity to consider. Overrides {severity_limit} ---         - {severity_limit}: (DiagnosticSeverity) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid. ---         - {workspace}: (boolean, default false)----             - Set the list with workspace diagnostics-function M.set_loclist(opts)+---             - Include workspace diagnostics. If false (default) only+---               diagnostics for the current buffer are included.+function M.get_as_qfitems(opts)","I pushed another fixup - adding a `util.diagnostics_to_items`. It also includes a fix for `set_loclist` (previously if `workspace` was `true`, the `client_id` option was ignored)Let me know which variant you prefer, the initial variant in the first commit - or the one in the last commit.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14122,647000030,2021-06-07T23:13:18Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,95 @@+local M = {}++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++function M._handle_semantic_tokens_full(client_id, bufnr, response)",since the module is already called semantic tokes I guess you can drop it to make the function names more terse,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/14758,648500163,2021-06-09T16:56:35Z,CONTRIBUTING.md,"@@ -74,16 +74,26 @@ For Comment) and `[RDY]` (Ready).  ### Commit messages -Follow [commit message hygiene][hygiene] to *make reviews easier* and to make-the VCS/git logs more valuable.+Follow the [convential commits guidelines][conventional_commits] to *make reviews easier* and to make+the VCS/git logs more valuable. The general structure of a commit message is as follows: -- Try to keep the first line under 72 characters.-- **Prefix the commit subject with a _scope_:** `doc:`, `test:`, `foo.c:`,+```+<type>([optional scope]): <description>++[optional body]++[optional footer(s)]+```++- **Prefix the commit subject with a _type_:** `doc:`, `test:`, `foo.c:`,","I think the `foo.c` does not belong here anymore ?```suggestion- **Prefix the commit subject with a _type_:** `doc:`, `test:````",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14122,649516635,2021-06-10T20:39:28Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,95 @@+local M = {}++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++function M._handle_semantic_tokens_full(client_id, bufnr, response)+  local client = vim.lsp.get_client_by_id(client_id)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local prev_line, prev_start = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    prev_line = prev_line and prev_line + delta_line or delta_line+    local delta_start = data[i + 1]+    prev_start = delta_line == 0 and prev_start + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    if delta_line == 0 and tokens[prev_line + 1] then+      table.insert(tokens[prev_line + 1], #tokens, {+        start_col = prev_start,+        length = data[i + 2],+        type = token_type,+        modifiers = modifiers+      })+    else+      tokens[prev_line + 1] = {+        {+          start_col = prev_start,+          length = data[i + 2],+          type = token_type,+          modifiers = modifiers+        }+      }+    end+  end++  if semantic_tokens[client_id] then+    semantic_tokens[client_id][bufnr] = tokens+  else+    semantic_tokens[client_id] = { [bufnr] = tokens }+  end+end++function M.request_tokens_full(client_id, bufnr)+  bufnr = bufnr or vim.fn.bufnr()+  local uri = vim.uri_from_bufnr(bufnr)+  local params = { textDocument = { uri = uri }; }++  -- TODO(smolck): Not sure what the other params to this are/mean+  local handler = function(_, _, response, _, _)+    M._handle_semantic_tokens_full(client_id, bufnr, response)+  end++  local client = vim.lsp.get_client_by_id(client_id)+  return client.request('textDocument/semanticTokens/full', params, handler)+end++function M.on_refresh()+  local bufnr = vim.fn.bufnr()+  -- TODO(smolck): Just do the active clients for the current buffer?+  -- If so, how to get those?",on_refresh is triggered by a particular language server so we should also use this server that requested a refresh: https://github.com/theHamsta/neovim/blob/33de6be20b21a250a9374d25bd0fb9e6cb288664/runtime/lua/vim/lsp/semantic_tokens.lua#L113 (but actually using the client_id :sweat_smile: ),
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14122,649524035,2021-06-10T20:51:59Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,95 @@+local M = {}++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++function M._handle_semantic_tokens_full(client_id, bufnr, response)",I would prefer it. Especially for `'lsp.semantic_tokens'.get_semantic_tokens()` a `'lsp.semantic_tokens'.get()` would feel better. But I `get` is feels also a bit unsafe for external users since they must know when to request tokens. Maybe a subscription to token changes would be better?I also played a bit around with this PR: https://github.com/theHamsta/neovim/blob/81f20e363c95437b12eec600eb003a9b54b5d7d4/runtime/lua/vim/lsp/semantic_tokens.lua#L1,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14122,649524809,2021-06-10T20:53:20Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,95 @@+local M = {}++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++function M._handle_semantic_tokens_full(client_id, bufnr, response)+  local client = vim.lsp.get_client_by_id(client_id)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local prev_line, prev_start = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    prev_line = prev_line and prev_line + delta_line or delta_line+    local delta_start = data[i + 1]+    prev_start = delta_line == 0 and prev_start + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    if delta_line == 0 and tokens[prev_line + 1] then+      table.insert(tokens[prev_line + 1], #tokens, {+        start_col = prev_start,+        length = data[i + 2],+        type = token_type,+        modifiers = modifiers+      })+    else+      tokens[prev_line + 1] = {+        {+          start_col = prev_start,","why not use the same names as from the LSP spec?```lua    local token = {      line = line,      start_char = start_char,      length = data[i + 2],      type = token_type,      modifiers = modifiers    }```",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/14122,649525545,2021-06-10T20:54:39Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,95 @@+local M = {}++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++function M._handle_semantic_tokens_full(client_id, bufnr, response)+  local client = vim.lsp.get_client_by_id(client_id)+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local prev_line, prev_start = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    prev_line = prev_line and prev_line + delta_line or delta_line+    local delta_start = data[i + 1]+    prev_start = delta_line == 0 and prev_start + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    if delta_line == 0 and tokens[prev_line + 1] then+      table.insert(tokens[prev_line + 1], #tokens, {","if and else branch are essentially the same code. Maybe?```lua    local token = {      line = line,      start_char = start_char,      length = data[i + 2],      type = token_type,      modifiers = modifiers    }    tokens[line + 1] = tokens[line + 1] or {}    table.insert(tokens[line + 1], token)```",x
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14761,649629631,2021-06-11T01:30:00Z,src/nvim/normal.c,"@@ -1025,10 +1025,14 @@ static int normal_execute(VimState *state, int key)     // If you give a count before AND after the operator, they are     // multiplied.     if (s->ca.count0) {-      s->ca.count0 *= s->ca.opcount;+      s->ca.count0 = (long)((uint64_t)s->ca.count0 * (uint64_t)s->ca.opcount);",I still don't understand how (un)signed integer overflow works so I used the largest unsigned type I know and then cast the result back to long.,
16781840,pohzipohzi,https://api.github.com/repos/neovim/neovim/pulls/14795,650484102,2021-06-13T07:36:09Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -461,38 +517,47 @@ end  --- Helper function to iterate through all of the diagnostic lines ---@return table list of diagnostics-local _iter_diagnostic_lines = function(start, finish, step, bufnr, opts, client_id)-  if bufnr == nil then-    bufnr = vim.api.nvim_get_current_buf()-  end-+local _iter_diagnostic_lines = function(cursor_position, search_forward, bufnr, opts, client_id)","> I don't think it makes sense anymore for this function to be iter_diagnostic_lines, I think we should probably rename it something like iter_diagnostic_positioni realise this can return a single diagnostic instead of a list of diagnostics, so i renamed it to `next_diagnostic` instead. What do you think?> it might make sense to have an iter_diagnostic_lines function as well (instead of replacing the old one)this function is internal and doesn't look like it's used anywhere else, so i'll prefer if we can avoid keeping the old one> Maybe the new function should be iter_diagnostic_range, and instead of having a ""search_forward"" param have a start/end param that correspond to the buf position.not sure if i understand this. The previous implementation supported wrapping by scanning through lines twice (eg. curr_line+1 to last_line, 1 to curr_line-1). I updated the implementation to use a offset+modulo to iterate through positions more easily, `search_forward` here is just a boolean switch to handle the various cases. For example, if we are searching forward and a diagnostic appears on the right of the same line, the nearest diagnostic to the right is returned",
13974112,ckipp01,https://api.github.com/repos/neovim/neovim/pulls/13165,650519169,2021-06-13T12:30:32Z,runtime/lua/vim/lsp/codelens.lua,"@@ -0,0 +1,223 @@+local util = require('vim.lsp.util')+local api = vim.api+local M = {}++--- bufnr -> client_id -> lenses+local lens_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end+})++local namespaces = setmetatable({}, {+  __index = function(t, key)+    local value = api.nvim_create_namespace('vim_lsp_codelens:' .. key)+    rawset(t, key, value)+    return value+  end;+})++--@private+M.__namespaces = namespaces+++--- Return all lenses for the given buffer+---@return table (`CodeLens[]`)+function M.get(bufnr)+  local lenses_by_client = lens_cache_by_buf[bufnr]+  if not lenses_by_client then return {} end+  local lenses = {}+  for _, client_lenses in pairs(lenses_by_client) do+    vim.list_extend(lenses, client_lenses)+  end+  return lenses+end+++--@private+local function execute_lens(lens, bufnr, client_id)+  local line = lens.range.start.line+  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)++  -- Need to use the client that returned the lens ��� must not use buf_request+  local client = vim.lsp.get_client_by_id(client_id)+  assert(client, 'Client is required to execute lens, client_id=' .. client_id)+  client.request('workspace/executeCommand', lens.command, function(...)+    local result = vim.lsp.handlers['workspace/executeCommand'](...)+    M.refresh()+    return result+  end, bufnr)+end+++--- Run the code lens in the current line+---+function M.run()+  local line = api.nvim_win_get_cursor(0)[1]+  local bufnr = api.nvim_get_current_buf()+  local options = {}+  local lenses_by_client = lens_cache_by_buf[bufnr] or {}+  for client, lenses in pairs(lenses_by_client) do+    for _, lens in pairs(lenses) do+      if lens.range.start.line == (line - 1) then+        table.insert(options, {client=client, lens=lens})+      end+    end+  end+  if #options == 0 then+    print('No executable codelens found at current line')+  elseif #options == 1 then+    local option = options[1]+    execute_lens(option.lens, bufnr, option.client)+  else+    local options_strings = {""Code lenses:""}+    for i, option in ipairs(options) do+       table.insert(options_strings, string.format('%d. %s', i, option.lens.command.title))+    end+    local choice = vim.fn.inputlist(options_strings)+    if choice < 1 or choice > #options then+      return+    end+    local option = options[choice]+    execute_lens(option.lens, bufnr, option.client)+  end+end+++--- Display the lenses using virtual text+---+---@param lenses table of lenses to display (`CodeLens[] | null`)+---@param bufnr number+---@param client_id number+function M.display(lenses, bufnr, client_id)+  if not lenses or not next(lenses) then+    return+  end+  local lenses_by_lnum = {}+  for _, lens in pairs(lenses) do+    local line_lenses = lenses_by_lnum[lens.range.start.line]+    if not line_lenses then+      line_lenses = {}+      lenses_by_lnum[lens.range.start.line] = line_lenses+    end+    table.insert(line_lenses, lens)+  end+  local ns = namespaces[client_id]+  local num_lines = api.nvim_buf_line_count(bufnr)+  for i = 0, num_lines do+    local line_lenses = lenses_by_lnum[i]+    api.nvim_buf_clear_namespace(bufnr, ns, i, i + 1)+    local chunks = {}+    for _, lens in pairs(line_lenses or {}) do+      local text = lens.command and lens.command.title or 'Unresolved lens ...'+      table.insert(chunks, {text, 'LspCodeLens' })+    end+    if #chunks > 0 then+      api.nvim_buf_set_virtual_text(bufnr, ns, i, chunks, {})+    end+  end+end+++--- Store lenses for a specific buffer and client+---+---@param lenses table of lenses to store (`CodeLens[] | null`)+---@param bufnr number+---@param client_id number+function M.save(lenses, bufnr, client_id)+  local lenses_by_client = lens_cache_by_buf[bufnr]+  if not lenses_by_client then+    lenses_by_client = {}+    lens_cache_by_buf[bufnr] = lenses_by_client+    local ns = namespaces[client_id]+    api.nvim_buf_attach(bufnr, false, {+      on_detach = function(b) lens_cache_by_buf[b] = nil end,+      on_lines = function(_, b, _, first_lnum, last_lnum)+        api.nvim_buf_clear_namespace(b, ns, first_lnum, last_lnum)+      end+    })+  end+  lenses_by_client[client_id] = lenses+end+++--@private+local function resolve_lenses(lenses, bufnr, client_id, callback)+  lenses = lenses or {}+  local num_lens = vim.tbl_count(lenses)+  if num_lens == 0 then+    callback()+    return+  end++  --@private+  local function countdown()+    num_lens = num_lens - 1+    if num_lens == 0 then+      callback()+    end+  end+  local ns = namespaces[client_id]+  local client = vim.lsp.get_client_by_id(client_id)+  for _, lens in pairs(lenses or {}) do+    if lens.command then+      countdown()+      goto continue+    end++    client.request('codeLens/resolve', lens, function(_, _, result)+      if result and result.command then+        lens.command = result.command+        -- Eager display to have some sort of incremental feedback+        -- Once all lenses got resolved there will be a full redraw for all lenses+        -- So that multiple lens per line are properly displayed+        api.nvim_buf_set_virtual_text(+          bufnr,+          ns,+          lens.range.start.line,+          {{ lens.command.title, 'LspCodeLens' },},+          {}+        )+      end+      countdown()+    end, bufnr)++    ::continue::+  end+end+++--- |lsp-handler| for the method `textDocument/codeLens`+---+function M.on_codelens(err, _, result, client_id, bufnr)+  assert(not err, vim.inspect(err))++  M.save(result, bufnr, client_id)++  -- Eager display for any resolved (and unresolved) lenses and refresh them+  -- once resolved.+  M.display(result, bufnr, client_id)+  resolve_lenses(result, bufnr, client_id, function()+    M.display(result, bufnr, client_id)+  end)+end+++--- Refresh the codelens for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- <pre>+---   autocmd BufEnter,CursorHold,InsertLeave <buffer> lua vim.lsp.codelens.refresh()+--- </pre>+---","> We could at least add a buf_version check using lsp.util.buf_versions, so that it doesn't re-resolve codelenses if the buffer didn't change.It might be nice to have, but I'm curious how often that will be the case where you're making no changes at all, but going into insert etc. Also that could technically cause issues for `BufEnter` as well. For example in Metals one of the code lenses we have is to navigate up the stack of super/parent methods. So in reality you could leave the buffer, change something, and then go back to this buffer and the code lens actually should be refreshed since something in another buffer could have impacted it. However, that's probably not that common of a use case.",
13974112,ckipp01,https://api.github.com/repos/neovim/neovim/pulls/13165,650526489,2021-06-13T13:24:24Z,runtime/lua/vim/lsp/codelens.lua,"@@ -0,0 +1,223 @@+local util = require('vim.lsp.util')+local api = vim.api+local M = {}++--- bufnr -> client_id -> lenses+local lens_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end+})++local namespaces = setmetatable({}, {+  __index = function(t, key)+    local value = api.nvim_create_namespace('vim_lsp_codelens:' .. key)+    rawset(t, key, value)+    return value+  end;+})++--@private+M.__namespaces = namespaces+++--- Return all lenses for the given buffer+---@return table (`CodeLens[]`)+function M.get(bufnr)+  local lenses_by_client = lens_cache_by_buf[bufnr]+  if not lenses_by_client then return {} end+  local lenses = {}+  for _, client_lenses in pairs(lenses_by_client) do+    vim.list_extend(lenses, client_lenses)+  end+  return lenses+end+++--@private+local function execute_lens(lens, bufnr, client_id)+  local line = lens.range.start.line+  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)++  -- Need to use the client that returned the lens ��� must not use buf_request+  local client = vim.lsp.get_client_by_id(client_id)+  assert(client, 'Client is required to execute lens, client_id=' .. client_id)+  client.request('workspace/executeCommand', lens.command, function(...)+    local result = vim.lsp.handlers['workspace/executeCommand'](...)+    M.refresh()+    return result+  end, bufnr)+end+++--- Run the code lens in the current line+---+function M.run()+  local line = api.nvim_win_get_cursor(0)[1]+  local bufnr = api.nvim_get_current_buf()+  local options = {}+  local lenses_by_client = lens_cache_by_buf[bufnr] or {}+  for client, lenses in pairs(lenses_by_client) do+    for _, lens in pairs(lenses) do+      if lens.range.start.line == (line - 1) then+        table.insert(options, {client=client, lens=lens})+      end+    end+  end+  if #options == 0 then+    print('No executable codelens found at current line')+  elseif #options == 1 then+    local option = options[1]+    execute_lens(option.lens, bufnr, option.client)+  else+    local options_strings = {""Code lenses:""}+    for i, option in ipairs(options) do+       table.insert(options_strings, string.format('%d. %s', i, option.lens.command.title))+    end+    local choice = vim.fn.inputlist(options_strings)+    if choice < 1 or choice > #options then+      return+    end+    local option = options[choice]+    execute_lens(option.lens, bufnr, option.client)+  end+end+++--- Display the lenses using virtual text+---+---@param lenses table of lenses to display (`CodeLens[] | null`)+---@param bufnr number+---@param client_id number+function M.display(lenses, bufnr, client_id)+  if not lenses or not next(lenses) then+    return+  end+  local lenses_by_lnum = {}+  for _, lens in pairs(lenses) do+    local line_lenses = lenses_by_lnum[lens.range.start.line]+    if not line_lenses then+      line_lenses = {}+      lenses_by_lnum[lens.range.start.line] = line_lenses+    end+    table.insert(line_lenses, lens)+  end+  local ns = namespaces[client_id]+  local num_lines = api.nvim_buf_line_count(bufnr)+  for i = 0, num_lines do+    local line_lenses = lenses_by_lnum[i]+    api.nvim_buf_clear_namespace(bufnr, ns, i, i + 1)+    local chunks = {}+    for _, lens in pairs(line_lenses or {}) do+      local text = lens.command and lens.command.title or 'Unresolved lens ...'","Maybe a future improvement, but what do you think about adding a way to add in a prefix symbol similar to the way diagnostics is done. I know for myself I'd love to easily be able to have a `���` preface or something denoting a lens.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14804,650575757,2021-06-13T20:49:20Z,src/nvim/api/vim.c,"@@ -1437,26 +1437,28 @@ void nvim_chan_send(Integer chan, String data, Error *err) ///                    end-of-buffer region is hidden by setting `eob` flag of ///                    'fillchars' to a space char, and clearing the ///                    |EndOfBuffer| region in 'winhighlight'.-///   - `border`: style of (optional) window border. This can either be a string-///      or an array. the string values are:-///     - ""none"" No border. This is the default-///     - ""single"" a single line box-///     - ""double"" a double line box-///     - ""shadow"" a drop shadow effect by blending with the background.-///     If it is an array it should be an array of eight items or any divisor of+///   - `border`: Style of (optional) window border. This can either be a string+///      or an array. The string values are+///     - ""none"": No border (default).+///     - ""single"": A single line box.+///     - ""double"": A double line box.+///     - ""rounded"": Like ""single"", but with rounded corners (""���"" etc.).+///     - ""solid"": Adds padding by a single whitespace cell.+///     - ""shadow"": A drop shadow effect by blending with the background.  ","Lint failure is related to this line, where I added two spaces at the end to introduce a line break (which is standard Markdown). Otherwise the following line -- which starts a new topic, array arguments -- runs into the final item of the list of valid string arguments.If there is a better way of separating these two, I'd love to hear about it.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/13165,651193296,2021-06-14T18:49:28Z,runtime/lua/vim/lsp/codelens.lua,"@@ -0,0 +1,223 @@+local util = require('vim.lsp.util')+local api = vim.api+local M = {}++--- bufnr -> client_id -> lenses+local lens_cache_by_buf = setmetatable({}, {+  __index = function(t, b)+    local key = b > 0 and b or api.nvim_get_current_buf()+    return rawget(t, key)+  end+})++local namespaces = setmetatable({}, {+  __index = function(t, key)+    local value = api.nvim_create_namespace('vim_lsp_codelens:' .. key)+    rawset(t, key, value)+    return value+  end;+})++--@private+M.__namespaces = namespaces+++--- Return all lenses for the given buffer+---@return table (`CodeLens[]`)+function M.get(bufnr)+  local lenses_by_client = lens_cache_by_buf[bufnr]+  if not lenses_by_client then return {} end+  local lenses = {}+  for _, client_lenses in pairs(lenses_by_client) do+    vim.list_extend(lenses, client_lenses)+  end+  return lenses+end+++--@private+local function execute_lens(lens, bufnr, client_id)+  local line = lens.range.start.line+  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)++  -- Need to use the client that returned the lens ��� must not use buf_request+  local client = vim.lsp.get_client_by_id(client_id)+  assert(client, 'Client is required to execute lens, client_id=' .. client_id)+  client.request('workspace/executeCommand', lens.command, function(...)+    local result = vim.lsp.handlers['workspace/executeCommand'](...)+    M.refresh()+    return result+  end, bufnr)+end+++--- Run the code lens in the current line+---+function M.run()",Can't think of a good reason. If you wanted to call this from somewhere else you'd also need to provide the line number. Not sure in which situation you'd know which lens to run from elsewhere?If a use-case does pop up it is easier to extend later than to remove in case we anticipate the wrong thing.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14804,651667882,2021-06-15T10:40:53Z,src/nvim/api/vim.c,"@@ -1437,26 +1437,28 @@ void nvim_chan_send(Integer chan, String data, Error *err) ///                    end-of-buffer region is hidden by setting `eob` flag of ///                    'fillchars' to a space char, and clearing the ///                    |EndOfBuffer| region in 'winhighlight'.-///   - `border`: style of (optional) window border. This can either be a string-///      or an array. the string values are:-///     - ""none"" No border. This is the default-///     - ""single"" a single line box-///     - ""double"" a double line box-///     - ""shadow"" a drop shadow effect by blending with the background.-///     If it is an array it should be an array of eight items or any divisor of+///   - `border`: Style of (optional) window border. This can either be a string+///      or an array. The string values are+///     - ""none"": No border (default).+///     - ""single"": A single line box.+///     - ""double"": A double line box.+///     - ""rounded"": Like ""single"", but with rounded corners (""���"" etc.).+///     - ""solid"": Adds padding by a single whitespace cell.+///     - ""shadow"": A drop shadow effect by blending with the background.  ","Ignoring lint sets a bad precedent ;)(It didn't even work, so I saw no point introducing a lint failure that would pollute future PRs.)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14584,652046517,2021-06-15T18:22:35Z,runtime/lua/vim/lsp/rpc.lua,"@@ -50,9 +50,11 @@ recursive_convert_NIL = function(v, tbl_processed)     return nil   elseif not tbl_processed[v] and type(v) == 'table' then     tbl_processed[v] = true-    return vim.tbl_map(function(x)-      return recursive_convert_NIL(x, tbl_processed)-    end, v)+    if not vim.tbl_islist(v) then","This will also mean that dictionaries within tables will no longer be recursively processed. Maybe we should acount for that and only keep `vim.NIL` in lists, but still recurse into dictionary-style-tables ?",
22454918,akinsho,https://api.github.com/repos/neovim/neovim/pulls/14584,652104461,2021-06-15T19:51:09Z,runtime/lua/vim/lsp/rpc.lua,"@@ -50,9 +50,11 @@ recursive_convert_NIL = function(v, tbl_processed)     return nil   elseif not tbl_processed[v] and type(v) == 'table' then     tbl_processed[v] = true-    return vim.tbl_map(function(x)-      return recursive_convert_NIL(x, tbl_processed)-    end, v)+    if not vim.tbl_islist(v) then",Just pushed a changed which should allow trimming `vim.NIL` in dictionaries but spare lists ��������,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14824,652909755,2021-06-16T17:41:29Z,src/nvim/api/buffer.c,"@@ -1683,7 +1683,7 @@ Integer nvim_buf_set_extmark(Buffer buffer, Integer ns_id,   }    if (col2 >= 0) {-    if (line2 >= 0 && line2 < buf->b_ml.ml_line_count) {+    if (!ephemeral && line2 >= 0 && line2 < buf->b_ml.ml_line_count) {",maybe could repeat the same pattern here? :),
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/14844,653488485,2021-06-17T11:47:49Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -59,42 +59,47 @@ string(REPLACE "";"" ""-"" fname ""${fname}"") set(file ${DOWNLOAD_DIR}/${fname}) message(STATUS ""file: ${file}"") -message(STATUS ""downloading...-     src='${URL}'-     dst='${file}'-     timeout='${timeout_msg}'"")--file(DOWNLOAD ${URL} ${file}-  ${timeout_args}-  ${hash_args}-  STATUS status-  LOG log)--list(GET status 0 status_code)-list(GET status 1 status_string)--if(NOT status_code EQUAL 0)-  # Retry on certain errors, e.g. CURLE_COULDNT_RESOLVE_HOST, which is often-  # seen with libtermkey (www.leonerd.org.uk).-  if((status_code EQUAL 6)  # ""Couldn't resolve host name""-    OR (status_code EQUAL 7))  # ""Couldn't connect to server""-    message(STATUS ""warning: retrying '${URL}' (${status_string}, status ${status_code})"")-    execute_process(COMMAND ${CMAKE_COMMAND} -E sleep 10)-    file(DOWNLOAD ${URL} ${file}-      ${timeout_args}-      ${hash_args}-      STATUS status-      LOG log)-    list(GET status 0 status_code)-    list(GET status 1 status_string)-  endif()-  if(NOT status_code EQUAL 0)-    message(FATAL_ERROR ""error: downloading '${URL}' failed-  status_code: ${status_code}-  status_string: ${status_string}-  log: ${log}-"")-  endif()+if(EXISTS ${file})",The entire download step has been enclosed by this condition.This will cause the download to never happen if the file wasn't downloaded yet.,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/14868,655014910,2021-06-21T00:49:26Z,src/nvim/lua/executor.c,"@@ -1417,20 +1427,20 @@ void ex_luafile(exarg_T *const eap) /// /// @param  path  path of the file ///-/// @return  true if everything ok, false if there was an error (echoed)+/// @return  false when unable to loadfile othewise return true","LGTM, but maybe be explicit here that `false` is returned if opening or reading the file fails (to disambiguate it from the other things `loadfile` does).",
541289,dstein64,https://api.github.com/repos/neovim/neovim/pulls/14884,658331717,2021-06-24T22:42:07Z,src/nvim/window.c,"@@ -4647,9 +4659,30 @@ win_free (   /* Remove the window from the b_wininfo lists, it may happen that the    * freed memory is re-used for another window. */   FOR_ALL_BUFFERS(buf) {-    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)-      if (wip->wi_win == wp)+    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next) {+      if (wip->wi_win == wp) {+        wininfo_T *wip2;++        // If there already is an entry with ""wi_win"" set to NULL it+        // must be removed, it would never be used.+        for (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next) {",The code in the loop is independent of `wip`.,
541289,dstein64,https://api.github.com/repos/neovim/neovim/pulls/14884,658352650,2021-06-24T23:31:45Z,src/nvim/window.c,"@@ -4647,9 +4659,30 @@ win_free (   /* Remove the window from the b_wininfo lists, it may happen that the    * freed memory is re-used for another window. */   FOR_ALL_BUFFERS(buf) {-    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next)-      if (wip->wi_win == wp)+    for (wip = buf->b_wininfo; wip != NULL; wip = wip->wi_next) {+      if (wip->wi_win == wp) {+        wininfo_T *wip2;++        // If there already is an entry with ""wi_win"" set to NULL it+        // must be removed, it would never be used.+        for (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next) {","I guess the intent to have that in the loop is to have it as part of the `if` clause, whose condition is a function of `wip`, but I'm not sure.",
34201958,ericonr,https://api.github.com/repos/neovim/neovim/pulls/14786,658373055,2021-06-25T00:33:59Z,src/nvim/tui/tui.c,"@@ -53,16 +53,16 @@  #define TOO_MANY_EVENTS 1000000 #define STARTS_WITH(str, prefix) (strlen(str) >= (sizeof(prefix) - 1) \-    && 0 == memcmp((str), (prefix), sizeof(prefix) - 1))-#define TMUX_WRAP(is_tmux, seq) ((is_tmux) \-    ? ""\x1bPtmux;\x1b"" seq ""\x1b\\"" : seq)+                    && 0 == memcmp((str), (prefix), sizeof(prefix) - 1))",I kept the macro definition in two lines because otherwise it would be too long.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/12481,659090899,2021-06-26T00:16:57Z,src/nvim/screen.c,"@@ -7116,7 +7116,24 @@ void ui_ext_tabline_update(void)      ADD(tabs, DICTIONARY_OBJ(tab_info));   }-  ui_call_tabline_update(curtab->handle, tabs);++  Array buffers = ARRAY_DICT_INIT;+  FOR_ALL_BUFFERS(buf) {+    // Do not include unlisted buffers+    if (!buf->b_p_bl) {",```$ git grep b_p_bl '*.h'src/nvim/buffer_defs.h:682:  int b_p_bl;                   ///< 'buflisted'```Unset buflisted on some buffer in a new test.Create the test in `test/functional/ui/tabline_spec.lua`.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14349,660223806,2021-06-29T01:53:01Z,runtime/doc/options.txt,"@@ -5227,11 +5227,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=-		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command-		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellquote= shellxquote=+		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command\ [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;",Need a test to justify putting this in the docs or reference because the option value is so long.. Existing tests didn't need to change default input/output encoding of powershell.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14930,660694439,2021-06-29T14:48:43Z,src/nvim/lua/treesitter.c,"@@ -1073,7 +1073,10 @@ static int node_rawquery(lua_State *L)   // TODO(bfredl): these are expensive allegedly,   // use a reuse list later on?   TSQueryCursor *cursor = ts_query_cursor_new();+  // TODO(clason): use of prerelease API; remove guard after ts bump to 0.19.6","Not need, but probably want. I assume that we will before long bump the minimum required version to 0.19.6 anyway; this reminds me to remove the guard _if_ that bump happens.But I can also remove the TODO if you prefer?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14930,660715148,2021-06-29T15:10:51Z,src/nvim/lua/treesitter.c,"@@ -1073,7 +1073,10 @@ static int node_rawquery(lua_State *L)   // TODO(bfredl): these are expensive allegedly,   // use a reuse list later on?   TSQueryCursor *cursor = ts_query_cursor_new();+  // TODO(clason): use of prerelease API; remove guard after ts bump to 0.19.6","well it is quite likely we will depend on yet newer TS API during the 0.6 cycle. While there is no hurry to remove it right after 0.19.6 is released, it is probably going to be defunct not long after.",
62146989,cbarrete,https://api.github.com/repos/neovim/neovim/pulls/14935,660997612,2021-06-29T22:10:20Z,runtime/doc/mbyte.txt,"@@ -335,8 +335,8 @@ Vim will automatically convert from one to another encoding in several places:   ""utf-8"" (requires a gettext version that supports this). - When reading a Vim script where |:scriptencoding| is different from   ""utf-8"".-Most of these require the |+iconv| feature.  Conversion for reading and","Oh yeah my bad, I didn't spot that, thanks",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14349,661857444,2021-06-30T22:43:47Z,runtime/doc/options.txt,"@@ -5227,11 +5227,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=-		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command-		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellquote= shellxquote=+		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command\ [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;","Screen test is fine for validating powershell output in the buffer.I'd start with `system()`, `systemlist`, `jobstart()`) which can accept stdin for unicode characters and can pass its output to Vimscript  variables so that you don't need to use screen tests.The tests should set the shell options directly to assert the expected results on different input/output encodings.Add/update powershell tests in `test/functional/eva/system_spec.lua`, `test/functional/core/job_spec.lua`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14848,662210799,2021-07-01T11:34:08Z,runtime/autoload/provider/clipboard.vim,"@@ -175,6 +182,10 @@ function! s:clipboard.set(lines, regtype, reg) abort    if s:cache_enabled == 0     call s:try_cmd(s:copy[a:reg], a:lines)+    ""Cache it anyway we can compare it later to get regtype of the yank+    let s:selections[a:reg] = copy(s:selection)+    let s:selections[a:reg].data = [a:lines, a:regtype]+    let s:selections[a:reg].stderr_buffered = v:false","Yes, that's fair, but for future reference: commenting on the **beginning** of a block is often ambiguous with the entire block, but I like to think a line being quoted in the middle of a block refers to that line only.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14349,662403446,2021-07-01T15:44:42Z,runtime/doc/options.txt,"@@ -5227,11 +5227,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=-		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command-		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellquote= shellxquote=+		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command\ [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;",That's fine. Create a similar test for `systemlist()` and I'll merge.,
886074,teto,https://api.github.com/repos/neovim/neovim/pulls/14946,662410168,2021-07-01T15:53:39Z,runtime/syntax/vim.vim,"@@ -644,7 +651,7 @@ syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' e ""   g:vimsyn_embed =~# 'r' : embed ruby ""   g:vimsyn_embed =~# 't' : embed tcl if !exists(""g:vimsyn_embed"")- let g:vimsyn_embed = 'l'+ let g:vimsyn_embed= ""lmpPr""",I think there was a perf performance but lua being first class citizen was not axed.,
847299,dtcaciuc,https://api.github.com/repos/neovim/neovim/pulls/14349,662629342,2021-07-01T22:35:05Z,runtime/doc/options.txt,"@@ -5227,11 +5227,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=-		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command-		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellquote= shellxquote=+		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command\ [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;","Re: odd newline after the character, apparently that's what systemlist does on Windows? https://vim-jp.org/vimdoc-en/eval.html#systemlist()",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14349,662678321,2021-07-02T01:26:27Z,runtime/doc/options.txt,"@@ -5227,11 +5227,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	Note that such processing is done after |:set| did its own round of  	unescaping, so to keep yourself sane use |:let-&| like shown above. 							*shell-powershell*-	To use powershell: >+	To use PowerShell: > 		let &shell = has('win32') ? 'powershell' : 'pwsh'-		set shellquote= shellpipe=\| shellxquote=-		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command-		set shellredir=\|\ Out-File\ -Encoding\ UTF8+		set shellquote= shellxquote=+		set shellcmdflag=-NoLogo\ -NoProfile\ -ExecutionPolicy\ RemoteSigned\ -Command\ [Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8;","Yes, crlf is not converted to lf for systemlist.",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/14349,662683366,2021-07-02T01:44:00Z,test/functional/ex_cmds/make_spec.lua,"@@ -0,0 +1,45 @@+local helpers = require('test.functional.helpers')(after_each)+local clear = helpers.clear+local eval = helpers.eval+local has_powershell = helpers.has_powershell+local has_pwsh = helpers.has_pwsh",unused.`make lint` failed.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14971,663361552,2021-07-03T12:47:52Z,runtime/doc/repeat.txt,"@@ -172,42 +172,34 @@ Using Vim scripts					*using-scripts* For writing a Vim script, see chapter 41 of the user manual |usr_41.txt|.  					*:so* *:source* *load-vim-script*-:so[urce] {file}	Runs vim or lua {file}","this wording is mushy. Let's be precise (yet concise) where we can, without being pedantic.",x
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/14985,663534185,2021-07-04T17:29:55Z,CMakeLists.txt,"@@ -387,7 +387,7 @@ include_directories(SYSTEM ${LIBUV_INCLUDE_DIRS}) find_package(Msgpack 1.0.0 REQUIRED) include_directories(SYSTEM ${MSGPACK_INCLUDE_DIRS}) -find_package(LibLUV 1.30.0 REQUIRED)+find_package(LibLUV 1.34.1 REQUIRED)","> For plugins that want to use more exposed functions. See: https://github.com/jose-elias-alvarez/null-ls.nvim/pull/23Some plugins also require ffi, but that doesn't mean nvim does. This specifies the minimum that nvim requires.Plugins should handle validating their base requirements are satisfied or use alternatives, rather than assuming nvim is built against a certain dependency version.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14985,663535134,2021-07-04T17:37:47Z,CMakeLists.txt,"@@ -387,7 +387,7 @@ include_directories(SYSTEM ${LIBUV_INCLUDE_DIRS}) find_package(Msgpack 1.0.0 REQUIRED) include_directories(SYSTEM ${MSGPACK_INCLUDE_DIRS}) -find_package(LibLUV 1.30.0 REQUIRED)+find_package(LibLUV 1.34.1 REQUIRED)","Makes sense -- we haven't done that so far, and we shouldn't start now (with a single dependency)._If_ that is done, it should be done across the board and documented as a breaking change. (The bump to `third-party` is sufficient to make the default build use the newer version, so leaving the minimum version lower is fine.)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14985,663554045,2021-07-04T20:39:25Z,CMakeLists.txt,"@@ -387,7 +387,7 @@ include_directories(SYSTEM ${LIBUV_INCLUDE_DIRS}) find_package(Msgpack 1.0.0 REQUIRED) include_directories(SYSTEM ${MSGPACK_INCLUDE_DIRS}) -find_package(LibLUV 1.30.0 REQUIRED)+find_package(LibLUV 1.34.1 REQUIRED)","Sorry.So the `Lib_LUV` in the _toplevel_ `CMakeLists.txt` is the minimum version required for Neovim itself to build successfully -- it tells distributions not to try to build against _earlier_ versions by erroring out early, because the basic functionality is known to be broken then.The version in `third-party/CMakeLists.txt` is the version Neovim bundles in CI and for the _official_ releases -- this can include nice-to-have features but is usually ignored by distributions (who build against their own versions, which is fine as long as that version is newer than the one specified in the top-level file). So the latter is what you want to make newer features accessible to the plugin ecosystem (in order not to fall behind distributions); the former is what you want to _force_ distributions to upgrade their own versions (which you'd only do if Neovim itself is unusable with earlier versions).",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14795,663566037,2021-07-04T22:43:00Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -459,63 +516,69 @@ end -- }}} -- Diagnostic Movements {{{ ---- Helper function to iterate through all of the diagnostic lines----@return table list of diagnostics-local _iter_diagnostic_lines = function(start, finish, step, bufnr, opts, client_id)-  if bufnr == nil then-    bufnr = vim.api.nvim_get_current_buf()-  end-+--- Helper function to find the next diagnostic relative to a position+---@return table the next diagnostic if found+local _next_diagnostic = function(position, search_forward, bufnr, opts, client_id)+  position[1] = position[1] - 1+  bufnr = bufnr or vim.api.nvim_get_current_buf()   local wrap = if_nil(opts.wrap, true)--  local search = function(search_start, search_finish, search_step)-    for line_nr = search_start, search_finish, search_step do-      local line_diagnostics = M.get_line_diagnostics(bufnr, line_nr, opts, client_id)-      if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then-        return line_diagnostics+  local line_count = vim.api.nvim_buf_line_count(bufnr)+  for i = 0, line_count do+    local offset = i * (search_forward and 1 or -1)+    local line_nr = position[1] + offset+    if line_nr < 0 or line_nr >= line_count then+      if not wrap then+        return       end+      line_nr = (line_nr + line_count) % line_count     end-  end--  local result = search(start, finish, step)--  if wrap then-    local wrap_start, wrap_finish-    if step == 1 then-      wrap_start, wrap_finish = 1, start-    else-      wrap_start, wrap_finish = vim.api.nvim_buf_line_count(bufnr), start-    end--    if not result then-      result = search(wrap_start, wrap_finish, step)+    local line_diagnostics = M.get_line_diagnostics(bufnr, line_nr, opts, client_id)+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then+      if search_forward then","These blocks seem like a lot of duplicated code, could turn into a small function that takes a comparison operator",x
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14987,663659232,2021-07-05T06:03:47Z,test/functional/lua/buffer_updates_spec.lua,"@@ -365,129 +367,129 @@ describe('lua: nvim_buf_attach on_bytes', function()    -- Yes, we can do both   local function do_both(verify)-    it('single and multiple join', function()-        local check_events = setup_eventcheck(verify, origlines)-        feed 'ggJ'-        check_events {-          {'test1', 'bytes', 1, 3, 0, 15, 15, 1, 0, 1, 0, 1, 1};-        }--        feed '3J'-        check_events {-          {'test1', 'bytes', 1, 5, 0, 31, 31, 1, 0, 1, 0, 1, 1};-          {'test1', 'bytes', 1, 5, 0, 47, 47, 1, 0, 1, 0, 1, 1};-        }+    it(""single and multiple join"", function()+      local check_events = setup_eventcheck(verify, origlines)+      feed ""ggJ""+      check_events {+        { ""test1"", ""bytes"", 1, 3, 0, 15, 15, 1, 0, 1, 0, 1, 1 },+      }++      feed ""3J""+      check_events {+        { ""test1"", ""bytes"", 1, 5, 0, 31, 31, 1, 0, 1, 0, 1, 1 },+        { ""test1"", ""bytes"", 1, 5, 0, 47, 47, 1, 0, 1, 0, 1, 1 },+      }     end) -    it('opening lines', function()-        local check_events = setup_eventcheck(verify, origlines)-        -- meths.buf_set_option(0, 'autoindent', true)-        feed 'Go'-        check_events {-          { ""test1"", ""bytes"", 1, 4, 7, 0, 114, 0, 0, 0, 1, 0, 1 };-        }-        feed '<cr>'-        check_events {-          { ""test1"", ""bytes"", 1, 5, 7, 0, 114, 0, 0, 0, 1, 0, 1 };-        }+    it(""opening lines"", function()+      local check_events = setup_eventcheck(verify, origlines)+      -- meths.buf_set_option(0, 'autoindent', true)+      feed ""Go""+      check_events {+        { ""test1"", ""bytes"", 1, 4, 7, 0, 114, 0, 0, 0, 1, 0, 1 },+      }+      feed ""<cr>""+      check_events {+        { ""test1"", ""bytes"", 1, 5, 7, 0, 114, 0, 0, 0, 1, 0, 1 },+      }     end) -    it('opening lines with autoindent', function()-        local check_events = setup_eventcheck(verify, origlines)-        meths.buf_set_option(0, 'autoindent', true)-        feed 'Go'-        check_events {-          { ""test1"", ""bytes"", 1, 4, 7, 0, 114, 0, 0, 0, 1, 0, 5 };-        }-        feed '<cr>'-        check_events {-          { ""test1"", ""bytes"", 1, 4, 7, 0, 114, 0, 4, 4, 0, 0, 0 };-          { ""test1"", ""bytes"", 1, 5, 7, 0, 114, 0, 0, 0, 1, 4, 5 };-        }+    it(""opening lines with autoindent"", function()+      local check_events = setup_eventcheck(verify, origlines)+      meths.buf_set_option(0, ""autoindent"", true)+      feed ""Go""+      check_events {+        { ""test1"", ""bytes"", 1, 4, 7, 0, 114, 0, 0, 0, 1, 0, 5 },+      }+      feed ""<cr>""+      check_events {+        { ""test1"", ""bytes"", 1, 4, 7, 0, 114, 0, 4, 4, 0, 0, 0 },+        { ""test1"", ""bytes"", 1, 5, 7, 0, 114, 0, 0, 0, 1, 4, 5 },+      }     end) -    it('setline(num, line)', function()+    it(""setline(num, line)"", function()       local check_events = setup_eventcheck(verify, origlines)       funcs.setline(2, ""babla"")       check_events {-        { ""test1"", ""bytes"", 1, 3, 1, 0, 16, 0, 15, 15, 0, 5, 5 };+        { ""test1"", ""bytes"", 1, 3, 1, 0, 16, 0, 15, 15, 0, 5, 5 },       } -      funcs.setline(2, {""foo"", ""bar""})+      funcs.setline(2, { ""foo"", ""bar"" })       check_events {-        { ""test1"", ""bytes"", 1, 4, 1, 0, 16, 0, 5, 5, 0, 3, 3 };","Can this conversion be disabled? I like the semantic distinction between `,` (between fields of a tuple) and `;` (after item in a ordered list of tuples) in places like this.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15011,665336968,2021-07-07T12:47:54Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1108,7 +1110,42 @@ function M.display(diagnostics, bufnr, client_id, config)   if signs_opts then     M.set_signs(diagnostics, bufnr, client_id, nil, signs_opts)   end++  -- cache extmarks+  M.save_extmarks(bufnr, client_id)+end++-- caches the extmarks set by M.display+function M.save_extmarks(bufnr, client_id)+  local ns = vim.lsp.diagnostic._get_diagnostic_namespace(client_id)+  diagnostic_cache_extmarks[bufnr][client_id] = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true}) end++-- restores the extmarks set by M.display+function M.restore_extmarks(bufnr)+  local lcount = vim.api.nvim_buf_line_count(bufnr)+  for client_id, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do+    local ns = vim.lsp.diagnostic._get_diagnostic_namespace(client_id)+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})+    local found = {}+    for _, extmark in ipairs(extmarks_current) do+      -- HACK: the missing extmakrs seems to still exist, but at the line after the last+      if extmark[2] < lcount then+        found[extmark[1]] = true+      end+    end+    for _, extmark in ipairs(extmarks) do+      if not found[extmark[1]] then+        local opts = extmark[4]+        opts.id = extmark[1]+        -- HACK: end_row is somtimes present, but not a valid option+        opts.end_row = nil","seems we accidentally `end_line` in set_extmarks instead :P, while we can't remove it, we could allow either:```// Integer nvim_buf_set_extmark(Buffer buffer, Integer ns_id, ...)...    } else if (strequal(""end_line"", k.data) || strequal(""end_row"", k.data)) {```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15011,665432170,2021-07-07T14:34:03Z,runtime/lua/vim/lsp.lua,"@@ -1042,6 +1042,7 @@ do     if tbl_isempty(all_buffer_active_clients[bufnr] or {}) then       return     end+    lsp.diagnostic.restore_extmarks(bufnr)","Given that we don't use any of the additional information that is being provided in these handlers, wouldn't it make sense to try to encapsulate this within the diagnostic module with a dedicated `buf_attach` `on_lines` listener?I think it is kinda nice that currently `lsp.diagnostic` is pretty self-contained. We also wouldn't have to expose `M.save_extmarks` and `M.restore_extmarks` and they currently look a lot like implementation detail and not like something we'd want users to call directly?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/12971,665718624,2021-07-07T21:29:45Z,src/nvim/buffer_defs.h,"@@ -525,6 +525,7 @@ struct file_buffer {   int b_flags;                  // various BF_ flags   int b_locked;                 // Buffer is being closed or referenced, don't                                 // let autocommands wipe it out.+  int b_ro_locked;              // Replacement for curbuf_lock","meaningless as `curbuf_lock` no longer exists, instead something like the removed comment there  `/// Non-zero when the buffer can't be changed.  Used for FileChangedRO.`",
894255,donbex,https://api.github.com/repos/neovim/neovim/pulls/15017,665755851,2021-07-07T22:52:39Z,runtime/lua/vim/uri.lua,"@@ -52,7 +52,7 @@ end  --@private local function is_windows_file_uri(uri)-  return uri:match('^file:///[a-zA-Z]:') ~= nil+  return uri:match('^file:/+[a-zA-Z]:') ~= nil","If I understand your suggestion correctly, that's actually what I wanted to do at first. Unfortunately Lua's pattern matching system is much less powerful than regular expressions and it does not allow optional matches (besides repetition).In other words, a pattern like the regular expression `^file:/(//)?[a-zA-Z]:` is not supported in Lua.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14844,665815652,2021-07-08T01:57:14Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -59,44 +59,55 @@ string(REPLACE "";"" ""-"" fname ""${fname}"") set(file ${DOWNLOAD_DIR}/${fname}) message(STATUS ""file: ${file}"") -message(STATUS ""downloading...-     src='${URL}'-     dst='${file}'-     timeout='${timeout_msg}'"")--file(DOWNLOAD ${URL} ${file}-  ${timeout_args}-  ${hash_args}-  STATUS status-  LOG log)--list(GET status 0 status_code)-list(GET status 1 status_string)--if(NOT status_code EQUAL 0)-  # Retry on certain errors, e.g. CURLE_COULDNT_RESOLVE_HOST, which is often-  # seen with libtermkey (www.leonerd.org.uk).-  if((status_code EQUAL 6)  # ""Couldn't resolve host name""-    OR (status_code EQUAL 7))  # ""Couldn't connect to server""-    message(STATUS ""warning: retrying '${URL}' (${status_string}, status ${status_code})"")-    execute_process(COMMAND ${CMAKE_COMMAND} -E sleep 10)-    file(DOWNLOAD ${URL} ${file}-      ${timeout_args}-      ${hash_args}-      STATUS status-      LOG log)-    list(GET status 0 status_code)-    list(GET status 1 status_string)-  endif()+set(existing_match FALSE)","1. don't need this extra variable, just set `EXISTING_SHA256` to empty string here . then the `if(NOT existing_match)` condition can be changed to `if(NOT EXISTING_SHA256 STREQUAL ""${EXPECTED_SHA256}"")`2. use 2-space indent",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14871,665818936,2021-07-08T02:07:57Z,src/nvim/json/lua_cjson.c,"@@ -0,0 +1,1590 @@+/* Lua CJSON - JSON support for Lua+ *+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>+ *+ * Permission is hereby granted, free of charge, to any person obtaining+ * a copy of this software and associated documentation files (the+ * ""Software""), to deal in the Software without restriction, including+ * without limitation the rights to use, copy, modify, merge, publish,+ * distribute, sublicense, and/or sell copies of the Software, and to+ * permit persons to whom the Software is furnished to do so, subject to+ * the following conditions:+ *+ * The above copyright notice and this permission notice shall be+ * included in all copies or substantial portions of the Software.+ *+ * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.+ */++/* Caveats:+ * - JSON ""null"" values are represented as lightuserdata since Lua+ *   tables cannot contain ""nil"". Compare with cjson.null.",we removed use of lightuserdata in https://github.com/neovim/neovim/pull/7880,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14871,665826888,2021-07-08T02:34:04Z,src/nvim/json/lua_cjson.c,"@@ -0,0 +1,1590 @@+/* Lua CJSON - JSON support for Lua+ *+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>+ *+ * Permission is hereby granted, free of charge, to any person obtaining+ * a copy of this software and associated documentation files (the+ * ""Software""), to deal in the Software without restriction, including+ * without limitation the rights to use, copy, modify, merge, publish,+ * distribute, sublicense, and/or sell copies of the Software, and to+ * permit persons to whom the Software is furnished to do so, subject to+ * the following conditions:+ *+ * The above copyright notice and this permission notice shall be+ * included in all copies or substantial portions of the Software.+ *+ * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.+ */++/* Caveats:+ * - JSON ""null"" values are represented as lightuserdata since Lua+ *   tables cannot contain ""nil"". Compare with cjson.null.","Definitely going to remove the internal cjson null representation and replace with vim.NIL, so no lightuserdata when done (that's why we have to vendor this instead of just adding the library), just haven't finished yet :) ",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15026,666045931,2021-07-08T09:53:33Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1199,18 +1199,19 @@ function M.show_line_diagnostics(opts, bufnr, line_nr, client_id)   end    local line_diagnostics = M.get_line_diagnostics(bufnr, line_nr, opts, client_id)-  if vim.tbl_isempty(line_diagnostics) then return end+  local num_diagnostics = vim.tbl_count(line_diagnostics)+  if num_diagnostics == 0 then return end    for i, diagnostic in ipairs(line_diagnostics) do-    local prefix = string.format(""%d. "", i)+    local prefix = num_diagnostics == 1 and '' or string.format(""%d. "", i)","Should we do a `'%0' .. tostring(math.log(...)) .. '%d'` here to ensure all listed items are aligned the same if there are more than 9, or more than 99 diagnostics?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14844,666419056,2021-07-08T18:15:05Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -59,41 +59,48 @@ string(REPLACE "";"" ""-"" fname ""${fname}"") set(file ${DOWNLOAD_DIR}/${fname}) message(STATUS ""file: ${file}"") -message(STATUS ""downloading...-     src='${URL}'-     dst='${file}'-     timeout='${timeout_msg}'"")--file(DOWNLOAD ${URL} ${file}-  ${timeout_args}-  ${hash_args}-  STATUS status-  LOG log)--list(GET status 0 status_code)-list(GET status 1 status_string)--if(NOT status_code EQUAL 0)-  # Retry on certain errors, e.g. CURLE_COULDNT_RESOLVE_HOST, which is often-  # seen with libtermkey (www.leonerd.org.uk).-  if((status_code EQUAL 6)  # ""Couldn't resolve host name""-    OR (status_code EQUAL 7))  # ""Couldn't connect to server""-    message(STATUS ""warning: retrying '${URL}' (${status_string}, status ${status_code})"")-    execute_process(COMMAND ${CMAKE_COMMAND} -E sleep 10)-    file(DOWNLOAD ${URL} ${file}-      ${timeout_args}-      ${hash_args}-      STATUS status-      LOG log)-    list(GET status 0 status_code)-    list(GET status 1 status_string)-  endif()+set(EXISTING_SHA256 """")+if(EXISTS ${file})+  file(SHA256 ${file} EXISTING_SHA256)+endif()++if(NOT EXISTING_SHA256 STREQUAL ${EXPECTED_SHA256})",> is it possible that EXPECTED_SHA256 is empty string?Looks like no: https://github.com/neovim/neovim/blob/490615612ed5ec587c8023de28db495b3181de30/third-party/cmake/DownloadAndExtractFile.cmake#L13,
4975310,stsewd,https://api.github.com/repos/neovim/neovim/pulls/14999,666674419,2021-07-09T05:09:59Z,runtime/lua/vim/treesitter/query.lua,"@@ -175,11 +173,22 @@ function M.get_node_text(node, source)   local end_row, end_col, end_byte = node:end_()    if type(source) == ""number"" then-    if start_row ~= end_row then-      return nil+    local lines+    if end_col == 0 then+      lines = a.nvim_buf_get_lines(source, start_row, end_row, true)","You'll need to check for start/end row not being larger than the number of lines of the buffer, similar to https://github.com/neovim/neovim/pull/15030/ ",
4975310,stsewd,https://api.github.com/repos/neovim/neovim/pulls/14999,667083064,2021-07-09T16:45:29Z,runtime/lua/vim/treesitter/query.lua,"@@ -175,11 +173,22 @@ function M.get_node_text(node, source)   local end_row, end_col, end_byte = node:end_()    if type(source) == ""number"" then-    if start_row ~= end_row then-      return nil+    local lines+    if end_col == 0 then+      lines = a.nvim_buf_get_lines(source, start_row, end_row, true)","he, this is kind of hard to replicate with the c parser, as it needs to have a node that includes the EOF mark at the start and/or end of de node. I was using this to replicate cases like this```lualocal parsers = require ""nvim-treesitter.parsers""local query = require ""vim.treesitter.query""local function print(str)  vim.api.nvim_err_writeln(vim.inspect(str))endlocal function show(node)  print { node:start() }  print { node:end_() }  print(query.get_node_text(node, 0))endlocal lang = ""ruby""local parser = parsers.get_parser(0, lang)local tree = parser:parse()[1]local node = tree:root()local q = query.parse_query(lang, ""(heredoc_end) @this"")for pattern, match, metadata in q:iter_matches(node, 0, 1, 4) do  for id, n in pairs(match) do    show(n)  endend```Executed while having this file open```rubydef run  a = <<~Eend```I think is easier to test this mocking the node, but don't know if that's possible to do in those tests.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14795,668183797,2021-07-12T19:05:53Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -1167,6 +1230,70 @@ end -- }}} -- Diagnostic User Functions {{{ +--- Open a floating window with the diagnostics from {position}+---+--- The floating window can be customized with the following highlight groups:+--- <pre>+--- LspDiagnosticsFloatingError+--- LspDiagnosticsFloatingWarning+--- LspDiagnosticsFloatingInformation+--- LspDiagnosticsFloatingHint+--- </pre>+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header.+---@param bufnr number The buffer number+---@param position table The (0,0)-indexed position+---@param client_id number|nil the client id+---@return table {popup_bufnr, win_id}+function M.show_position_diagnostics(opts, bufnr, position, client_id)+  opts = opts or {}++  local show_header = if_nil(opts.show_header, true)++  bufnr = bufnr or 0+  if not position then+    local curr_position = vim.api.nvim_win_get_cursor(0)+    curr_position[1] = curr_position[1] - 1+    position = curr_position+  end++  local lines = {}+  local highlights = {}+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  local position_diagnostics = M.get_position_diagnostics(bufnr, position, opts, client_id)+  if vim.tbl_isempty(position_diagnostics) then return end++  for i, diagnostic in ipairs(position_diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = M._get_floating_severity_highlight_name(diagnostic.severity)+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix, hiname})+    for j = 2, #message_lines do+      table.insert(lines, message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  opts.focus_id = ""position_diagnostics""+  local popup_bufnr, winnr = util.open_floating_preview(lines, 'plaintext', opts)+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end",This looks pretty much like a 1:1 copy of the `show_line_diagnostics` except that it misses improvements like done in https://github.com/neovim/neovim/commit/e43dbfdd05d09e28ee0468f1cd1808f859807606 and retrieves different diagnostics.I think you could extract the common logic related to displaying the diagnostic into an internal `show_diagnostic` function that is parameterized with the diagnostics that should be displayed and then call that function both from `show_line_diagnostics` and from this new function.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13268,668950028,2021-07-13T16:58:27Z,runtime/doc/vim_diff.txt,"@@ -72,6 +72,12 @@ the differences.  - |g:vimsyn_embed| defaults to ""l"" to enable Lua highlighting +==============================================================================+3. Nvim default Mappings                              *nvim-default-mappings*","don't need to mention ""Nvim"" in a section of a doc where every line in the doc is relevant to Nvim.```suggestion3. Default Mappings                              *nvim-default-mappings*```That also usually applies to tags, but the tags for vim_diff are an exception. They are the only tags that start with `nvim-`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13268,668952523,2021-07-13T17:01:49Z,runtime/doc/change.txt,"@@ -985,10 +985,7 @@ inside of strings can change!  Also see 'softtabstop' option. > [""x]yy			Yank [count] lines [into register x] |linewise|.  							*Y*-[""x]Y			yank [count] lines [into register x] (synonym for-			yy, |linewise|).  If you like ""Y"" to work from the-			cursor to the end of line (which is more logical,-			but not Vi-compatible) use "":map Y y$"".+[""x]Y			Yank [count] lines from the cursor to the end of line.","The doc for `:help Y` would not change (except we can delete the `If you like ""Y""...` passage), rather the pattern would be something like this: 1. mention the default mapping next to the (legacy) builtin.2. add a tag like `*Y-default*````*Y-default*This command is mapped to ""y$"" by default. |nvim-default-mappings|```",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15113,671662543,2021-07-17T09:22:16Z,runtime/doc/lsp.txt,"@@ -1630,23 +1630,29 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.handlers                                    *lsp-handlers* -                                         *vim.lsp.handlers.progress_handler()*-progress_handler({_}, {_}, {params}, {client_id})-                See also: ~-                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand+                                                    *vim.lsp.handlers.hover()*+hover({_}, {method}, {result}, {_}, {_}, {config})+                |lsp-handler| for the method ""textDocument/hover"" >",This sentence is incomplete,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15113,671662597,2021-07-17T09:22:40Z,runtime/doc/lsp.txt,"@@ -1630,23 +1630,29 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()* ============================================================================== Lua module: vim.lsp.handlers                                    *lsp-handlers* -                                         *vim.lsp.handlers.progress_handler()*-progress_handler({_}, {_}, {params}, {client_id})-                See also: ~-                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand+                                                    *vim.lsp.handlers.hover()*+hover({_}, {method}, {result}, {_}, {_}, {config})+                |lsp-handler| for the method ""textDocument/hover"" >++                 vim.lsp.handlers[""textDocument/hover""] = vim.lsp.with(+                   vim.lsp.handlers.hover, {+                     -- Use a sharp border with `FloatBorder` highlights+                     border = ""single""+                   }+                 )+< -                                           *vim.lsp.handlers.signature_help()*-signature_help({_}, {method}, {result}, {client_id}, {bufnr}, {config})                 Parameters: ~                     {config}  table Configuration table.                               ��� border: (default=nil)                                 ��� Add borders to the floating window                                 ��� See |vim.api.nvim_open_win()| -                See also: ~-                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_declaration@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_definition@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_typeDefinition@seehttps://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_implementation|lsp-handler| for the method ""textDocument/signatureHelp""-                    The active parameter is highlighted with-                    |hl-LspSignatureActiveParameter|>+                                           *vim.lsp.handlers.signature_help()*+signature_help({_}, {method}, {result}, {client_id}, {bufnr}, {config})+                |lsp-handler| for the method ""textDocument/signatureHelp"". The",incomplete sentence,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15094,671663938,2021-07-17T09:36:58Z,runtime/lua/vim/shared.lua,"@@ -234,6 +238,26 @@ local function tbl_extend(behavior, deep_extend, ...)   return ret end +--- Merges the values similar to vim.tbl_deep_extend with the **force** behavior,+--- but the values can be any type, in which case they override the values on the left.+--- Values will me merged in-place in the first left-most table. If you want the result to be in+--- a new table, then simply pass an empty table as the first argument `vim.merge({}, ...)`+function vim.merge(...)","Is it worth mentioning that this may not be safe to use for dict-style tables where numbers are used as key?E.g a common pattern is to have the buf number as key - then you could have something like this:```vim.merge({ [10] = 'a'}, { [20] = 'b'})```Which appears to work, but if you have a `[1] = ...` entry as well, it will override the left value.```vim.merge({ [1] = 'a', [10] = 'a'}, { [20] = 'b'})```",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/15094,671666980,2021-07-17T10:06:56Z,runtime/lua/vim/shared.lua,"@@ -234,6 +238,26 @@ local function tbl_extend(behavior, deep_extend, ...)   return ret end +--- Merges the values similar to vim.tbl_deep_extend with the **force** behavior,+--- but the values can be any type, in which case they override the values on the left.+--- Values will me merged in-place in the first left-most table. If you want the result to be in+--- a new table, then simply pass an empty table as the first argument `vim.merge({}, ...)`+function vim.merge(...)","Good catch!This also impacts `tbl_deep_extend`. In there lists always overwrite the left-hand-side, but with my change that would no longer be the case. Will make sure it follows the old behavior.Right now, `vim.tbl_islist({[10] = 'a'})` returns `true`, but that doesn't seem right? (that was the check that used to be there before)Not sure what the wanted behavior should be here.I'm also a bit hesitant to change the behavior of `tbl_islist`.For `vim.merge(`, I can change it of course.Maybe we should do the `islist` check there, by checking that all keys are consecutive from 1 to total count? (min key = 1 and max key = count of keys and all keys are numbers)?This way, your second example would also merge properly. but:`vim.merge({ [1] = 'a'}, { [20] = 'b'})` would still remove the `1`.Another approach could be that we merge if one of the params is `can_merge` and the other must be at least a `table`?That way, merging two list-like tables, will overwrite each other, while your example and my other example above here, would still merge.Wdyt?",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15114,671694255,2021-07-17T12:55:56Z,runtime/lua/vim/treesitter/highlighter.lua,"@@ -260,7 +260,7 @@ local function on_line_impl(self, buf, line)                                { end_line = end_row, end_col = end_col,                                  hl_group = hl,                                  ephemeral = true,-                                 priority = 100 -- Low but leaves room below+                                 priority = tonumber(metadata.priority) or 100 -- Low but leaves room below","This is ok, since metadata is non-nil and `tonumber(nil)` is `nil`",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15079,671712540,2021-07-17T15:48:47Z,src/nvim/generators/gen_api_dispatch.lua,"@@ -33,6 +33,19 @@ local function_names = {}  local c_grammar = require('generators.c_grammar') +-- C code snippets wraping actual api call+-- /*** API CALL ***/ gets replaced with actual call+local function_wraps = {+  nvim_exec = [[++    const sctx_T save_current_sctx = current_sctx;+    current_sctx.sc_sid = SID_LUA;",I mean when non-lua code is calling lua code (finite list of cases in executor.c),
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/15094,671789378,2021-07-18T06:14:50Z,runtime/lua/vim/shared.lua,"@@ -234,6 +238,26 @@ local function tbl_extend(behavior, deep_extend, ...)   return ret end +--- Merges the values similar to vim.tbl_deep_extend with the **force** behavior,+--- but the values can be any type, in which case they override the values on the left.+--- Values will me merged in-place in the first left-most table. If you want the result to be in+--- a new table, then simply pass an empty table as the first argument `vim.merge({}, ...)`+function vim.merge(...)","I don't think it's a good idea to try being smart about this. I changed the implementation back to how it was for tbl_deep_extend. The same check is now used for `vim.merge`.We will only merge tables if either the table is empty, or it is not `vim.tbl_islist`.For your examples, this means:```luavim.merge({ [10] = 'a'}, { [20] = 'b'}) -- result: {[20] = 'b'}vim.merge({ [1] = 'a', [10] = 'a'}, { [20] = 'b'}) -- result: {[20] = 'b'}```",x
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15121,671802710,2021-07-18T08:07:48Z,runtime/lua/vim/lsp/buf.lua,"@@ -422,6 +422,21 @@ function M.clear_references()   util.buf_clear_references() end +--- Requests code actions from all clients and calls the handler exactly once+--- with all aggregated results+--@private+local function code_action_request(params)","One limitation with this approach compared to formatting is we don't optionally allow a list of client_ids to restrict code actions to a single client, not sure if we should do that though. It may be better with the simpler way as it is.",
292349,folke,https://api.github.com/repos/neovim/neovim/pulls/15121,671802973,2021-07-18T08:09:17Z,runtime/lua/vim/lsp/buf.lua,"@@ -422,6 +422,21 @@ function M.clear_references()   util.buf_clear_references() end +--- Requests code actions from all clients and calls the handler exactly once+--- with all aggregated results+--@private+local function code_action_request(params)","I think for code actions, you probably always want to see the full list. Formatting is different, since there you typically only want one formatter. So probably fine as is?",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/14795,672491523,2021-07-19T17:26:06Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -359,78 +359,40 @@ end ---@param bufnr number ---@param client_id number|nil If nil, then return all of the diagnostics. ---                            Else, return just the diagnostics associated with the client_id.-function M.get(bufnr, client_id)-  if client_id == nil then-    local all_diagnostics = {}-    for iter_client_id, _ in pairs(diagnostic_cache[bufnr]) do-      local iter_diagnostics = M.get(bufnr, iter_client_id)--      for _, diagnostic in ipairs(iter_diagnostics) do-        table.insert(all_diagnostics, diagnostic)-      end-    end--    return all_diagnostics-  end--  return diagnostic_cache[bufnr][client_id] or {}-end----- Get the diagnostics by position--------@param bufnr number|nil The buffer number----@param position table|nil The (0,0)-indexed position ---@param opts table|nil Configuration keys ---         - severity: (DiagnosticSeverity, default nil) ---             - Only return diagnostics with this severity. Overrides severity_limit ---         - severity_limit: (DiagnosticSeverity, default nil) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.----@param client_id number|nil the client id----@return table Table with map of line number to list of diagnostics.---               Structured: { [1] = {...}, [5] = {.... } }-function M.get_position_diagnostics(bufnr, position, opts, client_id)+---@param predicate function|nil Optional function for filtering diagnostics+---@param comp      function|nil Optional function for sorting diagnostics+function M.get(bufnr, client_id, opts, predicate, comp)","I'd leave out the `opts` parameter. The predicate can be used to filter based on the severity - there is no need to have a special case it.I'd also remove the `comp` parameter - given that it is at the end, the call-site can do the `table.sort` call on the result - no need to inject the logic into `M.get`.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15114,672818844,2021-07-20T05:36:08Z,runtime/doc/treesitter.txt,"@@ -294,6 +294,20 @@ identical identifiers, highlighting both as |hl-WarningMsg|: >     ((binary_expression left: (identifier) @WarningMsg.left right: (identifier) @WarningMsg.right)      (eq? @WarningMsg.left @WarningMsg.right)) <+Treesitter Highlighting Priority            *lua-treesitter-highlight-priority*++Tree-sitter uses |nvim_buf_set_extmark()| to set highlights with a default +priority of 100. This enables plugins to set a highlighting priority lower or+higher than tree-sitter. It is also possible to change the priority of an+individual query manually by setting the `""priority""` metadata attribute of","```suggestionindividual patterns manually by setting the `""priority""` metadata attribute of```",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15114,672818947,2021-07-20T05:36:21Z,runtime/doc/treesitter.txt,"@@ -294,6 +294,20 @@ identical identifiers, highlighting both as |hl-WarningMsg|: >     ((binary_expression left: (identifier) @WarningMsg.left right: (identifier) @WarningMsg.right)      (eq? @WarningMsg.left @WarningMsg.right)) <+Treesitter Highlighting Priority            *lua-treesitter-highlight-priority*++Tree-sitter uses |nvim_buf_set_extmark()| to set highlights with a default +priority of 100. This enables plugins to set a highlighting priority lower or+higher than tree-sitter. It is also possible to change the priority of an+individual query manually by setting the `""priority""` metadata attribute of+a query: >",```suggestiona pattern: >```,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14795,673490576,2021-07-20T21:01:49Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -359,78 +359,40 @@ end ---@param bufnr number ---@param client_id number|nil If nil, then return all of the diagnostics. ---                            Else, return just the diagnostics associated with the client_id.-function M.get(bufnr, client_id)-  if client_id == nil then-    local all_diagnostics = {}-    for iter_client_id, _ in pairs(diagnostic_cache[bufnr]) do-      local iter_diagnostics = M.get(bufnr, iter_client_id)--      for _, diagnostic in ipairs(iter_diagnostics) do-        table.insert(all_diagnostics, diagnostic)-      end-    end--    return all_diagnostics-  end--  return diagnostic_cache[bufnr][client_id] or {}-end----- Get the diagnostics by position--------@param bufnr number|nil The buffer number----@param position table|nil The (0,0)-indexed position ---@param opts table|nil Configuration keys ---         - severity: (DiagnosticSeverity, default nil) ---             - Only return diagnostics with this severity. Overrides severity_limit ---         - severity_limit: (DiagnosticSeverity, default nil) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.----@param client_id number|nil the client id----@return table Table with map of line number to list of diagnostics.---               Structured: { [1] = {...}, [5] = {.... } }-function M.get_position_diagnostics(bufnr, position, opts, client_id)+---@param predicate function|nil Optional function for filtering diagnostics+---@param comp      function|nil Optional function for sorting diagnostics+function M.get(bufnr, client_id, opts, predicate, comp)",I like your suggestion better @mfussenegger because it simplifies the interfacet to M.get but I don't know offhand if the perf characteristics would be worse given this is a large copy,
16781840,pohzipohzi,https://api.github.com/repos/neovim/neovim/pulls/14795,673646879,2021-07-21T04:11:58Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -359,78 +359,40 @@ end ---@param bufnr number ---@param client_id number|nil If nil, then return all of the diagnostics. ---                            Else, return just the diagnostics associated with the client_id.-function M.get(bufnr, client_id)-  if client_id == nil then-    local all_diagnostics = {}-    for iter_client_id, _ in pairs(diagnostic_cache[bufnr]) do-      local iter_diagnostics = M.get(bufnr, iter_client_id)--      for _, diagnostic in ipairs(iter_diagnostics) do-        table.insert(all_diagnostics, diagnostic)-      end-    end--    return all_diagnostics-  end--  return diagnostic_cache[bufnr][client_id] or {}-end----- Get the diagnostics by position--------@param bufnr number|nil The buffer number----@param position table|nil The (0,0)-indexed position ---@param opts table|nil Configuration keys ---         - severity: (DiagnosticSeverity, default nil) ---             - Only return diagnostics with this severity. Overrides severity_limit ---         - severity_limit: (DiagnosticSeverity, default nil) ---             - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid.----@param client_id number|nil the client id----@return table Table with map of line number to list of diagnostics.---               Structured: { [1] = {...}, [5] = {.... } }-function M.get_position_diagnostics(bufnr, position, opts, client_id)+---@param predicate function|nil Optional function for filtering diagnostics+---@param comp      function|nil Optional function for sorting diagnostics+function M.get(bufnr, client_id, opts, predicate, comp)",@mfussenegger I've removed opts and comp from the function signature but left `predicate` as a parameter :slightly_smiling_face: - lmk if this works. I can delegate the predicate logic to the call-site as well if you prefer,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15079,674519778,2021-07-22T06:00:54Z,src/nvim/api/deprecated.c,"@@ -23,7 +23,7 @@ String nvim_command_output(String command, Error *err)   FUNC_API_SINCE(1)   FUNC_API_DEPRECATED_SINCE(7) {-  return nvim_exec(command, true, err);+  return nvim_exec(0, command, true, err);",Add `channel_id` to the deprecated function as well.,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15151,675710535,2021-07-23T17:03:52Z,src/nvim/ex_getln.c,"@@ -166,7 +166,7 @@ typedef struct command_line_state {   int firstc;   long count;   int indent;-  int c;+  bool c;","You are completely right, I had a brain fart.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15159,675939412,2021-07-24T03:16:21Z,.github/ISSUE_TEMPLATE/lsp_bug_report.yml,"@@ -0,0 +1,69 @@+name: Language server client bug report+description: Report a built-in lsp problem in Neovim+labels: [bug, lsp]+body:++  - type: markdown+    attributes:+      value: |+        Thank you for taking the time to fill out this bug report!+        Before reporting: search [existing issues](https://github.com/neovim/neovim/issues?q=is%3Aissue+is%3Aopen+label%3Abug) and check the [FAQ](https://github.com/neovim/neovim/wiki/FAQ). Usage questions such as ""How do I...?"" or ""Why isn't X language server/feature working?"" belong on the [Neovim Discourse](https://neovim.discourse.group/c/7-category/7) and will be closed.++  - type: input+    attributes:+      label: ""Neovim Version""+      description: ""`nvim --version`:""+    validations:+      required: true+  - type: input+    attributes:+      label: ""Language server name/version:""+    validations:+      required: true+  - type: input+    attributes:+      label: ""Operating system/version:""+    validations:+      required: true++  - type: textarea+    attributes:+      label: Checkhealth+      description: |+        Paste the results from `nvim -c "":checkhealth nvim lspconfig""` here:+      render: markdown++  - type: markdown+    attributes:+      value: |+        Note: if the issue is with an autocompletion or other LSP plugin, please report it at that plugin's issue tracker. Download the minimal config with `wget https://raw.githubusercontent.com/neovim/nvim-lspconfig/master/test/minimal_init.lua` and modify it to include any specific commands or servers pertaining to your issues.+  - type: textarea+    attributes:+      label: ""Steps to reproduce""+      description: |+        Steps to reproduce using `nvim -u minimal_init.lua`:+    validations:+      required: true++  - type: textarea+    attributes:+      label: ""Expected behavior""+  - type: textarea+    attributes:+      label: ""Actual behavior""+      description: ""Logs, images and videos alongside the description are not necessary, but certainly appreciated.""","""Logs, images and videos alongside the description are not necessary, but certainly appreciated."" -> ""A description of the behavior you expected. May optionally include logs, images, or videos.""",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14536,676693757,2021-07-26T15:07:35Z,runtime/doc/lua.txt,"@@ -1581,4 +1581,45 @@ uri_to_fname({uri})                                       *vim.uri_to_fname()*                 Return: ~                     Filename +==============================================================================+Lua module: xdiff                                                  *lua-xdiff*++xdl_diff({a}, {b}, {opts})                                    *vim.xdl_diff()*+                Run diff on strings {a} and {b}.++                Parameters: ~+                    {a}      First string to compare+                    {b}      Second string to compare+                    {opts}   Optional parameters:+                             ��� `hunk_func`: Lua callback invoked for each hunk","implementing iteration as callbacks in a loop is not considered efficient in luajit. It would be good with a `hunk_list` option which does the `hunk_func = function(sa, ca, sb, cb)          exp[#exp+1] = {sa, ca, sb, cb}        end` thing everyone is gonna do anyway (but without the overhead of re-entering the interpreter each item)",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15200,676887314,2021-07-26T19:34:08Z,CONTRIBUTING.md,"@@ -62,16 +62,28 @@ Pull requests (PRs) - During a squash/fixup, use `exec make -C build unittest` between each   pick/edit/reword. -### Stages: WIP, RFC, RDY+### Stages: Draft and Ready for review -Pull requests have three stages: `[WIP]` (Work In Progress), `[RFC]` (Request-For Comment) and `[RDY]` (Ready).+Pull requests have two stages: draft and ready for review -1. `[RFC]` is assumed by default, **do not** put ""RFC"" in the PR title (it adds+1. ready for review is assumed by default, **do not** put ""RFC"" in the PR title (it adds    noise to merge commit messages).-2. Add `[WIP]` to the PR title if you are _not_ requesting feedback and the work+2. Mark your PR as _draft_ if you are _not_ requesting feedback and the work    is still in flux.-3. Add `[RDY]` to the PR title if you are _done_ and only waiting on merge.++### The `RFC` tag","After a surprise team fight with @bfredl, I'd suggest using [RFD]��(for ""request for discussion"") instead since that is close enough to RFC to be understandable while still being different from our previous (documented) meaning:> However, you can and should use the label `[RFD] (""Request For Discussion"") for speculative, intrusive PRs that need broader discussion on its architecture or API.",
9730330,bew,https://api.github.com/repos/neovim/neovim/pulls/15202,677206296,2021-07-27T07:51:08Z,src/nvim/api/vim.c,"@@ -575,6 +575,25 @@ Object nvim_notify(String msg, Integer log_level, Dictionary opts, Error *err)   return nlua_exec(STATIC_CSTR_AS_STRING(""return vim.notify(...)""), args, err); } +/// Notify the user with a message+///+/// Relays the call to vim.notify . By default forwards your message in the+/// echo area but can be overridden to trigger desktop notifications.","Hmm the doc is wrong here, it's not a notification system but a picker system, a way to select one thing in a list",
9730330,bew,https://api.github.com/repos/neovim/neovim/pulls/15202,677208097,2021-07-27T07:53:47Z,src/nvim/lua/vim.lua,"@@ -424,6 +424,14 @@ function vim.notify(msg, log_level, _opts)   end end +vim.ui = {+  --- Picker+  --- without a runtime, relies on inputlist()+  --  see :help nvim_pick+  pick = function (entries, opts)",For opts I'm thinking we can have a `multiselect` option? But i'm not sure how to impl with inputlist..,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15206,677649538,2021-07-27T17:17:30Z,src/nvim/window.c,"@@ -3834,17 +3834,16 @@ int tabpage_index(tabpage_T *ftp)   return i; } -/*- * Prepare for leaving the current tab page.- * When autocommands change ""curtab"" we don't leave the tab page and return- * FAIL.- * Careful: When OK is returned need to get a new tab page very very soon!- */-static int -leave_tabpage (-    buf_T *new_curbuf,        /* what is going to be the new curbuf,-                                          NULL if unknown */-    int trigger_leave_autocmds+/// Prepare for leaving the current tab page.+/// When autocommands change ""curtab"" we don't leave the tab page and return+/// FAIL.+/// Careful: When OK is returned need to get a new tab page very very soon!+///+/// @param  new_curbuf   what is going to be the new curbuf, NULL if unknown+static int+leave_tabpage(+    buf_T *new_curbuf,+    bool trigger_leave_autocmds",Do you think you'd be able to add documentation for the `trigger_leave_autocmds` parameter ?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15207,677826393,2021-07-27T21:53:05Z,src/nvim/syntax.c,"@@ -3434,9 +3432,7 @@ static void syn_cmd_reset(exarg_T *eap, int syncing) {   eap->nextcmd = check_nextcmd(eap->arg);   if (!eap->skip) {-    set_internal_string_var(""syntax_cmd"", (char_u *)""reset"");-    do_cmdline_cmd(""runtime! syntax/syncolor.vim"");-    do_unlet(S_LEN(""g:syntax_cmd""), true);+    init_highlight(true, true);","this alters the behavior of `syn reset`. This _should_ not be a big deal, and is consistent with the plan that we are staking out, but I am making a note in case it causes an issue (spacebar heating or not) down the line. :)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14536,678352994,2021-07-28T14:25:12Z,src/nvim/lua/xdiff.c,"@@ -0,0 +1,318 @@+#include <lua.h>+#include <lualib.h>+#include <lauxlib.h>++#include <stdlib.h>+#include <stdio.h>+#include <errno.h>+#include <string.h>++#include ""nvim/vim.h""+#include ""nvim/xdiff/xdiff.h""+#include ""nvim/lua/xdiff.h""+#include ""nvim/lua/converter.h""+#include ""nvim/lua/executor.h""+#include ""nvim/api/private/helpers.h""++typedef enum {+  kNluaXdiffModeStr =  0,+  kNluaXdiffModeCb,+  kNluaXdiffModeLines,+} NluaXdiffMode;++typedef struct s_hunkpriv {+  lua_State *lstate;+  Error     *err;+} hunkpriv_t;++static int write_string(void *priv, mmbuffer_t *mb, int nbuf)+{+  luaL_Buffer *buf = (luaL_Buffer *)priv;+  for (int i = 0; i < nbuf; i++) {+    const long size = mb[i].size;+    for (long total = 0; total < size; total += LUAL_BUFFERSIZE) {+      const int tocopy = MIN((int)(size - total), LUAL_BUFFERSIZE);+      char *p = luaL_prepbuffer(buf);+      if (!p) {+        return -1;+      }+      memcpy(p, mb[i].ptr + total, (unsigned)tocopy);+      luaL_addsize(buf, (unsigned)tocopy);+    }+  }+  return 0;+}++// hunk_func callback used when opts.hunk_lines = true+static int hunk_lines_func(+    long start_a, long count_a, long start_b, long count_b, void *cb_data)+{+  // Mimic extra offsets done by xdiff, see:+  // src/nvim/xdiff/xemit.c:284+  // src/nvim/xdiff/xutils.c:(356,368)+  if (count_a > 0) {+    start_a += 1;+  }+  if (count_b > 0) {+    start_b += 1;+  }++  lua_State * lstate = (lua_State *)cb_data;+  lua_createtable(lstate, 0, 0);++  lua_pushnumber(lstate, (float)start_a);+  lua_rawseti(lstate, -2, 1);+  lua_pushnumber(lstate, (float)count_a);+  lua_rawseti(lstate, -2, 2);+  lua_pushnumber(lstate, (float)start_b);+  lua_rawseti(lstate, -2, 3);+  lua_pushnumber(lstate, (float)count_b);+  lua_rawseti(lstate, -2, 4);++  lua_rawseti(lstate, -2, (signed)lua_objlen(lstate, -2)+1);++  return 0;+}++// hunk_func callback used when opts.hunk_func is given+static int hunk_func_cb(","This should use a style more like```cstatic int hunk_func_cb(long start_a, long count_a, long start_b, long count_b,                        void *cb_data)```(and similar for other long signatures.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14536,678607528,2021-07-28T19:52:24Z,src/nvim/lua/xdiff.h,"@@ -0,0 +1,10 @@+#ifndef NVIM_LUA_XDIFF_H+#define NVIM_LUA_XDIFF_H++#include <lua.h>+#include <lualib.h>+#include <lauxlib.h>++int nlua_xdl_diff(lua_State *lstate);",use a `INCLUDE_GENERATED_DECLARATIONS` block instead. look at `lua/treesitter.h` (and similarly for the .c file).,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15211,678640728,2021-07-28T20:47:44Z,src/nvim/shada.c,"@@ -3937,15 +3944,28 @@ static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,       entry->data.global_var.name =           xmemdupz(unpacked.data.via.array.ptr[0].via.bin.ptr,                    unpacked.data.via.array.ptr[0].via.bin.size);-      if (msgpack_to_vim(unpacked.data.via.array.ptr[1],-                         &(entry->data.global_var.value)) == FAIL) {+      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, 2,","This feels like a _meh_ way of differentiating blobs from strings in the shada file. :thinking: Also, I need to check that this even works properly.",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15211,678721385,2021-07-28T23:37:47Z,src/nvim/shada.c,"@@ -3937,15 +3944,28 @@ static ShaDaReadResult shada_read_next_item(ShaDaReadDef *const sd_reader,       entry->data.global_var.name =           xmemdupz(unpacked.data.via.array.ptr[0].via.bin.ptr,                    unpacked.data.via.array.ptr[0].via.bin.size);-      if (msgpack_to_vim(unpacked.data.via.array.ptr[1],-                         &(entry->data.global_var.value)) == FAIL) {+      SET_ADDITIONAL_ELEMENTS(unpacked.data.via.array, 2,","For blobs, I use the `global_var.additional_elements` list to store a dummy `VAR_TYPE_BLOB` with the blob.(the exact value doesn't matter right now as `global_var.additional_elements` doesn't seem to be used for anything else yet)This seems to work and existing shadas should be (and appear to be) fine.",
4975310,stsewd,https://api.github.com/repos/neovim/neovim/pulls/14995,679383935,2021-07-29T18:18:18Z,test/functional/treesitter/parser_spec.lua,"@@ -102,6 +102,20 @@ void ui_refresh(void)   } }]] +  it('get_parser() changes the language of the parser', function()+    local res = exec_lua([[+      parser = vim.treesitter.get_parser(0, ""c"")+      return parser:lang()+    ]])+    eq(""c"", res)++    local ok, err = unpack(exec_lua([[+       return {pcall(vim.treesitter.get_parser, 0, ""cpp"")}+    ]]))+    assert(not ok)+    assert(string.find(err, ""no parser for 'cpp' language"", 1, true))+  end)+","the test fails without this change, get_parser reads from the file type if the lang isn't given https://github.com/neovim/neovim/blob/3521bf7672d2a33e60e2656043374a1584a0285b/runtime/lua/vim/treesitter.lua#L85-L87, the bug here is just when requesting a different language for the same buffer. I can change it if needed, but looks like it's the same.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15206,679777159,2021-07-30T09:14:44Z,src/nvim/ex_docmd.c,"@@ -306,13 +306,13 @@ int do_cmdline(char_u *cmdline, LineGetter fgetline,                void *cookie, /* argument for fgetline() */                int flags) {-  char_u      *next_cmdline;            /* next cmd to execute */-  char_u      *cmdline_copy = NULL;     /* copy of cmd line */-  int used_getline = FALSE;             /* used ""fgetline"" to obtain command */-  static int recursive = 0;             /* recursive depth */-  int msg_didout_before_start = 0;-  int count = 0;                        /* line number count */-  int did_inc = FALSE;                  /* incremented RedrawingDisabled */+  char_u      *next_cmdline;            // next cmd to execute+  char_u      *cmdline_copy = NULL;     // copy of cmd line+  int used_getline = FALSE;             // used ""fgetline"" to obtain command+  static int recursive = 0;             // recursive depth+  bool msg_didout_before_start = false;+  int count = 0;                        // line number count+  int did_inc = FALSE;                  // incremented RedrawingDisabled",Opted to NOLINT to avoid clint chain reaction.,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15206,679778054,2021-07-30T09:15:58Z,src/nvim/ex_cmds.c,"@@ -1892,7 +1892,7 @@ int do_write(exarg_T *eap)     if (eap->cmdidx == CMD_saveas) {       if (retval == OK) {         curbuf->b_p_ro = FALSE;",Opted to NOLINT to avoid clint chain reaction.,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15206,679778100,2021-07-30T09:16:04Z,src/nvim/ex_cmds.c,"@@ -1635,14 +1635,14 @@ void print_line(linenr_T lnum, int use_number, int list)    msg_start();   silent_mode = FALSE;",Opted to NOLINT to avoid clint chain reaction.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15206,679812425,2021-07-30T10:10:52Z,src/nvim/ex_docmd.c,"@@ -306,13 +306,13 @@ int do_cmdline(char_u *cmdline, LineGetter fgetline,                void *cookie, /* argument for fgetline() */                int flags) {-  char_u      *next_cmdline;            /* next cmd to execute */-  char_u      *cmdline_copy = NULL;     /* copy of cmd line */-  int used_getline = FALSE;             /* used ""fgetline"" to obtain command */-  static int recursive = 0;             /* recursive depth */-  int msg_didout_before_start = 0;-  int count = 0;                        /* line number count */-  int did_inc = FALSE;                  /* incremented RedrawingDisabled */+  char_u      *next_cmdline;            // next cmd to execute+  char_u      *cmdline_copy = NULL;     // copy of cmd line+  bool used_getline = false;            // used ""fgetline"" to obtain command+  static int recursive = 0;             // recursive depth+  bool msg_didout_before_start = false;+  int count = 0;                        // line number count+  int did_inc = FALSE;                  // incremented RedrawingDisabled NOLINT","No. don't use `NOLINT` to avoid a ""chain reaction"". Rather, we can just merge with unrelated failures and those will be added to the allowed failure list.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15129,680499657,2021-08-01T11:51:17Z,CONTRIBUTING.md,"@@ -86,15 +86,35 @@ the VCS/git logs more valuable. The general structure of a commit message is as [optional footer(s)] ``` -- **Prefix the commit subject with a _type_:** `doc:`, `test:`-  `runtime:`, ...-    - Subject line for commits with only style/lint changes can be a single-      word: `style` or `lint`.-- **Add the optional scope following <type> if possible:** `(lsp)`, `(treesitter)`, `(multigrid)`, ...+- Prefix the commit subject with one of the following _types_:+    - `build`: changes related to the build system (involving scripts, configurations or tools) and package dependencies.+    - `ci`: changes related to the continuous integration and deployment system - involving scripts, configurations or tools.+    - `docs`: all documentation changes. This includes both external documentation intended for end users as well as internal documentation intended for developers.+    - `feat`: new abilities or functionality in the product end users can utilize.+    - `fix`: a bug fix in the product that affects end users.+    - `perf`: a performance improvement that affects end users.+    - `refactor`: modification of the code base which neither adds a feature nor fixes a bug - such as removing redundant code, simplifying the code, renaming variables, etc.+    - `revert`: revert previous commits.+    - `test`: all changes related to tests such as refactoring existing tests or adding new tests.+    - `vim-patch`: all patches from upstream Vim. The commit messages for patches has [slightly different rules](https://github.com/neovim/neovim/wiki/Merging-patches-from-upstream-Vim#pull-requests) as not to interfere with existing scripts.+    - `chore`: Lastly, if none of the types above fits you may use `chore` as the type.++- Append optional scope to _type_ if possible: `(lsp)`, `(treesitter)` or `(float/windows)`.+ - Try to keep the first line under 72 characters.+ - A blank line must separate the subject from the description.-- Breaking changes must be indicated at the very beginning of the footer or body section of a commit. A breaking change must consist of the uppercase text BREAKING CHANGE, followed by a colon, a space, and a description of what has changed about the API.-- Check your commit message for spelling and grammatical mistakes.++- A breaking API change must be indicated by appending `!` after the type/scope and at the very beginning of the footer with a **BREAKING CHANGE**.++    Example:++    ```+    refactor!: drop support for Python 2",maybe add a scope here to make it unambiguous where the bang goes: `refactor(provider)!: drop support`,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15162,680613135,2021-08-02T02:21:11Z,scripts/vim-patch.sh,"@@ -326,12 +326,14 @@ stage_patch() {   return $ret } -hub_pr() {-  hub pull-request -m ""$1""+gh_pr() {+  gh pr create --title ""$1"" --body ""$2"" }  git_hub_pr() {-  git hub pull new -m ""$1""+  local pr_message+  pr_message=""$(printf '%s\n\n%s\n' ""$1"" ""$2"")""+  git hub pull new -m ""${pr_message}""","No, [git-hub](https://github.com/sociomantic-tsunami/git-hub/) is a separate project.  Only hub should be replaced by gh.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/14995,681476341,2021-08-03T06:39:23Z,test/functional/treesitter/parser_spec.lua,"@@ -102,6 +102,20 @@ void ui_refresh(void)   } }]] +  it('get_parser() changes the language of the parser', function()+    local res = exec_lua([[+      parser = vim.treesitter.get_parser(0, ""c"")+      return parser:lang()+    ]])+    eq(""c"", res)++    local ok, err = unpack(exec_lua([[+       return {pcall(vim.treesitter.get_parser, 0, ""cpp"")}+    ]]))+    assert(not ok)+    assert(string.find(err, ""no parser for 'cpp' language"", 1, true))+  end)+","It is okay, but my problem is that we explicitly call destroy on the previously cached parser, which IMO is a big no no.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/15242,681727773,2021-08-03T12:52:02Z,CONTRIBUTING.md,"@@ -7,10 +7,10 @@ Getting started If you want to help but don't know where to start, here are some low-risk/isolated tasks: -- [Merge a Vim patch]. - Try a [good first issue](../../labels/good-first-issue) or [complexity:low] issue. - Fix bugs found by [Clang](#clang-scan-build), [PVS](#pvs-studio) or   [Coverity](#coverity).+- Try a [mentored project](../../labels/mentored-project).","My goal is to do something like:Add new API function skeleton `nvim_edit(name, opts)`. I don't write any of the implementation. I just put a stub where tests should go. Then someone can take the PR over and I can just help them with some of the nvim specific quirks. It is not necessarily for new programmars or for people who need hand holding along the way, but just for people who are unfamiliar w/ nvim & the way to add a new feature.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15041,682396635,2021-08-04T08:20:15Z,.github/workflows/combine-typos.yml,"@@ -0,0 +1,48 @@+name: Combine Typo Pull Requests++on:+  pull_request:+    types: [ labeled ]","The idea is that this PR ""hoovers"" typofix PRs and _instantly_ adds it to a batch PR (which can then be reviewed/merged weekly, or whenever it's substantial enough).",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15293,684674478,2021-08-07T20:30:50Z,src/nvim/testdir/test_functions.vim,"@@ -875,6 +875,34 @@ func Test_byte2line_line2byte()   bw! endfunc +func Test_byteidx()","Ideally, how should this test be included?It's a new-style version of a test in test69 that was already lua'd here: https://github.com/neovim/neovim/blob/35041432bff6812126e1cc04d30d35a5c9117537/test/functional/legacy/069_multibyte_formatting_spec.lua#L309Difference though is that this test uses method call syntax, which is why I'd like to include it.As the patch removed the old version of the test, should I remove the lua'd version?Should I keep both versions of the test? Should I translate this to a lua test? :shrug:",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15317,685044922,2021-08-09T09:32:56Z,runtime/doc/api.txt,"@@ -1707,7 +1707,7 @@ nvim_set_decoration_provider({ns_id}, {opts})                                specific window. [""win"", winid, bufnr, topline,                                botline_guess]                              ��� on_line: called for each buffer line being-                               redrawn. (The interation with fold lines is+                               redrawn. (The interaction with fold lines is",Needs to be fixed here: https://github.com/neovim/neovim/blob/68f61b167e71ca8dd42157b10b3096571c06f39d/src/nvim/api/vim.c#L2950,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15315,685052938,2021-08-09T09:45:49Z,runtime/doc/treesitter.txt,"@@ -341,7 +341,7 @@ Lua module: vim.treesitter                               *lua-treesitter-core* get_parser({bufnr}, {lang}, {opts})                             *get_parser()*                 Gets the parser for this bufnr / ft combination. -                If needed this will create the parser. Unconditionnally attach+                If needed this will create the parser. Unconditionally attach",Typos from this line and below are generated from `runtime/lua/vim/treesitter.lua` and `runtime/lua/vim/treesitter/*` like from: https://github.com/neovim/neovim/blob/27da5511a0c0b12fcabe29cf38c3f8a0f0b444b9/runtime/lua/vim/treesitter.lua#L72,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15316,685824811,2021-08-10T08:52:54Z,src/nvim/lua/treesitter.c,"@@ -1043,13 +1046,17 @@ static int query_next_capture(lua_State *L)     lua_pushinteger(L, capture.index+1);  // [index]     push_node(L, capture.node, lua_upvalueindex(2));  // [index, node] +    // Now check if we need to run the predicates     uint32_t n_pred;     ts_query_predicates_for_pattern(query, match.pattern_index, &n_pred);-    if (n_pred > 0 && capture_index == 0) {++    if (n_pred > 0+        && (capture_index == 0 || ud->current_pattern != match.pattern_index)) {","Ans there's another issue, that points us again in the direction of either using tables to store results everywhere, or sometimes rerunning the predicates: when matches overlap, the library will return the first match, which we will use to set the lua table that we return, then fill with whether this match is active or not. On the next match, we will do the same, and overwrite the `active` value that we computed. Then if the first match comes back (because of overlap), we will have to recompute wether this match is active or not.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15260,685838641,2021-08-10T09:10:40Z,runtime/lua/vim/treesitter/query.lua,"@@ -34,14 +72,45 @@ local function safe_read(filename, read_quantifier)   return content end +-- Disables loading query files for {lang} matching provided {patterns}.+--+-- If {patterns} is nil, it clears the ignore patterns.+-- If {patterns} is string[], it replaces the currently set patterns (if any).+--+-- You can also pass a function as {patterns}, which will accept a table with+-- currently set patterns as keys. You can modify that table and return a new+-- table or nil. The return value will be used as the new ignore patterns.+--+---@param lang string+---@param patterns nil | string[] | fun(patterns:table<string, boolean | nil>): nil | table<string, boolean | nil>","We use `---` instead of `--` for doc comments:```suggestion--- Disables loading query files for {lang} matching provided {patterns}.------ If {patterns} is nil, it clears the ignore patterns.--- If {patterns} is string[], it replaces the currently set patterns (if any).------ You can also pass a function as {patterns}, which will accept a table with--- currently set patterns as keys. You can modify that table and return a new--- table or nil. The return value will be used as the new ignore patterns.------@param lang string---@param patterns nil | string[] | fun(patterns:table<string, boolean | nil>): nil | table<string, boolean | nil>```",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15260,685840639,2021-08-10T09:13:17Z,runtime/lua/vim/treesitter/query.lua,"@@ -34,14 +72,45 @@ local function safe_read(filename, read_quantifier)   return content end +-- Disables loading query files for {lang} matching provided {patterns}.+--+-- If {patterns} is nil, it clears the ignore patterns.+-- If {patterns} is string[], it replaces the currently set patterns (if any).+--+-- You can also pass a function as {patterns}, which will accept a table with+-- currently set patterns as keys. You can modify that table and return a new+-- table or nil. The return value will be used as the new ignore patterns.+--+---@param lang string+---@param patterns nil | string[] | fun(patterns:table<string, boolean | nil>): nil | table<string, boolean | nil>+function M.ignore_query_files(lang, patterns)+  -- remove cached results+  query_file_config.ignored_files[lang] = {}++  if type(patterns) == ""function"" then+    query_file_config.ignore_patterns[lang] = patterns(query_file_config.ignore_patterns[lang] or {})+    return+  end++  if not patterns then+    query_file_config.ignore_patterns[lang] = nil+    return+  end++  query_file_config.ignore_patterns[lang] = {}+  for _, pattern in ipairs(patterns) do+    query_file_config.ignore_patterns[lang][pattern] = true+  end",Why not using a table directly here ? This is not the classic way of storing value here :wink:,
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/15260,686026182,2021-08-10T13:36:38Z,runtime/lua/vim/treesitter/query.lua,"@@ -34,14 +72,45 @@ local function safe_read(filename, read_quantifier)   return content end +-- Disables loading query files for {lang} matching provided {patterns}.+--+-- If {patterns} is nil, it clears the ignore patterns.+-- If {patterns} is string[], it replaces the currently set patterns (if any).+--+-- You can also pass a function as {patterns}, which will accept a table with+-- currently set patterns as keys. You can modify that table and return a new+-- table or nil. The return value will be used as the new ignore patterns.+--+---@param lang string+---@param patterns nil | string[] | fun(patterns:table<string, boolean | nil>): nil | table<string, boolean | nil>+function M.ignore_query_files(lang, patterns)+  -- remove cached results+  query_file_config.ignored_files[lang] = {}++  if type(patterns) == ""function"" then+    query_file_config.ignore_patterns[lang] = patterns(query_file_config.ignore_patterns[lang] or {})+    return+  end++  if not patterns then+    query_file_config.ignore_patterns[lang] = nil+    return+  end++  query_file_config.ignore_patterns[lang] = {}+  for _, pattern in ipairs(patterns) do+    query_file_config.ignore_patterns[lang][pattern] = true+  end","I did that to support this pattern:```luavim.treesitter.ignore_query_files(""lua"", function(patterns)  patterns[""/nvim%-treesitter/""] = true -- or false/nil for removing  return patternsend)```I thought it might be handy when somebody wants to toggle a pattern on/off (via some keybinding or commands). Otherwise they have to loop over the table (`string[]`) and filter out the value... or check if the value already exists before adding the value.Do you want store the table (as `string[]`) directy instead of making `table<string, boolean>`?",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15330,686625727,2021-08-11T08:43:01Z,src/nvim/lua/treesitter.c,"@@ -1046,8 +1081,11 @@ static int query_next_capture(lua_State *L)     uint32_t n_pred;     ts_query_predicates_for_pattern(query, match.pattern_index, &n_pred);     if (n_pred > 0 && capture_index == 0) {-      lua_pushvalue(L, lua_upvalueindex(4));  // [index, node, match]","Yes, because we need to clear the previous match values.If you look at what changed in the tests, we actually did it wrong for a ling time, and we were keeping references in the temporary match to older nodes that are not in this match.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15330,686754711,2021-08-11T11:50:31Z,src/nvim/lua/treesitter.c,"@@ -1046,8 +1081,11 @@ static int query_next_capture(lua_State *L)     uint32_t n_pred;     ts_query_predicates_for_pattern(query, match.pattern_index, &n_pred);     if (n_pred > 0 && capture_index == 0) {-      lua_pushvalue(L, lua_upvalueindex(4));  // [index, node, match]","Ok, this was not wrong in the past, but is required now due to quantifiers possibly having zero nodes for a capture.",
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15330,686817720,2021-08-11T13:13:19Z,src/nvim/lua/treesitter.c,"@@ -1046,8 +1081,11 @@ static int query_next_capture(lua_State *L)     uint32_t n_pred;     ts_query_predicates_for_pattern(query, match.pattern_index, &n_pred);     if (n_pred > 0 && capture_index == 0) {-      lua_pushvalue(L, lua_upvalueindex(4));  // [index, node, match]","it _was_ wrong in the past, one can _not_ use a node captured in the previous pattern to compute things in another pattern. Captures are specific to their pattern, and the bug that was previously there broke that, because one could use, in the current pattern, the captures from another pattern",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15330,686896222,2021-08-11T14:38:14Z,src/nvim/lua/treesitter.c,"@@ -1046,8 +1081,11 @@ static int query_next_capture(lua_State *L)     uint32_t n_pred;     ts_query_predicates_for_pattern(query, match.pattern_index, &n_pred);     if (n_pred > 0 && capture_index == 0) {-      lua_pushvalue(L, lua_upvalueindex(4));  // [index, node, match]","Sorry but this simply is not correct. In the past, before supporting quantifiers on captures, a match was always guaranteed to fill all of its captures (and do so exactly once). Therefore, any pattern with well-formed predicates would only use its own captures already, as no stale values could've been left behind. For a non-well-formed predicate that accesses an_ invalid_ capture there is _no_ correct value, such a query can and should be rejected at query compile time and is not a concern for the runtime hot loop.But I am fine with de-optimizing this for now as it makes implementing quantifiers much simpler. We can consider optimizing again when we have proper profiling set up, anyway.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15340,686929921,2021-08-11T15:15:16Z,.github/ISSUE_TEMPLATE/bug_report.yml,"@@ -43,8 +37,8 @@ body:     attributes:       label: ""Steps to reproduce""       description: |-        Steps to reproduce using `nvim -u NORC` and/or `nvim -u NONE` (please test both).-        If you are reporting build failures, please list the exact sequence of steps including all CMake flags (if any).+        If you cannot reproduce the issue using `nvim -u NORC`, prepare and upload a [minimal config](https://github.com/neovim/neovim/blob/master/contrib/minimal.lua) that reproduces the issue with `nvim -u minimal.lua`.","Yes, there's only a (somewhat eclectic) list of allowed filetypes.I don't like the spoiler tag; if it's truly minimal, just copying the _added_ lines in the ""steps"" field would work.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/14795,686943485,2021-08-11T15:30:33Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -362,11 +362,12 @@ end ---@param bufnr number ---@param client_id number|nil If nil, then return all of the diagnostics. ---                            Else, return just the diagnostics associated with the client_id.-function M.get(bufnr, client_id)+---@param predicate function|nil Optional function for filtering diagnostics","In most other places in the docs we use `(function, optional)` to indicate an optional parameter (rather than `function|nil`). For the sake of consistency I'd suggest you stick with that.",x
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/15248,687015640,2021-08-11T17:01:51Z,runtime/doc/api.txt,"@@ -2566,6 +2566,26 @@ nvim_win_get_var({window}, {name})                        *nvim_win_get_var()*                 Return: ~                     Variable value +nvim_win_get_viewport({window})                      *nvim_win_get_viewport()*+                Gets the current viewport of a window++                The returned tuple contains (everything is 0-based,+                end-exclusive):+                ��� Top-most buffer line index+                ��� Bottom-most buffer line index+                ��� Left-most column index+                ��� Right-most column index","Just as a thought, but instead of `[top, bot, left, right]`, we instead have `[row, col, height, width]`, where:* top  = row* bot = row + height* left = col* right = col + widthJust so getting the dimensions of a viewport is more convenient as I often find myself wanting these more often than co-ordinates, otherwise the user can just do `height = top - bot` and `width = left - right`.Not a big deal either way.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/13247,688919426,2021-08-14T11:33:17Z,src/nvim/window.c,"@@ -1503,6 +1514,43 @@ bool win_valid_any_tab(win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT   return false; } +/// Creates new ""winref"" from ""win""+///+/// @param win    The window to reference.+winref_T winref_from(win_T *win)+{+  winref_T winref;+  winref.wr_win = win;+  winref.wr_fnum = win == NULL ? 0 : win->handle;+  winref.wr_win_free_count = win_free_count;+  return winref;+}++/// Store ""win"" in ""winref"" and set the free count.+///+/// @param winref Reference to be used for the window.+/// @param win    The window to reference.+void winref_set(winref_T *winref, win_T *win)+{+  winref->wr_win = win;+  winref->wr_fnum = win == NULL ? 0 : win->handle;+  winref->wr_win_free_count = win_free_count;+}++/// Return true if ""winref->wr_win"" points to the same window as when+/// set_winref() was called and it is a valid window.+/// Only goes through the window list if win_free_count changed.+/// Also checks if b_fnum is still the same, a :bwipe followed by :new might get+/// the same allocated memory, but it's a different window.+///+/// @param winref Buffer reference to check for.+bool winref_valid(winref_T *winref)+{+  return winref->wr_win_free_count == win_free_count+    ? true+    : win_valid(winref->wr_win) && winref->wr_fnum == winref->wr_win->handle;",this can be replaced by `handle_get_window(winref->wr_fnum) == winref->wr_win` (single hash lookup instead of linked list traversal),
1423607,romgrk,https://api.github.com/repos/neovim/neovim/pulls/13247,689011420,2021-08-15T01:04:32Z,src/nvim/window.c,"@@ -1503,6 +1514,43 @@ bool win_valid_any_tab(win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT   return false; } +/// Creates new ""winref"" from ""win""+///+/// @param win    The window to reference.+winref_T winref_from(win_T *win)+{+  winref_T winref;+  winref.wr_win = win;+  winref.wr_fnum = win == NULL ? 0 : win->handle;+  winref.wr_win_free_count = win_free_count;+  return winref;+}++/// Store ""win"" in ""winref"" and set the free count.+///+/// @param winref Reference to be used for the window.+/// @param win    The window to reference.+void winref_set(winref_T *winref, win_T *win)+{+  winref->wr_win = win;+  winref->wr_fnum = win == NULL ? 0 : win->handle;+  winref->wr_win_free_count = win_free_count;+}++/// Return true if ""winref->wr_win"" points to the same window as when+/// set_winref() was called and it is a valid window.+/// Only goes through the window list if win_free_count changed.+/// Also checks if b_fnum is still the same, a :bwipe followed by :new might get+/// the same allocated memory, but it's a different window.+///+/// @param winref Buffer reference to check for.+bool winref_valid(winref_T *winref)+{+  return winref->wr_win_free_count == win_free_count+    ? true+    : win_valid(winref->wr_win) && winref->wr_fnum == winref->wr_win->handle;","I get your point, however I like having `winref_T` for two reasons. One, it makes the design of the codebase orthogonal for buffers & windows. Second, it feels that it indicates more clearly that the window may be invalid. Therefore, I would like to keep `winref_T`, but with the handle thing to avoid the linked list. What do you think?",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/15240,689154635,2021-08-15T22:51:39Z,src/nvim/testdir/test_visual.vim,"@@ -861,6 +861,15 @@ func Test_visual_block_mode()   set tabstop& shiftwidth& endfunc +func Test_visual_force_motion_feedkeys()+    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)","```Executed:  2023 Tests Skipped:   181 Tests  FAILED:     1 TestsFailures: 	From test_visual.vim:	Found errors in Test_visual_force_motion_feedkeys():	Caught exception in Test_visual_force_motion_feedkeys(): Vim(call):E15: Invalid expression: >slice(0, 0) @ function RunTheTest[37]..Test_visual_force_motion_feedkeys, line 2```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13268,689215127,2021-08-16T03:13:41Z,runtime/doc/change.txt,"@@ -986,10 +986,10 @@ inside of strings can change!  Also see 'softtabstop' option. >  							*Y* [""x]Y			yank [count] lines [into register x] (synonym for-			yy, |linewise|).  If you like ""Y"" to work from the-			cursor to the end of line (which is more logical,-			but not Vi-compatible) use "":map Y y$"".-+			yy, |linewise|). This is the builtin mapping, see+			|Y-default| for neovim's default mapping.","- the builtin normal command is not a ""mapping"", it is a (normal) command.- we never say ""neovim"" (lowercase) in the help docs or anywhere else, and also rarely ""Neovim"". Almost always the help docs say ""Nvim"". In this case there isn't a reason to mention Nvim at all.    - I think we need a linter for this at this point...- There is really no reason to say anything at all here, given that the very next line mentions the default mapped nature.    - Might seem trivial, but we need a repeatable pattern that doesn't result in clunky text all over the docs.```suggestion			yy, |linewise|).```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13268,689215732,2021-08-16T03:16:02Z,runtime/doc/change.txt,"@@ -986,10 +986,10 @@ inside of strings can change!  Also see 'softtabstop' option. >  							*Y* [""x]Y			yank [count] lines [into register x] (synonym for-			yy, |linewise|).  If you like ""Y"" to work from the-			cursor to the end of line (which is more logical,-			but not Vi-compatible) use "":map Y y$"".-+			yy, |linewise|). This is the builtin mapping, see+			|Y-default| for neovim's default mapping.+							*Y-default*+[""x]Y                   This command maps to ""y$"". see |nvim-default-mappings|","- I do not understand why the `[""x]Y` in column 1 is repeated.- Don't need ""see"".- Can be more terse without loss of clarity, and now we have a repeatable pattern.```suggestion[""x]Y                   Mapped to ""y$"" by default. |nvim-default-mappings|```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12655,689503817,2021-08-16T12:45:03Z,test/functional/plugin/lsp_spec.lua,"@@ -847,25 +847,28 @@ describe('LSP', function()   end    it('highlight groups', function()-    eq({'LspDiagnosticsError',-        'LspDiagnosticsErrorFloating',-        'LspDiagnosticsErrorSign',-        'LspDiagnosticsHint',-        'LspDiagnosticsHintFloating',-        'LspDiagnosticsHintSign',-        'LspDiagnosticsInformation',-        'LspDiagnosticsInformationFloating',-        'LspDiagnosticsInformationSign',-        'LspDiagnosticsUnderline',-        'LspDiagnosticsUnderlineError',-        'LspDiagnosticsUnderlineHint',-        'LspDiagnosticsUnderlineInformation',-        'LspDiagnosticsUnderlineWarning',-        'LspDiagnosticsWarning',-        'LspDiagnosticsWarningFloating',-        'LspDiagnosticsWarningSign',-      },-      exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    eq({+      'LspDiagnosticsDefaultError',+      'LspDiagnosticsDefaultHint',+      'LspDiagnosticsDefaultInformation',+      'LspDiagnosticsDefaultWarning',","nit: name could be less verbose by omitting ""Default"", which is largely implied by the nature of builtin highlight groups. We should at least not repeat this pattern in the future.edit: fixed in https://github.com/neovim/neovim/pull/15585 and related PRs.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15346,689512016,2021-08-16T12:56:12Z,test/functional/api/buffer_spec.lua,"@@ -707,4 +707,40 @@ describe('api/buf', function()       eq({3, 0}, curbuf('get_mark', 'v'))     end)   end)++  describe('nvim_buf_set_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 1, 1)+      eq({1, 1}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercase marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 1)+      eq({3, 1}, curbuf('get_mark', 'Z'))+    end)+  end)++  describe('nvim_buf_del_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 3, 1)+      curbuf('del_mark', 'z')+      eq({0, 0}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercae marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 3)+      curbuf('del_mark', 'Z')+      eq({0, 0}, curbuf('get_mark', 'Z'))+    end)+    it('won\'t work in file/uppercae marks that do not belong to the buffer',","```suggestion    it('silently ignores file/uppercase marks that do not belong to the buffer',```",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15346,689515681,2021-08-16T13:00:52Z,test/functional/api/buffer_spec.lua,"@@ -707,4 +707,40 @@ describe('api/buf', function()       eq({3, 0}, curbuf('get_mark', 'v'))     end)   end)++  describe('nvim_buf_set_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 1, 1)+      eq({1, 1}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercase marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 1)+      eq({3, 1}, curbuf('get_mark', 'Z'))+    end)+  end)++  describe('nvim_buf_del_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 3, 1)+      curbuf('del_mark', 'z')+      eq({0, 0}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercae marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 3)+      curbuf('del_mark', 'Z')+      eq({0, 0}, curbuf('get_mark', 'Z'))+    end)+    it('won\'t work in file/uppercae marks that do not belong to the buffer',+      function()+        local abuf = meths.create_buf(false,true)+        buffer('set_lines', abuf, -1, -1, true, {'a', 'bit of', 'text'})+        buffer('set_mark', abuf, 'A', 2, 2)+        curbuf('del_mark', 'A')+        eq({2, 2}, buffer('get_mark', abuf, 'A'))","Yes, since it's trying to delete a mark a global mark that doesn't belong to the buffer therefore it doesn't change. This behavior is consistent with the existent `nvim_buf_get_mark` which only returns global marks positions that belong to the buffer. ",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15346,689517088,2021-08-16T13:02:39Z,test/functional/api/buffer_spec.lua,"@@ -707,4 +707,40 @@ describe('api/buf', function()       eq({3, 0}, curbuf('get_mark', 'v'))     end)   end)++  describe('nvim_buf_set_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 1, 1)+      eq({1, 1}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercase marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 1)+      eq({3, 1}, curbuf('get_mark', 'Z'))+    end)+  end)++  describe('nvim_buf_del_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 3, 1)+      curbuf('del_mark', 'z')+      eq({0, 0}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercae marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 3)+      curbuf('del_mark', 'Z')+      eq({0, 0}, curbuf('get_mark', 'Z'))+    end)+    it('won\'t work in file/uppercae marks that do not belong to the buffer',+      function()+        local abuf = meths.create_buf(false,true)+        buffer('set_lines', abuf, -1, -1, true, {'a', 'bit of', 'text'})+        buffer('set_mark', abuf, 'A', 2, 2)+        curbuf('del_mark', 'A')+        eq({2, 2}, buffer('get_mark', abuf, 'A'))","The mark belongs to ""abuf"" and It's trying to delete it from ""curbuf"" ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15346,689530505,2021-08-16T13:19:29Z,src/nvim/api/private/helpers.c,"@@ -2098,3 +2099,42 @@ bool parse_float_config(Dictionary config, FloatConfig *fconfig, bool reconf,   }   return true; }++/// Set a named mark+/// buffer and mark name must be validated already+/// @param buffer     Buffer to set the mark on+/// @param name       Mark name+/// @param line       Line number+/// @param col        Column/row number+void set_mark(buf_T *buf, String name, Integer line, Integer col, Error *err)+{+  buf = buf == NULL ? curbuf : buf;+  // If line == 0 the marks is being deleted+  bool deleting = false;+  if (line == 0) {+    col = 0;+    deleting = true;+  } else {+    if (col > MAXCOL) {+      api_set_error(err, kErrorTypeValidation, ""Column value outside range"");+      return;+    }+    if (line < 1 || line > buf->b_ml.ml_line_count) {+      api_set_error(err, kErrorTypeValidation, ""Line value outside range"");+      return;+    }+  }+  pos_T pos = { line, (int)col, (int)col };+  bool res = setmark_pos(*name.data, &pos, buf->handle);+  if (!res) {+    if (deleting) {+      api_set_error(err, kErrorTypeException,+                    ""Failed to delete named mark %c"", *name.data);+    } else {+      api_set_error(err, kErrorTypeException,+                    ""Failed to set named mark %c"", *name.data);","```suggestion                    ""Failed to set named mark: %c"", *name.data);```same for all other messages",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15346,689534629,2021-08-16T13:24:37Z,test/functional/api/buffer_spec.lua,"@@ -707,4 +707,40 @@ describe('api/buf', function()       eq({3, 0}, curbuf('get_mark', 'v'))     end)   end)++  describe('nvim_buf_set_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 1, 1)+      eq({1, 1}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercase marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 1)+      eq({3, 1}, curbuf('get_mark', 'Z'))+    end)+  end)++  describe('nvim_buf_del_mark', function()+    it('works with buffer marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'z', 3, 1)+      curbuf('del_mark', 'z')+      eq({0, 0}, curbuf('get_mark', 'z'))+    end)+    it('works with file/uppercae marks', function()+      curbuf('set_lines', -1, -1, true, {'a', 'bit of', 'text'})+      curbuf('set_mark', 'Z', 3, 3)+      curbuf('del_mark', 'Z')+      eq({0, 0}, curbuf('get_mark', 'Z'))+    end)+    it('won\'t work in file/uppercae marks that do not belong to the buffer',+      function()+        local abuf = meths.create_buf(false,true)+        buffer('set_lines', abuf, -1, -1, true, {'a', 'bit of', 'text'})+        buffer('set_mark', abuf, 'A', 2, 2)+        curbuf('del_mark', 'A')","if del_mark returns a success/fail result, the test becomes much clearer. that's a signal that the silent failure is probably not what we want.even then, i would still add a 1-line comment. too subtle.```suggestion        -- Fails because global mark A belongs to abuf, not curbuf.        eq(false, curbuf('del_mark', 'A'))```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15385,689551267,2021-08-16T13:45:29Z,runtime/doc/vim_diff.txt,"@@ -74,7 +74,10 @@ the differences.   Default Mappings:					*default-mappings*-  nnoremap Y y$++- nnoremap Y y$+- <C-L> clears search highlights |:nohlsearch| and updates diffs+  |:diffupdate|","nit: i think we should not have the bullet points, they end up being noisy in this help doc because of the sheer amount of items. Also for listing mappings they are distracting because mappings are a precise series of chars.I think we should just list the literal mappings here. Explain the semantics at `:help CTRL-L`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15385,689553987,2021-08-16T13:48:49Z,src/nvim/normal.c,"@@ -399,7 +399,8 @@ void init_normal_cmds(void)  void init_default_mappings(void) {-  add_map((char_u *)""Y y$"", NORMAL);+  add_map((char_u *)""Y y$"", NORMAL, true);+  add_map((char_u *)""<C-L> <Cmd>nohlsearch<Bar>diffupdate<CR><C-L>"", NORMAL, true);",- `<cmd>` is a good idea- do we need `<silent>` (extra arg to add_map I guess? but maybe it's not needed)- what about `has('diff')` to avoid unnecessary `:diffupdate`? see https://github.com/tpope/vim-sensible/blob/2d9f34c09f548ed4df213389caa2882bfe56db58/plugin/sensible.vim#L35,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15346,689568846,2021-08-16T14:06:32Z,src/nvim/api/buffer.c,"@@ -1134,9 +1134,63 @@ Boolean nvim_buf_is_valid(Buffer buffer)   return ret; } +/// Deletes a named mark in the buffer+//+/// Marks are (1,0)-indexed. |api-indexing|+///+/// @note Only deletes marks associated with the buffer+///+/// @param buffer     Buffer to set the mark on+/// @param name       Mark name {a-zZ0-9}+void nvim_buf_del_mark(Buffer buffer, String name, Error *err)+  FUNC_API_SINCE(8)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);+  if (!buf) {+    return;+  }+  if (name.size != 1) {+    api_set_error(err, kErrorTypeValidation,+                  ""Mark name must be a single character"");+  }+  // pos->lnum is 0 when the mark is not valid in the buffer, or is not set.+  pos_T *pos = getmark_buf(buf, *name.data, false);+  if (pos->lnum != 0) {+    // since the mark belongs to the buffer delete it.+    set_mark(buf, name, 0, 0, err);+  }+}++/// Sets a named mark in the given buffer"," I'm thinking of special marks like `'` , not extmarks.> In the other hand in the future there might a need for custom named marks (like bookmarks maybe?),Yeah. Might want to put a `Dictionary opt` parameter on all/most of these functions, for future expansion. (See other functions for examples of this pattern)",
329822,Julian,https://api.github.com/repos/neovim/neovim/pulls/14919,689594351,2021-08-16T14:36:20Z,runtime/lua/vim/shared.lua,"@@ -174,6 +174,21 @@ function vim.tbl_filter(func, t)   return rettab end +--- Create a table with a given value repeated multiple times.+---+--- Does *not* copy the provided object, so the returned table contains+--- identical objects.+---+--@param value the value to repeat+--@param count integer the number of times to repeat the given value",I used the style from the surrounding code (e.g. the function right below) but I think I caught out of the corner of my eye that that's being changed? But yeah e.g. https://github.com/neovim/neovim/blob/master/runtime/lua/vim/shared.lua#L59-L64 uses I believe what I did so I kept it the same for now unless you want me to use the new style just for this?,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15346,689675850,2021-08-16T16:16:36Z,src/nvim/api/buffer.c,"@@ -1134,9 +1134,63 @@ Boolean nvim_buf_is_valid(Buffer buffer)   return ret; } +/// Deletes a named mark in the buffer+//+/// Marks are (1,0)-indexed. |api-indexing|+///+/// @note Only deletes marks associated with the buffer+///+/// @param buffer     Buffer to set the mark on+/// @param name       Mark name {a-zZ0-9}+void nvim_buf_del_mark(Buffer buffer, String name, Error *err)+  FUNC_API_SINCE(8)+{+  buf_T *buf = find_buffer_by_handle(buffer, err);+  if (!buf) {+    return;+  }+  if (name.size != 1) {+    api_set_error(err, kErrorTypeValidation,+                  ""Mark name must be a single character"");+  }+  // pos->lnum is 0 when the mark is not valid in the buffer, or is not set.+  pos_T *pos = getmark_buf(buf, *name.data, false);+  if (pos->lnum != 0) {+    // since the mark belongs to the buffer delete it.+    set_mark(buf, name, 0, 0, err);+  }+}++/// Sets a named mark in the given buffer","This functions cover all types of marks. Since it's using `setmark_pos` this changes all types. https://github.com/neovim/neovim/blob/0aa8128aaa9e6f714372f7ea7299f4115de0a962/src/nvim/mark.c#L101 I'm under the impression that all default vim marks are called ""named marks""  and then there's global/file, lower, shada, etc. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13268,689693142,2021-08-16T16:40:28Z,src/nvim/normal.c,"@@ -397,6 +397,11 @@ void init_normal_cmds(void)   nv_max_linear = i - 1; } +void init_default_mappings(void)+{+  add_map((char_u *)""Y y$"", NORMAL | VISUAL);+}+",i guess technically it should go in getchar.c,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15397,689779561,2021-08-16T18:52:34Z,runtime/doc/vim_diff.txt,"@@ -60,8 +60,8 @@ the differences. - 'tags' defaults to ""./tags;,tags"" - 'ttimeoutlen' defaults to 50 - 'ttyfast' is always set-- 'viewoptions' includes ""unix,slash"" - 'undodir' defaults to ~/.local/share/nvim/undo (|xdg|), auto-created+- 'viewoptions' includes ""unix,slash"" and removes ""options""","for parallel form w/ line 53:```suggestion- 'viewoptions' includes ""unix,slash"", excludes ""options""```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15400,689965676,2021-08-17T01:26:43Z,test/functional/helpers.lua,"@@ -44,6 +44,8 @@ module.nvim_argv = {   '--cmd', module.nvim_set,   '--cmd', 'unmap Y',   '--cmd', 'unmap <C-L>',+  '--cmd', 'iunmap <C-U>',+  '--cmd', 'iunmap <C-W>',","~~for readability we should probably start a `module.nvim_unmap` variable to hold this.~~we may also run into the max arg limit: https://github.com/neovim/neovim/blob/3954537b9e243fb3df3672d47fe3d9529fa4e544/src/nvim/main.h#L7-L8up to now we have avoided passing a `-u` script to do the setup, possibly because it changes the startup sequence a bit. guess we can wait until we run into the limit...",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15243,690315853,2021-08-17T12:20:53Z,CONTRIBUTING.md,"@@ -62,16 +62,22 @@ Pull requests (PRs) - During a squash/fixup, use `exec make -C build unittest` between each   pick/edit/reword. -### Stages: WIP, RFC, RDY+### Stages: Draft and Ready for review -Pull requests have three stages: `[WIP]` (Work In Progress), `[RFC]` (Request-For Comment) and `[RDY]` (Ready).+Pull requests have two stages: Draft and Ready for review. -1. `[RFC]` is assumed by default, **do not** put ""RFC"" in the PR title (it adds-   noise to merge commit messages).-2. Add `[WIP]` to the PR title if you are _not_ requesting feedback and the work-   is still in flux.-3. Add `[RDY]` to the PR title if you are _done_ and only waiting on merge.+1. [Create a Draft PR][pr-draft] while you are _not_ requesting feedback as+  you are still working on the PR.+2. [Change your PR to ready][pr-ready] when the PR is ready for review.++You can convert the state of your PR back to Draft (or Ready for review) at any+time. You can also skip the Draft stage if your PR is ready for review from the+beginning.++Do __not__ add any labels like `[RFC]` or `[WIP]` in the title to indicate the+state of your PR: this just adds noise. Non-Draft PRs are assumed to be open+for comments by default; if you want feedback from specific people, `@`-ping+them in a comment.","Good point, but as long as we don't have more teams, how useful will that be? I worry that everyone will just ping `@neovim/neovim` then?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15418,691173140,2021-08-18T12:07:20Z,runtime/doc/eval.txt,"@@ -1060,7 +1060,8 @@ Floating point numbers can be written in two forms: 	[-+]{N}.{M}[eE][-+]{exp}  {N} and {M} are numbers.  Both {N} and {M} must be present and can only-contain digits.+contain digits, except that in |Vim9| script in {N} single quotes between+digits are ignored.","I'm not sure that's strictly true; we've used the commit ID in the past for (obvious) cherry-picks (and not gotten yelled at for it ;)). Just don't use the standard ""update runtime files"" description -- instead, be more specific -- and it should be unambiguous.But (only) @janlazo is the authority here.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15418,691201560,2021-08-18T12:45:54Z,runtime/doc/eval.txt,"@@ -1060,7 +1060,8 @@ Floating point numbers can be written in two forms: 	[-+]{N}.{M}[eE][-+]{exp}  {N} and {M} are numbers.  Both {N} and {M} must be present and can only-contain digits.+contain digits, except that in |Vim9| script in {N} single quotes between+digits are ignored.","That's how we have used it, and I would argue that, yes, since keeping the link to the runtime update commit is most important. (So it will show up in `git blame` for the cherry-picked file, and when searching for that commit in the log -- that you get multiple hits then is not a bad thing.)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15401,691437790,2021-08-18T16:54:42Z,src/nvim/autocmd.c,"@@ -2117,3 +2117,29 @@ bool au_exists(const char *const arg) FUNC_ATTR_WARN_UNUSED_RESULT   xfree(arg_save);   return retval; }++void init_default_autocmds(void)+{+  // open terminals when opening files that start with term://+#define PROTO ""term://""+  do_augroup((char_u *)""nvim_terminal"", false);+  do_autocmd_event(EVENT_BUFREADCMD, (char_u *)PROTO ""*"", false, true,+                   (char_u *)"":if !exists('b:term_title')|call termopen( ""+                   // Capture the command string+                   ""matchstr(expand(\""<amatch>\""), ""+                   ""'\\c\\m"" PROTO ""\\%(.\\{-}//\\%(\\d\\+:\\)\\?\\)\\?\\zs.*'), ""+                   // capture the working directory+                   ""{'cwd': expand(get(matchlist(expand(\""<amatch>\""), ""+                   ""'\\c\\m"" PROTO ""\\(.\\{-}\\)//'), 1, ''))})""+                   ""|endif"",+                   true,+                   AUGROUP_ALL);+  do_augroup((char_u *)""END"", false);+#undef PROTO++  // Only sync 1 syntax line in the command window+  do_augroup((char_u *)""nvim_cmdwin"", false);","One ""gotcha"" with using a runtime file is that it changes the script IDs of all subsequent scripts. This causes a lot of the tests to fail (since they assume script IDs start at 1, but they now start at 2) in addition to making the user's init.vim no longer have SID 1.Possible solutions:1. Don't execute the autocmd script when using `-u NONE`. This would fix the tests at least, but would prevent the `term://` BufReadCmd autocmd from working with `-u NONE`2. Source the autocmds.vim file after the user's init.vim. This would make init.vim still have SID 1, but the user can no longer remove these autocmds from their init.vim if they want to (I suppose we could add a guard around autocmds.vim so that user's can prevent it from loading). This would also prevent the `term://` BufReadCmd from working properly with e.g. `-c 'e term://ls'` on the command line.My 2 cents is that we do both (1) and (2) but keep the `nvim_terminal` autocommand as it is now, defined directly in `main.c` and only use `autocmds.vim` for the CmdWinEnter autocommand and any future default autocommands. Thoughts?**EDIT:** This pattern also extends well to another likely default autocommand: setting the cursor in its last position in a buffer when it's first opened. In order to blacklist buffers by filetype, that autocommand needs to be defined after the filetype autocommands, which the proposed method supports.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15401,691725483,2021-08-19T02:14:40Z,src/nvim/autocmd.c,"@@ -2117,3 +2117,29 @@ bool au_exists(const char *const arg) FUNC_ATTR_WARN_UNUSED_RESULT   xfree(arg_save);   return retval; }++void init_default_autocmds(void)+{+  // open terminals when opening files that start with term://+#define PROTO ""term://""+  do_augroup((char_u *)""nvim_terminal"", false);+  do_autocmd_event(EVENT_BUFREADCMD, (char_u *)PROTO ""*"", false, true,+                   (char_u *)"":if !exists('b:term_title')|call termopen( ""+                   // Capture the command string+                   ""matchstr(expand(\""<amatch>\""), ""+                   ""'\\c\\m"" PROTO ""\\%(.\\{-}//\\%(\\d\\+:\\)\\?\\)\\?\\zs.*'), ""+                   // capture the working directory+                   ""{'cwd': expand(get(matchlist(expand(\""<amatch>\""), ""+                   ""'\\c\\m"" PROTO ""\\(.\\{-}\\)//'), 1, ''))})""+                   ""|endif"",+                   true,+                   AUGROUP_ALL);+  do_augroup((char_u *)""END"", false);+#undef PROTO++  // Only sync 1 syntax line in the command window+  do_augroup((char_u *)""nvim_cmdwin"", false);","> This causes a lot of the tests to fail (since they assume script IDs start at 1, but they now start at 2)I'm surprised by this, and that's arguably a bug in the tests.  Upstream's test infrastructure sources numerous scripts as part of running the tests, so this sounds like something specific to _our_ tests.> in addition to making the user's init.vim no longer have SID 1.Meh, this just sounds like a case of [spacebar heating](https://xkcd.com/1172).> My 2 cents is that we do both (1) and (2) but keep the `nvim_terminal` autocommand as it is now, defined directly in `main.c` and only use `autocmds.vim` for the CmdWinEnter autocommand and any future default autocommands. Thoughts?Sounds good to me.  The important part is to be consistent.  I was starting to get flashbacks to the whole defaults.vim debacle, but thankfully you decided on always loading the file while providing the user the capability of short-circuiting the contents.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15425,692063751,2021-08-19T12:28:47Z,src/nvim/screen.c,"@@ -7643,7 +7638,7 @@ void screen_resize(int width, int height)   if (curwin->w_buffer == NULL)     return; -  ++busy;+  busy = true;","busy can only be zero or one, but renaming it `recursive` would make this more explicit.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15428,692084824,2021-08-19T12:57:27Z,.clang-format,"@@ -17,4 +17,7 @@ AllowShortLoopsOnASingleLine: false BinPackParameters: false BreakBeforeBinaryOperators: true BreakBeforeTernaryOperators: true-ContinuationIndentWidth: 4+ContinuationIndentWidth: 2+AlignEscapedNewlines: DontAlign+SortIncludes: false","Because of the clint warning > Found C system header after other header. Should be: c system, c++ system, other. [build/include_order] [4]If we add a `SortInlcudes: false` then we only need to sort them once manually and then be done with it, which seemed like the simplest solution to me. It's possible to sort includes by assigning priority with regexes but that looked like big trouble.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15428,692087200,2021-08-19T13:00:32Z,.clang-format,"@@ -17,4 +17,7 @@ AllowShortLoopsOnASingleLine: false BinPackParameters: false BreakBeforeBinaryOperators: true BreakBeforeTernaryOperators: true-ContinuationIndentWidth: 4+ContinuationIndentWidth: 2+AlignEscapedNewlines: DontAlign+SortIncludes: false","> Because of the clint warning> > > Found C system header after other header. Should be: c system, c++ system, other. [build/include_order] [4]> > If we add a `SortInlcudes: false` then we only need to sort them once manually and then be done with it, which seemed like the simplest solution to me. It's possible to sort includes by assigning priority with regexes but that looked like big trouble.If you separate the system headers from the project headers with a blank line, does clang-format still auto sort all of them into one big list, or does it respect the separation?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15428,692089161,2021-08-19T13:03:05Z,.clang-format,"@@ -17,4 +17,7 @@ AllowShortLoopsOnASingleLine: false BinPackParameters: false BreakBeforeBinaryOperators: true BreakBeforeTernaryOperators: true-ContinuationIndentWidth: 4+ContinuationIndentWidth: 2+AlignEscapedNewlines: DontAlign+SortIncludes: false","> It's possible to sort includes by assigning priority with regexes but that looked like big trouble.If we can sort the `#include <...>` includes first, that should be good enough. And then we can remove/relax the clint rule if it's still not happy.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15428,692094479,2021-08-19T13:09:45Z,.clang-format,"@@ -17,4 +17,7 @@ AllowShortLoopsOnASingleLine: false BinPackParameters: false BreakBeforeBinaryOperators: true BreakBeforeTernaryOperators: true-ContinuationIndentWidth: 4+ContinuationIndentWidth: 2+AlignEscapedNewlines: DontAlign+SortIncludes: false","> > Because of the clint warning> > > Found C system header after other header. Should be: c system, c++ system, other. [build/include_order] [4]> > > > > > If we add a `SortInlcudes: false` then we only need to sort them once manually and then be done with it, which seemed like the simplest solution to me. It's possible to sort includes by assigning priority with regexes but that looked like big trouble.> > If you separate the system headers from the project headers with a blank line, does clang-format still auto sort all of them into one big list, or does it respect the separation?Unfortunately not.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15428,692099567,2021-08-19T13:15:48Z,.clang-format,"@@ -17,4 +17,7 @@ AllowShortLoopsOnASingleLine: false BinPackParameters: false BreakBeforeBinaryOperators: true BreakBeforeTernaryOperators: true-ContinuationIndentWidth: 4+ContinuationIndentWidth: 2+AlignEscapedNewlines: DontAlign+SortIncludes: false","> > It's possible to sort includes by assigning priority with regexes but that looked like big trouble.> > If we can sort the `#include <...>` includes first, that should be good enough. And then we can remove/relax the clint rule if it's still not happy.I think that's possible. Two possible solutions:1. Add `// clang-format off/on` before and after the `#include <...>` block.2. Prioritize `#include <...>` over other includes with the help of regex rules.I'd probably go for the option 2 _if_ that's the only order that's important. If we start ordering three or more categories then probably option 1 (maybe it's my regex-phobia talking, so may not be entirely unbiased :) )",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15406,692253821,2021-08-19T15:46:24Z,src/nvim/terminal.c,"@@ -295,7 +295,10 @@ void terminal_close(Terminal *term, char *msg)   }    if (buf) {","> Is there ever a scenario where the `v:` dict is already freed but autocommands are _not_ blocked (I assume not but want to be sure)?No. I just like the semantics of checking `exiting`. But it's more correct to check `is_autocmd_blocked()` here, because `exiting` can be canceled if there are unsaved buffers.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15406,692624774,2021-08-20T03:04:25Z,test/functional/autocmd/termxx_spec.lua,"@@ -90,6 +90,19 @@ describe('autocmd TermClose', function()     retry(nil, nil, function() eq('3', eval('g:abuf')) end)     feed('<c-c>:qa!<cr>')   end)++  it('exposes v:event.status', function()+    nvim('set_option', 'shell', nvim_dir .. '/shell-test')+    command('autocmd TermClose * let g:status = v:event.status')+    command('terminal')+    retry(nil, nil, function() neq(-1, eval('jobwait([&channel], 0)[0]')) end)+    eq(0, eval('g:status'))++    nvim('set_option', 'shellcmdflag', 'EXIT')+    command('terminal 42')+    retry(nil, nil, function() neq(-1, eval('jobwait([&channel], 0)[0]')) end)+    eq(42, eval('g:status'))","do we need wmain() with wchar_t? that is what this other test fixture does: https://github.com/neovim/neovim/blob/2ae9ff128583984145ce38e61bbe9047871616bf/test/functional/fixtures/printenv-test.c#L13Edit: seems related to sscanf(), since this test commit succeeded: https://github.com/neovim/neovim/pull/15406/commits/0f99defa76dddae724009830e3331b9ac23374bd",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15406,692628953,2021-08-20T03:17:50Z,src/nvim/terminal.c,"@@ -278,8 +278,8 @@ void terminal_close(Terminal *term, char *msg, int status)   buf_T *buf = handle_get_buffer(term->buf_handle);   term->closed = true; -  if (!msg || exiting) {-    // If no msg was given, this was called by close_buffer(buffer.c).  Or if+  if (status == -1 || exiting) {+    // If status is -1, this was called by close_buffer(buffer.c).  Or if","I think status can be -1 when it's coming from job control. So now we need a special boolean parameter, `close_buf` or something ����",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/14536,692762584,2021-08-20T08:22:22Z,runtime/doc/lua.txt,"@@ -1581,4 +1581,72 @@ uri_to_fname({uri})                                       *vim.uri_to_fname()*                 Return: ~                     Filename +==============================================================================+Lua module: xdiff                                                  *lua-xdiff*++xdl_diff({a}, {b}, {opts})                                    *vim.xdl_diff()*","The original intention was to add a minimally-opinionated, maximally-transparent interface into xdiff.> Also ""xdiff"" is an implementation detail.It is and it isn't. Xdiff is the de facto standard diff library and has several implementations with pretty much identical API's, so I wanted this to be as close to that as possible. I'm ok if we want to do our own thing with this and just treat xdiff as pure implementation detail. Despite the interface being a close mapping to xdiff's, you're right in that it is quite generic. ",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/14536,692765506,2021-08-20T08:26:46Z,src/nvim/lua/xdiff.c,"@@ -0,0 +1,323 @@+#include <lua.h>+#include <lualib.h>+#include <lauxlib.h>++#include <stdlib.h>+#include <stdio.h>+#include <errno.h>+#include <string.h>++#include ""nvim/vim.h""+#include ""nvim/xdiff/xdiff.h""+#include ""nvim/lua/xdiff.h""+#include ""nvim/lua/converter.h""+#include ""nvim/lua/executor.h""+#include ""nvim/api/private/helpers.h""++typedef enum {+  kNluaXdiffModeStr =  0,+  kNluaXdiffModeCb,+  kNluaXdiffModeLines,+} NluaXdiffMode;++typedef struct {+  lua_State *lstate;+  Error     *err;+} hunkpriv_t;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""lua/xdiff.c.generated.h""+#endif++static int write_string(void *priv, mmbuffer_t *mb, int nbuf)+{+  luaL_Buffer *buf = (luaL_Buffer *)priv;+  for (int i = 0; i < nbuf; i++) {+    const long size = mb[i].size;+    for (long total = 0; total < size; total += LUAL_BUFFERSIZE) {+      const int tocopy = MIN((int)(size - total), LUAL_BUFFERSIZE);+      char *p = luaL_prepbuffer(buf);+      if (!p) {+        return -1;+      }+      memcpy(p, mb[i].ptr + total, (unsigned)tocopy);+      luaL_addsize(buf, (unsigned)tocopy);+    }+  }+  return 0;+}++// hunk_func callback used when opts.hunk_lines = true+static int hunk_lines_func(long start_a, long count_a,+                           long start_b, long count_b, void *cb_data)+{+  // Mimic extra offsets done by xdiff, see:+  // src/nvim/xdiff/xemit.c:284+  // src/nvim/xdiff/xutils.c:(356,368)+  if (count_a > 0) {","Ok, I'll make the adjustment in `hunk_func` too. Are you ok if I also rename `hunk_func` to `on_hunk` to indicate it isn't a 1-1 mapping, and to be more consistent with the naming scheme we use for other callbacks: `on_win`, `on_line`, etc?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15406,692892129,2021-08-20T12:04:07Z,test/functional/autocmd/termxx_spec.lua,"@@ -90,6 +90,19 @@ describe('autocmd TermClose', function()     retry(nil, nil, function() eq('3', eval('g:abuf')) end)     feed('<c-c>:qa!<cr>')   end)++  it('exposes v:event.status', function()+    nvim('set_option', 'shell', nvim_dir .. '/shell-test')+    command('autocmd TermClose * let g:status = v:event.status')+    command('terminal')+    retry(nil, nil, function() neq(-1, eval('jobwait([&channel], 0)[0]')) end)+    eq(0, eval('g:status'))++    nvim('set_option', 'shellcmdflag', 'EXIT')+    command('terminal 42')+    retry(nil, nil, function() neq(-1, eval('jobwait([&channel], 0)[0]')) end)+    eq(42, eval('g:status'))","wmain() is probably not needed and will require a lot of code. This test works on Windows CI, which also is using sscanf() in shell-test.c to parse a number: https://github.com/neovim/neovim/blob/29095b2a36babd0fc84823b2ecb60ed738d06dd7/test/functional/ui/wildmode_spec.lua#L117",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15406,693110545,2021-08-20T17:32:04Z,runtime/doc/nvim_terminal_emulator.txt,"@@ -134,6 +134,10 @@ Example: >   programs can set this by emitting an escape sequence. - |'channel'|  Terminal PTY |job-id|.  Can be used with |chansend()| to send   input to the terminal.+- The |TermClose| event gives the terminal job exit code in the |v:event|+  ""status"" field. For example, this autocmd closes terminal buffers if the job+  exited without error: >+    autocmd TermClose * if !v:event.status | exe 'bdelete! '..expand('<abuf>') | endif","> This should be just one `.` for concatenation, not two. And in fact you don���t need to concatenate the strings at all since `exe` automatically separates its arguments with a space.Two is supported now and is less ambiguous. `:help expr-..`I thought about omitting the operator but felt like it's a bit too magical and could lead to mistakes if users edit this in their config without knowing all the fun details of vimscript.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15406,693117585,2021-08-20T17:44:57Z,runtime/doc/nvim_terminal_emulator.txt,"@@ -134,6 +134,10 @@ Example: >   programs can set this by emitting an escape sequence. - |'channel'|  Terminal PTY |job-id|.  Can be used with |chansend()| to send   input to the terminal.+- The |TermClose| event gives the terminal job exit code in the |v:event|+  ""status"" field. For example, this autocmd closes terminal buffers if the job+  exited without error: >+    autocmd TermClose * if !v:event.status | exe 'bdelete! '..expand('<abuf>') | endif","> Two is supported now and is less ambiguous. `:help expr-..`Ah that���s right, I had forgotten about that since I so rarely see it in practice. That is nice that the Lua and VimL concatenation operator can be the same. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14536,693127931,2021-08-20T18:03:25Z,runtime/doc/lua.txt,"@@ -1581,4 +1581,70 @@ uri_to_fname({uri})                                       *vim.uri_to_fname()*                 Return: ~                     Filename +==============================================================================+Lua module: diff                                                    *lua-diff*++diff({a}, {b}, {opts})                                            *vim.diff()*+                Run diff on strings {a} and {b}.++                Examples: >+                vim.diff('a\n', 'b\nc\n')+                -->+                @@ -1 +1,2 @@+                -a+                +b+                +c++                vim.diff('a\n', 'b\nc\n', {hunk_lines = true})+                -->+                {+                    {1, 1, 1, 2}+                }+<+                Parameters: ~+                    {a}      First string to compare+                    {b}      Second string to compare+                    {opts}   Optional parameters:+                             ��� `on_hunk` (callback):+                               Invoked for each hunk in the diff. Return a+                               negative number to cancel the callback for any+                               remaining hunks.+                               Args:+                               ��� `start_a` (integer): Start line of hunk in {a}, 1-based.+                               ��� `count_a` (integer): Hunk size in {a}.+                               ��� `start_b` (integer): Start line of hunk in {b}, 1-based.+                               ��� `count_b` (integer): Hunk size in {b}.+                             ��� `hunk_lines` (boolean):+                               Return an array of the hunk locations. Cannot+                               be used with `on_hunk`.","Future idea: would it make sense to optionally return a structured result? Like a map of line numbers:textchanges, e.g.:```{  42= { type: .... old: '...', new: '...' },  43= { type: .... old: '...', new: '...' },  ...,}```Then to leave the door open for that, we probably want a single parameter (string instead of bool) than controls the result form. Something like```suggestion                             ��� `result_type` (string): Controls the form of the returned diff. Cannot be used with `on_hunk`.                               ��� ""unified"": (default) unified diff string                                ��� ""lines"": array of the hunk locations```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15442,693429710,2021-08-22T02:39:09Z,src/nvim/channel.c,"@@ -802,6 +802,7 @@ static void term_close(void *data)   Channel *chan = data;   process_stop(&chan->stream.proc);   multiqueue_put(chan->events, term_delayed_free, 1, data);+  terminal_wipe(chan->term);","The reason I wanted to put this in `term_close` is to avoid duplicate implementations both when the user presses a key on the `[Process exited 0]` message as well as when the buffer automatically closes in #15440. If we keep this in `terminal_enter` then we have to basically do the same thing again in #15440 but in a different way (unless we can make a `TermClose` autocommand that enters the `terminal_enter` code path with something like `feedkeys`, but that feels pretty hacky to me).I'm open to suggestions on how to approach this.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15402,693433366,2021-08-22T03:21:11Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +256,11 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""won't close while a job is running (without !)"", function()     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))+    command('call jobstop(&channel)')+    retry(nil, nil, function() eq(-3, eval('jobwait([&channel], 0)[0]')) end)+    command('bdelete')","There's a race condition somewhere, as even running the test locally fails randomly.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/12536,693516691,2021-08-22T15:16:06Z,runtime/doc/lua.txt,"@@ -876,6 +876,34 @@ vim.region({bufnr}, {pos1}, {pos2}, {type}, {inclusive})       *vim.region()*         whether the selection is inclusive or not, into a zero-indexed table          of linewise selections of the form `{linenr = {startcol, endcol}}` . +                                             *vim.register_keystroke_callback()*+vim.register_keystroke_callback({fn}, {ns_id})+        Register a lua {fn} with an {ns_id} to be run after every keystroke.","- `-w` was mentioned in the PR discussion, that's a hint that it should be mentioned in the docs here (and the commit message).- is `on_key` a more conventional name? we should try to use consistent naming conventions. It really helps users and plugin authors discover and reason about the API.PR: https://github.com/neovim/neovim/pull/15460",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14919,693552133,2021-08-22T20:21:46Z,runtime/lua/vim/shared.lua,"@@ -174,6 +174,21 @@ function vim.tbl_filter(func, t)   return rettab end +--- Create a table with a given value repeated multiple times.+---+--- Does *not* copy the provided object, so the returned table contains+--- identical objects.+---+---@param value the value to repeat+---@param count integer the number of times to repeat the given value+function vim.tbl_repeat(value, count)","- should we name it `tbl_rep` for parallel form with Lua's `string.rep()` ?- i would swap the arguments, because. this is a pattern i recommend in general.    1. the count is the most interesting part, since the idea is ""i want to repeat this N times""    2. the count arg will usually be short, this avoids having it get hidden off-screen if `value` is a big expression- also seems natural for `value` to optionally accept a function, but I guess that could be added later.```suggestionfunction vim.tbl_rep(count, value)```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15454,693565305,2021-08-22T22:19:10Z,test/functional/api/window_spec.lua,"@@ -347,6 +347,21 @@ describe('API/win', function()       eq(2, #meths.list_wins())       eq('', funcs.getcmdwintype())     end)++    it('closing current (float) window of another tabpage #15313', function()+      command('tabedit')+      eq(2, eval('tabpagenr()'))+      local win = meths.open_win(0, true, {+        relative='editor', row=10, col=10, width=50, height=10+      })+      local tabpage = eval('tabpagenr()')+      command('tabprevious')+      eq(1, eval('tabpagenr()'))+      meths.win_close(win, false)++      eq(1000, meths.tabpage_get_win(tabpage))","I think that error is indicating that the test framework thinks nvim_tabpage_get_win() is returning a list-like table.    eq({ 1001 }, meths.tabpage_get_win(tabpage))But that is suspicious. `nvim_tabpage_get_win` result should be interpreted as a Lua number, not a table.Just tried locally, this appears to be a quirk of `helpers.meths()`. Should be revisited, but is unrelated to this PR.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15087,693610128,2021-08-23T02:21:09Z,scripts/gen_vimdoc.py,"@@ -109,7 +109,10 @@         # Section helptag.         'helptag_fmt': lambda name: f'*api-{name.lower()}*',         # Per-function helptag.-        'fn_helptag_fmt': lambda fstem, name: f'*{name}()*',+        'fn_helptag_fmt': lambda fstem, name: [+            f'*{name}()*',",It's necessary for ambiguous cases. So this is the right choice.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,693992391,2021-08-23T13:52:41Z,src/nvim/screen.c,"@@ -1925,10 +1925,10 @@ static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl) /// @return number of chars added to \param p static size_t fill_foldcolumn(-    char_u *p,-    win_T *wp,-    foldinfo_T foldinfo,-    linenr_T lnum+                char_u *p,","this is better than before, but ideally should be converted to nvim-style parameter lists instead (but not a show-stopper for the first batch, as it doesn't make it _worse_ at least :)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15465,693993300,2021-08-23T13:53:44Z,src/nvim/screen.c,"@@ -1925,10 +1925,10 @@ static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl) /// @return number of chars added to \param p static size_t fill_foldcolumn(-    char_u *p,-    win_T *wp,-    foldinfo_T foldinfo,-    linenr_T lnum+                char_u *p,+                win_T *wp,+                foldinfo_T foldinfo,+                linenr_T lnum","Is aligning function parameters with the opening paren of a function definition already part of the Nvim style guide? If not, I'd like to throw my opinion into the ring to not do this and just have the parameter list indented twice (as it is now) to minimize diff noise any time a function name changes. I personally also find it less readable, particularly when you have a long function name and the parameter list is halfway across the screen.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15465,694214971,2021-08-23T18:35:09Z,src/nvim/screen.c,"@@ -1925,10 +1925,10 @@ static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl) /// @return number of chars added to \param p static size_t fill_foldcolumn(-    char_u *p,-    win_T *wp,-    foldinfo_T foldinfo,-    linenr_T lnum+                char_u *p,+                win_T *wp,+                foldinfo_T foldinfo,+                linenr_T lnum","> Is aligning function parameters with the opening paren of a function definition already part of the Nvim style guide?[Yes it is](https://neovim.io/develop/style-guide.xml?showone=Function_Declarations_and_Definitions#Function_Declarations_and_Definitions). That being said, if there ever was good opportunity to revise the style rules it would be now :) . I agree it looks kinda ridiculous for functions with long names or functions with many arguments.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,694231638,2021-08-23T19:00:19Z,src/nvim/screen.c,"@@ -1925,10 +1925,10 @@ static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl) /// @return number of chars added to \param p static size_t fill_foldcolumn(-    char_u *p,-    win_T *wp,-    foldinfo_T foldinfo,-    linenr_T lnum+                char_u *p,+                win_T *wp,+                foldinfo_T foldinfo,+                linenr_T lnum","It is also part of our style to _not_ have a linebreak per parameter no reason, but fill with parameters until the column limit is reached, and _then_ add a line break aligned to the start param (there are legitimate exceptions to this, but this function is not. it is just vim code which hasn't been adjusted yet).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,694233247,2021-08-23T19:02:55Z,src/nvim/screen.c,"@@ -1925,10 +1925,10 @@ static int line_putchar(LineState *s, schar_T *dest, int maxcells, bool rl) /// @return number of chars added to \param p static size_t fill_foldcolumn(-    char_u *p,-    win_T *wp,-    foldinfo_T foldinfo,-    linenr_T lnum+                char_u *p,+                win_T *wp,+                foldinfo_T foldinfo,+                linenr_T lnum",> I agree it looks kinda ridiculous for functions with long names or functions with many arguments.The style guide even mentions this case explicitly already.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,694332548,2021-08-23T21:48:56Z,src/nvim/screen.c,"@@ -6400,7 +6400,7 @@ void screenalloc(void)   if ((default_grid.chars != NULL        && Rows == default_grid.Rows        && Columns == default_grid.Columns-       )+  )","> it's aligned with the ""if"". it's a fairly common style (but i have no preference).except that it is _not_ the `)` that belongs to the `if(` statement but a _inner expression_ parenthesis. Look at the full diff, not just what github's UI shows you. ",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15472,694792342,2021-08-24T12:14:14Z,runtime/doc/pattern.txt,"@@ -71,12 +71,14 @@ N			Repeat the latest ""/"" or ""?"" [count] times in 			Only whole keywords are searched for, like with the 			command ""/\<keyword\>"".  |exclusive| 			'ignorecase' is used, 'smartcase' is not.+			In Visual mode, search forward selection.  							*#* #			Same as ""*"", but search backward.  The pound sign 			(character 163) also works.  If the ""#"" key works as 			backspace, try using ""stty erase <BS>"" before starting 			Vim (<BS> is CTRL-H or a real backspace).+			In Visual mode, search backward selection.","We need to add help tags for the default values, as in:https://github.com/neovim/neovim/blob/5d633546bf5990d03e4b4dc1df213f88316115e6/runtime/doc/insert.txt#L80-L82So let's add tags for `v_*-default` and `v_#-default`, both of which should also have a link back to `*default-mappings*`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,695664085,2021-08-25T11:33:41Z,src/nvim/screen.c,"@@ -4511,25 +4571,11 @@ void screen_adjust_grid(ScreenGrid **grid, int *row_off, int *col_off) // @param count max number of signs // @param[out] n_extrap number of characters from pp_extra to display // @param[in, out] sign_idxp Index of the displayed sign-static void get_sign_display_info(-    bool nrcol,-    win_T *wp,-    sign_attrs_T sattrs[],-    int row,-    int startrow,-    int filler_lines,-    int filler_todo,-    int count,-    int *c_extrap,-    int *c_finalp,-    char_u *extra,-    size_t extra_size,-    char_u **pp_extra,-    int *n_extrap,-    int *char_attrp,-    int *draw_statep,-    int *sign_idxp-)+static void get_sign_display_info(bool nrcol, win_T *wp, sign_attrs_T sattrs[], int row,+                                  int startrow, int filler_lines, int filler_todo, int count,+                                  int *c_extrap, int *c_finalp, char_u *extra, size_t extra_size,","IMHO no. Extremely long argument argument lists are pretty rare (and an antipattern, this should be refactored to use a struct later on) and our existing style looks good for the common case (_not_ extremely long arg lists)",x
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15402,695803670,2021-08-25T14:21:43Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +256,11 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""won't close while a job is running (without !)"", function()     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))","How should it be added though? `:quit` doesn't throw an exception, it simply terminates the running Nvim process as well as the terminal process. What are we testing there?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15402,695820633,2021-08-25T14:39:00Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +256,11 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""won't close while a job is running (without !)"", function()     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))+    command('call jobstop(&channel)')+    retry(nil, nil, function() eq(-3, eval('jobwait([&channel], 0)[0]')) end)+    command('bdelete')","I think I was wrong about the race condition. `f_jobwait` processes the job's event queue after the `process_wait` calls `decref` which enqueues `process_close_event`:https://github.com/neovim/neovim/blob/a373ca1d826b1386f1fa291de70ee5d6bb81ec9b/src/nvim/eval/funcs.c#L5414But this leaves me back at square one. I'm no longer able to reproduce the failure on my dev machine, and it seems like it only fails on Windows, but I have no ideas why that would be.Failing on FreeBSD too. Hmmm....",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15340,696481442,2021-08-26T09:59:54Z,.github/ISSUE_TEMPLATE/bug_report.yml,"@@ -43,8 +37,8 @@ body:     attributes:       label: ""Steps to reproduce""       description: |-        Steps to reproduce using `nvim -u NORC` and/or `nvim -u NONE` (please test both).-        If you are reporting build failures, please list the exact sequence of steps including all CMake flags (if any).+        If you cannot reproduce the issue using `nvim -u NORC`, prepare and upload a [minimal config](https://github.com/neovim/neovim/blob/master/contrib/minimal.lua) that reproduces the issue with `nvim -u minimal.lua`.","For the record, I experimented with providing a pre-filled text area for the minimal config in telescope: https://github.com/nvim-telescope/telescope.nvim/blob/master/.github/ISSUE_TEMPLATE/bug_report.ymlMy experience is mixed, since this invites reporters to just leave the prefilled text alone and submit the issue (without actually using and providing the minimal config).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15407,696500159,2021-08-26T10:26:34Z,runtime/doc/autocmd.txt,"@@ -812,6 +812,14 @@ RemoteReply			When a reply from a Vim that functions as 				Note that even if an autocommand is defined, 				the reply should be read with |remote_read()| 				to consume it.+							*RecordingEnter*+RecordingEnter			When a macro starts to be recorded.+				The pattern is the current file name, and+				|reg_recording()| is the current register that+				is used.+							*RecordinLeave*+RecordingLeave			When the is the end of a macro recording.+				The pattern is the current file name.","```suggestion				The pattern is the current file name, and				|reg_recorded()| is the register that				was recorded to.```Not sure if this is true though. Probably it shouldn't be: could be useful if, on RecordingLeave, reg_recording() is the ""current"" register and reg_recorded() is the previous one.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15484,696500797,2021-08-26T10:27:36Z,src/nvim/testdir/test_backspace_opt.vim,"@@ -1,3 +1,8 @@+"" 'backspace' is removed #15484+if has('nvim')+  finish+endif+ "" Tests for 'backspace' settings  func Test_backspace_option()",This seems to be a test of the generic idea of a commalist option. Do we have similar tests for other options that are equally comprehensive (otherwise this could be findreplaced into a test for some other option with at least four valid values),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15407,696516623,2021-08-26T10:51:26Z,src/nvim/normal.c,"@@ -4652,15 +4652,18 @@ static void nv_zet(cmdarg_T *cap) /*  * ""Q"" command.  */-static void nv_exmode(cmdarg_T *cap)+static void nv_regrecorded(cmdarg_T *cap)","based on `nv_at` this could be named `nv_q`. Though other `nv_` functions are named more semantically. So perhaps `nv_regexec` or `nv_regreplay`.nv_regrecorded doesn't seem right, it's named in the past tense and this is executing not recording.```suggestionstatic void nv_regexec(cmdarg_T *cap)```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15484,696548848,2021-08-26T11:42:27Z,src/nvim/testdir/test_backspace_opt.vim,"@@ -1,3 +1,8 @@+"" 'backspace' is removed #15484+if has('nvim')+  finish+endif+ "" Tests for 'backspace' settings  func Test_backspace_option()",See alsohttps://github.com/neovim/neovim/pull/15484/files#diff-d6ab96f29571f8965add2c71d890dc13bdae9e2653b01620e5d281ceffd376e4L641-R643andhttps://github.com/neovim/neovim/pull/15484/files#diff-6d7ef04f38f6f82559796fd15bfdc2d93485623d6ada5d9f89d660b2c48d13f5L190-R192So we are still covering comma list options.,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/15465,696707313,2021-08-26T14:50:19Z,src/nvim/screen.c,"@@ -7449,12 +7502,12 @@ static void win_redr_ruler(win_T *wp, bool always)      * To avoid portability problems we use strlen() here.      */     vim_snprintf((char *)buffer, RULER_BUF_LEN, ""%"" PRId64 "","",-        (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L+                 (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L                                                  : (int64_t)wp->w_cursor.lnum);",I think this decreses the readability of long ternary operators...,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,696729745,2021-08-26T15:14:32Z,src/nvim/screen.c,"@@ -7449,12 +7502,12 @@ static void win_redr_ruler(win_T *wp, bool always)      * To avoid portability problems we use strlen() here.      */     vim_snprintf((char *)buffer, RULER_BUF_LEN, ""%"" PRId64 "","",-        (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L+                 (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L                                                  : (int64_t)wp->w_cursor.lnum);","it's clearly wrong, but it doesn't make it worse than the previous (wrong) state, to my eyes at least. (though perhaps there are similar cases where it does?)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,696809305,2021-08-26T16:49:09Z,src/nvim/screen.c,"@@ -2327,7 +2362,7 @@ static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow,         area_highlighting = true;         attr = win_hl_attr(wp, HLF_V);       }-    // handle 'incsearch' and "":s///c"" highlighting+      // handle 'incsearch' and "":s///c"" highlighting","well it should be but it is not something an automated tool can understand unless it is an AI, so I think it is okay as far as uncrustify is concerned (alternative version: a human needs to move this comment one line below where it belongs)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15465,696819443,2021-08-26T17:02:46Z,src/nvim/screen.c,"@@ -2327,7 +2362,7 @@ static int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow,         area_highlighting = true;         attr = win_hl_attr(wp, HLF_V);       }-    // handle 'incsearch' and "":s///c"" highlighting+      // handle 'incsearch' and "":s///c"" highlighting","the problem is that it is about the next `else if` condition, but it is _syntactically_ part of the branch just before. in principle a comment like this could just as well be a post-condition of the previous branch, so the automatic formatter has to pick one or the other. (this applies to legacy vim code, in neovim code we write the comment in the following branch where it belongs).",
18519692,notomo,https://api.github.com/repos/neovim/neovim/pulls/15482,697046344,2021-08-26T23:39:35Z,test/functional/lua/highlight_spec.lua,"@@ -0,0 +1,26 @@+local helpers = require('test.functional.helpers')(after_each)+local funcs = helpers.funcs+local exec_lua = helpers.exec_lua+local command = helpers.command+local clear = helpers.clear++describe('vim.highlight.on_yank', function()++  before_each(function()+    clear()+  end)++  it('does not show errors even if buffer is wiped before timeout', function()","hmm.`on_yank()` is executed without yank.But my local environment's test seemed to be flaky.I'll fix it ���� <details><summary>Details</summary>```diffdiff --git a/runtime/lua/vim/highlight.lua b/runtime/lua/vim/highlight.luaindex 236f3165f..8f3a9764f 100644--- a/runtime/lua/vim/highlight.lua+++ b/runtime/lua/vim/highlight.lua@@ -86,9 +86,9 @@ function highlight.on_yank(opts)    vim.defer_fn(     function()-      if api.nvim_buf_is_valid(bufnr) then+      -- if api.nvim_buf_is_valid(bufnr) then         api.nvim_buf_clear_namespace(bufnr, yank_ns, 0, -1)-      end+      -- end     end,     timeout   )``````[----------] Global test environment setup.[----------] Running tests from test/functional/lua/highlight_spec.lua[ RUN      ] vim.highlight.on_yank does not show errors even if buffer is wiped before timeout: 1226.90 ms FAILtest/functional/lua/highlight_spec.lua:23: ""vim/highlight.lua:%d+: Invalid buffer id: 2"" should not be in logExpected objects to be the same.Passed in:(boolean) trueExpected:(boolean) falsestack traceback:        test/functional/lua/highlight_spec.lua:23: in function <test/functional/lua/highlight_spec.lua:13>[----------] 1 test from test/functional/lua/highlight_spec.lua (1229.11 ms total)[----------] Global test environment teardown.------------------------------------------------------------------------------$NVIM_LOG_FILE: /home/notomo/.cache/nvim/log(last 10 lines)INFO  2021-08-27T07:50:56.626 2070  emsg_multiline:684: Error executing vim.schedule lua callback: /home/notomo/workspace/neovim/runtime/lua/vim/highlight.lua:90: Invalid buffer id: 2DEBUG 2021-08-27T07:50:56.626 2070  UI: raw_lineDEBUG 2021-08-27T07:50:56.626 2070  UI: msg_set_posDEBUG 2021-08-27T07:50:56.626 2070  UI: raw_lineDEBUG 2021-08-27T07:50:56.626 2070  UI: raw_line (+1 times...)DEBUG 2021-08-27T07:50:56.626 2070  UI: msg_set_posDEBUG 2021-08-27T07:50:56.626 2070  UI: raw_lineDEBUG 2021-08-27T07:50:56.626 2070  UI: raw_line (+1 times...)DEBUG 2021-08-27T07:50:56.626 2070  UI: grid_cursor_gotoDEBUG 2021-08-27T07:50:56.626 2070  inbuf_poll:414: blocking... events_enabled=0 events_pending=0------------------------------------------------------------------------------[==========] 1 test from 1 test file ran. (1229.46 ms total)[  PASSED  ] 0 tests.[  FAILED  ] 1 test, listed below:[  FAILED  ] test/functional/lua/highlight_spec.lua @ 13: vim.highlight.on_yank does not show errors even if buffer is wiped before timeouttest/functional/lua/highlight_spec.lua:23: ""vim/highlight.lua:%d+: Invalid buffer id: 2"" should not be in logExpected objects to be the same.Passed in:(boolean) trueExpected:(boolean) falsestack traceback:        test/functional/lua/highlight_spec.lua:23: in function <test/functional/lua/highlight_spec.lua:13> 1 FAILED TEST-- Tests exited non-zero: 1-- No output to stderr.CMake Error at /home/notomo/workspace/neovim/cmake/RunTests.cmake:85 (message):  functional tests failed with error: 1```</details>",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15402,697125901,2021-08-27T03:25:23Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +256,11 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""won't close while a job is running (without !)"", function()     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))+    command('call jobstop(&channel)')+    retry(nil, nil, function() eq(-3, eval('jobwait([&channel], 0)[0]')) end)+    command('bdelete')","Ok I think I'm narrowing in on the issue.In `buffer.c` we're checking to see if the terminal job is finished with `terminal_running`, which just checks the `closed` field of the `Terminal` struct. This field is set in `terminal_close`, which is called by `channel_process_exit_cb`, which is called in `process_close_event`, which is enqueued on the process's `MultiQueue` struct when it has no remaining references.The problem is that this queue is not processed before our test runs `command(""bdelete"")`, so `do_buffer` gets called before `terminal_close` does, *even though* the process has already terminated. So one solution is to simply check the process directly rather than using `terminal_running`:```diff--- a/src/nvim/buffer.c+++ b/src/nvim/buffer.c@@ -1238,15 +1238,21 @@ do_buffer(       }     } -    if (!forceit && buf->terminal && terminal_running(buf->terminal)) {-      if (p_confirm || cmdmod.confirm) {-        if (!dialog_close_terminal(buf)) {+    if (!forceit && buf->terminal) {+      char_u *dummy;+      uint64_t chan_id;+      get_option_value(""channel"", (long *)&chan_id, &dummy, OPT_LOCAL);+      Channel *chan = find_job(chan_id, false);+      if (chan) {+        if (p_confirm || cmdmod.confirm) {+          if (!dialog_close_terminal(buf)) {+            return FAIL;+          }+        } else {+          EMSG2(_(""E89: %s will be killed (add ! to override)""),+                (char *)buf->b_fname);           return FAIL;         }-      } else {-        EMSG2(_(""E89: %s will be killed (add ! to override)""),-              (char *)buf->b_fname);-        return FAIL;       }     }```It's not as pretty as just calling `terminal_running`, but I'm fairly confident this would work.The only other way to force the process exit callback to run is to call `process_wait`, which immediately processes the process's event queue after decrementing the ref count: https://github.com/neovim/neovim/blob/274a3504a790a799b28ee89c75e29fb4dbdff41f/src/nvim/event/process.c#L201-L206`f_jobwait` only calls `process_wait` if the job is still valid, which it may not be by the time we call it. And *even if* the job still is valid, `f_jobwait` passes a different `MultiQueue` object to `process_wait`, so the `events` argument in the snippet above doesn't actually belong to `proc`. I think this might be a bug, I believe this should actually read:```diffdiff --git a/src/nvim/event/process.c b/src/nvim/event/process.cindex b93d6cc0a..05b94a7b6 100644--- a/src/nvim/event/process.c+++ b/src/nvim/event/process.c@@ -200,10 +200,8 @@ int process_wait(Process *proc, int ms, MultiQueue *events)   if (proc->refcount == 1) {     // Job exited, free its resources.     decref(proc);-    if (events) {-      // the decref call created an exit event, process it now-      multiqueue_process_events(events);-    }+    // the decref call created an exit event, process it now+    multiqueue_process_events(proc->events);   } else {     proc->refcount--;   }```In any case, there's no way (currently) to force a call to `process_wait`. So the first solution is the only viable option (as far as I can tell).@justinmk What do you think?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14812,697375327,2021-08-27T11:44:30Z,src/nvim/channel.h,"@@ -28,6 +28,10 @@ typedef enum {   kChannelPartAll } ChannelPart; +typedef enum {+  kChannelStdinPipe,+  kChannelStdinNull,+} ChannelStdinMode;","would it make sense to name this ChannelMode, and add kChannelBuffered, then use this internally to model the stderr_buffered/stdout_buffered flags? And potentially we would add `stderr`, `stdout` string options to jobstart(), and deprecate the stderr_buffered/stdout_buffered booleans.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15407,697387434,2021-08-27T12:05:57Z,src/nvim/ops.c,"@@ -909,35 +909,35 @@ int do_record(int c)       showmode();       regname = c;       retval = OK;+      apply_autocmds(EVENT_RECORDINGENTER, NULL, NULL, false, curbuf);     }-  } else {                        /* stop recording */-    /*-     * Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this-     * needs to be removed again to put it in a register.  exec_reg then-     * adds the escaping back later.-     */+  } else {  // stop recording+    // Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this+    // needs to be removed again to put it in a register.  exec_reg then+    // adds the escaping back later.+    reg_recorded = reg_recording;","> I'd expect that the return value is which register I just stopped recording.We aren't necessarily bound to RecordingLeave having those semantics. Many ""Leave"" events happen ""at the edge"", i.e. ""just before leaving"". So the question is which one is more useful; seems to me it is not useful for reg_recorded== reg_recording during RecordingLeave.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14812,697609287,2021-08-27T17:32:54Z,src/nvim/channel.h,"@@ -28,6 +28,10 @@ typedef enum {   kChannelPartAll } ChannelPart; +typedef enum {+  kChannelStdinPipe,+  kChannelStdinNull,+} ChannelStdinMode;","> For example, what happens when `""stdout""` is set to `""null""` but an `""on_stdout""` callback is provided? What does it mean when `""stdin""` is set to `""buffered""`?At the input layer we would of course validate valid values, just as ""foo"" is not a valid value for the `stdin` mode parameter.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/14812,697611407,2021-08-27T17:36:21Z,src/nvim/channel.h,"@@ -28,6 +28,10 @@ typedef enum {   kChannelPartAll } ChannelPart; +typedef enum {+  kChannelStdinPipe,+  kChannelStdinNull,+} ChannelStdinMode;","I understand that, but the point I was trying to make was that I don't know if the additional validation required results in a net reduction in complexity.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,697785711,2021-08-28T01:34:15Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +256,11 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""won't close while a job is running (without !)"", function()     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))+    command('call jobstop(&channel)')+    retry(nil, nil, function() eq(-3, eval('jobwait([&channel], 0)[0]')) end)+    command('bdelete')","> And _even if_ the job still is valid, `f_jobwait` passes a different `MultiQueue` object to `process_wait`, so the `events` argument in the snippet above doesn't actually belong to `proc`Nice catch, this looks like a mistake from f1de097dbb236ea400150f80b909407ca9af7441 .I don't see this change on this PR, shall we see if it fixes the windows CI?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,697791077,2021-08-28T02:21:26Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +256,11 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""won't close while a job is running (without !)"", function()     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))+    command('call jobstop(&channel)')+    retry(nil, nil, function() eq(-3, eval('jobwait([&channel], 0)[0]')) end)+    command('bdelete')","> `f_jobwait` passes a different `MultiQueue` object to `process_wait`, so the `events` argument in the snippet above doesn't actually belong to `proc`.Just to be clear (you probably know already): that ""only"" affects ordering, since `proc->events` is a child of `main_loop.events`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,697791923,2021-08-28T02:28:23Z,src/nvim/buffer.c,"@@ -1231,20 +1231,25 @@ do_buffer(           return FAIL;         }       } else {-        if (buf->terminal) {-          if (p_confirm || cmdmod.confirm) {-            if (!dialog_close_terminal(buf)) {-              return FAIL;-            }-          } else {-            EMSG2(_(""E89: %s will be killed (add ! to override)""),-                  (char *)buf->b_fname);+        EMSGN(_(""E89: No write since last change for buffer %"" PRId64+                "" (add ! to override)""),+              buf->b_fnum);+        return FAIL;+      }+    }++    if (!forceit && buf->terminal) {+      uint64_t chan_id;+      get_option_value(""channel"", (long *)&chan_id, NULL, OPT_LOCAL);","this makes an assumption about curbuf which we shouldn't introduce here. I was hoping that `f_getbufvar` would lead to a function that takes a `buf`, but no... https://github.com/neovim/neovim/blob/8af13ed946aa06636c633327c6549993e2e50116/src/nvim/eval/funcs.c#L3004-L3024",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15402,697792701,2021-08-28T02:34:46Z,src/nvim/buffer.c,"@@ -1231,20 +1231,25 @@ do_buffer(           return FAIL;         }       } else {-        if (buf->terminal) {-          if (p_confirm || cmdmod.confirm) {-            if (!dialog_close_terminal(buf)) {-              return FAIL;-            }-          } else {-            EMSG2(_(""E89: %s will be killed (add ! to override)""),-                  (char *)buf->b_fname);+        EMSGN(_(""E89: No write since last change for buffer %"" PRId64+                "" (add ! to override)""),+              buf->b_fnum);+        return FAIL;+      }+    }++    if (!forceit && buf->terminal) {+      uint64_t chan_id;+      get_option_value(""channel"", (long *)&chan_id, NULL, OPT_LOCAL);",We can use `get_option_value_strict` instead which takes a `buf_T` as its `from` parameter (this is how `nvim_buf_get_option` does it).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15504,697864341,2021-08-28T12:33:30Z,runtime/lua/vim/lsp.lua,"@@ -1316,8 +1316,8 @@ function lsp.buf_request_all(bufnr, method, params, callback)     end   end) -  local function _sync_handler(err, _, result, client_id)-    request_results[client_id] = { error = err, result = result }+  local function _sync_handler(err, result, context)","naming nit: any objection to using `ctx` for this arg everywhere? it's going to be all over the place I guess, and would rather establish that convention now. `ctx` is a common convention for ""context"" and has the mild benefit of disambiguating unrelated uses of the word ""context"" e.g. with `grep ctx`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15340,697864779,2021-08-28T12:37:10Z,.github/ISSUE_TEMPLATE/bug_report.yml,"@@ -52,24 +51,33 @@ body:     attributes:       label: ""How to reproduce the issue""       description: |-        - Steps to reproduce using `nvim -u NORC` or `nvim -u NONE` (try both).+        - [Prepare](https://github.com/neovim/neovim/blob/master/CONTRIBUTING.md#reporting-problems) a minimal config that reproduces the problem with `nvim -u minimal.lua` and provide it below.         - For build failures: list the exact steps including CMake flags (if any).         - For shell-related problems: try `env -i TERM=ansi-256color ""$(which nvim)""`.       placeholder: |-        nvim -u NONE-        :edit foo-        yiwp+        1. `nvim -u minimal.lua` +        2. `:edit foo` +        3. `yiwp`      validations:       required: true    - type: textarea     attributes:       label: ""Expected behavior""-      description: ""Describe the behavior you expect. May include logs, images, or videos.""+      description: ""Describe the behavior you expect. May include logs (`:edit $NVIM_LOG_FILE`), images, or videos.""     validations:       required: true   - type: textarea     attributes:       label: ""Actual behavior""     validations:       required: true++  - type: textarea+    attributes:+      label: ""Minimal config""+      description: ""Minimal(!) configuration necessary to reproduce the issue. You can start with the provided [`minimal.lua`](https://github.com/neovim/neovim/blob/master/contrib/minimal.lua). If _absolutely_ necessary, add plugins and config options from your `init.lua` at the indicated lines.""+      render: Lua+    validations:+      required: true","It doesn't really reduce friction. I almost never install plugins to repro an issue, and I don't want to start doing so. I'm also imagining a veteran vim user trying to file a bug report and getting hit with these bureaucratic steps, and then just giving us the middle finger...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15340,697864878,2021-08-28T12:38:14Z,.github/ISSUE_TEMPLATE/bug_report.yml,"@@ -52,24 +51,33 @@ body:     attributes:       label: ""How to reproduce the issue""       description: |-        - Steps to reproduce using `nvim -u NORC` or `nvim -u NONE` (try both).+        - [Prepare](https://github.com/neovim/neovim/blob/master/CONTRIBUTING.md#reporting-problems) a minimal config that reproduces the problem with `nvim -u minimal.lua` and provide it below.         - For build failures: list the exact steps including CMake flags (if any).         - For shell-related problems: try `env -i TERM=ansi-256color ""$(which nvim)""`.       placeholder: |-        nvim -u NONE-        :edit foo-        yiwp+        1. `nvim -u minimal.lua` +        2. `:edit foo` +        3. `yiwp` ","safari bugs (temporary) don't dictate our issue template. it's not purely cosmetic, because this establishes the pattern that many will follow or feel urged to follow.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15465,697871351,2021-08-28T13:38:33Z,src/nvim/screen.c,"@@ -1065,7 +1080,7 @@ static void win_update(win_T *wp, Providers *providers)         if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {           /*            * Skip the lines (below the deleted lines) that are still-           * valid and don't need redrawing.	Copy their info+           * valid and don't need redrawing.    Copy their info","My bad, I thought this was desired. I turned on the option that converts tabs to spaces in comments. Should I change it back?Also, impressive that you noticed it considering this was a very recent change :) .",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/13320,697999229,2021-08-29T11:18:36Z,test/functional/lua/highlight_spec.lua,"@@ -1,14 +1,187 @@+local Screen = require('test.functional.ui.screen') local helpers = require('test.functional.helpers')(after_each)-local exec_lua = helpers.exec_lua+local clear = helpers.clear+local command = helpers.command local eq = helpers.eq local eval = helpers.eval-local command = helpers.command-local clear = helpers.clear--describe('vim.highlight.on_yank', function()+local exec_lua = helpers.exec_lua+local feed = helpers.feed -  before_each(function()+before_each(function()     clear()+end)++describe('highlight.on_yank()', function()+  local screen+  local HL_TIMEOUT = 30+  local enable_hl_on_yank = function(args)+    local higroup = args['higroup'] or 'IncSearch'","And I was following the pattern `hi[ghlight] foo guifg=...`, I guess.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15504,698069711,2021-08-29T20:58:20Z,runtime/lua/vim/lsp.lua,"@@ -672,13 +672,13 @@ function lsp.start_client(config)   --- corresponding handler.   ---   ---@param method (string) LSP method name-  ---@param params (table) The parameters for that method.-  function dispatch.notification(method, params)-    local _ = log.debug() and log.debug('notification', method, params)+  ---@param result (table) The parameters for that method.",is this docstring correct? result=parameters ?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,698079972,2021-08-29T22:29:00Z,src/nvim/eval/funcs.c,"@@ -5404,8 +5404,17 @@ static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)   TV_LIST_ITER_CONST(args, arg, {     Channel *chan = NULL;     if (TV_LIST_ITEM_TV(arg)->v_type != VAR_NUMBER-        || !(chan = find_job(TV_LIST_ITEM_TV(arg)->vval.v_number, false))) {+        || !(chan = find_channel(TV_LIST_ITEM_TV(arg)->vval.v_number))+        || chan->streamtype != kChannelStreamProc) {       jobs[i] = NULL;  // Invalid job.+    } else if (process_is_stopped(&chan->stream.proc)) {+      // Process is already stopped, so ensure all callbacks on its event+      // queue are drained+      Process *proc = &chan->stream.proc;+      LOOP_PROCESS_EVENTS_UNTIL(proc->loop, proc->events, -1, !proc->refcount);++      // Set job to NULL so that the return value will be set to -3 below+      jobs[i] = NULL;",as a reader it would help me see a pattern if this stays identical with the case above. the longer comment doesn't seem to add anything.```suggestion      jobs[i] = NULL;  // Invalid job.```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,698081204,2021-08-29T22:40:29Z,src/nvim/eval/funcs.c,"@@ -5404,8 +5404,17 @@ static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)   TV_LIST_ITER_CONST(args, arg, {     Channel *chan = NULL;     if (TV_LIST_ITEM_TV(arg)->v_type != VAR_NUMBER-        || !(chan = find_job(TV_LIST_ITEM_TV(arg)->vval.v_number, false))) {+        || !(chan = find_channel(TV_LIST_ITEM_TV(arg)->vval.v_number))+        || chan->streamtype != kChannelStreamProc) {       jobs[i] = NULL;  // Invalid job.+    } else if (process_is_stopped(&chan->stream.proc)) {+      // Process is already stopped, so ensure all callbacks on its event+      // queue are drained+      Process *proc = &chan->stream.proc;+      LOOP_PROCESS_EVENTS_UNTIL(proc->loop, proc->events, -1, !proc->refcount);","- any reason not to use `process_wait()`? that avoids reaching into `proc->refcount` (informally private), and also fits semantically, so a reader can see that process_wait() is called in multiple places in jobwait().```suggestion      process_wait(&chan->stream.proc, -1, NULL);```also via @bfredl:> it should be documented that any object holding a proc->refcount must release that eventually by an event on the process own event queue. and i.e. not by some event on some other child queue (only)Not sure where to document this, I guess the top of `src/nvim/event/process.c` or a docstring on `Process`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,698081747,2021-08-29T22:45:42Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +260,22 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""requires bang (!) to close a running job"", function()+    local cwd = funcs.fnamemodify('.', ':p:~'):gsub([[[\/]*$]], '')+    local ext_pat = iswin() and '%.EXE' or ''     eq('Vim(wqall):E948: Job still running', exc_exec('wqall'))+    matches('^Vim%(bdelete%):E89: term://'..pesc(cwd)..'//%d+:'..nvim_dir..'/tty%-test'..ext_pat..' will be killed %(add %! to override%)$', exc_exec('bdelete'))","- we could simplify the test by not being so precise. I don't think we lose much by changing the pattern to ignore the CWD and EXE. Up to you, though.    - this anticipates a glorious future where we change the `term://` format https://github.com/neovim/neovim/issues/3278```suggestion    matches('^Vim%(bdelete%):E89: term://.*tty%-test.* will be killed %(add %! to override%)$', exc_exec('bdelete'))```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15402,698082513,2021-08-29T22:52:28Z,src/nvim/eval/funcs.c,"@@ -5404,8 +5404,17 @@ static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)   TV_LIST_ITER_CONST(args, arg, {     Channel *chan = NULL;     if (TV_LIST_ITEM_TV(arg)->v_type != VAR_NUMBER-        || !(chan = find_job(TV_LIST_ITEM_TV(arg)->vval.v_number, false))) {+        || !(chan = find_channel(TV_LIST_ITEM_TV(arg)->vval.v_number))+        || chan->streamtype != kChannelStreamProc) {       jobs[i] = NULL;  // Invalid job.+    } else if (process_is_stopped(&chan->stream.proc)) {+      // Process is already stopped, so ensure all callbacks on its event+      // queue are drained+      Process *proc = &chan->stream.proc;+      LOOP_PROCESS_EVENTS_UNTIL(proc->loop, proc->events, -1, !proc->refcount);","The idea was to cut to the chase and sidestep the other stuff that process_wait does, as well as being explicit that we are just processing the event queue and not necessarily ���waiting��� for a process that has already stopped.But I think you���re right that it may be clearer. And I wasn���t aware of the semantics around `refcount`, so I think your suggestion makes sense.(Btw I���m replying on mobile and just using the ���Commit suggestion��� box, so forgive the lack of better commit messages. I figure they can be squashed/rebased later).",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15504,698089336,2021-08-29T23:44:33Z,runtime/lua/vim/lsp.lua,"@@ -687,12 +687,12 @@ function lsp.start_client(config)   ---   ---@param method (string) LSP method name   ---@param params (table) The parameters for that method-  function dispatch.server_request(method, params)-    local _ = log.debug() and log.debug('server_request', method, params)+  function dispatch.server_request(method, result)","I changed it back, to params, I think result make sense in the signature of our handlers, but we should stick with params in the dispatch function table, as that maps directly onto the spec (my bad for changing it originally in the PR, see my above comment earlier in the thread.",
42310725,Diomendius,https://api.github.com/repos/neovim/neovim/pulls/15507,698122239,2021-08-30T02:26:06Z,src/nvim/lua/vim.lua,"@@ -55,29 +55,30 @@ end  function vim._load_package(name)   local basename = name:gsub('%.', '/')-  local paths = {""lua/""..basename.."".lua"", ""lua/""..basename..""/init.lua""}-  for _,path in ipairs(paths) do-    local found = vim.api.nvim_get_runtime_file(path, false)-    if #found > 0 then-      local f, err = loadfile(found[1])-      return f or error(err)-    end+  local paths = ""lua/""..basename.."".lua lua/""..basename..""/init.lua""","The only code path from `require()` besides Lua's own search paths is through `vim._load_package -> vim.api.nvim_get_runtime_file -> do_in_runtimepath -> do_in_path_and_pp -> do_in_path`. The only calls to the callback are in `do_in_path` here: https://github.com/neovim/neovim/blob/b35de6c525e7c8ad9d64d42f57f348dff608b9e5/src/nvim/runtime.c#L102-L137If `path` is `NULL`, the callback is called with `buf`, which is the current rtp entry (this behaviour is briefly documented in the doc-comment on `do_in_path_and_pp`, although only `do_in_path` actually implements it) and if `path` is not `NULL` it is split on spaces and tabs at line 116, wildcard-expanded at line 126 and the callback is called on each expansion.So `do_in_path_and_pp` does currently handle globbing and does also unconditionally split on spaces and tabs. `require()` currently works to find modules in packages (and still does on this PR branch) and currently breaks when the module name contains spaces or tabs (and still does on this PR branch).I agree that these functions shouldn't be so fragile (I already ran into the problem that you still can't build Neovim from a path which contains whitespace, see #4621, but that depends on the build process for Nvim's dependencies too) but I'm not sure if that's in scope for this PR.If it does get changed, the signature for many of these functions would have to change. `nvim_get_runtime_file` could, as a Lua function, take either a string or an array, but I'm not sure the current Lua API generation makes it easy to express this.Alternatively, the string handling could be changed to handle escaped whitespace, but that might be even more effort than changing the signatures.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15507,698298970,2021-08-30T08:33:50Z,src/nvim/lua/vim.lua,"@@ -55,29 +55,30 @@ end  function vim._load_package(name)   local basename = name:gsub('%.', '/')-  local paths = {""lua/""..basename.."".lua"", ""lua/""..basename..""/init.lua""}-  for _,path in ipairs(paths) do-    local found = vim.api.nvim_get_runtime_file(path, false)-    if #found > 0 then-      local f, err = loadfile(found[1])-      return f or error(err)-    end+  local paths = ""lua/""..basename.."".lua lua/""..basename..""/init.lua""","we probably want a new `nvim_get_runtime_pattern` or something function later which takes a structural pattern (and is more efficient than spamming syscalls via string hacking), for now this PR is fine if it marginally improves things while still supporting all the existing cases. The exiting test for `fixtures/pack/foo/start/lua/bar.lua` needs to be complemented with  `fixtures/pack/foo/start/lua/spam/init.lua` to verify this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15526,698625114,2021-08-30T16:19:40Z,src/nvim/CMakeLists.txt,"@@ -56,6 +56,8 @@ set(VIM_MODULE_FILE ${GENERATED_DIR}/lua/vim_module.generated.h) set(LUA_VIM_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/src/nvim/lua/vim.lua) set(LUA_SHARED_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/shared.lua) set(LUA_INSPECT_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/inspect.lua)+set(LUA_F_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/F.lua)+set(LUA_META_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/_meta.lua)",Why not put them in `src/nvim/lua/` then? IIRC `runtime/lua/`  is only for shared stuff or stuff that isn't necessary for `nvim -u NONE`. https://github.com/neovim/neovim/blob/c52ec8f9eb397da3440dcd821c41d5687b46ec16/src/nvim/lua/vim.lua#L1-L9,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15526,698690709,2021-08-30T17:56:14Z,src/nvim/CMakeLists.txt,"@@ -56,6 +56,8 @@ set(VIM_MODULE_FILE ${GENERATED_DIR}/lua/vim_module.generated.h) set(LUA_VIM_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/src/nvim/lua/vim.lua) set(LUA_SHARED_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/shared.lua) set(LUA_INSPECT_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/inspect.lua)+set(LUA_F_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/F.lua)+set(LUA_META_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/_meta.lua)","> but I'm not sure why it would be helpful to spread things around.How is it spreading things? Isn't it a bit confusing that compiled things are also present in the runtime files, yet inert: changes to the file won't be reflected when calling `vim.F` ? (The exception being `shared*`, which at least has a common, documented indicator ""shared"".)> > -- Guideline: ""If in doubt, put it in the runtime"".Yes, but there is no doubt based on the decision tree: item (3) says compiled things go in src/nvim/lua.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15526,698698180,2021-08-30T18:08:13Z,src/nvim/CMakeLists.txt,"@@ -56,6 +56,8 @@ set(VIM_MODULE_FILE ${GENERATED_DIR}/lua/vim_module.generated.h) set(LUA_VIM_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/src/nvim/lua/vim.lua) set(LUA_SHARED_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/shared.lua) set(LUA_INSPECT_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/inspect.lua)+set(LUA_F_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/F.lua)+set(LUA_META_MODULE_SOURCE ${PROJECT_SOURCE_DIR}/runtime/lua/vim/_meta.lua)","> changes to the file won't be reflected when calling vim.F ? (The exception being shared*, which at least has a common, documented indicator ""shared"".)Except that same is true with _all_ runtime files,  when you use any prefixed install, which is the only officially supported way of running neovim. (running directly from the source dir requires hacks, I _have_ been arguing of making this work by a standardized entry point but I was counter-signaled that time, happy to let things be revised of course).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15402,699206144,2021-08-31T10:48:45Z,test/functional/terminal/buffer_spec.lua,"@@ -255,8 +260,22 @@ describe(':terminal buffer', function()     command('bdelete!')   end) -  it('handles wqall', function()+  it(""requires bang (!) to close a running job"", function()+    local cwd = funcs.fnamemodify('.', ':p:~'):gsub([[[\/]*$]], '')+    local ext_pat = iswin() and '%.EXE' or ''",ext_pat is no longer used (helpers.iswin and other imports can be removed also),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15440,699396272,2021-08-31T14:43:54Z,src/nvim/ex_docmd.c,"@@ -9504,6 +9504,13 @@ static void ex_terminal(exarg_T *eap)   }    do_cmdline_cmd(ex_cmd);++  if (*eap->arg == NUL) {+    do_cmdline_cmd(""autocmd TermClose <buffer> ""+                   "" if !v:event.status | ""+                   ""   exec 'bdelete! ' .. expand('<abuf>') | ""+                   "" endif"");","I've been thinking about this more and two things occurred to me:1) Making it a global autocommand means we can't use the heuristic of whether or not an argument was provided to `:terminal` to determine if we should automatically close the buffer or not. Right now, we create this autocommand if there is no argument and we are therefore using a default shell. But if, for instance, a user runs `:terminal ls` then we *do not* want to automatically close the buffer when the job completes. If we use a global autocommand we will need another flag or something to indicate which state we are in.2) I wonder if it's not actually more common that users may want to opt-out of the auto-close behavior on a per-job/per-terminal instance, rather than opting out globally. This is much more straightforward to do with a buffer-local autocommand. This would also provide plugins finer-grained control to opt out of this behavior, which wouldn't be possible (or at least, more complex) with a global autocommand.For these two reasons I think we ought to stick with a buffer-local autocommand. What do you think?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15440,699439652,2021-08-31T15:29:07Z,src/nvim/ex_docmd.c,"@@ -9504,6 +9504,13 @@ static void ex_terminal(exarg_T *eap)   }    do_cmdline_cmd(ex_cmd);++  if (*eap->arg == NUL) {+    do_cmdline_cmd(""autocmd TermClose <buffer> ""+                   "" if !v:event.status | ""+                   ""   exec 'bdelete! ' .. expand('<abuf>') | ""+                   "" endif"");","> Should work, since this default autocmd will always be defined before any user/plugin autocmds. Just needs a unique augroup, something like `nvim_terminal_close`.The plugin would need to disable the global autocommand in that case though, which the user may not want. The only way around this would be to add some kind of buffer-local variable that acts as a flag (e.g. `let b:terminal_autoclose = v:false`) that the plugin could set. But if we're doing that, why not just use a buffer-local autocommand?I guess I disagree that a global autocommand is less messy, it paints with too broad of a brush so we end up needing to introduce further measures to account for edge cases and exceptions.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15401,699595398,2021-08-31T18:59:17Z,src/nvim/aucmd.c,"@@ -35,6 +36,30 @@ void do_autocmd_uienter(uint64_t chanid, bool attached)   recursive = false; } +void init_default_autocmds(void)+{+  // open terminals when opening files that start with term://+#define PROTO ""term://""+  do_cmdline_cmd(""augroup nvim_terminal"");+  do_cmdline_cmd(""autocmd!"");+  do_cmdline_cmd(""autocmd BufReadCmd "" PROTO ""* ++nested ""+                 ""if !exists('b:term_title')|call termopen(""+                 // Capture the command string+                 ""matchstr(expand(\""<amatch>\""), ""+                 ""'\\c\\m"" PROTO ""\\%(.\\{-}//\\%(\\d\\+:\\)\\?\\)\\?\\zs.*'), ""+                 // capture the working directory+                 ""{'cwd': expand(get(matchlist(expand(\""<amatch>\""), ""+                 ""'\\c\\m"" PROTO ""\\(.\\{-}\\)//'), 1, ''))})""+                 ""|endif"");+  do_cmdline_cmd(""augroup END"");+#undef PROTO++  // limit syntax synchronization in the command window+  do_cmdline_cmd(""augroup nvim_cmdwinenter"");","nit: we can use a slightly more general name, `nvim_cmdwin` . If we ever need other handlers in that augroup, they will be disambiguated by the event type.```suggestion  do_cmdline_cmd(""augroup nvim_cmdwin"");```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15540,700167504,2021-09-01T12:33:30Z,runtime/lua/vim/lsp/codelens.lua,"@@ -44,9 +44,10 @@ end  --- Return all lenses for the given buffer ---+---@param bufnr number  Buffer number. 0 can be used for the current buffer.","Sorry, was too quick with the merge.I can do a follow up to streamline the docs, there are a couple of other places where we use different ways to describe the bufnr parameter.",
629908,hrsh7th,https://api.github.com/repos/neovim/neovim/pulls/15561,701951455,2021-09-03T14:50:23Z,runtime/lua/vim/lsp/util.lua,"@@ -255,45 +252,73 @@ function M.apply_text_edits(text_edits, bufnr)     vim.fn.bufload(bufnr)   end   api.nvim_buf_set_option(bufnr, 'buflisted', true)-  local start_line, finish_line = math.huge, -1-  local cleaned = {}-  for i, e in ipairs(text_edits) do-    -- adjust start and end column for UTF-16 encoding of non-ASCII characters-    local start_row = e.range.start.line-    local start_col = get_line_byte_from_position(bufnr, e.range.start)-    local end_row = e.range[""end""].line-    local end_col = get_line_byte_from_position(bufnr, e.range['end'])-    start_line = math.min(e.range.start.line, start_line)-    finish_line = math.max(e.range[""end""].line, finish_line)-    -- TODO(ashkan) sanity check ranges for overlap.-    table.insert(cleaned, {-      i = i;-      A = {start_row; start_col};-      B = {end_row; end_col};-      lines = vim.split(e.newText, '\n', true);-    })-  end -  -- Reverse sort the orders so we can apply them without interfering with-  -- eachother. Also add i as a sort key to mimic a stable sort.-  table.sort(cleaned, edit_sort_key)-  local lines = api.nvim_buf_get_lines(bufnr, start_line, finish_line + 1, false)-  local fix_eol = api.nvim_buf_get_option(bufnr, 'fixeol')-  local set_eol = fix_eol and api.nvim_buf_line_count(bufnr) <= finish_line + 1-  if set_eol and (#lines == 0 or #lines[#lines] ~= 0) then-    table.insert(lines, '')-  end+  -- Fix reversed range and indexing each text_edits+  local index = 0+  text_edits = vim.tbl_map(function(text_edit)",See https://github.com/microsoft/vscode-languageserver-node/blob/main/textDocument/src/main.ts#L440The `index` is needed to sort as stable.,
629908,hrsh7th,https://api.github.com/repos/neovim/neovim/pulls/15561,701951781,2021-09-03T14:50:50Z,runtime/lua/vim/lsp/util.lua,"@@ -255,45 +252,73 @@ function M.apply_text_edits(text_edits, bufnr)     vim.fn.bufload(bufnr)   end   api.nvim_buf_set_option(bufnr, 'buflisted', true)-  local start_line, finish_line = math.huge, -1-  local cleaned = {}-  for i, e in ipairs(text_edits) do-    -- adjust start and end column for UTF-16 encoding of non-ASCII characters-    local start_row = e.range.start.line-    local start_col = get_line_byte_from_position(bufnr, e.range.start)-    local end_row = e.range[""end""].line-    local end_col = get_line_byte_from_position(bufnr, e.range['end'])-    start_line = math.min(e.range.start.line, start_line)-    finish_line = math.max(e.range[""end""].line, finish_line)-    -- TODO(ashkan) sanity check ranges for overlap.-    table.insert(cleaned, {-      i = i;-      A = {start_row; start_col};-      B = {end_row; end_col};-      lines = vim.split(e.newText, '\n', true);-    })-  end -  -- Reverse sort the orders so we can apply them without interfering with-  -- eachother. Also add i as a sort key to mimic a stable sort.-  table.sort(cleaned, edit_sort_key)-  local lines = api.nvim_buf_get_lines(bufnr, start_line, finish_line + 1, false)-  local fix_eol = api.nvim_buf_get_option(bufnr, 'fixeol')-  local set_eol = fix_eol and api.nvim_buf_line_count(bufnr) <= finish_line + 1-  if set_eol and (#lines == 0 or #lines[#lines] ~= 0) then-    table.insert(lines, '')-  end+  -- Fix reversed range and indexing each text_edits+  local index = 0+  text_edits = vim.tbl_map(function(text_edit)+    index = index + 1+    text_edit._index = index++    if text_edit.range.start.line > text_edit.range['end'].line or text_edit.range.start.line == text_edit.range['end'].line and text_edit.range.start.character > text_edit.range['end'].character then+      local start = text_edit.range.start+      text_edit.range.start = text_edit.range['end']+      text_edit.range['end'] = start+    end+    return text_edit+  end, text_edits)++  -- Sort text_edits+  table.sort(text_edits, function(a, b)",See https://github.com/microsoft/vscode-languageserver-node/blob/main/textDocument/src/main.ts#L355,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14115,702520145,2021-09-06T02:09:16Z,runtime/lua/vim/lsp/handlers.lua,"@@ -110,36 +110,45 @@ M['client/registerCapability'] = function(_, _, ctx) end  --see: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction-M['textDocument/codeAction'] = function(_, result)-  if result == nil or vim.tbl_isempty(result) then+M['textDocument/codeAction'] = function(_, actions, ctx)","I tried to keep the naming consistent as `result` for each handler and fully populate each handler with nil (`_`) args to make it obvious that they all have the same signature, up for discussion though.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15575,703048608,2021-09-06T19:21:57Z,src/nvim/ex_docmd.c,"@@ -2093,8 +2114,9 @@ int parse_command_modifiers(exarg_T *eap, char_u **errormsg, bool skip_only)       cmdmod.split |= WSP_BOT;       continue; -    case 'c':   if (!checkforcmd(&eap->cmd, ""confirm"", 4))+    case 'c':   if (!checkforcmd(&eap->cmd, ""confirm"", 4)) {         break;+    }","there's a few more cases like this, could be fixed manually with a suitable pattern for now :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15579,703050192,2021-09-06T19:28:59Z,runtime/lua/vim/lsp/snippet.lua,"@@ -0,0 +1,406 @@+local P = {}++---Take characters until the target characters (The escape sequence is '\' + char)+---@param targets string[] The character list for stop consuming text.+---@param specials string[] If the character isn't contained in targets/specials, '\' will be left.+P.take_until = function(targets, specials)+  targets = targets or {}+  specials = specials or {}++  return function(input, pos)+    local new_pos = pos+    local raw = {}+    local esc = {}+    while new_pos <= #input do+      local c = string.sub(input, new_pos, new_pos)+      if c == '\\' then+        table.insert(raw, '\\')+        new_pos = new_pos + 1+        c = string.sub(input, new_pos, new_pos)+        if not vim.tbl_contains(targets, c) and not vim.tbl_contains(specials, c) then+          table.insert(esc, '\\')+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      else+        if vim.tbl_contains(targets, c) then+          break+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      end+    end++    if new_pos == pos then+      return P.unmatch(pos)+    end++    return {+      parsed = true,+      value = {+        raw = table.concat(raw, ''),+        esc = table.concat(esc, '')+      },+      pos = new_pos,+    }+  end+end++P.unmatch = function(pos)+  return {+    parsed = false,+    value = nil,+    pos = pos,+  }+end++P.map = function(parser, map)+  return function(input, pos)+    local result = parser(input, pos)+    if result.parsed then+      return {+        parsed = true,+        value = map(result.value),+        pos = result.pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.lazy = function(factory)","looks like a lot of functional-style utilities are here. Consider moving them to a new module `runtime/lua/vim/fun.lua`.( https://github.com/neovim/neovim/pull/12655 introduced `F.lua` but I do not think we should augment it, instead we should deprecate it because it does not follow the module naming convention of any of our other modules.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15579,703050875,2021-09-06T19:31:39Z,runtime/lua/vim/lsp/snippet.lua,"@@ -0,0 +1,406 @@+local P = {}++---Take characters until the target characters (The escape sequence is '\' + char)+---@param targets string[] The character list for stop consuming text.+---@param specials string[] If the character isn't contained in targets/specials, '\' will be left.+P.take_until = function(targets, specials)+  targets = targets or {}+  specials = specials or {}++  return function(input, pos)+    local new_pos = pos+    local raw = {}+    local esc = {}+    while new_pos <= #input do+      local c = string.sub(input, new_pos, new_pos)+      if c == '\\' then+        table.insert(raw, '\\')+        new_pos = new_pos + 1+        c = string.sub(input, new_pos, new_pos)+        if not vim.tbl_contains(targets, c) and not vim.tbl_contains(specials, c) then+          table.insert(esc, '\\')+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      else+        if vim.tbl_contains(targets, c) then+          break+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      end+    end++    if new_pos == pos then+      return P.unmatch(pos)+    end++    return {+      parsed = true,+      value = {+        raw = table.concat(raw, ''),+        esc = table.concat(esc, '')+      },+      pos = new_pos,+    }+  end+end++P.unmatch = function(pos)+  return {+    parsed = false,+    value = nil,+    pos = pos,+  }+end++P.map = function(parser, map)+  return function(input, pos)+    local result = parser(input, pos)+    if result.parsed then+      return {+        parsed = true,+        value = map(result.value),+        pos = result.pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.lazy = function(factory)+  return function(input, pos)+    return factory()(input, pos)+  end+end++P.token = function(token)+  return function(input, pos)+    local maybe_token = string.sub(input, pos, pos + #token - 1)+    if token == maybe_token then+      return {+        parsed = true,+        value = maybe_token,+        pos = pos + #token,+      }+    end+    return P.unmatch(pos)+  end+end++P.pattern = function(p)+  return function(input, pos)+    local maybe_match = string.match(string.sub(input, pos), '^' .. p)+    if maybe_match then+      return {+        parsed = true,+        value = maybe_match,+        pos = pos + #maybe_match,+      }+    end+    return P.unmatch(pos)+  end+end++P.many = function(parser)+  return function(input, pos)+    local values = {}+    local new_pos = pos+    while new_pos <= #input do+      local result = parser(input, new_pos)+      if not result.parsed then+        break+      end+      table.insert(values, result.value)+      new_pos = result.pos+    end+    if #values > 0 then+      return {+        parsed = true,+        value = values,+        pos = new_pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.any = function(...)+  local parsers = { ... }+  return function(input, pos)+    for _, parser in ipairs(parsers) do+      local result = parser(input, pos)+      if result.parsed then+        return result+      end+    end+    return P.unmatch(pos)+  end+end++P.opt = function(parser)+  return function(input, pos)+    local result = parser(input, pos)+    return {+      parsed = true,+      value = result.value,+      pos = result.pos,+    }+  end+end++P.seq = function(...)+  local parsers = { ... }+  return function(input, pos)+    local values = {}+    local new_pos = pos+    for _, parser in ipairs(parsers) do+      local result = parser(input, new_pos)+      if result.parsed then+        table.insert(values, result.value)+        new_pos = result.pos+      else+        return P.unmatch(pos)+      end+    end+    return {+      parsed = true,+      value = values,+      pos = new_pos,+    }+  end+end++--@see https://code.visualstudio.com/docs/editor/userdefinedsnippets#_grammar+local S = {}+S.dollar = P.token('$')+S.open = P.token('{')+S.close = P.token('}')+S.colon = P.token(':')+S.slash = P.token('/')+S.comma = P.token(',')+S.pipe = P.token('|')+S.plus = P.token('+')+S.minus = P.token('-')+S.question = P.token('?')+S.int = P.map(P.pattern('[0-9]+'), function(value)+  return tonumber(value, 10)+end)+S.var = P.pattern('[%a_][%w_]+')+S.text = function(targets, specials)+  return P.map(P.take_until(targets, specials), function(value)+    return {+      type = 'text',+      raw = value.raw,+      esc = value.esc,+    }+  end)+end++S.toplevel = P.lazy(function()+  return P.any(S.placeholder, S.tabstop, S.variable, S.choice)+end)++S.format = P.any(+  P.map(P.seq(S.dollar, S.int), function(values)",Does it make sense to use LPEG or treesitter instead of a new DSL? (Edit: addressed by https://github.com/neovim/neovim/pull/15579#issuecomment-913807832 )We use LPEG in some legacy code:- https://github.com/neovim/neovim/blob/687a0b3d3e8878b6de058b02d84fbd1f78aa2e89/src/nvim/generators/gen_declarations.lua- https://github.com/neovim/neovim/blob/687a0b3d3e8878b6de058b02d84fbd1f78aa2e89/src/nvim/generators/c_grammar.lua,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15579,703054542,2021-09-06T19:48:04Z,runtime/lua/vim/lsp/snippet.lua,"@@ -0,0 +1,406 @@+local P = {}++---Take characters until the target characters (The escape sequence is '\' + char)+---@param targets string[] The character list for stop consuming text.+---@param specials string[] If the character isn't contained in targets/specials, '\' will be left.+P.take_until = function(targets, specials)+  targets = targets or {}+  specials = specials or {}++  return function(input, pos)+    local new_pos = pos+    local raw = {}+    local esc = {}+    while new_pos <= #input do+      local c = string.sub(input, new_pos, new_pos)+      if c == '\\' then+        table.insert(raw, '\\')+        new_pos = new_pos + 1+        c = string.sub(input, new_pos, new_pos)+        if not vim.tbl_contains(targets, c) and not vim.tbl_contains(specials, c) then+          table.insert(esc, '\\')+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      else+        if vim.tbl_contains(targets, c) then+          break+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      end+    end++    if new_pos == pos then+      return P.unmatch(pos)+    end++    return {+      parsed = true,+      value = {+        raw = table.concat(raw, ''),+        esc = table.concat(esc, '')+      },+      pos = new_pos,+    }+  end+end++P.unmatch = function(pos)+  return {+    parsed = false,+    value = nil,+    pos = pos,+  }+end++P.map = function(parser, map)+  return function(input, pos)+    local result = parser(input, pos)+    if result.parsed then+      return {+        parsed = true,+        value = map(result.value),+        pos = result.pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.lazy = function(factory)+  return function(input, pos)+    return factory()(input, pos)+  end+end++P.token = function(token)+  return function(input, pos)+    local maybe_token = string.sub(input, pos, pos + #token - 1)+    if token == maybe_token then+      return {+        parsed = true,+        value = maybe_token,+        pos = pos + #token,+      }+    end+    return P.unmatch(pos)+  end+end++P.pattern = function(p)+  return function(input, pos)+    local maybe_match = string.match(string.sub(input, pos), '^' .. p)+    if maybe_match then+      return {+        parsed = true,+        value = maybe_match,+        pos = pos + #maybe_match,+      }+    end+    return P.unmatch(pos)+  end+end++P.many = function(parser)+  return function(input, pos)+    local values = {}+    local new_pos = pos+    while new_pos <= #input do+      local result = parser(input, new_pos)+      if not result.parsed then+        break+      end+      table.insert(values, result.value)+      new_pos = result.pos+    end+    if #values > 0 then+      return {+        parsed = true,+        value = values,+        pos = new_pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.any = function(...)+  local parsers = { ... }+  return function(input, pos)+    for _, parser in ipairs(parsers) do+      local result = parser(input, pos)+      if result.parsed then+        return result+      end+    end+    return P.unmatch(pos)+  end+end++P.opt = function(parser)+  return function(input, pos)+    local result = parser(input, pos)+    return {+      parsed = true,+      value = result.value,+      pos = result.pos,+    }+  end+end++P.seq = function(...)+  local parsers = { ... }+  return function(input, pos)+    local values = {}+    local new_pos = pos+    for _, parser in ipairs(parsers) do+      local result = parser(input, new_pos)+      if result.parsed then+        table.insert(values, result.value)+        new_pos = result.pos+      else+        return P.unmatch(pos)+      end+    end+    return {+      parsed = true,+      value = values,+      pos = new_pos,+    }+  end+end++--@see https://code.visualstudio.com/docs/editor/userdefinedsnippets#_grammar+local S = {}+S.dollar = P.token('$')+S.open = P.token('{')+S.close = P.token('}')+S.colon = P.token(':')+S.slash = P.token('/')+S.comma = P.token(',')+S.pipe = P.token('|')+S.plus = P.token('+')+S.minus = P.token('-')+S.question = P.token('?')+S.int = P.map(P.pattern('[0-9]+'), function(value)+  return tonumber(value, 10)+end)+S.var = P.pattern('[%a_][%w_]+')+S.text = function(targets, specials)+  return P.map(P.take_until(targets, specials), function(value)+    return {+      type = 'text',+      raw = value.raw,+      esc = value.esc,+    }+  end)+end++S.toplevel = P.lazy(function()+  return P.any(S.placeholder, S.tabstop, S.variable, S.choice)+end)++S.format = P.any(+  P.map(P.seq(S.dollar, S.int), function(values)","(and for the sake of completeness: right now `lpeg` is a build dependency but not a runtime dependency; unless you build from source yourself, it's not bundled.)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15579,703055714,2021-09-06T19:53:01Z,runtime/lua/vim/lsp/snippet.lua,"@@ -0,0 +1,406 @@+local P = {}++---Take characters until the target characters (The escape sequence is '\' + char)+---@param targets string[] The character list for stop consuming text.+---@param specials string[] If the character isn't contained in targets/specials, '\' will be left.+P.take_until = function(targets, specials)+  targets = targets or {}+  specials = specials or {}++  return function(input, pos)+    local new_pos = pos+    local raw = {}+    local esc = {}+    while new_pos <= #input do+      local c = string.sub(input, new_pos, new_pos)+      if c == '\\' then+        table.insert(raw, '\\')+        new_pos = new_pos + 1+        c = string.sub(input, new_pos, new_pos)+        if not vim.tbl_contains(targets, c) and not vim.tbl_contains(specials, c) then+          table.insert(esc, '\\')+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      else+        if vim.tbl_contains(targets, c) then+          break+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      end+    end++    if new_pos == pos then+      return P.unmatch(pos)+    end++    return {+      parsed = true,+      value = {+        raw = table.concat(raw, ''),+        esc = table.concat(esc, '')+      },+      pos = new_pos,+    }+  end+end++P.unmatch = function(pos)+  return {+    parsed = false,+    value = nil,+    pos = pos,+  }+end++P.map = function(parser, map)+  return function(input, pos)+    local result = parser(input, pos)+    if result.parsed then+      return {+        parsed = true,+        value = map(result.value),+        pos = result.pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.lazy = function(factory)","I think we should keep the parser functional abstractions in the current file, because if we replace with lpeg as part of a `vim.snippet` those might be dead code anyways",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15579,703056099,2021-09-06T19:54:51Z,runtime/lua/vim/lsp/snippet.lua,"@@ -0,0 +1,406 @@+local P = {}++---Take characters until the target characters (The escape sequence is '\' + char)+---@param targets string[] The character list for stop consuming text.+---@param specials string[] If the character isn't contained in targets/specials, '\' will be left.+P.take_until = function(targets, specials)+  targets = targets or {}+  specials = specials or {}++  return function(input, pos)+    local new_pos = pos+    local raw = {}+    local esc = {}+    while new_pos <= #input do+      local c = string.sub(input, new_pos, new_pos)+      if c == '\\' then+        table.insert(raw, '\\')+        new_pos = new_pos + 1+        c = string.sub(input, new_pos, new_pos)+        if not vim.tbl_contains(targets, c) and not vim.tbl_contains(specials, c) then+          table.insert(esc, '\\')+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      else+        if vim.tbl_contains(targets, c) then+          break+        end+        table.insert(raw, c)+        table.insert(esc, c)+        new_pos = new_pos + 1+      end+    end++    if new_pos == pos then+      return P.unmatch(pos)+    end++    return {+      parsed = true,+      value = {+        raw = table.concat(raw, ''),+        esc = table.concat(esc, '')+      },+      pos = new_pos,+    }+  end+end++P.unmatch = function(pos)+  return {+    parsed = false,+    value = nil,+    pos = pos,+  }+end++P.map = function(parser, map)+  return function(input, pos)+    local result = parser(input, pos)+    if result.parsed then+      return {+        parsed = true,+        value = map(result.value),+        pos = result.pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.lazy = function(factory)+  return function(input, pos)+    return factory()(input, pos)+  end+end++P.token = function(token)+  return function(input, pos)+    local maybe_token = string.sub(input, pos, pos + #token - 1)+    if token == maybe_token then+      return {+        parsed = true,+        value = maybe_token,+        pos = pos + #token,+      }+    end+    return P.unmatch(pos)+  end+end++P.pattern = function(p)+  return function(input, pos)+    local maybe_match = string.match(string.sub(input, pos), '^' .. p)+    if maybe_match then+      return {+        parsed = true,+        value = maybe_match,+        pos = pos + #maybe_match,+      }+    end+    return P.unmatch(pos)+  end+end++P.many = function(parser)+  return function(input, pos)+    local values = {}+    local new_pos = pos+    while new_pos <= #input do+      local result = parser(input, new_pos)+      if not result.parsed then+        break+      end+      table.insert(values, result.value)+      new_pos = result.pos+    end+    if #values > 0 then+      return {+        parsed = true,+        value = values,+        pos = new_pos,+      }+    end+    return P.unmatch(pos)+  end+end++P.any = function(...)+  local parsers = { ... }+  return function(input, pos)+    for _, parser in ipairs(parsers) do+      local result = parser(input, pos)+      if result.parsed then+        return result+      end+    end+    return P.unmatch(pos)+  end+end++P.opt = function(parser)+  return function(input, pos)+    local result = parser(input, pos)+    return {+      parsed = true,+      value = result.value,+      pos = result.pos,+    }+  end+end++P.seq = function(...)+  local parsers = { ... }+  return function(input, pos)+    local values = {}+    local new_pos = pos+    for _, parser in ipairs(parsers) do+      local result = parser(input, new_pos)+      if result.parsed then+        table.insert(values, result.value)+        new_pos = result.pos+      else+        return P.unmatch(pos)+      end+    end+    return {+      parsed = true,+      value = values,+      pos = new_pos,+    }+  end+end++--@see https://code.visualstudio.com/docs/editor/userdefinedsnippets#_grammar+local S = {}+S.dollar = P.token('$')+S.open = P.token('{')+S.close = P.token('}')+S.colon = P.token(':')+S.slash = P.token('/')+S.comma = P.token(',')+S.pipe = P.token('|')+S.plus = P.token('+')+S.minus = P.token('-')+S.question = P.token('?')+S.int = P.map(P.pattern('[0-9]+'), function(value)+  return tonumber(value, 10)+end)+S.var = P.pattern('[%a_][%w_]+')+S.text = function(targets, specials)+  return P.map(P.take_until(targets, specials), function(value)+    return {+      type = 'text',+      raw = value.raw,+      esc = value.esc,+    }+  end)+end++S.toplevel = P.lazy(function()+  return P.any(S.placeholder, S.tabstop, S.variable, S.choice)+end)++S.format = P.any(+  P.map(P.seq(S.dollar, S.int), function(values)","> Another option could be to ""vendorize"" LPegLJ (or LuLPeg) If we're not modifying the source I'm not sure we should do this as it will anger the Debian gods",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15566,703069659,2021-09-06T21:02:10Z,src/nvim/mpack/LICENSE-MIT,"@@ -0,0 +1,22 @@+Copyright (c) 2016 Thiago de Arruda","should this go in `src/mpack` ? In https://github.com/neovim/neovim/issues/11239 we plan to move xdiff to `src/xdiff/` . Rationale: 1. signals that we don't ""own"" this library2. thereby leaves the door open for un-vendoring it in the future?3. adds clarity to cmake logic, analyzers, etc.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15259,703887498,2021-09-07T22:10:09Z,runtime/autoload/health.vim,"@@ -147,31 +147,36 @@ function! health#report_error(msg, ...) abort "" {{{   endif endfunction "" }}} -function! s:filepath_to_function(name) abort-  return substitute(substitute(substitute(a:name, '.*autoload[\/]', '', ''),-        \ '\.vim', '#check', ''), '[\/]', '#', 'g')+"" From a filepath translate to checkhealth+function! s:filepath_to_health_check(path) abort+  let name =  matchstr(a:path, '\zs[^\/]*\ze\.\(vim\|lua\)$')+  let c = (a:path =~# 'vim$') +              \? 'health#'.name.'#check'+              \ : substitute(a:path, '.*lua[\/]\([^\.]*\).lua$',+                  \ 'v:lua.require(""\1"").check', '')+  return [name, c] endfunction  function! s:discover_health_checks() abort-  let healthchecks = globpath(&runtimepath, 'autoload/health/*.vim', 1, 1)-  let healthchecks = map(healthchecks, '<SID>filepath_to_function(v:val)')-  return healthchecks+  return s:get_health_check('*') endfunction -"" Translates a list of plugin names to healthcheck function names.-function! s:to_fn_names(plugin_names) abort+"" return checkhealts ['name', 'func'], 'func' is empty '' if not found","```suggestion"" Return a list of [{name}, {func}] pairs. {func} is an empty string if the plugin is not found.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15595,703973830,2021-09-08T02:17:07Z,runtime/lua/vim/lsp/log.lua,"@@ -32,6 +32,17 @@ do    vim.fn.mkdir(vim.fn.stdpath('cache'), ""p"")   local logfile = assert(io.open(logfilename, ""a+""))++	local log_info = vim.loop.fs_stat(logfilename)+	if log_info and log_info.size > 1e9 then+		local warn_msg = string.format(+			""Language server client log at %s has reached %d KB in size"",+			logfilename,+			log_info.size / 1000","- if the variable part of a message must go in the middle of a message, try to put the longest part (filename in this case) at the end. - this message only matters for very large files. They are always going to be MB or GB, so KB is not a user-friendly unit.```suggestion			""LSP client log is big (%d MB): %s"",			log_info.size / (1000 * 1000),			logfilename,```",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15595,703987737,2021-09-08T02:59:05Z,runtime/lua/vim/lsp/log.lua,"@@ -32,6 +32,17 @@ do    vim.fn.mkdir(vim.fn.stdpath('cache'), ""p"")   local logfile = assert(io.open(logfilename, ""a+""))++	local log_info = vim.loop.fs_stat(logfilename)+	if log_info and log_info.size > 1e9 then+		local warn_msg = string.format(+			""Language server client log at %s has reached %d KB in size"",+			logfilename,+			log_info.size / 1000+		)+		vim.notify(warn_msg)+	end","The runtime check? I just don't like adding things that are done automatically during the startup process. It's just an fstat, so probably not a big deal.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15595,703994223,2021-09-08T03:19:45Z,runtime/lua/vim/lsp/log.lua,"@@ -32,6 +32,17 @@ do    vim.fn.mkdir(vim.fn.stdpath('cache'), ""p"")   local logfile = assert(io.open(logfilename, ""a+""))++	local log_info = vim.loop.fs_stat(logfilename)+	if log_info and log_info.size > 1e9 then+		local warn_msg = string.format(+			""Language server client log at %s has reached %d KB in size"",+			logfilename,+			log_info.size / 1000+		)+		vim.notify(warn_msg)+	end","definitely a good instinct, but this seems important enough (potentially catastrophic) to warrant some sort of active check. Doing it on (lazy) startup is a one-time cost so not too bad.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15595,704014179,2021-09-08T04:23:13Z,runtime/lua/vim/lsp/log.lua,"@@ -32,6 +32,17 @@ do    vim.fn.mkdir(vim.fn.stdpath('cache'), ""p"")   local logfile = assert(io.open(logfilename, ""a+""))++	local log_info = vim.loop.fs_stat(logfilename)+	if log_info and log_info.size > 1e9 then+		local warn_msg = string.format(+			""LSP client log is large (%d MB): %s"",+			log_info.size / (1000 * 1000),","Oh, I thought it was the indentation for which I accepted your GH edit, my bad. I'll fix.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15514,704122334,2021-09-08T07:21:57Z,runtime/lua/vim/lsp/buf.lua,"@@ -249,13 +249,34 @@ end ---@param new_name (string) If not provided, the user will be prompted for a new ---name using |input()|. function M.rename(new_name)-  -- TODO(ashkan) use prepareRename-  -- * result: [`Range`](#range) \| `{ range: Range, placeholder: string }` \| `null` describing the range of the string to rename and optionally a placeholder text of the string content to be renamed. If `null` is returned then it is deemed that a 'textDocument/rename' request is not valid at the given position.   local params = util.make_position_params()-  new_name = new_name or npcall(vfn.input, ""New Name: "", vfn.expand('<cword>'))-  if not (new_name and #new_name > 0) then return end-  params.newName = new_name-  request('textDocument/rename', params)+  local function prepare_rename(err, result)+    if err == nil and result == nil then+      print('nothing to rename')+      return+    end+    if result ~= nil and result.placeholder then+      new_name = new_name or npcall(vfn.input, ""New Name: "", result.placeholder)+    elseif result ~= nil and result.start and result['end'] and+      result.start.line == result['end'].line then+      local line = vfn.getline(result.start.line+1)","Might be better to use nvim_buf_get_lines instead of calling via vimscript, not a big deal though, we're already calling vfn.input.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15601,704602413,2021-09-08T16:51:55Z,Makefile,"@@ -190,6 +190,13 @@ clint: build/.ran-cmake clint-full: build/.ran-cmake 	+$(BUILD_CMD) -C build clint-full +clang-tidy: generate-compilation-db+	bash scripts/run_clang_tidy.sh $(FILE)","is the run_clang_tidy.sh script really needed? it's not a pattern we usually follow. Better not to spread things out if possible, also keeps the Makefile more portable (e.g. on Windows)",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,704631219,2021-09-08T17:30:41Z,Makefile,"@@ -190,6 +190,13 @@ clint: build/.ran-cmake clint-full: build/.ran-cmake 	+$(BUILD_CMD) -C build clint-full +clang-tidy: generate-compilation-db+	bash scripts/run_clang_tidy.sh $(FILE)","Only if you want a way to run it per-file from the CLI. If you're running `clangd` then it can also manage `clang-tidy` for you and dynamically display any warnings and code-actions through LSP.Alternatively, we can introduce another target called  `clang-tidy-file` or something, which would allow us to skip validating the variable inside make.I didn't want to do conditional run from inside make, because that would get hacky very quickly: https://stackoverflow.com/a/45003119",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,704638957,2021-09-08T17:41:12Z,Makefile,"@@ -190,6 +190,13 @@ clint: build/.ran-cmake clint-full: build/.ran-cmake 	+$(BUILD_CMD) -C build clint-full +clang-tidy: generate-compilation-db+	bash scripts/run_clang_tidy.sh $(FILE)++generate-compilation-db: build/.ran-cmake+	ninja -C build -t compdb C_COMPILER__nvim_$(CMAKE_BUILD_TYPE) > build/compile_commands.json	+	ln -sf build/compile_commands.json .","Yeah, it's the same one I mentioned in #10632This is essential if we want to run this in the CI and not have it analyze third-party and other non-essential files. Let me know if you feel that it's missing some files. You can verify the list quickly with `jq`.```bash# you can change the filter or drop it all togethercat compile_commands.json | jq -c '.[] | select( .file | contains(""src""))' | wc -l```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,705439687,2021-09-09T15:09:01Z,Makefile,"@@ -190,6 +190,13 @@ clint: build/.ran-cmake clint-full: build/.ran-cmake 	+$(BUILD_CMD) -C build clint-full +clang-tidy: generate-compilation-db+	bash scripts/run_clang_tidy.sh $(FILE)++generate-compilation-db: build/.ran-cmake+	ninja -C build -t compdb C_COMPILER__nvim_$(CMAKE_BUILD_TYPE) > build/compile_commands.json	+	ln -sf build/compile_commands.json .","My bad, I didn't notice it. It's just the standard way to let the other tools find it without hard-coding the build path. I wanted to use $(BUILD_DIR) but it's not defined.```makeln -sf $(BUILD_DIR)/compile_commands.json .```There are a few ways for cmake to use it:1) your typical ```shellcd $BUILD_DIR && cmake .. ```2) by setting the `CMAKE_BINARY_DIR=..` variable2) my favorite, but I believe it's relatively new so I need to check which is the oldest supported cmake version```shellcmake -B $BUILD_DIR```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15566,705441191,2021-09-09T15:10:31Z,runtime/doc/lua.txt,"@@ -686,6 +686,19 @@ vim.diff({a}, {b}, {opts})                                        *vim.diff()*                 Return: ~                     See {opts.result_type}. nil if {opts.on_hunk} is given. +------------------------------------------------------------------------------+VIM.MPACK                                                          *lua-mpack*++The *vim.mpack* module provides packing and unpacking of lua objects to+msgpack encoded strings. |vim.NIL| and |vim.empty_dict()| are supported.++vim.mpack.pack({obj})					*vim.mpack.pack*","No it's not, I suspect msgpack libs always use ""pack"" and ""unpack"" as it rhymes with ""msgpack"". I don't think `from_lua` and `to_lua` makes sense as (1) lua is implied by the context of lua code (2) later we need the nouns such as the Packer and the Unpacker, where the Encoder/Decoder works if there's a strong preference to change it to that, though my honest opinion would be to err at the side of lazyness and keep the msgpack conventions.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15566,705452609,2021-09-09T15:22:44Z,runtime/doc/lua.txt,"@@ -686,6 +686,19 @@ vim.diff({a}, {b}, {opts})                                        *vim.diff()*                 Return: ~                     See {opts.result_type}. nil if {opts.on_hunk} is given. +------------------------------------------------------------------------------+VIM.MPACK                                                          *lua-mpack*++The *vim.mpack* module provides packing and unpacking of lua objects to+msgpack encoded strings. |vim.NIL| and |vim.empty_dict()| are supported.++vim.mpack.pack({obj})					*vim.mpack.pack*","> where the Encoder/Decoder works if there's a strong preference to change it to that, though my honest opinion would be to err at the side of lazyness and keep the msgpack conventions.if you just want to avoid the chore, I am willing to do it :) Consistency (in the scope of our system) helps users a lot.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15259,705487246,2021-09-09T16:01:53Z,runtime/autoload/health.vim,"@@ -43,19 +43,23 @@ function! health#check(plugin_names) abort     redraw|echo 'Running healthchecks...'     for c in healthchecks       let output = ''-      call append('$', split(printf(""\n%s\n%s"", c, repeat('=',72)), ""\n""))+      let disp = c[2] != '' ? c[2] : c[1]+      call append('$', split(printf(""\n%s: %s\n%s"", c[0], disp, repeat('=',72)), ""\n""))       try-        let output = ""\n\n"".execute('call '.c.'()')+        let output = ""\n\n"".execute('call '.c[1].'()')+        if output =~# 'HEALTHCHECK_ERROR:'+          throw matchlist(output, 'HEALTHCHECK_ERROR:\(.*$\)')[1]","I refactored health.vim to use variable scope, now every report function instead of echoing the formatted parameters appends to an `output` list. So now in the lua side things are cleaner, the report functions are wrapped to look nicer. Let me know what you think @justinmk .",X
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15259,705490493,2021-09-09T16:06:17Z,runtime/autoload/health.vim,"@@ -119,59 +125,68 @@ endfunction "" }}}  "" Use {msg} to report information in the current section function! health#report_info(msg) abort "" {{{-  echo s:format_report_message('INFO', a:msg)+  call health#output(s:format_report_message('INFO', a:msg)) endfunction "" }}}  "" Reports a successful healthcheck. function! health#report_ok(msg) abort "" {{{-  echo s:format_report_message('OK', a:msg)+  call health#output(s:format_report_message('OK', a:msg)) endfunction "" }}}  "" Reports a health warning. "" a:1: Optional advice (string or list) function! health#report_warn(msg, ...) abort "" {{{   if a:0 > 0-    echo s:format_report_message('WARNING', a:msg, a:1)+    call health#output(s:format_report_message('WARNING', a:msg, a:1))   else-    echo s:format_report_message('WARNING', a:msg)+    call health#output(s:format_report_message('WARNING', a:msg))   endif endfunction "" }}}  "" Reports a failed healthcheck. "" a:1: Optional advice (string or list) function! health#report_error(msg, ...) abort "" {{{   if a:0 > 0-    echo s:format_report_message('ERROR', a:msg, a:1)+    call health#output(s:format_report_message('ERROR', a:msg, a:1))   else-    echo s:format_report_message('ERROR', a:msg)+    call health#output(s:format_report_message('ERROR', a:msg))   endif endfunction "" }}} -function! s:filepath_to_function(name) abort-  return substitute(substitute(substitute(a:name, '.*autoload[\/]', '', ''),-        \ '\.vim', '#check', ''), '[\/]', '#', 'g')+"" From a filepath translate to checkhealth+function! s:filepath_to_healthcheck(path) abort+  let name =  matchstr(a:path, '\zs[^\/]*\ze\.\(vim\|lua\)$')+  if a:path =~# 'vim$' +    let call = 'health#'.name.'#check'+    let type = 'v'+  else+   let call = substitute(substitute(a:path, '.*lua[\/]\([^.]*\)\.lua$',+                  \ 'require(""\1"").check()', ''), '[\/]', '.', 'g')+   let type = 'l'+ endif+  return [name, call, type] endfunction -function! s:discover_health_checks() abort-  let healthchecks = globpath(&runtimepath, 'autoload/health/*.vim', 1, 1)-  let healthchecks = map(healthchecks, '<SID>filepath_to_function(v:val)')-  return healthchecks+function! s:discover_healthchecks() abort+  return s:get_healthcheck('*') endfunction -"" Translates a list of plugin names to healthcheck function names.-function! s:to_fn_names(plugin_names) abort+"" Return a list of [{name}, {callable}, {display_name}].","```suggestion"" Return a list of [{name}, {callable}, {type}].```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15611,705522897,2021-09-09T16:48:17Z,test/functional/core/channels_spec.lua,"@@ -90,10 +90,28 @@ describe('channels', function()     eq({""notification"", ""stdout"", {id, {""[1, ['howdy'], 'stdin']""}}}, next_msg())      command(""call chanclose(id, 'stdin')"")-    expect_twostreams({{""notification"", ""stdout"", {id, {""[1, [''], 'stdin']""}}},-                       {'notification', 'stdout', {id, {''}}}},-                      {{""notification"", ""stderr"", {id, {""*dies*""}}},-                       {'notification', 'stderr', {id, {''}}}})+    expect_msg_seq(+      { {""notification"", ""stdout"", {id, {""[1, [''], 'stdin']""}}},+        {'notification', 'stdout', {id, {''}}},+        {""notification"", ""stderr"", {id, {""*dies*""}}},+        {'notification', 'stderr', {id, {''}}},+      },+      { {""notification"", ""stdout"", {id, {""[1, [''], 'stdin']""}}},+        {'notification', 'stdout', {id, {''}}},+        {'notification', 'stderr', {id, {''}}},+        {""notification"", ""stderr"", {id, {""*dies*""}}},",This manually-specified permutation list is annoying and verbose. Might try to do this programmatically.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15614,705762763,2021-09-09T22:48:24Z,scripts/gen_vimdoc.py,"@@ -197,8 +203,8 @@             'query.lua',             'highlighter.lua',             'languagetree.lua',-            'health.lua',         ],+        'ignored_sections': ['health.lua'],","instead of this, doxygen supports `EXCLUDE_PATTERNS`  https://github.com/neovim/neovim/blob/80a75fc81560269e5d36824ea1c1e328140f82c9/scripts/gen_vimdoc.py#L1142maybe it works to add a `exclude_pattern` field similar to `file_patterns`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,705768332,2021-09-09T22:54:21Z,runtime/doc/lsp.txt,"@@ -1647,13 +1700,17 @@ show_line_diagnostics({opts}, {buf_nr}, {line_nr}, {client_id}) show_position_diagnostics({opts}, {buf_nr}, {position})                 Open a floating window with the diagnostics from {position} +                Deprecated in favor of+                |vim.diagnostic.show_position_diagnostics()|","1. move the helptags for all of these to `runtime/doc/deprecated.txt`    - in there, only need to move the new replacement, don't need to have full docs2. don't generate these docs (delete them from lsp.txt). No need for redundant docs.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,705832417,2021-09-10T01:39:28Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -453,7 +427,7 @@ end  --- Set underline for given diagnostics ------- Deprecated in favor of |vim.diagnostic.set_underline()|+---@deprecated Prefer |vim.diagnostic.set_underline()|","helps a lot to move the functions to a separate `lsp/_deprecated.lua` file, if possible.  Avoids noise and avoids confused contributors.This `lsp.diagnostic` module can load the `lsp._deprecated` and merge it with its own module, for back-compat. We do something similar in the test infra: https://github.com/neovim/neovim/blob/13748512f6d6dfb5895c2233d2e07480e00eb753/test/unit/helpers.lua#L865-L868",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15236,706175696,2021-09-10T13:20:58Z,runtime/lua/vim/shared.lua,"@@ -267,18 +267,23 @@ function vim.tbl_deep_extend(behavior, ...) end  --- Deep compare values for equality+---+--- Tables are compared recursively unless they both provide the `eq` methamethod.",weird that we named this `deep_equal` instead of `eq_foo` or `foo_eq` for parallel with Lua's convention,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,706298417,2021-09-10T16:00:54Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -453,7 +427,7 @@ end  --- Set underline for given diagnostics ------- Deprecated in favor of |vim.diagnostic.set_underline()|+---@deprecated Prefer |vim.diagnostic.set_underline()|","I'll push back on this a little bit: there are some local functions we use in `lsp/diagnostic.lua` to do the translation between LSP style data structures and `vim.diagnostic` data structures. If we split up that module, we either have to 1) duplicate those functions in both modules or 2) expose those local functions as part of the public interface. Both options are icky and I don't think worth the benefit of having a dedicated `_deprecated.lua` module.Instead, what if we just tuck all the deprecated functions down at the bottom and throw in a ""Deprecated"" header and fold markers.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15627,706393299,2021-09-10T18:38:46Z,src/nvim/syntax.c,"@@ -1571,36 +1622,33 @@ syn_finish_line(   return false; } -/*- * Return highlight attributes for next character.- * Must first call syntax_start() once for the line.- * ""col"" is normally 0 for the first use in a line, and increments by one each- * time.  It's allowed to skip characters and to stop before the end of the- * line.  But only a ""col"" after a previously used column is allowed.- * When ""can_spell"" is not NULL set it to TRUE when spell-checking should be- * done.- */-int-get_syntax_attr(-    const colnr_T col,-    bool *const can_spell,-    const bool keep_state           // keep state of char at ""col""-)+/// @return  highlight attributes for next character.",looks like a bad search-replace. Would change to: ```suggestion/// Gets highlight attributes for next character.```and maybe also add `@return` blurb at the end,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15585,706591755,2021-09-11T09:54:15Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,616 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++							*diagnostic-highlights*+All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding DiagnosticDefault highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is+linked to |hl-DiagnosticDefaultError|. To change the default (and+therefore the linked highlights), use the |:highlight| command: >++    highlight DiagnosticDefaultError guifg=""BrightRed""+<+						*hl-DiagnosticDefaultError*+DiagnosticDefaultError+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultWarn*+DiagnosticDefaultWarn+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultInfo*+DiagnosticDefaultInfo+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultHint*+DiagnosticDefaultHint+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++					*hl-DiagnosticVirtualTextError*+DiagnosticVirtualTextError+  Used for ""Error"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++					*hl-DiagnosticVirtualTextWarn*+DiagnosticVirtualTextWarn+  Used for ""Warn"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticVirtualTextInfo*+DiagnosticVirtualTextInfo+  Used for ""Info"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticVirtualTextHint*+DiagnosticVirtualTextHint+  Used for ""Hint"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticUnderlineError*+DiagnosticUnderlineError+  Used to underline ""Error"" diagnostics.+  See |vim.diagnostic.set_underline()|","similarly this reference doesn't seem useful, there is no info at `vim.diagnostic.set_underline()` what this means anyway, and similarlily for the `|vim.diagnostic.set_virtual_text()|` refs above. The _user-facing_ semantics of all of this is already documented at `*diagnostic-highlights*` right above.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15585,706593817,2021-09-11T10:15:36Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,616 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++							*diagnostic-highlights*+All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding DiagnosticDefault highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is+linked to |hl-DiagnosticDefaultError|. To change the default (and+therefore the linked highlights), use the |:highlight| command: >++    highlight DiagnosticDefaultError guifg=""BrightRed""+<+						*hl-DiagnosticDefaultError*+DiagnosticDefaultError+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultWarn*+DiagnosticDefaultWarn+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultInfo*+DiagnosticDefaultInfo+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultHint*+DiagnosticDefaultHint+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++					*hl-DiagnosticVirtualTextError*+DiagnosticVirtualTextError+  Used for ""Error"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++					*hl-DiagnosticVirtualTextWarn*+DiagnosticVirtualTextWarn+  Used for ""Warn"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticVirtualTextInfo*+DiagnosticVirtualTextInfo+  Used for ""Info"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticVirtualTextHint*+DiagnosticVirtualTextHint+  Used for ""Hint"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticUnderlineError*+DiagnosticUnderlineError+  Used to underline ""Error"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticUnderlineWarn*+DiagnosticUnderlineWarn+  Used to underline ""Warn"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticUnderlineInfo*+DiagnosticUnderlineInfo+  Used to underline ""Info"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticUnderlineHint*+DiagnosticUnderlineHint+  Used to underline ""Hint"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticFloatingError*+DiagnosticFloatingError+  Used to color ""Error"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingWarn*+DiagnosticFloatingWarn+  Used to color ""Warn"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingInfo*+DiagnosticFloatingInfo+  Used to color ""Info"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingHint*+DiagnosticFloatingHint+  Used to color ""Hint"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticSignError*+DiagnosticSignError+  Used for ""Error"" signs in sign column.+  See |vim.diagnostic.set_signs()|++						*hl-DiagnosticSignWarn*+DiagnosticSignWarn+  Used for ""Warn"" signs in sign column.+  See |vim.diagnostic.set_signs()|++						*hl-DiagnosticSignInfo*+DiagnosticSignInfo+  Used for ""Info"" signs in sign column.+  See |vim.diagnostic.set_signs()|++						*hl-DiagnosticSignHint*+DiagnosticSignHint+  Used for ""Hint"" signs in sign column.+  See |vim.diagnostic.set_signs()|++==============================================================================+Events							*diagnostic-events*++							*DiagnosticsChanged*+DiagnosticsChanged	After diagnostics have changed in a loaded buffer.++Example: >+	autocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })+<++==============================================================================+Lua module: vim.diagnostic                                    *diagnostic-api*++clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*+                Clear the currently displayed diagnostics.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Clear diagnostics in the given+                                 buffer. If omitted, diagnostics for the given+                                 namespace are cleared in all buffers.++config({opts}, {namespace})                          *vim.diagnostic.config()*+                Configure diagnostic options globally or for a specific+                diagnostic namespace.++                Note:+                    Each of the configuration options below accepts one of the+                    following:- `false`: Disable this feature - `true`: Enable this+                    feature, use default settings. - `table`: Enable this+                    feature with overrides. - `function`: Function with+                    signature (namespace, bufnr) that returns any of the+                    above.++                Parameters: ~+                    {opts}       table Configuration table with the following+                                 keys:+                                 ��� underline: (default true) Use underline for+                                   diagnostics+                                   |vim.diagnostic.set_underline()|+                                 ��� virtual_text: (default true) Use virtual+                                   text for diagnostics+                                   |vim.diagnostic.set_virtual_text()|+                                 ��� signs: (default true) Use signs for+                                   diagnostics |vim.diagnostic.set_signs()|+                                 ��� update_in_insert: (default false) Update+                                   diagnostics in Insert mode (if false,+                                   diagnostics are updated on InsertLeave)+                                 ��� severity_sort: (default false) Sort+                                   diagnostics by severity. This affects the+                                   order in which signs and virtual text are+                                   displayed+                    {namespace}  number|nil Update the options for the given+                                 namespace. When omitted, update the global+                                 diagnostic options.++disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*+                Disable diagnostics for the given namespace and buffer.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Buffer handle. If omitted, disable+                                 diagnostics for all buffers in the given+                                 namespace++enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*+                Enable diagnostics for the given namespace and buffer.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Buffer handle. If omitted, eanble+                                 diagnostics for all buffers in the given+                                 namespace++get({namespace}, {bufnr})                               *vim.diagnostic.get()*+                Get all diagnostics for the given namespace or buffer.++                With no arguments, return a list of all diagnostics.++                If {namespace} is `nil` , retrieve all diagnostics associated+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all+                diagnostics associated with namespace {namespace}. Otherwise,+                retrieve diagnostics from namespace {namespace} associated+                with buffer {bufnr}.++                Parameters: ~+                    {namespace}  number|nil The namespace to get diagnostics+                                 from. If omitted, get diagnostics from all+                                 namespaces. be `nil` only when {bufnr} is not+                                 `nil` .+                    {bufnr}      number|nil The buffer number to get+                                 diagnistics from. If omitted, get diagnostics+                                 from all buffers.++                Return: ~+                    table A list of diagnostic items |diagnostic-structure|.++                                                  *vim.diagnostic.get_count()*+get_count({namespace}, {bufnr}, {severity})+                Get the number of diagnostics with the given severity.++                Useful for showing diagnostic counts in statusline. eg: >++                 function! DiagnosticStatus() abort+                   let sl = ''+                   let sl .= 'E: %{luaeval(""vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)"")} '+                   let sl .= 'W: %{luaeval(""vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)"")}'+                   return sl+                 endfunction+<++                Then simply add `%{DiagnosticStatus()}` to your statusline.++                Parameters: ~+                    {namespace}     number|nil Limit diagnostics to the given+                                    namespace. If `nil` , retrieve diagnostics+                                    from all namespaces.+                    {bufnr}         number|nil The buffer number. Defaults to+                                    the current buffer.+                    {severity|nil}  Return diagnostics for the given severity+                                    |vim.diagnostic.severity|. If omitted, all+                                    diagnositcs are returned.++                                       *vim.diagnostic.get_line_diagnostics()*+get_line_diagnostics({bufnr}, {lnum}, {opts})+                Get diagnostics by line.++                Parameters: ~+                    {namespace}  number|nil Limit diagnostics to the given+                                 namespace. If `nil` , retrieve diagnostics+                                 from all namespaces.+                    {bufnr}      number|nil The buffer number. Defaults to the+                                 current buffer.+                    {lnum}       number|nil The line number. Defaults to the+                                 current line.+                    {opts}       table|nil A table with the following keys:+                                 ��� namespace: (number) Limit diagnostics to+                                   the given namespace.+                                 ��� severity: (|vim.diagnostic.severity|) Only+                                   return diagnostics with this severity.","And while we're at naming, I can't help but add my *ceterum censeo* that the inconsistent use of `diagnostic` and `diagnostics` is a mild but constant irritation...If we do make a breaking change to the API (even with a compatibility layer to make it transparent), I'd love to take the opportunity to standardize on `vim.diagnostic**s**` everywhere!",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15585,706599902,2021-09-11T11:13:28Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,616 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++							*diagnostic-highlights*+All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding DiagnosticDefault highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is+linked to |hl-DiagnosticDefaultError|. To change the default (and+therefore the linked highlights), use the |:highlight| command: >++    highlight DiagnosticDefaultError guifg=""BrightRed""+<+						*hl-DiagnosticDefaultError*+DiagnosticDefaultError+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultWarn*+DiagnosticDefaultWarn+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultInfo*+DiagnosticDefaultInfo+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultHint*+DiagnosticDefaultHint+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++					*hl-DiagnosticVirtualTextError*+DiagnosticVirtualTextError+  Used for ""Error"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++					*hl-DiagnosticVirtualTextWarn*+DiagnosticVirtualTextWarn+  Used for ""Warn"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticVirtualTextInfo*+DiagnosticVirtualTextInfo+  Used for ""Info"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticVirtualTextHint*+DiagnosticVirtualTextHint+  Used for ""Hint"" diagnostic virtual text.+  See |vim.diagnostic.set_virtual_text()|++						*hl-DiagnosticUnderlineError*+DiagnosticUnderlineError+  Used to underline ""Error"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticUnderlineWarn*+DiagnosticUnderlineWarn+  Used to underline ""Warn"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticUnderlineInfo*+DiagnosticUnderlineInfo+  Used to underline ""Info"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticUnderlineHint*+DiagnosticUnderlineHint+  Used to underline ""Hint"" diagnostics.+  See |vim.diagnostic.set_underline()|++						*hl-DiagnosticFloatingError*+DiagnosticFloatingError+  Used to color ""Error"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingWarn*+DiagnosticFloatingWarn+  Used to color ""Warn"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingInfo*+DiagnosticFloatingInfo+  Used to color ""Info"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingHint*+DiagnosticFloatingHint+  Used to color ""Hint"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticSignError*+DiagnosticSignError+  Used for ""Error"" signs in sign column.+  See |vim.diagnostic.set_signs()|++						*hl-DiagnosticSignWarn*+DiagnosticSignWarn+  Used for ""Warn"" signs in sign column.+  See |vim.diagnostic.set_signs()|++						*hl-DiagnosticSignInfo*+DiagnosticSignInfo+  Used for ""Info"" signs in sign column.+  See |vim.diagnostic.set_signs()|++						*hl-DiagnosticSignHint*+DiagnosticSignHint+  Used for ""Hint"" signs in sign column.+  See |vim.diagnostic.set_signs()|++==============================================================================+Events							*diagnostic-events*++							*DiagnosticsChanged*+DiagnosticsChanged	After diagnostics have changed in a loaded buffer.++Example: >+	autocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })+<++==============================================================================+Lua module: vim.diagnostic                                    *diagnostic-api*++clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*+                Clear the currently displayed diagnostics.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Clear diagnostics in the given+                                 buffer. If omitted, diagnostics for the given+                                 namespace are cleared in all buffers.++config({opts}, {namespace})                          *vim.diagnostic.config()*+                Configure diagnostic options globally or for a specific+                diagnostic namespace.++                Note:+                    Each of the configuration options below accepts one of the+                    following:- `false`: Disable this feature - `true`: Enable this+                    feature, use default settings. - `table`: Enable this+                    feature with overrides. - `function`: Function with+                    signature (namespace, bufnr) that returns any of the+                    above.++                Parameters: ~+                    {opts}       table Configuration table with the following+                                 keys:+                                 ��� underline: (default true) Use underline for+                                   diagnostics+                                   |vim.diagnostic.set_underline()|+                                 ��� virtual_text: (default true) Use virtual+                                   text for diagnostics+                                   |vim.diagnostic.set_virtual_text()|+                                 ��� signs: (default true) Use signs for+                                   diagnostics |vim.diagnostic.set_signs()|+                                 ��� update_in_insert: (default false) Update+                                   diagnostics in Insert mode (if false,+                                   diagnostics are updated on InsertLeave)+                                 ��� severity_sort: (default false) Sort+                                   diagnostics by severity. This affects the+                                   order in which signs and virtual text are+                                   displayed+                    {namespace}  number|nil Update the options for the given+                                 namespace. When omitted, update the global+                                 diagnostic options.++disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*+                Disable diagnostics for the given namespace and buffer.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Buffer handle. If omitted, disable+                                 diagnostics for all buffers in the given+                                 namespace++enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*+                Enable diagnostics for the given namespace and buffer.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Buffer handle. If omitted, eanble+                                 diagnostics for all buffers in the given+                                 namespace++get({namespace}, {bufnr})                               *vim.diagnostic.get()*+                Get all diagnostics for the given namespace or buffer.++                With no arguments, return a list of all diagnostics.++                If {namespace} is `nil` , retrieve all diagnostics associated+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all+                diagnostics associated with namespace {namespace}. Otherwise,+                retrieve diagnostics from namespace {namespace} associated+                with buffer {bufnr}.++                Parameters: ~+                    {namespace}  number|nil The namespace to get diagnostics+                                 from. If omitted, get diagnostics from all+                                 namespaces. be `nil` only when {bufnr} is not+                                 `nil` .+                    {bufnr}      number|nil The buffer number to get+                                 diagnistics from. If omitted, get diagnostics+                                 from all buffers.++                Return: ~+                    table A list of diagnostic items |diagnostic-structure|.++                                                  *vim.diagnostic.get_count()*+get_count({namespace}, {bufnr}, {severity})+                Get the number of diagnostics with the given severity.++                Useful for showing diagnostic counts in statusline. eg: >++                 function! DiagnosticStatus() abort+                   let sl = ''+                   let sl .= 'E: %{luaeval(""vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)"")} '+                   let sl .= 'W: %{luaeval(""vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)"")}'+                   return sl+                 endfunction+<++                Then simply add `%{DiagnosticStatus()}` to your statusline.++                Parameters: ~+                    {namespace}     number|nil Limit diagnostics to the given+                                    namespace. If `nil` , retrieve diagnostics+                                    from all namespaces.+                    {bufnr}         number|nil The buffer number. Defaults to+                                    the current buffer.+                    {severity|nil}  Return diagnostics for the given severity+                                    |vim.diagnostic.severity|. If omitted, all+                                    diagnositcs are returned.++                                       *vim.diagnostic.get_line_diagnostics()*+get_line_diagnostics({bufnr}, {lnum}, {opts})+                Get diagnostics by line.++                Parameters: ~+                    {namespace}  number|nil Limit diagnostics to the given+                                 namespace. If `nil` , retrieve diagnostics+                                 from all namespaces.+                    {bufnr}      number|nil The buffer number. Defaults to the+                                 current buffer.+                    {lnum}       number|nil The line number. Defaults to the+                                 current line.+                    {opts}       table|nil A table with the following keys:+                                 ��� namespace: (number) Limit diagnostics to+                                   the given namespace.+                                 ��� severity: (|vim.diagnostic.severity|) Only+                                   return diagnostics with this severity.","As promoting this to _top level_ core API will substantially increase the direct usage of this API among plugins and users (as opposed to indirectly by activating a LSP config), I do think it is worthwhile to do some polish at the API at the same time, even if this implies a breaking change for some existing usages (no opinion either way on a compat layer)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15585,706609075,2021-09-11T12:46:03Z,runtime/lua/vim/diagnostic.lua,"@@ -0,0 +1,1377 @@+local M = {}++M.severity = {+  ERROR = 1,+  WARN = 2,+  INFO = 3,+  HINT = 4,+}++vim.tbl_add_reverse_lookup(M.severity)++local global_diagnostic_options = {+  signs = true,+  underline = true,+  virtual_text = true,+  update_in_insert = false,+  severity_sort = false,+}++-- Local functions {{{++---@private+local function to_severity(severity)+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity+end++---@private+local function filter_to_severity_limit(severity, diagnostics)+  local filter_level = to_severity(severity)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)+end++---@private+local function filter_by_severity_limit(severity_limit, diagnostics)+  local filter_level = to_severity(severity_limit)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)+end++---@private+local function valid_severity()+  return function(severity)+    if type(severity) == 'string' then+      return to_severity(severity) ~= nil+    elseif type(severity) == 'number' then+      return M.severity[severity] ~= nil+    end+  end, ""Invalid value for 'severity' parameter""+end++---@private+local function resolve_optional_value(option, namespace, bufnr)+  local enabled_val = {}++  if not option then+    return false+  elseif option == true then+    return enabled_val+  elseif type(option) == 'function' then+    local val = option(namespace, bufnr)+    if val == true then+      return enabled_val+    else+      return val+    end+  elseif type(option) == 'table' then+    return option+  else+    error(""Unexpected option type: "" .. vim.inspect(option))+  end+end++local all_namespaces = {}++---@private+local function get_namespace(ns)+  if not all_namespaces[ns] then+    local name+    for k, v in pairs(vim.api.nvim_get_namespaces()) do+      if ns == v then+        name = k+        break+      end+    end++    if not name then+      return vim.notify(""namespace does not exist or is anonymous"", vim.log.levels.ERROR)+    end++    all_namespaces[ns] = {+      name = name,+      sign_group = string.format(""vim.diagnostic.%s"", name),+      opts = {}+    }+  end+  return all_namespaces[ns]+end++---@private+local function get_resolved_options(opts, namespace, bufnr)+  local ns = get_namespace(namespace)+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)+  for k in pairs(global_diagnostic_options) do+    if resolved[k] ~= nil then+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)+    end+  end+  return resolved+end++-- Default diagnostic highlights+local diagnostic_severities = {+  [M.severity.ERROR] = { ctermfg = 1, guifg = ""Red"" };+  [M.severity.WARN] = { ctermfg = 3, guifg = ""Orange"" };+  [M.severity.INFO] = { ctermfg = 4, guifg = ""LightBlue"" };+  [M.severity.HINT] = { ctermfg = 7, guifg = ""LightGrey"" };+}++-- Make a map from DiagnosticSeverity -> Highlight Name+---@private+local function make_highlight_map(base_name)+  local result = {}+  for k in pairs(diagnostic_severities) do+    local name = M.severity[k]+    name = name:sub(1, 1) .. name:sub(2):lower()+    result[k] = ""Diagnostic"" .. base_name .. name+  end++  return result+end++local default_highlight_map = make_highlight_map(""Default"")+local virtual_text_highlight_map = make_highlight_map(""VirtualText"")+local underline_highlight_map = make_highlight_map(""Underline"")+local floating_highlight_map = make_highlight_map(""Floating"")+local sign_highlight_map = make_highlight_map(""Sign"")++---@private+local function get_bufnr(bufnr)+  if not bufnr or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++-- Metatable that automatically creates an empty table when assigning to a missing key+local bufnr_and_namespace_cacher_mt = {+  __index = function(t, bufnr)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    if rawget(t, bufnr) == nil then+      rawset(t, bufnr, {})+    end++    return rawget(t, bufnr)+  end,++  __newindex = function(t, bufnr, v)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    rawset(t, bufnr, v)+  end,+}++local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_attached_buffers = {}+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)++---@private+local function diagnostic_lines(diagnostics)+  if not diagnostics then+    return+  end++  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++---@private+local function diagnostic_counts(diagnostics)+  if not diagnostics then+    return+  end++  local counts = {}+  for _, diagnostic in pairs(diagnostics) do+    if diagnostic.severity then+      local val = counts[diagnostic.severity]+      if val == nil then+        val = 0+      end++      counts[diagnostic.severity] = val + 1+    end+  end++  return counts+end++---@private+local function set_diagnostic_cache(namespace, diagnostics, bufnr)+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)+  for _, diagnostic in ipairs(diagnostics) do+    if diagnostic.severity == nil then+      diagnostic.severity = M.severity.ERROR+    end++    diagnostic.bufnr = bufnr++    if buf_line_count > 0 then+      diagnostic.lnum = math.max(math.min(+        diagnostic.lnum, buf_line_count - 1+      ), 0)+      diagnostic.end_lnum = math.max(math.min(+        diagnostic.end_lnum, buf_line_count - 1+      ), 0)+    end+  end++  diagnostic_cache[bufnr][namespace] = diagnostics+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)+end++---@private+local function clear_diagnostic_cache(namespace, bufnr)+  diagnostic_cache[bufnr][namespace] = nil+  diagnostic_cache_lines[bufnr][namespace] = nil+  diagnostic_cache_counts[bufnr][namespace] = nil+end++---@private+local function restore_extmarks(bufnr, last)+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})+    local found = {}+    for _, extmark in ipairs(extmarks_current) do+      -- nvim_buf_set_lines will move any extmark to the line after the last+      -- nvim_buf_set_text will move any extmark to the last line+      if extmark[2] ~= last + 1 then+        found[extmark[1]] = true+      end+    end+    for _, extmark in ipairs(extmarks) do+      if not found[extmark[1]] then+        local opts = extmark[4]+        opts.id = extmark[1]+        -- HACK: end_row should be end_line+        if opts.end_row then+          opts.end_line = opts.end_row+          opts.end_row = nil+        end+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)+      end+    end+  end+end++---@private+local function save_extmarks(namespace, bufnr)+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr+  if not diagnostic_attached_buffers[bufnr] then+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = function(_, _, _, _, _, last)+        restore_extmarks(bufnr, last - 1)+      end,+      on_detach = function()+        diagnostic_cache_extmarks[bufnr] = nil+      end})+    diagnostic_attached_buffers[bufnr] = true+  end+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})+end++local registered_autocmds = {}++---@private+local function make_augroup_key(namespace, bufnr)+  local ns = get_namespace(namespace)+  return string.format(""DiagnosticInsertLeave:%s:%s"", bufnr, ns.name)+end++--- Table of autocmd events to fire the update for displaying new diagnostic information+local insert_leave_auto_cmds = { ""InsertLeave"", ""CursorHoldI"" }++---@private+local function schedule_display(namespace, bufnr, args)+  bufs_waiting_to_update[bufnr][namespace] = args++  local key = make_augroup_key(namespace, bufnr)+  if not registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(+      string.format(+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],+        table.concat(insert_leave_auto_cmds, "",""),+        bufnr,+        namespace,+        bufnr+      )+    )+    vim.cmd(""augroup END"")++    registered_autocmds[key] = true+  end+end++---@private+local function clear_scheduled_display(namespace, bufnr)+  local key = make_augroup_key(namespace, bufnr)++  if registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(""augroup END"")++    registered_autocmds[key] = nil+  end+end+++--- Display diagnostics for the buffer with the given options.+---@private+local function display(namespace, diagnostics, bufnr, opts)+  if diagnostic_disabled[bufnr][namespace] then+    return+  end++  M.clear(namespace, bufnr)++  diagnostics = diagnostics or M.get(namespace, bufnr)++  if not diagnostics or vim.tbl_isempty(diagnostics) then+    return+  end++  vim.api.nvim_command(""doautocmd <nomodeline> User DiagnosticsChanged"")++  opts = get_resolved_options(opts, namespace, bufnr)++  if opts.update_in_insert then+    clear_scheduled_display(namespace, bufnr)+  else+    local mode = vim.api.nvim_get_mode()+    if string.sub(mode.mode, 1, 1) == 'i' then+      schedule_display(namespace, bufnr, opts)+      return+    end+  end++  if opts.underline then+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)+  end++  if opts.virtual_text then+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)+  end++  if opts.signs then+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)+  end++  save_extmarks(namespace, bufnr)+end++---@private+--- Open a floating window with the provided diagnostics+---+--- The floating window can be customized with the following highlight groups:+--- <pre>+--- DiagnosticsFloatingError+--- DiagnosticsFloatingWarning+--- DiagnosticsFloatingInformation+--- DiagnosticsFloatingHint+--- </pre>+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header+---     - all opts for |vim.util.open_floating_preview()| can be used here+---@param diagnostics table: The diagnostics to display+---@return table {popup_bufnr, win_id}+local function show_diagnostics(opts, diagnostics)+  if vim.tbl_isempty(diagnostics) then return end+  local lines = {}+  local highlights = {}+  local show_header = vim.F.if_nil(opts.show_header, true)+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  for i, diagnostic in ipairs(diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = floating_highlight_map[diagnostic.severity]+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix, hiname})+    for j = 2, #message_lines do+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end++local errlist_type_map = {+  [M.severity.ERROR] = 'E',+  [M.severity.WARN] = 'W',+  [M.severity.INFO] = 'I',+  [M.severity.HINT] = 'I',+}++---@private+local function diagnostics_to_list_items(diagnostics)",I wonder if we should expose this and remove the `setloclist` / `setqflist` functions instead and point users to using `vim.fn.setloclist` directly.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15585,706609565,2021-09-11T12:50:51Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -57,338 +13,241 @@ end  local M = {} --- Diagnostic Highlights {{{---- TODO(tjdevries): Determine how to generate documentation for these---                  and how to configure them to be easy for users.------                  For now, just use the following script. It should work pretty good.---[[-local levels = {""Error"", ""Warning"", ""Information"", ""Hint"" }--local all_info = {-  { ""Default"", ""Used as the base highlight group, other highlight groups link to"", },-  { ""VirtualText"", 'Used for ""%s"" diagnostic virtual text.\n  See |vim.lsp.diagnostic.set_virtual_text()|', },-  { ""Underline"", 'Used to underline ""%s"" diagnostics.\n  See |vim.lsp.diagnostic.set_underline()|', },-  { ""Floating"", 'Used to color ""%s"" diagnostic messages in diagnostics float.\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },-  { ""Sign"", 'Used for ""%s"" signs in sing column.\n  See |vim.lsp.diagnostic.set_signs()|', },-}--local results = {}-for _, info in ipairs(all_info) do-  for _, level in ipairs(levels) do-    local name = info[1]-    local description = info[2]-    local fullname = string.format(""Lsp%s%s"", name, level)-    table.insert(results, string.format(-      ""%78s"", string.format(""*hl-%s*"", fullname))-    )--    table.insert(results, fullname)-    table.insert(results, string.format(""  %s"", description))-    table.insert(results, """")-  end-end---- print(table.concat(results, '\n'))-vim.fn.setreg(""*"", table.concat(results, '\n'))---]]--local diagnostic_severities = {-  [DiagnosticSeverity.Error]       = { guifg = ""Red"" };-  [DiagnosticSeverity.Warning]     = { guifg = ""Orange"" };-  [DiagnosticSeverity.Information] = { guifg = ""LightBlue"" };-  [DiagnosticSeverity.Hint]        = { guifg = ""LightGrey"" };-}---- Make a map from DiagnosticSeverity -> Highlight Name-local make_highlight_map = function(base_name)-  local result = {}-  for k, _ in pairs(diagnostic_severities) do-    result[k] = ""LspDiagnostics"" .. base_name .. DiagnosticSeverity[k]-  end--  return result-end--local default_highlight_map = make_highlight_map(""Default"")-local virtual_text_highlight_map = make_highlight_map(""VirtualText"")-local underline_highlight_map = make_highlight_map(""Underline"")-local floating_highlight_map = make_highlight_map(""Floating"")-local sign_highlight_map = make_highlight_map(""Sign"")---- }}}--- Diagnostic Namespaces {{{ local DEFAULT_CLIENT_ID = -1-local get_client_id = function(client_id)+---@private+local function get_client_id(client_id)   if client_id == nil then     client_id = DEFAULT_CLIENT_ID   end    return client_id end -local get_bufnr = function(bufnr)+---@private+local function get_bufnr(bufnr)   if not bufnr then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   elseif bufnr == 0 then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   end    return bufnr end ----- Create a namespace table, used to track a client's buffer local items-local _make_namespace_table = function(namespace, api_namespace)-  vim.validate { namespace = { namespace, 's' } }--  return setmetatable({-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)-  }, {-    __index = function(t, client_id)-      client_id = get_client_id(client_id)--      if rawget(t, client_id) == nil then-        local value = string.format(""%s:%s"", namespace, client_id)--        if api_namespace then-          value = api.nvim_create_namespace(value)-        end--        rawset(t, client_id, value)-      end--      return rawget(t, client_id)-    end-  })+---@private+local function severity_lsp_to_vim(severity)+  if type(severity) == 'string' then+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]+  end+  return severity end -local _diagnostic_namespaces = _make_namespace_table(""vim_lsp_diagnostics"", true)-local _sign_namespaces = _make_namespace_table(""vim_lsp_signs"", false)- ---@private-function M._get_diagnostic_namespace(client_id)-  return _diagnostic_namespaces[client_id]+local function severity_vim_to_lsp(severity)+  if type(severity) == 'string' then+    severity = vim.diagnostic.severity[severity]+  end+  return severity end  ---@private-function M._get_sign_namespace(client_id)-  return _sign_namespaces[client_id]+local function diagnostic_lsp_to_vim(diagnostics)+  return vim.tbl_map(function(diagnostic)+    local start = diagnostic.range.start+    local _end = diagnostic.range[""end""]+    return {+      lnum = start.line,+      col = start.character,+      end_lnum = _end.line,+      end_col = _end.character,","`Position` in LSP uses UTF16 offsets (or UTF8, `vim.lsp.client` contains an `offset_encoding` property that indices which one is the case)We'd have to convert this here (which is potentially expensive, as we'd have to read the filesystem and diagnostics may be updated quite often).An alternative would be to store the `col` format as part of the diagnostics and make the conversion to byte column lazy?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15631,706621263,2021-09-11T14:42:15Z,runtime/doc/autocmd.txt,"@@ -499,8 +499,8 @@ CursorMoved			After the cursor was moved in Normal or Visual 				mode or to another window.  Also when the text 				of the cursor line has been changed, e.g. with 				""x"", ""rx"" or ""p"".-				Not triggered when there is typeahead, when-				an operator is pending or when moving to+				Not triggered when there is typeahead, while+				executing commands in a script file, when 				another window while remaining at the same","- wording looks off, should be ""when moving to...""- ""executing commands in a script file"" is pedantic, can be condensed to ""executing a script""```suggestion				Not triggered when there is typeahead, while				executing a script, or when moving to				another window while remaining at the same```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,706627397,2021-09-11T15:39:33Z,runtime/lua/vim/diagnostic.lua,"@@ -0,0 +1,1377 @@+local M = {}++M.severity = {+  ERROR = 1,+  WARN = 2,+  INFO = 3,+  HINT = 4,+}++vim.tbl_add_reverse_lookup(M.severity)++local global_diagnostic_options = {+  signs = true,+  underline = true,+  virtual_text = true,+  update_in_insert = false,+  severity_sort = false,+}++-- Local functions {{{++---@private+local function to_severity(severity)+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity+end++---@private+local function filter_to_severity_limit(severity, diagnostics)+  local filter_level = to_severity(severity)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)+end++---@private+local function filter_by_severity_limit(severity_limit, diagnostics)+  local filter_level = to_severity(severity_limit)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)+end++---@private+local function valid_severity()+  return function(severity)+    if type(severity) == 'string' then+      return to_severity(severity) ~= nil+    elseif type(severity) == 'number' then+      return M.severity[severity] ~= nil+    end+  end, ""Invalid value for 'severity' parameter""+end++---@private+local function resolve_optional_value(option, namespace, bufnr)+  local enabled_val = {}++  if not option then+    return false+  elseif option == true then+    return enabled_val+  elseif type(option) == 'function' then+    local val = option(namespace, bufnr)+    if val == true then+      return enabled_val+    else+      return val+    end+  elseif type(option) == 'table' then+    return option+  else+    error(""Unexpected option type: "" .. vim.inspect(option))+  end+end++local all_namespaces = {}++---@private+local function get_namespace(ns)+  if not all_namespaces[ns] then+    local name+    for k, v in pairs(vim.api.nvim_get_namespaces()) do+      if ns == v then+        name = k+        break+      end+    end++    if not name then+      return vim.notify(""namespace does not exist or is anonymous"", vim.log.levels.ERROR)+    end++    all_namespaces[ns] = {+      name = name,+      sign_group = string.format(""vim.diagnostic.%s"", name),+      opts = {}+    }+  end+  return all_namespaces[ns]+end++---@private+local function get_resolved_options(opts, namespace, bufnr)+  local ns = get_namespace(namespace)+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)+  for k in pairs(global_diagnostic_options) do+    if resolved[k] ~= nil then+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)+    end+  end+  return resolved+end++-- Default diagnostic highlights+local diagnostic_severities = {+  [M.severity.ERROR] = { ctermfg = 1, guifg = ""Red"" };+  [M.severity.WARN] = { ctermfg = 3, guifg = ""Orange"" };+  [M.severity.INFO] = { ctermfg = 4, guifg = ""LightBlue"" };+  [M.severity.HINT] = { ctermfg = 7, guifg = ""LightGrey"" };+}++-- Make a map from DiagnosticSeverity -> Highlight Name+---@private+local function make_highlight_map(base_name)+  local result = {}+  for k in pairs(diagnostic_severities) do+    local name = M.severity[k]+    name = name:sub(1, 1) .. name:sub(2):lower()+    result[k] = ""Diagnostic"" .. base_name .. name+  end++  return result+end++local default_highlight_map = make_highlight_map(""Default"")+local virtual_text_highlight_map = make_highlight_map(""VirtualText"")+local underline_highlight_map = make_highlight_map(""Underline"")+local floating_highlight_map = make_highlight_map(""Floating"")+local sign_highlight_map = make_highlight_map(""Sign"")++---@private+local function get_bufnr(bufnr)+  if not bufnr or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++-- Metatable that automatically creates an empty table when assigning to a missing key+local bufnr_and_namespace_cacher_mt = {+  __index = function(t, bufnr)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    if rawget(t, bufnr) == nil then+      rawset(t, bufnr, {})+    end++    return rawget(t, bufnr)+  end,++  __newindex = function(t, bufnr, v)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    rawset(t, bufnr, v)+  end,+}++local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_attached_buffers = {}+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)++---@private+local function diagnostic_lines(diagnostics)+  if not diagnostics then+    return+  end++  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++---@private+local function diagnostic_counts(diagnostics)+  if not diagnostics then+    return+  end++  local counts = {}+  for _, diagnostic in pairs(diagnostics) do+    if diagnostic.severity then+      local val = counts[diagnostic.severity]+      if val == nil then+        val = 0+      end++      counts[diagnostic.severity] = val + 1+    end+  end++  return counts+end++---@private+local function set_diagnostic_cache(namespace, diagnostics, bufnr)+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)+  for _, diagnostic in ipairs(diagnostics) do+    if diagnostic.severity == nil then+      diagnostic.severity = M.severity.ERROR+    end++    diagnostic.bufnr = bufnr++    if buf_line_count > 0 then+      diagnostic.lnum = math.max(math.min(+        diagnostic.lnum, buf_line_count - 1+      ), 0)+      diagnostic.end_lnum = math.max(math.min(+        diagnostic.end_lnum, buf_line_count - 1+      ), 0)+    end+  end++  diagnostic_cache[bufnr][namespace] = diagnostics+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)+end++---@private+local function clear_diagnostic_cache(namespace, bufnr)+  diagnostic_cache[bufnr][namespace] = nil+  diagnostic_cache_lines[bufnr][namespace] = nil+  diagnostic_cache_counts[bufnr][namespace] = nil+end++---@private+local function restore_extmarks(bufnr, last)+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})+    local found = {}+    for _, extmark in ipairs(extmarks_current) do+      -- nvim_buf_set_lines will move any extmark to the line after the last+      -- nvim_buf_set_text will move any extmark to the last line+      if extmark[2] ~= last + 1 then+        found[extmark[1]] = true+      end+    end+    for _, extmark in ipairs(extmarks) do+      if not found[extmark[1]] then+        local opts = extmark[4]+        opts.id = extmark[1]+        -- HACK: end_row should be end_line+        if opts.end_row then+          opts.end_line = opts.end_row+          opts.end_row = nil+        end+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)+      end+    end+  end+end++---@private+local function save_extmarks(namespace, bufnr)+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr+  if not diagnostic_attached_buffers[bufnr] then+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = function(_, _, _, _, _, last)+        restore_extmarks(bufnr, last - 1)+      end,+      on_detach = function()+        diagnostic_cache_extmarks[bufnr] = nil+      end})+    diagnostic_attached_buffers[bufnr] = true+  end+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})+end++local registered_autocmds = {}++---@private+local function make_augroup_key(namespace, bufnr)+  local ns = get_namespace(namespace)+  return string.format(""DiagnosticInsertLeave:%s:%s"", bufnr, ns.name)+end++--- Table of autocmd events to fire the update for displaying new diagnostic information+local insert_leave_auto_cmds = { ""InsertLeave"", ""CursorHoldI"" }++---@private+local function schedule_display(namespace, bufnr, args)+  bufs_waiting_to_update[bufnr][namespace] = args++  local key = make_augroup_key(namespace, bufnr)+  if not registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(+      string.format(+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],+        table.concat(insert_leave_auto_cmds, "",""),+        bufnr,+        namespace,+        bufnr+      )+    )+    vim.cmd(""augroup END"")++    registered_autocmds[key] = true+  end+end++---@private+local function clear_scheduled_display(namespace, bufnr)+  local key = make_augroup_key(namespace, bufnr)++  if registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(""augroup END"")++    registered_autocmds[key] = nil+  end+end+++--- Display diagnostics for the buffer with the given options.+---@private+local function display(namespace, diagnostics, bufnr, opts)+  if diagnostic_disabled[bufnr][namespace] then+    return+  end++  M.clear(namespace, bufnr)++  diagnostics = diagnostics or M.get(namespace, bufnr)++  if not diagnostics or vim.tbl_isempty(diagnostics) then+    return+  end++  vim.api.nvim_command(""doautocmd <nomodeline> User DiagnosticsChanged"")++  opts = get_resolved_options(opts, namespace, bufnr)++  if opts.update_in_insert then+    clear_scheduled_display(namespace, bufnr)+  else+    local mode = vim.api.nvim_get_mode()+    if string.sub(mode.mode, 1, 1) == 'i' then+      schedule_display(namespace, bufnr, opts)+      return+    end+  end++  if opts.underline then+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)+  end++  if opts.virtual_text then+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)+  end++  if opts.signs then+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)+  end++  save_extmarks(namespace, bufnr)+end++---@private+--- Open a floating window with the provided diagnostics+---+--- The floating window can be customized with the following highlight groups:+--- <pre>+--- DiagnosticsFloatingError+--- DiagnosticsFloatingWarning+--- DiagnosticsFloatingInformation+--- DiagnosticsFloatingHint+--- </pre>+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header+---     - all opts for |vim.util.open_floating_preview()| can be used here+---@param diagnostics table: The diagnostics to display+---@return table {popup_bufnr, win_id}+local function show_diagnostics(opts, diagnostics)+  if vim.tbl_isempty(diagnostics) then return end+  local lines = {}+  local highlights = {}+  local show_header = vim.F.if_nil(opts.show_header, true)+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  for i, diagnostic in ipairs(diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = floating_highlight_map[diagnostic.severity]+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix, hiname})+    for j = 2, #message_lines do+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end++local errlist_type_map = {+  [M.severity.ERROR] = 'E',+  [M.severity.WARN] = 'W',+  [M.severity.INFO] = 'I',+  [M.severity.HINT] = 'I',+}++---@private+local function diagnostics_to_list_items(diagnostics)","I did consider this, but it introduces a lot of boiler plate.Before:```luavim.diagnostic.setqflist()```After:```lualocal diagnostics = vim.diagnostic.get()local items = vim.diagnostic.diagnostics_to_list_items(diagnostics)vim.fn.setqflist({}, ' ', { items = items })```Even more so if you want to use `setloclist` for buffer-local diagnostics.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,706627977,2021-09-11T15:45:10Z,runtime/lua/vim/diagnostic.lua,"@@ -0,0 +1,1377 @@+local M = {}++M.severity = {+  ERROR = 1,+  WARN = 2,+  INFO = 3,+  HINT = 4,+}++vim.tbl_add_reverse_lookup(M.severity)++local global_diagnostic_options = {+  signs = true,+  underline = true,+  virtual_text = true,+  update_in_insert = false,+  severity_sort = false,+}++-- Local functions {{{++---@private+local function to_severity(severity)+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity+end++---@private+local function filter_to_severity_limit(severity, diagnostics)+  local filter_level = to_severity(severity)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)+end++---@private+local function filter_by_severity_limit(severity_limit, diagnostics)+  local filter_level = to_severity(severity_limit)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)+end++---@private+local function valid_severity()+  return function(severity)+    if type(severity) == 'string' then+      return to_severity(severity) ~= nil+    elseif type(severity) == 'number' then+      return M.severity[severity] ~= nil+    end+  end, ""Invalid value for 'severity' parameter""+end++---@private+local function resolve_optional_value(option, namespace, bufnr)+  local enabled_val = {}++  if not option then+    return false+  elseif option == true then+    return enabled_val+  elseif type(option) == 'function' then+    local val = option(namespace, bufnr)+    if val == true then+      return enabled_val+    else+      return val+    end+  elseif type(option) == 'table' then+    return option+  else+    error(""Unexpected option type: "" .. vim.inspect(option))+  end+end++local all_namespaces = {}++---@private+local function get_namespace(ns)+  if not all_namespaces[ns] then+    local name+    for k, v in pairs(vim.api.nvim_get_namespaces()) do+      if ns == v then+        name = k+        break+      end+    end++    if not name then+      return vim.notify(""namespace does not exist or is anonymous"", vim.log.levels.ERROR)+    end++    all_namespaces[ns] = {+      name = name,+      sign_group = string.format(""vim.diagnostic.%s"", name),+      opts = {}+    }+  end+  return all_namespaces[ns]+end++---@private+local function get_resolved_options(opts, namespace, bufnr)+  local ns = get_namespace(namespace)+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)+  for k in pairs(global_diagnostic_options) do+    if resolved[k] ~= nil then+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)+    end+  end+  return resolved+end++-- Default diagnostic highlights+local diagnostic_severities = {+  [M.severity.ERROR] = { ctermfg = 1, guifg = ""Red"" };+  [M.severity.WARN] = { ctermfg = 3, guifg = ""Orange"" };+  [M.severity.INFO] = { ctermfg = 4, guifg = ""LightBlue"" };+  [M.severity.HINT] = { ctermfg = 7, guifg = ""LightGrey"" };+}++-- Make a map from DiagnosticSeverity -> Highlight Name+---@private+local function make_highlight_map(base_name)+  local result = {}+  for k in pairs(diagnostic_severities) do+    local name = M.severity[k]+    name = name:sub(1, 1) .. name:sub(2):lower()+    result[k] = ""Diagnostic"" .. base_name .. name+  end++  return result+end++local default_highlight_map = make_highlight_map(""Default"")+local virtual_text_highlight_map = make_highlight_map(""VirtualText"")+local underline_highlight_map = make_highlight_map(""Underline"")+local floating_highlight_map = make_highlight_map(""Floating"")+local sign_highlight_map = make_highlight_map(""Sign"")++---@private+local function get_bufnr(bufnr)+  if not bufnr or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++-- Metatable that automatically creates an empty table when assigning to a missing key+local bufnr_and_namespace_cacher_mt = {+  __index = function(t, bufnr)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    if rawget(t, bufnr) == nil then+      rawset(t, bufnr, {})+    end++    return rawget(t, bufnr)+  end,++  __newindex = function(t, bufnr, v)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    rawset(t, bufnr, v)+  end,+}++local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_attached_buffers = {}+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)++---@private+local function diagnostic_lines(diagnostics)+  if not diagnostics then+    return+  end++  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++---@private+local function diagnostic_counts(diagnostics)+  if not diagnostics then+    return+  end++  local counts = {}+  for _, diagnostic in pairs(diagnostics) do+    if diagnostic.severity then+      local val = counts[diagnostic.severity]+      if val == nil then+        val = 0+      end++      counts[diagnostic.severity] = val + 1+    end+  end++  return counts+end++---@private+local function set_diagnostic_cache(namespace, diagnostics, bufnr)+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)+  for _, diagnostic in ipairs(diagnostics) do+    if diagnostic.severity == nil then+      diagnostic.severity = M.severity.ERROR+    end++    diagnostic.bufnr = bufnr++    if buf_line_count > 0 then+      diagnostic.lnum = math.max(math.min(+        diagnostic.lnum, buf_line_count - 1+      ), 0)+      diagnostic.end_lnum = math.max(math.min(+        diagnostic.end_lnum, buf_line_count - 1+      ), 0)+    end+  end++  diagnostic_cache[bufnr][namespace] = diagnostics+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)+end++---@private+local function clear_diagnostic_cache(namespace, bufnr)+  diagnostic_cache[bufnr][namespace] = nil+  diagnostic_cache_lines[bufnr][namespace] = nil+  diagnostic_cache_counts[bufnr][namespace] = nil+end++---@private+local function restore_extmarks(bufnr, last)+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})+    local found = {}+    for _, extmark in ipairs(extmarks_current) do+      -- nvim_buf_set_lines will move any extmark to the line after the last+      -- nvim_buf_set_text will move any extmark to the last line+      if extmark[2] ~= last + 1 then+        found[extmark[1]] = true+      end+    end+    for _, extmark in ipairs(extmarks) do+      if not found[extmark[1]] then+        local opts = extmark[4]+        opts.id = extmark[1]+        -- HACK: end_row should be end_line+        if opts.end_row then+          opts.end_line = opts.end_row+          opts.end_row = nil+        end+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)+      end+    end+  end+end++---@private+local function save_extmarks(namespace, bufnr)+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr+  if not diagnostic_attached_buffers[bufnr] then+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = function(_, _, _, _, _, last)+        restore_extmarks(bufnr, last - 1)+      end,+      on_detach = function()+        diagnostic_cache_extmarks[bufnr] = nil+      end})+    diagnostic_attached_buffers[bufnr] = true+  end+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})+end++local registered_autocmds = {}++---@private+local function make_augroup_key(namespace, bufnr)+  local ns = get_namespace(namespace)+  return string.format(""DiagnosticInsertLeave:%s:%s"", bufnr, ns.name)+end++--- Table of autocmd events to fire the update for displaying new diagnostic information+local insert_leave_auto_cmds = { ""InsertLeave"", ""CursorHoldI"" }++---@private+local function schedule_display(namespace, bufnr, args)+  bufs_waiting_to_update[bufnr][namespace] = args++  local key = make_augroup_key(namespace, bufnr)+  if not registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(+      string.format(+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],+        table.concat(insert_leave_auto_cmds, "",""),+        bufnr,+        namespace,+        bufnr+      )+    )+    vim.cmd(""augroup END"")++    registered_autocmds[key] = true+  end+end++---@private+local function clear_scheduled_display(namespace, bufnr)+  local key = make_augroup_key(namespace, bufnr)++  if registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(""augroup END"")++    registered_autocmds[key] = nil+  end+end+++--- Display diagnostics for the buffer with the given options.+---@private+local function display(namespace, diagnostics, bufnr, opts)+  if diagnostic_disabled[bufnr][namespace] then+    return+  end++  M.clear(namespace, bufnr)++  diagnostics = diagnostics or M.get(namespace, bufnr)++  if not diagnostics or vim.tbl_isempty(diagnostics) then+    return+  end++  vim.api.nvim_command(""doautocmd <nomodeline> User DiagnosticsChanged"")++  opts = get_resolved_options(opts, namespace, bufnr)++  if opts.update_in_insert then+    clear_scheduled_display(namespace, bufnr)+  else+    local mode = vim.api.nvim_get_mode()+    if string.sub(mode.mode, 1, 1) == 'i' then+      schedule_display(namespace, bufnr, opts)+      return+    end+  end++  if opts.underline then+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)+  end++  if opts.virtual_text then+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)+  end++  if opts.signs then+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)+  end++  save_extmarks(namespace, bufnr)+end++---@private+--- Open a floating window with the provided diagnostics+---+--- The floating window can be customized with the following highlight groups:+--- <pre>+--- DiagnosticsFloatingError+--- DiagnosticsFloatingWarning+--- DiagnosticsFloatingInformation+--- DiagnosticsFloatingHint+--- </pre>+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header+---     - all opts for |vim.util.open_floating_preview()| can be used here+---@param diagnostics table: The diagnostics to display+---@return table {popup_bufnr, win_id}+local function show_diagnostics(opts, diagnostics)+  if vim.tbl_isempty(diagnostics) then return end+  local lines = {}+  local highlights = {}+  local show_header = vim.F.if_nil(opts.show_header, true)+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  for i, diagnostic in ipairs(diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = floating_highlight_map[diagnostic.severity]+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix, hiname})+    for j = 2, #message_lines do+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end++local errlist_type_map = {+  [M.severity.ERROR] = 'E',+  [M.severity.WARN] = 'W',+  [M.severity.INFO] = 'I',+  [M.severity.HINT] = 'I',+}++---@private+local function diagnostics_to_list_items(diagnostics)+  local items = {}+  for _, d in pairs(diagnostics) do+    table.insert(items, {+      bufnr = d.bufnr,+      lnum = d.lnum + 1,+      col = d.col + 1,+      text = d.message,+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'+    })+  end+  table.sort(items, function(a, b)+    if a.bufnr == b.bufnr then+      return a.lnum < b.lnum+    else+      return a.bufnr < b.bufnr+    end+  end)+  return items+end++---@private+local function set_list(loclist, opts)+  opts = opts or {}+  local open = vim.F.if_nil(opts.open, true)+  local title = opts.title or ""Diagnostics""+  local diagnostics = M.get(opts.namespace, opts.bufnr)+  local items = vim.tbl_filter(function(d)+    local severity = to_severity(opts.severity)+    if severity then+      return d.severity == severity+    end+    local severity_limit = to_severity(opts.severity_limit)+    if severity_limit then+      return d.severity <= severity_limit+    end+    return true+  end, diagnostics_to_list_items(diagnostics))+  if loclist then+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })+  else+    vim.fn.setqflist({}, ' ', { title = title, items = items })+  end+  if open then+    vim.api.nvim_command(loclist and ""lopen"" or ""copen"")+  end+end++--- Create links to Lsp* groups for backward compatibility (this should+--- eventually be removed)+---@private+local function make_compat_highlight_link(name)+  local from = name:gsub(""^Diagnostic"", ""LspDiagnostics""):gsub(""Info"", ""Information""):gsub(""Warn"", ""Warning"")+  vim.highlight.link(from, name, false)+end++---@private+local function define_default_signs_and_highlights()+  ---@private+  local function define_default_sign(name, properties)+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then+      vim.fn.sign_define(name, properties)+    end+  end++  -- Initialize default diagnostic highlights+  for severity, hi_info in pairs(diagnostic_severities) do+    local default_highlight_name = default_highlight_map[severity]+    vim.highlight.create(default_highlight_name, hi_info, true)++    -- Default link all corresponding highlights to the default highlight+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)++    make_compat_highlight_link(default_highlight_name)+    make_compat_highlight_link(virtual_text_highlight_map[severity])+    make_compat_highlight_link(floating_highlight_map[severity])+    make_compat_highlight_link(sign_highlight_map[severity])+  end++  -- Create all signs+  for severity, sign_hl_name in pairs(sign_highlight_map) do+    local severity_name = M.severity[severity]++    define_default_sign(sign_hl_name, {+      text = (severity_name or 'U'):sub(1, 1),+      texthl = sign_hl_name,+      linehl = '',+      numhl = '',+    })+  end++  -- Initialize Underline highlights+  for severity, underline_highlight_name in pairs(underline_highlight_map) do+    vim.highlight.create(underline_highlight_name, {+      cterm = 'underline',+      gui   = 'underline',+      guisp = diagnostic_severities[severity].guifg+    }, true)+    make_compat_highlight_link(underline_highlight_name)+  end+end++define_default_signs_and_highlights()++-- }}}++-- Public API {{{++--- Configure diagnostic options globally or for a specific diagnostic+--- namespace.+---+---@note Each of the configuration options below accepts one of the following:+---+---         - `false`: Disable this feature+---         - `true`: Enable this feature, use default settings.+---         - `table`: Enable this feature with overrides.+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.+---+---@param opts table Configuration table with the following keys:+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,+---                           diagnostics are updated on InsertLeave)+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in+---                         which signs and virtual text are displayed+---@param namespace number|nil Update the options for the given namespace. When omitted, update the+---                            global diagnostic options.+function M.config(opts, namespace)+  vim.validate {+    opts = { opts, 't' },+    namespace = { namespace, 'n', true },+  }++  local t+  if namespace then+    local ns = get_namespace(namespace)+    t = ns.opts+  else+    t = global_diagnostic_options+  end++  for opt in pairs(global_diagnostic_options) do+    if opts[opt] ~= nil then+      t[opt] = opts[opt]+    end+  end++  if namespace then+    M.redraw(namespace)+  else+    for k in pairs(all_namespaces) do+      M.redraw(k)+    end+  end+end++--- Set diagnostics for the given namespace and buffer.+---+---@param namespace number The diagnostic namespace+---@param diagnostics table A list of diagnostic items |diagnostic-structure|+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.+function M.set(namespace, diagnostics, bufnr)+  vim.validate {+    namespace = {namespace, 'n'},+    diagnostics = {diagnostics, 't'},+    bufnr = {bufnr, 'n', true},+  }++  if vim.tbl_isempty(diagnostics) then+    return+  end++  bufnr = get_bufnr(bufnr)+  if not diagnostic_cleanup[bufnr][namespace] then+    diagnostic_cleanup[bufnr][namespace] = true++    -- Clean up our data when the buffer unloads.+    vim.api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        clear_diagnostic_cache(b, namespace)+        diagnostic_cleanup[b][namespace] = nil+      end+    })+  end++  set_diagnostic_cache(namespace, diagnostics, bufnr)++  if vim.api.nvim_buf_is_loaded(bufnr) then+    display(namespace, diagnostics, bufnr)+  end","I guess it depends on who you mean by ""users"". As an end-user (e.g. someone using a plugin to display diagnostics), I want to be able to simply call `enable()` or `disable()` to mean ""do show diagnostics"" or ""do not show diagnostics"". I don't want to be on the hook for displaying them myself.For plugins who are users of the diagnostic API I think this makes a little more sense, although I suspect in the vast majority of cases when diagnostics are set they should also be displayed (assuming the user has enabled diagnostics in the buffer).  We could add an optional parameter to `set` to disable automatically displaying diagnostics for the other cases though.> (Maybe we rename redraw to draw ?)We can probably combine `redraw()` and `display()` and just expose `display()`.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,706868673,2021-09-12T17:30:33Z,runtime/lua/vim/diagnostic.lua,"@@ -0,0 +1,1377 @@+local M = {}++M.severity = {+  ERROR = 1,+  WARN = 2,+  INFO = 3,+  HINT = 4,+}++vim.tbl_add_reverse_lookup(M.severity)++local global_diagnostic_options = {+  signs = true,+  underline = true,+  virtual_text = true,+  update_in_insert = false,+  severity_sort = false,+}++-- Local functions {{{++---@private+local function to_severity(severity)+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity+end++---@private+local function filter_to_severity_limit(severity, diagnostics)+  local filter_level = to_severity(severity)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)+end++---@private+local function filter_by_severity_limit(severity_limit, diagnostics)+  local filter_level = to_severity(severity_limit)+  if not filter_level then+    return diagnostics+  end++  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)+end++---@private+local function valid_severity()+  return function(severity)+    if type(severity) == 'string' then+      return to_severity(severity) ~= nil+    elseif type(severity) == 'number' then+      return M.severity[severity] ~= nil+    end+  end, ""Invalid value for 'severity' parameter""+end++---@private+local function resolve_optional_value(option, namespace, bufnr)+  local enabled_val = {}++  if not option then+    return false+  elseif option == true then+    return enabled_val+  elseif type(option) == 'function' then+    local val = option(namespace, bufnr)+    if val == true then+      return enabled_val+    else+      return val+    end+  elseif type(option) == 'table' then+    return option+  else+    error(""Unexpected option type: "" .. vim.inspect(option))+  end+end++local all_namespaces = {}++---@private+local function get_namespace(ns)+  if not all_namespaces[ns] then+    local name+    for k, v in pairs(vim.api.nvim_get_namespaces()) do+      if ns == v then+        name = k+        break+      end+    end++    if not name then+      return vim.notify(""namespace does not exist or is anonymous"", vim.log.levels.ERROR)+    end++    all_namespaces[ns] = {+      name = name,+      sign_group = string.format(""vim.diagnostic.%s"", name),+      opts = {}+    }+  end+  return all_namespaces[ns]+end++---@private+local function get_resolved_options(opts, namespace, bufnr)+  local ns = get_namespace(namespace)+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)+  for k in pairs(global_diagnostic_options) do+    if resolved[k] ~= nil then+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)+    end+  end+  return resolved+end++-- Default diagnostic highlights+local diagnostic_severities = {+  [M.severity.ERROR] = { ctermfg = 1, guifg = ""Red"" };+  [M.severity.WARN] = { ctermfg = 3, guifg = ""Orange"" };+  [M.severity.INFO] = { ctermfg = 4, guifg = ""LightBlue"" };+  [M.severity.HINT] = { ctermfg = 7, guifg = ""LightGrey"" };+}++-- Make a map from DiagnosticSeverity -> Highlight Name+---@private+local function make_highlight_map(base_name)+  local result = {}+  for k in pairs(diagnostic_severities) do+    local name = M.severity[k]+    name = name:sub(1, 1) .. name:sub(2):lower()+    result[k] = ""Diagnostic"" .. base_name .. name+  end++  return result+end++local default_highlight_map = make_highlight_map(""Default"")+local virtual_text_highlight_map = make_highlight_map(""VirtualText"")+local underline_highlight_map = make_highlight_map(""Underline"")+local floating_highlight_map = make_highlight_map(""Floating"")+local sign_highlight_map = make_highlight_map(""Sign"")++---@private+local function get_bufnr(bufnr)+  if not bufnr or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++-- Metatable that automatically creates an empty table when assigning to a missing key+local bufnr_and_namespace_cacher_mt = {+  __index = function(t, bufnr)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    if rawget(t, bufnr) == nil then+      rawset(t, bufnr, {})+    end++    return rawget(t, bufnr)+  end,++  __newindex = function(t, bufnr, v)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    rawset(t, bufnr, v)+  end,+}++local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_attached_buffers = {}+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)++---@private+local function diagnostic_lines(diagnostics)+  if not diagnostics then+    return+  end++  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++---@private+local function diagnostic_counts(diagnostics)+  if not diagnostics then+    return+  end++  local counts = {}+  for _, diagnostic in pairs(diagnostics) do+    if diagnostic.severity then+      local val = counts[diagnostic.severity]+      if val == nil then+        val = 0+      end++      counts[diagnostic.severity] = val + 1+    end+  end++  return counts+end++---@private+local function set_diagnostic_cache(namespace, diagnostics, bufnr)+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)+  for _, diagnostic in ipairs(diagnostics) do+    if diagnostic.severity == nil then+      diagnostic.severity = M.severity.ERROR+    end++    diagnostic.bufnr = bufnr++    if buf_line_count > 0 then+      diagnostic.lnum = math.max(math.min(+        diagnostic.lnum, buf_line_count - 1+      ), 0)+      diagnostic.end_lnum = math.max(math.min(+        diagnostic.end_lnum, buf_line_count - 1+      ), 0)+    end+  end++  diagnostic_cache[bufnr][namespace] = diagnostics+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)+end++---@private+local function clear_diagnostic_cache(namespace, bufnr)+  diagnostic_cache[bufnr][namespace] = nil+  diagnostic_cache_lines[bufnr][namespace] = nil+  diagnostic_cache_counts[bufnr][namespace] = nil+end++---@private+local function restore_extmarks(bufnr, last)+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})+    local found = {}+    for _, extmark in ipairs(extmarks_current) do+      -- nvim_buf_set_lines will move any extmark to the line after the last+      -- nvim_buf_set_text will move any extmark to the last line+      if extmark[2] ~= last + 1 then+        found[extmark[1]] = true+      end+    end+    for _, extmark in ipairs(extmarks) do+      if not found[extmark[1]] then+        local opts = extmark[4]+        opts.id = extmark[1]+        -- HACK: end_row should be end_line+        if opts.end_row then+          opts.end_line = opts.end_row+          opts.end_row = nil+        end+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)+      end+    end+  end+end++---@private+local function save_extmarks(namespace, bufnr)+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr+  if not diagnostic_attached_buffers[bufnr] then+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = function(_, _, _, _, _, last)+        restore_extmarks(bufnr, last - 1)+      end,+      on_detach = function()+        diagnostic_cache_extmarks[bufnr] = nil+      end})+    diagnostic_attached_buffers[bufnr] = true+  end+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})+end++local registered_autocmds = {}++---@private+local function make_augroup_key(namespace, bufnr)+  local ns = get_namespace(namespace)+  return string.format(""DiagnosticInsertLeave:%s:%s"", bufnr, ns.name)+end++--- Table of autocmd events to fire the update for displaying new diagnostic information+local insert_leave_auto_cmds = { ""InsertLeave"", ""CursorHoldI"" }++---@private+local function schedule_display(namespace, bufnr, args)+  bufs_waiting_to_update[bufnr][namespace] = args++  local key = make_augroup_key(namespace, bufnr)+  if not registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(+      string.format(+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],+        table.concat(insert_leave_auto_cmds, "",""),+        bufnr,+        namespace,+        bufnr+      )+    )+    vim.cmd(""augroup END"")++    registered_autocmds[key] = true+  end+end++---@private+local function clear_scheduled_display(namespace, bufnr)+  local key = make_augroup_key(namespace, bufnr)++  if registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(""augroup END"")++    registered_autocmds[key] = nil+  end+end+++--- Display diagnostics for the buffer with the given options.+---@private+local function display(namespace, diagnostics, bufnr, opts)+  if diagnostic_disabled[bufnr][namespace] then+    return+  end++  M.clear(namespace, bufnr)++  diagnostics = diagnostics or M.get(namespace, bufnr)++  if not diagnostics or vim.tbl_isempty(diagnostics) then+    return+  end++  vim.api.nvim_command(""doautocmd <nomodeline> User DiagnosticsChanged"")++  opts = get_resolved_options(opts, namespace, bufnr)++  if opts.update_in_insert then+    clear_scheduled_display(namespace, bufnr)+  else+    local mode = vim.api.nvim_get_mode()+    if string.sub(mode.mode, 1, 1) == 'i' then+      schedule_display(namespace, bufnr, opts)+      return+    end+  end++  if opts.underline then+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)+  end++  if opts.virtual_text then+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)+  end++  if opts.signs then+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)+  end++  save_extmarks(namespace, bufnr)+end++---@private+--- Open a floating window with the provided diagnostics+---+--- The floating window can be customized with the following highlight groups:+--- <pre>+--- DiagnosticsFloatingError+--- DiagnosticsFloatingWarning+--- DiagnosticsFloatingInformation+--- DiagnosticsFloatingHint+--- </pre>+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header+---     - all opts for |vim.util.open_floating_preview()| can be used here+---@param diagnostics table: The diagnostics to display+---@return table {popup_bufnr, win_id}+local function show_diagnostics(opts, diagnostics)+  if vim.tbl_isempty(diagnostics) then return end+  local lines = {}+  local highlights = {}+  local show_header = vim.F.if_nil(opts.show_header, true)+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  for i, diagnostic in ipairs(diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = floating_highlight_map[diagnostic.severity]+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix, hiname})+    for j = 2, #message_lines do+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end++local errlist_type_map = {+  [M.severity.ERROR] = 'E',+  [M.severity.WARN] = 'W',+  [M.severity.INFO] = 'I',+  [M.severity.HINT] = 'I',+}++---@private+local function diagnostics_to_list_items(diagnostics)+  local items = {}+  for _, d in pairs(diagnostics) do+    table.insert(items, {+      bufnr = d.bufnr,+      lnum = d.lnum + 1,+      col = d.col + 1,+      text = d.message,+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'+    })+  end+  table.sort(items, function(a, b)+    if a.bufnr == b.bufnr then+      return a.lnum < b.lnum+    else+      return a.bufnr < b.bufnr+    end+  end)+  return items+end++---@private+local function set_list(loclist, opts)+  opts = opts or {}+  local open = vim.F.if_nil(opts.open, true)+  local title = opts.title or ""Diagnostics""+  local diagnostics = M.get(opts.namespace, opts.bufnr)+  local items = vim.tbl_filter(function(d)+    local severity = to_severity(opts.severity)+    if severity then+      return d.severity == severity+    end+    local severity_limit = to_severity(opts.severity_limit)+    if severity_limit then+      return d.severity <= severity_limit+    end+    return true+  end, diagnostics_to_list_items(diagnostics))+  if loclist then+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })+  else+    vim.fn.setqflist({}, ' ', { title = title, items = items })+  end+  if open then+    vim.api.nvim_command(loclist and ""lopen"" or ""copen"")+  end+end++--- Create links to Lsp* groups for backward compatibility (this should+--- eventually be removed)+---@private+local function make_compat_highlight_link(name)+  local from = name:gsub(""^Diagnostic"", ""LspDiagnostics""):gsub(""Info"", ""Information""):gsub(""Warn"", ""Warning"")+  vim.highlight.link(from, name, false)+end++---@private+local function define_default_signs_and_highlights()+  ---@private+  local function define_default_sign(name, properties)+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then+      vim.fn.sign_define(name, properties)+    end+  end++  -- Initialize default diagnostic highlights+  for severity, hi_info in pairs(diagnostic_severities) do+    local default_highlight_name = default_highlight_map[severity]+    vim.highlight.create(default_highlight_name, hi_info, true)++    -- Default link all corresponding highlights to the default highlight+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)++    make_compat_highlight_link(default_highlight_name)+    make_compat_highlight_link(virtual_text_highlight_map[severity])+    make_compat_highlight_link(floating_highlight_map[severity])+    make_compat_highlight_link(sign_highlight_map[severity])+  end++  -- Create all signs+  for severity, sign_hl_name in pairs(sign_highlight_map) do+    local severity_name = M.severity[severity]++    define_default_sign(sign_hl_name, {+      text = (severity_name or 'U'):sub(1, 1),+      texthl = sign_hl_name,+      linehl = '',+      numhl = '',+    })+  end++  -- Initialize Underline highlights+  for severity, underline_highlight_name in pairs(underline_highlight_map) do+    vim.highlight.create(underline_highlight_name, {+      cterm = 'underline',+      gui   = 'underline',+      guisp = diagnostic_severities[severity].guifg+    }, true)+    make_compat_highlight_link(underline_highlight_name)+  end+end++define_default_signs_and_highlights()++-- }}}++-- Public API {{{++--- Configure diagnostic options globally or for a specific diagnostic+--- namespace.+---+---@note Each of the configuration options below accepts one of the following:+---+---         - `false`: Disable this feature+---         - `true`: Enable this feature, use default settings.+---         - `table`: Enable this feature with overrides.+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.+---+---@param opts table Configuration table with the following keys:+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,+---                           diagnostics are updated on InsertLeave)+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in+---                         which signs and virtual text are displayed+---@param namespace number|nil Update the options for the given namespace. When omitted, update the+---                            global diagnostic options.+function M.config(opts, namespace)+  vim.validate {+    opts = { opts, 't' },+    namespace = { namespace, 'n', true },+  }++  local t+  if namespace then+    local ns = get_namespace(namespace)+    t = ns.opts+  else+    t = global_diagnostic_options+  end++  for opt in pairs(global_diagnostic_options) do+    if opts[opt] ~= nil then+      t[opt] = opts[opt]+    end+  end++  if namespace then+    M.redraw(namespace)+  else+    for k in pairs(all_namespaces) do+      M.redraw(k)+    end+  end+end++--- Set diagnostics for the given namespace and buffer.+---+---@param namespace number The diagnostic namespace+---@param diagnostics table A list of diagnostic items |diagnostic-structure|+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.+function M.set(namespace, diagnostics, bufnr)+  vim.validate {+    namespace = {namespace, 'n'},+    diagnostics = {diagnostics, 't'},+    bufnr = {bufnr, 'n', true},+  }++  if vim.tbl_isempty(diagnostics) then+    return+  end++  bufnr = get_bufnr(bufnr)+  if not diagnostic_cleanup[bufnr][namespace] then+    diagnostic_cleanup[bufnr][namespace] = true++    -- Clean up our data when the buffer unloads.+    vim.api.nvim_buf_attach(bufnr, false, {+      on_detach = function(_, b)+        clear_diagnostic_cache(b, namespace)+        diagnostic_cleanup[b][namespace] = nil+      end+    })+  end++  set_diagnostic_cache(namespace, diagnostics, bufnr)++  if vim.api.nvim_buf_is_loaded(bufnr) then+    display(namespace, diagnostics, bufnr)+  end","> We could add an optional parameter to set to disable automatically displaying diagnostics for the other cases though.I just added this, but on further thought I'm not sure it's necessary. We already have a way for diagnostic producers to temporarily disable display of their diagnostics:```luavim.diagnostic.disable(my_namespace)-- Set diagnostics. They won't be displayed becuase of the 'disable()' callvim.diagnostic.set(...)-- Re-enable to display diagnosticsvim.diagnostic.enable(my_namespace)```This is pretty much exactly equivalent to using```luavim.diagnostic.set(..., false)vim.diagnostic.display(my_namespace)```I don't like having two ways to do the same thing, so I think I'll revert that last change.In addition I'm not sure we need to expose `redraw()` *or* `display()`. Display of diagnostics should be handled completely internally by `vim.diagnostic` and we should only expose `enable()` and `disable()` to API consumers.Any thoughts?",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15620,707196239,2021-09-13T10:14:25Z,.github/workflows/commitlint.yml,"@@ -1,18 +0,0 @@-name: ""Commit Linter""-on: pull_request-jobs:-  lint-commits:-    runs-on: ubuntu-latest-    env:-      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}-    steps:-      - uses: actions/checkout@v2.3.1-        with:-          fetch-depth: 0-      - run: npm install --save-dev @commitlint/cli-      - run: |-          if [[ ""$(gh pr view ${{ github.event.pull_request.number }} --json commits --jq '.[][0].messageHeadline')"" == vim-patch* ]];then-            npx commitlint --from HEAD~1 --to HEAD --verbose --help-url https://github.com/neovim/neovim/blob/master/CONTRIBUTING.md#commit-messages --config .github/workflows/commitlint.config_patch.js","Haven't decided yet, but I may split up this PR into two parts if it becomes too big. In that case I'll unremove the current commitlinter workflow and only focus on making the manual linter work locally and then focus on the CI in part 2.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15620,707575547,2021-09-13T18:19:22Z,scripts/lintcommit.lua,"@@ -0,0 +1,35 @@+-- Captures shell output and returns it.+function os.capture(cmd, raw)+  local f = assert(io.popen(cmd, 'r'))+  local s = assert(f:read('*a'))+  f:close()+  if raw then return s end+  s = string.gsub(s, '^%s+', '')+  s = string.gsub(s, '%s+$', '')+  s = string.gsub(s, '[\n\r]+', ' ')+  return s+end++current_branch = os.capture(""git branch --show-current"")","`vim.fn.system(['git', 'branch', '--show-current'])`same for this others. Don't use shell (the non-list form uses shell).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15620,707576396,2021-09-13T18:20:43Z,scripts/lintcommit.lua,"@@ -0,0 +1,35 @@+-- Captures shell output and returns it.+function os.capture(cmd, raw)+  local f = assert(io.popen(cmd, 'r'))+  local s = assert(f:read('*a'))+  f:close()+  if raw then return s end+  s = string.gsub(s, '^%s+', '')+  s = string.gsub(s, '%s+$', '')+  s = string.gsub(s, '[\n\r]+', ' ')+  return s+end++current_branch = os.capture(""git branch --show-current"")+ancestor_commit = os.capture(""git merge-base master "" .. current_branch)+commits_on_current_pr = os.capture(""git rev-list "" .. ancestor_commit .."".."" .. current_branch)","no string concatenation needed, use list form of `vim.fn.system()`",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15620,707629580,2021-09-13T19:43:17Z,scripts/lintcommit.lua,"@@ -0,0 +1,35 @@+-- Captures shell output and returns it.+function os.capture(cmd, raw)+  local f = assert(io.popen(cmd, 'r'))+  local s = assert(f:read('*a'))+  f:close()+  if raw then return s end+  s = string.gsub(s, '^%s+', '')+  s = string.gsub(s, '%s+$', '')+  s = string.gsub(s, '[\n\r]+', ' ')+  return s+end++current_branch = os.capture(""git branch --show-current"")+ancestor_commit = os.capture(""git merge-base master "" .. current_branch)+commits_on_current_pr = os.capture(""git rev-list "" .. ancestor_commit .."".."" .. current_branch)","I think `system()` is returning a trailing newline. Try wrapping the call in `vim.trim()`:```luacurrent_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))```Alternatively use `systemlist()` and get the first item from the result:```luacurrent_branch = vim.fn.systemlist({'git', 'branch', '--show-current'})[1]```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15620,707993180,2021-09-14T07:33:38Z,scripts/lintcommit.lua,"@@ -0,0 +1,35 @@+-- Captures shell output and returns it.+function os.capture(cmd, raw)+  local f = assert(io.popen(cmd, 'r'))+  local s = assert(f:read('*a'))+  f:close()+  if raw then return s end+  s = string.gsub(s, '^%s+', '')+  s = string.gsub(s, '%s+$', '')+  s = string.gsub(s, '[\n\r]+', ' ')+  return s+end++current_branch = os.capture(""git branch --show-current"")+ancestor_commit = os.capture(""git merge-base master "" .. current_branch)+commits_on_current_pr = os.capture(""git rev-list "" .. ancestor_commit .."".."" .. current_branch)",I've fixed it. Any reason to avoid string concatenation in general or is it mostly because the list form is more readable?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15620,708167287,2021-09-14T11:19:15Z,scripts/lintcommit.lua,"@@ -0,0 +1,35 @@+-- Captures shell output and returns it.+function os.capture(cmd, raw)+  local f = assert(io.popen(cmd, 'r'))+  local s = assert(f:read('*a'))+  f:close()+  if raw then return s end+  s = string.gsub(s, '^%s+', '')+  s = string.gsub(s, '%s+$', '')+  s = string.gsub(s, '[\n\r]+', ' ')+  return s+end++current_branch = os.capture(""git branch --show-current"")+ancestor_commit = os.capture(""git merge-base master "" .. current_branch)+commits_on_current_pr = os.capture(""git rev-list "" .. ancestor_commit .."".."" .. current_branch)","> I've fixed it. Any reason to avoid string concatenation in general or is it mostly because the list form is more readable?it avoids use of the shell, which avoids quoting issues and other shell quirks. see `:help system()`",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15620,708170118,2021-09-14T11:23:34Z,scripts/lintcommit.lua,"@@ -0,0 +1,34 @@+current_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))+ancestor_commit = vim.trim(vim.fn.system({'git', 'merge-base', 'master', current_branch}))+commits_on_current_pr = vim.trim(vim.fn.system({'git', 'rev-list', ancestor_commit .. "".."" .. current_branch}))","good practice to use `local`. same for `all_commits` and `good_messages` .```suggestionlocal current_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))local ancestor_commit = vim.trim(vim.fn.system({'git', 'merge-base', 'master', current_branch}))local commits_on_current_pr = vim.trim(vim.fn.system({'git', 'rev-list', ancestor_commit .. "".."" .. current_branch}))```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,708270979,2021-09-14T13:30:13Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -57,338 +13,241 @@ end  local M = {} --- Diagnostic Highlights {{{---- TODO(tjdevries): Determine how to generate documentation for these---                  and how to configure them to be easy for users.------                  For now, just use the following script. It should work pretty good.---[[-local levels = {""Error"", ""Warning"", ""Information"", ""Hint"" }--local all_info = {-  { ""Default"", ""Used as the base highlight group, other highlight groups link to"", },-  { ""VirtualText"", 'Used for ""%s"" diagnostic virtual text.\n  See |vim.lsp.diagnostic.set_virtual_text()|', },-  { ""Underline"", 'Used to underline ""%s"" diagnostics.\n  See |vim.lsp.diagnostic.set_underline()|', },-  { ""Floating"", 'Used to color ""%s"" diagnostic messages in diagnostics float.\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },-  { ""Sign"", 'Used for ""%s"" signs in sing column.\n  See |vim.lsp.diagnostic.set_signs()|', },-}--local results = {}-for _, info in ipairs(all_info) do-  for _, level in ipairs(levels) do-    local name = info[1]-    local description = info[2]-    local fullname = string.format(""Lsp%s%s"", name, level)-    table.insert(results, string.format(-      ""%78s"", string.format(""*hl-%s*"", fullname))-    )--    table.insert(results, fullname)-    table.insert(results, string.format(""  %s"", description))-    table.insert(results, """")-  end-end---- print(table.concat(results, '\n'))-vim.fn.setreg(""*"", table.concat(results, '\n'))---]]--local diagnostic_severities = {-  [DiagnosticSeverity.Error]       = { guifg = ""Red"" };-  [DiagnosticSeverity.Warning]     = { guifg = ""Orange"" };-  [DiagnosticSeverity.Information] = { guifg = ""LightBlue"" };-  [DiagnosticSeverity.Hint]        = { guifg = ""LightGrey"" };-}---- Make a map from DiagnosticSeverity -> Highlight Name-local make_highlight_map = function(base_name)-  local result = {}-  for k, _ in pairs(diagnostic_severities) do-    result[k] = ""LspDiagnostics"" .. base_name .. DiagnosticSeverity[k]-  end--  return result-end--local default_highlight_map = make_highlight_map(""Default"")-local virtual_text_highlight_map = make_highlight_map(""VirtualText"")-local underline_highlight_map = make_highlight_map(""Underline"")-local floating_highlight_map = make_highlight_map(""Floating"")-local sign_highlight_map = make_highlight_map(""Sign"")---- }}}--- Diagnostic Namespaces {{{ local DEFAULT_CLIENT_ID = -1-local get_client_id = function(client_id)+---@private+local function get_client_id(client_id)   if client_id == nil then     client_id = DEFAULT_CLIENT_ID   end    return client_id end -local get_bufnr = function(bufnr)+---@private+local function get_bufnr(bufnr)   if not bufnr then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   elseif bufnr == 0 then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   end    return bufnr end ----- Create a namespace table, used to track a client's buffer local items-local _make_namespace_table = function(namespace, api_namespace)-  vim.validate { namespace = { namespace, 's' } }--  return setmetatable({-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)-  }, {-    __index = function(t, client_id)-      client_id = get_client_id(client_id)--      if rawget(t, client_id) == nil then-        local value = string.format(""%s:%s"", namespace, client_id)--        if api_namespace then-          value = api.nvim_create_namespace(value)-        end--        rawset(t, client_id, value)-      end--      return rawget(t, client_id)-    end-  })+---@private+local function severity_lsp_to_vim(severity)+  if type(severity) == 'string' then+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]+  end+  return severity end -local _diagnostic_namespaces = _make_namespace_table(""vim_lsp_diagnostics"", true)-local _sign_namespaces = _make_namespace_table(""vim_lsp_signs"", false)- ---@private-function M._get_diagnostic_namespace(client_id)-  return _diagnostic_namespaces[client_id]+local function severity_vim_to_lsp(severity)+  if type(severity) == 'string' then+    severity = vim.diagnostic.severity[severity]+  end+  return severity end  ---@private-function M._get_sign_namespace(client_id)-  return _sign_namespaces[client_id]+local function diagnostic_lsp_to_vim(diagnostics)+  return vim.tbl_map(function(diagnostic)+    local start = diagnostic.range.start+    local _end = diagnostic.range[""end""]+    return {+      lnum = start.line,+      col = start.character,+      end_lnum = _end.line,+      end_col = _end.character,","That makes sense. So if I'm understanding your suggestion here:>An alternative would be to store the col format as part of the diagnostics and make the conversion to byte column lazy?We don't need to really convert the byte columns until the point where diagnostics are actually displayed somehow (either through decorations or via the quickfix list). So we could indicate in some fashion to defer that conversion until the point of display.I suppose we could support letting the `col` field of the diagnostic structure be a function, in which case it gets called in order to resolve the value.This seems like a lot of additional complexity though and I'd want to be sure that the performance improvements are really worth it. So I'm leaning toward copying what folke did in #14615 first and then if we find that it's too slow we can try to be more clever.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15585,708391263,2021-09-14T15:30:53Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -57,250 +13,122 @@ end  local M = {} --- Diagnostic Highlights {{{---- TODO(tjdevries): Determine how to generate documentation for these---                  and how to configure them to be easy for users.------                  For now, just use the following script. It should work pretty good.---[[-local levels = {""Error"", ""Warning"", ""Information"", ""Hint"" }--local all_info = {-  { ""Default"", ""Used as the base highlight group, other highlight groups link to"", },-  { ""VirtualText"", 'Used for ""%s"" diagnostic virtual text.\n  See |vim.lsp.diagnostic.set_virtual_text()|', },-  { ""Underline"", 'Used to underline ""%s"" diagnostics.\n  See |vim.lsp.diagnostic.set_underline()|', },-  { ""Floating"", 'Used to color ""%s"" diagnostic messages in diagnostics float.\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },-  { ""Sign"", 'Used for ""%s"" signs in sing column.\n  See |vim.lsp.diagnostic.set_signs()|', },-}--local results = {}-for _, info in ipairs(all_info) do-  for _, level in ipairs(levels) do-    local name = info[1]-    local description = info[2]-    local fullname = string.format(""Lsp%s%s"", name, level)-    table.insert(results, string.format(-      ""%78s"", string.format(""*hl-%s*"", fullname))-    )--    table.insert(results, fullname)-    table.insert(results, string.format(""  %s"", description))-    table.insert(results, """")-  end-end---- print(table.concat(results, '\n'))-vim.fn.setreg(""*"", table.concat(results, '\n'))---]]--local diagnostic_severities = {-  [DiagnosticSeverity.Error]       = { guifg = ""Red"" };-  [DiagnosticSeverity.Warning]     = { guifg = ""Orange"" };-  [DiagnosticSeverity.Information] = { guifg = ""LightBlue"" };-  [DiagnosticSeverity.Hint]        = { guifg = ""LightGrey"" };-}---- Make a map from DiagnosticSeverity -> Highlight Name-local make_highlight_map = function(base_name)-  local result = {}-  for k, _ in pairs(diagnostic_severities) do-    result[k] = ""LspDiagnostics"" .. base_name .. DiagnosticSeverity[k]-  end--  return result-end--local default_highlight_map = make_highlight_map(""Default"")-local virtual_text_highlight_map = make_highlight_map(""VirtualText"")-local underline_highlight_map = make_highlight_map(""Underline"")-local floating_highlight_map = make_highlight_map(""Floating"")-local sign_highlight_map = make_highlight_map(""Sign"")---- }}}--- Diagnostic Namespaces {{{ local DEFAULT_CLIENT_ID = -1-local get_client_id = function(client_id)+---@private+local function get_client_id(client_id)   if client_id == nil then     client_id = DEFAULT_CLIENT_ID   end    return client_id end -local get_bufnr = function(bufnr)+---@private+local function get_bufnr(bufnr)   if not bufnr then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   elseif bufnr == 0 then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   end    return bufnr end ----- Create a namespace table, used to track a client's buffer local items-local _make_namespace_table = function(namespace, api_namespace)-  vim.validate { namespace = { namespace, 's' } }--  return setmetatable({-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)-  }, {-    __index = function(t, client_id)-      client_id = get_client_id(client_id)--      if rawget(t, client_id) == nil then-        local value = string.format(""%s:%s"", namespace, client_id)--        if api_namespace then-          value = api.nvim_create_namespace(value)-        end--        rawset(t, client_id, value)-      end--      return rawget(t, client_id)-    end-  })-end--local _diagnostic_namespaces = _make_namespace_table(""vim_lsp_diagnostics"", true)-local _sign_namespaces = _make_namespace_table(""vim_lsp_signs"", false)- ---@private-function M._get_diagnostic_namespace(client_id)-  return _diagnostic_namespaces[client_id]+local function severity_lsp_to_vim(severity)+  if type(severity) == 'string' then+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]+  end+  return severity end  ---@private-function M._get_sign_namespace(client_id)-  return _sign_namespaces[client_id]-end--- }}}--- Diagnostic Buffer & Client metatables {{{-local bufnr_and_client_cacher_mt = {-  __index = function(t, bufnr)-    if bufnr == 0 or bufnr == nil then-      bufnr = vim.api.nvim_get_current_buf()-    end--    if rawget(t, bufnr) == nil then-      rawset(t, bufnr, {})-    end--    return rawget(t, bufnr)-  end,--  __newindex = function(t, bufnr, v)-    if bufnr == 0 or bufnr == nil then-      bufnr = vim.api.nvim_get_current_buf()-    end--    rawset(t, bufnr, v)-  end,-}--- }}}--- Diagnostic Saving & Caching {{{-local _diagnostic_cleanup = setmetatable({}, bufnr_and_client_cacher_mt)-local diagnostic_cache = setmetatable({}, bufnr_and_client_cacher_mt)-local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_client_cacher_mt)-local diagnostic_cache_lines = setmetatable({}, bufnr_and_client_cacher_mt)-local diagnostic_cache_counts = setmetatable({}, bufnr_and_client_cacher_mt)-local diagnostic_attached_buffers = {}---- Disabled buffers and clients-local diagnostic_disabled = setmetatable({}, bufnr_and_client_cacher_mt)--local _bufs_waiting_to_update = setmetatable({}, bufnr_and_client_cacher_mt)----- Store Diagnostic[] by line--------@param diagnostics Diagnostic[]----@return table<number, Diagnostic[]>-local _diagnostic_lines = function(diagnostics)-  if not diagnostics then return end--  local diagnostics_by_line = {}-  for _, diagnostic in ipairs(diagnostics) do-    local start = diagnostic.range.start-    local line_diagnostics = diagnostics_by_line[start.line]-    if not line_diagnostics then-      line_diagnostics = {}-      diagnostics_by_line[start.line] = line_diagnostics-    end-    table.insert(line_diagnostics, diagnostic)+local function severity_vim_to_lsp(severity)+  if type(severity) == 'string' then+    severity = vim.diagnostic.severity[severity]   end-  return diagnostics_by_line+  return severity end ---- Get the count of M by Severity--------@param diagnostics Diagnostic[]----@return table<DiagnosticSeverity, number>-local _diagnostic_counts = function(diagnostics)-  if not diagnostics then return end--  local counts = {}-  for _, diagnostic in pairs(diagnostics) do-    if diagnostic.severity then-      local val = counts[diagnostic.severity]-      if val == nil then-        val = 0-      end+---@private+local function line_byte_from_position(lines, lnum, col, offset_encoding)+  if offset_encoding == ""utf-8"" then+    return col+  end -      counts[diagnostic.severity] = val + 1-    end+  local line = lines[lnum + 1]+  local ok, result = pcall(vim.str_byteindex, line, col, offset_encoding == ""utf-16"")+  if ok then+    return result   end -  return counts+  return col end  ---@private---- Set the different diagnostic cache after `textDocument/publishDiagnostics`----@param diagnostics Diagnostic[]----@param bufnr number----@param client_id number----@return nil-local function set_diagnostic_cache(diagnostics, bufnr, client_id)-  client_id = get_client_id(client_id)--  -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#diagnostic-  ---  -- The diagnostic's severity. Can be omitted. If omitted it is up to the-  -- client to interpret diagnostics as error, warning, info or hint.-  -- TODO: Replace this with server-specific heuristics to infer severity.-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)-  for _, diagnostic in ipairs(diagnostics) do-    if diagnostic.severity == nil then-      diagnostic.severity = DiagnosticSeverity.Error-    end-    -- Account for servers that place diagnostics on terminating newline-    if buf_line_count > 0 then-      diagnostic.range.start.line = math.max(math.min(-        diagnostic.range.start.line, buf_line_count - 1-      ), 0)-      diagnostic.range[""end""].line = math.max(math.min(-        diagnostic.range[""end""].line, buf_line_count - 1-      ), 0)-    end+local function get_buf_lines(bufnr)+  if vim.api.nvim_buf_is_loaded(bufnr) then+    return vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)   end -  diagnostic_cache[bufnr][client_id] = diagnostics-  diagnostic_cache_lines[bufnr][client_id] = _diagnostic_lines(diagnostics)-  diagnostic_cache_counts[bufnr][client_id] = _diagnostic_counts(diagnostics)+  local filename = vim.api.nvim_buf_get_name(bufnr)+  local f = io.open(filename)+  local lines = vim.split(f:read(""*a""), ""\n"")+  f:close()+  return lines end +---@private+local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)+  local buf_lines = get_buf_lines(bufnr)+  local client = vim.lsp.get_client_by_id(client_id)+  local offset_encoding = client and client.offset_encoding or ""utf-8""",The specification uses UTF-16 and I think UTF-8 is the exception that is not even part of the specification. (afaik only clangd supports it).  So I'd tend to change the default value here,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15585,708393192,2021-09-14T15:32:56Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -57,338 +13,241 @@ end  local M = {} --- Diagnostic Highlights {{{---- TODO(tjdevries): Determine how to generate documentation for these---                  and how to configure them to be easy for users.------                  For now, just use the following script. It should work pretty good.---[[-local levels = {""Error"", ""Warning"", ""Information"", ""Hint"" }--local all_info = {-  { ""Default"", ""Used as the base highlight group, other highlight groups link to"", },-  { ""VirtualText"", 'Used for ""%s"" diagnostic virtual text.\n  See |vim.lsp.diagnostic.set_virtual_text()|', },-  { ""Underline"", 'Used to underline ""%s"" diagnostics.\n  See |vim.lsp.diagnostic.set_underline()|', },-  { ""Floating"", 'Used to color ""%s"" diagnostic messages in diagnostics float.\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },-  { ""Sign"", 'Used for ""%s"" signs in sing column.\n  See |vim.lsp.diagnostic.set_signs()|', },-}--local results = {}-for _, info in ipairs(all_info) do-  for _, level in ipairs(levels) do-    local name = info[1]-    local description = info[2]-    local fullname = string.format(""Lsp%s%s"", name, level)-    table.insert(results, string.format(-      ""%78s"", string.format(""*hl-%s*"", fullname))-    )--    table.insert(results, fullname)-    table.insert(results, string.format(""  %s"", description))-    table.insert(results, """")-  end-end---- print(table.concat(results, '\n'))-vim.fn.setreg(""*"", table.concat(results, '\n'))---]]--local diagnostic_severities = {-  [DiagnosticSeverity.Error]       = { guifg = ""Red"" };-  [DiagnosticSeverity.Warning]     = { guifg = ""Orange"" };-  [DiagnosticSeverity.Information] = { guifg = ""LightBlue"" };-  [DiagnosticSeverity.Hint]        = { guifg = ""LightGrey"" };-}---- Make a map from DiagnosticSeverity -> Highlight Name-local make_highlight_map = function(base_name)-  local result = {}-  for k, _ in pairs(diagnostic_severities) do-    result[k] = ""LspDiagnostics"" .. base_name .. DiagnosticSeverity[k]-  end--  return result-end--local default_highlight_map = make_highlight_map(""Default"")-local virtual_text_highlight_map = make_highlight_map(""VirtualText"")-local underline_highlight_map = make_highlight_map(""Underline"")-local floating_highlight_map = make_highlight_map(""Floating"")-local sign_highlight_map = make_highlight_map(""Sign"")---- }}}--- Diagnostic Namespaces {{{ local DEFAULT_CLIENT_ID = -1-local get_client_id = function(client_id)+---@private+local function get_client_id(client_id)   if client_id == nil then     client_id = DEFAULT_CLIENT_ID   end    return client_id end -local get_bufnr = function(bufnr)+---@private+local function get_bufnr(bufnr)   if not bufnr then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   elseif bufnr == 0 then-    return api.nvim_get_current_buf()+    return vim.api.nvim_get_current_buf()   end    return bufnr end ----- Create a namespace table, used to track a client's buffer local items-local _make_namespace_table = function(namespace, api_namespace)-  vim.validate { namespace = { namespace, 's' } }--  return setmetatable({-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)-  }, {-    __index = function(t, client_id)-      client_id = get_client_id(client_id)--      if rawget(t, client_id) == nil then-        local value = string.format(""%s:%s"", namespace, client_id)--        if api_namespace then-          value = api.nvim_create_namespace(value)-        end--        rawset(t, client_id, value)-      end--      return rawget(t, client_id)-    end-  })+---@private+local function severity_lsp_to_vim(severity)+  if type(severity) == 'string' then+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]+  end+  return severity end -local _diagnostic_namespaces = _make_namespace_table(""vim_lsp_diagnostics"", true)-local _sign_namespaces = _make_namespace_table(""vim_lsp_signs"", false)- ---@private-function M._get_diagnostic_namespace(client_id)-  return _diagnostic_namespaces[client_id]+local function severity_vim_to_lsp(severity)+  if type(severity) == 'string' then+    severity = vim.diagnostic.severity[severity]+  end+  return severity end  ---@private-function M._get_sign_namespace(client_id)-  return _sign_namespaces[client_id]+local function diagnostic_lsp_to_vim(diagnostics)+  return vim.tbl_map(function(diagnostic)+    local start = diagnostic.range.start+    local _end = diagnostic.range[""end""]+    return {+      lnum = start.line,+      col = start.character,+      end_lnum = _end.line,+      end_col = _end.character,",Looks good :+1: > This seems like a lot of additional complexity though and I'd want to be sure that the performance improvements are really worth it. So I'm leaning toward copying what folke did in #14615 first and then if we find that it's too slow we can try to be more clever.:100:,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15585,708408187,2021-09-14T15:49:19Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,520 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based+rows and columns). |api-indexing|++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++							*diagnostic-highlights*+All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding DiagnosticDefault highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is+linked to |hl-DiagnosticDefaultError|. To change the default (and+therefore the linked highlights), use the |:highlight| command: >++    highlight DiagnosticDefaultError guifg=""BrightRed""+<+						*hl-DiagnosticDefaultError*+DiagnosticDefaultError+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultWarn*+DiagnosticDefaultWarn+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultInfo*+DiagnosticDefaultInfo+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++						*hl-DiagnosticDefaultHint*+DiagnosticDefaultHint+  Used as the base highlight group.+  Other LspDiagnostic highlights link to this by default (except Underline)++					*hl-DiagnosticVirtualTextError*+DiagnosticVirtualTextError+  Used for ""Error"" diagnostic virtual text.++					*hl-DiagnosticVirtualTextWarn*+DiagnosticVirtualTextWarn+  Used for ""Warn"" diagnostic virtual text.++						*hl-DiagnosticVirtualTextInfo*+DiagnosticVirtualTextInfo+  Used for ""Info"" diagnostic virtual text.++						*hl-DiagnosticVirtualTextHint*+DiagnosticVirtualTextHint+  Used for ""Hint"" diagnostic virtual text.++						*hl-DiagnosticUnderlineError*+DiagnosticUnderlineError+  Used to underline ""Error"" diagnostics.++						*hl-DiagnosticUnderlineWarn*+DiagnosticUnderlineWarn+  Used to underline ""Warn"" diagnostics.++						*hl-DiagnosticUnderlineInfo*+DiagnosticUnderlineInfo+  Used to underline ""Info"" diagnostics.++						*hl-DiagnosticUnderlineHint*+DiagnosticUnderlineHint+  Used to underline ""Hint"" diagnostics.++						*hl-DiagnosticFloatingError*+DiagnosticFloatingError+  Used to color ""Error"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingWarn*+DiagnosticFloatingWarn+  Used to color ""Warn"" diagnostic messages in diagnostics float.++						*hl-DiagnosticFloatingInfo*+DiagnosticFloatingInfo+  Used to color ""Info"" diagnostic messages in diagnostics float.++						*hl-DiagnosticFloatingHint*+DiagnosticFloatingHint+  Used to color ""Hint"" diagnostic messages in diagnostics float.++						*hl-DiagnosticSignError*+DiagnosticSignError+  Used for ""Error"" signs in sign column.++						*hl-DiagnosticSignWarn*+DiagnosticSignWarn+  Used for ""Warn"" signs in sign column.++						*hl-DiagnosticSignInfo*+DiagnosticSignInfo+  Used for ""Info"" signs in sign column.++						*hl-DiagnosticSignHint*+DiagnosticSignHint+  Used for ""Hint"" signs in sign column.++==============================================================================+Events							*diagnostic-events*++							*DiagnosticsChanged*+DiagnosticsChanged	After diagnostics have changed in a loaded buffer.++Example: >+	autocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })+<++==============================================================================+Lua module: vim.diagnostic                                    *diagnostic-api*++config({opts}, {namespace})                          *vim.diagnostic.config()*+                Configure diagnostic options globally or for a specific+                diagnostic namespace.++                Note:+                    Each of the configuration options below accepts one of the+                    following:- `false`: Disable this feature - `true`: Enable this+                    feature, use default settings. - `table`: Enable this+                    feature with overrides. - `function`: Function with+                    signature (namespace, bufnr) that returns any of the+                    above.++                Parameters: ~+                    {opts}       table Configuration table with the following+                                 keys:+                                 ��� underline: (default true) Use underline for+                                   diagnostics+                                   |vim.diagnostic.set_underline()|+                                 ��� virtual_text: (default true) Use virtual+                                   text for diagnostics+                                   |vim.diagnostic.set_virtual_text()|+                                 ��� signs: (default true) Use signs for+                                   diagnostics |vim.diagnostic.set_signs()|+                                 ��� update_in_insert: (default false) Update+                                   diagnostics in Insert mode (if false,+                                   diagnostics are updated on InsertLeave)+                                 ��� severity_sort: (default false) Sort+                                   diagnostics by severity. This affects the+                                   order in which signs and virtual text are+                                   displayed+                    {namespace}  number|nil Update the options for the given+                                 namespace. When omitted, update the global+                                 diagnostic options.++disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*+                Disable diagnostics in the given buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer handle. Defaults to the+                                 current buffer.+                    {namespace}  number|nil Only disable diagnostics for the+                                 given namespace.++enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*+                Enable diagnostics in the given buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer handle. Defaults to the+                                 current buffer.+                    {namespace}  number|nil Only enable diagnostics for the+                                 given namespace.++get({bufnr}, {namespace})                               *vim.diagnostic.get()*+                Get all diagnostics for the buffer.++                Parameters: ~+                    {bufnr}      number|nil The buffer number to get+                                 diagnistics from. Use 0 for current buffer.+                                 If `nil` , retrieve diagnostics from all+                                 buffers.+                    {namespace}  number|nil Limit diagnostics to the given+                                 namespace.++                Return: ~+                    table A list of diagnostic items |diagnostic-structure|.++                                                  *vim.diagnostic.get_count()*+get_count({bufnr}, {severity}, {namespace})+                Get the number of diagnostics with the given severity.++                Useful for showing diagnostic counts in statusline. eg: >++                 function! DiagnosticStatus() abort+                   let sl = ''+                   let sl .= 'E: %{luaeval(""vim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)"")} '+                   let sl .= 'W: %{luaeval(""vim.diagnostic.get_count(0, vim.diagnostic.severity.WARN)"")}'+                   return sl+                 endfunction+<++                Then simply add `%{DiagnosticStatus()}` to your statusline.++                Parameters: ~+                    {bufnr}      number|nil The buffer number. Use 0 for+                                 current buffer. If `nil` , count diagnostics+                                 from all buffers.+                    {severity}   |vim.diagnostic.severity| Count only+                                 diagnostics for the given severity. If+                                 omitted, count all diagnostics.+                    {namespace}  number|nil Count only diagnostics from the+                                 given namespace.++                                       *vim.diagnostic.get_line_diagnostics()*+get_line_diagnostics({bufnr}, {lnum}, {opts})+                Get diagnostics by line.++                Parameters: ~+                    {namespace}  number|nil Limit diagnostics to the given+                                 namespace. If `nil` , retrieve diagnostics+                                 from all namespaces.+                    {bufnr}      number|nil The buffer number. Defaults to the+                                 current buffer.+                    {lnum}       number|nil The line number. Defaults to the+                                 current line.+                    {opts}       table|nil A table with the following keys:+                                 ��� namespace: (number) Limit diagnostics to+                                   the given namespace.+                                 ��� severity: (|vim.diagnostic.severity|) Only+                                   return diagnostics with this severity.+                                   Conflicts with {min_severity}.+                                 ��� min_severity: (|vim.diagnostic.severity|)+                                   Return diagnostics with this severity or+                                   worse. Conflicts with {severity}.++                Return: ~+                    table Table with map of line number to list of+                    diagnostics.++get_next({opts})                                   *vim.diagnostic.get_next()*+                Get the next diagnostic closest to the cursor position.++                Parameters: ~+                    {opts}  table See |vim.diagnostic.goto_next()|++                Return: ~+                    table Next diagnostic++get_next_pos({opts})                           *vim.diagnostic.get_next_pos()*+                Return the position of the next diagnostic in the current+                buffer.++                Parameters: ~+                    {opts}  table See |vim.diagnostic.goto_next()|++                Return: ~+                    table Next diagnostic position as a (row, col) tuple.++get_prev({opts})                                   *vim.diagnostic.get_prev()*+                Get the previous diagnostic closest to the cursor position.++                Parameters: ~+                    {opts}  table See |vim.diagnostic.goto_next()|++                Return: ~+                    table Previous diagnostic++get_prev_pos({opts})                           *vim.diagnostic.get_prev_pos()*+                Return the position of the previous diagnostic in the current+                buffer.++                Parameters: ~+                    {opts}  table See |vim.diagnostic.goto_next()|++                Return: ~+                    table Previous diagnostic position as a (row, col) tuple.++                                       *vim.diagnostic.get_virt_text_chunks()*+get_virt_text_chunks({line_diags}, {opts})+                Get virtual text chunks to display using+                |nvim_buf_set_extmark()|.++                Parameters: ~+                    {line_diags}  table The diagnostics associated with the+                                  line |vim.diagnostic.get_line_diagnostics()|+                    {opts}        table|nil Configuration table with the+                                  following keys:+                                  ��� prefix: (string) Prefix to display before+                                    virtual text on line+                                  ��� spacing: (number) Number of spaces to+                                    insert before virtual text++                Return: ~+                    an array of [text, hl_group] arrays. This can be passed+                    directly to the {virt_text} option of+                    |nvim_buf_set_extmark()|.++goto_next({opts})                                 *vim.diagnostic.goto_next()*+                Move to the next diagnostic.++                Parameters: ~+                    {opts}  table|nil Configuration table with the following+                            keys:+                            ��� namespace: (number) Only consider diagnostics+                              from the given namespace.+                            ��� cursor_position: (cursor position) Cursor+                              position as a (row, col) tuple. See+                              |nvim_win_get_cursor()|. Defaults to the current+                              cursor position.+                            ��� wrap: (boolean, default true) Whether to loop+                              around file or not. Similar to 'wrapscan'.+                            ��� severity: (|vim.diagnostic.severity|) Only+                              return diagnostics with this severity. Conflicts+                              with {min_severity}.+                            ��� min_severity: (|vim.diagnostic.severity|) Return+                              diagnostics with this severity or worse.+                              Conflicts with {severity}.+                            ��� enable_popup: (boolean, default true) Call+                              |vim.diagnostic.show_line_diagnostics()| on+                              jump.+                            ��� popup_opts: (table) Table to pass as {opts}+                              parameter to+                              |vim.diagnostic.show_line_diagnostics()|+                            ��� win_id: (number, default 0) Window ID++goto_prev({opts})                                 *vim.diagnostic.goto_prev()*+                Move to the previous diagnostic in the current buffer.++                Parameters: ~+                    {opts}  table See |vim.diagnostic.goto_next()|++hide({namespace}, {bufnr})                             *vim.diagnostic.hide()*+                Hide currently displayed diagnostics.++                This only clears the decorations displayed in the buffer.+                Diagnostics can be redisplayed with |vim.diagnostic.show()|.+                To completely remove diagnostics, use+                |vim.diagnostic.reset()|.++                Parameters: ~+                    {namespace}  number The diagnostic namespace+                    {bufnr}      number|nil Only clear diagnostics in the+                                 given buffer. Defaults to the current buffer.++reset({namespace}, {bufnr})                           *vim.diagnostic.reset()*+                Remove all diagnostics from the given namespace.++                Unlike |vim.diagnostic.hide()|, this function removes all+                saved diagnostics. They cannot be redisplayed using+                |vim.diagnostic.show()|. To simply remove diagnostic+                decorations in a way that they can be re-displayed, use+                |vim.diagnostic.hide()|.++                Parameters: ~+                    {namespace}  number+                    {bufnr}      number|nil Remove diagnostics for the given+                                 buffer. If omitted, diagnostics are removed+                                 for all buffers.++set({namespace}, {diagnostics}, {bufnr}, {opts})        *vim.diagnostic.set()*+                Set diagnostics for the given namespace and buffer.++                Parameters: ~+                    {namespace}    number The diagnostic namespace+                    {diagnostics}  table A list of diagnostic items+                                   |diagnostic-structure|+                    {bufnr}        number|nil The buffer to set diagnostics+                                   for. Defaults to the current buffer.+                    {opts}         table|nil Display options to pass to+                                   |vim.diagnostic.show()|++setloclist({opts})                               *vim.diagnostic.setloclist()*+                Add diagnostics to the location list.++                By default, adds diagnostics for the current buffer in all+                namespaces.++                Parameters: ~+                    {opts}  table|nil Configuration table with the following+                            keys:+                            ��� namespace: (number) Only add diagnostics from+                              the given namespace.+                            ��� bufnr: (number, default 0) Only add diagnostics","instead of `buffer` shouldn't this function take an (optional) window? IIUC if the buffer is displayed in multiple windows, each window still has a separate loclist.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15658,708424846,2021-09-14T16:07:54Z,src/nvim/lua/executor.c,"@@ -1043,12 +1234,19 @@ LuaRef nlua_ref(lua_State *lstate, int index)   lua_pushvalue(lstate, index);   LuaRef ref = luaL_ref(lstate, LUA_REGISTRYINDEX);   if (ref > 0) {-    nlua_refcount++;+    nlua_inc_refcount(lstate);","This much extra complexity for a what is supposed to be a primitive operation is a bit unfortunate. But AFAIK, references tracked by nvim is only used by editor state keeping refs to lua, so these won't be used by lua threads anyway. So for now we could just revert this and document `nlua_ref` is not to be used for threads.  But if we do later on, we should add a single userdata for thread-local state which can passed as a _c pointer_ to internal helper functions so there only will be one register (read) access per enter c code from lua to get this struct.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15620,708447603,2021-09-14T16:35:58Z,scripts/lintcommit.lua,"@@ -0,0 +1,34 @@+local current_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))+local ancestor_commit = vim.trim(vim.fn.system({'git', 'merge-base', 'master', current_branch}))+local commits_on_current_pr = vim.trim(vim.fn.system({'git', 'rev-list', ancestor_commit .. "".."" .. current_branch}))++local all_commits = {}+for substring in commits_on_current_pr:gmatch(""%S+"") do+   table.insert(all_commits, substring)","Looks like `commits_on_current_pr` and `all_commits` are semantically the same but just different in their structure. This is an example of the peril of ""premature explanation"": `commits_on_current_pr` has an elaborate (prematurely-explained) name and but is actually just an intermediate container. Then `all_commits` struggles to find a different name.I would rename them as:- `commits_on_current_pr` => `commits_str`- `all_commits` => `commits`(Of course, this script has a small scope so it ""doesn't matter"", but I mention this for reference  in future/bigger contributions. Also in any case where it ""doesn't matter"", it's less confusing to use meaningless names than pseudo-meaningful names.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15620,708449684,2021-09-14T16:38:43Z,scripts/lintcommit.lua,"@@ -0,0 +1,44 @@+function commit_message_is_ok(commit_message)+  if string.match(commit_message, '^ci: .*$') then+    return true+  end+end++function main()+  local current_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))+  local ancestor_commit = vim.trim(vim.fn.system({'git', 'merge-base', 'master', current_branch}))+  local commits_on_current_pr = vim.trim(vim.fn.system({'git', 'rev-list', ancestor_commit .. "".."" .. current_branch}))++  local all_commits = {}+  for substring in commits_on_current_pr:gmatch(""%S+"") do+     table.insert(all_commits, substring)+  end++  for index, commit_hash in ipairs(all_commits) do+    local message = vim.trim(vim.fn.system({'git', 'show', '-s', '--format=%s' , commit_hash}))+    if not commit_message_is_ok(message) then+      vim.cmd(""cquit 1"")+    end+  end+end++function testing()","this is a good pattern for our scripts, I would keep it around as an optional thing (in case you planned to remove it). Maybe `_self_test` or `_test`.```suggestionfunction _test()```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15632,708459457,2021-09-14T16:51:05Z,runtime/doc/options.txt,"@@ -4878,9 +4878,12 @@ A jump table for the options with a short description can be found at |Q_op|. 	   ordering.  This is for preferences to overrule or add to the  	   distributed defaults or system-wide settings (rarely needed). -	More entries are added when using |packages|.  If it gets very long-	then `:set rtp` will be truncated, use `:echo &rtp` to see the full-	string.+							*rtp-packages*+	""start"" packages will additionally be used to search for runtime files+	after these, but package entries are not visible in `:set rtp`, as the+	final path would be too long and get truncated. use",```suggestion	final path would be too long and get truncated. Use```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15547,708487861,2021-09-14T17:31:24Z,src/nvim/testdir/test_diffmode.vim,"@@ -965,6 +965,30 @@ func Test_diff_screen()   call delete('XdiffSetup') endfunc +func Test_diff_with_scroll_and_change()+  CheckScreendump","this test will be skipped because Nvim does not use Vim screen tests. we need a lua screen test that mimics this one. It is pretty easy, see [test/functional/example_spec.lua](https://github.com/neovim/neovim/blob/master/test/functional/example_spec.lua) for example. You can [run the test](https://github.com/neovim/neovim/blob/master/test/README.md#running-tests) like this:    TEST_FILE=test/functional/example_spec.lua make functionaltest",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15669,708635559,2021-09-14T21:11:02Z,src/nvim/msgpack_rpc/helpers.c,"@@ -48,15 +47,17 @@ static msgpack_sbuffer sbuffer;   } \   \   static void msgpack_rpc_from_##lt(Integer o, msgpack_packer *res) \+  /* *INDENT-OFF* */ \","this is hideously ugly, but imma gonna de-monomorphise this entire block very soon, so it doesn't matter either way if this is like the only case or two in the codebase.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15669,708958725,2021-09-15T08:26:58Z,src/nvim/msgpack_rpc/helpers.c,"@@ -385,43 +384,43 @@ void msgpack_rpc_from_object(const Object result, msgpack_packer *const res)                   && kObjectTypeTabpage == kObjectTypeWindow + 1,                   ""Buffer, window and tabpage enum items are in order"");     switch (cur.aobj->type) {-      case kObjectTypeNil:-      case kObjectTypeLuaRef: {+    case kObjectTypeNil:+    case kObjectTypeLuaRef: {","I removed the extra indentation inside braces in case, I *think* that should solve the issue with the bad indentation of `}`. The fix affected a lot of other code though, so please check it didn't mess up anything else in the process.If this doesn't work it's also possible to remove the braces if there are no variable declarations inside.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,709050772,2021-09-15T10:23:48Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","might be out of scope for this PR, but I am surprised to see that we have a module where require() does global side-effects. That is an anti-pattern. require() should always be safe. Callers should explicitly do something like `require('vim.disagnostic').init()`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,709088417,2021-09-15T11:21:14Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,524 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++Generally speaking, the API is split between functions meant to be used by+diagnostic producers and those meant for diagnostic consumers (i.e. end users+who want to read and view the diagnostics for a buffer).  The APIs for+producers require a {namespace} as their first argument, while those for+consumers generally do not require a namespace (though often one may be+optionally supplied).  A good rule of thumb is that if a method is meant to+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it+requires a namespace.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based+rows and columns). |api-indexing|++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++==============================================================================+HIGHLIGHTS						*diagnostic-highlights*++All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding DiagnosticDefault highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is+linked to |hl-DiagnosticDefaultError|. To change the default (and+therefore the linked highlights), use the |:highlight| command: >++    highlight DiagnosticDefaultError guifg=""BrightRed""+<+						*hl-DiagnosticDefaultError*+DiagnosticDefaultError","since we are renaming these anyway let's remove ""Default"" from the highlight names. Don't want this pattern to proliferate. It is redundant and unnecessary. All highlights may (or may not) have ""default"" forms.```suggestionDiagnosticError```",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15111,709127390,2021-09-15T12:18:43Z,test/functional/ex_cmds/source_spec.lua,"@@ -60,6 +60,15 @@ describe(':source', function()     eq('Vim(let):E15: Invalid expression: #{', exc_exec(""'<,'>source""))   end) +  it('does not break if current buffer is modified while sourced', function()+    insert [[+      bw!","My bad, I'm so used to using `bw` that I sometimes forget it's shortened ����",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15620,709133130,2021-09-15T12:26:11Z,scripts/lintcommit.lua,"@@ -0,0 +1,69 @@+-- Get length of table+function get_table_length(table)+  local length = 0+  for n in pairs(table) do +    length = length + 1 +  end+  return length+end++-- Split a string+function string:split(delimiter)","OK, I'm beginning to see a pattern here :). I'll check `lua.txt` for the function I'm looking for before I copy code from online.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,709175034,2021-09-15T13:15:44Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","> We could expose some method like `_setup_highlight_groups()` but that would _only_ be used in this one test. Not sure that is worth it IMO.Just an `init()` is all that's needed. We're already implicitly doing it.> but it's idempotent.Yeah but people copy the pattern and then start doing other things. Also,- even idempotent effects are surprising. Imagine if require() is called by some other component somewhere earlier in Nvim startup; now state that previously wasn't available is available. This could affect scripts or whatever, and it's harder to track down because nothing is explicitly calling `require(..).init()`.- For documentation/communication, it is clearer to have a simple guideline: ""require() should not have side-effects"".",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,709180950,2021-09-15T13:22:08Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","What do you think of the suggestion of defining the groups directly in `syntax.c`? That would remove the need for any kind of init() altogether.Having to call init() bothers me as that's not a pattern used anywhere else in the Lua API. There is no `vim.api.init()` or `vim.lsp.init()`: users just use the API without thinking about having to initialize it. Having users manually initialize the system just doesn't feel right to me. But I also understand that 'require' shouldn't have side effects, and since we're just defining highlight groups it seems we can solve both problems at once by defining these highlights in the same place that we define all the other groups.Or we can just remove the test that checks for the highlight groups ���� ",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15585,709190943,2021-09-15T13:32:49Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","Either is fine, I think -- for LSP, we also did not predefine highlight groups and explicitly mentioned in the documentation that these need to be defined by the user.However, that _did_ lead to repeated questions since not everybody reads the documentation...So I would prefer if these were just defined in `syntax.c` (as they are now no longer LSP-specific) so that colorschemes can redefine them easily.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15585,709202045,2021-09-15T13:44:22Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","> Either is fine, I think -- for LSP, we also did not predefine highlight groups and explicitly mentioned in the documentation that these need to be defined by the user.This is not correct. I copied this pattern from the existing code:https://github.com/neovim/neovim/blob/afdc9e61502a9f02c8cf5156652a1bde027e4345/runtime/lua/vim/lsp.lua#L1538So already, accessing `vim.lsp` has the same side effects that `vim.diagnostic` would have (i.e. defining highlight groups).Just wanted to clarify that I'm not introducing anything new here, just sticking with the status quo. > So I would prefer if these were just defined in syntax.c (as they are now no longer LSP-specific) so that colorschemes can redefine them easily.+1",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,709205053,2021-09-15T13:47:25Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,524 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++Generally speaking, the API is split between functions meant to be used by+diagnostic producers and those meant for diagnostic consumers (i.e. end users+who want to read and view the diagnostics for a buffer).  The APIs for+producers require a {namespace} as their first argument, while those for+consumers generally do not require a namespace (though often one may be+optionally supplied).  A good rule of thumb is that if a method is meant to+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it+requires a namespace.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based+rows and columns). |api-indexing|++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++==============================================================================+HIGHLIGHTS						*diagnostic-highlights*++All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding default highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is linked+to |hl-DiagnosticError|. To change the default (and therefore the linked+highlights), use the |:highlight| command: >++    highlight DiagnosticError guifg=""BrightRed""+<+							*hl-DiagnosticError*+DiagnosticError+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++							*hl-DiagnosticWarn*+DiagnosticWarn+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++							*hl-DiagnosticInfo*+DiagnosticInfo+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++							*hl-DiagnosticHint*+DiagnosticHint+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++					*hl-DiagnosticVirtualTextError*+DiagnosticVirtualTextError+  Used for ""Error"" diagnostic virtual text.++					*hl-DiagnosticVirtualTextWarn*+DiagnosticVirtualTextWarn+  Used for ""Warn"" diagnostic virtual text.++						*hl-DiagnosticVirtualTextInfo*+DiagnosticVirtualTextInfo+  Used for ""Info"" diagnostic virtual text.++						*hl-DiagnosticVirtualTextHint*+DiagnosticVirtualTextHint+  Used for ""Hint"" diagnostic virtual text.++						*hl-DiagnosticUnderlineError*+DiagnosticUnderlineError+  Used to underline ""Error"" diagnostics.++						*hl-DiagnosticUnderlineWarn*+DiagnosticUnderlineWarn+  Used to underline ""Warn"" diagnostics.++						*hl-DiagnosticUnderlineInfo*+DiagnosticUnderlineInfo+  Used to underline ""Info"" diagnostics.++						*hl-DiagnosticUnderlineHint*+DiagnosticUnderlineHint+  Used to underline ""Hint"" diagnostics.++						*hl-DiagnosticFloatingError*+DiagnosticFloatingError+  Used to color ""Error"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingWarn*+DiagnosticFloatingWarn+  Used to color ""Warn"" diagnostic messages in diagnostics float.++						*hl-DiagnosticFloatingInfo*+DiagnosticFloatingInfo+  Used to color ""Info"" diagnostic messages in diagnostics float.++						*hl-DiagnosticFloatingHint*+DiagnosticFloatingHint+  Used to color ""Hint"" diagnostic messages in diagnostics float.++						*hl-DiagnosticSignError*+DiagnosticSignError+  Used for ""Error"" signs in sign column.++						*hl-DiagnosticSignWarn*+DiagnosticSignWarn+  Used for ""Warn"" signs in sign column.++						*hl-DiagnosticSignInfo*+DiagnosticSignInfo+  Used for ""Info"" signs in sign column.++						*hl-DiagnosticSignHint*+DiagnosticSignHint+  Used for ""Hint"" signs in sign column.++==============================================================================+EVENTS							*diagnostic-events*++							*DiagnosticsChanged*+DiagnosticsChanged	After diagnostics have changed.++Example: >+	autocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })+<++==============================================================================+Lua module: vim.diagnostic                                    *diagnostic-api*++config({opts}, {namespace})                          *vim.diagnostic.config()*+                Configure diagnostic options globally or for a specific+                diagnostic namespace.++                Note:+                    Each of the configuration options below accepts one of the+                    following:+                    ��� `false` : Disable this feature+                    ��� `true` : Enable this feature, use default settings.+                    ��� `table` : Enable this feature with overrides.+                    ��� `function` : Function with signature (namespace, bufnr)+                      that returns any of the above.++                Parameters: ~+                    {opts}       table Configuration table with the following+                                 keys:+                                 ��� underline: (default true) Use underline for+                                   diagnostics+                                 ��� virtual_text: (default true) Use virtual+                                   text for diagnostics+                                 ��� signs: (default true) Use signs for+                                   diagnostics+                                 ��� update_in_insert: (default false) Update+                                   diagnostics in Insert mode (if false,+                                   diagnostics are updated on InsertLeave)+                                 ��� severity_sort: (default false) Sort+                                   diagnostics by severity. This affects the+                                   order in which signs and virtual text are+                                   displayed+                    {namespace}  number|nil Update the options for the given+                                 namespace. When omitted, update the global+                                 diagnostic options.++disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*+                Disable diagnostics in the given buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer number. Defaults to the+                                 current buffer.+                    {namespace}  number|nil Only disable diagnostics for the+                                 given namespace.++enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*+                Enable diagnostics in the given buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer number. Defaults to the+                                 current buffer.+                    {namespace}  number|nil Only enable diagnostics for the+                                 given namespace.++get({bufnr}, {namespace})                               *vim.diagnostic.get()*+                Get all diagnostics for the buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer number to get diagnistics+                                 from. Use 0 for current buffer. When omitted,+                                 retrieve diagnostics from all buffers.+                    {namespace}  number|nil Limit diagnostics to the given+                                 namespace.++                Return: ~+                    table A list of diagnostic items |diagnostic-structure|.++                                                  *vim.diagnostic.get_count()*+get_count({bufnr}, {severity}, {namespace})+                Get the number of diagnostics with the given severity.++                Useful for showing diagnostic counts in the |status-line|.+                Example: >++                 function! DiagnosticStatus() abort+                   let sl = ''+                   let sl .= 'E: %{luaeval(""vim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)"")} '+                   let sl .= 'W: %{luaeval(""vim.diagnostic.get_count(0, vim.diagnostic.severity.WARN)"")}'+                   return sl+                 endfunction+<++                Then simply add `%{DiagnosticStatus()}` to 'statusline'.++                Parameters: ~+                    {bufnr}      number|nil Buffer number. Use 0 for current+                                 buffer. When omitted, count diagnostics from+                                 all buffers.+                    {severity}   |vim.diagnostic.severity| Count only+                                 diagnostics for the given severity. When+                                 omitted, count all diagnostics.+                    {namespace}  number|nil Count only diagnostics from the+                                 given namespace.++                                       *vim.diagnostic.get_line_diagnostics()*+get_line_diagnostics({bufnr}, {lnum}, {opts})","- for parallel form with `get()` we can name this `get_by_linenr`. (Don't need to repeat ""diagnostics"" in the name)- alternatively I would consider adding an optional `opt.linenr` param to `get()`, then we don't need this extra function.- OTOH, I see this has a counterpart in `show_line_diagnostics` , so maybe just leave it. Else that would need to be renamed to something like `show_at_line````suggestionget_by_linenr({bufnr}, {lnum}, {opts})```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15585,709208419,2021-09-15T13:50:45Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","> This is not correct. I copied this pattern from the existing code:Ah, that's relatively new. The documentation still claims that you need to define them (which really did use to be the case, at least for some, before that was changed).In any case, defining them in `syntax.c` is much cleaner IMHO. (I suspect the only reason they are currently defined the way they are is that TJ would only touch the C code if held at gunpoint ;))",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,709212424,2021-09-15T13:54:41Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","> What do you think of the suggestion of defining the groups directly in `syntax.c`? That would remove the need for any kind of init() altogether.No, I don't think we should start mixing parts of the LSP framework into the C core. That makes it hard to reason about and hard to explain.> Having to call init() bothers me as that's not a pattern used anywhere else in the Lua API. There is no `vim.api.init()` or `vim.lsp.init()`: users just use the API without thinking about having to initialize it. Having users manually initialize the system just doesn't feel right to me.on second thought, we already have a pattern for this: `plugin/foo.vim` and `lua/foo/init.vim`. Don't need `init()`.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15585,709215093,2021-09-15T13:57:22Z,test/functional/plugin/lsp_spec.lua,"@@ -1039,7 +1039,7 @@ describe('LSP', function()       'LspDiagnosticsVirtualTextHint',       'LspDiagnosticsVirtualTextInformation',       'LspDiagnosticsVirtualTextWarning',-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))","But this is no longer LSP-specific but a more general diagnostic framework? (The argument still applies, of course, albeit more weakly.)",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,709261642,2021-09-15T14:44:58Z,src/nvim/CMakeLists.txt,"@@ -63,6 +63,7 @@ set(LINT_SUPPRESS_FILE ${PROJECT_BINARY_DIR}/errors.json) set(LINT_SUPPRESS_URL_BASE ""https://raw.githubusercontent.com/neovim/doc/gh-pages/reports/clint"") set(LINT_SUPPRESS_URL ""${LINT_SUPPRESS_URL_BASE}/errors.json"") set(LINT_PRG ${PROJECT_SOURCE_DIR}/src/clint.py)+set(CLANG_TIDY_CONFIG_FILE ${PROJECT_SOURCE_DIR}/.clang-tidy)",~~Oh I forgot to point it to the build directory.~~ I also removed the step with linking the database. I'll fix it ASAP.  Edit: I got confused by what I was looking at. I needed to explicitly set that flag for `CodeChecker`. But you're absolutely right about it being redundant here. That can always be verified by appending the `--dump-config` flag.,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15601,709283702,2021-09-15T15:07:41Z,src/nvim/screen.c,"@@ -7778,20 +7797,20 @@ void limit_screen_size(void)  void win_new_shellsize(void) {-  static long old_Rows = 0;-  static long old_Columns = 0;+  static long old_rows = 0;+  static long old_columns = 0;",Yeah this is part of the naming convention [rules](https://github.com/neovim/neovim/pull/15601/files#diff-0534891fbc8b89b4c521057e7e8dff70d3cbeb822cc9991a3abad77848c289f8R35-R36): > clang-tidy: Invalid case style for variable 'old_Columns' (fix available) [readability-identifier-naming],
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/15211,709509190,2021-09-15T19:25:34Z,src/nvim/eval.c,"@@ -2332,7 +2371,50 @@ static void set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv,   if (lp->ll_tv == NULL) {     cc = *endp;     *endp = NUL;-    if (op != NULL && *op != '=') {+    if (lp->ll_blob != NULL) {+      if (op != NULL && *op != '=') {+        EMSG2(_(e_letwrong), op);+        return;+      }+      if (var_check_lock(lp->ll_blob->bv_lock, lp->ll_name, TV_CSTRING)) {+        return;+      }++      if (lp->ll_range && rettv->v_type == VAR_BLOB) {+        if (lp->ll_empty2) {+          lp->ll_n2 = tv_blob_len(lp->ll_blob) - 1;+        }++        if (lp->ll_n2 - lp->ll_n1 + 1 != tv_blob_len(rettv->vval.v_blob)) {+          EMSG(_(""E972: Blob value does not have the right number of bytes""));+          return;+        }+        if (lp->ll_empty2) {+          lp->ll_n2 = tv_blob_len(lp->ll_blob);+        }++        for (int il = lp->ll_n1, ir = 0; il <= lp->ll_n2; il++) {+          tv_blob_set(lp->ll_blob, il, tv_blob_get(rettv->vval.v_blob, ir++));+        }+      } else {+        bool error = false;+        if (!error) {","This is dead code.It is missing `tv_get_number_chk(rettv, &error)`.Vim patch had the following:```diff+		val = (int)tv_get_number_chk(rettv, &error);+		if (!error)+		{+		    garray_T *gap = &lp->ll_blob->bv_ga;++		    // Allow for appending a byte.  Setting a byte beyond+		    // the end is an error otherwise.+		    if (lp->ll_n1 < gap->ga_len+			    || (lp->ll_n1 == gap->ga_len+				&& ga_grow(&lp->ll_blob->bv_ga, 1) == OK))+		    {+			blob_set(lp->ll_blob, lp->ll_n1, val);+			if (lp->ll_n1 == gap->ga_len)+			    ++gap->ga_len;+		    }+		    else+			EMSG(_(e_invrange));+		}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15585,709522623,2021-09-15T19:47:01Z,runtime/doc/diagnostic.txt,"@@ -0,0 +1,484 @@+*diagnostic.txt*   Diagnostics+++                            NVIM REFERENCE MANUAL+++Diagnostic framework                                     *vim.diagnostic*++Nvim provides a framework for displaying errors or warnings from external+tools, otherwise known as ""diagnostics"". These diagnostics can come from a+variety of sources, such as linters or LSP servers. The diagnostic framework+is an extension to existing error handling functionality such as the+|quickfix| list.++                                      Type |gO| to see the table of contents.++==============================================================================+QUICKSTART                                              *diagnostic-quickstart*++Anything that reports diagnostics is referred to below as a ""diagnostic+producer"". Diagnostic producers need only follow a few simple steps to+report diagnostics:++1. Create a namespace |nvim_create_namespace()|. Note that the namespace must+   have a name. Anonymous namespaces WILL NOT WORK.+2. (Optional) Configure options for the diagnostic namespace+   |vim.diagnostic.config()|.+3. Generate diagnostics.+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.+5. Repeat from step 3.++Generally speaking, the API is split between functions meant to be used by+diagnostic producers and those meant for diagnostic consumers (i.e. end users+who want to read and view the diagnostics for a buffer).  The APIs for+producers require a {namespace} as their first argument, while those for+consumers generally do not require a namespace (though often one may be+optionally supplied).  A good rule of thumb is that if a method is meant to+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it+requires a namespace.++							*diagnostic-structure*+A diagnostic is a Lua table with the following keys:++	lnum: The starting line of the diagnostic+	end_lnum: The final line of the diagnostic+	col: The starting column of the diagnostic+	end_col: The final column of the diagnostic+	severity: The severity of the diagnostic |vim.diagnostic.severity|+	message: The diagnostic text++Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based+rows and columns). |api-indexing|++				*vim.diagnostic.severity* *diagnostic-severity*+The ""severity"" key in a diagnostic is one of the values defined in+`vim.diagnostic.severity`:++	vim.diagnostic.severity.ERROR+	vim.diagnostic.severity.WARN+	vim.diagnostic.severity.INFO+	vim.diagnostic.severity.HINT++==============================================================================+HIGHLIGHTS						*diagnostic-highlights*++All highlights defined for diagnostics begin with `Diagnostic` followed by+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.+`Error`, `Warn`, etc.)++Sign, underline and virtual text highlights (by default) are linked to their+corresponding default highlight.++For example, the default highlighting for |hl-DiagnosticSignError| is linked+to |hl-DiagnosticError|. To change the default (and therefore the linked+highlights), use the |:highlight| command: >++    highlight DiagnosticError guifg=""BrightRed""+<+							*hl-DiagnosticError*+DiagnosticError+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++							*hl-DiagnosticWarn*+DiagnosticWarn+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++							*hl-DiagnosticInfo*+DiagnosticInfo+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++							*hl-DiagnosticHint*+DiagnosticHint+  Used as the base highlight group.+  Other Diagnostic highlights link to this by default (except Underline)++					*hl-DiagnosticVirtualTextError*+DiagnosticVirtualTextError+  Used for ""Error"" diagnostic virtual text.++					*hl-DiagnosticVirtualTextWarn*+DiagnosticVirtualTextWarn+  Used for ""Warn"" diagnostic virtual text.++						*hl-DiagnosticVirtualTextInfo*+DiagnosticVirtualTextInfo+  Used for ""Info"" diagnostic virtual text.++						*hl-DiagnosticVirtualTextHint*+DiagnosticVirtualTextHint+  Used for ""Hint"" diagnostic virtual text.++						*hl-DiagnosticUnderlineError*+DiagnosticUnderlineError+  Used to underline ""Error"" diagnostics.++						*hl-DiagnosticUnderlineWarn*+DiagnosticUnderlineWarn+  Used to underline ""Warn"" diagnostics.++						*hl-DiagnosticUnderlineInfo*+DiagnosticUnderlineInfo+  Used to underline ""Info"" diagnostics.++						*hl-DiagnosticUnderlineHint*+DiagnosticUnderlineHint+  Used to underline ""Hint"" diagnostics.++						*hl-DiagnosticFloatingError*+DiagnosticFloatingError+  Used to color ""Error"" diagnostic messages in diagnostics float.+  See |vim.diagnostic.show_line_diagnostics()|++						*hl-DiagnosticFloatingWarn*+DiagnosticFloatingWarn+  Used to color ""Warn"" diagnostic messages in diagnostics float.++						*hl-DiagnosticFloatingInfo*+DiagnosticFloatingInfo+  Used to color ""Info"" diagnostic messages in diagnostics float.++						*hl-DiagnosticFloatingHint*+DiagnosticFloatingHint+  Used to color ""Hint"" diagnostic messages in diagnostics float.++						*hl-DiagnosticSignError*+DiagnosticSignError+  Used for ""Error"" signs in sign column.++						*hl-DiagnosticSignWarn*+DiagnosticSignWarn+  Used for ""Warn"" signs in sign column.++						*hl-DiagnosticSignInfo*+DiagnosticSignInfo+  Used for ""Info"" signs in sign column.++						*hl-DiagnosticSignHint*+DiagnosticSignHint+  Used for ""Hint"" signs in sign column.++==============================================================================+EVENTS							*diagnostic-events*++							*DiagnosticsChanged*+DiagnosticsChanged	After diagnostics have changed.++Example: >+	autocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })+<++==============================================================================+Lua module: vim.diagnostic                                    *diagnostic-api*++config({opts}, {namespace})                          *vim.diagnostic.config()*+                Configure diagnostic options globally or for a specific+                diagnostic namespace.++                Note:+                    Each of the configuration options below accepts one of the+                    following:+                    ��� `false` : Disable this feature+                    ��� `true` : Enable this feature, use default settings.+                    ��� `table` : Enable this feature with overrides.+                    ��� `function` : Function with signature (namespace, bufnr)+                      that returns any of the above.++                Parameters: ~+                    {opts}       table Configuration table with the following+                                 keys:+                                 ��� underline: (default true) Use underline for+                                   diagnostics+                                 ��� virtual_text: (default true) Use virtual+                                   text for diagnostics+                                 ��� signs: (default true) Use signs for+                                   diagnostics+                                 ��� update_in_insert: (default false) Update+                                   diagnostics in Insert mode (if false,+                                   diagnostics are updated on InsertLeave)+                                 ��� severity_sort: (default false) Sort+                                   diagnostics by severity. This affects the+                                   order in which signs and virtual text are+                                   displayed+                    {namespace}  number|nil Update the options for the given+                                 namespace. When omitted, update the global+                                 diagnostic options.++disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*+                Disable diagnostics in the given buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer number. Defaults to the+                                 current buffer.+                    {namespace}  number|nil Only disable diagnostics for the+                                 given namespace.++enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*+                Enable diagnostics in the given buffer.++                Parameters: ~+                    {bufnr}      number|nil Buffer number. Defaults to the+                                 current buffer.+                    {namespace}  number|nil Only enable diagnostics for the+                                 given namespace.++get({bufnr}, {opts})                                    *vim.diagnostic.get()*+                Get all diagnostics for the buffer.++                Parameters: ~+                    {bufnr}  number|nil Buffer number to get diagnistics from.+                             Use 0 for current buffer. When omitted, retrieve+                             diagnostics from all buffers.+                    {opts}   table|nil A table with the following keys:+                             ��� namespace: (number) Limit diagnostics to the+                               given namespace.+                             ��� lnum: (number) Limit diagnostics to the given+                               line number.+                             ��� severity: (|vim.diagnostic.severity|) Only+                               return diagnostics with this severity.+                               Conflicts with {min_severity}.+                             ��� min_severity: (|vim.diagnostic.severity|)+                               Return diagnostics with this severity or worse.+                               Conflicts with {severity}.","a dict could avoid that. The main point is to avoid awkward mix-and-match parameters that conflict. Although the validation/processing logic might be a chore, this ""single value or dict"" pattern is common and we could formalize it in `vim.validate()`.> ```lua> vim.diagnostic.get(0, { severity = {min=vim.diagnostic.severity.WARN} })> ```",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15211,709606719,2021-09-15T22:03:12Z,src/nvim/eval/typval.h,"@@ -711,6 +721,65 @@ static inline bool tv_dict_is_watched(const dict_T *const d)   return d && !QUEUE_EMPTY(&d->watchers); } +static inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)+  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);++/// Set a blob as the return value.+///+/// Increments the reference count.+///+/// @param[out]  tv  Object to receive the blob.+/// @param[in,out]  b  Blob to pass to the object.+static inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)+{+  tv->v_type = VAR_BLOB;+  tv->vval.v_blob = b;+  if (b != NULL) {+    b->bv_refcount++;+  }+}++static inline int tv_blob_len(const blob_T *const b)+  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;++/// Get the length of the data in the blob, in bytes.+///+/// @param[in]  b  Blob to check.+static inline int tv_blob_len(const blob_T *const b)+{+  if (b == NULL) {+    return 0;+  }+  return b->bv_ga.ga_len;+}++static inline char_u tv_blob_get(const blob_T *const b, int idx)+  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;+","I'll address this later :+1:(I think I excluded this on purpose because I thought `char_u` was more appropriate at the time, but it was probably a bad idea :smile:)",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15211,709608130,2021-09-15T22:06:28Z,src/nvim/eval/typval.h,"@@ -711,6 +721,65 @@ static inline bool tv_dict_is_watched(const dict_T *const d)   return d && !QUEUE_EMPTY(&d->watchers); } +static inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)+  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ARG(1);++/// Set a blob as the return value.+///+/// Increments the reference count.+///+/// @param[out]  tv  Object to receive the blob.+/// @param[in,out]  b  Blob to pass to the object.+static inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)+{+  tv->v_type = VAR_BLOB;+  tv->vval.v_blob = b;+  if (b != NULL) {+    b->bv_refcount++;+  }+}++static inline int tv_blob_len(const blob_T *const b)+  REAL_FATTR_PURE REAL_FATTR_WARN_UNUSED_RESULT;++/// Get the length of the data in the blob, in bytes.+///+/// @param[in]  b  Blob to check.+static inline int tv_blob_len(const blob_T *const b)+{+  if (b == NULL) {+    return 0;+  }+  return b->bv_ga.ga_len;+}++static inline char_u tv_blob_get(const blob_T *const b, int idx)+  REAL_FATTR_ALWAYS_INLINE REAL_FATTR_NONNULL_ALL REAL_FATTR_WARN_UNUSED_RESULT;+","> > > Nvrmnd. Noticed the commit description.Oh, apparently I had a good reason at the time then ���� I guess it's because blob deals with bytes, I didn't see the reason for it to change to `int` apart from minimizing conversions where it's used as an `int`, though maybe `uint8_t` would have been the better choice with that reasoning?:shrug:",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/15211,709637093,2021-09-15T23:09:37Z,src/nvim/testdir/test_const.vim,"@@ -244,18 +244,22 @@ func Test_const_with_eval_name()     call assert_fails('const {s2} = ""bar""', 'E995:') endfunc -func Test_lock_depth_is_1()-    const l = [1, 2, 3]-    const d = {'foo': 10}--    "" Modify list - setting item is OK, adding/removing items not-    let l[0] = 42+func Test_lock_depth_is_2()+    "" Modify list - error when changing item or adding/removing items+    const l = [1, 2, [3, 4]]+    call assert_fails('let l[0] = 42', 'E741:')+    call assert_fails('let l[2][0] = 42', 'E741:')     call assert_fails('call add(l, 4)', 'E741:')     call assert_fails('unlet l[1]', 'E741:') -    "" Modify dict - changing item is OK, adding/removing items not-    let d['foo'] = 'hello'-    let d.foo = 44+    "" Modify blob - error when changing+    const b = 0z001122+    call assert_fails('let b[0] = 42', 'E741:')++    "" Modify dict - error when changing item or adding/removing items+    const d = {'foo': 10}+    call assert_fails(""let d['foo'] = 'hello'"", 'E741:')+    call assert_fails(""let d.foo = 'hello'"", 'E741:')     call assert_fails(""let d['bar'] = 'hello'"", 'E741:')     call assert_fails(""unlet d['foo']"", 'E741:')","Missing```diff++    "" Modifying list or dict item contents is OK.+    let lvar = ['a', 'b']+    let bvar = 0z1122+    const l2 = [0, lvar, bvar]+    let l2[1][0] = 'c'+    let l2[2][1] = 0x33+    call assert_equal([0, ['c', 'b'], 0z1133], l2)++    const d2 = #{a: 0, b: lvar, c: 4}+    let d2.b[1] = 'd'```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15658,709901330,2021-09-16T08:28:53Z,src/nvim/lua/executor.c,"@@ -520,51 +621,18 @@ static int nlua_state_init(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   lua_setfield(lstate, LUA_REGISTRYINDEX, ""mpack.empty_dict"");   lua_setfield(lstate, -2, ""_empty_dict_mt""); ",we could move `vim.NIL` and `vim._empty_dict_mt` also into `nlua_common_vim_init`. just place the `nlua_empty_dict_ref` and `nlua_nil_ref` assigments within `if (!is_thread) { ... }` conditions.,
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/15364,710606474,2021-09-17T00:28:18Z,src/nvim/edit.c,"@@ -4127,6 +4127,8 @@ static int ins_compl_get_exp(pos_T *ini)   char_u *dict = NULL;   int dict_f = 0;   bool set_match_pos;+  pos_T prev_pos = { 0, 0, 0 };+  bool looped_around = false;",This assignment is dead. `looped_around` is set to false in the outer loop.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15674,710829324,2021-09-17T07:45:04Z,src/nvim/api/ui_events.in.h,"@@ -123,6 +123,9 @@ void win_viewport(Integer grid, Window win, Integer topline,                   Integer line_count)   FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY; +void win_extmarks(Window win, Array data)","This doesn't need to be an array, but could actually spell the named arguments `win, ns_id, mark_id, start_row, end_row, start_col`. The UI msgpack layer already packs events of the same kind very efficiently as long as their are sent together (at one place in `win_update()`, after all lines, in this case). Only downside is we need a separate `win_extmarks_clear` event but I think it worth able to use event metadata as intended.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/15585,710910682,2021-09-17T09:40:58Z,runtime/lua/vim/diagnostic.lua,"@@ -0,0 +1,1150 @@+local M = {}++M.severity = {+  ERROR = 1,+  WARN = 2,+  INFO = 3,+  HINT = 4,+}++vim.tbl_add_reverse_lookup(M.severity)++local global_diagnostic_options = {+  signs = true,+  underline = true,+  virtual_text = true,+  update_in_insert = false,+  severity_sort = false,+}++-- Local functions {{{++---@private+local function to_severity(severity)+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity+end++---@private+local function filter_by_severity(severity, diagnostics)+  if not severity then+    return diagnostics+  end++  if type(severity) ~= ""table"" then+    severity = to_severity(severity)+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)+  end++  local min_severity = to_severity(severity.min) or M.severity.HINT+  local max_severity = to_severity(severity.max) or M.severity.ERROR++  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)+end++---@private+local function resolve_optional_value(option, namespace, bufnr)+  local enabled_val = {}++  if not option then+    return false+  elseif option == true then+    return enabled_val+  elseif type(option) == 'function' then+    local val = option(namespace, bufnr)+    if val == true then+      return enabled_val+    else+      return val+    end+  elseif type(option) == 'table' then+    return option+  else+    error(""Unexpected option type: "" .. vim.inspect(option))+  end+end++local all_namespaces = {}++---@private+local function get_namespace(ns)+  if not all_namespaces[ns] then+    local name+    for k, v in pairs(vim.api.nvim_get_namespaces()) do+      if ns == v then+        name = k+        break+      end+    end++    if not name then+      return vim.notify(""namespace does not exist or is anonymous"", vim.log.levels.ERROR)+    end++    all_namespaces[ns] = {+      name = name,+      sign_group = string.format(""vim.diagnostic.%s"", name),+      opts = {}+    }+  end+  return all_namespaces[ns]+end++---@private+local function get_resolved_options(opts, namespace, bufnr)+  local ns = get_namespace(namespace)+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)+  for k in pairs(global_diagnostic_options) do+    if resolved[k] ~= nil then+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)+    end+  end+  return resolved+end++-- Default diagnostic highlights+local diagnostic_severities = {+  [M.severity.ERROR] = { ctermfg = 1, guifg = ""Red"" };+  [M.severity.WARN] = { ctermfg = 3, guifg = ""Orange"" };+  [M.severity.INFO] = { ctermfg = 4, guifg = ""LightBlue"" };+  [M.severity.HINT] = { ctermfg = 7, guifg = ""LightGrey"" };+}++-- Make a map from DiagnosticSeverity -> Highlight Name+---@private+local function make_highlight_map(base_name)+  local result = {}+  for k in pairs(diagnostic_severities) do+    local name = M.severity[k]+    name = name:sub(1, 1) .. name:sub(2):lower()+    result[k] = ""Diagnostic"" .. base_name .. name+  end++  return result+end++local virtual_text_highlight_map = make_highlight_map(""VirtualText"")+local underline_highlight_map = make_highlight_map(""Underline"")+local floating_highlight_map = make_highlight_map(""Floating"")+local sign_highlight_map = make_highlight_map(""Sign"")++---@private+local define_default_signs = (function()+  local signs_defined = false+  return function()+    if signs_defined then+      return+    end++    for severity, sign_hl_name in pairs(sign_highlight_map) do+      local severity_name = M.severity[severity]+      vim.fn.sign_define(sign_hl_name, {+        text = (severity_name or 'U'):sub(1, 1),+        texthl = sign_hl_name,+        linehl = '',+        numhl = '',+      })+    end++    signs_defined = true+  end+end)()++---@private+local function get_bufnr(bufnr)+  if not bufnr or bufnr == 0 then+    return vim.api.nvim_get_current_buf()+  end+  return bufnr+end++-- Metatable that automatically creates an empty table when assigning to a missing key+local bufnr_and_namespace_cacher_mt = {+  __index = function(t, bufnr)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    if rawget(t, bufnr) == nil then+      rawset(t, bufnr, {})+    end++    return rawget(t, bufnr)+  end,++  __newindex = function(t, bufnr, v)+    if not bufnr or bufnr == 0 then+      bufnr = vim.api.nvim_get_current_buf()+    end++    rawset(t, bufnr, v)+  end,+}++local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_attached_buffers = {}+local diagnostic_disabled = {}+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)++---@private+local function is_disabled(namespace, bufnr)+  if type(diagnostic_disabled[bufnr]) == ""table"" then+    return diagnostic_disabled[bufnr][namespace]+  end+  return diagnostic_disabled[bufnr]+end++---@private+local function diagnostic_lines(diagnostics)+  if not diagnostics then+    return+  end++  local diagnostics_by_line = {}+  for _, diagnostic in ipairs(diagnostics) do+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]+    if not line_diagnostics then+      line_diagnostics = {}+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics+    end+    table.insert(line_diagnostics, diagnostic)+  end+  return diagnostics_by_line+end++---@private+local function set_diagnostic_cache(namespace, diagnostics, bufnr)+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)+  for _, diagnostic in ipairs(diagnostics) do+    if diagnostic.severity == nil then+      diagnostic.severity = M.severity.ERROR+    end++    diagnostic.namespace = namespace+    diagnostic.bufnr = bufnr++    if buf_line_count > 0 then+      diagnostic.lnum = math.max(math.min(+        diagnostic.lnum, buf_line_count - 1+      ), 0)+      diagnostic.end_lnum = math.max(math.min(+        diagnostic.end_lnum, buf_line_count - 1+      ), 0)+    end+  end++  diagnostic_cache[bufnr][namespace] = diagnostics+end++---@private+local function clear_diagnostic_cache(namespace, bufnr)+  diagnostic_cache[bufnr][namespace] = nil+end++---@private+local function restore_extmarks(bufnr, last)+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})+    local found = {}+    for _, extmark in ipairs(extmarks_current) do+      -- nvim_buf_set_lines will move any extmark to the line after the last+      -- nvim_buf_set_text will move any extmark to the last line+      if extmark[2] ~= last + 1 then+        found[extmark[1]] = true+      end+    end+    for _, extmark in ipairs(extmarks) do+      if not found[extmark[1]] then+        local opts = extmark[4]+        opts.id = extmark[1]+        -- HACK: end_row should be end_line+        if opts.end_row then+          opts.end_line = opts.end_row+          opts.end_row = nil+        end+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)+      end+    end+  end+end++---@private+local function save_extmarks(namespace, bufnr)+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr+  if not diagnostic_attached_buffers[bufnr] then+    vim.api.nvim_buf_attach(bufnr, false, {+      on_lines = function(_, _, _, _, _, last)+        restore_extmarks(bufnr, last - 1)+      end,+      on_detach = function()+        diagnostic_cache_extmarks[bufnr] = nil+      end})+    diagnostic_attached_buffers[bufnr] = true+  end+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})+end++local registered_autocmds = {}++---@private+local function make_augroup_key(namespace, bufnr)+  local ns = get_namespace(namespace)+  return string.format(""DiagnosticInsertLeave:%s:%s"", bufnr, ns.name)+end++--- Table of autocmd events to fire the update for displaying new diagnostic information+local insert_leave_auto_cmds = { ""InsertLeave"", ""CursorHoldI"" }++---@private+local function schedule_display(namespace, bufnr, args)+  bufs_waiting_to_update[bufnr][namespace] = args++  local key = make_augroup_key(namespace, bufnr)+  if not registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(+      string.format(+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],+        table.concat(insert_leave_auto_cmds, "",""),+        bufnr,+        namespace,+        bufnr+      )+    )+    vim.cmd(""augroup END"")++    registered_autocmds[key] = true+  end+end++---@private+local function clear_scheduled_display(namespace, bufnr)+  local key = make_augroup_key(namespace, bufnr)++  if registered_autocmds[key] then+    vim.cmd(string.format(""augroup %s"", key))+    vim.cmd(""  au!"")+    vim.cmd(""augroup END"")++    registered_autocmds[key] = nil+  end+end++---@private+--- Open a floating window with the provided diagnostics+---@param opts table Configuration table+---     - show_header (boolean, default true): Show ""Diagnostics:"" header+---     - all opts for |vim.util.open_floating_preview()| can be used here+---@param diagnostics table: The diagnostics to display+---@return table {popup_bufnr, win_id}+local function show_diagnostics(opts, diagnostics)+  if vim.tbl_isempty(diagnostics) then return end+  local lines = {}+  local highlights = {}+  local show_header = vim.F.if_nil(opts.show_header, true)+  if show_header then+    table.insert(lines, ""Diagnostics:"")+    table.insert(highlights, {0, ""Bold""})+  end++  for i, diagnostic in ipairs(diagnostics) do+    local prefix = string.format(""%d. "", i)+    local hiname = floating_highlight_map[diagnostic.severity]+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))++    local message_lines = vim.split(diagnostic.message, '\n', true)+    table.insert(lines, prefix..message_lines[1])+    table.insert(highlights, {#prefix, hiname})+    for j = 2, #message_lines do+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])+      table.insert(highlights, {0, hiname})+    end+  end++  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)+  for i, hi in ipairs(highlights) do+    local prefixlen, hiname = unpack(hi)+    -- Start highlight after the prefix+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)+  end++  return popup_bufnr, winnr+end++local errlist_type_map = {+  [M.severity.ERROR] = 'E',+  [M.severity.WARN] = 'W',+  [M.severity.INFO] = 'I',+  [M.severity.HINT] = 'I',+}++---@private+local function diagnostics_to_list_items(diagnostics)+  local items = {}+  for _, d in pairs(diagnostics) do+    table.insert(items, {+      bufnr = d.bufnr,+      lnum = d.lnum + 1,+      col = d.col + 1,+      text = d.message,+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'+    })+  end+  table.sort(items, function(a, b)+    if a.bufnr == b.bufnr then+      return a.lnum < b.lnum+    else+      return a.bufnr < b.bufnr+    end+  end)+  return items+end++---@private+local function set_list(loclist, opts)+  opts = opts or {}+  local open = vim.F.if_nil(opts.open, true)+  local title = opts.title or ""Diagnostics""+  local winnr = opts.winnr or 0+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)","Using `lua vim.diagnostic.setqflist()` results in an error.```E5108: Error executing lua /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:534: bufnr: expected number, got booleanstack traceback:        /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:534: in function 'get'        /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:411: in function 'set_list'        /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:1090: in function 'setqflist'        [string "":lua""]:1: in main chunk```If `loclist == false` then the first argument to `M.get()` is a bool and not a number.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15674,711152262,2021-09-17T15:25:55Z,src/nvim/api/ui_events.in.h,"@@ -123,6 +123,9 @@ void win_viewport(Integer grid, Window win, Integer topline,                   Integer line_count)   FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY; +void win_extmarks(Window win, Array data)","I mean an empty event in case there were extmarks before but now they are now invalid. but perhaps that won't be necessary, actually.  the UI knows after a win_line that old extmarks on that line is no longer valid, regardless if new ones are supplied or not.",
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/15699,711212658,2021-09-17T16:55:48Z,runtime/pack/dist/opt/termdebug/plugin/termdebug.vim,"@@ -870,7 +877,15 @@ func s:DeleteCommands()     if empty(s:k_map_saved)       nunmap K     else-      call mapset('n', 0, s:k_map_saved)+      "" call mapset('n', 0, s:k_map_saved)+      let mode = s:k_map_saved.mode !=# ' ' ? s:k_map_saved.mode : ''","Oh shoot, my bad, it supposed to be the first argument to `nvim_set_keymap`, because it takes empty string as `:map`",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15620,711244192,2021-09-17T17:48:22Z,scripts/lintcommit.lua,"@@ -0,0 +1,131 @@+function commit_message_is_ok(commit_message)+  local commit_split = vim.fn.split(commit_message, "":"")++  -- Return true if the type is vim-patch since most of the normal rules don't+  -- apply.+  if commit_split[1] == ""vim-patch"" then+    return true+  end++  -- Return false if no colons are detected.+  if vim.tbl_count(commit_split) < 2 then+    return false+  end++  local before_colon = commit_split[1]+  local after_colon = commit_split[2]++  -- Check if commit introduces a breaking change.+  if vim.endswith(before_colon, ""!"") then+    before_colon = before_colon:sub(1, -2)+  end++  -- Check if type is correct+  local type = vim.fn.split(before_colon, ""("")[1]+  local allowed_types = {""build"", ""ci"", ""docs"", ""feat"", ""fix"", ""perf"", ""refactor"", ""revert"", ""test"", ""chore""}+  if not vim.tbl_contains(allowed_types, type) then+    return false+  end++  -- Check if scope is empty+  -- if before_colon:match(""%("") then+    -- scope = before_colon:match(""%((.*)%)"")+  -- end++  -- Check that description doesn't end with a period+  if vim.endswith(after_colon, ""."") then+    return false+  end++  -- Check that description has exactly one whitespace after colon, followed by+  -- a lowercase letter and then any number of letters.+  if not string.match(after_colon, '^ %l%a*') then+    return false+  end++  return true+end++function main()+  local current_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))+  local ancestor_commit = vim.trim(vim.fn.system({'git', 'merge-base', 'origin/master', current_branch}))+  local commits_str = vim.trim(vim.fn.system({'git', 'rev-list', ancestor_commit .. "".."" .. current_branch}))++  local commits = {}+  for substring in commits_str:gmatch(""%S+"") do+     table.insert(commits, substring)+  end++  for index, commit_hash in ipairs(commits) do","Sorry to chime in so late, but any specific reason as to why not use a [commit-msg hook](https://git-scm.com/docs/githooks#_commit_msg)? It will pass the commit-message directly to `stdout` which you can pipe to `nvim` or any other script, and will even allow you to edit it, if you so wish.There's also another hook, [pre-commit-msg](http://git-scm.com/docs/githooks#_prepare_commit_msg).Here's the PR that I mentioned awhile ago about introducing git-hooks: https://github.com/kylo252/neovim/commit/09b12c2ab9e94c8109208cf4d672898e651ea400We can just replace the `npx commitlint` call with this script, which means no longer depending on a local nodejs installation ���� ",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15620,711560159,2021-09-18T08:49:18Z,Makefile,"@@ -163,6 +163,14 @@ _opt_pylint: 	@command -v flake8 && { $(MAKE) pylint; exit $$?; } \ 		|| echo ""SKIP: pylint (flake8 not found)"" +commitlint:+	# $(realpath build/bin/nvim) -es -u NONE +""luafile scripts/lintcommit.lua""+	$(realpath build/bin/nvim) -u NONE +""luafile scripts/lintcommit.lua""","Note: `realpath` doesn't exist by default on macOS, you need to install it with `coreutils`. All macOS devs should probably have that, well one would hope so at least, but it may currently cause problems if you want to use it in the CI: https://github.com/neovim/neovim/blob/1f49268c46fcbe65f7e2e2cb620e6f51c059cf9e/.github/workflows/release.yml#L86",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15620,711561182,2021-09-18T08:58:30Z,scripts/lintcommit.lua,"@@ -0,0 +1,131 @@+function commit_message_is_ok(commit_message)+  local commit_split = vim.split(commit_message, "":"")++  -- Return true if the type is vim-patch since most of the normal rules don't+  -- apply.+  if commit_split[1] == ""vim-patch"" then+    return true+  end++  -- Return false if no colons are detected.+  if vim.tbl_count(commit_split) < 2 then+    return false+  end++  local before_colon = commit_split[1]+  local after_colon = commit_split[2]++  -- Check if commit introduces a breaking change.+  if vim.endswith(before_colon, ""!"") then+    before_colon = before_colon:sub(1, -2)+  end++  -- Check if type is correct+  local type = vim.split(before_colon, ""%("")[1]+  local allowed_types = {""build"", ""ci"", ""docs"", ""feat"", ""fix"", ""perf"", ""refactor"", ""revert"", ""test"", ""chore""}+  if not vim.tbl_contains(allowed_types, type) then+    return false+  end++  -- Check if scope is empty+  -- if before_colon:match(""%("") then+    -- scope = before_colon:match(""%((.*)%)"")+  -- end++  -- Check that description doesn't end with a period+  if vim.endswith(after_colon, ""."") then+    return false+  end++  -- Check that description has exactly one whitespace after colon, followed by+  -- a lowercase letter and then any number of letters.+  if not string.match(after_colon, '^ %l%a*') then+    return false+  end++  return true+end++function main()+  local current_branch = vim.trim(vim.fn.system({'git', 'branch', '--show-current'}))+  local ancestor_commit = vim.trim(vim.fn.system({'git', 'merge-base', 'origin/master', current_branch}))+  local commits_str = vim.trim(vim.fn.system({'git', 'rev-list', ancestor_commit .. "".."" .. current_branch}))","Not sure this is a common case outside of maybe CI usage.The last command `git rev-list ..` doesn't really produce anything on a shallow clone, but you can just re-use the `ancestor_commit` as a fallback. ```console$ git clone https://github.com/neovim/neovim neovim-test -- --depth=1Cloning into 'neovim-test'...remote: Enumerating objects: 2964, done.remote: Counting objects: 100% (2964/2964), done.remote: Compressing objects: 100% (2749/2749), done.remote: Total 2964 (delta 208), reused 905 (delta 153), pack-reused 0Receiving objects: 100% (2964/2964), 10.02 MiB | 6.78 MiB/s, done.Resolving deltas: 100% (208/208), done.$ cd neovim-test$ git branch --show-currentmaster$ git merge-base origin/master master1f49268c46fcbe65f7e2e2cb620e6f51c059cf9e$ git rev-list 1f49268c46fcbe65f7e2e2cb620e6f51c059cf9e..master # notice the empty output$ git show -s --format=%s 1f49268c46fcbe65f7e2e2cb620e6f51c059cf9e # using the ancestor SHA againrefactor: convert TRUE/FALSE to true/false (#15660)```",
20684720,yatli,https://api.github.com/repos/neovim/neovim/pulls/15674,711570939,2021-09-18T10:24:02Z,src/nvim/api/ui_events.in.h,"@@ -123,6 +123,9 @@ void win_viewport(Integer grid, Window win, Integer topline,                   Integer line_count)   FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY; +void win_extmarks(Window win, Array data)","I just implemented this in FVim -- an extmark is attached to a grid cell, and then if the cell is invalidated (e.g. scrolled out of view) with no further win_extmarks updates, the ui finds the inconsistency and hide the marks.There's one bad case though: in insert mode, if a new line is input and it triggers a scroll (e.g. enter at the bottom row), and the top row has the same content as the second top row (e.g. two empty lines), there's no grid event for the top rows ����Guess that's when `win_extmarks_clear` should come in, but I'm not sure where to start implementing this...",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15704,711575192,2021-09-18T11:04:13Z,test/functional/lua/diagnostic_spec.lua,"@@ -869,4 +869,80 @@ describe('vim.diagnostic', function()       assert(loc_list[1].lnum < loc_list[2].lnum)     end)   end)++  describe('match()', function()+    it('matches a string', function()",Could you also add a test for a case where the pattern doesn't match a string? (Returning an empty list?),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15708,711593980,2021-09-18T13:58:40Z,Makefile,"@@ -12,6 +14,8 @@ CMAKE_BUILD_TYPE ?= Debug CMAKE_FLAGS := -DCMAKE_BUILD_TYPE=$(CMAKE_BUILD_TYPE) # Extra CMake flags which extend the default set CMAKE_EXTRA_FLAGS ?=+BUILD_DIR ?= build","not in favor of parameterizing this unless there is a strong use case. Making everything configurable ""just because"" needs a clear gain, to outweight the costs which are:- makes build logs and user reports less consistent- adds churn- makes the script logic slightly more verbose",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15632,711596853,2021-09-18T14:20:18Z,runtime/doc/options.txt,"@@ -4887,9 +4887,11 @@ A jump table for the options with a short description can be found at |Q_op|. 	   ordering.  This is for preferences to overrule or add to the  	   distributed defaults or system-wide settings (rarely needed). -	More entries are added when using |packages|.  If it gets very long-	then `:set rtp` will be truncated, use `:echo &rtp` to see the full-	string.+							*rtp-packages*+	""start"" packages will additionally be used to search for runtime files+	after these, but package entries are not visible in `:set rtp`.","wording could be confusing. suggestion:```suggestion	""start"" packages will also be searched for runtime files after these,	though such packages are not explicitly listed in `:set rtp`.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15632,711597097,2021-09-18T14:22:19Z,runtime/doc/repeat.txt,"@@ -516,16 +516,26 @@ You would now have these files under ~/.local/share/nvim/site: 	pack/foo/start/foobar/syntax/some.vim 	pack/foo/opt/foodebug/plugin/debugger.vim -When Vim starts up, after processing your .vimrc, it scans all directories in-'packpath' for plugins under the ""pack/*/start"" directory.  First all those-directories are added to 'runtimepath'.  Then all the plugins are loaded.-See |packload-two-steps| for how these two steps can be useful.+							*runtime-search-path*+When runtime files are searched for, first all paths in 'runtimepath' are+searched, then all ""pack/*/start/*"" dirs are searched. However, package entries+are not visible in `:set rtp` or `echo &rtp`, as the final concatenated path+would be too long and get truncated. To list all used directories, use","we don't really need to mention this reason, which is a pretty lame reason anyway (and doesn't capture our full reasoning?).```suggestionare not visible in `:set rtp` or `echo &rtp`. To list all used directories, use```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15632,711597211,2021-09-18T14:23:39Z,runtime/doc/repeat.txt,"@@ -516,16 +516,26 @@ You would now have these files under ~/.local/share/nvim/site: 	pack/foo/start/foobar/syntax/some.vim 	pack/foo/opt/foodebug/plugin/debugger.vim -When Vim starts up, after processing your .vimrc, it scans all directories in-'packpath' for plugins under the ""pack/*/start"" directory.  First all those-directories are added to 'runtimepath'.  Then all the plugins are loaded.-See |packload-two-steps| for how these two steps can be useful.+							*runtime-search-path*+When runtime files are searched for, first all paths in 'runtimepath' are+searched, then all ""pack/*/start/*"" dirs are searched. However, package entries+are not visible in `:set rtp` or `echo &rtp`, as the final concatenated path+would be too long and get truncated. To list all used directories, use+|nvim_list_runtime_paths()|. In addition |nvim_get_runtime_file()| can be used",active voice saves so many words and is clearer```suggestion|nvim_list_runtime_paths()|. Use |nvim_get_runtime_file()|```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15632,711598089,2021-09-18T14:31:44Z,test/functional/api/vim_spec.lua,"@@ -1591,7 +1591,10 @@ describe('API', function()       eq({'a', '', 'b'}, meths.list_runtime_paths())       meths.set_option('runtimepath', ',a,b')       eq({'', 'a', 'b'}, meths.list_runtime_paths())+      -- trailing , is ignored, use ,, if you really really want $CWD",is this a change (or even existing behavior) that needs to be documented (e.g. mention it on docstring for `nvim_list_runtime_paths()`)? also not mentioned in `:h 'runtimepath'`,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15632,711601513,2021-09-18T15:02:42Z,test/functional/api/vim_spec.lua,"@@ -1591,7 +1591,10 @@ describe('API', function()       eq({'a', '', 'b'}, meths.list_runtime_paths())       meths.set_option('runtimepath', ',a,b')       eq({'', 'a', 'b'}, meths.list_runtime_paths())+      -- trailing , is ignored, use ,, if you really really want $CWD",It is the existing behavior for internal runtime lookup (essentially all other code paths except for nvim_list_runtime_paths()). Could have compat note perhaps in the docs but i think this was rarely used (c f at least typing `.` as a path which also works and is more explicit),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15710,711606823,2021-09-18T15:50:15Z,runtime/lua/vim/diagnostic.lua,"@@ -1073,6 +1073,7 @@ function M.show_line_diagnostics(opts, bufnr, lnum)   opts = opts or {}   opts.focus_id = ""line_diagnostics""   opts.lnum = lnum or (vim.api.nvim_win_get_cursor(0)[1] - 1)+  bufnr = get_bufnr(bufnr)   local line_diagnostics = M.get(bufnr, opts)","reassigning a param in the middle of a function body is a bit icky, maybe inlining the expression is better?```suggestion  local line_diagnostics = M.get(get_bufnr(bufnr), opts)```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15710,711607060,2021-09-18T15:52:16Z,runtime/lua/vim/diagnostic.lua,"@@ -1073,6 +1073,7 @@ function M.show_line_diagnostics(opts, bufnr, lnum)   opts = opts or {}   opts.focus_id = ""line_diagnostics""   opts.lnum = lnum or (vim.api.nvim_win_get_cursor(0)[1] - 1)+  bufnr = get_bufnr(bufnr)   local line_diagnostics = M.get(bufnr, opts)","It may be icky, but it's the pattern used throughout the file so it's a familiar pattern for readers. And we can't use the inline expression in all places.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15702,711607674,2021-09-18T15:57:51Z,src/nvim/eval/funcs.c,"@@ -10062,10 +10046,12 @@ static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)   tv_list_append_string(rettv->vval.v_list, word, len);   tv_list_append_string(rettv->vval.v_list,                         (attr == HLF_SPB ? ""bad""-                         : attr == HLF_SPR ? ""rare""-                         : attr == HLF_SPL ? ""local""-                         : attr == HLF_SPC ? ""caps""-                         : NULL), -1);+                                         : attr == HLF_SPR ? ""rare""+                                                           : attr == HLF_SPL ? ""local""+                                                                             : attr ==+                         HLF_SPC ? ""caps""+                                 :+                         NULL), -1);",hmmthink we broke uncrusty's brain with nested ternaries,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15704,711612399,2021-09-18T16:39:53Z,runtime/doc/diagnostic.txt,"@@ -265,6 +265,16 @@ enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*                     {namespace}  number|nil Only enable diagnostics for the                                  given namespace. +fromlist({list})                                   *vim.diagnostic.fromlist()*","- is there a reason we would not stick with the ""qflist"" convention? That clearly communicates what kind of list this is. Especially given that this also returns... a list.- same for `tolist()` => `toqflist()`- if this is too garbled, could name it `from_qflist`, `to_qflist````suggestionfromqflist({list})                                   *vim.diagnostic.fromlist()*```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15704,711612650,2021-09-18T16:41:52Z,runtime/doc/diagnostic.txt,"@@ -265,6 +265,16 @@ enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*                     {namespace}  number|nil Only enable diagnostics for the                                  given namespace. +fromlist({list})                                   *vim.diagnostic.fromlist()*","I am fine with this, hopefully it's clear that this can be use for the loclist as well though.I prefer no `_` personally (e.g. `fromqflist` instead of `from_qflist`).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15704,711614152,2021-09-18T16:55:40Z,runtime/doc/diagnostic.txt,"@@ -265,6 +265,16 @@ enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*                     {namespace}  number|nil Only enable diagnostics for the                                  given namespace. +fromlist({list})                                   *vim.diagnostic.fromlist()*","> I am fine with this, hopefully it's clear that this can be use for the loclist as well though.yeah, it's understood that loclists have qflist format/structure. Or we need to establish that understanding, because having ""loclist"" variants everywhere or just calling them ""lists"" is strictly worse.Even `:help setloclist()` says _refer to |setqflist-what|_.> I prefer no `_` personally (e.g. `fromqflist` instead of `from_qflist`).fine with me :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15704,711614380,2021-09-18T16:57:24Z,runtime/lua/vim/diagnostic.lua,"@@ -1167,7 +1144,135 @@ function M.enable(bufnr, namespace)   end end --- }}}+--- Parse a diagnostic from a string.+---+--- For example, consider a line of output from a linter:+--- <pre>+--- WARNING filename:27:3: Variable 'foo' does not exist+--- </pre>+--- This can be parsed into a diagnostic |diagnostic-structure|+--- with:+--- <pre>+--- local s = ""WARNING filename:27:3: Variable 'foo' does not exist""+--- local pattern = ""^(%w+) %w+:(%d+):(%d+): (.+)$""+--- local groups = {""severity"", ""lnum"", ""col"", ""message""}+--- vim.diagnostic.match(s, pattern, groups, {WARNING = vim.diagnostic.WARN})+--- </pre>+---+---@param str string String to parse diagnostics from.+---@param pat string Lua pattern with capture groups.+---@param groups table List of fields in a |diagnostic-structure| to+---                    associate with captures from {pat}.+---@param severity_map table A table mapping the severity field from {groups}+---                          with an item from |vim.diagnostic.severity|.+---@param defaults table|nil Table of default values for any fields not listed in {groups}.+---                          When omitted, numeric values default to 0 and ""severity"" defaults to+---                          ERROR.+---@return diagnostic |diagnostic-structure| or `nil` if {pat} fails to match {str}.+function M.match(str, pat, groups, severity_map, defaults)+  vim.validate {+    str = { str, 's' },+    pat = { pat, 's' },+    groups = { groups, 't' },+    severity_map = { severity_map, 't', true },+    defaults = { defaults, 't', true },+  }++  severity_map = severity_map or M.severity++  local diagnostic = {}+  local matches = {string.match(str, pat)}+  if vim.tbl_isempty(matches) then+    return+  end++  for i, match in ipairs(matches) do+    local field = groups[i]+    if field == ""severity"" then+      match = severity_map[match]+    elseif field == ""lnum"" or field == ""end_lnum"" or field == ""col"" or field == ""end_col"" then+      match = assert(tonumber(match)) - 1+    end+    diagnostic[field] = match+  end +  diagnostic = vim.tbl_extend(""keep"", diagnostic, defaults or {})+  diagnostic.severity = diagnostic.severity or M.severity.ERROR+  diagnostic.col = diagnostic.col or 0+  diagnostic.end_lnum = diagnostic.end_lnum or diagnostic.lnum+  diagnostic.end_col = diagnostic.end_col or diagnostic.col+  return diagnostic+end++local errlist_type_map = {+  [M.severity.ERROR] = 'E',+  [M.severity.WARN] = 'W',+  [M.severity.INFO] = 'I',+  [M.severity.HINT] = 'N',+}++--- Convert a list of diagnostics to a list of quickfix items.+---+--- The result can be passed to |setqflist()| or |setloclist()|.","this is perfect, i would even jam it into the first line:```suggestion--- Convert a list of diagnostics to a list of quickfix items, which can be passed to |setqflist()| or |setloclist()|.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15708,711761201,2021-09-19T15:24:17Z,Makefile,"@@ -35,37 +38,35 @@ else checkprefix: ; endif -BUILD_TYPE ?= $(shell (type ninja > /dev/null 2>&1 && echo ""Ninja"") || \+CMAKE_GENERATOR ?= $(shell (command -v ninja > /dev/null 2>&1 && echo ""Ninja"") || \     echo ""Unix Makefiles"") DEPS_BUILD_DIR ?= .deps ifneq (1,$(words [$(DEPS_BUILD_DIR)]))   $(error DEPS_BUILD_DIR must not contain whitespace) endif  ifeq (,$(BUILD_TOOL))-  ifeq (Ninja,$(BUILD_TYPE))+  ifeq (Ninja,$(CMAKE_GENERATOR))     ifneq ($(shell $(CMAKE_PRG) --help 2>/dev/null | grep Ninja),)       BUILD_TOOL := ninja     else       # User's version of CMake doesn't support Ninja       BUILD_TOOL = $(MAKE)-      BUILD_TYPE := Unix Makefiles","why remove this? the condition on line 50 isn't checked anywhere else. If CMAKE_GENERATOR is ""ninja"" but that condition fails, then we have a regression",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15723,711765192,2021-09-19T15:54:31Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,158 @@+local M = {}+local util = require ""vim.lsp.util""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}++local function highlight(buf, token, hl)",There's already a highlight function for tokens in https://github.com/neovim/neovim/blob/2afbce7651f79b0626ebeae3688274ce18ac2920/runtime/lua/vim/lsp/util.lua#L1493-L1507Can this be refactored to utilize common code?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15723,711766845,2021-09-19T16:07:43Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,158 @@+local M = {}+local util = require ""vim.lsp.util""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return _G.bit.band(_G.bit.rshift(n, k), 1)",We could upstream https://github.com/nvim-lua/plenary.nvim/blob/bfe08f26bdc246a13f66e37d44334da83c27f134/lua/plenary/bit.lua for this.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,711767901,2021-09-19T16:15:05Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,158 @@+local M = {}+local util = require ""vim.lsp.util""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}++local function highlight(buf, token, hl)+  vim.highlight.range(buf, ns, hl, {token.line, token.start_char}, {token.line, token.start_char + token.length})+  vim.schedule_wrap(function()+    vim.api.nvim_buf_set_extmark(+      buf,+      ns,+      token.line,+      token.start_char,+      {+        end_line = token.line,+        end_col = token.start_char + token.length,+        hl_group = hl,+        ephemeral = false,","TODO: what is the best strategy for highlighting? Probably, we'd assume to do this request not to often. tree-sitter and regex highlight are for highlighting on every keystroke. LSP add's extra semantic fancyness when document is stale, LSP would even notify us with `refresh` when it would be a good moment to refresh.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15708,711797401,2021-09-19T20:18:27Z,Makefile,"@@ -35,37 +38,35 @@ else checkprefix: ; endif -BUILD_TYPE ?= $(shell (type ninja > /dev/null 2>&1 && echo ""Ninja"") || \+CMAKE_GENERATOR ?= $(shell (command -v ninja > /dev/null 2>&1 && echo ""Ninja"") || \     echo ""Unix Makefiles"") DEPS_BUILD_DIR ?= .deps ifneq (1,$(words [$(DEPS_BUILD_DIR)]))   $(error DEPS_BUILD_DIR must not contain whitespace) endif  ifeq (,$(BUILD_TOOL))-  ifeq (Ninja,$(BUILD_TYPE))+  ifeq (Ninja,$(CMAKE_GENERATOR))     ifneq ($(shell $(CMAKE_PRG) --help 2>/dev/null | grep Ninja),)       BUILD_TOOL := ninja     else       # User's version of CMake doesn't support Ninja       BUILD_TOOL = $(MAKE)-      BUILD_TYPE := Unix Makefiles","It's because it's done in a slightly convoluted logic: https://github.com/neovim/neovim/blob/1090ac568272565879b2f0d2c61c94d4884e34f7/Makefile#L41-L42 I had figured that you wouldn't actually have `ninja` on the system while simultaneously have an old/(ancient?) `cmake`.But you're right, there's an actual chance of a regression here, although unlikely. If you want me to change it, then my vote is to start the change from the original line that I linked, and actually only change the default value of the variable, ""Unix Makefile"", when both requirements are met 1) compatible cmake, 2) ninja is available",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15704,711805194,2021-09-19T21:24:46Z,runtime/doc/deprecated.txt,"@@ -96,6 +96,7 @@ internally and are no longer exposed as part of the API. Instead, use  LSP Utility Functions ~ +*vim.lsp.util.diagnostics_to_items()*	Use |vim.diagnostic.tolist()| instead.",```suggestion*vim.lsp.util.diagnostics_to_items()*	Use |vim.diagnostic.toqflist()| instead.```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15736,712319866,2021-09-20T16:17:35Z,src/nvim/garray.c,"@@ -178,7 +178,7 @@ char_u *ga_concat_strings_sep(const garray_T *gap, const char *sep) /// @param gap /// /// @returns the concatenated strings-char_u* ga_concat_strings(const garray_T *gap) FUNC_ATTR_NONNULL_RET+char_u * ga_concat_strings(const garray_T *gap) FUNC_ATTR_NONNULL_RET","Personally, I prefer to put the `*` next to the identifier rather than the type:```cint *p;```This avoids confusion in cases like```cint* p, x;```The above implies that both `p` and `x` are pointers to int `int *` which is not the case: only `p` is and `x` is just an `int` (yet another reason to avoid multiple declarations on one line).But seeing as there's no ambiguity in a function declaration this is fine too.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,712367469,2021-09-20T17:21:35Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,158 @@+local M = {}+local util = require ""vim.lsp.util""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return bit.band(bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}++local function highlight(buf, token, hl)",I think this is difficult because the tokens don't use the range schema (pretty unusual for LSP). I might try to convert the tokens to ranges but I don't think the benefit would be big.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15741,712386565,2021-09-20T17:49:38Z,src/nvim/math.c,"@@ -2,6 +2,7 @@ // it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com  #include <math.h>+",This looks random. not a big deal tho.,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15738,712415574,2021-09-20T18:31:37Z,runtime/lua/vim/lsp/buf.lua,"@@ -321,13 +321,21 @@ end ---@private local function call_hierarchy(method)   local params = util.make_position_params()-  request('textDocument/prepareCallHierarchy', params, function(err, _, result)+  request('textDocument/prepareCallHierarchy', params, function(err, result, ctx)     if err then       vim.notify(err.message, vim.log.levels.WARN)       return     end     local call_hierarchy_item = pick_call_hierarchy_item(result)-    vim.lsp.buf_request(0, method, { item = call_hierarchy_item })+    local client = vim.lsp.get_client_by_id(ctx.client_id)+    if client then+      client.request(method, { item = call_hierarchy_item }, nil, ctx.bufnr)+    else+      vim.notify(string.format(+        'Client with id=%d disappeared during call hierarchy request', ctx.client_id),","I feel like dissapeared is a big mysterious for an error message, but not going to bike shed on it",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15735,712426373,2021-09-20T18:47:33Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -102,15 +102,21 @@ local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)       end_lnum = _end.line,       end_col = line_byte_from_position(buf_lines, _end.line, _end.character, offset_encoding),       severity = severity_lsp_to_vim(diagnostic.severity),-      message = diagnostic.message+      message = diagnostic.message,+      lsp = {",I had something like `user_data`  in mind (Similar to how it is used in `complete-items`) and nest it further - to avoid making `lsp` a first-class diagnostic item property. But no strong opinion.,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15735,712465168,2021-09-20T19:47:51Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -102,15 +102,21 @@ local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)       end_lnum = _end.line,       end_col = line_byte_from_position(buf_lines, _end.line, _end.character, offset_encoding),       severity = severity_lsp_to_vim(diagnostic.severity),-      message = diagnostic.message+      message = diagnostic.message,+      lsp = {","Also no strong opinion. Do we anticipate additional things populating this field? I don't know of any off the top of my head, but additional table nesting doesn't heart (apart from code beauty)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15735,712474783,2021-09-20T20:02:54Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -102,15 +102,21 @@ local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)       end_lnum = _end.line,       end_col = line_byte_from_position(buf_lines, _end.line, _end.character, offset_encoding),       severity = severity_lsp_to_vim(diagnostic.severity),-      message = diagnostic.message+      message = diagnostic.message,+      lsp = {","I don't anticipate needing to attach any other kind of non-LSP related data here, but of course I can't see the future and this would save us a refactor if that ever was the case. So SGTM.**EDIT:** Maybe plugins can do something interesting with it, so on further thought I think this is a good idea.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15743,712620051,2021-09-21T01:08:03Z,cmake/FindLibUV.cmake,"@@ -75,6 +75,13 @@ if(WIN32)   list(APPEND LIBUV_LIBRARIES ws2_32) endif() +if(Threads_FOUND)+  # TODO: Fix the cmake file to properly handle static deps for bundled builds,+  # but for not just include the threads library if CMake tells us there's one","""now"" has a confusing typo, so i will also editorialize :)```suggestion  # TODO: Fix the cmake file to properly handle static deps for bundled builds.  # Meanwhile just include the threads library if CMake tells us there's one```",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15735,713089600,2021-09-21T14:18:38Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -102,15 +102,23 @@ local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)       end_lnum = _end.line,       end_col = line_byte_from_position(buf_lines, _end.line, _end.character, offset_encoding),       severity = severity_lsp_to_vim(diagnostic.severity),-      message = diagnostic.message+      message = diagnostic.message,+      user_data = {+        lsp = {+          code = diagnostic.code,+          codeDescription = diagnostic.codeDescription,+          tags = diagnostic.tags,+          relatedInformation = diagnostic.relatedInformation,+        },",Could you also add the `data` property? ``` /**      * A data entry field that is preserved between a      * `textDocument/publishDiagnostics` notification and      * `textDocument/codeAction` request.      *      * @since 3.16.0      */    data?: unknown;```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15739,713922125,2021-09-22T13:06:37Z,cmake/FindLibUV.cmake,"@@ -75,6 +75,7 @@ if(WIN32)   list(APPEND LIBUV_LIBRARIES ws2_32) endif() +find_package(Threads)","should it specify ""REQUIRED"" like this one: https://github.com/neovim/neovim/blob/e8fb0728e220bb378a8689415c3915fe5912e987/CMakeLists.txt#L505then I guess we could remove the `if(Threads_FOUND)` check?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14979,714042126,2021-09-22T15:07:41Z,runtime/doc/dev_style.txt,"@@ -0,0 +1,1157 @@+*dev_style.txt*          Nvim+++                            NVIM REFERENCE MANUAL+++Neovim style guide					*style* *dev-style*++This reference describes the neovim style guide.++                                      Type |gO| to see the table of contents.++==============================================================================+Background						*style-background*++One way in which we keep the code base manageable is by enforcing consistency.+It is very important that any programmer be able to look at another's code and+quickly understand it.++Maintaining a uniform style and following conventions means that we can more+easily use ""pattern-matching"" to infer what various symbols are and what+invariants are true about them. Creating common, required idioms and patterns+makes code much easier to understand.++In some cases there might be good arguments for changing certain style rules,+but we nonetheless keep things as they are in order to preserve consistency.+++==============================================================================+Header Files						*style-header-files*+++The #define Guard ~++All header files should have `#define` guards to prevent multiple inclusion.+The format of the symbol name should be `NEOVIM_<DIRECTORY>_<FILE>_H`.++    In foo/bar.h:+>+	#ifndef NEOVIM_FOO_BAR_H+	#define NEOVIM_FOO_BAR_H++	...++	#endif  // NEOVIM_FOO_BAR_H+<+++Names and Order of Includes ~++Use standard order for readability and to avoid hidden dependencies: C+library, other libraries' `.h`, your project's `.h`.++    In foo.c order your includes as follows:++	1. C system files.+	2. Other libraries' `.h` files.+	3. Your project's `.h` files.++    Exception: sometimes, system-specific code needs conditional includes.+    Such code can put conditional includes after other includes. Of course,+    keep your system-specific code small and localized.+++Constants ~++Do not use macros to define constants in headers.++Macro constants in header files cannot be used by unit tests.++However, you are allowed to define a macro that holds the same value as a+non-enum constant (defined in the same header) if the value of the constant+represents the size of an array.+++==============================================================================+Scoping						*style-scope* *style-scoping*++Local Variables ~++Place a function's variables in the narrowest scope possible, and initialize+variables in the declaration.++C99 allows you to declare variables anywhere in a function. Declare them in as+local a scope as possible, and as close to the first use as possible. This+makes it easier for the reader to find the declaration and see what type the+variable is and what it was initialized to. In particular, initialization+should be used instead of declaration and assignment, e.g. >++    int i;+    i = f();      // Bad -- initialization separate from declaration.++    int j = g();  // Good -- declaration has initialization.+++==============================================================================+Neovim-Specific Magic++clint ~++Use `clint.py` to detect style errors.++`clint.py` is a tool that reads a source file and identifies many style+errors. It is not perfect, and has both false positives and false negatives,+but it is still a valuable tool. False positives can be ignored by putting `//+NOLINT` at the end of the line.+++==============================================================================+Other C Features					    *style-c-features*+++Variable-Length Arrays and alloca() ~++We do not allow variable-length arrays or `alloca()`.++Variable-length arrays can cause hard to detect stack overflows.+++Postincrement and Postdecrement ~++Use postfix form (`i++`) in statements. >++    for (int i = 0; i < 3; i++) { }+    int j = ++i;  // OK: ++i is used as an expression.++    for (int i = 0; i < 3; ++i) { }+    ++i;  // BAD: ++i is used as a statement.+++Use of const ~++Use `const` pointers whenever possible. Avoid `const` on non-pointer parameter definitions.++    Where to put the const ~++    Some people favor the form `int const *foo` to `const int *foo` . They+    argue that this is more readable because it's more consistent: it keeps+    the rule that `const` always follows the object it's describing. However,+    this consistency argument doesn't apply in codebases with few+    deeply-nested pointer expressions since most `const` expressions have only+    one `const`, and it applies to the underlying value. In such cases, there's+    no consistency to maintain. Putting the `const` first is arguably more+    readable, since it follows English in putting the ""adjective"" (`const`)+    before the ""noun"" (`int`).++    That said, while we encourage putting `const` first, we do not require it.+    But be consistent with the code around you! >++    void foo(const char *p, int i);+    }++    int foo(const int a, const bool b) {+    }++    int foo(int *const p) {+    }+++Integer Types ~++Of the built-in integer types only use `char`, `int`, `uint8_t`, `int8_t`,+`uint16_t`, `int16_t`, `uint32_t`, `int32_t`, `uint64_t`, `int64_t`,+`uintmax_t`, `intmax_t`, `size_t`, `ssize_t`, `uintptr_t`, `intptr_t`, and+`ptrdiff_t`.++Use `int` for error codes and local, trivial variables only.++Use care when converting integer types. Integer conversions and promotions can+cause non-intuitive behavior. Note that the signedness of `char` is+implementation defined.++Public facing types must have fixed width (`uint8_t`, etc.)++There are no convenient `printf` format placeholders for fixed width types.+Cast to `uintmax_t` or `intmax_t` if you have to format fixed width integers.++Type		unsigned    signed+`char`		`%hhu`	    `%hhd`+`int`		n/a	    `%d`+`(u)intmax_t`	`%ju`	    `%jd`+`(s)size_t`	`%zu`	    `%zd`+`ptrdiff_t`	`%tu`	    `%td`+++Booleans ~++Use `bool` to represent boolean values. >++    int loaded = 1;  // BAD: loaded should have type bool.+++Variable declarations ~++Declare only one variable per line. >++    int i, j = 1+++Conditions ~++Don't use ""yoda-conditions"". Use at most one assignment per condition. >++    if (1 == x) {++    if (x == 1) {  //use this order+    +    if ((x = f()) && (y = g())) {+++Function declarations ~++Every function must not have a separate declaration.++Function declarations are created by the gendeclarations.lua script. >++    static void f(void);++    static void f(void)+    {+      ...+    }+++General translation unit layout ~++The definitions of public functions precede the definitions of static+functions. >++    <HEADER>++    <PUBLIC FUNCTION DEFINITIONS>++    <STATIC FUNCTION DEFINITIONS>+++Integration with declarations generator ~++Every C file must contain #include of the generated header file, guarded by+#ifdef INCLUDE_GENERATED_DECLARATIONS.++Include must go after other #includes and typedefs in .c files and after+everything else in header files. It is allowed to omit #include in a .c file+if .c file does not contain any static functions.++Included file name consists of the .c file name without extension, preceded by+the directory name relative to src/nvim. Name of the file containing static+functions declarations ends with `.c.generated.h`, `*.h.generated.h` files+contain only non-static function declarations. >++    // src/nvim/foo.c file+    #include <stddef.h>++    typedef int FooType;++    #ifdef INCLUDE_GENERATED_DECLARATIONS+    # include ""foo.c.generated.h""+    #endif++    ���+++    // src/nvim/foo.h file+    #ifndef NVIM_FOO_H+    #define NVIM_FOO_H++    ���++    #ifdef INCLUDE_GENERATED_DECLARATIONS+    # include ""foo.h.generated.h""+    #endif+    #endif  // NVIM_FOO_H+++64-bit Portability ~++Code should be 64-bit and 32-bit friendly. Bear in mind problems of printing,+comparisons, and structure alignment.++- Remember that `sizeof(void *)` != `sizeof(int)`. Use `intptr_t` if you want+  a pointer-sized integer.++- You may need to be careful with structure alignments, particularly for+  structures being stored on disk. Any class/structure with a+  `int64_t`/`uint64_t` member will by default end up being 8-byte aligned on a+  64-bit system. If you have such structures being shared on disk between+  32-bit and 64-bit code, you will need to ensure that they are packed the+  same on both architectures. Most compilers offer a way to alter structure+  alignment. For gcc, you can use `__attribute__((packed))`. MSVC offers+  `#pragma pack()` and `__declspec(align())`.++- Use the `LL` or `ULL` suffixes as needed to create 64-bit constants. For+  example: >++    int64_t my_value = 0x123456789LL;+    uint64_t my_mask = 3ULL << 48;+++sizeof ~++Prefer `sizeof(varname)` to `sizeof(type)`.++Use `sizeof(varname)` when you take the size of a particular variable.+`sizeof(varname)` will update appropriately if someone changes the variable+type either now or later. You may use `sizeof(type)` for code unrelated to any+particular variable, such as code that manages an external or internal data+format where a variable of an appropriate C type is not convenient. >++    Struct data;+    memset(&data, 0, sizeof(data));++    memset(&data, 0, sizeof(Struct));++    if (raw_size < sizeof(int)) {+      fprintf(stderr, ""compressed record not big enough for count: %ju"", raw_size);+      return false;+    }+++==============================================================================+Naming								*style-naming*",all of the tags in this file should be prefixed with `dev-`. They are only relevant to core devs.```suggestionNaming								*dev-style-naming*```,
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/15079,714064082,2021-09-22T15:30:37Z,src/nvim/lua/executor.c,"@@ -1809,3 +1810,64 @@ void nlua_execute_log_keystroke(int c) #endif } +// Checks if str is in blacklist array+bool is_in_blacklist(const char *str, char *blacklist[], int blacklist_size)+{+  for (int i = 0; i < blacklist_size; i++) {+    if (strcmp(blacklist[i], str) == 0) {+      return true;+    }+  }+  return false;+}+// Get sctx of current file being sourc3d if doesn't exsist genarate it+static sctx_T *nlua_get_sourcing_sctx(void)+{+  lua_State *const lstate = global_lstate;+  sctx_T *retval = (sctx_T *)xmalloc(sizeof(sctx_T));+  retval->sc_seq = -1;+  retval->sc_sid = SID_LUA;+  retval->sc_lnum = -1;+  lua_Debug *info = (lua_Debug *)xmalloc(sizeof(lua_Debug));++  // Files where internal wrappers are defined so we can ignore them+  // like vim.o/opt etc are defined in _meta.lua+  char *blacklist[] = {+    ""vim/_meta.lua"",",@bfredl @justinmk Should we provide users a way to append to this list?For example if user is using a wrapper around api / a plugin all the verbose resultwill point to that wrapper/plugin location .I'm not sure adding an option for this is worth it or not since it'll be only for very specific case in lua.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15742,714227548,2021-09-22T19:00:29Z,runtime/lua/vim/diagnostic.lua,"@@ -524,6 +542,9 @@ end ---                       severity |diagnostic-severity| ---                       * source: (string) Include the diagnostic source in virtual ---                       text. One of ""always"" or ""if_many"".+---                       * format: (function) A function that takes a diagnostic as input and","I included an example. Considering it's a one argument function and Lua doesn't have a way to indicate return value using its own syntax, I wasn't sure how to indicate the signature in an unambiguous way (suggestions welcome).I think prose + example is clearer than something cryptic like `diagnostic -> string`. Open to changing it tho",X
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,714244116,2021-09-22T19:25:19Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,180 @@+local M = {}+local util = require ""vim.lsp.util""+local highlight = require ""vim.highlight""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}+local last_tick = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}++---@private+local function make_cache(base_map)+  return setmetatable({}, { __index = function(outer_table, ft)+    local rtn = setmetatable({}, { __index = function(inner_table, key)+      local hl = base_map[key]+      if hl then+        hl = highlight._link_default_highlight_once(ft..hl, hl)+        rawset(inner_table, key, hl)+        return hl+      end+    end})+    rawset(outer_table, ft, rtn)+    return rtn+  end})+end++local token_cache = make_cache(M.token_map)+local modifiers_cache = make_cache(M.modifiers_map)++---@private+local function highlight(buf, token, hl)+  vim.highlight.range(buf, ns, hl, {token.line, token.start_char}, {token.line, token.start_char + token.length})+end++---@private+local function highlight_token(buf, token, token_cache, modifiers_cache)+  local hl = token_cache[token.type]+  if hl then+    highlight(buf, token, hl)+  end+  for _, m in pairs(token.modifiers) do+    hl = modifiers_cache[m]+    if hl then+      highlight(buf, token, hl)+    end+  end+end++function M._handle_full(response, ctx, _)+  vim.api.nvim_buf_clear_namespace(ctx.bufnr, ns, 0, -1)+  -- if tick is has changed our response is outdated!+  if last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data+  local ft = vim.api.nvim_buf_get_option(ctx.bufnr, ""filetype"")+  local ft_token_cache = token_cache[ft]+  local ft_modifiers_cache = modifiers_cache[ft]++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)",TODO: maybe here and use the number instead. Would maybe be better to look up combination of modifiers just by their bit pattern. type_number * 2#modifiers + modifier_number,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,714249495,2021-09-22T19:33:21Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,158 @@+local M = {}+local util = require ""vim.lsp.util""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}",I would assume that users will still use regex/tree-sitter highlights because they are fast and only use LSP for some hand-picked extras on top that can only be resolved with semantic insights. Or should I draw using LSP only when the information is available for the current moment?I just remember that it was a huge discussion to map the tree-sitter token somehow to the built-in groups. But it could of course be done,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15079,714276892,2021-09-22T20:14:49Z,src/nvim/lua/executor.c,"@@ -1809,3 +1810,64 @@ void nlua_execute_log_keystroke(int c) #endif } +// Checks if str is in blacklist array+bool is_in_blacklist(const char *str, char *blacklist[], int blacklist_size)+{+  for (int i = 0; i < blacklist_size; i++) {+    if (strcmp(blacklist[i], str) == 0) {+      return true;+    }+  }+  return false;+}+// Get sctx of current file being sourc3d if doesn't exsist genarate it+static sctx_T *nlua_get_sourcing_sctx(void)+{+  lua_State *const lstate = global_lstate;+  sctx_T *retval = (sctx_T *)xmalloc(sizeof(sctx_T));+  retval->sc_seq = -1;+  retval->sc_sid = SID_LUA;+  retval->sc_lnum = -1;+  lua_Debug *info = (lua_Debug *)xmalloc(sizeof(lua_Debug));++  // Files where internal wrappers are defined so we can ignore them+  // like vim.o/opt etc are defined in _meta.lua+  char *blacklist[] = {+    ""vim/_meta.lua"",","Not really sure we want this at all. We're already iterating the stacktrace... why are we throwing away that gold? We could show the full stacktrace after the `Last set from...` line.We can truncate long stacktraces. If stacktraces tend to be deep, then we can start filtering out useless parts.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15079,714435926,2021-09-23T02:44:03Z,src/nvim/lua/executor.c,"@@ -1809,3 +1810,64 @@ void nlua_execute_log_keystroke(int c) #endif } +// Checks if str is in blacklist array+bool is_in_blacklist(const char *str, char *blacklist[], int blacklist_size)+{+  for (int i = 0; i < blacklist_size; i++) {+    if (strcmp(blacklist[i], str) == 0) {+      return true;+    }+  }+  return false;+}+// Get sctx of current file being sourc3d if doesn't exsist genarate it+static sctx_T *nlua_get_sourcing_sctx(void)+{+  lua_State *const lstate = global_lstate;+  sctx_T *retval = (sctx_T *)xmalloc(sizeof(sctx_T));+  retval->sc_seq = -1;+  retval->sc_sid = SID_LUA;+  retval->sc_lnum = -1;+  lua_Debug *info = (lua_Debug *)xmalloc(sizeof(lua_Debug));++  // Files where internal wrappers are defined so we can ignore them+  // like vim.o/opt etc are defined in _meta.lua+  char *blacklist[] = {+    ""vim/_meta.lua"",","we don't necessarily need to go in that direction. I'm just saying, there is no need for a ""blacklist"" concept. We are already iterating `lua_getstack`, right? Just collect the results into a string.",
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/15079,714489458,2021-09-23T05:55:36Z,src/nvim/ex_cmds2.c,"@@ -2928,48 +2928,8 @@ int do_source(char_u *fname, int check_other, int is_vimrc)   funccal_entry_T funccalp_entry;   save_funccal(&funccalp_entry); -  // Check if this script was sourced before to finds its SID.-  // If it's new, generate a new SID.-  // Always use a new sequence number.   const sctx_T save_current_sctx = current_sctx;-  current_sctx.sc_seq = ++last_current_SID_seq;-  current_sctx.sc_lnum = 0;-  FileID file_id;-  bool file_id_ok = os_fileid((char *)fname_exp, &file_id);-  assert(script_items.ga_len >= 0);-  for (current_sctx.sc_sid = script_items.ga_len; current_sctx.sc_sid > 0;-       current_sctx.sc_sid--) {-    si = &SCRIPT_ITEM(current_sctx.sc_sid);-    // Compare dev/ino when possible, it catches symbolic links.-    // Also compare file names, the inode may change when the file was edited.-    bool file_id_equal = file_id_ok && si->file_id_valid-                         && os_fileid_equal(&(si->file_id), &file_id);-    if (si->sn_name != NULL-        && (file_id_equal || fnamecmp(si->sn_name, fname_exp) == 0)) {-      break;-    }-  }-  if (current_sctx.sc_sid == 0) {-    current_sctx.sc_sid = ++last_current_SID;-    ga_grow(&script_items, (int)(current_sctx.sc_sid - script_items.ga_len));-    while (script_items.ga_len < current_sctx.sc_sid) {-      script_items.ga_len++;-      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;-      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = false;-    }-    si = &SCRIPT_ITEM(current_sctx.sc_sid);-    si->sn_name = fname_exp;-    fname_exp = vim_strsave(si->sn_name);  // used for autocmd",fname_exp is also an allocated string inside `do_source` function . It was allocated [here](https://www.github.com/shadmansaleh/neovim/blob/b62b274c56821940e7fbb6f9a6cb527a34de9d40/src/nvim/ex_cmds2.c#L2050)before```si->sn_name = fname_exp;fname_exp = vim_strsave(si->sn_name);  ````fname_exp` was stored in `si` and new copy was made of that then `fname_exp` gets cleared at end of this gets cleared by (threadend:) or autocmd call .Does it matter which copy gets cleared ? We made a copy so a valid name stays in `script_items` garray_T right ?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14871,714786449,2021-09-23T13:16:33Z,src/cjson/lua_cjson.c,"@@ -0,0 +1,1609 @@+/* Lua CJSON - JSON support for Lua+ *+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>+ *+ * Permission is hereby granted, free of charge, to any person obtaining+ * a copy of this software and associated documentation files (the+ * ""Software""), to deal in the Software without restriction, including+ * without limitation the rights to use, copy, modify, merge, publish,+ * distribute, sublicense, and/or sell copies of the Software, and to+ * permit persons to whom the Software is furnished to do so, subject to+ * the following conditions:+ *+ * The above copyright notice and this permission notice shall be+ * included in all copies or substantial portions of the Software.+ *+ * THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.+ */++/* Caveats:+ * - JSON ""null"" values are represented as lightuserdata since Lua+ *   tables cannot contain ""nil"". Compare with cjson.null.+ * - Invalid UTF-8 characters are not detected and will be passed+ *   untouched. If required, UTF-8 error checking should be done+ *   outside this library.+ * - Javascript comments are not part of the JSON spec, and are not+ *   currently supported.+ *+ * Note: Decoding is slower than encoding. Lua spends significant+ *       time (30%) managing tables when parsing JSON since it is+ *       difficult to know object/array sizes ahead of time.+ */++#include <assert.h>+#include <stdint.h>+#include <string.h>+#include <math.h>+#include <limits.h>+#include <lua.h>+#include <lauxlib.h>++#include ""nvim/lua/executor.h""",can we avoid this circular dependency? I don't see any `nlua_*` calls below...,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14871,714991327,2021-09-23T17:04:09Z,src/nvim/CMakeLists.txt,"@@ -186,6 +186,10 @@ if(NOT MSVC)     set_source_files_properties(       eval/funcs.c PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-conversion"")   endif()+  # lua-cjson: ignore strict and missing prototypes for cjson+  file(GLOB CJSON_SOURCES ../cjson/*.c)+  set_source_files_properties(+    ${CJSON_SOURCES} PROPERTIES COMPILE_FLAGS ""${COMPILE_FLAGS} -Wno-strict-prototypes -Wno-missing-prototypes -Wno-conversion"")","I fixed the missing prototypes warning, (it was from unused functions), are we ok with silencing strict prototypes? ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15079,715261732,2021-09-24T01:41:00Z,src/nvim/ex_cmds2.c,"@@ -2928,48 +2928,8 @@ int do_source(char_u *fname, int check_other, int is_vimrc)   funccal_entry_T funccalp_entry;   save_funccal(&funccalp_entry); -  // Check if this script was sourced before to finds its SID.-  // If it's new, generate a new SID.-  // Always use a new sequence number.   const sctx_T save_current_sctx = current_sctx;-  current_sctx.sc_seq = ++last_current_SID_seq;-  current_sctx.sc_lnum = 0;-  FileID file_id;-  bool file_id_ok = os_fileid((char *)fname_exp, &file_id);-  assert(script_items.ga_len >= 0);-  for (current_sctx.sc_sid = script_items.ga_len; current_sctx.sc_sid > 0;-       current_sctx.sc_sid--) {-    si = &SCRIPT_ITEM(current_sctx.sc_sid);-    // Compare dev/ino when possible, it catches symbolic links.-    // Also compare file names, the inode may change when the file was edited.-    bool file_id_equal = file_id_ok && si->file_id_valid-                         && os_fileid_equal(&(si->file_id), &file_id);-    if (si->sn_name != NULL-        && (file_id_equal || fnamecmp(si->sn_name, fname_exp) == 0)) {-      break;-    }-  }-  if (current_sctx.sc_sid == 0) {-    current_sctx.sc_sid = ++last_current_SID;-    ga_grow(&script_items, (int)(current_sctx.sc_sid - script_items.ga_len));-    while (script_items.ga_len < current_sctx.sc_sid) {-      script_items.ga_len++;-      SCRIPT_ITEM(script_items.ga_len).sn_name = NULL;-      SCRIPT_ITEM(script_items.ga_len).sn_prof_on = false;-    }-    si = &SCRIPT_ITEM(current_sctx.sc_sid);-    si->sn_name = fname_exp;-    fname_exp = vim_strsave(si->sn_name);  // used for autocmd","the lifetimes are different. > then `fname_exp` gets cleared at end of this gets cleared by (threadend:) or autocmd call . `apply_autocmds` sets the global `autocmd_fname` to the fname that was passed. The lifetime of this is tricky, see https://github.com/neovim/neovim/commit/189c5abeba4fb508d879ebbf5fa07965c4092cf2 for example.With your changes here, the lifetimes are swapped. It looks like `fname_exp` is allocated in this function, ok. But it's also aliased to a global: https://github.com/neovim/neovim/blob/844a28bd041cc1abcc90e7d65eb24a08ff6ab6b4/src/nvim/ex_cmds2.c#L2141It's risky to just swap this. It can cause difficult bugs later.The `// used for autocmd` comment is a big ol' hint that doesn't quite do justice to how delicate this is.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15771,715503567,2021-09-24T10:35:32Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)+---               Function to format an+---               individual entry from `entries`. Defaults to `tostring`.+---@param callback function ((entry|nil, idx|nil) -> ())+---               Called once the user made a choice.+---               `idx` is the 1-based index of `entry` within `entries`.+---               `nil` if the user aborted the dialog.+function M.pick_one(entries, opts, callback)+  opts = opts or {}+  local choices = {opts.prompt or 'Pick one of:'}+  local format_entry = opts.format_entry or tostring+  for i, item in pairs(entries) do+    table.insert(choices, string.format('%d: %s', i, format_entry(item)))+  end","If we wanted, we could support `entries` being a function following the iterator protocol. It would make 3rd party `pick_one` implementations slightly more complex, but it would enable support for providing the data lazily, avoiding the need to fully materialize a table with all items. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15771,715517888,2021-09-24T10:59:47Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)",weird name. can be avoided by renaming `entries` to `items`.```suggestion---     - format_item (function entry -> text)```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15771,715524595,2021-09-24T11:12:02Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)+---               Function to format an+---               individual entry from `entries`. Defaults to `tostring`.+---@param callback function ((entry|nil, idx|nil) -> ())+---               Called once the user made a choice.+---               `idx` is the 1-based index of `entry` within `entries`.+---               `nil` if the user aborted the dialog.+function M.pick_one(entries, opts, callback)","maybe we can find a name that (1) draws on existing conventions and (2) generalizes beyond the ""picker"" case. ""pick"" is a new verb that comes from vscode I assume. Since this appears to be a thin wrapper around input(),  consider naming this ...- `vim.ui.input()` for discoverability and analogy with the existing `input()` (also common in [HTML forms](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input))- some other verb that's common in UI frameworks. Typically ""select"" (also in [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select))""input"" seems like it works. We could have `vim.ui.input()`, `vim.ui.input_multi()`, and other `vim.ui.input_xx()` if we need more advanced things. ",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15771,715569115,2021-09-24T12:27:52Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options","It's using `inputlist` under the hood, not `input`. And I'd consider `inputlist` an implementation detail.And I'd rather start small and add more options as use-cases arise instead of anticipating more up-front.Considering that this is intended as an extension point to be overridden we also have to consider what's easy or hard to implement. E.g. if you want to dispatch to a tool like `fzf`.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15771,715571218,2021-09-24T12:30:52Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)+---               Function to format an+---               individual entry from `entries`. Defaults to `tostring`.+---@param callback function ((entry|nil, idx|nil) -> ())+---               Called once the user made a choice.+---               `idx` is the 1-based index of `entry` within `entries`.+---               `nil` if the user aborted the dialog.+function M.pick_one(entries, opts, callback)","I think `input` is ambiguous - `vim.fn.input` already exists and is for taking a literal string as input.I'd rather go with `select` in that case, though picker / pick is also used in a couple of UI frameworks - we're not inventing a new term, but I'm fine with either. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15771,715604340,2021-09-24T13:17:10Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options","> And I'd consider inputlist an implementation detail.Sure, but that's orthogonal to asking if there is a reason to diverge from its interface as a basic model. > And I'd rather start small and add more options as use-cases arise instead of anticipating more up-front.Sure, the point is to mark the missing options as TODO so that we don't invent similar but different options in the future. Use input() as a reference point unless there is a conscious reason to diverge.> Considering that this is intended as an extension point to be overridden we also have to consider what's easy or hard to implement. E.g. if you want to dispatch to a tool like fzf.- Is there also a goal of having an easy-to-use interface? If so, those are in conflict.-  if we have a sparse interface that is easy to override, does that risk it being ignored in favor of full-featured implementations?- can ""easy to override"" be achieved by allowing partial implementations ?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15771,715606899,2021-09-24T13:20:32Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)+---               Function to format an+---               individual entry from `entries`. Defaults to `tostring`.+---@param callback function ((entry|nil, idx|nil) -> ())+---               Called once the user made a choice.+---               `idx` is the 1-based index of `entry` within `entries`.+---               `nil` if the user aborted the dialog.+function M.pick_one(entries, opts, callback)","> `vim.fn.input` already exists and is for taking a literal string as input.Please do _not_ choose names that are different from existing vimscript functions for that purpose. That is completely the wrong practice. It results in a mismash of APIs that are similar but have N different names for the same concept.> though picker / pick is also used in a couple of UI frameworks - we're not inventing a new term, It is new in vim ecosystem.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15771,715621320,2021-09-24T13:39:14Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)+---               Function to format an+---               individual entry from `entries`. Defaults to `tostring`.+---@param callback function ((entry|nil, idx|nil) -> ())+---               Called once the user made a choice.+---               `idx` is the 1-based index of `entry` within `entries`.+---               `nil` if the user aborted the dialog.+function M.pick_one(entries, opts, callback)","> It results in a mismash of APIs that are similar but have N different names for the same concept.Prompting a user for an input string (`vim.fn.input`) and asking the user to select a single element from a collection of elements (`vim.ui.pick_one`) are two different concepts. Yes, you can zoom out and view both as ""asking user for input"", but in the context of how these two functions are going to be used, the different semantic is important.To be clear, I'm not hung up on the `pick_one` name. But I'm pretty sure that using `input` is not the best idea idea either.If we wanted to stick with existing naming, I'd rather go with another `inputlist`, though I personally dislike the term because it is focused on what is supplied as main parameter, and not on what the function does. (And speaking of existing functions, there is also `confirm` which is also kinda similar).",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15771,715628099,2021-09-24T13:47:53Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options","> Sure, but that's orthogonal to asking if there is a reason to diverge from its interface as a basic model.But they are are different functions.Looking at the `opts` of `input`:`default` as string value doesn't make sense. What would make sense is to indicate which item should be preselected. But I think `pick_one` (or whatever we call it) should also work as fuzzy filter - given that one of the use-cases is to allow telescope to override it, and many people use telescope as generic fuzzy finder picker.`completion` - doesn't make sense in the context of choosing one item from many(?)`cancelreturn` - might make sense, though I think it is kinda redundant as a feature and the word `return` is a poor fit given that the `pick_one` function uses a callback.`highlight` - May be an option for the future. I don't know.> Sure, the point is to mark the missing options as TODO so that we don't invent similar but different options in the future.I can add a TODO in the function body, but I wouldn't put it in the user-facing docs?> Is there also a goal of having an easy-to-use interface? If so, those are in conflict.It is a goal and I don't see how it is in conflict. It adds some constraints in how powerful the function can get.> if we have a sparse interface that is easy to override, does that risk it being ignored in favor of full-featured implementations?Possibly to some degree. I think input from @tjdevries  would be very valueable here due to the experience with Telescope. > can ""easy to override"" be achieved by allowing partial implementations ?Possibly, but then we've to make sure that they degrade to something that is still working in a basic form.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15771,715720379,2021-09-24T15:43:05Z,runtime/lua/vim/ui.lua,"@@ -0,0 +1,32 @@+local M = {}++--- Prompts the user to pick a single item from a collection of entries+---+---@param entries table Arbitrary entries+---@param opts table Additional options+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Pick one of:`+---     - format_entry (function entry -> text)+---               Function to format an+---               individual entry from `entries`. Defaults to `tostring`.+---@param callback function ((entry|nil, idx|nil) -> ())+---               Called once the user made a choice.+---               `idx` is the 1-based index of `entry` within `entries`.+---               `nil` if the user aborted the dialog.+function M.pick_one(entries, opts, callback)","+1 for `select`. It's short, simple, easy to understand, maps well to this use case, and has existing usage with similar semantics (e.g. in HTML).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13457,715721378,2021-09-24T15:44:34Z,src/nvim/api/vim.c,"@@ -250,32 +249,37 @@ void nvim_set_hl(Integer ns_id, String name, Dictionary val, Error *err) /// |nvim_set_decoration_provider| on_win and on_line callbacks /// are explicitly allowed to change the namespace during a redraw cycle. ///-/// @param ns_id the namespace to activate+// @param ns_id the namespace to activate /// @param[out] err Error details, if any-void nvim__set_hl_ns(Integer ns_id, Error *err)-  FUNC_API_FAST+void nvim_set_hl_ns(Integer ns_id, Error *err)+  FUNC_API_SINCE(7) {-  if (ns_id >= 0) {-    ns_hl_active = (NS)ns_id;-  }--  // TODO(bfredl): this is a little bit hackish.  Eventually we want a standard-  // event path for redraws caused by ""fast"" events. This could tie in with-  // better throttling of async events causing redraws, such as non-batched-  // nvim_buf_set_extmark calls from async contexts.-  if (!provider_active && !ns_hl_changed) {-    multiqueue_put(main_loop.events, on_redraw_event, 0);+  if (ns_id < 0) {+    api_set_error(err, kErrorTypeValidation, ""no such namespace"");+    return;   }-  ns_hl_changed = true;+  ns_hl_global = (NS)ns_id;+  hl_check_ns();+  redraw_all_later(NOT_VALID); } -static void on_redraw_event(void **argv)-  FUNC_API_NOEXPORT+/// Set active namespace for highlights.+///+/// NB: this function can be called from async contexts, but the+/// semantics are not yet well-defined. To start with+/// |nvim_set_decoration_provider| on_win and on_line callbacks+/// are explicitly allowed to change the namespace during a redraw cycle.+///+/// @param ns_id the namespace to activate+/// @param[out] err Error details, if any+void nvim_set_hl_ns_fast(Integer ns_id, Error *err)","don't think we should start adding ""fast"" suffix to api names. It's already covered by an attribute and could be part of the metadata if it isn't already.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/14871,715934344,2021-09-24T22:27:39Z,test/functional/lua/json_spec.lua,"@@ -0,0 +1,26 @@+local helpers = require('test.functional.helpers')(after_each)+local clear = helpers.clear+local exec_lua = helpers.exec_lua+local eq = helpers.eq++describe('lua-cjson', function()+  before_each(function()+    clear()+  end)++  it('can encode json', function()++    eq(+     '{""hello"":""world""}' ,+      exec_lua([[return vim.json.encode({ hello = 'world'})]])+    )+  end)++  it('can decode json', function()++    eq(+      { hello = 'world'},+      exec_lua([[return vim.json.decode('{""hello"":""world""}')]])","(not a blocker, but at least mentioning for reference...)i kinda assumed more tests were on the way. Maybe copy a few from `json_functions_spec.lua` ? Or parameterize (most of) the tests in `json_functions_spec.lua`, then in this file, something like:```lualocal json_spec = require('test.functional.json_functions_spec')local json_encode = function(o)  exec_lua([[return vim.json.encode(...)]], o)endlocal json_decode = function(o) ... endjson_spec.run(json_encode, json_decode)```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15218,715958563,2021-09-25T00:07:00Z,runtime/lua/vim/shared.lua,"@@ -98,17 +98,41 @@ end --- <pre> ---  split("":aa::b:"", "":"")     --> {'','aa','','b',''} ---  split(""axaby"", ""ab?"")     --> {'','x','y'}----  split(x*yz*o, ""*"", true)  --> {'x','yz','o'}+---  split(""x*yz*o"", ""*"", true)  --> {'x','yz','o'}+---  split(""|x|y|z|"", ""|"", true, true) --> {'x', 'y', 'z'} --- </pre>------@see |vim.gsplit()| ------@param s String to split---@param sep Separator string or pattern---@param plain If `true` use `sep` literally (passed to String.find)---@returns List-like table of the split components.-function vim.split(s,sep,plain)-  local t={} for c in vim.gsplit(s, sep, plain) do table.insert(t,c) end+---@see |vim.gsplit()|+---+---@param s String to split+---@param sep Separator string or pattern+---@param plain If `true` use `sep` literally (passed to String.find)+---@param trimempty If `true` remove empty items from the front and back of the list+---@returns List-like table of the split components.+function vim.split(s, sep, plain, trimempty)","It���s not ���noempty��� though, only empty elements from the front and back of the array are removed. ���noempty��� implies *all* empty elements are removed.though I guess the vim parameter ���keepempty��� suffers from the same ambiguity.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15723,716028484,2021-09-25T11:17:11Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,158 @@+local M = {}+local util = require ""vim.lsp.util""+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = {}++local function modifiers_from_number(x, modifiers_table)+  local function get_bit(n, k)+    -- Based on/from https://stackoverflow.com/a/26230537+    -- (n >> k) & 1+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}","I am strongly in favor of defining new, basic highlight groups for these new kinds of tokens; these could (and should) be linked by default to the classical vim groups to make them visible out of the box. That allows a decent OOTB experience while still allowing maximal customization (which I hold to be a major yardstick for Neovim).I'm not going to bikeshed on the actual names, although they seem fine to me.(*Ceterum censeo* the builtin standard groups are starting to show their age and are becoming increasingly restrictive for Neovim's rapidly expanding use. Might be worth revisiting at some point, especially in connection with tree-sitter graduating to first-class syntax highlighter -- whenever that will be.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15218,716107932,2021-09-25T22:56:55Z,runtime/lua/vim/shared.lua,"@@ -98,17 +98,41 @@ end --- <pre> ---  split("":aa::b:"", "":"")     --> {'','aa','','b',''} ---  split(""axaby"", ""ab?"")     --> {'','x','y'}----  split(x*yz*o, ""*"", true)  --> {'x','yz','o'}+---  split(""x*yz*o"", ""*"", true)  --> {'x','yz','o'}+---  split(""|x|y|z|"", ""|"", true, true) --> {'x', 'y', 'z'} --- </pre>------@see |vim.gsplit()| ------@param s String to split---@param sep Separator string or pattern---@param plain If `true` use `sep` literally (passed to String.find)---@returns List-like table of the split components.-function vim.split(s,sep,plain)-  local t={} for c in vim.gsplit(s, sep, plain) do table.insert(t,c) end+---@see |vim.gsplit()|+---+---@param s String to split+---@param sep Separator string or pattern+---@param plain If `true` use `sep` literally (passed to String.find)+---@param trimempty If `true` remove empty items from the front and back of the list+---@returns List-like table of the split components.+function vim.split(s, sep, plain, trimempty)","> kwargs variant is a good idea. If we go that route it would make sense to also make `{plain}` a keyword arg so that we don't mix positional and keyword arguments, but we can't do this without breaking backward compatibilitytypicall pattern is to accept exactly 1 arg for the kwargs variant. That's backward-compatible because normally arg1 is a string, not a table. See e.g. screen:expect() https://github.com/neovim/neovim/blob/b854e3ee8c7234f0e144c5e850c3cea9c3e01388/test/functional/ui/screen.lua#L315-L319It's a bit noisy in the impl, but we can start to build common util functions since this is a pattern that should be pervasive (or just start kwargs from the beginning for most functions).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15785,716109444,2021-09-25T23:14:20Z,runtime/lua/vim/diagnostic.lua,"@@ -794,8 +794,6 @@ end ---@param bufnr number Buffer number ---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the ---                       current diagnostics in the given buffer are used.----@param opts table Configuration table with the following keys:----            - priority: Set the priority of the signs |sign-priority|.","Yes, we should. I meant to only remove the ���priority��� option, not the whole parameter**EDIT:** although on further thought it shouldn't be removed at all. It's still useful to let users define the default sign priority in case they want to use something other than 10",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15788,716123360,2021-09-26T01:51:37Z,src/nvim/ex_docmd.c,"@@ -7710,8 +7710,12 @@ void free_cd_dir(void) /// Deal with the side effects of changing the current directory. /// /// @param scope  Scope of the function call (global, tab or window).-void post_chdir(CdScope scope, bool trigger_dirchanged)+void post_chdir(CdScope scope, bool trigger_dirchanged, char_u *previous_dir) {+  if (previous_dir != NULL) {+    prev_dir = vim_strsave(previous_dir);","I believe this is a leak, you need to free the old prev_dir.https://github.com/neovim/neovim/blob/70b854dbd2ae9763f8061052e1074cb14be27c00/src/nvim/ex_docmd.c#L7788",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/14871,716143453,2021-09-26T05:22:45Z,test/functional/lua/json_spec.lua,"@@ -0,0 +1,26 @@+local helpers = require('test.functional.helpers')(after_each)+local clear = helpers.clear+local exec_lua = helpers.exec_lua+local eq = helpers.eq++describe('lua-cjson', function()+  before_each(function()+    clear()+  end)++  it('can encode json', function()++    eq(+     '{""hello"":""world""}' ,+      exec_lua([[return vim.json.encode({ hello = 'world'})]])+    )+  end)++  it('can decode json', function()++    eq(+      { hello = 'world'},+      exec_lua([[return vim.json.decode('{""hello"":""world""}')]])","Looking through the tests, I think parameterizing them is going to be non-trivial, seems like many of them deal with vimscript specific behavior, or eval-ing a string representation of the vim command.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/15756,716143530,2021-09-26T05:23:52Z,third-party/CMakeLists.txt,"@@ -144,14 +144,8 @@ endif()  include(ExternalProject) -if(WIN32)-  # ""nvim"" branch of https://github.com/neovim/libuv-  set(LIBUV_URL https://github.com/neovim/libuv/archive/b899d12b0d56d217f31222da83f8c398355b69ef.tar.gz)-  set(LIBUV_SHA256 eb7e37b824887e1b31a4e31d1d9bad4c03d8b98532d9cce5f67a3b70495a4b2a)-else()-  set(LIBUV_URL https://github.com/libuv/libuv/archive/v1.42.0.tar.gz)-  set(LIBUV_SHA256 371e5419708f6aaeb8656671f89400b92a9bba6443369af1bb70bcd6e4b3c764)-endif()+set(LIBUV_URL https://github.com/libuv/libuv/archive/v1.42.0.tar.gz)+set(LIBUV_SHA256 371e5419708f6aaeb8656671f89400b92a9bba6443369af1bb70bcd6e4b3c764)","The reason why mignw32 fails to build libuv is due to incomplete modification of libuv/libuv/issues/3178 for MinGW-w64. I don't know if it is correct to report to msys2/MINGW-packages, but I created msys2/MINGW-packages/issues/9667 anyway. I think you should wait until it is fixed on the msys2/MINGW-packages side.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15795,716214520,2021-09-26T14:43:15Z,src/nvim/screen.c,"@@ -7810,20 +7826,20 @@ void limit_screen_size(void)  void win_new_shellsize(void) {-  static long old_Rows = 0;","> unless these are changed as well (which would be fine, if you want to do it).could cause a lot of shadowing, i would suggest renaming the globals to `g_rows`, `g_columns` if we are going to rename them.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15788,716269478,2021-09-26T22:10:04Z,test/functional/api/vim_spec.lua,"@@ -487,6 +489,31 @@ describe('API', function()     end)   end) +  describe('nvim_set_current_dir', function()+    local start_dir++    before_each(function()+      clear()+      lfs.mkdir(""testdir"")","typical pattern for test files is to prefix with ""X"". ```suggestion      funcs.mkdir(""Xtestdir"")```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15771,716284691,2021-09-27T00:07:25Z,runtime/lua/vim/lsp/handlers.lua,"@@ -116,42 +116,44 @@ M['textDocument/codeAction'] = function(_, result, ctx)     return   end -  local option_strings = {""Code actions:""}-  for i, action in ipairs(result) do-    local title = action.title:gsub('\r\n', '\\r\\n')-    title = title:gsub('\n', '\\n')-    table.insert(option_strings, string.format(""%d. %s"", i, title))-  end--  local choice = vim.fn.inputlist(option_strings)-  if choice < 1 or choice > #result then-    return-  end-  local action = result[choice]-  -- textDocument/codeAction can return either Command[] or CodeAction[]-  ---  -- CodeAction-  --  ...-  --  edit?: WorkspaceEdit    -- <- must be applied before command-  --  command?: Command-  ---  -- Command:-  --  title: string-  --  command: string-  --  arguments?: any[]-  ---  if action.edit then-    util.apply_workspace_edit(action.edit)-  end-  if action.command then-    local command = type(action.command) == 'table' and action.command or action-    local fn = vim.lsp.commands[command.command]-    if fn then-      fn(command, ctx)-    else-      buf.execute_command(command)+  ---@private+  local function handle_choice(action)",callbacks should usually be named with `on_` prefix. `:help dev-naming````suggestion  local function on_user_choice(action)```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15801,716286751,2021-09-27T00:19:13Z,MAINTAIN.md,"@@ -55,6 +55,23 @@ has a major bug:     - The [nightly job](https://github.com/neovim/bot-ci/blob/master/ci/nightly.sh)       will update the release assets based on the `stable` tag. +Third-party dependencies+--------------++The following are the third-party dependencies used in neovim.+  - [Klib](https://github.com/attractivechaos/klib)+  - [Lua](https://www.lua.org/download.html)+  - [LuaJIT](https://github.com/LuaJIT/LuaJIT)+  - [Luv](https://github.com/luvit/luv)+  - [libmpack](https://github.com/libmpack/libmpack)+  - [libtermkey](https://github.com/neovim/libtermkey)+  - [libuv](https://github.com/libuv/libuv)+  - [libvterm](http://www.leonerd.org.uk/code/libvterm/)+  - [lua-compat](https://github.com/keplerproject/lua-compat-5.3)+  - [tree-sitter](https://github.com/tree-sitter/tree-sitter)+  - [xdiff](https://github.com/git/git/tree/master/xdiff)+  - [lua-cjson](https://github.com/openresty/lua-cjson)","almost, klib is inlined so I would list it here also. Though it doesn't live in src/, we kinda forked it.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15815,716931824,2021-09-27T18:14:21Z,scripts/run_uncrustify.sh,"@@ -0,0 +1,70 @@+#!/usr/bin/env bash","@justinmk, This is not related to the makefile though. The make target is just there to make it easier.This script is allowing a better workflow for me, so I figured I could share it in case others find themselves in a similar boat. Use-case (1):While working on refactoring, I have no idea if I broke what uncrustify has already fixed or not. This allows me to check and _fix_ that. And please do try to run uncrustify on individual files to see how picky uncrustify can be about the arguments. Even the half-working `gq` command isn't ideal when I need to hard-code the configuration path in it.Use-case (2):Actually I won't go into this, I know you said forget the CI ����  ",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15820,717698442,2021-09-28T15:29:08Z,runtime/lua/vim/lsp/codelens.lua,"@@ -31,10 +31,24 @@ local function execute_lens(lens, bufnr, client_id)   local line = lens.range.start.line   api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1) +  local command = lens.command+  local fn = vim.lsp.commands[command.command]+  if fn then+    fn(command, { bufnr = bufnr, client_id = client_id })+    return+  end   -- Need to use the client that returned the lens ��� must not use buf_request   local client = vim.lsp.get_client_by_id(client_id)   assert(client, 'Client is required to execute lens, client_id=' .. client_id)-  client.request('workspace/executeCommand', lens.command, function(...)+  local command_provider = client.server_capabilities.executeCommandProvider",Also I still dislike this pattern of sanitizing capabilities and think we should change it but it's consistent with everything else so not important.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15658,717769518,2021-09-28T16:50:45Z,src/nvim/lua/executor.c,"@@ -397,6 +488,154 @@ static int nlua_wait(lua_State *lstate)   return 2; } +static void nlua_init_ref_state(nlua_ref_state_t *state)+  FUNC_ATTR_NONNULL_ALL+{+  state->nil_ref = LUA_NOREF;+  state->empty_dict_ref = LUA_NOREF;+}++static nlua_ref_state_t *nlua_get_ref_state(lua_State *lstate)+  FUNC_ATTR_NONNULL_ALL+{+  lua_getfield(lstate, LUA_REGISTRYINDEX, ""nlua.ref_state"");+  nlua_ref_state_t *ref_state = lua_touserdata(lstate, -1);+  lua_pop(lstate, 1);++  return ref_state;+}++LuaRef nlua_get_nil_ref(lua_State *lstate)+  FUNC_ATTR_NONNULL_ALL+{+  nlua_ref_state_t *ref_state = nlua_get_ref_state(lstate);+  return ref_state->nil_ref;+}++LuaRef nlua_get_empty_dict_ref(lua_State *lstate)+  FUNC_ATTR_NONNULL_ALL+{+  nlua_ref_state_t *ref_state = nlua_get_ref_state(lstate);+  return ref_state->empty_dict_ref;+}++static int nlua_get_ref_count(lua_State *lstate)+  FUNC_ATTR_NONNULL_ALL+{+  nlua_ref_state_t *ref_state = nlua_get_ref_state(lstate);+  return ref_state->ref_count;+}++int nlua_get_global_ref_count(void)+{+  lua_State *const lstate = global_lstate;+  return nlua_get_ref_count(lstate);+}++static void nlua_common_vim_init(lua_State *lstate, bool is_thread)+  FUNC_ATTR_NONNULL_ARG(1)+{+  nlua_ref_state_t *ref_state = xcalloc(1, sizeof(*ref_state));+  nlua_init_ref_state(ref_state);+  lua_pushlightuserdata(lstate, ref_state);","a lightuserdata that ""owns"" an allocation is an anti-pattern. use a full userdata to store the `nlua_ref_state_t` directly instead.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15846,719060665,2021-09-30T05:06:09Z,scripts/vim-patch.sh,"@@ -376,8 +376,13 @@ submit_pr() {   pr_title=""$(printf 'vim-patch:%s' ""${pr_title#,}"")""    if [[ $push_first -ne 0 ]]; then-    echo ""Pushing to 'origin/${checked_out_branch}'.""-    output=""$(git push origin ""${checked_out_branch}"" 2>&1)"" &&+    local checked_out_branch_remote+    checked_out_branch_remote=""$(git config --get ""branch.${checked_out_branch}.remote"")""","I guess I'm spoiled by [git hub](https://github.com/sociomantic-tsunami/git-hub/)'s behavior.The way all of my clones are setup, there are two remotes -- `fork` and `upstream`.  A plain `git pull` will pull from the tracking branch in upstream and a plain `git push` will push to `fork`.I usually create a branch with `git checkout -b foo upstream/master`.  Now, `git config --get branch.foo.remote` is going to show `upstream` for me, which isn't correct in your scenario.Granted, when `git hub` is being used, `$push_first` is false.  However, to handle similar setups, `git config --get remote.pushdefault` should probably be checked first.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15846,719470956,2021-09-30T14:34:29Z,scripts/vim-patch.sh,"@@ -124,13 +124,22 @@ commit_message() {   fi } -find_git_remote() {-  git_remote=$(git remote -v \+find_nvim_remote() {+  nvim_remote=$(git remote -v \     | awk '$2 ~ /github.com[:\/]neovim\/neovim/ && $3 == ""(fetch)"" {print $1; exit}')-  if [[ -z ""$git_remote"" ]]; then-    git_remote=""origin""+  if [[ -z ""$nvim_remote"" ]]; then+    nvim_remote=""origin""   fi-  echo ""$git_remote""+  echo ""$nvim_remote""+}++find_fork_remote() {","these functions are almost identical, can be easily parameterized. something like```local rif [ ""$1"" = fork ] ; then  r=$(git remote -v | awk '$2 !~ /github.com[:\/]neovim\/neovim/ && $3 == ""(fetch)"" {print $1; exit}')else  r=$(git remote -v | awk '$2 ~ /github.com[:\/]neovim\/neovim/ && $3 == ""(fetch)"" {print $1; exit}')fi```",X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15838,719492718,2021-09-30T14:56:13Z,runtime/lua/vim/ui.lua,"@@ -9,6 +9,10 @@ local M = {} ---     - format_item (function item -> text) ---               Function to format an ---               individual item from `items`. Defaults to `tostring`.+---     - type (string|nil)+---               Type of `items`. Useful for some implentations of+---               `select` which might inspect the structure of+---               `items`.",this explanation is useless.and the code change just looks random. what is going on here?,X
24906808,goolord,https://api.github.com/repos/neovim/neovim/pulls/15838,719514067,2021-09-30T15:19:05Z,runtime/lua/vim/ui.lua,"@@ -9,6 +9,10 @@ local M = {} ---     - format_item (function item -> text) ---               Function to format an ---               individual item from `items`. Defaults to `tostring`.+---     - type (string|nil)+---               Type of `items`. Useful for some implentations of+---               `select` which might inspect the structure of+---               `items`.","ok, maybe i did not do a good enough job explaining myself. i will try to summarize:there are many plugins which implement lsp handlers which just replace inputlist with some other ui element from another pluginhttps://github.com/gbrlsnchs/telescope-lsp-handlers.nvim, https://github.com/goolord/nvim-clap-lsp, https://github.com/weilbith/nvim-code-action-menuthese plugins *all* have to track the behavior of the codeAction handler on master sans the UI code, which i thought was unfortunate so i made this pr to separate that logic https://github.com/neovim/neovim/pull/15808the `vim.ui.select` pr was merged afterwards. it was suggested that these plugins could just re-implement `vim.ui.select`, which i think is the more generally useful and future-proof abstraction for this kind of plugin. for many would-be `vim.ui.select` replacements you may want to show a preview of what's being selected. for a codeaction, this is a diff, for a workspace symbol, this is a file, etc. if in the future, `vim.ui.select` is ever used for more than one type of data (likely), you would need some mechanism to dispatch different behavior based on the structure of `input`in the pr i linked https://github.com/neovim/neovim/pull/15808 the only person who responded to me agreed that this is a good enough solution, and it's a pretty small change, so i opened this pr :)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15832,720112432,2021-10-01T09:55:55Z,src/nvim/window.c,"@@ -853,11 +853,11 @@ void ui_ext_win_position(win_T *wp)       bool east = c.anchor & kFloatAnchorEast;       bool south = c.anchor & kFloatAnchorSouth; -      int comp_row = (int)row - (south ? wp->w_height : 0);-      int comp_col = (int)col - (east ? wp->w_width : 0);+      int comp_row = (int)row - (south ? wp->w_height_outer - 1 : 0);","the latter. think of the anchor point as the upper-left corner of the marked cell, not the middle of it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15867,720671240,2021-10-02T12:07:42Z,src/nvim/runtime.c,"@@ -332,40 +332,55 @@ int do_in_path_and_pp(char_u *path, char_u *name, int flags, DoInRuntimepathCB c   return done; } -static void push_path(RuntimeSearchPath *search_path, char *entry, bool after)+static void push_path(RuntimeSearchPath *search_path, Map(String, handle_T) *rtp_used,+                      char *entry, bool after) {-  kv_push(*search_path, ((SearchPathItem){ entry, after }));+  handle_T *h = map_ref(String, handle_T)(rtp_used, cstr_as_string((char *)entry), true);+  if (*h == 0) {+    (*h)++;+    kv_push(*search_path, ((SearchPathItem){ entry, after }));+  } } -static void expand_pack_entry(RuntimeSearchPath *search_path, CharVec *after_path,-                              char_u *pack_entry)+static void expand_rtp_entry(RuntimeSearchPath *search_path, Map(String, handle_T) *rtp_used,+                             char *entry, bool after) {-  static char_u buf[MAXPATHL], buf2[MAXPATHL];-  char *start_dir = ""/pack/*/start/*"";  // NOLINT-  if (STRLEN(pack_entry) + STRLEN(start_dir) + 1 < MAXPATHL) {-    xstrlcpy((char *)buf, (char *)pack_entry, MAXPATHL);-    xstrlcpy((char *)buf2, (char *)pack_entry, MAXPATHL);-    xstrlcat((char *)buf, start_dir, sizeof buf);-    xstrlcat((char *)buf2, ""/start/*"", sizeof buf);  // NOLINT-    int num_files;-    char_u **files;--    char_u *(pat[]) = { buf, buf2 };-    if (gen_expand_wildcards(2, pat, &num_files, &files, EW_DIR) == OK) {-      for (int i = 0; i < num_files; i++) {-        push_path(search_path, xstrdup((char *)files[i]), false);-        size_t after_size = STRLEN(files[i])+7;-        char *after = xmallocz(after_size);-        xstrlcpy(after, (char *)files[i], after_size);-        xstrlcat(after, ""/after"", after_size);-        if (os_isdir((char_u *)after)) {-          kv_push(*after_path, after);-        } else {-          xfree(after);-        }-      }-      FreeWild(num_files, files);+  if (map_get(String, handle_T)(rtp_used, cstr_as_string(entry))) {+    return;+  }++  if (!*entry) {+    push_path(search_path, rtp_used, xstrdup(entry), after);+  }++  int num_files;+  char_u **files;+  char_u *(pat[]) = { (char_u *)entry };+  if (gen_expand_wildcards(1, pat, &num_files, &files, EW_DIR) == OK) {+    for (int i = 0; i < num_files; i++) {+      push_path(search_path, rtp_used, xstrdup((char *)files[i]), after);+    }+    FreeWild(num_files, files);+  }+}++static void expand_pack_entry(RuntimeSearchPath *search_path, Map(String, handle_T) *rtp_used,+                              CharVec *after_path, char_u *pack_entry)+{+  static char buf[MAXPATHL];+  char *(start_pat[]) = { ""/pack/*/start/*"", ""/start/*"" };  // NOLINT+  for (int i = 0; i < 2; i++) {+    if (!(STRLEN(pack_entry) + STRLEN(start_pat[i]) + 1 < MAXPATHL)) {",- nit: this negative logic (used in 3 places) could be more readable if the `!(... < ...)` is switched to `... >= ...`- is it worth adding a 1-line comment explaining the intention? e.g. `// Do not expand very long paths` ?    - should we log such cases instead of silently skipping?,X
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/15842,720691555,2021-10-02T15:19:10Z,src/nvim/strings.c,"@@ -832,15 +840,22 @@ int vim_vsnprintf_typval(       // parse flags       while (true) {         switch (*p) {-          case '0': zero_padding = 1; p++; continue;-          case '-': justify_left = 1; p++; continue;-                    // if both '0' and '-' flags appear, '0' should be ignored-          case '+': force_sign = 1; space_for_positive = 0; p++; continue;-          case ' ': force_sign = 1; p++; continue;-                    // if both ' ' and '+' flags appear, ' ' should be ignored-          case '#': alternate_form = 1; p++; continue;-          case '\'': p++; continue;-          default: break;+        case '0':+          zero_padding = 1; p++; continue;+        case '-':+          justify_left = 1; p++; continue;+        // if both '0' and '-' flags appear, '0' should be ignored+        case '+':+          force_sign = 1; space_for_positive = 0; p++; continue;+        case ' ':+          force_sign = 1; p++; continue;+        // if both ' ' and '+' flags appear, ' ' should be ignored+        case '#':+          alternate_form = 1; p++; continue;","Hmm, good question. I did a quick look and I don't think there's an option for that yet. I'll add it to my TODO list :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15826,720692354,2021-10-02T15:26:00Z,runtime/lua/vim/lsp/rpc.lua,"@@ -485,14 +457,15 @@ local function start(cmd, cmd_args, dispatchers, extra_spawn_params)    ---@private   local function handle_body(body)-    local decoded, err = json_decode(body)-    if not decoded then-      -- on_error(client_errors.INVALID_SERVER_JSON, err)+    local ok, decoded = pcall(vim.json.decode, body)+    if not ok then+      on_error(client_errors.INVALID_SERVER_JSON, decoded)",For reference: this was commented-out in f75be5e9d510d5369c572cf98e78d9480df3b0bb #12655 accidentally.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15817,720699368,2021-10-02T16:30:21Z,CONTRIBUTING.md,"@@ -220,10 +220,12 @@ You can lint a single file (but this will _not_ exclude legacy errors): - Style rules are (mostly) defined by `src/uncrustify.cfg` which tries to match   the [style-guide]. To use the Nvim `gq` command with `uncrustify`:   ```-  if !empty(findfile('src/.uncrustify', ';'))-    setlocal formatprg=uncrustify\ -q\ -c\ src/uncrustify.cfg\ --replace\ --no-backup+  if !empty(findfile('src/uncrustify.cfg', ';'))+    setlocal formatprg=uncrustify\ -q\ -l\ C\ -c\ src/uncrustify.cfg\ --no-backup   endif   ```+  The required version of `uncrustify` is specified in `uncrustify.cfg`.+",this extra blank line causes github (at least) to spread all of the list items out when rendering. Do not add random blank lines,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15871,720699602,2021-10-02T16:32:47Z,src/nvim/eval/funcs.c,"@@ -4514,8 +4516,8 @@ static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)    bool n = false;   const char *const name = tv_get_string(&argvars[0]);-  for (size_t i = 0; i < ARRAY_SIZE(has_list); i++) {-    if (STRICMP(name, has_list[i]) == 0) {+  for (size_t i = 0; i < ARRAY_SIZE(kHasList); i++) {","Unless I hear other core contributors in favor of this, I do not think all of these endless name changes are worth the entropy. If we change names they should be semantic improvements, usually.Closing any PRs with these changes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15795,720701747,2021-10-02T16:50:28Z,src/nvim/api/ui.c,"@@ -631,7 +631,7 @@ static void remote_ui_raw_line(UI *ui, Integer grid, Integer row, Integer startc       remote_ui_highlight_set(ui, (int)clearattr);       // legacy eol_clear was only ever used with cleared attributes       // so be on the safe side-      if (clearattr == 0 && clearcol == Columns) {+      if (clearattr == 0 && clearcol == g_columns) {","We only use all caps for macros. Constants are ""k"" prefixed. Those rules apply regardless of scope.Globals are something else. `g_` tells me something is clearly a global. Less important with advanced tooling these days, but I think there's always a benefit to having unambiguous lexical signals that don't depend on tools.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/15871,720706189,2021-10-02T17:30:41Z,src/nvim/eval/funcs.c,"@@ -4514,8 +4516,8 @@ static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)    bool n = false;   const char *const name = tv_get_string(&argvars[0]);-  for (size_t i = 0; i < ARRAY_SIZE(has_list); i++) {-    if (STRICMP(name, has_list[i]) == 0) {+  for (size_t i = 0; i < ARRAY_SIZE(kHasList); i++) {","> I don't understand the name changes either. What does the `k` mean exactly?> > I do think that some of the other changes in this PR are valuable though, namely wrapping macro function arguments in parens.I didn't come up with any of the rules btw: https://neovim.io/doc/user/dev_style.html#dev-style> Yes. But these PRs should not include name changes, I've mentioned this in previous PRs...I must've missed your comment regarding the name changes, maybe it was in the other PR which I've been working on in parallel. Sorry about that.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,720821184,2021-10-03T12:27:42Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,233 @@+local M = {}+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+	local rtn = {}+	rawset(table, key, rtn)+	return rtn+  end})+local last_tick = {}+local active_requests = {}++---@private+local function modifiers_from_number(x, modifiers_table)+  ---@private+  local function get_bit(n, k)+    --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+    if _G.bit then+      return _G.bit.band(_G.bit.rshift(n, k), 1)+    else+      return (n / math.pow(2, k)) % 2+    end+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  namespace = ""LspNamespace"",+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}++---@private+local function make_cache(base_map)+  return setmetatable({}, { __index = function(outer_table, ft)+    local rtn = setmetatable({}, { __index = function(inner_table, key)+      local hl = base_map[key]+      if hl then+	local prefixed+	if type(hl) == ""table"" then+	  prefixed = {}+	  for k, v in pairs(hl) do+	    local prefixed_v = ft..v+	    vim.cmd(""highlight default link "" .. prefixed_v .. "" "" .. v)+	    prefixed[k] = prefixed_v+	  end+	else+	  prefixed = ft..hl+	  vim.cmd(""highlight default link "" .. prefixed .. "" "" .. hl)+	end+	rawset(inner_table, key, prefixed)+	return prefixed+      end+      return hl+    end})+    rawset(outer_table, ft, rtn)+    return rtn+  end})+end++local token_cache = make_cache(M.token_map)+local modifiers_cache = make_cache(M.modifiers_map)++---@private+local function highlight(buf, token, hl)+  vim.highlight.range(buf, ns, hl, {token.line, token.start_char}, {token.line, token.start_char + token.length})+end++---@private+local function highlight_token(buf, token, ft_token_cache, ft_modifiers_cache)+  local hl = ft_token_cache[token.type]+  if hl then+    highlight(buf, token, hl)+  end+  for _, m in pairs(token.modifiers) do+    hl = ft_modifiers_cache[m]+    -- modifiers can have a per-type mapping+    -- e.g. readonly = { variable = ""ReadOnlyVariable"" }","After using this for while, I wanted to map a combination of TokenType and TokenModifier.I have to implementation of that, in the first I would just look up modifiers for type.modifier and then for modifier only```luarequire'vim.lsp.semantic_tokens'.token_map['variable.readonly'] = 'LspReadOnly'require'vim.lsp.semantic_tokens'.token_map['variable.globalScope'] = 'LspGlobalScope'```in the second (latest commit of this PR), you can choose whether you have a direct mapping `readonly = ""LspReadOnly""` or whether you want to set a per-type table. This is more efficient since there are only additional look-ups for modifiers that use this feature.```luarequire'vim.lsp.semantic_tokens'.modifiers_map['readonly'] = { variable = 'LspVariableReadOnly' }require'vim.lsp.semantic_tokens'.modifiers_map['globalScope'] = { variable = 'LspGlobalScope' }```In whatever way, this is implemented internally, users should access more advanced mapping via nice API functions once it's settled what should be possible. So implementation can be changed easily if needed.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15277,720971997,2021-10-04T00:35:39Z,test/functional/lua/uri_spec.lua,"@@ -158,6 +158,18 @@ describe('URI methods', function()    end) +  describe('uri from bufnr', function()+    it('Windows paths should not be treated as uris', function()+      local file = 'C:\foo\bar.txt'+      local uri = 'file:/C:/foo/bar.txt'+        local test_case = string.format([[+          local file = '%s'+          return vim.uri_from_bufnr(vim.fn.bufadd(file))+        ]], file)+        eq(uri, exec_lua(test_case))+    end)+  end)","pending_win32 is only for skipping non-Windows tests. In this case, just guard it with condition that checks `helpers.iswin()` ",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15907,721961029,2021-10-05T07:26:42Z,runtime/lua/vim/lsp/util.lua,"@@ -1784,7 +1784,7 @@ local function make_position_param()   if not line then     return { line = 0; character = 0; }   end-  col = str_utfindex(line, col)+  _, col = str_utfindex(line, col)","this is the correct default, but ideally this should use the configured position encoding by the client (which will be plain ol' bytes for clangd), which is gonna need a parameter to this function.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/15911,722202028,2021-10-05T12:44:22Z,runtime/doc/autocmd.txt,"@@ -1232,6 +1232,13 @@ Example: > This prevents having the autocommands defined twice (e.g., after sourcing the vimrc file again). +						*FileExplorer*","`:aug` lists `FileExplorer`, so I assume so?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/15911,722204795,2021-10-05T12:47:29Z,runtime/doc/autocmd.txt,"@@ -1232,6 +1232,13 @@ Example: > This prevents having the autocommands defined twice (e.g., after sourcing the vimrc file again). +						*FileExplorer*",Probably `netrw` defining it; not sure it has any special behaviour in Nvim though.E.g: Vim has https://github.com/vim/vim/blob/7f2dd1e90c1d4a30c791fae20014594641769a1e/src/ex_cmds.c#L2547 and https://github.com/vim/vim/blob/08d7b1c82866a61b61a55e55b6c190dba04e54ea/src/ex_docmd.c#L6523 but I don't see anything in Nvim like this ���� I believe it was probably removed with the GUI-specific stuff?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15592,722854995,2021-10-06T03:20:30Z,test/functional/options/num_options_spec.lua,"@@ -36,6 +37,14 @@ describe(':setlocal', function()     feed_command('setlocal imsearch=1')     eq(-1, meths.get_option('imsearch'))   end)++  it('returns an error if local option does not exist #15587', function()+    feed_command('setglobal undolevels=1000')+    feed_command('setlocal undolevels<')+    eq(""Failed to get value for option 'undolevels'"",","`vim.opt` and `vim.o` check if a local option value is set by checking if `nvim_buf_get_option` returns an error:https://github.com/neovim/neovim/blob/acd5e831b6294e54b12c09983bee3da89c0f183a/runtime/lua/vim/_meta.lua#L200-L206If we change `nvim_buf_get_option` to just return the local value even if unset (which is consistent with `:setlocal`) then there's no reliable way to check if the local value was set or not. For most options we can just check if the local value is an empty string, but there are exceptions (such as 'undolevels'). We could just hardcode in that exception I guess.```lualocal local_value = a.nvim_buf_get_option(0, k)local was_set = local_value ~= """"if k == ""undolevels"" then  was_set = local_value ~= -123456endif```But this doesn't feel right. Maybe we could add another field to the return value of `nvim_get_option_info` that indicates whether or not a global-local option has a local value (there is already `was_set` but that doesn't differentiate between global/local).If we make `nvim_buf_get_option` return an error in all cases when the local value isn't set then `vim.opt` and `vim.o` will just work (albeit differently than `:set` and `:setlocal`). This is already what happens for string options, so we'd just be making the API more consistent.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/13854,723342351,2021-10-06T14:34:21Z,src/nvim/edit.c,"@@ -3791,7 +3984,7 @@ static bool ins_compl_prep(int c)       // but only do this, if the Popup is still visible       if (c == Ctrl_E) {         ins_compl_delete();-        if (compl_leader != NULL) {+        if (compl_leader != NULL && STRNCMP(compl_leader, """", 1) != 0) {",usual pattern in the codebase is to compare `compl_leader[0] == NUL`,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/15932,723386558,2021-10-06T15:17:49Z,src/nvim/api/buffer.c,"@@ -1571,45 +1573,42 @@ Integer nvim_buf_set_extmark(Buffer buffer, Integer ns_id, Integer line, Integer     return 0;   } -   uint64_t id = 0;   if (opts->id.type == kObjectTypeInteger && opts->id.data.integer > 0) {     id = (uint64_t)opts->id.data.integer;   } else if (HAS_KEY(opts->id)) {       api_set_error(err, kErrorTypeValidation, ""id is not a positive integer"");-      goto error;+      return 0;","Yes, but before line 1620, the call to `clear_virttext` should not be necessary. If we value clarity, it would be better to change `return 0;` to `goto error:`. If the cost of the function call is an issue, I think the `goto error;` in line 1615 should also be `return 0;`. I don't really have an opinion on this, so I'd like to hear @bfredl opinion.https://github.com/neovim/neovim/blob/74c73bf20502057f17c68375af569d5ae4e1a11f/src/nvim/api/buffer.c#L1612-L1620",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15788,723574509,2021-10-06T18:32:42Z,test/functional/api/vim_spec.lua,"@@ -487,6 +487,31 @@ describe('API', function()     end)   end) +  describe('nvim_set_current_dir', function()+    local start_dir++    before_each(function()+      clear()+      funcs.mkdir(""Xtestdir"")+      start_dir = funcs.getcwd()+    end)++    after_each(function()+      helpers.rmdir(""Xtestdir"")+    end)++    it('works', function()+      meths.set_current_dir(""Xtestdir"")+      eq(funcs.getcwd(), start_dir .. ""/Xtestdir"")",https://github.com/neovim/neovim/blob/e06936125a628d8a61069f5fbce68394292db4df/test/functional/helpers.lua#L788-L790,
36219739,chentoast,https://api.github.com/repos/neovim/neovim/pulls/13854,723792113,2021-10-07T01:55:26Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,85 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +///+/// Set matches and start insert completion: see |complete()|.","Having the opts dictionary allows for better extensibility without adding a bunch of new vimscript functions. In the future, I'd like to expose more of the completion list via this api function, so that plugins can add or remove matches (like 'complete_add', but for stuff besides 'completefunc') . In addition, having it be an api function is more ergonomic as plugins can just directly pass a lua function as 'filterfunc' instead of resorting to 'v:lua'.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15188,724616500,2021-10-08T00:16:38Z,src/nvim/testdir/test_window_cmd.vim,"@@ -924,4 +924,18 @@ func Test_window_resize()   %bwipe! endfunc +"" Test for errors with :wincmd+func Test_wincmd_errors()+  call assert_fails('wincmd g', 'E474:')+  call assert_fails('wincmd ab', 'E474:')+endfunc++"" Test for errors with :winpos+func Test_winpos_errors()+  if !has(""gui_running"") && !has('win32')+    call assert_fails('winpos', 'E188:')+  endif+  call assert_fails('winpos 10', 'E466:')+endfunc",Not needed. Just skip it via the `throw 'Skipped:` syntax: https://github.com/neovim/neovim/blob/a161559a006bcbc31a2eccbd96df3138e8bc3bc5/src/nvim/testdir/test_python3.vim#L178,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15960,725239615,2021-10-08T19:01:30Z,runtime/lua/vim/lsp/util.lua,"@@ -1593,6 +1593,38 @@ function M.get_lines(uri, rows)   return lines end +--- Return a function that converts LSP responses to list items and opens the list+---+--- The returned function has an optional {config} parameter that accepts a table+--- with the following keys:+---+---   loclist: (boolean) use the location list (default is to use the quickfix list)+---+---@param map_result function `((resp, bufnr) -> list)` to convert the response+---@param entity name of the resource used in a `not found` error message+function M.response_to_list(map_result, entity)","In vim.diagnostic we ended up favoring `qflist` over `list`. Even though it works for both qflist and loclist, the `list` alone was too generic. (Full method name being `toqflist`)",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/15959,725392227,2021-10-08T23:33:42Z,test/functional/plugin/lsp_spec.lua,"@@ -2262,9 +2262,9 @@ describe('LSP', function()             local bufnr = vim.api.nvim_get_current_buf()             lsp.buf_attach_client(bufnr, TEST_RPC_CLIENT_ID)             vim.lsp._stubs = {}-            vim.fn.input = function(prompt, text)-              vim.lsp._stubs.input_prompt = prompt-              vim.lsp._stubs.input_text = text+            vim.fn.input = function(opts, on_confirm)+              vim.lsp._stubs.input_prompt = opts.prompt+              vim.lsp._stubs.input_text = opts.default","Is `vim.fn.{func}` being overridable a documented behavior? The documentation of `vim.fn` says:```vim.fn.{func}({...})					*vim.fn*        Invokes |vim-function| or |user-function| {func} with arguments {...}.```if `vim.fn.{func}` is overridden, it no longer invokes the Vim function, which goes against the documentation.",
5160701,seblj,https://api.github.com/repos/neovim/neovim/pulls/15959,725473549,2021-10-09T11:09:33Z,test/functional/plugin/lsp_spec.lua,"@@ -2262,9 +2262,9 @@ describe('LSP', function()             local bufnr = vim.api.nvim_get_current_buf()             lsp.buf_attach_client(bufnr, TEST_RPC_CLIENT_ID)             vim.lsp._stubs = {}-            vim.fn.input = function(prompt, text)-              vim.lsp._stubs.input_prompt = prompt-              vim.lsp._stubs.input_text = text+            vim.fn.input = function(opts, on_confirm)+              vim.lsp._stubs.input_prompt = opts.prompt+              vim.lsp._stubs.input_text = opts.default","> Is the idea that on_confirm would potentially be asynchronous?No I don't think so. I used it in lsp rename, and I don't know how an async request for that would potentially be. I would maybe have the same concerns as there is for formatting asynchronous on save. What if the user manage to save before the response from renaming comes back? I am no expert here, so this is just my initial concern.> 1. What precedents did you draw from? How does your solution compare to them?So I based my solution to this on @mfussenegger and `vim.ui.select`. I think this fits with the style of `vim.ui.select` of being a wrapper around both ui-functions.> 2. Does your new API allow future expansion? How? Or why not?I don't really know what should be further expanded with `vim.ui.input`? To me, it looks like it supports everything `input` supports, while also being easily overridable. > 3. Is the new API similar to existing APIs? Do we need to deprecate the old ones?> 4. Did you cross-reference related concepts in your API docs?Not to my knowledge. It is more of a wrapper around `input()`, but with the expansion on taking a callback. I also searched the API docs and couldn't find anything similar. > so `vim.fn.input` can _already_ be overridden.> > Then what is the point of `vim.ui.input` ?So the point of `vim.ui.input` is that it's not possible to override input to create a popup and return the input from the user from that popup (at least I don't know how this would work, so I could maybe be wrong). So therefore, `vim.ui.input` takes a callback which can be called when the user has confirmed the input in the popup.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15260,725482668,2021-10-09T12:38:18Z,.gitignore,"@@ -6,6 +6,9 @@ compile_commands.json /.vs/ /.vscode/ /.idea/+/.vim/+.exrc+.nvimrc","this is a personal thing, the core project doesn't need  this in its gitignore. None of these patterns are recommended.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/15260,725487903,2021-10-09T13:28:31Z,runtime/lua/vim/treesitter.lua,"@@ -27,6 +28,22 @@ setmetatable(M, {    end  }) +--- Configure treesitter options globally or for a specific lang.+---+---@param options table Configuration table with the following keys:+---       - query_file_ignore_patterns: if query file path matches one of the",~Would we still allow string patterns? Or are full paths preferable?~~(asking because `query_file_exclude` might seem like they expect full paths. ���� )~How do you feel about `query_file_ignore` (that kinda sounds like `.gitignore` and similar ignore files)?,
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/15959,725499244,2021-10-09T15:13:14Z,runtime/lua/vim/ui.lua,"@@ -32,5 +32,34 @@ function M.select(items, opts, on_choice)   end end +--- Prompts the user for input+---+---@param opts table Additional options. See |input()|+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Input: `.+---     - default (string|nil)+---               Default reply to the input+---     - completion (string|nil)+---               Specifies type of completion supported+---               for input. Supported types are the same+---               that can be supplied to a user-defined+---               command using the ""-complete="" argument.+---               See |:command-completion|+---     - highlight (function)+---               Function that will be used for highlighting+---               user inputs.+---@param on_confirm function ((input) -> ())+---               Called once the user enters the input.+---               `input` is what the user typed.+function M.input(opts, on_confirm)","Will there be a way of doing something as input value changes? e.g. highlight some text on a buffer as input value changes, or filter a list based on the input value as it changes and display it.",
8050659,MunifTanjim,https://api.github.com/repos/neovim/neovim/pulls/15959,725502751,2021-10-09T15:44:30Z,runtime/lua/vim/ui.lua,"@@ -32,5 +32,34 @@ function M.select(items, opts, on_choice)   end end +--- Prompts the user for input+---+---@param opts table Additional options. See |input()|+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Input: `.+---     - default (string|nil)+---               Default reply to the input+---     - completion (string|nil)+---               Specifies type of completion supported+---               for input. Supported types are the same+---               that can be supplied to a user-defined+---               command using the ""-complete="" argument.+---               See |:command-completion|+---     - highlight (function)+---               Function that will be used for highlighting+---               user inputs.+---@param on_confirm function ((input) -> ())+---               Called once the user enters the input.+---               `input` is what the user typed.+function M.input(opts, on_confirm)",">  this is not possible with vim.fn.inputI know. But since the idea of `vim.ui.*` is that others can override these for fancier implementation, is `input(opts, on_confirm)` the best signature? If somebody wants to implement `on_change` they'll either have to put `on_change` inside `opts` or add another parameter after `on_confirm`.Did you think about keeping `on_confirm` inside `opts`?Also, a minor nit-pick - if you decide to put `on_confirm` inside `opts`, I think `on_submit` would be a better name.",
629908,hrsh7th,https://api.github.com/repos/neovim/neovim/pulls/15953,725574025,2021-10-10T04:18:52Z,runtime/lua/vim/lsp/util.lua,"@@ -322,18 +321,17 @@ function M.apply_text_edits(text_edits, bufnr)     local row_count = (e.end_row - e.start_row) + 1     if e.end_row < cursor.row then       cursor.row = cursor.row + (#e.text - row_count)-      is_cursor_fixed = true-    elseif e.end_row == cursor.row and e.end_col <= cursor.col then-      cursor.row = cursor.row + (#e.text - row_count)-      cursor.col = #e.text[#e.text] + (cursor.col - e.end_col)+    elseif e.end_row == cursor.row then+      cursor.row = e.start_row+      if e.end_col <= cursor.col then+        cursor.col = #e.text[#e.text] + (cursor.col - e.end_col)+      end       if #e.text == 1 then         cursor.col = cursor.col + e.start_col       end-      is_cursor_fixed = true     end-  end -  if is_cursor_fixed then+    -- Moving cursor position after every text edit so that final placement is accurate     vim.api.nvim_win_set_cursor(0, {       cursor.row + 1,       math.min(cursor.col, #(vim.api.nvim_buf_get_lines(bufnr, cursor.row, cursor.row + 1, false)[1] or ''))",Sorry. It's my bad.I think this line fixes the `cursor.col` to the valid column.Could you provide the TextEdit and buffer content that causes this error?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15979,726131827,2021-10-11T13:44:08Z,src/nvim/tui/tui.c,"@@ -308,6 +311,8 @@ static void terminfo_start(UI *ui)   // Enable bracketed paste   unibi_out_ext(ui, data->unibi_ext.enable_bracketed_paste); +  // Let highlight know the new color info+  init_highlight(true, true);","reverse looks bad in many cases. My suggestion is ""white"" for bg=dark, ""black"" for bg=light. Don't want to spend time debating this.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16003,727664230,2021-10-13T03:09:08Z,cmake/RunTests.cmake,"@@ -10,6 +10,7 @@ set(ENV{VIMRUNTIME} ${WORKING_DIR}/runtime) set(ENV{NVIM_RPLUGIN_MANIFEST} ${BUILD_DIR}/Xtest_rplugin_manifest) set(ENV{XDG_CONFIG_HOME} ${BUILD_DIR}/Xtest_xdg/config) set(ENV{XDG_DATA_HOME} ${BUILD_DIR}/Xtest_xdg/share)+unset(ENV{XDG_DATA_DIRS})",Had a long discussion about this in https://github.com/neovim/neovim/pull/15621 cc @Jun-T,
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/15996,728035602,2021-10-13T12:59:44Z,src/nvim/api/vim.c,"@@ -919,6 +919,115 @@ Object nvim_get_option(String name, Error *err)   return get_option_from(NULL, SREQ_GLOBAL, name, err); } +/// Gets the value of an option. The behavior of this function matches that of+/// |:set|: the local value of an option is returned if it exists; otherwise,+/// the global value is returned. Local values always correspond to the current+/// buffer or window. To get a buffer-local or window-local option for a+/// specific buffer or window, use |nvim_buf_get_option()| or+/// |nvim_win_get_option()|.+///+/// @param name      Option name+/// @param opts      Optional parameters+///                  - scope: One of 'global' or 'local'. Analagous to+///                  |:setglobal| and |:setlocal|, respectively.+/// @param[out] err  Error details, if any+/// @return          Option value+Object nvim_get_option_value(String name, Dict(option) *opts, Error *err)","perhaps we should call it `nvim_get_scoped_option`? I don't have any strong preferences.(btw, TY for doing the larger fix for this. This will be very nice)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15996,729174914,2021-10-14T16:58:30Z,src/nvim/api/vim.c,"@@ -919,6 +919,115 @@ Object nvim_get_option(String name, Error *err)   return get_option_from(NULL, SREQ_GLOBAL, name, err); } +/// Gets the value of an option. The behavior of this function matches that of+/// |:set|: the local value of an option is returned if it exists; otherwise,+/// the global value is returned. Local values always correspond to the current+/// buffer or window. To get a buffer-local or window-local option for a+/// specific buffer or window, use |nvim_buf_get_option()| or+/// |nvim_win_get_option()|.+///+/// @param name      Option name+/// @param opts      Optional parameters+///                  - scope: One of 'global' or 'local'. Analagous to+///                  |:setglobal| and |:setlocal|, respectively.+/// @param[out] err  Error details, if any+/// @return          Option value+Object nvim_get_option_value(String name, Dict(option) *opts, Error *err)",I'd say `nvim_get_option_value` because we want it to be fully generic (which can be done incrementally as long as there is a `opts` dict) it is not just about local/global scope.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16020,729233295,2021-10-14T18:20:23Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,163 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox+///           - fillchar: character to fill blank spaces in the statusline+///           - eval_highlights: whether to return the highlight information+/// @param[out] err Error details, if any+/// @return Dictionary containing statusline information, with these keys:+///       - str: Characters that will be displayed on the statusline+///       - width: Display width of the statusline+///       - highlights (optional): Array containing highlight information of+///                                the statusline. Each element of the array+///                                is a Dictionary containing the highlight+///                                information of a section, with these+///                                keys:+///           - start: byte index of first character that uses the highlight+///           - hl: Dictionary that contains cterm and gui highlight values+///                 accessible through the ""cterm"" and ""gui"" keys, respectively+Dictionary nvim_eval_statusline_str(String str, Dictionary opts, Error *err)+  FUNC_API_SINCE(8) FUNC_API_FAST+{+  Dictionary result = ARRAY_DICT_INIT;++  Window window = 0;+  Boolean use_tabline = false;+  Boolean use_sandbox = false;+  Boolean eval_highlights = false;+  char_u fillchar = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(k.data, ""winid"")) {+      if (v.type != kObjectTypeInteger) {+        api_set_error(err, kErrorTypeValidation, ""winid must be an integer"");+        return result;+      }",Don't use string comparison to find keys. Add a new keyset to `src/nvim/api/keysets.lua` and use `Dict({keyset}) opts` as the function parameter. Then you can just use `opts->winid`. There are examples of this in this file.,
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/16020,729244056,2021-10-14T18:37:14Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,163 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox+///           - fillchar: character to fill blank spaces in the statusline+///           - eval_highlights: whether to return the highlight information+/// @param[out] err Error details, if any+/// @return Dictionary containing statusline information, with these keys:+///       - str: Characters that will be displayed on the statusline+///       - width: Display width of the statusline+///       - highlights (optional): Array containing highlight information of+///                                the statusline. Each element of the array+///                                is a Dictionary containing the highlight+///                                information of a section, with these+///                                keys:+///           - start: byte index of first character that uses the highlight+///           - hl: Dictionary that contains cterm and gui highlight values+///                 accessible through the ""cterm"" and ""gui"" keys, respectively+Dictionary nvim_eval_statusline_str(String str, Dictionary opts, Error *err)+  FUNC_API_SINCE(8) FUNC_API_FAST+{+  Dictionary result = ARRAY_DICT_INIT;++  Window window = 0;+  Boolean use_tabline = false;+  Boolean use_sandbox = false;+  Boolean eval_highlights = false;+  char_u fillchar = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(k.data, ""winid"")) {+      if (v.type != kObjectTypeInteger) {+        api_set_error(err, kErrorTypeValidation, ""winid must be an integer"");+        return result;+      }++      window = (Window)v.data.integer;+    } else if (strequal(k.data, ""use_tabline"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""use_tabline must be a boolean value"");+        return result;+      }++      use_tabline = v.data.boolean;+    } else if (strequal(k.data, ""use_sandbox"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""use_sandbox must be a boolean value"");+        return result;+      }++      use_sandbox = v.data.boolean;+    } else if (strequal(k.data, ""fillchar"")) {+      if (v.type != kObjectTypeString || v.data.string.size > 1) {+        api_set_error(err, kErrorTypeValidation, ""fillchar must be an ASCII character"");+        return result;+      }++      fillchar = (char_u)v.data.string.data[0];+    } else if (strequal(k.data, ""eval_highlights"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""eval_highlights must be a boolean value"");+        return result;+      }++      eval_highlights = v.data.boolean;+    }+  }++  stl_hlrec_t *hltab;+  stl_hlrec_t **hltab_ptr;++  if (!eval_highlights) {",I can see a ternary statement here. Though change isn't necessary```chltab_ptr = eval_highlights ? &hltab : NULL;```I actually don't remember if neovim's style guide considered ternaries bad or not ����,
29580810,famiu,https://api.github.com/repos/neovim/neovim/pulls/16020,729286351,2021-10-14T19:40:19Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,163 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox+///           - fillchar: character to fill blank spaces in the statusline+///           - eval_highlights: whether to return the highlight information+/// @param[out] err Error details, if any+/// @return Dictionary containing statusline information, with these keys:+///       - str: Characters that will be displayed on the statusline+///       - width: Display width of the statusline+///       - highlights (optional): Array containing highlight information of+///                                the statusline. Each element of the array+///                                is a Dictionary containing the highlight+///                                information of a section, with these+///                                keys:+///           - start: byte index of first character that uses the highlight+///           - hl: Dictionary that contains cterm and gui highlight values+///                 accessible through the ""cterm"" and ""gui"" keys, respectively+Dictionary nvim_eval_statusline_str(String str, Dictionary opts, Error *err)+  FUNC_API_SINCE(8) FUNC_API_FAST+{+  Dictionary result = ARRAY_DICT_INIT;++  Window window = 0;+  Boolean use_tabline = false;+  Boolean use_sandbox = false;+  Boolean eval_highlights = false;+  char_u fillchar = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(k.data, ""winid"")) {+      if (v.type != kObjectTypeInteger) {+        api_set_error(err, kErrorTypeValidation, ""winid must be an integer"");+        return result;+      }++      window = (Window)v.data.integer;+    } else if (strequal(k.data, ""use_tabline"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""use_tabline must be a boolean value"");+        return result;+      }++      use_tabline = v.data.boolean;+    } else if (strequal(k.data, ""use_sandbox"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""use_sandbox must be a boolean value"");+        return result;+      }++      use_sandbox = v.data.boolean;+    } else if (strequal(k.data, ""fillchar"")) {+      if (v.type != kObjectTypeString || v.data.string.size > 1) {+        api_set_error(err, kErrorTypeValidation, ""fillchar must be an ASCII character"");+        return result;+      }++      fillchar = (char_u)v.data.string.data[0];+    } else if (strequal(k.data, ""eval_highlights"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""eval_highlights must be a boolean value"");+        return result;+      }++      eval_highlights = v.data.boolean;+    }+  }++  stl_hlrec_t *hltab;+  stl_hlrec_t **hltab_ptr;++  if (!eval_highlights) {+    hltab_ptr = NULL;+  } else {+    hltab_ptr = &hltab;+  }++  int attr;+  int maxwidth;+  win_T *wp, *ewp;++  if (use_tabline) {+    wp = NULL;+    ewp = curwin;+    maxwidth = Columns;+    fillchar = ' ';",`fillchar` for statusline is already exposed. fillchar of tabline is always `' '` so it doesn't need to be configurable. And personally I don't see any reason to configure maxwidth since it's the window width for the provided window for statusline and the amount of columns for the tabline. Length of buf seems too much of a technical detail to expose imo.,
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/16020,729295558,2021-10-14T19:54:25Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,163 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox+///           - fillchar: character to fill blank spaces in the statusline+///           - eval_highlights: whether to return the highlight information+/// @param[out] err Error details, if any+/// @return Dictionary containing statusline information, with these keys:+///       - str: Characters that will be displayed on the statusline+///       - width: Display width of the statusline+///       - highlights (optional): Array containing highlight information of+///                                the statusline. Each element of the array+///                                is a Dictionary containing the highlight+///                                information of a section, with these+///                                keys:+///           - start: byte index of first character that uses the highlight+///           - hl: Dictionary that contains cterm and gui highlight values+///                 accessible through the ""cterm"" and ""gui"" keys, respectively+Dictionary nvim_eval_statusline_str(String str, Dictionary opts, Error *err)+  FUNC_API_SINCE(8) FUNC_API_FAST+{+  Dictionary result = ARRAY_DICT_INIT;++  Window window = 0;+  Boolean use_tabline = false;+  Boolean use_sandbox = false;+  Boolean eval_highlights = false;+  char_u fillchar = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(k.data, ""winid"")) {+      if (v.type != kObjectTypeInteger) {+        api_set_error(err, kErrorTypeValidation, ""winid must be an integer"");+        return result;+      }++      window = (Window)v.data.integer;+    } else if (strequal(k.data, ""use_tabline"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""use_tabline must be a boolean value"");+        return result;+      }++      use_tabline = v.data.boolean;+    } else if (strequal(k.data, ""use_sandbox"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""use_sandbox must be a boolean value"");+        return result;+      }++      use_sandbox = v.data.boolean;+    } else if (strequal(k.data, ""fillchar"")) {+      if (v.type != kObjectTypeString || v.data.string.size > 1) {+        api_set_error(err, kErrorTypeValidation, ""fillchar must be an ASCII character"");+        return result;+      }++      fillchar = (char_u)v.data.string.data[0];+    } else if (strequal(k.data, ""eval_highlights"")) {+      if (v.type != kObjectTypeBoolean) {+        api_set_error(err, kErrorTypeValidation, ""eval_highlights must be a boolean value"");+        return result;+      }++      eval_highlights = v.data.boolean;+    }+  }++  stl_hlrec_t *hltab;+  stl_hlrec_t **hltab_ptr;++  if (!eval_highlights) {+    hltab_ptr = NULL;+  } else {+    hltab_ptr = &hltab;+  }++  int attr;+  int maxwidth;+  win_T *wp, *ewp;++  if (use_tabline) {+    wp = NULL;+    ewp = curwin;+    maxwidth = Columns;+    fillchar = ' ';",Sorry missed the fill char part .Float window or external ui can display the statusline in different place then in bottom of that window. In those cases having control over maxwidth & buf len will be useful. Current behavior will be a good default when they aren't provided in opts.For example in floatlines case maxwidth & buf len needs to correspond to screen width not win width while the stl expression getting evaluated on active wimdows context.> Length of buf seems too much of a technical detail to expose imo.In that case expose maxwidth whe maxwidth is given use 2|3 * maxwidth as buflen.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16020,729311732,2021-10-14T20:19:25Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,155 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox","I forgot that `'exrc'` is permanently disabled in Nvim, so hardcoding to false should be fine.Nvm, it's not permanently disabled, just deprecated. So I don't think we can hardcode false, because someone could have `'exrc'` and `'secure'` set and```vimcall nvim_eval_statusline(...)```in a `.nvimrc` file, which should enable sandboxing.Maybe we just need a variant of `check_secure()`:```cif (secure || sandbox) {    api_set_error(...);    return result;}```",X
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/16020,729316539,2021-10-14T20:27:09Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,155 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox","> Nvm, it's not permanently disabled, just deprecated. So I don't think we can hardcode false, because someone could have 'exrc' and 'secure' set andI'm not sure if we care about supporting a deprecated feature . I wonder if stuff like `nvim_exec` / `luaeval` take exrc secure into account.",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/16030,729902196,2021-10-15T15:03:59Z,src/nvim/tui/tui.c,"@@ -489,6 +491,7 @@ static void sigwinch_cb(SignalWatcher *watcher, int signum, void *data)   }    tui_guess_size(ui);+  apply_autocmds(EVENT_SIGNAL, (char_u *)""SIGWINCH"" , NULL, false, curbuf);",Do not call `apply_autocmds` in a TUI thread. Please create an event to the main thread by referring to the following  and others.https://github.com/neovim/neovim/blob/5fd4557573c73a6b41b702b1ee39151b5bd7e5fd/src/nvim/tui/tui.c#L253-L254,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16020,729927676,2021-10-15T15:37:28Z,src/nvim/api/vim.c,"@@ -2882,3 +2883,155 @@ Array nvim_get_mark(String name, Error *err)   return rv; } +/// Evaluates statusline string.+///+/// @param str Statusline string+/// @param opts Optional parameters.+///           - winid: id of the window to use as context for statusline+///           - use_tabline: evaluate tabline instead of statusline+///                          makes winid have no effect+///           - use_sandbox: whether the string should be evaluated in a sandbox+///           - fillchar: character to fill blank spaces in the statusline+///           - eval_highlights: whether to return the highlight information+/// @param[out] err Error details, if any+/// @return Dictionary containing statusline information, with these keys:+///       - str: Characters that will be displayed on the statusline+///       - width: Display width of the statusline+///       - highlights (optional): Array containing highlight information of+///                                the statusline. Each element of the array+///                                is a Dictionary containing the highlight+///                                information of a section, with these+///                                keys:+///           - start: byte index of first character that uses the highlight+///           - hl: Dictionary that contains cterm and gui highlight values+///                 accessible through the ""cterm"" and ""gui"" keys, respectively+Dictionary nvim_eval_statusline(String str, Dict(statusline_config) *opts, Error *err)+  FUNC_API_SINCE(8) FUNC_API_FAST+{+  Dictionary result = ARRAY_DICT_INIT;++  Window window = 0;+  Boolean use_tabline = false;+  Boolean use_sandbox = false;+  Boolean eval_highlights = false;+  char_u fillchar = 0;++  if (opts) {+    if (HAS_KEY(opts->winid)) {+      if (opts->winid.type != kObjectTypeInteger) {+        api_set_error(err, kErrorTypeValidation, ""winid must be an integer"");+        return result;+      }++      window = (Window)opts->winid.data.integer;+    }++    if (HAS_KEY(opts->fillchar)) {+      if (opts->fillchar.type != kObjectTypeString || opts->fillchar.data.string.size > 1) {+        api_set_error(err, kErrorTypeValidation, ""fillchar must be an ASCII character"");+        return result;+      }++      fillchar = (char_u)opts->fillchar.data.string.data[0];+    }++#define KEY_TO_BOOL(option) \","Hm, yea you're right.Since we got rid of `use_sandbox` there are only two boolean options now so IMO the cost of introducing a temporary macro isn't worth it. So let's just use```c  if (HAS_KEY(opts->highlights)) {    highlights = api_object_to_bool(opts->highlights, ""highlights"", false, err);    if (ERROR_SET(err)) {      return result;    }  }```",
894255,donbex,https://api.github.com/repos/neovim/neovim/pulls/15277,730145410,2021-10-15T21:58:40Z,runtime/lua/vim/uri.lua,"@@ -82,7 +82,8 @@ local URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9+-.]*):.*' local function uri_from_bufnr(bufnr)   local fname = vim.api.nvim_buf_get_name(bufnr)   local scheme = fname:match(URI_SCHEME_PATTERN)-  if scheme then+  -- Windows paths should not be considered URIs+  if scheme and scheme:len() > 1 then","I find this a bit cleane than the solution from #16027, in that it only performs one pattern matching. I doubt there's going to be any noticeable performance impact, though.",
20077627,teddylear,https://api.github.com/repos/neovim/neovim/pulls/15953,730208300,2021-10-16T04:21:03Z,runtime/lua/vim/lsp/util.lua,"@@ -322,18 +321,17 @@ function M.apply_text_edits(text_edits, bufnr)     local row_count = (e.end_row - e.start_row) + 1     if e.end_row < cursor.row then       cursor.row = cursor.row + (#e.text - row_count)-      is_cursor_fixed = true-    elseif e.end_row == cursor.row and e.end_col <= cursor.col then-      cursor.row = cursor.row + (#e.text - row_count)-      cursor.col = #e.text[#e.text] + (cursor.col - e.end_col)+    elseif e.end_row == cursor.row then+      cursor.row = e.start_row+      if e.end_col <= cursor.col then+        cursor.col = #e.text[#e.text] + (cursor.col - e.end_col)+      end       if #e.text == 1 then         cursor.col = cursor.col + e.start_col       end-      is_cursor_fixed = true     end-  end -  if is_cursor_fixed then+    -- Moving cursor position after every text edit so that final placement is accurate     vim.api.nvim_win_set_cursor(0, {       cursor.row + 1,       math.min(cursor.col, #(vim.api.nvim_buf_get_lines(bufnr, cursor.row, cursor.row + 1, false)[1] or ''))","Hey! Here is some more debug information is the starting cursor is: { 21, 0 } and the final cursor being output is {39, 0} (which the buffer row size is 26, so it's going over the max). Commands running the refactor are [here](https://github.com/ThePrimeagen/refactoring.nvim/blob/master/lua/refactoring/tests/refactor/106/ts/switch-statement/extract.commands) with the [minimal.vim here](https://github.com/ThePrimeagen/refactoring.nvim/blob/master/lua/refactoring/tests/minimal.vim). The main plugin I'm running this from is [here](https://github.com/ThePrimeagen/refactoring.nvim). Please let me know if you need more debug information. I'm gonna try this weekend to create a failing test case in lsp_spec to repo issue. ",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16049,730424796,2021-10-17T14:30:43Z,src/nvim/testdir/test_listchars.vim,"@@ -286,6 +286,10 @@ func Test_listchars_unicode()   call cursor(1, 1)   call assert_equal(expected, ScreenLines(1, virtcol('$'))) +  set listchars=eol:\\u21d4,space:\\u2423,multispace:���\\u2262\\U00002263,nbsp:\\U00002260,tab:������\\u2192+  redraw!+  call assert_equal(expected, ScreenLines(1, virtcol('$')))","Yes. Without the patch:```From test_listchars.vim:Executed Test_listchars()                          in   0.004763 secondsExecuted Test_listchars_composing()                in   0.000481 secondsExecuted Test_listchars_invalid()                  in   0.000366 secondsExecuted Test_listchars_unicode()                  in   0.000448 secondsExecuted 4 tests                         in   0.007646 seconds1 FAILED:Found errors in Test_listchars_unicode():Caught exception in Test_listchars_unicode(): Vim(set):E474: Invalid argument: listchars=eol:\\u21d4,space:\\u2423,multispace:���\\u2262\\U00002263,nbsp:\\U00002260,tab:������\\u2192 @ function RunTheTest[37]..Test_listchars_unicode, line 16```",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16027,730435330,2021-10-17T15:43:40Z,runtime/lua/vim/uri.lua,"@@ -75,13 +75,22 @@ local function uri_from_fname(path) end  local URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9+-.]*):.*'+local WINDOWS_URI_SCHEME_PATTERN = '^([a-zA-Z]+[a-zA-Z0-9+-.]*):[a-zA-Z]:.*'  --- Get a URI from a bufnr ---@param bufnr (number): Buffer number ---@return URI local function uri_from_bufnr(bufnr)   local fname = vim.api.nvim_buf_get_name(bufnr)",Do you just mean folding the scheme matching into https://github.com/mjlbach/neovim/blob/baf5fb085fee3d9812ca80e16d4f8d178d2447de/runtime/lua/vim/uri.lua#L61? We already have `uri_from_fname`,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16047,730456531,2021-10-17T18:28:22Z,src/nvim/options.lua,"@@ -2535,6 +2535,16 @@ return {       varname='p_tsr',       defaults={if_true=""""}     },+    {+      full_name='thesaurusfunc', abbreviation='tsrfu',+      short_desc=N_(""function for filetype-specific thesaurus""),+      type='string', scope={'global', 'buffer'},+      deny_duplicates=true,+      normal_dname_chars=true,+      expand=true,+      varname='p_tsrfu',+      defaults={if_true=""""}+    },","> @seandewar and I would need a help with that definition in src/nvim/options.lua. Any idea what could be the right options? I have just copied from tsr, but not sure whether it is right.These are based on the definitions in [`optiondefs.h` here](https://github.com/vim/vim/blob/f4d8b76d304dabc39c06d2344cd4c7b28484811b/src/optiondefs.h#L2635), so probably:```suggestion    {      full_name='thesaurusfunc', abbreviation='tsrfu',      short_desc=N_(""function for filetype-specific thesaurus""),      type='string', scope={'global', 'buffer'},      alloced=true,      secure=true,      varname='p_tsrfu',      defaults={if_true=""""}    },```",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16047,730457341,2021-10-17T18:34:33Z,src/nvim/edit.c,"@@ -4096,7 +4111,14 @@ int ins_compl_add_tv(typval_T *const tv, const Direction dir, bool fast)     return FAIL;   }   return ins_compl_add((char_u *)word, -1, NULL,-                       (char_u **)cptext, true, &user_data, dir, flags, dup);+                       (char_u * *)cptext, true, &user_data, dir, flags, dup);","```suggestion                       (char_u **)cptext, true, &user_data, dir, flags, dup);```",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16047,730458968,2021-10-17T18:47:25Z,src/nvim/edit.c,"@@ -4272,17 +4294,17 @@ static int ins_compl_get_exp(pos_T *ini)      case CTRL_X_DICTIONARY:     case CTRL_X_THESAURUS:-      ins_compl_dictionaries(dict != NULL ? dict-                                          : (type == CTRL_X_THESAURUS-             ? (*curbuf->b_p_tsr == NUL-                ? p_tsr-                : curbuf->b_p_tsr)-                : (*curbuf->b_p_dict == NUL-                ? p_dict-                : curbuf->b_p_dict)),-                             compl_pattern,-                             dict != NULL ? dict_f-                                          : 0, type == CTRL_X_THESAURUS);+      if (thesaurus_func_complete(type)) {+        expand_by_function(type, compl_pattern);+      } else {+        ins_compl_dictionaries(dict != NULL ? dict+                                            : (type == CTRL_X_THESAURUS+                         ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)+                                                    : (*curbuf->b_p_dict ==+                                                       NUL ? p_dict : curbuf->b_p_dict)),+                               compl_pattern,+                               dict != NULL ? dict_f : 0, type == CTRL_X_THESAURUS);","Something like this should appease the lint errors for this part:```suggestion        ins_compl_dictionaries(dict != NULL ? dict                               : (type == CTRL_X_THESAURUS                                  ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)                                  : (*curbuf->b_p_dict == NUL ? p_dict : curbuf->b_p_dict)),                               compl_pattern,                               dict != NULL ? dict_f : 0, type == CTRL_X_THESAURUS);```",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/15949,730477480,2021-10-17T21:12:14Z,runtime/lua/vim/lsp.lua,"@@ -769,8 +769,11 @@ function lsp.start_client(config)     config = config;      handlers = handlers;+    pending_requests = {};+    cancel_requests = {};","Unfortunately it requires changes to the RPC layer, but I didn't want to make the RPC layer aware of the ""tracking"" functionality for the client. That should be entirely in the actual client handling layer. Since the RPC layer wasn't quite able to fully meet those needs, I had to extend it (minimally as much as I could). The only changes to the RPC library are that it now calls an optional callback when a reply is received for a request (including cancel requests). The rest of the changes are to simply keep track of the request IDs and associated method while the request is in flight to the server. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15949,730477762,2021-10-17T21:14:19Z,runtime/lua/vim/lsp.lua,"@@ -967,6 +981,11 @@ function lsp.start_client(config)   ---@see |vim.lsp.client.notify()|   function client.cancel_request(id)     validate{id = {id, 'n'}}+    if client.pending_requests[id] then+      client.cancel_requests[id] = client.pending_requests[id]+      client.pending_requests[id] = nil+      nvim_command(""doautocmd <nomodeline> User LspRequestChange"")+    end     return rpc.notify(""$/cancelRequest"", { id = id })","Would it make sense to have a single `requests` map? (Please check if one already exists...)Two parallel maps is unnecessary, there will not be a lot of requests at any given time, and even if there are, canceling should be rare enough that iterating all requests is a reasonable cost.More generally, avoid special-purpose things and try to use or enhance existing structures (if they exist).",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/15949,730477790,2021-10-17T21:14:36Z,runtime/lua/vim/lsp.lua,"@@ -903,11 +906,22 @@ function lsp.start_client(config)     end     -- Ensure pending didChange notifications are sent so that the server doesn't operate on a stale state     changetracking.flush(client)-+    bufnr = resolve_bufnr(bufnr)     local _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, handler, bufnr)-    return rpc.request(method, params, function(err, result)+    local success, request_id = rpc.request(method, params, function(err, result)       handler(err, result, {method=method, client_id=client_id, bufnr=bufnr, params=params})+    end, function(request_id)+      client.pending_requests[request_id] = nil+      client.cancel_requests[request_id] = nil+      nvim_command(""doautocmd <nomodeline> User LspRequestChange"")","There's a similar autocmd for progress messages (see `LspProgressUpdate`) which has the same intended use case. This PR has changes to allow both the initial request and the reply to be observable. Without it, user status lines (or other hooks when there is a new request or reply) would have to poll the client object to notice changes instead of waiting on an event.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16020,730482164,2021-10-17T21:52:35Z,src/nvim/api/keysets.lua,"@@ -48,5 +48,12 @@ return {     ""style"";     ""noautocmd"";   };+  statusline = {",following the pattern of the other keysets :```suggestion  eval_statusline = {```,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15949,730499493,2021-10-18T00:01:14Z,runtime/lua/vim/lsp.lua,"@@ -903,11 +906,22 @@ function lsp.start_client(config)     end     -- Ensure pending didChange notifications are sent so that the server doesn't operate on a stale state     changetracking.flush(client)-+    bufnr = resolve_bufnr(bufnr)     local _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, handler, bufnr)-    return rpc.request(method, params, function(err, result)+    local success, request_id = rpc.request(method, params, function(err, result)       handler(err, result, {method=method, client_id=client_id, bufnr=bufnr, params=params})+    end, function(request_id)+      client.pending_requests[request_id] = nil+      client.cancel_requests[request_id] = nil+      nvim_command(""doautocmd <nomodeline> User LspRequestChange"")",It should be at minimum documented. I share Justin's concern that it's a little weird to duplicate it but the triggering logic is pretty different at each callsite,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15949,730499814,2021-10-18T00:03:14Z,runtime/lua/vim/lsp.lua,"@@ -903,11 +906,22 @@ function lsp.start_client(config)     end     -- Ensure pending didChange notifications are sent so that the server doesn't operate on a stale state     changetracking.flush(client)-+    bufnr = resolve_bufnr(bufnr)     local _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, handler, bufnr)-    return rpc.request(method, params, function(err, result)+    local success, request_id = rpc.request(method, params, function(err, result)       handler(err, result, {method=method, client_id=client_id, bufnr=bufnr, params=params})+    end, function(request_id)+      client.pending_requests[request_id] = nil+      client.cancel_requests[request_id] = nil+      nvim_command(""doautocmd <nomodeline> User LspRequestChange"")",what are we trying to convey by naming it `LspRequestChange` ? should it be just `LspRequest` ?,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16041,730648449,2021-10-18T07:42:45Z,third-party/cmake/BuildLuajit.cmake,"@@ -55,12 +55,12 @@ else() endif() set(INSTALLCMD_UNIX ${MAKE_PRG} CFLAGS=-fPIC                                 CFLAGS+=-DLUA_USE_APICHECK-                                CFLAGS+=-DLUA_USE_ASSERT+                                CFLAGS+=-funwind-tables","quite possibly :) (Windows is a big mystery to me, so I prefer not to touch it unless absolutely necessary.)Will update the commit ASAP.",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/15949,731000442,2021-10-18T14:39:20Z,runtime/lua/vim/lsp.lua,"@@ -903,11 +906,22 @@ function lsp.start_client(config)     end     -- Ensure pending didChange notifications are sent so that the server doesn't operate on a stale state     changetracking.flush(client)-+    bufnr = resolve_bufnr(bufnr)     local _ = log.debug() and log.debug(log_prefix, ""client.request"", client_id, method, params, handler, bufnr)-    return rpc.request(method, params, function(err, result)+    local success, request_id = rpc.request(method, params, function(err, result)       handler(err, result, {method=method, client_id=client_id, bufnr=bufnr, params=params})+    end, function(request_id)+      client.pending_requests[request_id] = nil+      client.cancel_requests[request_id] = nil+      nvim_command(""doautocmd <nomodeline> User LspRequestChange"")","Initially my thought was that it's indicating a change to the active set of lsp requests. I'm fine naming it `LspRequest` as well. As for documentation - `LspProgressUpdate` is not currently documented either, so where would the best place be for this?",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16070,731067871,2021-10-18T15:39:37Z,runtime/lua/vim/lsp.lua,"@@ -1226,9 +1228,20 @@ function lsp._vim_exit_handler()     client.stop()   end -  if not vim.wait(500, function() return tbl_isempty(active_clients) end, 50) then-    for _, client in pairs(active_clients) do-      client.stop(true)+  local timeouts = {}+  for _, client in pairs(active_clients) do+    local timeout = if_nil(client.flags.graceful_exit_timeout, 500)+    table.insert(timeouts, timeout)+  end++  table.sort(timeouts)",Could also just keep track of the highest value - no need to materialize the list of timeouts.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16083,731918733,2021-10-19T14:19:02Z,runtime/doc/vim_diff.txt,"@@ -429,7 +424,21 @@ Vimscript compatibility:   `this_session` does not alias to |v:this_session|  ==============================================================================-5. Missing legacy features				 *nvim-features-missing*+5. Diverged features					*nvim-features-diverged*","Thanks for considering this, but let's not add a new section. The distinction vs `:help nvim-features-changed` is mostly pedantic, doesn't matter to users, and adds friction when contributors need to add notes to vim_diff.txt. In fact I will likely _combine_ `:help nvim-features-changed` into `:help nvim-features`.Meanwhile you could add a very brief clause at the top of `:help nvim-features-changed` like : > Some Vim features were changed in Nvim, and vice versa.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16095,732198682,2021-10-19T19:58:01Z,test/functional/lua/diagnostic_spec.lua,"@@ -1046,6 +1046,21 @@ describe('vim.diagnostic', function()         vim.api.nvim_win_close(winnr, true)         return lines       ]])++      -- With column position past the end of the line (#16062)","Nit (mentioning for general practice): the `#` is very unambiguous in comments, so there is no need for extra adornments like parentheses.```suggestion      -- With column position past the end of the line. #16062```",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16099,732374684,2021-10-20T02:43:16Z,runtime/lua/vim/lsp.lua,"@@ -1181,15 +1172,11 @@ end  --- Returns list of buffers attached to client_id. ------@param client_id client id+---@param client_id number client id ---@returns list of buffer ids function lsp.get_buffers_by_client_id(client_id)","We could consider deprecating this function at some point, it saves 2 lines of code now (which is my bad)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16099,732514471,2021-10-20T08:05:15Z,runtime/lua/vim/lsp.lua,"@@ -1032,6 +1028,7 @@ function lsp.start_client(config)       -- TODO(ashkan) handle errors.       pcall(config.on_attach, client, bufnr)     end+    client.buffers[bufnr] = true",I think I'd prefer it as it adds a lot of semantic context.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16103,732520123,2021-10-20T08:12:32Z,runtime/lua/vim/lsp/tagfunc.lua,"@@ -0,0 +1,66 @@+local M = {}+local lsp = vim.lsp++do+  local function mk_tag_item(name, range, uri)+    local start = range.start+    return {+      name = name,+      filename = vim.uri_to_fname(uri),+      cmd = string.format(+        'call cursor(%d, %d)', start.line + 1, start.character + 1",In my implementation I was lazy here because I mainly use ascii/latin-1  - this needs to handle the client encoding and translate the position,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16105,732830532,2021-10-20T14:20:57Z,runtime/lua/vim/lsp/util.lua,"@@ -1375,7 +1375,7 @@ end --- ---@param contents table of lines to show in window ---@param syntax string of syntax to set for opened buffer----@param opts dictionary with optional fields+---@param opts dictionary with optional fields, additional keys are passed on to |vim.api.nvim_open_win()| ---             - height    of floating window ---             - width     of floating window ---             - wrap boolean enable wrapping of long lines (defaults to true)","While you're modifying this docstring can you please update the format of the key listings?```suggestion---@param opts dictionary with optional fields (additional keys are passed to |vim.api.nvim_open_win()|)---             - height: (number) height of floating window---             - width: (number) width of floating window---             - wrap: (boolean, default true) wrap long lines```etc. Essentially the format is```key: (type[, default {val}]) brief description```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16090,733139520,2021-10-20T20:56:21Z,src/nvim/lib/ringbuf.h,"@@ -183,21 +183,21 @@       return item_p - rb->buf + rb->buf_end - rb->first + 1; \     } \   } \-\+ \","funny. not a big deal though. Macros have no reason to have ""blank"" lines.we could just remove these lines.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16098,733140359,2021-10-20T20:57:38Z,src/nvim/auevents.lua,"@@ -37,6 +37,7 @@ return {     'CursorHoldI',            -- idem, in Insert mode     'CursorMoved',            -- cursor was moved     'CursorMovedI',           -- cursor was moved in Insert mode+    'DiagnosticsChanged',     -- diagnostics in a buffer were modified","+1 for the singular `Diagnostic`, but using `NounVerb` pattern seems more idiomatic (`BufRead`, `EncodingChanged`, `TabClosed`, etc.)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16121,735019321,2021-10-23T20:50:48Z,runtime/lua/vim/lsp/util.lua,"@@ -412,120 +422,110 @@ local function last_difference(old_lines, new_lines, start_char, end_line_idx)   local new_line   if end_line_idx <= -line_count then     end_line_idx = -line_count-    old_line  = string.sub(old_lines[#old_lines + end_line_idx + 1], start_char)-    new_line  = string.sub(new_lines[#new_lines + end_line_idx + 1], start_char)+    old_line  = string.sub(old_lines[#old_lines + end_line_idx + 1], start_byte)+    new_line  = string.sub(new_lines[#new_lines + end_line_idx + 1], start_byte)   else     old_line  = old_lines[#old_lines + end_line_idx + 1]     new_line  = new_lines[#new_lines + end_line_idx + 1]   end   local old_line_length = #old_line   local new_line_length = #new_line   local length = math.min(old_line_length, new_line_length)-  local end_col_idx = -1-  while end_col_idx >= -length do-    local old_char =  string.sub(old_line, old_line_length + end_col_idx + 1, old_line_length + end_col_idx + 1)-    local new_char =  string.sub(new_line, new_line_length + end_col_idx + 1, new_line_length + end_col_idx + 1)-    if old_char ~= new_char then+  local end_byte_idx = -1+  while end_byte_idx >= -length do+    local old_byte =  string.sub(old_line, old_line_length + end_byte_idx + 1, old_line_length + end_byte_idx + 1)+    local new_byte =  string.sub(new_line, new_line_length + end_byte_idx + 1, new_line_length + end_byte_idx + 1)+    if old_byte ~= new_byte then+      for _, codepoint in ipairs(vim.str_utfpos(old_line)) do+        if codepoint >= end_byte_idx then+          end_byte_idx = codepoint+          break+        end+      end       break     end-    end_col_idx = end_col_idx - 1+    end_byte_idx = end_byte_idx - 1   end-  return end_line_idx, end_col_idx+  return end_line_idx, end_byte_idx  end  ---@private --- Get the text of the range defined by start and end line/column ---@param lines table list of lines----@param start_char integer First different character idx of range----@param end_char integer Last different character idx of range+---@param start_byte integer First different byte idx of range+---@param end_byte integer Last different byte idx of range ---@param start_line integer First different line idx of range ---@param end_line integer Last different line idx of range ---@returns string text extracted from defined region-local function extract_text(lines, start_line, start_char, end_line, end_char)+local function extract_text(lines, start_line, start_byte, end_line, end_byte)   if start_line == #lines + end_line + 1 then     if end_line == 0 then return '' end     local line = lines[start_line]-    local length = #line + end_char - start_char-    return string.sub(line, start_char, start_char + length + 1)+    local length = #line + end_byte - start_byte+    return string.sub(line, start_byte, start_byte + length + 1)   end-  local result = string.sub(lines[start_line], start_char) .. '\n'+  local result = string.sub(lines[start_line], start_byte) .. '\n'   for line_idx = start_line + 1, #lines + end_line do     result = result .. lines[line_idx] .. '\n'   end   if end_line ~= 0 then     local line = lines[#lines + end_line + 1]-    local length = #line + end_char + 1+    local length = #line + end_byte + 1     result = result .. string.sub(line, 1, length)   end   return result end ----@private---- Compute the length of the substituted range----@param lines table list of lines----@param start_char integer First different character idx of range----@param end_char integer Last different character idx of range----@param start_line integer First different line idx of range----@param end_line integer Last different line idx of range----@returns (int, int) end_line_idx and end_col_idx of range-local function compute_length(lines, start_line, start_char, end_line, end_char)-  local adj_end_line = #lines + end_line + 1-  local adj_end_char-  if adj_end_line > #lines then-    adj_end_char =  end_char - 1-  else-    adj_end_char = #lines[adj_end_line] + end_char-  end-  if start_line == adj_end_line then-    return adj_end_char - start_char + 1-  end-  local result = #lines[start_line] - start_char + 1-  for line = start_line + 1, adj_end_line -1 do-    result = result + #lines[line] + 1-  end-  result = result + adj_end_char + 1-  return result-end- --- Returns the range table for the difference between old and new lines ---@param old_lines table list of lines ---@param new_lines table list of lines----@param start_line_idx int line to begin search for first difference----@param end_line_idx int line to begin search for last difference+---@param start_line_idx number line to begin search for first difference+---@param end_line_idx number line to begin search for last difference ---@param offset_encoding string encoding requested by language server ---@returns table start_line_idx and start_col_idx of range function M.compute_diff(old_lines, new_lines, start_line_idx, end_line_idx, offset_encoding)-  local start_line, start_char = first_difference(old_lines, new_lines, start_line_idx)-  local end_line, end_char = last_difference(vim.list_slice(old_lines, start_line, #old_lines),-      vim.list_slice(new_lines, start_line, #new_lines), start_char, end_line_idx)-  local text = extract_text(new_lines, start_line, start_char, end_line, end_char)-  local length = compute_length(old_lines, start_line, start_char, end_line, end_char)--  local adj_end_line = #old_lines + end_line-  local adj_end_char-  if end_line == 0 then-    adj_end_char = 0+  -- Find first changed line, and the first utf-8 character difference+  local start_line_idx, start_byte_idx = first_difference(old_lines, new_lines, start_line_idx)++  -- Find the last changed line, and the last utf-8 character difference+  local end_line_idx, end_byte_idx = last_difference(+    vim.list_slice(old_lines, start_line_idx, #old_lines),","As in, I don't need to change anything because the pointers stored to strings in the sliced list should be the same?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16047,735031225,2021-10-23T21:43:39Z,src/nvim/option.c,"@@ -139,7 +139,7 @@ static char_u *p_cpt; static char_u *p_cfu; static char_u *p_ofu; static char_u *p_tfu;-static char_u *p_thsfu;+static char_u *p_tsrfu;","Again, a nit-pick, but the `p_thsfu` to `p_tsrfu` change is from v8.2.3528; you've instead included it in v8.2.3525 with the `b_p_thsfu` to `b_p_tsrfu` change.(What you did is technically correct, as this was an error in the original v8.2.3525 patch (though your changes won't compile without `option.lua` changes from v8.2.3528), but it was a bit confusing to review)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16129,735033099,2021-10-23T21:47:21Z,src/nvim/lua/executor.c,"@@ -206,6 +206,38 @@ static int nlua_str_byteindex(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   return 1; } +/// returns the byte offset of the next codepoint+///+/// Expects a string and a string+///+/// Returns the byte offset of the next codepoint+static int nlua_str_utf_next(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  size_t s1_len;+  size_t s2_len;+  const char *s1 = luaL_checklstring(lstate, 1, &s1_len);+  const char *s2 = luaL_checklstring(lstate, 1, &s2_len);","duh, my bad. will fix",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16129,735078631,2021-10-24T07:46:56Z,src/nvim/lua/executor.c,"@@ -206,6 +206,38 @@ static int nlua_str_byteindex(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL   return 1; } +/// returns the byte offset of the next codepoint+///+/// Expects a string and a string+///+/// Returns the byte offset of the next codepoint+static int nlua_str_utf_next(lua_State *const lstate) FUNC_ATTR_NONNULL_ALL+{+  size_t s1_len;+  size_t s2_len;+  const char *s1 = luaL_checklstring(lstate, 1, &s1_len);+  const char *s2 = luaL_checklstring(lstate, 2, &s2_len);+  int offset = mb_off_next((char_u*)&s1, (char_u*)&s2);","both args has to be from the same string for it to make sense. so this has to take `(str, offset)` args instead (which will avoid string slicing/duplication on the lua side so it is more efficient anyway).",
2602750,doubleloop,https://api.github.com/repos/neovim/neovim/pulls/16141,735410246,2021-10-25T09:16:45Z,.github/workflows/ci-asan.yml,"@@ -0,0 +1,96 @@+name: ""CI asan""+on:+  push:+    branches: '**'+  pull_request:+    types: [opened, synchronize, reopened, ready_for_review]+    branches:+      - 'master'+      - 'release-[0-9]+.[0-9]+'++jobs:+  unixish:+    name: ${{ matrix.runner }} ${{ matrix.flavor }} (cc=${{ matrix.cc }})+    strategy:+      fail-fast: false+      matrix:+        include:+          - flavor: asan+            cc: clang-12+            runner: ubuntu-20.04+            os: linux+    runs-on: ${{ matrix.runner }}+    timeout-minutes: 45+    if: github.event.pull_request.draft == false+    env:+      CC: ${{ matrix.cc }}+      CI_OS_NAME: ${{ matrix.os }}+    steps:+      - uses: actions/checkout@v2++      - name: Setup commom environment variables+        run: ./.github/workflows/env.sh ${{ matrix.flavor }}++      - name: Install apt packages+        if: matrix.os == 'linux'+        run: |+          sudo apt-get update+          sudo apt-get install -y autoconf automake build-essential ccache cmake cpanminus cscope gcc-multilib gdb gettext gperf language-pack-tr libtool-bin locales ninja-build pkg-config python3 python3-pip python3-setuptools unzip valgrind xclip++      - name: Install minimum required version of cmake+        if: matrix.cmake == 'minimum_required'","IMO this is not required here. Minimal cmake was installed only in one workflow (I picked functionaltest-lua), no need to duplicate this step for other workflows.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16137,736603944,2021-10-26T14:27:28Z,runtime/lua/vim/diagnostic.lua,"@@ -1074,16 +1087,10 @@ function M.show(namespace, bufnr, diagnostics, opts)    clamp_line_numbers(bufnr, diagnostics) -  if opts.underline then-    M._set_underline(namespace, bufnr, diagnostics, opts.underline)-  end--  if opts.virtual_text then-    M._set_virtual_text(namespace, bufnr, diagnostics, opts.virtual_text)-  end--  if opts.signs then-    M._set_signs(namespace, bufnr, diagnostics, opts.signs)+  for hook, cb in pairs(M.hooks) do+    if opts[hook] then","I suspect collisions will be rare, and namespaces can already be used as a string (that is, `vim.diagnostic.hooks[""plugin/hook""]` works just fine). If we allow sub-tables as namespaces we lose the ability to validate that any new key in `hooks` is a function, as well as introducing complexity in needing to iterate through those subtables.",
86065,yorickpeterse,https://api.github.com/repos/neovim/neovim/pulls/16153,736748564,2021-10-26T17:01:33Z,src/nvim/lua/vim.lua,"@@ -182,6 +182,12 @@ function vim._os_proc_children(ppid)   return children end +function vim._has_wsl()+  return+    vim.loop.os_uname()['release']:match(+      '[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]') and true or false","This seems like something that would stop working the moment the format is changed even slightly. Is there perhaps a simpler pattern or a specific string (e.g. ""microsoft"" or something like that) that we could use/look for?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16153,736750713,2021-10-26T17:04:15Z,src/nvim/lua/vim.lua,"@@ -182,6 +182,12 @@ function vim._os_proc_children(ppid)   return children end +function vim._has_wsl()+  return+    vim.loop.os_uname()['release']:match(+      '[Mm][Ii][Cc][Rr][Oo][Ss][Oo][Ff][Tt]') and true or false","> Is there perhaps a simpler pattern or a specific string (e.g. ""microsoft"" or something like that)That's what this is doing already though, it's checking to see if `uname` contains ""Microsoft"" (case-insensitively).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16137,737515053,2021-10-27T14:15:24Z,runtime/lua/vim/diagnostic.lua,"@@ -782,156 +796,167 @@ function M.goto_next(opts)   ) end --- Diagnostic Setters {{{----- Set signs for given diagnostics.--------@param namespace number The diagnostic namespace----@param bufnr number Buffer number----@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the----                       current diagnostics in the given buffer are used.----@param opts table Configuration table with the following keys:----            - priority: Set the priority of the signs |sign-priority|.----@private-function M._set_signs(namespace, bufnr, diagnostics, opts)-  vim.validate {-    namespace = {namespace, 'n'},-    bufnr = {bufnr, 'n'},-    diagnostics = {diagnostics, 't'},-    opts = {opts, 't', true},-  }+M.handlers.signs = {+  show = function(namespace, bufnr, diagnostics, opts)+    vim.validate {+      namespace = {namespace, 'n'},+      bufnr = {bufnr, 'n'},+      diagnostics = {diagnostics, 't'},+      opts = {opts, 't', true},+    }","I had to rewrite the built-in handlers like this, because using```lua---@privatefunction M.handlers.signs.show(...)```caused the `gen_vimdoc.py` script to exclude the `vim.diagnostic.show()` and `hide()` functions as well. I guess the `---@private` annotation is applied to the last ""token"" of the function name.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16103,737618703,2021-10-27T15:56:31Z,runtime/lua/vim/lsp/tagfunc.lua,"@@ -0,0 +1,66 @@+local M = {}+local lsp = vim.lsp++do+  local function mk_tag_item(name, range, uri)+    local start = range.start+    return {+      name = name,+      filename = vim.uri_to_fname(uri),+      cmd = string.format(+        'call cursor(%d, %d)', start.line + 1, start.character + 1+      )+    }+  end++  local function query_definition(pattern)+    local params = lsp.util.make_position_params()+    local results_by_client, err = lsp.buf_request_sync(0, 'textDocument/definition', params, 1000)+    assert(not err, vim.inspect(err))+    local results = {}+    local add = function(range, uri) table.insert(results, mk_tag_item(pattern, range, uri)) end+    for _, lsp_results in pairs(results_by_client) do+      local result = lsp_results.result or {}+      if result.range then              -- Location+        add(result.range, result.uri)+      else                              -- Location[] or LocationLink[]+        for _, item in pairs(result) do+          if item.range then            -- Location+            add(item.range, item.uri)+          else                          -- LocationLink+            add(item.targetSelectionRange, item.targetUri)+          end+        end+      end+    end+    return results+  end++  local function query_workspace_symbols(pattern)+    local results_by_client, err = lsp.buf_request_sync(0, 'workspace/symbol', { query = pattern }, 1000)+    assert(not err, vim.inspect(err))+    local results = {}+    for _, symbols in pairs(results_by_client) do+      for _, symbol in pairs(symbols.result or {}) do+        local loc = symbol.location+        local item = mk_tag_item(symbol.name, loc.range, loc.uri)+        item.kind = lsp.protocol.SymbolKind[symbol.kind] or 'Unknown'+        table.insert(results, item)+      end+    end+    return results+  end++  function M.tagfunc(pattern, flags)+    if flags == 'c' then+      return query_definition(pattern)+    elseif flags == '' or flags == 'i' then+      return query_workspace_symbols(pattern)","We should check the return value of `query_definition` and `query_workspace_symbols` rather than returning them directly. If they return an empty list, we should return `vim.NIL` (so that we fall back to tags).",
394891,jdrouhard,https://api.github.com/repos/neovim/neovim/pulls/15949,739186005,2021-10-29T12:21:23Z,runtime/doc/lsp.txt,"@@ -451,6 +451,22 @@ LspSignatureActiveParameter    Used to highlight the active parameter in the signature help. See    |vim.lsp.handlers.signature_help()|. +==============================================================================+EVENTS                                                            *lsp-events*++LspProgressUpdate                                          *LspProgressUpdate*","This autocmd has already been in master for a very long time, I'm just adding the missing documentation for it. I don't think I want to change it and introduce a breaking change here.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16177,739641494,2021-10-30T11:22:30Z,runtime/lua/vim/lsp/handlers.lua,"@@ -185,7 +185,7 @@ local function response_to_list(map_result, entity)           title = 'Language Server';           items = map_result(result, ctx.bufnr);         })-        api.nvim_command(""copen"")+        api.nvim_command(""botright copen"")","Actually, given that the location list is bound to the window I guess the difference makes sense.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16175,739650211,2021-10-30T12:39:48Z,src/mpack/lmpack.c,"@@ -1161,8 +1161,8 @@ static const luaL_reg mpack_functions[] = {   {""Unpacker"", lmpack_unpacker_new},   {""Packer"", lmpack_packer_new},   {""Session"", lmpack_session_new},-  {""unpack"", lmpack_unpack},-  {""pack"", lmpack_pack},+  {""decode"", lmpack_unpack},+  {""encode"", lmpack_pack},","But this is incongruent with the `Unpacker` and `Packer` classes, above... :/There is also an option named `unpack`...",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16192,739858346,2021-10-31T18:19:05Z,runtime/lua/vim/lsp.lua,"@@ -1255,27 +1255,30 @@ function lsp._vim_exit_handler()       send_kill = true       timeouts[client_id] = timeout       max_timeout = math.max(timeout, max_timeout)-    else-      active_clients[client_id] = nil     end   end    local poll_time = 50    local function check_clients_closed()","This won't have the desired effect, because the function no longer considers whether the client is actually active, so a client that shuts down early but has a long timeout will still block. You would still want to filter on active clients.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/15838,739891844,2021-10-31T23:28:18Z,runtime/lua/vim/ui.lua,"@@ -9,6 +9,14 @@ local M = {} ---     - format_item (function item -> text) ---               Function to format an ---               individual item from `items`. Defaults to `tostring`.+---     - kind (string|nil)+---               Kind of `items`.+---               Plugins reimplementing `vim.ui.select` may wish to+---               display different ui elements depending on the+---               the structure of `items`, or the context in which+---               `select` is called. `kind` allows authors+---               of such plugins to opt into maintaining such+---               behavior.","Can say  more, with less.```suggestion---     - kind (string|nil)---               Arbitrary hint string indicating the item shape.---               Plugins reimplementing `vim.ui.select` may wish to---               use this to infer the structure or semantics of---               `items`, or the context in which select() was called.```",
5160701,seblj,https://api.github.com/repos/neovim/neovim/pulls/15959,740103739,2021-11-01T10:18:40Z,runtime/lua/vim/ui.lua,"@@ -32,5 +32,34 @@ function M.select(items, opts, on_choice)   end end +--- Prompts the user for input+---+---@param opts table Additional options. See |input()|+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Input: `.+---     - default (string|nil)+---               Default reply to the input+---     - completion (string|nil)+---               Specifies type of completion supported+---               for input. Supported types are the same+---               that can be supplied to a user-defined+---               command using the ""-complete="" argument.+---               See |:command-completion|+---     - highlight (function)+---               Function that will be used for highlighting+---               user inputs.+---@param on_confirm function ((input) -> ())+---               Called once the user confirms the input.+---               `input` is what the user typed.","I can change it to `handler`. I chose `on_confirm` to follow the naming of `vim.ui.select` though, since that one is called `on_choice`",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15959,740202581,2021-11-01T13:17:12Z,runtime/lua/vim/ui.lua,"@@ -32,5 +32,34 @@ function M.select(items, opts, on_choice)   end end +--- Prompts the user for input+---+---@param opts table Additional options. See |input()|+---     - prompt (string|nil)+---               Text of the prompt. Defaults to `Input: `.+---     - default (string|nil)+---               Default reply to the input+---     - completion (string|nil)+---               Specifies type of completion supported+---               for input. Supported types are the same+---               that can be supplied to a user-defined+---               command using the ""-complete="" argument.+---               See |:command-completion|+---     - highlight (function)+---               Function that will be used for highlighting+---               user inputs.+---@param on_confirm function ((input) -> ())+---               Called once the user confirms the input.+---               `input` is what the user typed.",">I chose `on_confirm` to follow the naming of `vim.ui.select` though, since that one is called `on_choice`Sticking with `on_` for callbacks is good as it's consistent with other areas in the Nvim API (e.g. `on_key`), particularly if it's already used in `vim.ui.select`.",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16047,740300827,2021-11-01T15:26:09Z,src/nvim/edit.c,"@@ -4096,7 +4111,14 @@ int ins_compl_add_tv(typval_T *const tv, const Direction dir, bool fast)     return FAIL;   }   return ins_compl_add((char_u *)word, -1, NULL,-                       (char_u **)cptext, true, &user_data, dir, flags, dup);+                       (char_u * *)cptext, true, &user_data, dir, flags, dup);","```suggestion                       (char_u **)cptext, true, &user_data, dir, flags, dup);```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/16204,740941081,2021-11-02T10:53:28Z,src/nvim/globals.h,"@@ -990,8 +988,8 @@ EXTERN char e_api_error[] INIT(=N_(""E5555: API call: %s""));  EXTERN char e_luv_api_disabled[] INIT(=N_(""E5560: %s must not be called in a lua loop callback"")); -EXTERN char e_floatonly[] INIT(=N_(-                                  ""E5601: Cannot close window, only floating window would remain""));+EXTERN char e_floatonly[] INIT(=+                                 N_(""E5601: Cannot close window, only floating window would remain""));","It's more that it tries (and fails) to properly split the line since it's over the 100-character limit. We have following options, from what I believe to be from the best to worst:1. Add a `\` after `INIT` for all lines exceeding 100 characters. This would typically look like```cEXTERN char e_floatonly[] \  INIT(=N_(""E5601: Cannot close window, only floating window would remain""));```2. Revert the offending commit, meaning resetting `sp_enum_after_assign = ignore`. I've rechecked and the number of changes is really negligible so this isn't a big deal.3. Disable the formatting for the `INIT`-graveyard with a `// uncrustify:off` before and `// uncrustify:on` after.4. Increase the character-limit to 130Which one would you prefer the most?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16103,742103769,2021-11-03T16:10:13Z,runtime/lua/vim/lsp/tagfunc.lua,"@@ -0,0 +1,69 @@+local M = {}+local lsp = vim.lsp++local function mk_tag_item(name, range, uri)+  local start = range.start+  return {+    name = name,+    filename = vim.uri_to_fname(uri),+    cmd = string.format(+      'call cursor(%d, %d)', start.line + 1, start.character + 1","```suggestion      'call cursor(%d, %d)|', start.line + 1, start.character + 1```So seems that the trailing characters thing is not a bug with Nvim, but an oddity of the tags file format.It's explained somewhat in `:h tags-file-format`.We don't actually want to use the `|;""` terminator described in the `{term}` bit otherwise we'd lose the `kind` information. :shrug:_Though I do wonder what caused that one segfault I had..._Looks like a search pattern can be used here instead, so something like:```luacmd = string.format(  '/\\%%%dl\\%%%dc/', start.line + 1, start.character + 1)```could probably also work?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16103,742117572,2021-11-03T16:24:36Z,runtime/lua/vim/lsp/tagfunc.lua,"@@ -0,0 +1,69 @@+local M = {}+local lsp = vim.lsp++local function mk_tag_item(name, range, uri)+  local start = range.start+  return {+    name = name,+    filename = vim.uri_to_fname(uri),+    cmd = string.format(+      'call cursor(%d, %d)', start.line + 1, start.character + 1+    )+  }+end++local function query_definition(pattern)+  local params = lsp.util.make_position_params()+  local results_by_client, err = lsp.buf_request_sync(0, 'textDocument/definition', params, 1000)+  assert(not err, vim.inspect(err))+  local results = {}+  local add = function(range, uri) table.insert(results, mk_tag_item(pattern, range, uri)) end+  for _, lsp_results in pairs(results_by_client) do+    local result = lsp_results.result or {}+    if result.range then              -- Location+      add(result.range, result.uri)+    else                              -- Location[] or LocationLink[]+      for _, item in pairs(result) do+        if item.range then            -- Location+          add(item.range, item.uri)+        else                          -- LocationLink+          add(item.targetSelectionRange, item.targetUri)+        end+      end+    end+  end+  return results+end++local function query_workspace_symbols(pattern)+  local results_by_client, err = lsp.buf_request_sync(0, 'workspace/symbol', { query = pattern }, 1000)+  assert(not err, vim.inspect(err))+  local results = {}+  for _, symbols in pairs(results_by_client) do+    for _, symbol in pairs(symbols.result or {}) do+      local loc = symbol.location+      local item = mk_tag_item(symbol.name, loc.range, loc.uri)+      item.kind = lsp.protocol.SymbolKind[symbol.kind] or 'Unknown'+      table.insert(results, item)+    end+  end+  return results+end++function M.tagfunc(pattern, flags)+  local matches+  if flags == 'c' then","Seems that more than one flag may be passed to `tagfunc`; i.e: insert mode tag completion can pass `cir`.If tag completion is the only thing which does that, it's probably not a big deal as omni-completion can be used instead.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16218,742794236,2021-11-04T12:37:29Z,runtime/lua/vim/lsp/util.lua,"@@ -1481,6 +1481,24 @@ function M.open_floating_preview(contents, syntax, opts)   return floating_bufnr, floating_winnr end +local function convert_utf_to_byte(line, idx, offset_encoding)",There's `get_line_byte_from_position` which is similar - is it possible to merge the two?,x
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16155,744122214,2021-11-06T12:54:36Z,src/nvim/window.c,"@@ -725,8 +725,11 @@ void win_config_float(win_T *wp, FloatConfig fconfig)    bool has_border = wp->w_floating && wp->w_float_config.border;   for (int i = 0; i < 4; i++) {-    wp->w_border_adj[i] =-      has_border && wp->w_float_config.border_chars[2 * i+1][0];+    int new_adj = has_border && wp->w_float_config.border_chars[2 * i + 1][0];+    if (new_adj != wp->w_border_adj[i]) {+      change_border = true;",Isn't there already `w_redr_border` for that?<https://github.com/neovim/neovim/blob/1fdbd29dfa6366f8346693d0bf67f4f782ab0f32/src/nvim/window.c#L777-L781>,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16155,744124449,2021-11-06T13:18:20Z,src/nvim/window.c,"@@ -725,8 +725,11 @@ void win_config_float(win_T *wp, FloatConfig fconfig)    bool has_border = wp->w_floating && wp->w_float_config.border;   for (int i = 0; i < 4; i++) {-    wp->w_border_adj[i] =-      has_border && wp->w_float_config.border_chars[2 * i+1][0];+    int new_adj = has_border && wp->w_float_config.border_chars[2 * i + 1][0];+    if (new_adj != wp->w_border_adj[i]) {+      change_border = true;",That `change_border` name is indeed a bit ambiguous.,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16155,744126521,2021-11-06T13:40:35Z,src/nvim/window.c,"@@ -725,8 +725,11 @@ void win_config_float(win_T *wp, FloatConfig fconfig)    bool has_border = wp->w_floating && wp->w_float_config.border;   for (int i = 0; i < 4; i++) {-    wp->w_border_adj[i] =-      has_border && wp->w_float_config.border_chars[2 * i+1][0];+    int new_adj = has_border && wp->w_float_config.border_chars[2 * i + 1][0];+    if (new_adj != wp->w_border_adj[i]) {+      change_border = true;","Oh, that because without that `memcmp` highlight attrs won't be recalculated:<https://github.com/neovim/neovim/blob/1fdbd29dfa6366f8346693d0bf67f4f782ab0f32/src/nvim/window.c#L742>",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16254,744187443,2021-11-07T01:15:44Z,runtime/doc/options.txt,"@@ -3703,9 +3703,10 @@ A jump table for the options with a short description can be found at |Q_op|. 						*'list'* *'nolist'* 'list'			boolean	(default off) 			local to window-	List mode: Show tabs as CTRL-I is displayed, display $ after end of-	line.  Useful to see the difference between tabs and spaces and for-	trailing blanks.  Further changed by the 'listchars' option.+	List mode: Display non-printable characters according to 'listchars'.","We can use something else if it's clearer, but I don't think we should overthink it too much.I'd honestly be fine with something as simple as ""When set, display characters according to 'listchars'"".FWIW `:h :list` also uses the term ""unprintable characters"".",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/16230,745118587,2021-11-08T21:48:51Z,runtime/doc/vim_diff.txt,"@@ -85,6 +85,10 @@ of these in your config by simply removing the mapping, e.g. "":unmap Y"". 	nnoremap <C-L> <Cmd>nohlsearch<Bar>diffupdate<CR><C-L> 	inoremap <C-U> <C-G>u<C-U> 	inoremap <C-W> <C-G>u<C-W>+	nmap ]g <Plug>(VimDiagnosticGotoNext)+	nmap [g <Plug>(VimDiagnosticGotoPrev)+	nmap ]G <Plug>(VimDiagnosticGotoLast)+	nmap [G <Plug>(VimDiagnosticGotoFirst)","Well `<Plug>` mapping is ""future-proof"", as in, if we change the module location, file path, naming scheme, default arguments, etc., the `<Plug>` mapping can evolve separately.But I'm happy to put the default ones in :) It seems good to me. They just need to be linked in the docs.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16268,745481611,2021-11-09T10:27:42Z,src/nvim/fileio.c,"@@ -5326,38 +5326,112 @@ static void vim_maketempdir(void)   (void)umask(umask_save); } +// Evaluate ""expr"" for readdir().+static varnumber_T readdir_checkitem(typval_T *expr, const char *name)+{+  typval_T save_val;+  typval_T rettv;+  typval_T argv[2];+  varnumber_T retval = 0;+  bool error = false;++  prepare_vimvar(VV_VAL, &save_val);+  set_vim_var_string(VV_VAL, name, -1);+  argv[0].v_type = VAR_STRING;+  argv[0].vval.v_string = (char_u *)name;++  if (eval_expr_typval(expr, argv, 1, &rettv) == FAIL) {+    goto theend;+  }++  retval = tv_get_number_chk(&rettv, &error);+  if (error) {+    retval = -1;+  }++  tv_clear(&rettv);++theend:+  set_vim_var_string(VV_VAL, NULL, 0);+  restore_vimvar(VV_VAL, &save_val);+  return retval;+}++/// Core part of ""readdir()"" function.+/// Retrieve the list of files/directories of ""dirp"" into ""gap"".+void readdir_core(+    garray_T *gap,+    Directory *dirp,+    typval_T *expr,+    bool is_checkitem)+{+  ga_init(gap, (int)sizeof(char *), 20);++  for (;;) {+    bool ignore;++    const char *path = os_scandir_next(dirp);+    if (path == NULL) {+      break;+    }++    ignore = (path[0] == '.'+              && (path[1] == NUL || (path[1] == '.' && path[2] == NUL)));+    if (!ignore && expr != NULL && expr->v_type != VAR_UNKNOWN+        && is_checkitem) {+      varnumber_T r = readdir_checkitem(expr, path);++      if (r < 0) {+        break;+      }+      if (r == 0) {+        ignore = true;+      }+    }++    if (!ignore) {+      ga_grow(gap, 1);+      ((char **)gap->ga_data)[gap->ga_len++] = xstrdup(path);+    }+  }++  if (gap->ga_len > 0) {+    sort_strings((char_u **)gap->ga_data, gap->ga_len);+  }++  os_closedir(dirp);+} /// Delete ""name"" and everything in it, recursively. /// @param name The path which should be deleted. /// @return 0 for success, -1 if some file was not deleted. int delete_recursive(const char *name) {   int result = 0;+  char *exp = (char *)vim_strsave((char_u *)name);+  Directory dir; -  if (os_isrealdir(name)) {-    snprintf((char *)NameBuff, MAXPATHL, ""%s/*"", name);  // NOLINT--    char_u **files;-    int file_count;-    char_u *exp = vim_strsave(NameBuff);-    if (gen_expand_wildcards(1, &exp, &file_count, &files,-                             EW_DIR | EW_FILE | EW_SILENT | EW_ALLLINKS-                             | EW_DODOT | EW_EMPTYOK) == OK) {-      for (int i = 0; i < file_count; i++) {-        if (delete_recursive((const char *)files[i]) != 0) {-          result = -1;-        }+  if (os_isrealdir(name) && os_scandir(&dir, exp)) {+    garray_T ga;++    readdir_core(&ga, &dir, NULL, false);++    for (int i = 0; i < ga.ga_len; i++) {+      vim_snprintf((char *)NameBuff, MAXPATHL, ""%s/%s"", exp,+          ((char_u **)ga.ga_data)[i]);","```src/nvim/fileio.c:5420:  Inner expression should be aligned as opening brace + 1 (+ 2 in case of {). Relevant opening is on line 5419  [whitespace/alignment] [2]``````suggestion      vim_snprintf((char *)NameBuff, MAXPATHL, ""%s/%s"", exp,                   ((char_u **)ga.ga_data)[i]);```",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/16264,745694154,2021-11-09T14:53:27Z,src/nvim/terminal.c,"@@ -278,15 +293,16 @@ void terminal_close(Terminal *term, int status)   term->closed = true;    if (status == -1 || exiting) {-    // If status is -1, this was called by close_buffer(buffer.c).  Or if-    // exiting, we must inform the buffer the terminal no longer exists so that-    // close_buffer() doesn't call this again.+    // If status is -1 so this was called by close_buffer(), or if inside+    // process_teardown(), we must inform the buffer the terminal no longer+    // exists so that close_buffer() doesn't call this again.","```suggestion    // If status is -1, this was called by close_buffer() or inside    // process_teardown().  We must inform the buffer the terminal no longer    // exists so that close_buffer() doesn't call this again.```",
9766,blueyed,https://api.github.com/repos/neovim/neovim/pulls/13843,745900031,2021-11-09T18:34:58Z,src/nvim/log.h,"@@ -17,10 +17,11 @@ #endif  -#define DEBUG_LOG_LEVEL 0-#define INFO_LOG_LEVEL 1-#define WARN_LOG_LEVEL 2-#define ERROR_LOG_LEVEL 3+#define TRACE_LOG_LEVEL 0+#define DEBUG_LOG_LEVEL 1+#define INFO_LOG_LEVEL 2+#define WARN_LOG_LEVEL 3+#define ERROR_LOG_LEVEL 4","This changes behavior, where `CMAKE_EXTRA_FLAGS += -DMIN_LOG_LEVEL=1` now enables debug messages, whereas it was `INFO` only before..!  (e.g. via https://github.com/neovim/neovim/blob/4174244d8b6718c703f8b8d3e907809bde9430bd/src/nvim/channel.c#L185)Since it is released in 0.5 already it should probably stay like this, but it seems like documentation (and CI config) needs to be adjusted also (e.g. https://github.com/neovim/neovim/blob/4174244d8b6718c703f8b8d3e907809bde9430bd/.github/workflows/env.sh#L30).",
541289,dstein64,https://api.github.com/repos/neovim/neovim/pulls/15378,747663566,2021-11-11T16:52:14Z,src/nvim/ex_cmds2.c,"@@ -1409,6 +1409,7 @@ void ex_listdo(exarg_T *eap)     listcmd_busy = true;            // avoids setting pcmark below      while (!got_int && buf != NULL) {+      bool execute = true;","> ""Also let's move the declaration of this variable to its first assignment at line 1438, which makes the code (slightly) easier to follow.""The variable is used at line [1468](https://github.com/neovim/neovim/blob/f436506402f8e233f840f36f9a277c884cf6712b/src/nvim/ex_cmds2.c#L1468), outside the scope of where it's assigned at line [1438](https://github.com/neovim/neovim/blob/f436506402f8e233f840f36f9a277c884cf6712b/src/nvim/ex_cmds2.c#L1438).The variable was named `execute` for how it was used in the later part of the update (i.e., whether `do_cmdline` is called).",
15367354,dmitmel,https://api.github.com/repos/neovim/neovim/pulls/16286,747703199,2021-11-11T17:50:07Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -102,9 +102,10 @@ local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)       end_lnum = _end.line,       end_col = line_byte_from_position(buf_lines, _end.line, _end.character, offset_encoding),       severity = severity_lsp_to_vim(diagnostic.severity),-      message = diagnostic.message,+      message = table.concat(vim.lsp.util.split_lines(diagnostic.message), '\n'),","> This is just the diagnostic message displayed, I don't think we need to split and concatenate here?https://github.com/neovim/neovim/blob/9d6a475cedf93a03214ca9c9bd0673a763994d78/runtime/lua/vim/diagnostic.lua#L1230> Is the server actually returning anything other than `\n`?Unclear, the specification doesn't state anything concrete either",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16289,747902204,2021-11-12T00:31:13Z,test/functional/core/channels_spec.lua,"@@ -282,3 +283,22 @@ describe('channels', function()     eq({""notification"", ""exit"", {id, 1, {''}}}, next_msg())   end) end)++describe('loopback', function()+  before_each(function()+    clear()+    command(""let chan = sockconnect('pipe', v:servername, {'rpc': v:true})"")+  end)++  it('does not crash when seending raw data', function()","```suggestion  it('does not crash when sending raw data', function()```",
21000943,RRethy,https://api.github.com/repos/neovim/neovim/pulls/16218,748889080,2021-11-14T18:08:59Z,runtime/lua/vim/lsp/util.lua,"@@ -1497,18 +1502,30 @@ do --[[ References ]]   ---@param bufnr buffer id   ---@param references List of `DocumentHighlight` objects to highlight   ---@see https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#documentHighlight-  function M.buf_highlight_references(bufnr, references)+  function M.buf_highlight_references(bufnr, references, client_id)     validate { bufnr = {bufnr, 'n', true} }+    local client = vim.lsp.get_client_by_id(client_id)+    if not client then+      return+    end",Changing the function signature in a way that breaks functionality for every single existing caller (since client_id will be nil for all existing callers as it's a new parameter) is a pretty unnecessary landmine to hide.This caused https://github.com/RRethy/vim-illuminate/issues/85.A default value for the `offset_encoding` when `client_id` isn't present would make more sense IMO.,
21000943,RRethy,https://api.github.com/repos/neovim/neovim/pulls/16322,748894268,2021-11-14T18:58:17Z,runtime/lua/vim/lsp/util.lua,"@@ -1341,19 +1341,21 @@ do --[[ References ]]   ---   ---@param bufnr buffer id   ---@param references List of `DocumentHighlight` objects to highlight+  ---@param client_id number client id   ---@see https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#documentHighlight   function M.buf_highlight_references(bufnr, references, client_id)     validate { bufnr = {bufnr, 'n', true} }     local client = vim.lsp.get_client_by_id(client_id)-    if not client then-      return+    local offset_encoding = ""utf-16""+    if client then","> (But this is a newly-introduced API on the development branch that very deliberately is not marked as stable -- breakage must be expected.> That's not saying the API can't be improved, of course.)I was under the impression `vim.lsp.util.buf_highlight_references` is not a newly-introduced API, it exists even in `v0.5.0` with documentation, is there a list of stable APIs? The issue I have though is that this doesn't need to be a breaking change, when this gets released as stable it's gonna be an issue for every caller that exists (which is probably pretty small tbf) and I don't see how the average dev would fix their config/plugin without reading the source code.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16322,748895148,2021-11-14T19:06:18Z,runtime/lua/vim/lsp/util.lua,"@@ -1341,19 +1341,21 @@ do --[[ References ]]   ---   ---@param bufnr buffer id   ---@param references List of `DocumentHighlight` objects to highlight+  ---@param client_id number client id   ---@see https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#documentHighlight   function M.buf_highlight_references(bufnr, references, client_id)     validate { bufnr = {bufnr, 'n', true} }     local client = vim.lsp.get_client_by_id(client_id)-    if not client then-      return+    local offset_encoding = ""utf-16""+    if client then","> I was under the impression vim.lsp.util.buf_highlight_references is not a newly-introduced API, it exists even in v0.5.0 with documentation, is there a list of stable APIs? The issue I have though is that this doesn't need to be a breaking change, when this gets released as stable it's gonna be an issue for every caller that exists (which is probably pretty small tbf) and I don't see how the average dev would fix their config/plugin without reading the source code.Ofc it's not, but this is the nightly we are talking about. You found and noticed an undocumented breaking change that can be worked around.As for client being nillable, this is an lsp utility function, it's not meant to be used outside the lsp subsystem (that applies to all lsp utilities). Generally everything in the lsp subsystem assumes you are working within the lsp subsystem. If you're using this function for something *not* involving an active client (I have not looked at your plugin), then we can discuss moving it out of the lsp system and making it a general utility function.",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/16277,749857288,2021-11-16T02:43:12Z,runtime/lua/vim/lsp.lua,"@@ -358,16 +362,47 @@ do     end   end -  function changetracking.prepare(bufnr, firstline, lastline, new_lastline, changedtick)+  function changetracking.prepare(bufnr, firstline, old_lastline, new_lastline, changedtick)     local incremental_changes = function(client)-      local cached_buffers = state_by_client[client.id].buffers-      local curr_lines = nvim_buf_get_lines(bufnr, 0, -1, true)-      local line_ending = format_line_ending[vim.api.nvim_buf_get_option(0, 'fileformat')]+      local state = state_by_client[client.id]+      local prev_lines = state.buffers[bufnr]+      -- See the comment below for why the curr_lines table is pulled out of buffers_tmp+      -- instead of making a brand new table.+      local curr_lines = state.buffers_tmp[bufnr]++      local changed_lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      for i = 1, firstline do+        curr_lines[i] = prev_lines[i]+      end+      for i = firstline + 1, new_lastline do+        curr_lines[i] = changed_lines[i - firstline]+      end+      for i = old_lastline + 1, #prev_lines do+        curr_lines[i - old_lastline + new_lastline] = prev_lines[i]+      end+      if tbl_isempty(curr_lines) then+        -- Can happen when deleting the entire contents of a buffer, see https://github.com/neovim/neovim/issues/16259.+        curr_lines[1] = ''+      end++      local line_ending = buf_get_line_ending(bufnr)       local incremental_change = sync.compute_diff(-        cached_buffers[bufnr], curr_lines, firstline, lastline, new_lastline, client.offset_encoding or 'utf-16', line_ending or '\n')-      cached_buffers[bufnr] = curr_lines+        prev_lines, curr_lines, firstline, old_lastline, new_lastline, client.offset_encoding or 'utf-16', line_ending)++      -- Double-buffering of lines tables is used to reduce the load on the garbage collector.+      -- At this point the prev_lines table is useless, but its internal storage has already been allocated,+      -- so let's keep it around for the next didChange event, in which it will become the next+      -- curr_lines table. Note that setting elements to nil doesn't actually deallocate slots in the+      -- internal storage - it merely marks them as free, for the GC to deallocate them.+      for i = #prev_lines, 1, -1 do","Not sure if mentioned anywhere, but if you can measure this for the large slowdowns and it provides a meaningful difference, then you can keep. But otherwise, I think it obscures what is happening. I find it unlikely it will provide any meaningful difference (but it's possible I suppose)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16103,750903504,2021-11-17T05:59:16Z,runtime/lua/vim/lsp/tagfunc.lua,"@@ -0,0 +1,69 @@+local M = {}+local lsp = vim.lsp++local function mk_tag_item(name, range, uri)+  local start = range.start+  return {+    name = name,+    filename = vim.uri_to_fname(uri),+    cmd = string.format(+      'call cursor(%d, %d)', start.line + 1, start.character + 1","Sorry, slightly out of my comfort zone with the vim incantations hah. The search pattern looks fine based on my reading, but I have no idea if this is slower/if this causes any issues. cc @mfussenegger /@gpanders",
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/14540,751864326,2021-11-18T02:44:55Z,src/nvim/testdir/test_arglist.vim,"@@ -26,6 +30,8 @@ func Test_argidx() endfunc  func Test_argadd()+  call Reset_arglist()",```  From test_command_count.vim:  Found errors in Test_command_count_2():  function RunTheTest[37]..Test_command_count_2 line 9: Expected 'a' but got ''```I think arglist reset is needed.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16357,752506924,2021-11-18T18:17:44Z,runtime/lua/vim/diagnostic.lua,"@@ -1545,7 +1545,7 @@ function M.fromqflist(list)   for _, item in ipairs(list) do     if item.valid == 1 then       local lnum = math.max(0, item.lnum - 1)-      local col = item.col > 0 and (item.col - 1) or nil+      local col = item.col       local end_lnum = item.end_lnum > 0 and (item.end_lnum - 1) or lnum       local end_col = item.end_col > 0 and (item.end_col - 1) or col","Hmm, I don't think so. If the qflist item doesn't contain an `end_col` then we just use the value of `col`, which would just be zero if `col` is also missing. What are you suggesting we change it to?",
8740057,janlazo,https://api.github.com/repos/neovim/neovim/pulls/16270,752832706,2021-11-19T03:11:38Z,src/nvim/testdir/test_highlight.vim,"@@ -761,4 +761,137 @@ func Test_highlight_default_colorscheme_restores_links()   hi clear endfunc +"" Test for the hlget() function+func Test_hlget()+  call assert_notequal([], filter(hlget(), 'v:val.name == ""Visual""'))+  call assert_equal([], hlget('SomeHLGroup'))+  highlight MyHLGroup cterm=reverse ctermfg=10 ctermbg=Black+  call assert_equal([{'id': hlID('MyHLGroup'), 'ctermfg': '10', 'name': 'MyHLGroup', 'ctermbg': '0', 'cterm': {'reverse': v:true}}], hlget('MyHLGroup'))+  highlight clear MyHLGroup+  call assert_equal(v:true, hlget('MyHLGroup')[0].cleared)+  highlight link MyHLGroup IncSearch+  call assert_equal('IncSearch', hlget('MyHLGroup')[0].linksto)+  highlight clear MyHLGroup+  "" call assert_equal([], hlget(v:null))+  call assert_equal([], hlget(""""))++"" Test for resolving highlight group links+  highlight hlgA cterm=bold+  let hlgAid = hlID('hlgA')+  highlight link hlgB hlgA+  let hlgBid = hlID('hlgB')+  highlight link hlgC hlgB+  let hlgCid = hlID('hlgC')+  call assert_equal('hlgA', hlget('hlgB')[0].linksto)+  call assert_equal('hlgB', hlget('hlgC')[0].linksto)+  call assert_equal([{'id': hlgAid, 'name': 'hlgA',+                    \ 'cterm': {'bold': v:true}}], hlget('hlgA'))+  call assert_equal([{'id': hlgBid, 'name': 'hlgB',+                    \ 'linksto': 'hlgA'}], hlget('hlgB'))+  call assert_equal([{'id': hlgCid, 'name': 'hlgC',+                    \ 'linksto': 'hlgB'}], hlget('hlgC'))+  call assert_equal([{'id': hlgAid, 'name': 'hlgA',+                    \ 'cterm': {'bold': v:true}}], hlget('hlgA', v:false))+  call assert_equal([{'id': hlgBid, 'name': 'hlgB',+                    \ 'linksto': 'hlgA'}], hlget('hlgB', 0))+  call assert_equal([{'id': hlgCid, 'name': 'hlgC',+                    \ 'linksto': 'hlgB'}], hlget('hlgC', v:false))+  call assert_equal([{'id': hlgAid, 'name': 'hlgA',+                    \ 'cterm': {'bold': v:true}}], hlget('hlgA', v:true))+  call assert_equal([{'id': hlgBid, 'name': 'hlgB',+                    \ 'cterm': {'bold': v:true}}], hlget('hlgB', 1))+  call assert_equal([{'id': hlgCid, 'name': 'hlgC',+                    \ 'cterm': {'bold': v:true}}], hlget('hlgC', v:true))++  call assert_fails('call hlget([])', 'E1174:')+  call assert_fails('call hlget(""abc"", ""xyz"")', 'E1212:')+endfunc++"" Test for the hlset() function+func Test_hlset()+  "" call assert_equal(0, hlset(v:null))",`v:_null_list`,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16270,752844062,2021-11-19T03:49:58Z,src/nvim/syntax.c,"@@ -8754,6 +8755,391 @@ RgbValue name_to_color(const char *name) }  -/**************************************-*  End of Highlighting stuff          *-**************************************/++// Convert each of the highlight attribute bits (bold, standout, underline,+// etc.) set in 'hlattr' into a separate boolean item in a Dictionary with+// the attribute name as the key.+static dict_T * highlight_get_attr_dict(int hlattr)+{+  dict_T      *dict;+  int         i;++  dict = tv_dict_alloc();+  if (dict == NULL) {+    return NULL;+  }++  for (i = 0; hl_attr_table[i] != 0; i++) {+    if (hlattr & hl_attr_table[i]) {+      tv_dict_add_bool(dict, hl_name_table[i], strlen(hl_name_table[i]), kBoolVarTrue);+      hlattr &= ~hl_attr_table[i];        // don't want ""inverse""+    }+  }++  return dict;+}+++// Return the attributes of the highlight group at index 'hl_idx' as a+// Dictionary. If 'resolve_link' is true, then resolves the highlight group+// links recursively.+static dict_T * highlight_get_info(int hl_idx, bool resolve_link)+{+  dict_T      *dict;+  HlGroup     *sgp;+  dict_T      *attr_dict;+  int         hlgid;++  dict = tv_dict_alloc();+  if (dict == NULL) {+    return dict;+  }++  sgp = &HL_TABLE()[hl_idx];+  // highlight group id is 1-based+  hlgid = hl_idx + 1;++  if (tv_dict_add_str(dict, S_LEN(""name""), (const char *)sgp->sg_name) == FAIL) {+    goto error;+  }+  if (tv_dict_add_nr(dict, S_LEN(""id""), hlgid) == FAIL) {+    goto error;+  }++  if (sgp->sg_link && resolve_link) {+    // resolve the highlight group link recursively+    while (sgp->sg_link) {+      hlgid = sgp->sg_link;+      sgp = &HL_TABLE()[sgp->sg_link - 1];+    }+  }++  if (sgp->sg_cterm != 0) {+    attr_dict = highlight_get_attr_dict(sgp->sg_cterm);+    if (attr_dict != NULL) {+      if (tv_dict_add_dict(dict, S_LEN(""cterm""), attr_dict) == FAIL) {+        goto error;+      }+    }+  }+  if (sgp->sg_cterm_fg != 0) {+    if (tv_dict_add_str(dict, S_LEN(""ctermfg""),+                        highlight_color(hlgid, (const char *)""fg"", 'c')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_cterm_bg != 0) {+    if (tv_dict_add_str(dict, S_LEN(""ctermbg""),+                        highlight_color(hlgid, (const char *)""bg"", 'c')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_gui != 0) {+    attr_dict = highlight_get_attr_dict(sgp->sg_gui);+    if (attr_dict != NULL) {+      if (tv_dict_add_dict(dict, S_LEN(""gui""), attr_dict) == FAIL) {+        goto error;+      }+    }+  }+  if (sgp->sg_rgb_fg_name != NULL) {+    if (tv_dict_add_str(dict, S_LEN(""guifg""),+                        highlight_color(hlgid, (const char *)""fg"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_rgb_bg_name != NULL) {+    if (tv_dict_add_str(dict, S_LEN(""guibg""),+                        highlight_color(hlgid, (const char *)""bg"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_rgb_sp_name != NULL) {+    if (tv_dict_add_str(dict, S_LEN(""guisp""),+                        highlight_color(hlgid, (const char *)""sp"", 'g')) == FAIL) {+      goto error;+    }+  }+  if (sgp->sg_link) {+    char_u  *link;+    link = HL_TABLE()[sgp->sg_link - 1].sg_name;+    if (link != NULL && tv_dict_add_str(dict, S_LEN(""linksto""), (char *)link) == FAIL) {+      goto error;+    }+  }+  if (dict->dv_hashtab.ht_used == 2) {+    // If only 'name' is present, then the highlight group is cleared.+    tv_dict_add_bool(dict, S_LEN(""cleared""), kBoolVarTrue);+  }++  return dict;++error:+  xfree(dict);+  return NULL;+}++// ""hlget([name])"" function+// Return the attributes of a specific highlight group (if specified) or all+// the highlight groups.+void f_hlget(typval_T *argvars, typval_T *rettv, FunPtr fptr)+{+  list_T      *list;+  dict_T      *dict;+  int         i;+  const char  *hlarg = NULL;+  bool                resolve_link = false;++  tv_list_alloc_ret(rettv, kListLenMayKnow);++  if (argvars[0].v_type != VAR_UNKNOWN) {",May be <https://github.com/vim/vim/commit/83494b4ac61898f687d6ef9dce4bad5802fb8e51>,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16370,753432552,2021-11-19T18:39:47Z,runtime/lua/vim/diagnostic.lua,"@@ -399,17 +397,56 @@ local function set_list(loclist, opts) end  ---@private---- To (slightly) improve performance, modifies diagnostics in place.-local function clamp_line_numbers(bufnr, diagnostics)-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)-  if buf_line_count == 0 then-    return+local function get_diagnostics(bufnr, opts, clamp)",Assuming for qflist we only need to clamp line number and not col number?,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16370,753435926,2021-11-19T18:45:23Z,runtime/lua/vim/diagnostic.lua,"@@ -399,17 +397,56 @@ local function set_list(loclist, opts) end  ---@private---- To (slightly) improve performance, modifies diagnostics in place.-local function clamp_line_numbers(bufnr, diagnostics)-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)-  if buf_line_count == 0 then-    return+local function get_diagnostics(bufnr, opts, clamp)","We're not doing any clamping for qflist right now (though maybe we should). The only things that go through this code path are the navigation methods, `open_float()`, and `show()`.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16370,753437587,2021-11-19T18:48:12Z,runtime/lua/vim/diagnostic.lua,"@@ -399,17 +397,56 @@ local function set_list(loclist, opts) end  ---@private---- To (slightly) improve performance, modifies diagnostics in place.-local function clamp_line_numbers(bufnr, diagnostics)-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)-  if buf_line_count == 0 then-    return+local function get_diagnostics(bufnr, opts, clamp)",I thought the call chain was:set_qflist -> set_list -> M.get -> get_diagnostics with clamp == false,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16370,753437784,2021-11-19T18:48:36Z,runtime/lua/vim/diagnostic.lua,"@@ -399,17 +397,56 @@ local function set_list(loclist, opts) end  ---@private---- To (slightly) improve performance, modifies diagnostics in place.-local function clamp_line_numbers(bufnr, diagnostics)-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)-  if buf_line_count == 0 then-    return+local function get_diagnostics(bufnr, opts, clamp)","Ah sorry, I misunderstood your comment. I think we probably should clamp for qflist as well.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16369,753543208,2021-11-19T21:29:04Z,runtime/lua/vim/lsp.lua,"@@ -805,11 +806,26 @@ function lsp.start_client(config)     }     local version = vim.version() -    if config.root_dir and not config.workspace_folders then-      config.workspace_folders = {{-        uri = vim.uri_from_fname(config.root_dir);-        name = string.format(""%s"", config.root_dir);-      }};+    local workspace_folders+    local root_uri+    local root_path+    if config.workspace_folders or config.root_dir then+      -- Legacy compatibility, will be removed in neovim 0.7+      if config.root_dir and not config.workspace_folders then+        vim.notify(""Calling start_client with root_dir is deprecated in nvim 0.6 and will be removed in 0.7, please see `:help start_client`"", vim.log.levels.WARN)","```suggestion        vim.notify(""Calling start_client with root_dir is deprecated and will be removed in 0.7, use workspace_folders instead, see `:help start_client`"", vim.log.levels.WARN)```I think giving a hint about what to do can't hurt",
15367354,dmitmel,https://api.github.com/repos/neovim/neovim/pulls/16277,753677226,2021-11-20T13:50:59Z,runtime/lua/vim/lsp.lua,"@@ -358,16 +362,47 @@ do     end   end -  function changetracking.prepare(bufnr, firstline, lastline, new_lastline, changedtick)+  function changetracking.prepare(bufnr, firstline, old_lastline, new_lastline, changedtick)     local incremental_changes = function(client)-      local cached_buffers = state_by_client[client.id].buffers-      local curr_lines = nvim_buf_get_lines(bufnr, 0, -1, true)-      local line_ending = format_line_ending[vim.api.nvim_buf_get_option(0, 'fileformat')]+      local state = state_by_client[client.id]+      local prev_lines = state.buffers[bufnr]+      -- See the comment below for why the curr_lines table is pulled out of buffers_tmp+      -- instead of making a brand new table.+      local curr_lines = state.buffers_tmp[bufnr]++      local changed_lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      for i = 1, firstline do+        curr_lines[i] = prev_lines[i]+      end+      for i = firstline + 1, new_lastline do+        curr_lines[i] = changed_lines[i - firstline]+      end+      for i = old_lastline + 1, #prev_lines do+        curr_lines[i - old_lastline + new_lastline] = prev_lines[i]+      end+      if tbl_isempty(curr_lines) then+        -- Can happen when deleting the entire contents of a buffer, see https://github.com/neovim/neovim/issues/16259.+        curr_lines[1] = ''+      end++      local line_ending = buf_get_line_ending(bufnr)       local incremental_change = sync.compute_diff(-        cached_buffers[bufnr], curr_lines, firstline, lastline, new_lastline, client.offset_encoding or 'utf-16', line_ending or '\n')-      cached_buffers[bufnr] = curr_lines+        prev_lines, curr_lines, firstline, old_lastline, new_lastline, client.offset_encoding or 'utf-16', line_ending)++      -- Double-buffering of lines tables is used to reduce the load on the garbage collector.+      -- At this point the prev_lines table is useless, but its internal storage has already been allocated,+      -- so let's keep it around for the next didChange event, in which it will become the next+      -- curr_lines table. Note that setting elements to nil doesn't actually deallocate slots in the+      -- internal storage - it merely marks them as free, for the GC to deallocate them.+      for i = #prev_lines, 1, -1 do","Alright, let's compare the table clearing loop using ipairs vs the current implementation with a counter.```diffdiff --git a/runtime/lua/vim/lsp.lua b/runtime/lua/vim/lsp.luaindex 9eaa41e75..5d6bf6eb5 100644--- a/runtime/lua/vim/lsp.lua+++ b/runtime/lua/vim/lsp.lua@@ -389,7 +389,7 @@ do       -- so let's keep it around for the next didChange event, in which it will become the next       -- curr_lines table. Note that setting elements to nil doesn't actually deallocate slots in the       -- internal storage - it merely marks them as free, for the GC to deallocate them.-      for i = #prev_lines, 1, -1 do+      for i in ipairs(prev_lines) do         prev_lines[i] = nil       end       state.buffers[bufnr] = curr_lines```<details><summary>Benchmarking method</summary>The benchmark is almost the same as I have described in the commit message, with the exception that I increased the number of runs to 40 and swapped vim-commentary for `call setline(1, getline(1, '$'))` - as I had explained [here](https://github.com/neovim/neovim/pull/16277#issuecomment-968105798), it exhibits the exact same problem, but removes the Vimscript interpreter from the equation, thus I need to wait less for the benchmark to complete.```vimset rtp+=~/.config/nvim/plugged/nvim-lspconfiglua require('lspconfig')['ccls'].setup({})function! Benchmark(tries) abort  let results_comment = []  let results_undo = []  for i in range(a:tries)    echo printf('run %d', i+1)    let begin = reltime()    call setline(1, getline(1, '$'))    call add(results_comment, reltimefloat(reltime(begin)))    let begin = reltime()    silent! undo    call add(results_undo, reltimefloat(reltime(begin)))    redraw  endfor  let avg_comment = 0.0  let avg_undo = 0.0  for i in range(a:tries)    echomsg printf('run %3d: setline=%fs undo=%fs', i+1, results_comment[i], results_undo[i])    let avg_comment += results_comment[i]    let avg_undo += results_undo[i]  endfor  echomsg printf('average: setline=%fs undo=%fs', avg_comment / a:tries, avg_undo / a:tries)endfunctioncommand! -bar Benchmark call Benchmark(40)```I have performed tests on both Lua5.1 and LuaJIT. I built nvim with LuaJIT as explained in the commit (`make CMAKE_BUILD_TYPE=Release`), and with Lua5.1 like this:```shmake CMAKE_BUILD_TYPE=Release CMAKE_EXTRA_FLAGS='-DPREFER_LUA=ON' DEPS_CMAKE_FLAGS='-DUSE_BUNDLED_LUA=ON -DUSE_BUNDLED_LUAJIT=OFF'```Then opened the file `src/nvim/lua/executor.c` in the nvim source tree and ran `:Benchmark`.</details>Here are the results:| Lua version | table clearing loop | setline time | undo time || ----------- | ------------------- | ------------ | --------- || Lua5.1      | with ipairs         | 0.276445s    | 0.270881s || Lua5.1      | with a counter      | 0.190557s    | 0.185333s || LuaJIT      | with ipairs         | 0.047433s    | 0.042246s || LuaJIT      | with a counter      | 0.047436s    | 0.042917s |Notice that on LuaJIT the difference is next to none, as the microbenchmark I've linked in a comment above suggests.",
14950617,rish987,https://api.github.com/repos/neovim/neovim/pulls/16382,753734707,2021-11-21T01:39:01Z,runtime/lua/vim/lsp/sync.lua,"@@ -59,31 +58,14 @@ local function byte_to_utf(line, byte, offset_encoding)   -- convert to 0 based indexing for str_utfindex   byte = byte - 1 -  local utf_idx-  local _-  -- Convert the byte range to utf-{8,16,32} and convert 1-based (lua) indexing to 0-based-  if offset_encoding == 'utf-16' then-    _, utf_idx = str_utfindex(line, byte)-  elseif offset_encoding == 'utf-32' then-    utf_idx, _ = str_utfindex(line, byte)-  else-    utf_idx = byte-  end+  local utf_idx = vim.lsp.util.str_utfindex(line, byte, offset_encoding)    -- convert to 1 based indexing   return utf_idx + 1 end  local function compute_line_length(line, offset_encoding)-  local length-  local _-  if offset_encoding == 'utf-16' then-     _, length = str_utfindex(line)-  elseif offset_encoding == 'utf-32' then-    length, _ = str_utfindex(line)-  else-    length = #line-  end+  local length = vim.lsp.util.str_utfindex(line, nil, offset_encoding)",> I would strongly prefer not eliding built-in API functions.I just don't think that we have a good alternative here yet if we want to avoid repeating this conditional block throughout the code.,
14950617,rish987,https://api.github.com/repos/neovim/neovim/pulls/16382,753737666,2021-11-21T02:26:36Z,runtime/lua/vim/lsp/util.lua,"@@ -150,8 +188,9 @@ end ---@private --- Position is a https://microsoft.github.io/language-server-protocol/specifications/specification-current/#position --- Returns a zero-indexed column, since set_lines() does the conversion to+---@param encoding string utf-8|utf-16|utf-32|nil defaults to utf-16 --- 1-indexed-local function get_line_byte_from_position(bufnr, position, offset_encoding)+local function get_line_byte_from_position(bufnr, position, encoding)",Hmm yeah so this was a result of a search and replace so it's unlikely that here in particular it would be anything other than an offset encoding. I could go through and make these parameter names more specific if you like.,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16382,753737813,2021-11-21T02:28:47Z,runtime/lua/vim/lsp/util.lua,"@@ -150,8 +188,9 @@ end ---@private --- Position is a https://microsoft.github.io/language-server-protocol/specifications/specification-current/#position --- Returns a zero-indexed column, since set_lines() does the conversion to+---@param encoding string utf-8|utf-16|utf-32|nil defaults to utf-16 --- 1-indexed-local function get_line_byte_from_position(bufnr, position, offset_encoding)+local function get_line_byte_from_position(bufnr, position, encoding)","I just, in general, would prefer we keep renaming/refactoring to a minimum if it's not on the direct path to addressing the bug, and also try to preserve naming conventions from other parts of the codebase.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16382,753738564,2021-11-21T02:41:31Z,runtime/lua/vim/lsp.lua,"@@ -1301,7 +1302,8 @@ nvim_command(""autocmd VimLeavePre * lua vim.lsp._vim_exit_handler()"") --- ---@param bufnr (number) Buffer handle, or 0 for current. ---@param method (string) LSP method name----@param params (optional, table) Parameters to send to the server+---@param params (optional, table | funtion number -> table) Parameters to send to the server, or a function","I think if it was something like a utility function that set up the params (and then dispatched) each request with the appropriate positional params (where params was still of the old type), that would work. Generally I want to avoid introducing more middleware like buf_request/new types of requests like pos_request.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16383,753743040,2021-11-21T03:49:49Z,src/nvim/message.c,"@@ -3064,14 +3072,19 @@ int msg_end(void)  void msg_ext_ui_flush(void) {-  if (!ui_has(kUIMessages)) {+  if (!msg_enable_ext()) {     return;   }    msg_ext_emit_chunk();   if (msg_ext_chunks.size > 0) {-    ui_call_msg_show(cstr_to_string(msg_ext_kind),-                     msg_ext_chunks, msg_ext_overwrite);+    if (ui_has(kUIMessages)) {+      ui_call_msg_show(cstr_to_string(msg_ext_kind),+                       msg_ext_chunks, msg_ext_overwrite);+    } else {+      msg_call_msgfunc(""msg_show"", &msg_ext_chunks);","`ui_call_msg_show()` calls `ui_event()`, which frees the allocated chunk here:<https://github.com/neovim/neovim/blob/120a88163078e61b272e9629138642bc5df80e4a/src/nvim/ui.c#L180-L182>So the allocated chunk should also need freeing in or after `msg_call_msgfunc()`.",
24480985,VVKot,https://api.github.com/repos/neovim/neovim/pulls/16386,753765209,2021-11-21T08:26:04Z,src/nvim/main.c,"@@ -677,7 +677,7 @@ void getout(int exitval)   if (did_emsg) {     // give the user a chance to read the (error) message     no_wait_return = FALSE;-    wait_return(FALSE);+//  wait_return(FALSE);",Don't think this was an intentional change - it is still present in the Vim though. Figured I'll port it?https://github.com/vim/vim/blob/87fd0924e2d85213cc111ee7a5122f92216a37c7/src/main.c#L1664,
59243201,ii14,https://api.github.com/repos/neovim/neovim/pulls/16387,753801116,2021-11-21T13:33:57Z,src/nvim/eval/funcs.c,"@@ -3386,15 +3386,17 @@ static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)     emsg(_(e_invarg));     return;   }+  const char *pattern = tv_get_string(&argvars[0]);","For what it's worth, const is already casted away in `xpc.xp_pattern = (char_u *)pat;`, line 3399.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16382,753835591,2021-11-21T18:13:39Z,runtime/lua/vim/lsp/util.lua,"@@ -1638,29 +1672,33 @@ function M.try_trim_markdown_code_blocks(lines)   return 'markdown' end -local str_utfindex = vim.str_utfindex ---@private-local function make_position_param()-  local row, col = unpack(api.nvim_win_get_cursor(0))+---@param window (optional, number): window handle or 0 for current, defaults to current+---@param encoding string utf-8|utf-16|utf-32|nil defaults to utf-16+local function make_position_param(window, encoding)+  window = window or 0","Shouldn't this be ""buffer"" (semantically speaking) since the encodings are per buffer not per window?",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16382,753837875,2021-11-21T18:35:17Z,runtime/lua/vim/lsp/util.lua,"@@ -90,6 +90,44 @@ local function split_lines(value)   return split(value, '\n', true) end +---Alternative to vim.str_utfindex that takes an encoding.+---@param line string line to be indexed+---@param index number byte index (utf-8)+---@param encoding string utf-8|utf-16|utf-32|nil defaults to utf-16+---@return number `encoding` index of `index` in `line`+function M.str_utfindex(line, index, encoding)+  if encoding ~= protocol.Encodings.UTF8 then+    local col32, col16+    if index then+      col32, col16 = vim.str_utfindex(line, index)+    else+      col32, col16 = vim.str_utfindex(line)+    end+    if encoding == protocol.Encodings.UTF32 then+      return col32+    else+      return col16+    end+  else+    return index+  end+end++---Alternative to vim.str_byteindex that takes an encoding.+---@param line string line to be indexed+---@param index number UTF index+---@param encoding string utf-8|utf-16|utf-32|nil defaults to utf-16+---@return number byte (utf-8) index of `encoding` index `index` in `line`+function M.str_byteindex(line, index, encoding)+  if encoding ~= protocol.Encodings.UTF8 then+    return vim.str_byteindex(line, index, not encoding or encoding ~= protocol.Encodings.UTF32)+  else+    return index+  end+end++local str_utfindex, str_byteindex = M.str_utfindex, M.str_byteindex",We already have `character_offset` and `get_line_byte_from_position` which are lsp specific.If we count the `vim.` functions we'd have a total of 6 functions for the conversions. Do we really need all of these? The overlapping naming makes it also kinda confusing and easy to mix them up,
46855713,smolck,https://api.github.com/repos/neovim/neovim/pulls/16397,753852784,2021-11-21T20:52:57Z,runtime/lua/vim/diagnostic.lua,"@@ -60,7 +60,24 @@ local bufnr_and_namespace_cacher_mt = { }  local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)-local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, {+  __index = function(t, bufnr)","So this is weird; you'd think `__newindex` would be the way to go here, but it never seems to be called, either here or with `bufnr_and_namespace_cacher_mt`. Maybe `__index` doing the `rawset(t, bufnr, {})` part has something to do with it? Not sure, but it seems weird.Also this `__index` is basically exactly the same as the one in `bufnr_and_namespace_cacher_mt`, any thoughts on reducing the repetition here, or is it not that big of a deal?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16397,753869685,2021-11-21T23:15:08Z,runtime/lua/vim/diagnostic.lua,"@@ -59,8 +59,22 @@ local bufnr_and_namespace_cacher_mt = {   end, } -local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)-local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)+local diagnostic_cache = setmetatable({}, {+  __index = function(t, bufnr)+    if not bufnr or bufnr == 0 then","Is it even possible for `bufnr` to be nil here? If not, let���s remove the useless `not bufnr` check",
15367354,dmitmel,https://api.github.com/repos/neovim/neovim/pulls/16277,754112855,2021-11-22T09:58:58Z,runtime/lua/vim/lsp.lua,"@@ -358,16 +362,47 @@ do     end   end -  function changetracking.prepare(bufnr, firstline, lastline, new_lastline, changedtick)+  function changetracking.prepare(bufnr, firstline, old_lastline, new_lastline, changedtick)     local incremental_changes = function(client)-      local cached_buffers = state_by_client[client.id].buffers-      local curr_lines = nvim_buf_get_lines(bufnr, 0, -1, true)-      local line_ending = format_line_ending[vim.api.nvim_buf_get_option(0, 'fileformat')]+      local state = state_by_client[client.id]+      local prev_lines = state.buffers[bufnr]+      -- See the comment below for why the curr_lines table is pulled out of buffers_tmp+      -- instead of making a brand new table.+      local curr_lines = state.buffers_tmp[bufnr]++      local changed_lines = nvim_buf_get_lines(bufnr, firstline, new_lastline, true)+      for i = 1, firstline do+        curr_lines[i] = prev_lines[i]+      end+      for i = firstline + 1, new_lastline do+        curr_lines[i] = changed_lines[i - firstline]+      end+      for i = old_lastline + 1, #prev_lines do+        curr_lines[i - old_lastline + new_lastline] = prev_lines[i]+      end+      if tbl_isempty(curr_lines) then+        -- Can happen when deleting the entire contents of a buffer, see https://github.com/neovim/neovim/issues/16259.+        curr_lines[1] = ''+      end++      local line_ending = buf_get_line_ending(bufnr)       local incremental_change = sync.compute_diff(-        cached_buffers[bufnr], curr_lines, firstline, lastline, new_lastline, client.offset_encoding or 'utf-16', line_ending or '\n')-      cached_buffers[bufnr] = curr_lines+        prev_lines, curr_lines, firstline, old_lastline, new_lastline, client.offset_encoding or 'utf-16', line_ending)++      -- Double-buffering of lines tables is used to reduce the load on the garbage collector.+      -- At this point the prev_lines table is useless, but its internal storage has already been allocated,+      -- so let's keep it around for the next didChange event, in which it will become the next+      -- curr_lines table. Note that setting elements to nil doesn't actually deallocate slots in the+      -- internal storage - it merely marks them as free, for the GC to deallocate them.+      for i = #prev_lines, 1, -1 do","The conclusion we have reached in the Matrix room is that if you are using Lua5.1 builds you are a priori not interested in performance. I have also measured the difference on LuaJIT 2.0.5 (as opposed to the beta version Nvim downloads) to be ~2% faster with a counter, which is negligible IMO. (Then again I am surprised that this loop is such a big deal.)",
15367354,dmitmel,https://api.github.com/repos/neovim/neovim/pulls/16431,756690901,2021-11-25T09:01:15Z,runtime/lua/vim/lsp.lua,"@@ -402,27 +402,36 @@ do       if state.use_incremental_sync then         -- This must be done immediately and cannot be delayed         -- The contents would further change and startline/endline may no longer fit-        table.insert(state.pending_changes, incremental_changes(client))+        if not state.pending_changes[uri] then","No, changedtick is used for the `version` parameter and is buffer-local",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16431,756726160,2021-11-25T09:44:54Z,runtime/lua/vim/lsp.lua,"@@ -402,27 +402,36 @@ do       if state.use_incremental_sync then         -- This must be done immediately and cannot be delayed         -- The contents would further change and startline/endline may no longer fit-        table.insert(state.pending_changes, incremental_changes(client))+        if not state.pending_changes[uri] then",Can you also update the comment here: https://github.com/neovim/neovim/blob/b5b025f6a3ad406929c096f63b5f1e7649d3c818/runtime/lua/vim/lsp.lua#L323,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16431,756730667,2021-11-25T09:50:25Z,runtime/lua/vim/lsp.lua,"@@ -1159,6 +1168,7 @@ function lsp.buf_attach_client(bufnr, client_id)       on_reload = function()         local params = { textDocument = { uri = uri; } }         for_each_buffer_client(bufnr, function(client, _)+          changetracking.reset_buf(client, bufnr)",I'm aware that notify doesn't flush. It can't flush as long as the debounce itself calls `client.notify` to do the debouncing.My question is whether this here should be calling flush instead of reset_buf.,
15367354,dmitmel,https://api.github.com/repos/neovim/neovim/pulls/16431,756733827,2021-11-25T09:54:13Z,runtime/lua/vim/lsp.lua,"@@ -1159,6 +1168,7 @@ function lsp.buf_attach_client(bufnr, client_id)       on_reload = function()         local params = { textDocument = { uri = uri; } }         for_each_buffer_client(bufnr, function(client, _)+          changetracking.reset_buf(client, bufnr)","Well, currently calling `flush` makes more sense because `reset_buf` currently doesn't delete the entry in `pending_changes` for the buffer, but that is beside the point. The thing is that we are sending new buffer contents immediately afterwards, and with the pending didChange events meant to be applied to the version of the buffer before reload, they are basically useless because their results will be discarded as soon as the client processes didOpen. Thus I think that it is better to throw them away.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16431,756842529,2021-11-25T12:21:11Z,runtime/lua/vim/lsp.lua,"@@ -402,27 +402,36 @@ do       if state.use_incremental_sync then         -- This must be done immediately and cannot be delayed         -- The contents would further change and startline/endline may no longer fit-        table.insert(state.pending_changes, incremental_changes(client))+        if not state.pending_changes[uri] then","> No, changedtick is used for the version parameter and is buffer-localThis isn't relevant, because URI is effectively bufnr in this case.> Also when debounce is off didChange is effectively sent per-buffer and not per-URII don't see the issue with this",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16431,756846686,2021-11-25T12:27:12Z,runtime/lua/vim/lsp.lua,"@@ -1159,6 +1168,7 @@ function lsp.buf_attach_client(bufnr, client_id)       on_reload = function()         local params = { textDocument = { uri = uri; } }         for_each_buffer_client(bufnr, function(client, _)+          changetracking.reset_buf(client, bufnr)",There's no point to flushing as we send the full document here https://github.com/mjlbach/neovim/blob/988fd1d825c99e6212f25c10236eda528a89dda1/runtime/lua/vim/lsp.lua#L478-L486I'll modify reset_buf to flush pending changes (I thought we overwriting state entirely in change_tracking.init),
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/16430,756852325,2021-11-25T12:35:51Z,runtime/lua/vim/lsp/rpc.lua,"@@ -325,7 +323,14 @@ local function start(cmd, cmd_args, dispatchers, extra_spawn_params)     end     handle, pid = uv.spawn(cmd, spawn_params, onexit)     if handle == nil then-      error(string.format(""start `%s` failed: %s"", cmd, pid))+      local msg = string.format(""Spawning language server with cmd: `%s` failed"", cmd)",Seems more clear for not that technical users (and not gamers :D). No big deal feel free to ignore.,
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/16435,757003529,2021-11-25T15:54:49Z,runtime/lua/vim/shared.lua,"@@ -12,7 +12,7 @@ local vim = vim or {} --- same functions as those in the input table. Userdata and threads are not --- copied and will throw an error. -------@param orig Table to copy+---@param orig table to copy",Technically deepcopy isn't just for `table`. It works on everything but `cdata` & `coroutine` I think.See if https://github.com/neovim/neovim/pull/16435/commits/22583c45377ce0a39e8e019958ab5b06e6aa9895 works ?,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16431,757142322,2021-11-25T22:14:49Z,runtime/lua/vim/lsp.lua,"@@ -1159,6 +1168,7 @@ function lsp.buf_attach_client(bufnr, client_id)       on_reload = function()         local params = { textDocument = { uri = uri; } }         for_each_buffer_client(bufnr, function(client, _)+          changetracking.reset_buf(client, bufnr)","I think `debounce` should only debounce - not additionally optimize away change sets, even if they're most likely unnecessary. I'm pretty sure the optimization wouldn't have any practical impact.And I think keeping the semantics of debounce on/off close to each other helps reasoning about potential issues or with trouble shooting. Both should result in the same set of changes getting eventually reported to the server (although in a different format due the batching)",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16422,757377806,2021-11-26T10:10:24Z,runtime/lua/vim/shared.lua,"@@ -104,13 +104,13 @@ end --- ---@see |vim.gsplit()| -------@param s String to split----@param sep Separator string or pattern----@param kwargs Keyword arguments:+---@param s string String to split+---@param sep string Separator string or pattern+---@param kwargs table|boolean Keyword arguments:",```suggestion---@param kwargs table Keyword arguments:````boolean` is only supported for BWC. I wouldn't keep promoting that in the docs. Otherwise we'd also have to document the behavior of the boolean parameter ( that it sets `plain`),
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16382,757713407,2021-11-26T22:58:46Z,runtime/lua/vim/lsp/util.lua,"@@ -323,8 +356,9 @@ end --- Applies a list of text edits to a buffer. ---@param text_edits table list of `TextEdit` objects ---@param bufnr number Buffer id+---@param offset_encoding string utf-8|utf-16|utf-32|nil defaults to utf-16 ---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textEdit-function M.apply_text_edits(text_edits, bufnr)+function M.apply_text_edits(text_edits, bufnr, offset_encoding)",Looks like there are several calls to this function which don't provide the `offset_encoding` parameter.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16382,757714359,2021-11-26T23:06:53Z,runtime/lua/vim/lsp/util.lua,"@@ -1722,10 +1783,11 @@ end  --- Creates a `TextDocumentIdentifier` object for the current buffer. ---+---@param bufnr (optional, number): Buffer handle, defaults to current ---@returns `TextDocumentIdentifier` ---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier-function M.make_text_document_params()-  return { uri = vim.uri_from_bufnr(0) }+function M.make_text_document_params(bufnr)","What do you think of using `win` as parameter here as well? I think the inconsistency could otherwise trip up users and lead to bugs.(I'd generally prefer using bufnr everywhere, but I saw that's not possible because of `make_position_param` needing to get the cursor position)",
14950617,rish987,https://api.github.com/repos/neovim/neovim/pulls/16382,757729400,2021-11-27T01:56:23Z,runtime/lua/vim/lsp/util.lua,"@@ -1635,41 +1667,69 @@ function M.try_trim_markdown_code_blocks(lines)   return 'markdown' end -local str_utfindex = vim.str_utfindex ---@private-local function make_position_param()-  local row, col = unpack(api.nvim_win_get_cursor(0))+---@param window (optional, number): window handle or 0 for current, defaults to current+---@param offset_encoding string utf-8|utf-16|utf-32|nil defaults to utf-16+local function make_position_param(window, offset_encoding)","This is a great idea, my only concern is that this makes things a bit opaque on the plugin side. That is, if you're persistently storing these parameters -- as we do for our ""pins"" in lean.nvim -- you don't know what encoding they came from. It would probably be okay to add the encoding as a second return value, right?",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16382,757731479,2021-11-27T02:25:04Z,runtime/lua/vim/lsp/util.lua,"@@ -90,6 +90,44 @@ local function split_lines(value)   return split(value, '\n', true) end +---Alternative to vim.str_utfindex that takes an encoding.+---@param line string line to be indexed+---@param index number byte index (utf-8)+---@param encoding string utf-8|utf-16|utf-32|nil defaults to utf-16+---@return number `encoding` index of `index` in `line`+function M._str_utfindex_enc(line, index, encoding)+  if encoding ~= 'utf-8' then+    local col32, col16+    if index then+      col32, col16 = vim.str_utfindex(line, index)+    else+      col32, col16 = vim.str_utfindex(line)+    end",could be changed but right now the bindings use gettop so the nil will still trigger the conditional https://github.com/mjlbach/neovim/blob/68e3fbec93185f3567f60933343c38bf9e4c14e1/src/nvim/lua/stdlib.c#L178-L182,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16382,757779567,2021-11-27T13:03:59Z,runtime/lua/vim/lsp/util.lua,"@@ -1722,10 +1783,11 @@ end  --- Creates a `TextDocumentIdentifier` object for the current buffer. ---+---@param bufnr (optional, number): Buffer handle, defaults to current ---@returns `TextDocumentIdentifier` ---@see https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier-function M.make_text_document_params()-  return { uri = vim.uri_from_bufnr(0) }+function M.make_text_document_params(bufnr)","> I see make_position_params as an inherently window-based method because it gets your position from the cursor, which is obviously tied to the window. This function not so much.I think this is leaking implementation details to some degree. E.g. if you think about how you'd explain the difference:""These functions generate parameters related to the document you're editing in the active window""vs.""These functions generate parameters for the document you're editing.  `make_x` takes a bufnr because it identifies the document, `make_y` takes winnr because it also needs the cursor position""(I should add that I'm not too opinionated on this.  It depends on how much weight we put on API coherence looking at the group of functions vs. evaluating the methods as  individual. Also fine to keep as it is)",X
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16361,757793506,2021-11-27T15:47:25Z,runtime/doc/diagnostic.txt,"@@ -373,39 +373,8 @@ config({opts}, {namespace})                          *vim.diagnostic.config()*                                      Otherwise, all signs use the same                                      priority. -                                 ��� float: Options for floating windows:-                                   ��� severity: See |diagnostic-severity|.-                                   ��� header: (string or table) String to use-                                     as the header for the floating window. If-                                     a table, it is interpreted as a [text,-                                     hl_group] tuple. Defaults to-                                     ""Diagnostics:"".-                                   ��� source: (string) Include the diagnostic-                                     source in the message. One of ""always"" or-                                     ""if_many"".-                                   ��� format: (function) A function that takes-                                     a diagnostic as input and returns a-                                     string. The return value is the text used-                                     to display the diagnostic.-                                   ��� prefix: (function, string, or table)-                                     Prefix each diagnostic in the floating-                                     window. If a function, it must have the-                                     signature (diagnostic, i, total) ->-                                     (string, string), where {i} is the index-                                     of the diagnostic being evaluated and-                                     {total} is the total number of-                                     diagnostics displayed in the window. The-                                     function should return a string which is-                                     prepended to each diagnostic in the-                                     window as well as an (optional) highlight-                                     group which will be used to highlight the-                                     prefix. If {prefix} is a table, it is-                                     interpreted as a [text, hl_group] tuple-                                     as in |nvim_echo()|; otherwise, if-                                     {prefix} is a string, it is prepended to-                                     each diagnostic in the window with no-                                     highlight.-+                                 ��� float: Options for floating windows. See",Is this correct/up-to-date? Seems like a big deletion,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16361,757793568,2021-11-27T15:47:56Z,runtime/doc/lsp.txt,"@@ -873,6 +877,11 @@ start_client({config})                                *vim.lsp.start_client()*                                            debounce occurs if nil                                          ��� exit_timeout (number, default 500):                                            Milliseconds to wait for server to+                                           exit cleanly after sending the","Same, big change",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16361,757793582,2021-11-27T15:48:19Z,runtime/lua/vim/diagnostic.lua,"@@ -570,33 +570,15 @@ end ---                * priority: (number, default 10) Base priority to use for signs. When ---                {severity_sort} is used, the priority of a sign is adjusted based on ---                its severity. Otherwise, all signs use the same priority.----       - float: Options for floating windows:----                  * severity: See |diagnostic-severity|.----                  * header: (string or table) String to use as the header for the floating----                            window. If a table, it is interpreted as a [text, hl_group] tuple.----                            Defaults to ""Diagnostics:"".----                  * source: (string) Include the diagnostic source in----                            the message. One of ""always"" or ""if_many"".----                  * format: (function) A function that takes a diagnostic as input and returns a----                            string. The return value is the text used to display the diagnostic.----                  * prefix: (function, string, or table) Prefix each diagnostic in the floating----                            window. If a function, it must have the signature (diagnostic, i,----                            total) -> (string, string), where {i} is the index of the diagnostic----                            being evaluated and {total} is the total number of diagnostics----                            displayed in the window. The function should return a string which----                            is prepended to each diagnostic in the window as well as an----                            (optional) highlight group which will be used to highlight the----                            prefix. If {prefix} is a table, it is interpreted as a [text,----                            hl_group] tuple as in |nvim_echo()|; otherwise, if {prefix} is a----                            string, it is prepended to each diagnostic in the window with no----                            highlight.+---       - float: Options for floating windows. See |vim.diagnostic.open_float()|.","Same, big change.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16361,757793589,2021-11-27T15:48:28Z,runtime/lua/vim/diagnostic.lua,"@@ -1162,7 +1146,17 @@ end ---            - format: (function) A function that takes a diagnostic as input and returns a ---                      string. The return value is the text used to display the diagnostic. ---                      Overrides the setting from |vim.diagnostic.config()|.----            - prefix: (function, string, or table) Prefix each diagnostic in the floating window.+---            - prefix: (function, string, or table) Prefix each diagnostic in the floating",big change,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/16452,757813888,2021-11-27T19:42:04Z,src/nvim/testdir/test_filetype.vim,"@@ -553,7 +553,7 @@ let s:filename_checks = {     \ 'xhtml': ['file.xhtml', 'file.xht'],     \ 'xinetd': ['/etc/xinetd.conf', '/etc/xinetd.d/file', 'any/etc/xinetd.conf', 'any/etc/xinetd.d/file'],     \ 'xmath': ['file.msc', 'file.msf'],-    \ 'xml': ['/etc/blkid.tab', '/etc/blkid.tab.old', 'file.xmi', 'file.csproj', 'file.csproj.user', 'file.ui', 'file.tpm', '/etc/xdg/menus/file.menu', 'fglrxrc', 'file.xlf', 'file.xliff', 'file.xul', 'file.wsdl', 'file.wpl', 'any/etc/blkid.tab', 'any/etc/blkid.tab.old', 'any/etc/xdg/menus/file.menu'],+    \ 'xml': ['/etc/blkid.tab', '/etc/blkid.tab.old', 'file.xmi', 'file.csproj', 'file.csproj.user', 'file.fsproj', 'file.fsproj.user', 'file.vbproj', 'file.vbproj.user', 'file.ui', 'file.tpm', '/etc/xdg/menus/file.menu', 'fglrxrc', 'file.xlf', 'file.xliff', 'file.xul', 'file.wsdl', 'file.wpl', 'any/etc/blkid.tab', 'any/etc/blkid.tab.old', 'any/etc/xdg/menus/file.menu', 'file.atom', 'file.rss', 'file.cdxml', 'file.psc1', 'file.mpd'],",Good fix. Looks like this was accidentally reverted a bit in #14424.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16440,758188555,2021-11-29T09:46:33Z,runtime/lua/vim/shared.lua,"@@ -401,24 +401,28 @@ end --- for example from |rpcrequest()| or |vim.fn|. --- ---@param t Table----@returns `true` if array-like table, else `false`.+---@return boolean @`true` if list (table indexed with sequential integers starting from 1), else `false`.","better move the definition to the doc text above, and leave `list-like table` here",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16440,758213349,2021-11-29T10:11:29Z,runtime/lua/vim/shared.lua,"@@ -429,6 +432,48 @@ function vim.tbl_islist(t)   end end +--- Tests if a Lua table can be treated as a list.+---+--- `Array` is a indexing table with integers.+--- `List` is a table indexed with sequential integers starting from 1.",```suggestion--- Tests if a Lua table can be treated as a list (a table indexed by consecutive integers starting from 1).```,
14950617,rish987,https://api.github.com/repos/neovim/neovim/pulls/16382,758721194,2021-11-29T20:43:47Z,runtime/lua/vim/lsp/util.lua,"@@ -1635,41 +1667,69 @@ function M.try_trim_markdown_code_blocks(lines)   return 'markdown' end -local str_utfindex = vim.str_utfindex ---@private-local function make_position_param()-  local row, col = unpack(api.nvim_win_get_cursor(0))+---@param window (optional, number): window handle or 0 for current, defaults to current+---@param offset_encoding string utf-8|utf-16|utf-32|nil defaults to utf-16+local function make_position_param(window, offset_encoding)",This would kind of force use to either use the private function `_get_offset_encoding` or have some ugly logic for independently determining the offset encoding to pass in. I don't really see an issue if the encoding is an inherent property of the position params? IMO the protocol should even be extended to include it as its own (optional) field within the params themselves.,
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762112947,2021-12-03T17:16:41Z,runtime/doc/message.txt,"@@ -836,4 +836,33 @@ The |g<| command can be used to see the last page of previous command output. This is especially useful if you accidentally typed <Space> at the hit-enter prompt. ++						*message-function*  >++If the 'msgfunc' option is set, then the user specified function is+invoked to display messages instead.++The arguments are:++    a:method	""msg_clear"", ""msg_history_show"", or ""msg_show""+    a:kind	specify internal message command.","I found out this is related to the ""kinds"" described in `:help ui-message````Name indicating the message kind:		"""" (empty)	Unknown (consider a feature-request: |bugs|)		""confirm""	|confirm()| or |:confirm| dialog		""confirm_sub""	|:substitute| confirm dialog |:s_c|		""emsg""		Error (|errors|, internal error, |:throw|, ���)		""echo""		|:echo| message		""echomsg""	|:echomsg| message		""echoerr""	|:echoerr| message		""lua_error""	Error in |:lua| code		""rpc_error""	Error response from |rpcrequest()|		""return_prompt""	|press-enter| prompt after a multiple messages		""quickfix""	Quickfix navigation message		""search_count""	Search count message (""S"" flag of 'shortmess')		""wmsg""		Warning (""search hit BOTTOM"", |W10|, ���)```Are all of them **expected** for this command? If so please link to that section, otherwise list what are the expected kinds here. I think ""internal message command"" is vague.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762141832,2021-12-03T18:02:54Z,runtime/doc/message.txt,"@@ -836,4 +836,33 @@ The |g<| command can be used to see the last page of previous command output. This is especially useful if you accidentally typed <Space> at the hit-enter prompt. ++						*message-function*  >++If the 'msgfunc' option is set, then the user specified function is+invoked to display messages instead.++The arguments are:++    a:method	""msg_clear"", ""msg_history_show"", or ""msg_show""+    a:kind	specify internal message command.+    a:chunks	[attr, text] list","attr -> attr_id`attr_id` is consistent with how it is described in the ""content"" item of `:help ui-messages`More specifically this is a highlight group id from what I've found, thus it could be named `highlight_id` or something along those lines. If that is correct then users are likely to consume those ids in ""hl_group"" of `nvim_buf_set_extmark` or `nvim_buf_add_highlight`, so it might be worthwhile to mention those functions somewhere.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762199822,2021-12-03T19:43:42Z,test/functional/ui/messages_spec.lua,"@@ -1096,6 +1097,37 @@ vimComment     xxx match /\s""[^\-:.%#=*].*$/ms=s+1,lc=1  excludenl contains=@vim       {4:Press ENTER or type command to continue}^                     |     ]]}   end)+  it('msgfunc disables messages output', function()","If feasible, it would be good to test the crash prevention as well. Something along the lines of:*Note: this is pseudo-code which has not been ran*```luait('msgfunc does not crash on recursive echo', function()    source([[    let g:ok = v:false    function! Func(...) abort      echomsg ""Test recursion crash prevention""      let g:ok = v:true    endfunction    set msgfunc=Func    echomsg ""Foo""    ]])    eq(0, eval('wait(2048, {->g:ok})'))end)```",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762380775,2021-12-04T03:47:34Z,src/nvim/message.c,"@@ -3064,14 +3077,24 @@ int msg_end(void)  void msg_ext_ui_flush(void) {-  if (!ui_has(kUIMessages)) {+  if (!msg_enable_ext()) {     return;   }    msg_ext_emit_chunk();   if (msg_ext_chunks.size > 0) {-    ui_call_msg_show(cstr_to_string(msg_ext_kind),-                     msg_ext_chunks, msg_ext_overwrite);+    if (ui_has(kUIMessages)) {+      ui_call_msg_show(cstr_to_string(msg_ext_kind),+                       msg_ext_chunks, msg_ext_overwrite);+    } else {+      msg_call_msgfunc(""msg_show"", &msg_ext_chunks);","I found one issue from usageIf you trigger an exception which has multiple chunks (probably any message which has multiple chunks), the state will be set to `HITRETURN` which will freeze the UI until Enter is pressed. I discovered this situation by accident when `nvim_get_mode()` evaluated to `""r""` while I was trying to debug the problem.https://github.com/neovim/neovim/blob/419e0d117d61f6d22f696a8833541dd1691c92fb/src/nvim/state.c#L150-L152`HITRETURN` should be ignored if the chunks have not been drawn to the built-in message output buffer.## To reproduce1.```function! Func(...)endfunctionset msgfunc=Func```2. Modify a buffer3. Try to `:quit`. Doing so will throw the `No write since last change for buffer` exception, but the message will not be drawn because we're using `msgfunc=Func`.4. The cursor is stuck in an empty command line until you press Enter, although no message has been drawn",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762399288,2021-12-04T07:56:13Z,src/nvim/message.c,"@@ -3145,6 +3172,65 @@ void msg_check(void)   } } +bool msg_enable_ext(void)+{+  return ui_has(kUIMessages) || msg_enable_msgfunc();+}++bool msg_enable_msgfunc(void)+{+  // msgfunc is disabled in command line mode","For ""msgfunc is disabled in command line mode"" to be true, you have to add `!(State & CMDLINE)` to the condition below, which makes sense I assume.Adding that condition also will avoid sending data to msgfunc while the user is typing something in the command line.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762521824,2021-12-05T07:26:11Z,src/nvim/message.c,"@@ -3064,14 +3077,24 @@ int msg_end(void)  void msg_ext_ui_flush(void) {-  if (!ui_has(kUIMessages)) {+  if (!msg_enable_ext()) {     return;   }    msg_ext_emit_chunk();   if (msg_ext_chunks.size > 0) {-    ui_call_msg_show(cstr_to_string(msg_ext_kind),-                     msg_ext_chunks, msg_ext_overwrite);+    if (ui_has(kUIMessages)) {+      ui_call_msg_show(cstr_to_string(msg_ext_kind),+                       msg_ext_chunks, msg_ext_overwrite);+    } else {+      msg_call_msgfunc(""msg_show"", &msg_ext_chunks);++      // ui_call_msg_xxx() calls ui_event(), which frees the allocated chunk+      // The allocated chunk should also need freeing in or after+      // msg_call_msgfunc().+      api_free_array(msg_ext_chunks);","Makes sense. I was not sure if the data was being copied before usage on `msg_call_msgfunc_event`.It's good to explain the motivation in the comment```c// since msg_ext_chunks has been copied in msg_call_msgfunc, it can already be// freed here       api_free_array(msg_ext_chunks); ```",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762522385,2021-12-05T07:32:12Z,src/nvim/message.c,"@@ -3145,6 +3167,71 @@ void msg_check(void)   } } +bool msg_enable_ext(void)+{+  return ui_has(kUIMessages) || msg_enable_msgfunc();+}++bool msg_enable_msgfunc(void)+{+  // msgfunc is disabled in command line mode+  // Because default echo is used for command line redraw+  return *p_msgfunc != NUL && !msg_check_loop+    && !redir_off && !need_wait_return+    && State != CMDLINE && State != CONFIRM;","FWIW, according to the docs of vim.hhttps://github.com/neovim/neovim/blob/828bf128a64466f254629b102e283af35666cd05/src/nvim/vim.h#L43-L44I suggested `State & CMDLINE` because that is how it's used in other places, e.g.https://github.com/neovim/neovim/blob/828bf128a64466f254629b102e283af35666cd05/src/nvim/aucmd.c#L106https://github.com/neovim/neovim/blob/725cbe7d414f609e769081276f2a034e32a4337b/src/nvim/cursor_shape.c#L332I don't know if `!= CMDLINE` is as effective.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,762533019,2021-12-05T09:13:55Z,src/nvim/message.c,"@@ -1045,7 +1049,16 @@ void ex_messages(void *const eap_p)         ADD(entries, ARRAY_OBJ(entry));       }     }-    ui_call_msg_history_show(entries);+    if (ui_has(kUIMessages)) {+      ui_call_msg_history_show(entries);+    } else {+      msg_call_msgfunc(""msg_history_show"", &entries);","One hopefully final question about this.I noticed that when I execute a search through the command line, e.g. type `/text` and Enter, the `/text` gets sent to the msgfunc. Do you think this behavior makes sense? The `a:method` for msgfunc in that occasion is `""""`, which also comes up for arbitrary lines in large sequences of message chunks, so there's no trivial way of identifying those kinds of events from the user's side.To work around that, we could tag the lingering command line from user input, e.g. `/`, `:`, `?`, etc. with a specific kind. Probably can be done in a future PR.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16531,762544100,2021-12-05T10:52:59Z,runtime/lua/vim/lsp/buf.lua,"@@ -116,31 +116,32 @@ end --- asks the user to select one. -- ---@returns The client that the user selected or nil-local function select_client(method)-  local clients = vim.tbl_values(vim.lsp.buf_get_clients());-  clients = vim.tbl_filter(function (client)+local function select_client(method, on_choice)+  validate {+    on_choice = { on_choice, 'function', false },+  }+  local clients = vim.tbl_values(vim.lsp.buf_get_clients())+  clients = vim.tbl_filter(function(client)     return client.supports_method(method)   end, clients)   -- better UX when choices are always in the same order (between restarts)-  table.sort(clients, function (a, b) return a.name < b.name end)+  table.sort(clients, function(a, b)+    return a.name < b.name+  end)    if #clients > 1 then-    local choices = {}-    for k,v in pairs(clients) do-      table.insert(choices, string.format(""%d %s"", k, v.name))-    end-    local user_choice = vim.fn.confirm(-      ""Select a language server:"",-      table.concat(choices, ""\n""),-      0,-      ""Question""-    )-    if user_choice == 0 then return nil end-    return clients[user_choice]+    vim.ui.select(clients, {+      prompt = 'Select a language server:',+      format_item = function(client)+        return client.name+      end,+    }, function(item, idx)+      on_choice(item)+    end)","```suggestion    }, on_choice)```Not necessary to wrap the function to drop an unused argument",
36740602,mtoohey31,https://api.github.com/repos/neovim/neovim/pulls/16527,762602262,2021-12-05T19:05:30Z,test/functional/lua/diagnostic_spec.lua,"@@ -1918,5 +1918,31 @@ describe('vim.diagnostic', function()         return {show_called, hide_called}       ]])     end)++    it('triggers the autocommand when diagnostics are set', function()+      eq(1, exec_lua [[+        vim.g.diagnostic_autocmd_triggered = 0+        vim.cmd('autocmd DiagnosticChanged * let g:diagnostic_autocmd_triggered = 1')+        vim.api.nvim_buf_set_name(diagnostic_bufnr, ""test | test"")+        vim.wait(100, function ()","You're right! My bad, it seems it's unecessary. Fixed in 7ad910d.",
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/16480,762632790,2021-12-05T23:29:53Z,src/nvim/message.c,"@@ -1045,7 +1049,16 @@ void ex_messages(void *const eap_p)         ADD(entries, ARRAY_OBJ(entry));       }     }-    ui_call_msg_history_show(entries);+    if (ui_has(kUIMessages)) {+      ui_call_msg_history_show(entries);+    } else {+      msg_call_msgfunc(""msg_history_show"", &entries);","Well, it is very hard to what messages should be passed to `msgfunc`...If `set cmdheight=0` is set, the default echo is very useless.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16536,762669337,2021-12-06T02:45:04Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -253,6 +253,7 @@ end ---                        If nil, diagnostics of all clients are included. ---@return table with diagnostics grouped by bufnr (bufnr: Diagnostic[]) function M.get_all(client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_all is deprecated. Use vim.diagnostic.get instead', 'WarningMsg']], true, {})","I like @clason's suggestion to instead refer users to `:h deprecated`, which already contains the replacements for each deprecated function, rather than suggesting the replacement for each function individually.```suggestion  vim.api.nvim_echo([['vim.lsp.diagnostic.get_all is deprecated. See :h deprecated', 'WarningMsg']], true, {})```We can workshop the actual wording/phrasing (our resident wordsmith @clason likely has the *mot juste*).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762887248,2021-12-06T10:39:03Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -253,6 +253,7 @@ end ---                        If nil, diagnostics of all clients are included. ---@return table with diagnostics grouped by bufnr (bufnr: Diagnostic[]) function M.get_all(client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_all is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_all is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762887744,2021-12-06T10:39:44Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -274,6 +275,7 @@ end ---                            Else, return just the diagnostics associated with the client_id. ---@param predicate function|nil Optional function for filtering diagnostics function M.get(bufnr, client_id, predicate)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762887881,2021-12-06T10:39:55Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -335,6 +337,7 @@ end ---@param severity DiagnosticSeverity ---@param client_id number the client id function M.get_count(bufnr, severity, client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_count is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_count is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762888069,2021-12-06T10:40:10Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -351,6 +354,7 @@ end ---@param opts table See |vim.lsp.diagnostic.goto_next()| ---@return table Previous diagnostic function M.get_prev(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_prev is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_prev is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762888285,2021-12-06T10:40:27Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -368,6 +372,7 @@ end ---@param opts table See |vim.lsp.diagnostic.goto_next()| ---@return table Previous diagnostic position function M.get_prev_pos(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_prev_pos is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_prev_pos is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762888466,2021-12-06T10:40:42Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -384,6 +389,7 @@ end --- ---@param opts table See |vim.lsp.diagnostic.goto_next()| function M.goto_prev(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.goto_prev is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.goto_prev is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762888640,2021-12-06T10:40:55Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -401,6 +407,7 @@ end ---@param opts table See |vim.lsp.diagnostic.goto_next()| ---@return table Next diagnostic function M.get_next(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_next is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_next is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762888812,2021-12-06T10:41:07Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -418,6 +425,7 @@ end ---@param opts table See |vim.lsp.diagnostic.goto_next()| ---@return table Next diagnostic position function M.get_next_pos(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_next_pos is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_next_pos is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762888997,2021-12-06T10:41:22Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -432,6 +440,7 @@ end --- ---@deprecated Prefer |vim.diagnostic.goto_next()| function M.goto_next(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.goto_next is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.goto_next is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762889216,2021-12-06T10:41:38Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -455,6 +464,7 @@ end ---             - severity_limit (DiagnosticSeverity): ---                 - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid. function M.set_signs(diagnostics, bufnr, client_id, _, opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.set_signs is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.set_signs is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762889360,2021-12-06T10:41:50Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -475,6 +485,7 @@ end ---             - severity_limit (DiagnosticSeverity): ---                 - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid. function M.set_underline(diagnostics, bufnr, client_id, _, opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.set_underline is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.set_underline is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762889551,2021-12-06T10:42:05Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -496,6 +507,7 @@ end ---             - severity_limit (DiagnosticSeverity): ---                 - Limit severity of diagnostics found. E.g. ""Warning"" means { ""Error"", ""Warning"" } will be valid. function M.set_virtual_text(diagnostics, bufnr, client_id, _, opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.set_virtual_text is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.set_virtual_text is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762889707,2021-12-06T10:42:18Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -514,6 +526,7 @@ end ---@return an array of [text, hl_group] arrays. This can be passed directly to ---        the {virt_text} option of |nvim_buf_set_extmark()|. function M.get_virtual_text_chunks_for_line(bufnr, _, line_diags, opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.get_virtual_text_chunks_for_line is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.get_virtual_text_chunks_for_line is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762889851,2021-12-06T10:42:30Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -531,6 +544,7 @@ end ---@param position table|nil The (0,0)-indexed position ---@return table {popup_bufnr, win_id} function M.show_position_diagnostics(opts, buf_nr, position)+  vim.api.nvim_echo([['vim.lsp.diagnostic.show_position_diagnostics is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.show_position_diagnostics is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762889989,2021-12-06T10:42:42Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -554,6 +568,7 @@ end ---@param client_id number|nil the client id ---@return table {popup_bufnr, win_id} function M.show_line_diagnostics(opts, buf_nr, line_nr, client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.show_line_diagnostics is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.show_line_diagnostics is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762890141,2021-12-06T10:42:54Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -577,6 +592,7 @@ end ---       client. The default is to redraw diagnostics for all attached ---       clients. function M.redraw(bufnr, client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.redraw is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.redraw is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762890307,2021-12-06T10:43:06Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -604,6 +620,7 @@ end ---         - {workspace}: (boolean, default true) ---             - Set the list with workspace diagnostics function M.set_qflist(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.set_qflist is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.set_qflist is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762890483,2021-12-06T10:43:20Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -635,6 +652,7 @@ end ---         - {workspace}: (boolean, default false) ---             - Set the list with workspace diagnostics function M.set_loclist(opts)+  vim.api.nvim_echo([['vim.lsp.diagnostic.set_loclist is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.set_loclist is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762890641,2021-12-06T10:43:32Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -662,6 +680,7 @@ end -- send diagnostic information and the client will still process it. The -- diagnostics are simply not displayed to the user. function M.disable(bufnr, client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.disable is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.disable is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762890792,2021-12-06T10:43:44Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -682,6 +701,7 @@ end ---       client. The default is to enable diagnostics for all attached ---       clients. function M.enable(bufnr, client_id)+  vim.api.nvim_echo([['vim.lsp.diagnostic.enable is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.diagnostic.enable is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762890952,2021-12-06T10:43:56Z,runtime/lua/vim/lsp/util.lua,"@@ -1531,6 +1531,7 @@ end --- ---@param items (table) list of items function M.set_loclist(items, win_id)+  vim.api.nvim_echo([['vim.lsp.util.set_loclist is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.util.set_loclist is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16536,762891127,2021-12-06T10:44:10Z,runtime/lua/vim/lsp/util.lua,"@@ -1544,6 +1545,7 @@ end --- ---@param items (table) list of items function M.set_qflist(items)+  vim.api.nvim_echo([['vim.lsp.util.set_qflist is deprecated. See :h deprecated', 'WarningMsg']], true, {})","```suggestion  vim.api.nvim_echo({{'vim.lsp.util.set_qflist is deprecated. See :h deprecated', 'WarningMsg'}}, true, {})```",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,763549189,2021-12-07T01:10:25Z,src/nvim/message.c,"@@ -3182,7 +3182,7 @@ bool msg_enable_msgfunc(void)   // Note: msgfunc is disabled in command line mode   //       Because default echo is used for command line redraw   return *p_msgfunc != NUL && !msg_check_loop-    && !redir_off && !need_wait_return && !starting+    && !redir_off && !need_wait_return && !starting && !called_emsg","Hm... I don't think this is the right fix. I think error messages should go to `msgfunc`.In https://github.com/neovim/neovim/pull/16480#issuecomment-987334632 I called `input(""What is your name? "")` which means I should be in command line mode. Then I `set msgfunc=` **while I was still in command line mode**,  but it should not matter in any case since the feature should be completely disabled in command line mode.The desired outcome for this mode is that no message should be sent, regardless of it being an error or not. It seems like the command line mode detection is incomplete or not enough. Are we considering all the relevant states when `input()`, `getchar()`, etc, are called? Because that should be ""command line mode"" still.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,763587911,2021-12-07T02:49:56Z,src/nvim/message.c,"@@ -3182,7 +3182,7 @@ bool msg_enable_msgfunc(void)   // Note: msgfunc is disabled in command line mode   //       Because default echo is used for command line redraw   return *p_msgfunc != NUL && !msg_check_loop-    && !redir_off && !need_wait_return && !starting+    && !redir_off && !need_wait_return && !starting && !called_emsg","Now I remember why I got confused.1. I am in command line mode for `input()`2. `foo()` throws an exception; part of the exception's message is sent to msgfunc, and another part is sent to the output buffer3. Because the message from `foo()` was sent to the output buffer, I need to press EnterIn step 3 I thought I was still in command line mode due to the need to press Enter, because my cursor did not move back to the window.`input()` has something to do with this problem because the whole exception is sent to msgfunc if it is in thrown while I am in normal mode. Maybe I have not ""exited completely"" by the time `foo` is called, as far as the UI state is concerned.",
17429390,resolritter,https://api.github.com/repos/neovim/neovim/pulls/16480,764480273,2021-12-08T01:20:42Z,src/nvim/message.c,"@@ -3049,9 +3069,11 @@ int msg_end(void)    * we have to redraw the window.    * Do not do this if we are abandoning the file or editing the command line.    */-  if (!exiting && need_wait_return && !(State & CMDLINE)) {-    wait_return(FALSE);-    return FALSE;+  if (msg_enable_ext()) {",The failure from https://github.com/neovim/neovim/pull/16480#issuecomment-988403007 might be related to this condition. It probably makes sense to change this `msg_enable_ext` to `msg_enable_msgfunc` so that the old behavior is preserved for GUI.,
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/16564,764561531,2021-12-08T05:37:19Z,test/helpers.lua,"@@ -741,17 +741,46 @@ function module.read_file_list(filename, start)   if not file then     return nil   end++  local chars_per_line = 256",">Instead of guessing, you could read the last N characters of the file That's what this code does, max_chars (whose value depends on chars_per_line) is the N you're talking about :). Lines can vary a lot in length, some are a couple dozen characters, some are ~200 characters long, there is no point in computing an average on only part of the file when we have one computed over all of the file.Note that I've replaced 256 with 15000, which is the size of the longest line I've found in the log file. Perf impact is minimal and the result should be slightly more accurate.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16573,764998710,2021-12-08T15:58:02Z,runtime/doc/help.txt,"@@ -164,13 +167,24 @@ GUI ~  Interfaces ~ |if_cscop.txt|	using Cscope with Vim+|if_perl|	Perl interface |if_pyth.txt|	Python interface |if_ruby.txt|	Ruby interface |sign.txt|	debugging signs  Versions ~ |vim_diff.txt|	Main differences between Nvim and Vim |vi_diff.txt|	Main differences between Vim and Vi+|deprecated.txt|  Deprecated items that has been or will be removed",```suggestion|deprecated.txt|  Deprecated items that have been or will be removed```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16573,765041218,2021-12-08T16:46:16Z,runtime/doc/help.txt,"@@ -164,13 +167,24 @@ GUI ~  Interfaces ~ |if_cscop.txt|	using Cscope with Vim+|if_perl|	Perl interface","The others in this list contain the `.txt` extension, should this one too?",
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/16541,765711383,2021-12-09T11:44:12Z,src/nvim/syntax.c,"@@ -7623,10 +7627,9 @@ int syn_name2id(const char *name) int syn_name2id_len(const char_u *name, size_t len)   FUNC_ATTR_NONNULL_ALL {-  char name_u[201];+  char name_u[MAX_SYN_NAME + 1]; -  if (len == 0 || len > 200) {-    // ID names over 200 chars don't deserve to be found!+  if (len == 0 || len > MAX_SYN_NAME) {",I think this condition can be removed or changed to the following `assert`. I believe this condition is no longer met by vim/vim@5e18ccc and vim/vim@f7f7aaf.```Cassert(len != 0);assert(len <= MAX_SYN_NAME);```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16603,766706953,2021-12-10T14:10:10Z,runtime/lua/vim/lsp/handlers.lua,"@@ -285,7 +286,7 @@ local function location_handler(_, result, ctx, _)     util.jump_to_location(result[1])      if #result > 1 then-      util.set_qflist(util.locations_to_items(result))+      diag.setqflist(util.locations_to_items(result))","```suggestion      vim.fn.setqflist({}, ' ', {title = 'LSP locations', items = util.locations_to_items(result))```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16603,766707975,2021-12-10T14:11:30Z,runtime/lua/vim/lsp/handlers.lua,"@@ -379,7 +380,7 @@ local make_call_hierarchy_handler = function(direction)         })       end     end-    util.set_qflist(items)+    diag.setqflist(items)","```suggestion    vim.fn.setqflist({}, ' ', {title = 'LSP call hierarchy', items = util.locations_to_items(result))```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16603,766724620,2021-12-10T14:33:07Z,runtime/lua/vim/lsp/handlers.lua,"@@ -379,7 +379,7 @@ local make_call_hierarchy_handler = function(direction)         })       end     end-    util.set_qflist(items)+    vim.fn.setqflist({}, ' ', {title = 'LSP call hierarchy', items = util.locations_to_items(result))","(my) copypasta:```suggestion    vim.fn.setqflist({}, ' ', {title = 'LSP call hierarchy', items = items)```",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/16633,767841133,2021-12-13T15:04:59Z,CMakeLists.txt,"@@ -413,7 +413,7 @@ endif() option(PREFER_LUA ""Prefer Lua over LuaJIT in the nvim executable."" OFF)  if(PREFER_LUA)-  find_package(Lua 5.1 REQUIRED)+  find_package(Lua 5.1 EXACT REQUIRED)","We control `FindLua.cmake`, so if you want to prefer Lua5.1 then switch the order. :) There are distros which insist on packaging neovim with newer versions of Lua (because they don't understand Lua versioning and have dropped Lua 5.1), which is why we have that list in `FindLua.cmake`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16633,767985301,2021-12-13T17:47:08Z,CMakeLists.txt,"@@ -413,7 +413,7 @@ endif() option(PREFER_LUA ""Prefer Lua over LuaJIT in the nvim executable."" OFF)  if(PREFER_LUA)-  find_package(Lua 5.1 REQUIRED)+  find_package(Lua 5.1 EXACT REQUIRED)","I thought findLua also affected the use of build time lua, where we _do_ support any lua 5.1+ version (so a distro could use lua5.3+lua5.3-(lpeg+mpack+bit)  as a buildtime dependency and only luajit+luv as the only runtime lua dependencies).",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/16633,768078718,2021-12-13T19:59:08Z,CMakeLists.txt,"@@ -413,7 +413,7 @@ endif() option(PREFER_LUA ""Prefer Lua over LuaJIT in the nvim executable."" OFF)  if(PREFER_LUA)-  find_package(Lua 5.1 REQUIRED)+  find_package(Lua 5.1 EXACT REQUIRED)","This is the only place that uses FindLua.cmake.  FindLua.cmake gives us the include and library paths, so I agree that it's targeting what should be built against for use during runtime.  That would imply that it shouldn't allow unsupported Lua versions.Now, a bit further down in this file we have the LUA_PRG+lpeg+mpack+bit checks and _those_ only allow using Lua 5.1, 5.2, or LuaJIT.  LUA_PRG is what we use to run the lua scripts and parts of the test suite.It seems like the version checks we're doing are reversed from what they should be.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16631,768516261,2021-12-14T10:22:04Z,src/nvim/generators/gen_char_blob.lua,"@@ -28,6 +28,8 @@ for argi = 2, #arg, 2 do    target:write(('static const uint8_t %s[] = {\n'):format(varname)) +  local compiled = assert(io.popen(os.getenv(""LUAC_PRG""):format(source_file)):read(""*a""))",`gen_char_blob` could be used for other things than lua source potentially. perhaps add an `arg` to toggle compilation?,
11682285,erw7,https://api.github.com/repos/neovim/neovim/pulls/16631,768531319,2021-12-14T10:35:04Z,src/nvim/CMakeLists.txt,"@@ -326,7 +326,9 @@ add_custom_command(  add_custom_command(   OUTPUT ${VIM_MODULE_FILE}-  COMMAND ${LUA_PRG} ${CHAR_BLOB_GENERATOR} ${VIM_MODULE_FILE}+  COMMAND ${CMAKE_COMMAND} -E env+      ""LUAC_PRG=${LUAC_PRG}""+      ${LUA_PRG} ${CHAR_BLOB_GENERATOR} ${VIM_MODULE_FILE}","I think we need to do some escaping. I have tried several things, but they do not work. On Windows, how about using `loadstring` and `string.dump` as follows? This method is about `3k` larger (`vim.lua`: 20k, pre-compile: 8k, this method: 11k), but the load time doesn't seem to change much.```lualocal compiled = string.dump(assert(loadstring(sourc:read('*a'), source_name)))```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16620,768895801,2021-12-14T17:34:41Z,runtime/doc/lua.txt,"@@ -707,6 +707,38 @@ vim.mpack.encode({obj})                                 *vim.mpack.encode* vim.mpack.decode({str})                                 *vim.mpack.decode*         Decodes (or ""unpacks"") the msgpack-encoded {str} to a Lua object. +------------------------------------------------------------------------------+VIM.SPELL                                                           *lua-spell*++vim.spell.check({str}, {opts})                           *vim.spell.check*","It looks like `{opts}` is unused. Since this is not part of the RPC API there is no strict contract preventing us from adding an argument in the future if need be, so we don't need to ""defensively"" add an `opts` table here like we often do for API functions.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/16649,769058908,2021-12-14T21:28:13Z,runtime/autoload/health.vim,"@@ -29,7 +29,8 @@ function! health#check(plugin_names) abort         \ ? s:discover_healthchecks()         \ : s:get_healthcheck(a:plugin_names) -  tabnew+  "" create scratch-buffer+  execute 'tab sbuffer' nvim_create_buf(v:true, v:true)","Hello. I believe this doesn't address the issue at hand. There's still no way to tell if this is a checkhealth buffer or not. Now it's a nofile buffer.To solve the issue let's name the buffer to something meaningful. So we can close #16639 and  #8148```suggestion  let l:b = bufnr(""nvim.chechhealth"", v:true)  execute 'tab sbuffer ' . l:b  call nvim_buf_set_lines(l:b, 0, -1, v:true, [])  setlocal buftype=nofile  setlocal buflisted noswapfile```",
14950617,rish987,https://api.github.com/repos/neovim/neovim/pulls/16669,769940368,2021-12-15T19:17:59Z,runtime/lua/vim/lsp/sync.lua,"@@ -93,30 +93,35 @@ end -- utf-8 index and either the utf-16, or utf-32 index. ---@param line string the line to index into ---@param byte integer the byte idx+---@param start boolean true for start align, false for end align ---@param offset_encoding string utf-8|utf-16|utf-32|nil (default: utf-8) ---@returns table<string, int> byte_idx and char_idx of first change position-local function align_end_position(line, byte, offset_encoding)+local function align_position(line, byte, start, offset_encoding)+  if byte <= #line then+    -- Modifying line, find the nearest utf codepoint+    local offset = str_utf_start(line, byte)++    -- If the byte does not fall on the start of the character, then+    -- align to the start of the next character if end align, and start+    -- of this character if start align+    if offset < 0 then+      if start then+        byte = byte + offset+      else+        byte = byte + str_utf_end(line, byte) + 1+      end+    end+  end+   local char-  -- If on the first byte, or an empty string: the trivial case-  if byte == 1 or #line == 0 then","My bad, just added an equivalent optimization for this case.",
14950617,rish987,https://api.github.com/repos/neovim/neovim/pulls/16670,770120167,2021-12-15T23:41:37Z,runtime/lua/vim/lsp/sync.lua,"@@ -105,16 +105,13 @@ local function align_end_position(line, byte, offset_encoding)     char = compute_line_length(line, offset_encoding) + 1   else     -- Modifying line, find the nearest utf codepoint-    local offset = str_utf_end(line, byte)","After reading the code for `mb_head_off` and `mb_tail_off` it indeed looks like [we're starting the search relative to the offset, not the beginning of the line](https://github.com/neovim/neovim/blob/326e74571be43823ded9fa805a3173bdabda6bec/src/nvim/mbyte.c#L1867). It looks like the only reason we pass in the base pointer is so we know when to stop in the case of malformed UTF-8. So having to do an extra check here should only require at most a couple more memory accesses.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16678,770471519,2021-12-16T11:53:41Z,test/functional/api/vim_spec.lua,"@@ -2121,6 +2121,9 @@ describe('API', function()        eq({}, meths.get_runtime_file(""foobarlang/"", true))     end)+    it('can handle bad patterns', function()+      eq({}, exec_lua(""return vim.api.nvim_get_runtime_file('{', true)""))","Hmm this should still return (one) `Vim:E220: Missing }` error. This PR works as intended in interactive testing (proper lua exception, no repeat messages), but not here in testing for some reason.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/16678,770477647,2021-12-16T12:02:49Z,test/functional/api/vim_spec.lua,"@@ -2121,6 +2121,9 @@ describe('API', function()        eq({}, meths.get_runtime_file(""foobarlang/"", true))     end)+    it('can handle bad patterns', function()+      eq({}, exec_lua(""return vim.api.nvim_get_runtime_file('{', true)""))","Yeah, this is really confusing me. It seems like the testing env is suppressing vim exceptions in some form.FWIW this test completely hangs without the added changes.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16684,770785216,2021-12-16T17:58:13Z,runtime/doc/vim_diff.txt,"@@ -354,7 +355,8 @@ Motion:   The |jumplist| avoids useless/phantom jumps.  Normal commands:-  |Q| is the same as |gQ|+  |Q| replays the last macro instead of switching to Ex mode.",```suggestion  |Q| replays the last recorded macro instead of switching to Ex mode.```Can you also add `RecordingEnter` and `RecordingLeave` to the `Events:` list under `FEATURES`?,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,770973784,2021-12-16T22:49:14Z,src/nvim/option_defs.h,"@@ -492,9 +492,10 @@ EXTERN int p_js;                // 'joinspaces' EXTERN char_u *p_jop;           // 'jumpooptions' EXTERN unsigned jop_flags; #ifdef IN_OPTION_C-static char *(p_jop_values[]) = { ""stack"", NULL };+static char *(p_jop_values[]) = { ""stack"", ""view"", NULL };",Let me know what you think https://github.com/muniter/neovim/blob/4897a954bc06b3d6935b53b783285f5994e48f45/runtime/doc/options.txt#L3513,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,770974114,2021-12-16T22:49:53Z,test/functional/editor/jump_spec.lua,"@@ -137,3 +139,88 @@ describe(""jumpoptions=stack behaves like 'tagstack'"", function()        exec_capture('jumps'))   end) end)++describe(""jumpoptions=view"", function()+  local file1 = 'Xtestfile-functional-editor-jumps'+  local file2 = 'Xtestfile-functional-editor-jumps-2'+  local function content()+    local c = {}+    for i=1,30 do+      c[i] = i .. "" line""+    end+    return table.concat(c, ""\n"")+  end+  before_each(function()+    clear()+    write_file(file1, content(), false, false)+    write_file(file2, content(), false, false)+    command('set jumpoptions=view')+  end)+  after_each(function()+    os.remove(file1)+    os.remove(file2)+  end)++  it('restores the view', function()+    local screen = Screen.new(5, 8)+    screen:attach()+    command(""edit "" .. file1)+    feed(""12Gztj"")+    feed(""gg<C-o>"")+    screen:expect([[+    12 line     |+    ^13 line     |+    14 line     |+    15 line     |+    16 line     |+    17 line     |+    18 line     |+                |+    ]])+  end)++  it('restores  the view across files', function()+    local screen = Screen.new(5, 5)+    screen:attach()+    command(""args "" .. file1 .. "" "" .. file2)+    feed(""12Gzt"")+    command(""next"")+    feed(""G"")+    screen:expect([[+    27 line     |+    28 line     |+    29 line     |+    ^30 line     |+                |+    ]])+    feed(""<C-o><C-o>"")+    screen:expect([[+    ^12 line     |+    13 line     |+    14 line     |+    15 line     |+                |+    ]])+  end)++  it('fallback to standard behavior when view can\'t be recovered', function()+    local screen = Screen.new(5, 8)+    screen:attach()+    command(""edit "" .. file1)+    feed(""7GzbG"")+    curbufmeths.set_lines(0, 2, true, {})+    -- Since lines where deleted can't se a 7 lines topline offset, so it+    -- fallback to centering the view.",I think this explanation is a little better https://github.com/muniter/neovim/blob/4897a954bc06b3d6935b53b783285f5994e48f45/test/functional/editor/jump_spec.lua#L212,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/15831,771041965,2021-12-17T01:51:46Z,runtime/doc/options.txt,"@@ -3510,6 +3510,12 @@ A jump table for the options with a short description can be found at |Q_op|. 			jumplist and then jumping to a location. 			|jumplist-stack| +	  view          When moving on the jumplist try to recover the view in+			which the jump was defined. The view of a jump is",```suggestion	  view          When moving through the jumplist try to restore the view from			when the jump occurred. The view of a jump is```,
23341710,AckslD,https://api.github.com/repos/neovim/neovim/pulls/16684,771153289,2021-12-17T07:10:59Z,runtime/doc/index.txt,"@@ -339,7 +339,7 @@ tag		char	      note action in Normal mode	~ 				   insert text, repeat N times |P|		[""x]P		2  put the text [from register x] before the 				   cursor N times-|Q|		Q		   switch to ""Ex"" mode+|gQ|		gQ		   switch to ""Ex"" mode","Woops, by bad, removed in ca42b05fd19ae7641ba9fe67fd7bdcfd46d72d05",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16698,771881099,2021-12-19T00:44:30Z,test/functional/autocmd/cursormoved_spec.lua,"@@ -31,4 +31,14 @@ describe('CursorMoved', function()     eq({'aaa'}, funcs.nvim_buf_get_lines(eval('g:buf'), 0, -1, true))     eq(0, eval('g:cursormoved'))   end)++  it(""is not triggered by cursor movement prior to first CursorMoved instantiation"", function()+    source([[+    let g:cursormoved = 0+    "" Move the cursor by inserting text+    call nvim_feedkeys('aaa', 'i', v:true)",`w_last_cursormoved` is always updated when entering a new window:<https://github.com/neovim/neovim/blob/95803f0e902278079e5876082465b1910c819947/src/nvim/window.c#L4594>,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16212,771934071,2021-12-19T11:16:02Z,src/nvim/eval/typval_encode.c.h,"@@ -391,11 +391,7 @@ static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(     }     break;   case VAR_SPECIAL:-    switch (tv->vval.v_special) {-    case kSpecialVarNull:-      TYPVAL_ENCODE_CONV_NIL(tv);  // -V1037-      break;-    }+    TYPVAL_ENCODE_CONV_NIL(tv);  // -V1037","I agree. The only way this can be done is a refactor that consistently removes `tv->vval.v_special` everywhere. But the complexity savings are negligible, so better to keep this to be open for more special values, which might happen.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16710,771988838,2021-12-19T19:09:43Z,src/nvim/api/vim.c,"@@ -696,7 +696,15 @@ Object nvim_get_option_value(String name, Dict(option) *opts, Error *err)     rv = INTEGER_OBJ(numval);     break;   case 2:-    rv = BOOLEAN_OBJ(!!numval);+    switch (numval) {+      case 0:+      case 1:+        rv = BOOLEAN_OBJ(numval);+        break;+      default:+        rv = INTEGER_OBJ(numval);",`-1` is used in `do_set()`: https://github.com/neovim/neovim/blob/abb2b1a31cb2b7819d2db897006ea6e53b359c02/src/nvim/option.c#L1211-L1218```vim:set autoread:setl autoread<:echo &l:autoread-1```Shouldn't we try and keep the API version consistent with the Vim script version?,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16740,773477711,2021-12-21T22:20:01Z,test/functional/terminal/buffer_spec.lua,"@@ -298,6 +298,18 @@ describe(':terminal buffer', function()     feed_command('put a') -- buffer a is empty     helpers.assert_alive()   end)++  it('supports OSC7 with autochdir', function()+    command('set autochdir')+    local cwd = eval(""getcwd()"")+    local parent = cwd:match(""^(.+\\)"")+    if parent == nil then+        parent = cwd:match(""^(.+/)"")+    end+    command('terminal')+    feed('printf ""\\033]7;file://host/' .. parent .. '..\\033\\\\""<CR>')",1. `printf` is shell-dependent2. You feeded the keys in Normal mode,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/16752,774874079,2021-12-24T05:03:58Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1342,182 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, Buffer buffer,+                      int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  char desc[20];++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->range.type == kObjectTypeBoolean) {+    if (opts->range.data.boolean) {+      argt |= EX_RANGE;+      addr_type_arg = ADDR_LINES;+    }+  } else if (opts->range.type == kObjectTypeString) {+    if (opts->range.data.string.data[0] == '%' && opts->range.data.string.size == 1) {+      argt |= EX_RANGE | EX_DFLALL;+      addr_type_arg = ADDR_LINES;+    } else {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+      return;+    }+  } else if (opts->range.type == kObjectTypeInteger) {+    argt |= EX_RANGE | EX_ZEROR;+    def = opts->range.data.integer;+    addr_type_arg = ADDR_LINES;+  } else if (HAS_KEY(opts->range)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+    return;+  }++  if (opts->count.type == kObjectTypeBoolean) {+    if (opts->count.data.boolean) {+      argt |= EX_COUNT | EX_ZEROR | EX_RANGE;+      addr_type_arg = ADDR_OTHER;+      def = 0;+    }+  } else if (opts->count.type == kObjectTypeInteger) {+    argt |= EX_COUNT | EX_ZEROR | EX_RANGE;+    addr_type_arg = ADDR_OTHER;+    def = opts->count.data.integer;+  } else if (HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'count'"");+    return;+  }++  if (opts->addr.type == kObjectTypeString) {+    if (parse_addr_type_arg((char_u *)opts->addr.data.string.data, (int)opts->addr.data.string.size,+                            &addr_type_arg) != OK) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'addr'"");+      return;+    }++    if (addr_type_arg != ADDR_LINES) {+      argt |= EX_ZEROR;+    }+  } else if (HAS_KEY(opts->addr)) {",Just wondering if first checking for the key and then for the type is a better approach/pattern?  If it is not set why check for the type multiple times?. Or maybe I'm missing something ? :) Since it's done with the other options as well.,
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/16678,774970083,2021-12-24T10:34:22Z,test/functional/api/vim_spec.lua,"@@ -2121,6 +2121,9 @@ describe('API', function()        eq({}, meths.get_runtime_file(""foobarlang/"", true))     end)+    it('can handle bad patterns', function()+      eq({}, exec_lua(""return vim.api.nvim_get_runtime_file('{', true)""))",Debugged this and basically the error wasn't being thrown because `msg_list = NULL` for whatever reason. Using `try_enter/try_leave` uses a localized trystate which ensures `msg_list != NULL`.,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15831,775024682,2021-12-24T14:10:20Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.","```suggestion/// @note cleanup_jumplist() is run, which removes duplicate marks, and///       changes win->w_jumplistidx.```",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15831,775024755,2021-12-24T14:10:41Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of jumplist bounds under or over.","```suggestion/// @return  mark, NULL if out of jumplist bounds.```",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15831,775025942,2021-12-24T14:15:34Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of jumplist bounds under or over.+fmark_T *get_jumplist(win_T *win, int count) {-  pos_T *pos;-  xfmark_T *jmp;+  xfmark_T *jmp = NULL; -  cleanup_jumplist(curwin, true);+  cleanup_jumplist(win, true); -  if (curwin->w_jumplistlen == 0) {         // nothing to jump to-    return (pos_T *)NULL;+  if (win->w_jumplistlen == 0) {         // nothing to jump to+    return NULL;   }    for (;;) {-    if (curwin->w_jumplistidx + count < 0-        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen) {-      return (pos_T *)NULL;+    if (win->w_jumplistidx + count < 0+        || win->w_jumplistidx + count >= win->w_jumplistlen) {+      return NULL;     } -    /*-     * if first CTRL-O or CTRL-I command after a jump, add cursor position-     * to list.  Careful: If there are duplicates (CTRL-O immediately after-     * starting Vim on a file), another entry may have been removed.-     */-    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {+    // if first CTRL-O or CTRL-I command after a jump, add cursor position+    // to list.  Careful: If there are duplicates (CTRL-O immediately after+    // starting Vim on a file), another entry may have been removed.+    if (win->w_jumplistidx == win->w_jumplistlen) {       setpcmark();-      --curwin->w_jumplistidx;          // skip the new entry-      if (curwin->w_jumplistidx + count < 0) {-        return (pos_T *)NULL;+      win->w_jumplistidx--;          // skip the new entry+      if (win->w_jumplistidx + count < 0) {+        return NULL;       }     } -    curwin->w_jumplistidx += count;+    win->w_jumplistidx += count; -    jmp = curwin->w_jumplist + curwin->w_jumplistidx;+    jmp = win->w_jumplist + win->w_jumplistidx;     if (jmp->fmark.fnum == 0) {+      // Resolve the fnum (buff number) in the mark before returning it (shada)       fname2fnum(jmp);     }     if (jmp->fmark.fnum != curbuf->b_fnum) {-      // jump to other file-      if (buflist_findnr(jmp->fmark.fnum) == NULL) {  // Skip this one ..+      // Needs to switch buffer, if it can't find it skip the mark+      if (buflist_findnr(jmp->fmark.fnum) == NULL) {         count += count < 0 ? -1 : 1;         continue;       }-      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,-                          0, FALSE) == FAIL) {-        return (pos_T *)NULL;-      }-      // Set lnum again, autocommands my have changed it-      curwin->w_cursor = jmp->fmark.mark;-      pos = (pos_T *)-1;-    } else {-      pos = &(jmp->fmark.mark);     }-    return pos;+    break;   }+  return jmp != NULL ? &jmp->fmark : NULL; } -/*- * Move ""count"" positions in the changelist (count may be negative).- */-pos_T *movechangelist(int count)+/// Get mark in ""count"" position in the |changelist| relative to the current index.+///+/// @note  Changes the win->w_changelistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of bounds under or over.+fmark_T *get_changelist(buf_T *buf, win_T *win, int count) {   int n;+  fmark_T *fm; -  if (curbuf->b_changelistlen == 0) {       // nothing to jump to-    return (pos_T *)NULL;+  if (buf->b_changelistlen == 0) {       // nothing to jump to+    return NULL;   } -  n = curwin->w_changelistidx;+  n = win->w_changelistidx;   if (n + count < 0) {     if (n == 0) {-      return (pos_T *)NULL;+      return NULL;     }     n = 0;-  } else if (n + count >= curbuf->b_changelistlen) {-    if (n == curbuf->b_changelistlen - 1) {-      return (pos_T *)NULL;+  } else if (n + count >= buf->b_changelistlen) {+    if (n == buf->b_changelistlen - 1) {+      return NULL;     }-    n = curbuf->b_changelistlen - 1;+    n = buf->b_changelistlen - 1;   } else {     n += count;   }-  curwin->w_changelistidx = n;-  return &(curbuf->b_changelist[n].mark);+  win->w_changelistidx = n;+  fm = &(buf->b_changelist[n]);+  // Changelist marks are always buffer local, Shada does not set it when loading+  fm->fnum = curbuf->handle;+  return &(buf->b_changelist[n]); } -/*- * Find mark ""c"" in buffer pointed to by ""buf"".- * If ""changefile"" is TRUE it's allowed to edit another file for '0, 'A, etc.- * If ""fnum"" is not NULL store the fnum there for '0, 'A etc., don't edit- * another file.- * Returns:- * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is- *   in another file which can't be gotten. (caller needs to check lnum!)- * - NULL if there is no mark called 'c'.- * - -1 if mark is in other file and jumped there (only if changefile is TRUE)- */-pos_T *getmark_buf(buf_T *buf, int c, bool changefile)+/// Get a named mark.+///+/// All types of marks, even those that are not technically a mark will be returned as such, to then+/// move to the mark use mark_move_to().","Not sure the comment on `mark_move_to` is necessary, but I see the benefit in cross-referencing.What's meant by `not technically a mark`?```suggestion/// All types of marks, even those that are not technically a mark will be returned as such. Use mark_move_to() to move to the mark.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,775030479,2021-12-24T14:36:36Z,src/nvim/api/private/helpers.c,"@@ -605,8 +606,13 @@ void modify_keymap(Buffer buffer, bool is_unmap, String mode, String lhs, String     return;   } -  if (opts != NULL && opts->luaref.type == kObjectTypeLuaRef) {-    lua_funcref = api_new_luaref(opts->luaref.data.luaref);+  if (rhs_obj.type == kObjectTypeString) {+    rhs = rhs_obj.data.string;+  } else if (rhs_obj.type == kObjectTypeLuaRef) {+    lua_funcref = api_new_luaref(rhs_obj.data.luaref);+  } else {+    api_set_error(err, kErrorTypeValidation, ""Unexpected type of rhs provided"");+    return;",I would recommend also adding a `desc` option for when `rhs` is a function (similar to #16752) that is listed when users use `:map {lhs}`.,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15831,775033464,2021-12-24T14:49:59Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of jumplist bounds under or over.+fmark_T *get_jumplist(win_T *win, int count) {-  pos_T *pos;-  xfmark_T *jmp;+  xfmark_T *jmp = NULL; -  cleanup_jumplist(curwin, true);+  cleanup_jumplist(win, true); -  if (curwin->w_jumplistlen == 0) {         // nothing to jump to-    return (pos_T *)NULL;+  if (win->w_jumplistlen == 0) {         // nothing to jump to+    return NULL;   }    for (;;) {-    if (curwin->w_jumplistidx + count < 0-        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen) {-      return (pos_T *)NULL;+    if (win->w_jumplistidx + count < 0+        || win->w_jumplistidx + count >= win->w_jumplistlen) {+      return NULL;     } -    /*-     * if first CTRL-O or CTRL-I command after a jump, add cursor position-     * to list.  Careful: If there are duplicates (CTRL-O immediately after-     * starting Vim on a file), another entry may have been removed.-     */-    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {+    // if first CTRL-O or CTRL-I command after a jump, add cursor position+    // to list.  Careful: If there are duplicates (CTRL-O immediately after+    // starting Vim on a file), another entry may have been removed.+    if (win->w_jumplistidx == win->w_jumplistlen) {       setpcmark();-      --curwin->w_jumplistidx;          // skip the new entry-      if (curwin->w_jumplistidx + count < 0) {-        return (pos_T *)NULL;+      win->w_jumplistidx--;          // skip the new entry+      if (win->w_jumplistidx + count < 0) {+        return NULL;       }     } -    curwin->w_jumplistidx += count;+    win->w_jumplistidx += count; -    jmp = curwin->w_jumplist + curwin->w_jumplistidx;+    jmp = win->w_jumplist + win->w_jumplistidx;     if (jmp->fmark.fnum == 0) {+      // Resolve the fnum (buff number) in the mark before returning it (shada)       fname2fnum(jmp);     }     if (jmp->fmark.fnum != curbuf->b_fnum) {-      // jump to other file-      if (buflist_findnr(jmp->fmark.fnum) == NULL) {  // Skip this one ..+      // Needs to switch buffer, if it can't find it skip the mark+      if (buflist_findnr(jmp->fmark.fnum) == NULL) {         count += count < 0 ? -1 : 1;         continue;       }-      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,-                          0, FALSE) == FAIL) {-        return (pos_T *)NULL;-      }-      // Set lnum again, autocommands my have changed it-      curwin->w_cursor = jmp->fmark.mark;-      pos = (pos_T *)-1;-    } else {-      pos = &(jmp->fmark.mark);     }-    return pos;+    break;   }+  return jmp != NULL ? &jmp->fmark : NULL; } -/*- * Move ""count"" positions in the changelist (count may be negative).- */-pos_T *movechangelist(int count)+/// Get mark in ""count"" position in the |changelist| relative to the current index.+///+/// @note  Changes the win->w_changelistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of bounds under or over.+fmark_T *get_changelist(buf_T *buf, win_T *win, int count) {   int n;+  fmark_T *fm; -  if (curbuf->b_changelistlen == 0) {       // nothing to jump to-    return (pos_T *)NULL;+  if (buf->b_changelistlen == 0) {       // nothing to jump to+    return NULL;   } -  n = curwin->w_changelistidx;+  n = win->w_changelistidx;   if (n + count < 0) {     if (n == 0) {-      return (pos_T *)NULL;+      return NULL;     }     n = 0;-  } else if (n + count >= curbuf->b_changelistlen) {-    if (n == curbuf->b_changelistlen - 1) {-      return (pos_T *)NULL;+  } else if (n + count >= buf->b_changelistlen) {+    if (n == buf->b_changelistlen - 1) {+      return NULL;     }-    n = curbuf->b_changelistlen - 1;+    n = buf->b_changelistlen - 1;   } else {     n += count;   }-  curwin->w_changelistidx = n;-  return &(curbuf->b_changelist[n].mark);+  win->w_changelistidx = n;+  fm = &(buf->b_changelist[n]);+  // Changelist marks are always buffer local, Shada does not set it when loading+  fm->fnum = curbuf->handle;+  return &(buf->b_changelist[n]); } -/*- * Find mark ""c"" in buffer pointed to by ""buf"".- * If ""changefile"" is TRUE it's allowed to edit another file for '0, 'A, etc.- * If ""fnum"" is not NULL store the fnum there for '0, 'A etc., don't edit- * another file.- * Returns:- * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is- *   in another file which can't be gotten. (caller needs to check lnum!)- * - NULL if there is no mark called 'c'.- * - -1 if mark is in other file and jumped there (only if changefile is TRUE)- */-pos_T *getmark_buf(buf_T *buf, int c, bool changefile)+/// Get a named mark.+///+/// All types of marks, even those that are not technically a mark will be returned as such, to then+/// move to the mark use mark_move_to().+/// @param buf  Buffer to get the mark from.+/// @param win  Window to get or calculate the mark from (motion type marks, context mark).+/// @param flag  kMarkAll (default) returns any mark found, if global it resolves it's fnum.+///              kMarkBufLocal return only marks that belong to buf, kMarkAllNoResolve same as+///              kMarkAll but does not resolve the fnum.+///+/// @return          Mark, if not found returns NULL, if kMarkBufLocal returns NULL when+///                  mark->fnum != buf->handle.+/// @return[static]  Marks that need ""wrapping"", are statically allocated see get_local_mark,+///                  get_motion_mark for an explanation.+fmark_T *mark_get(buf_T *buf, win_T *win, MarkGet flag, int name) {-  return getmark_buf_fnum(buf, c, changefile, NULL);+  fmark_T *fm = NULL;+  if (ASCII_ISUPPER(name) || ascii_isdigit(name)) {+    // Global marks+    xfmark_T *xfm = mark_get_global(!(flag & kMarkAllNoResolve), name);+    fm = &xfm->fmark;+    // Only wanted marks belonging to the buffer+    if (flag & kMarkBufLocal && xfm->fmark.fnum != buf->handle) {+      return NULL;+    }+  } else if (name > 0 && name < NMARK_LOCAL_MAX) {+    // Local Marks+    fm = mark_get_local(buf, win, name);+  }+  return fm; } -pos_T *getmark(int c, bool changefile)+/// Get a global mark {A-Z0-9}.+///+/// @note  input must be validated previously otherwise undefined behavior.+/// @param name  the name of the mark.+/// @param resolve  If true try resolving the mark fnum, meaning load the buffer stored in+///                 the mark fname and update the xfmark_T (expensive).+///+/// @return  Mark, undefined behavior if input is not validated.+xfmark_T *mark_get_global(bool resolve, int name) {-  return getmark_buf_fnum(curbuf, c, changefile, NULL);+  xfmark_T *mark;++  assert(ASCII_ISUPPER(name) || ascii_isdigit(name));+  if (ascii_isdigit(name)) {+    name = name - '0' + NMARKS;+  } else {+    name -= 'A';+  }+  mark = &namedfm[name];++  if (resolve && mark->fmark.fnum == 0) {+    // Resolve filename to fnum (SHADA marks)+    fname2fnum(mark);+  }+  return mark; } -pos_T *getmark_buf_fnum(buf_T *buf, int c, bool changefile, int *fnum)++/// Get a local mark (lowercase and symbols).+///+/// Some marks are not actually marks, but positions that are never adjusted or motions presented as+/// marks. It searches first for marks and falls back to finding motion type marks. If it's known+/// ahead of time that the marks is actually a motion use the function mark_get_motion directly.+///+/// @note  Lowercase, last_cursor '""', last insert '^', last change '.' are not statically+/// allocated.+/// @param name  the name of the mark.+/// @param win  window to retrieve marks that belong to it (motions and context mark).+/// @param buf  buf to retrieve marks that belong to it.+///+/// @return  Mark, NULL if not found.+fmark_T *mark_get_local(buf_T *buf, win_T *win, int name) {-  pos_T *posp;-  pos_T *startp, *endp;-  static pos_T pos_copy;+  fmark_T *mark = NULL;+  if (ASCII_ISLOWER(name)) {+    // normal named mark+    mark = &buf->b_namedm[name - 'a'];+    // to start of previous operator+  } else if (name == '[') {+    mark = pos_to_mark(buf, buf->b_op_start);+    // to end of previous operator+  } else if (name == ']') {+    mark = pos_to_mark(buf, buf->b_op_end);+    // visual marks+  } else if (name == '<' || name == '>') {+    mark = mark_get_visual(buf, name);+    // previous context mark+  } else if (name == '\'' || name == '`') {+    // TODO(muniter): w_pcmark should be stored as a mark, but causes a nasty bug.+    mark = pos_to_mark(curbuf, win->w_pcmark);+    // to position when leaving buffer+  } else if (name == '""') {+    mark = &(buf->b_last_cursor);+    // to where last Insert mode stopped+  } else if (name == '^') {+    mark = &(buf->b_last_insert);+    // to where last change was made+  } else if (name == '.') {+    mark = &buf->b_last_change;+    // Mark that are actually not marks but motions, e.g {, }, (, ), ...+  } else {+    mark = mark_get_motion(buf, win, name);+  } -  posp = NULL;+  return mark;+} -  // Check for special key, can't be a mark name and might cause islower()-  // to crash.-  if (c < 0) {-    return posp;-  }-  if (c > '~') {                        // check for islower()/isupper()-  } else if (c == '\'' || c == '`') {   // previous context mark-    pos_copy = curwin->w_pcmark;        // need to make a copy because-    posp = &pos_copy;                   //   w_pcmark may be changed soon-  } else if (c == '""') {                // to pos when leaving buffer-    posp = &(buf->b_last_cursor.mark);-  } else if (c == '^') {                // to where Insert mode stopped-    posp = &(buf->b_last_insert.mark);-  } else if (c == '.') {                // to where last change was made-    posp = &(buf->b_last_change.mark);-  } else if (c == '[') {                // to start of previous operator-    posp = &(buf->b_op_start);-  } else if (c == ']') {                // to end of previous operator-    posp = &(buf->b_op_end);-  } else if (c == '{' || c == '}') {    // to previous/next paragraph-    pos_T pos;+/// Get marks that are actually motions but return them as marks+///+/// Gets the following motions as marks: '{', '}', '(', ')'+/// @param name  name of the mark+/// @param win  window to retrieve the cursor to calculate the mark.+/// @param buf  buf to wrap motion marks with it's buffer number (fm->fnum).+///+/// @return[static] Mark.+fmark_T *mark_get_motion(buf_T *buf, win_T *win, int name)+{+  fmark_T *mark = NULL;+  if (name == '{' || name == '}') {+    // to previous/next paragraph     oparg_T oa;     bool slcb = listcmd_busy;+    listcmd_busy = true;  // avoid that '' is changed -    pos = curwin->w_cursor;-    listcmd_busy = true;            // avoid that '' is changed     if (findpar(&oa.inclusive,-                c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {-      pos_copy = curwin->w_cursor;-      posp = &pos_copy;+                name == '}' ? FORWARD : BACKWARD, 1L, NUL, false)) {+      mark = pos_to_mark(buf, win->w_cursor);     }-    curwin->w_cursor = pos;     listcmd_busy = slcb;-  } else if (c == '(' || c == ')') {  // to previous/next sentence-    pos_T pos;+    // to previous/next sentence+  } else if (name == '(' || name == ')') {     bool slcb = listcmd_busy;+    listcmd_busy = true;  // avoid that '' is changed -    pos = curwin->w_cursor;-    listcmd_busy = true;            // avoid that '' is changed-    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {-      pos_copy = curwin->w_cursor;-      posp = &pos_copy;+    if (findsent(name == ')' ? FORWARD : BACKWARD, 1L)) {+      mark = pos_to_mark(buf, win->w_cursor);     }-    curwin->w_cursor = pos;     listcmd_busy = slcb;-  } else if (c == '<' || c == '>') {  // start/end of visual area-    startp = &buf->b_visual.vi_start;-    endp = &buf->b_visual.vi_end;-    if (((c == '<') == lt(*startp, *endp) || endp->lnum == 0)-        && startp->lnum != 0) {-      posp = startp;+  }+  return mark;+}++/// Get visual marks '<', '>'+///+/// This marks are different to normal marks:+/// 1. Never adjusted.+/// 2. Different behavior depending on editor state (visual mode).+/// 3. Not saved in shada.+/// 4. Re-ordered when defined in reverse.+/// @param buf  Buffer to get the mark from.+/// @param name  Mark name '<' or '>'.+///+/// @return[static]  Mark+fmark_T *mark_get_visual(buf_T *buf, int name)+{+  fmark_T *mark = NULL;+  if (name == '<' || name == '>') {+    // start/end of visual area+    pos_T startp = buf->b_visual.vi_start;+    pos_T endp = buf->b_visual.vi_end;+    if (((name == '<') == lt(startp, endp) || endp.lnum == 0)+        && startp.lnum != 0) {+      mark = pos_to_mark(buf, startp);     } else {-      posp = endp;+      mark = pos_to_mark(buf, endp);     } -    // For Visual line mode, set mark at begin or end of line-    if (buf->b_visual.vi_mode == 'V') {-      pos_copy = *posp;-      posp = &pos_copy;-      if (c == '<') {-        pos_copy.col = 0;+    if (mark != NULL && buf->b_visual.vi_mode == 'V') {+      if (name == '<') {+        mark->mark.col = 0;       } else {-        pos_copy.col = MAXCOL;+        mark->mark.col = MAXCOL;       }-      pos_copy.coladd = 0;+      mark->mark.coladd = 0;     }-  } else if (ASCII_ISLOWER(c)) {      // normal named mark-    posp = &(buf->b_namedm[c - 'a'].mark);-  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    // named file mark-    if (ascii_isdigit(c)) {-      c = c - '0' + NMARKS;-    } else {-      c -= 'A';-    }-    posp = &(namedfm[c].fmark.mark);+  }+  return mark;+}++/// Wrap a pos_T into an fmark_T, used to abstract marks hadnling.+/// @note  view fields are set to 0.+/// @param buf  for fmark->fnum.+/// @param pos  for fmrak->mark.+///+/// @return[static] Mark with the given information.+fmark_T *pos_to_mark(buf_T *buf, pos_T pos)+{+  static fmark_T mark = INIT_FMARK;","This means you can't have two calls to `pos_to_mark` in the same scope, otherwise your data is garbage... and the pointer can't be cached anywhere.  This sounds like a major footgun.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16752,775154368,2021-12-25T16:52:16Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,199 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, Buffer buffer,+                      int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }++  if (HAS_KEY(opts->complete) && !argt) {+    api_set_error(err, kErrorTypeValidation, ""'complete' used without 'nargs'"");+    return;+  }++  if (opts->range.type == kObjectTypeBoolean) {+    if (opts->range.data.boolean) {+      argt |= EX_RANGE;+      addr_type_arg = ADDR_LINES;+    }+  } else if (opts->range.type == kObjectTypeString) {+    if (opts->range.data.string.data[0] == '%' && opts->range.data.string.size == 1) {+      argt |= EX_RANGE | EX_DFLALL;+      addr_type_arg = ADDR_LINES;+    } else {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+      return;+    }+  } else if (opts->range.type == kObjectTypeInteger) {+    argt |= EX_RANGE | EX_ZEROR;+    def = opts->range.data.integer;+    addr_type_arg = ADDR_LINES;+  } else if (HAS_KEY(opts->range)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+    return;+  }++  if (opts->count.type == kObjectTypeBoolean) {+    if (opts->count.data.boolean) {+      argt |= EX_COUNT | EX_ZEROR | EX_RANGE;+      addr_type_arg = ADDR_OTHER;+      def = 0;+    }+  } else if (opts->count.type == kObjectTypeInteger) {+    argt |= EX_COUNT | EX_ZEROR | EX_RANGE;+    addr_type_arg = ADDR_OTHER;+    def = opts->count.data.integer;+  } else if (HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'count'"");+    return;+  }++  if (opts->addr.type == kObjectTypeString) {+    if (parse_addr_type_arg((char_u *)opts->addr.data.string.data, (int)opts->addr.data.string.size,+                            &addr_type_arg) != OK) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'addr'"");+      return;+    }++    if (addr_type_arg != ADDR_LINES) {+      argt |= EX_ZEROR;+    }+  } else if (HAS_KEY(opts->addr)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'addr'"");+    return;+  }++  if (api_object_to_bool(opts->bang, ""bang"", false, err)) {+    if (ERROR_SET(err)) {+      return;+    }++    argt |= EX_BANG;+  }++  if (api_object_to_bool(opts->bar, ""bar"", false, err)) {+    if (ERROR_SET(err)) {+      return;+    }++    argt |= EX_TRLBAR;+  }++  if (api_object_to_bool(opts->register_, ""register"", false, err)) {+    if (ERROR_SET(err)) {+      return;+    }++    argt |= EX_REGSTR;+  }++  bool force = api_object_to_bool(opts->force, ""force"", false, err);+  if (ERROR_SET(err)) {+    return;+  }++  if (opts->complete.type == kObjectTypeLuaRef) {+    compl = EXPAND_USER_LUA;+    compl_luaref = api_new_luaref(opts->complete.data.luaref);+  } else if (opts->complete.type == kObjectTypeString) {+    if (parse_compl_arg((char_u *)opts->complete.data.string.data,+                        (int)opts->complete.data.string.size, &compl, &argt,+                        (char_u **)&compl_arg) != OK) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'complete'"");+      goto out;+    }+  } else if (HAS_KEY(opts->complete)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'complete'"");+    goto out;+  }++  switch (command.type) {+  case kObjectTypeLuaRef:+    luaref = api_new_luaref(command.data.luaref);+    if (opts->desc.type == kObjectTypeString) {+      rep = opts->desc.data.string.data;+    } else {+      snprintf((char *)IObuff, IOSIZE, ""<Lua function %d>"", luaref);+      rep = (char *)IObuff;+    }+    break;+  case kObjectTypeString:+    rep = command.data.string.data;+    break;+  default:+    api_set_error(err, kErrorTypeValidation, ""'command' must be a string or Lua function"");+    goto out;+  }++  buf_T *target_buf = find_buffer_by_handle(buffer, err);+  buf_T *save_curbuf = NULL;",Let's just do `buf_T *save_curbuf = curbuf; curbuf = target_buf` unconditionally. If there's no side-effects there is no need for an if.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16752,775163548,2021-12-25T19:18:44Z,test/functional/lua/api_spec.lua,"@@ -158,13 +158,6 @@ describe('luaeval(vim.api.���)', function()   end)    it('errors out correctly when working with API', function()-    -- Conversion errors-    eq('Vim(call):E5108: Error executing lua [string ""luaeval()""]:1: Cannot convert given lua type',","The second one (the one passing a dict-style table to `nvim__id`) should, and I've restored that test. And I moved the ones that now work (passing a function and passing a list containing a function) into the other test https://github.com/neovim/neovim/pull/16752/commits/67663ca0cdac302638c4cc2fecf6c233b27b327d.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16745,775163740,2021-12-25T19:21:23Z,src/nvim/lua/converter.c,"@@ -1241,8 +1241,18 @@ LuaRef nlua_pop_LuaRef(lua_State *const lstate, Error *err)   type nlua_pop_##type(lua_State *lstate, Error *err) \   FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT \   { \+    if (lua_type(lstate, -1) != LUA_TNUMBER) { \+      lua_pop(lstate, 1); \+      api_set_error(err, kErrorTypeValidation, ""Expected lua number""); \","Lua is a proper noun and should be capitalized:```suggestion      api_set_error(err, kErrorTypeValidation, ""Expected Lua number""); \```This is inconsistent across our code base right now but I'm trying to pedantically correct it one code review at a time.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16800,775566959,2021-12-27T16:28:31Z,runtime/lua/vim/path.lua,"@@ -0,0 +1,148 @@+local uv = vim.loop++local Path = {}+Path.__index = Path++function Path:__tostring()+  return self.path+end++function Path:exists()+  return uv.fs_realpath(self.path) and true+end++function Path:expanduser()+  if self.path == '/' or self.path:match '^~/' then+    return os.getenv('HOME') .. self.path:sub(2)+  else+    return self.path+  end+end++function Path:home()+  return os.getenv('HOME')+end++function Path:parts()+  if self.is_windows then+    return vim.split(self.path, '/')+  else+    local parts = vim.split(self.path, '/')+    if self.path:sub(1, 1) == '/' then+      parts[1] = '/'+    end+    return parts+  end+end++function Path:is_dir()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'directory'+end++function Path:is_file()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'file'+end++function Path:is_absolute()+  if self.is_windows then+    return (self.path:match '^%a:' or self.path:match '^\\\\') or false+  else+    return self.path:match '^/' or false+  end+end++function Path:is_relative_to(root)+  local path_parts = self:parts()+  local root_parts = Path:new(root):parts()++  local root_parts_len = #root_parts+  local path_parts_len = #path_parts++  if root_parts_len > path_parts_len then+    return false+  end++  for i = 1,math.min(root_parts_len, path_parts_len) do+    if root_parts[i] ~= path_parts[i] then+      return false+      end+  end+  return true+end++function Path:is_fs_root()+  if self.is_windows then+    return self.path:match '^%a:$'+  else+    return self.path == '/'+  end+end++function Path:as_uri()+  if self.is_windows then+    return 'file:///' .. self.path+  else+    return 'file://' .. self.path+  end+end++function Path:as_posix()+  return self.path+end++function Path:as_windows()+  return self.path:gsub('/', '\\')+end++function Path:parent()+  local strip_dir_pat = '/([^/]+)$'+  local strip_sep_pat = '/$'+  if not self.path or #self.path == 0 then+    return+  end+  local result = self.path:gsub(strip_sep_pat, ''):gsub(strip_dir_pat, '')+  if #result == 0 then+    if self.is_windows then+      return Path:new(self.path:sub(1, 2))+    else+      return Path:new('/')+    end+  end+  return Path:new(result)+end++function Path:new(path)","https://github.com/neovim/neovim/blob/9804a2870f6f308f788f939f52958e3fbd2adaac/runtime/lua/vim/treesitter/highlighter.lua#L128 I'll suggest using this pattern for consistency, also can just use `self` name in constructor for the object same as in methods.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16800,775578410,2021-12-27T16:59:23Z,runtime/lua/vim/path.lua,"@@ -0,0 +1,148 @@+local uv = vim.loop++local Path = {}+Path.__index = Path++function Path:__tostring()+  return self.path+end++function Path:exists()+  return uv.fs_realpath(self.path) and true+end++function Path:expanduser()+  if self.path == '/' or self.path:match '^~/' then+    return os.getenv('HOME') .. self.path:sub(2)+  else+    return self.path+  end+end++function Path:home()+  return os.getenv('HOME')+end++function Path:parts()+  if self.is_windows then+    return vim.split(self.path, '/')+  else+    local parts = vim.split(self.path, '/')+    if self.path:sub(1, 1) == '/' then+      parts[1] = '/'+    end+    return parts+  end+end++function Path:is_dir()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'directory'+end++function Path:is_file()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'file'+end++function Path:is_absolute()+  if self.is_windows then+    return (self.path:match '^%a:' or self.path:match '^\\\\') or false+  else+    return self.path:match '^/' or false+  end+end++function Path:is_relative_to(root)+  local path_parts = self:parts()+  local root_parts = Path.new(root):parts()++  local root_parts_len = #root_parts+  local path_parts_len = #path_parts++  if root_parts_len > path_parts_len then+    return false+  end++  for i = 1,math.min(root_parts_len, path_parts_len) do+    if root_parts[i] ~= path_parts[i] then+      return false+      end+  end+  return true+end++function Path:is_fs_root()+  if self.is_windows then+    return self.path:match '^%a:$'+  else+    return self.path == '/'+  end+end++function Path:as_uri()+  if self.is_windows then+    return 'file:///' .. self.path+  else+    return 'file://' .. self.path+  end+end++function Path:as_posix()+  return self.path+end++function Path:as_windows()+  return self.path:gsub('/', '\\')+end++function Path:parent()+  local strip_dir_pat = '/([^/]+)$'+  local strip_sep_pat = '/$'+  if not self.path or #self.path == 0 then+    return+  end+  local result = self.path:gsub(strip_sep_pat, ''):gsub(strip_dir_pat, '')+  if #result == 0 then+    if self.is_windows then+      return Path.new(self.path:sub(1, 2))+    else+      return Path.new('/')+    end+  end+  return Path.new(result)+end++function Path.new(path)+  local path_obj = {+    is_windows = uv.os_uname().version:match('Windows')+  }+  local self = setmetatable(path_obj, Path)","better but could perhaps use```local self = setmetatable({    is_windows = uv.os_uname().version:match('Windows');    path = path;}, Path)```and skip the extra temporary",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16800,775585491,2021-12-27T17:23:20Z,runtime/lua/vim/path.lua,"@@ -0,0 +1,146 @@+local uv = vim.loop++local Path = {}+Path.__index = Path++function Path:__tostring()+  return self.path+end++function Path:exists()+  return uv.fs_realpath(self.path) and true+end++function Path:expanduser()+  if self.path == '/' or self.path:match '^~/' then+    return os.getenv('HOME') .. self.path:sub(2)+  else+    return self.path+  end+end++function Path:home()+  return os.getenv('HOME')+end++function Path:parts()+  if self.is_windows then+    return vim.split(self.path, '/')+  else+    local parts = vim.split(self.path, '/')+    if self.path:sub(1, 1) == '/' then+      parts[1] = '/'+    end+    return parts+  end+end++function Path:is_dir()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'directory'+end++function Path:is_file()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'file'+end++function Path:is_absolute()+  if self.is_windows then+    return (self.path:match '^%a:' or self.path:match '^\\\\') or false+  else+    return self.path:match '^/' or false+  end+end++function Path:is_relative_to(root)+  local path_parts = self:parts()+  local root_parts = Path.new(root):parts()++  local root_parts_len = #root_parts+  local path_parts_len = #path_parts++  if root_parts_len > path_parts_len then+    return false+  end++  for i = 1,math.min(root_parts_len, path_parts_len) do+    if root_parts[i] ~= path_parts[i] then+      return false+      end+  end+  return true+end++function Path:is_fs_root()+  if self.is_windows then+    return self.path:match '^%a:$'+  else+    return self.path == '/'+  end+end++function Path:as_uri()+  if self.is_windows then+    return 'file:///' .. self.path+  else+    return 'file://' .. self.path+  end+end++function Path:as_posix()+  return self.path+end++function Path:as_windows()+  return self.path:gsub('/', '\\')+end++function Path:parent()+  local strip_dir_pat = '/([^/]+)$'+  local strip_sep_pat = '/$'+  if not self.path or #self.path == 0 then+    return+  end+  local result = self.path:gsub(strip_sep_pat, ''):gsub(strip_dir_pat, '')+  if #result == 0 then+    if self.is_windows then+      return Path.new(self.path:sub(1, 2))+    else+      return Path.new('/')+    end+  end+  return Path.new(result)+end++function Path.new(path)","I asked on Matrix what style of string library core preferred, string or path object. We discussed it briefly and the sentiment was to use a Plenary/Python style library which used Path objects (https://github.com/nvim-lua/plenary.nvim/blob/master/lua/plenary/path.lua).I don't have particularly strong opinions either way. One advantage of a Path object is that we can always ensure that path separators and drive letters are sanitized. This is somewhat of a headache due to the behavior of buf_get_name, which can return either forward or backwards slash delineated paths depending on the `shellescape` option, if you're opening the path from `netrw`, a location handler in the LSP code, etc. Same situation with drive letters, see https://github.com/neovim/neovim/issues/16331. Even if these were fixed, it's nice to be able to control the internal representation of a path so all of the utilities ""just work"" instead of having to either sanitize the input string on each invocation of a path utility, or assume the user always provides well-formed, forward delineated paths.I am mixed, because I also like the simplicity of string based path utilities. ",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/14537,775665775,2021-12-27T22:53:22Z,src/nvim/diff.c,"@@ -1753,11 +1758,534 @@ void diff_clear(tabpage_T *tp)   diff_T *next_p;   for (p = tp->tp_first_diff; p != NULL; p = next_p) {     next_p = p->df_next;+    xfree(p->df_comparisonlines);     xfree(p);   }   tp->tp_first_diff = NULL; } +///+/// return true if the options are set to use diff linematch+///+bool diff_linematch(diff_T *dp)+{+  if (!(diff_flags & DIFF_LINEMATCH)) {+        return 0;+  }+  // are there more than three diff buffers?+  int diffbuffers = 0;+  int tsize = 0;+  for (int i = 0; i < DB_COUNT; i++) {+    if ( curtab->tp_diffbuf[i] != NULL ) {+      diffbuffers++;+      tsize += dp->df_count[i];+    }+  }+  // avoid allocating a huge array because it will lag+  if (tsize > linematch_lines) {+    return 0;+  }+  if (diffbuffers <= 3) {  // can diff up to 3 buffers+    return 1;+  }+  return 0;+}++///+/// Count the number of virtual (filler + non filler) lines between ""start"" and+/// ""endline"" in ""win""+///+/// @param win+/// @param start+/// @param endline+int count_virtual_lines(win_T *win, linenr_T start, linenr_T endline)+{+  int virtual_lines = 0;+  for (int k = start; k <= endline; k++) {+    int n = diff_check(win, k, NULL);+    if (n > 0) {+        virtual_lines+=n;  // filler lines+    }+    virtual_lines++;+  }+  return virtual_lines;+}+/// in ""win"" window, move from ""lnum"" down by the amount ""virtual_lines""+/// and return the number of real lines moved. if a non null pointer is+/// passed to ""line_new_virtualp"", it will be set to the number of virtual+/// lines moved+///+/// @param win+/// @param lnum+/// @param virtual_lines+/// @param line_new_virtualp+int count_virtual_to_real(win_T *win, const linenr_T lnum,+                          const int virtual_lines, int *line_new_virtualp )+{+  int real_offset = 0;+  int virtual_offset = 0;+  while (1) {+    int n = diff_check(win, lnum+real_offset, NULL);+    virtual_offset++;+    if (n > 0) {+        virtual_offset+=n;  // filler lines+    }+    if (virtual_offset > virtual_lines) {+        break;+    }+    real_offset++;+  }+  if ( line_new_virtualp != NULL ) {+    (*line_new_virtualp) = virtual_offset;+  }+  return real_offset;+}++long count_matched_chars_f(char_u** stringps, int* fromValues, int n, int*** comparison_mem) {+","```suggestionlong count_matched_chars_f(char_u **stringps, int *fromValues, int n, int ***comparison_mem){```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/14537,775667654,2021-12-27T23:06:23Z,src/nvim/diff.c,"@@ -1753,11 +1758,534 @@ void diff_clear(tabpage_T *tp)   diff_T *next_p;   for (p = tp->tp_first_diff; p != NULL; p = next_p) {     next_p = p->df_next;+    xfree(p->df_comparisonlines);     xfree(p);   }   tp->tp_first_diff = NULL; } +///+/// return true if the options are set to use diff linematch+///+bool diff_linematch(diff_T *dp)+{+  if (!(diff_flags & DIFF_LINEMATCH)) {+        return 0;+  }+  // are there more than three diff buffers?+  int diffbuffers = 0;+  int tsize = 0;+  for (int i = 0; i < DB_COUNT; i++) {+    if ( curtab->tp_diffbuf[i] != NULL ) {+      diffbuffers++;+      tsize += dp->df_count[i];+    }+  }+  // avoid allocating a huge array because it will lag+  if (tsize > linematch_lines) {+    return 0;+  }+  if (diffbuffers <= 3) {  // can diff up to 3 buffers+    return 1;+  }+  return 0;+}++///+/// Count the number of virtual (filler + non filler) lines between ""start"" and+/// ""endline"" in ""win""+///+/// @param win+/// @param start+/// @param endline+int count_virtual_lines(win_T *win, linenr_T start, linenr_T endline)+{+  int virtual_lines = 0;+  for (int k = start; k <= endline; k++) {+    int n = diff_check(win, k, NULL);+    if (n > 0) {+        virtual_lines+=n;  // filler lines+    }+    virtual_lines++;+  }+  return virtual_lines;+}+/// in ""win"" window, move from ""lnum"" down by the amount ""virtual_lines""+/// and return the number of real lines moved. if a non null pointer is+/// passed to ""line_new_virtualp"", it will be set to the number of virtual+/// lines moved+///+/// @param win+/// @param lnum+/// @param virtual_lines+/// @param line_new_virtualp+int count_virtual_to_real(win_T *win, const linenr_T lnum,+                          const int virtual_lines, int *line_new_virtualp )+{+  int real_offset = 0;+  int virtual_offset = 0;+  while (1) {+    int n = diff_check(win, lnum+real_offset, NULL);+    virtual_offset++;+    if (n > 0) {+        virtual_offset+=n;  // filler lines+    }+    if (virtual_offset > virtual_lines) {+        break;+    }+    real_offset++;+  }+  if ( line_new_virtualp != NULL ) {+    (*line_new_virtualp) = virtual_offset;+  }+  return real_offset;+}++long count_matched_chars_f(char_u** stringps, int* fromValues, int n, int*** comparison_mem) {++  int matched_chars = 0, pointerindex = 0, matched = 0;+  for (int i = 0; i < n; i++) {+    for (int j = i + 1; j < n; j++) {+      if ( stringps[i] != NULL && stringps[j] != NULL ) {+        int i1 = fromValues[i]; // index of where to get the buffer+        int j1 = fromValues[j];+        if (comparison_mem[pointerindex][i1][j1] == -1) {+          comparison_mem[pointerindex][i1][j1] = count_matched_chars(+              stringps[i], stringps[j]+              );+        }+        matched ++;+        matched_chars += comparison_mem[pointerindex][i1][j1];+      }+      pointerindex++;+    }+  }+  if (matched == 3) {+    matched_chars *= 2, matched_chars /= 3;+  }++  return matched_chars;+}++/// return the number of matching characters between two strings+///+/// @param s1+/// @param s2+long count_matched_chars(const char_u *s1, const char_u *s2)+{+  long l1 = (long)STRLEN(s1), l2 = (long)STRLEN(s2);+  if ( diff_flags & DIFF_IWHITE || diff_flags & DIFF_IWHITEALL+      || diff_flags & DIFF_ICASE ) {+    bool iwhite = (diff_flags & DIFF_IWHITEALL || diff_flags & DIFF_IWHITE);+    // the newly processed strings that will be compared+    char_u *s1_proc = xmalloc(STRLEN(s1) * sizeof(char_u));+    char_u *s2_proc = xmalloc(STRLEN(s2) * sizeof(char_u));+    // delete the white space characters,+    // and/or replace all upper case with lower+    char_u *strsproc[2] = { s1_proc, s2_proc };+    const char_u *strsorig[2] = { s1, s2 };+    long slen[2] = { l1, l2 };+    for (int k = 0; k < 2; k++) {+      int d = 0, i = 0;+      while (d+i < slen[k]) {+        if ((iwhite)?(strsorig[k][i+d] != ' ' && strsorig[k][i+d] != '\t'):1) {+          strsproc[k][i] = (diff_flags & DIFF_ICASE)?+           (tolower(strsorig[k][i+d])):(strsorig[k][i+d]);+          i++;+        } else { d++; }+      }+      strsproc[k][i] = '\0';+    }+    long matching = matching_characters(s1_proc, s2_proc);+    xfree(s1_proc), xfree(s2_proc);+    return matching;+  }+  // compare strings without changing the white space / case+  return matching_characters(s1, s2);+}++void update_path_flat(diffcomparisonpath_flat_T* diffcomparisonpath_flat, int score, int to, int from, const int choice) {+  for (int k = 0; k < diffcomparisonpath_flat[from].df_path_index; k++) {+    diffcomparisonpath_flat[to].decision[k] = diffcomparisonpath_flat[from].decision[k];+  }+  diffcomparisonpath_flat[to].df_path_index = diffcomparisonpath_flat[from].df_path_index;++  diffcomparisonpath_flat[to].df_lev_score = score;+  diffcomparisonpath_flat[to].decision[diffcomparisonpath_flat[to].df_path_index] = choice;+  diffcomparisonpath_flat[to].df_path_index++;+}+/// return matching characters between ""s1"" and ""s2""+/// between string ""s1"" and ""s2"".+/// Consider the case of two strings 'AAACCC' and 'CCCAAA', the+/// return value from this function will be 3, either to match+/// the 3 C's, or the 3 A's.+///+/// @param s1+/// @param s2+long matching_characters(const char_u *s1, const char_u *s2)+{+    long s1len = (long)STRLEN(s1), s2len = (long)STRLEN(s2);+    long *matrix[2];+    matrix[0] = xmalloc(sizeof(long) * (s2len+1));+    matrix[1] = xmalloc(sizeof(long) * (s2len+1));+    bool icur = 1;  // save space by storing only two rows for i axis+    for (long i = 0; i <= s1len; i++) {+      icur = !icur;+      for (long j = 0; j <= s2len; j++) {+        if (i == 0) {+          matrix[icur][j] = 0;+        } else if (j == 0) {+          matrix[icur][j] = 0;+        } else {+          matrix[icur][j] = 0;+          // skip char in s1+          if (matrix[!icur][j] > matrix[icur][j]) {+            matrix[icur][j] = matrix[!icur][j];+          }+          // skip char in s2+          if (matrix[icur][j-1] > matrix[icur][j]) {+            matrix[icur][j] = matrix[icur][j-1];+          }+          // compare char in s1 and s2+          if ( (s1[i-1] == s2[j-1])+              && (matrix[!icur][j-1] + 1) > matrix[icur][j] ) {+            matrix[icur][j] = matrix[!icur][j-1] + 1;+          }+        }+      }+    }+    long rvalue = matrix[icur][s2len];+    xfree(matrix[0]), xfree(matrix[1]);+    return rvalue;+}+int unwrap_indexes(int* values, df_iterators_T df_iterators, diff_T* dp) {+  int num_unwrap_scalar = 1;+  int path_index = 0;+  for (int k = 0; k < df_iterators.n; k++) {+    num_unwrap_scalar *= ( dp->df_count[df_iterators.buffers[k]] + 1 );+  }+  for (int k = 0; k < df_iterators.n; k++) {+    num_unwrap_scalar = num_unwrap_scalar / (dp->df_count[df_iterators.buffers[k]] + 1);++    if (k == 0) {+      // space optimization+      path_index += num_unwrap_scalar * ( values[k] % 2 );+    } else {+      path_index += num_unwrap_scalar * values[k];+    }+  }+  return path_index;+}++void try_possible_paths(df_iterators_T df_iterators, paths_T paths, int index, int* choice, diff_T* dp, diffcomparisonpath_flat_T* diffcomparisonpath_flat, int*** comparison_mem) {+  if (index == paths.n) {+    if ((*choice) > 0) {+      int* fromValues = xmalloc(sizeof(int) * df_iterators.n);+      int* toValues = xmalloc(sizeof(int) * df_iterators.n);+      char_u** stringps = xmalloc(sizeof(char_u*) * df_iterators.n);+      for ( int k = 0; k < df_iterators.n; k++ ) {+        fromValues[k] = df_iterators.iterators[k];+        toValues[k] = df_iterators.iterators[k];+        // get the index at all of the places+        if ( (*choice) & (1 << k) ) {+          fromValues[k]--;+          stringps[k] = ml_get_buf(+              curtab->tp_diffbuf[df_iterators.buffers[k]],+              dp->df_lnum[df_iterators.buffers[k]] + df_iterators.iterators[k] - 1,+              false+              );+        } else {+          stringps[k] = NULL;+        }+      }+      int unwrapped_index_from = unwrap_indexes(fromValues, df_iterators, dp);+      int unwrapped_index_to = unwrap_indexes(toValues, df_iterators, dp);+      long matched_chars = count_matched_chars_f(+          stringps, fromValues, df_iterators.n, comparison_mem+          );","```suggestion      long matched_chars = count_matched_chars_f(          stringps, fromValues, df_iterators.n, comparison_mem);```",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/14537,775678357,2021-12-28T00:22:08Z,src/nvim/buffer_defs.h,"@@ -897,25 +897,76 @@ struct file_buffer {  */ #define DB_COUNT 8     // up to four buffers can be diff'ed -/*- * Each diffblock defines where a block of lines starts in each of the buffers- * and how many lines it occupies in that buffer.  When the lines are missing- * in the buffer the df_count[] is zero.  This is all counted in- * buffer lines.- * There is always at least one unchanged line in between the diffs.- * Otherwise it would have been included in the diff above or below it.- * df_lnum[] + df_count[] is the lnum below the change.  When in one buffer- * lines have been inserted, in the other buffer df_lnum[] is the line below- * the insertion and df_count[] is zero.  When appending lines at the end of- * the buffer, df_lnum[] is one beyond the end!- * This is using a linked list, because the number of differences is expected- * to be reasonable small.  The list is sorted on lnum.- */+typedef struct df_iterators_S df_iterators_T;+struct df_iterators_S {+  int* iterators;  // current index of this path+  int* buffers;  // mapping to dp buffer+  int n;+};++typedef struct paths_S paths_T;+struct paths_S {+  int* index;  // current index of this path+  int n;+};++typedef struct diffcomparisonpath_flat_S diffcomparisonpath_flat_T;+struct diffcomparisonpath_flat_S{+  int *decision;  // to keep track of this path traveled+  int df_lev_score;  // to keep track of the total score of this path+  int df_path_index;  // current index of this path+};++// contains the information for how to construct diff views when linematch+// diffopt is enabled, it is populated after running linematch_3buffers or+// linematch_2buffers.+typedef struct df_linecompare_S df_linecompare_T;+struct df_linecompare_S{+  bool df_newline;  // is this line skipped in other buffers?+  int df_filler;  // how many filler lines above this?+  int df_compare[DB_COUNT];  // which line to compare to in other buffer+};++// Each diffblock defines where a block of lines starts in each of the buffers+// and how many lines it occupies in that buffer.  When the lines are missing+// in the buffer the df_count[] is zero.  This is all counted in+// buffer lines.+// There is always at least one unchanged line in between the diffs.+// Otherwise it would have been included in the diff above or below it.+// df_lnum[] + df_count[] is the lnum below the change.  When in one buffer+// lines have been inserted, in the other buffer df_lnum[] is the line below+// the insertion and df_count[] is zero.  When appending lines at the end of+// the buffer, df_lnum[] is one beyond the end!+// This is using a linked list, because the number of differences is expected+// to be reasonable small.  The list is sorted on lnum.+ typedef struct diffblock_S diff_T; struct diffblock_S {   diff_T *df_next;   linenr_T df_lnum[DB_COUNT];           // line number in buffer   linenr_T df_count[DB_COUNT];          // nr of inserted/changed lines++  // diffopt linematch algorithm parameter: marks when the algorithm for diff+  // alignment has been ran the algorithm will run only when this diff is+  // scrolled into view, or if it has been changed+  int df_redraw;++  // diffopt linematch algorithm parameter: mark the current buffer ids to+  // correlate them with axes of 2d or 3d tensor (0,1, or 2)+  int df_valid_buffers[DB_COUNT];++  //  diffopt linematch algorithm parameter: count the current buffers+  //  with diffthis enabled. If it's more than 3, cannot use linematch+  //  algorithm","```suggestion  // diffopt linematch algorithm parameter: count the current buffers  // with diffthis enabled. If it's more than 3, cannot use linematch  // algorithm```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16752,776024043,2021-12-28T18:18:30Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,187 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }","I think it would be better to switch the order of this condition by basically moving all the way to the top```c    if (HAS_KEY(opts->nargs)) {      if (opts->nargs.type == kObjectTypeInteger) {        // ...      } else if (opts->nargs.type == kObjectTypeString) {        // ..      } else {        // error      }    }```That way you won't be trying to de-reference `nargs` if it doesn't exist, and you have a secure `else` branch that acts as a proper catch-all. It's also probably easier to read as a bonus! ���� ",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16752,776024523,2021-12-28T18:20:08Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,187 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }++  if (HAS_KEY(opts->complete) && !argt) {+    api_set_error(err, kErrorTypeValidation, ""'complete' used without 'nargs'"");+    return;+  }++  if (opts->range.type == kObjectTypeBoolean) {+    if (opts->range.data.boolean) {+      argt |= EX_RANGE;+      addr_type_arg = ADDR_LINES;+    }+  } else if (opts->range.type == kObjectTypeString) {+    if (opts->range.data.string.data[0] == '%' && opts->range.data.string.size == 1) {+      argt |= EX_RANGE | EX_DFLALL;+      addr_type_arg = ADDR_LINES;+    } else {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+      return;+    }+  } else if (opts->range.type == kObjectTypeInteger) {+    argt |= EX_RANGE | EX_ZEROR;+    def = opts->range.data.integer;+    addr_type_arg = ADDR_LINES;+  } else if (HAS_KEY(opts->range)) {","This would also benefit from switching the condition order, same as `opts->nargs`.",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16752,776028670,2021-12-28T18:33:33Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,187 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }++  if (HAS_KEY(opts->complete) && !argt) {+    api_set_error(err, kErrorTypeValidation, ""'complete' used without 'nargs'"");+    return;+  }++  if (opts->range.type == kObjectTypeBoolean) {+    if (opts->range.data.boolean) {+      argt |= EX_RANGE;+      addr_type_arg = ADDR_LINES;+    }+  } else if (opts->range.type == kObjectTypeString) {+    if (opts->range.data.string.data[0] == '%' && opts->range.data.string.size == 1) {+      argt |= EX_RANGE | EX_DFLALL;+      addr_type_arg = ADDR_LINES;+    } else {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+      return;+    }+  } else if (opts->range.type == kObjectTypeInteger) {+    argt |= EX_RANGE | EX_ZEROR;+    def = opts->range.data.integer;+    addr_type_arg = ADDR_LINES;+  } else if (HAS_KEY(opts->range)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'range'"");+    return;+  }++  if (opts->count.type == kObjectTypeBoolean) {+    if (opts->count.data.boolean) {+      argt |= EX_COUNT | EX_ZEROR | EX_RANGE;+      addr_type_arg = ADDR_OTHER;+      def = 0;+    }+  } else if (opts->count.type == kObjectTypeInteger) {+    argt |= EX_COUNT | EX_ZEROR | EX_RANGE;+    addr_type_arg = ADDR_OTHER;+    def = opts->count.data.integer;+  } else if (HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'count'"");+    return;+  }++  if (opts->addr.type == kObjectTypeString) {+    if (parse_addr_type_arg((char_u *)opts->addr.data.string.data, (int)opts->addr.data.string.size,+                            &addr_type_arg) != OK) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'addr'"");+      return;+    }++    if (addr_type_arg != ADDR_LINES) {+      argt |= EX_ZEROR;+    }+  } else if (HAS_KEY(opts->addr)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'addr'"");+    return;+  }++  if (api_object_to_bool(opts->bang, ""bang"", false, err)) {+    if (ERROR_SET(err)) {+      return;+    }++    argt |= EX_BANG;+  }++  if (api_object_to_bool(opts->bar, ""bar"", false, err)) {+    if (ERROR_SET(err)) {+      return;+    }++    argt |= EX_TRLBAR;+  }++  if (api_object_to_bool(opts->register_, ""register"", false, err)) {+    if (ERROR_SET(err)) {+      return;+    }++    argt |= EX_REGSTR;+  }",I think these are done backwards:https://github.com/neovim/neovim/blob/0d7a97224f28cdf47d7ecc80b6d300c8c67c0b29/src/nvim/api/private/helpers.c#L1199-L1205Meaning that you'd never have the error inside the condition itself.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16752,776031831,2021-12-28T18:44:10Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,187 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }","@muniter made the same comment [here](https://github.com/neovim/neovim/pull/16752#discussion_r774874079).`opts->nargs` always exists. If ""nargs"" isn't present in the options dict, it just has type `kObjectTypeNil`. `HAS_KEY` is simply a check for `opts->nargs.type != kObjectTypeNil`. So your suggestion would be transforming the check to```cif (opts->nargs.type != kObjectTypeNil) {  if (opts->nargs.type == kObjectTypeInteger)```but this adds an unnecessary check as well as unnecessary indentation, since the current implementation is just```if (opts->nargs.type == kObjectTypeInteger) {  ...} else if (opts->nargs.type != kObjectTypeNil) {  // ERROR}```i.e. the pattern is ""check for valid types, and if the value is not nil and also not a valid type it's an error"".",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16761,776033816,2021-12-28T18:50:32Z,Makefile,"@@ -45,21 +42,12 @@ ifneq (1,$(words [$(DEPS_BUILD_DIR)]))   $(error DEPS_BUILD_DIR must not contain whitespace) endif -ifeq (,$(BUILD_TOOL))-  ifeq (Ninja,$(CMAKE_GENERATOR))-    ifneq ($(shell $(CMAKE_PRG) --help 2>/dev/null | grep Ninja),)-      BUILD_TOOL = ninja-    else-      # User's version of CMake doesn't support Ninja-      BUILD_TOOL = $(MAKE)-      CMAKE_GENERATOR := Unix Makefiles-    endif-  else-    BUILD_TOOL = $(MAKE)-  endif+ifeq (Ninja,$(CMAKE_GENERATOR))+  BUILD_TOOL = ninja+else+  BUILD_TOOL = $(MAKE) endif - # Only need to handle Ninja here.  Make will inherit the VERBOSE variable, and the -j, -l, and -n flags. ifeq ($(CMAKE_GENERATOR),Ninja)",Merge with the condition above.,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16761,776034614,2021-12-28T18:53:18Z,Makefile,"@@ -89,10 +75,10 @@ endif SINGLE_MAKE = export MAKEFLAGS= ; $(MAKE)  nvim: build/.ran-cmake deps-	+$(BUILD_TOOL) -C build+	$(BUILD_TOOL) -C build  libnvim: build/.ran-cmake deps-	+$(BUILD_TOOL) -C build libnvim+	$(BUILD_TOOL) -C build libnvim  cmake: 	touch CMakeLists.txt","This target looks useless, so it should probably go```suggestion```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16752,776042810,2021-12-28T19:21:09Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,187 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }","I'd choose security over style in this case, since this is actually breaking a rule:> All if������else if constructs shall be terminated with an else statementYou could always check for errors and bail out as early as possible. Generally speaking, I think this function might be trying to do too much. I would break it into at 3-4 smaller functions with each handling a smaller an argument type. That way it's more modular and easier to swap in the future, and helps reduce the cyclomatic complexity.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16752,776059220,2021-12-28T20:17:54Z,src/nvim/api/private/helpers.c,"@@ -1342,3 +1346,187 @@ const char *get_default_stl_hl(win_T *wp)     return ""StatusLineNC"";   } }++void add_user_command(String name, Object command, Dict(user_command) *opts, int flags, Error *err)+{+  uint32_t argt = 0;+  long def = -1;+  cmd_addr_T addr_type_arg = ADDR_NONE;+  int compl = EXPAND_NOTHING;+  char *compl_arg = NULL;+  char *rep = NULL;+  LuaRef luaref = LUA_NOREF;+  LuaRef compl_luaref = LUA_NOREF;++  if (HAS_KEY(opts->range) && HAS_KEY(opts->count)) {+    api_set_error(err, kErrorTypeValidation, ""'range' and 'count' are mutually exclusive"");+    return;+  }++  if (opts->nargs.type == kObjectTypeInteger) {+    switch (opts->nargs.data.integer) {+    case 0:+      // Default value, nothing to do+      break;+    case 1:+      argt |= EX_EXTRA | EX_NOSPC | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (opts->nargs.type == kObjectTypeString) {+    if (opts->nargs.data.string.size > 1) {+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    }++    switch (opts->nargs.data.string.data[0]) {+    case '*':+      argt |= EX_EXTRA;+      break;+    case '?':+      argt |= EX_EXTRA | EX_NOSPC;+      break;+    case '+':+      argt |= EX_EXTRA | EX_NEEDARG;+      break;+    default:+      api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+      return;+    }+  } else if (HAS_KEY(opts->nargs)) {+    api_set_error(err, kErrorTypeValidation, ""Invalid value for 'nargs'"");+    return;+  }","This should not be changed. Eventually keyset dicts will gain some typing support, and then refactoring code will be _much_ easier if we follow a consistent pattern instead of engaging in _ad-hoc_ reasoning in every single if-else stament for keyset arg parsing. There is no issue neither with ""security"" nor ""style"" here.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16800,776335135,2021-12-29T13:49:02Z,runtime/lua/vim/path.lua,"@@ -0,0 +1,146 @@+local uv = vim.loop++local Path = {}+Path.__index = Path++function Path:__tostring()+  return self.path+end++function Path:exists()+  return uv.fs_realpath(self.path) and true+end++function Path:expanduser()+  if self.path:match '^~/' then+    return os.getenv('HOME') .. self.path:sub(2)+  else+    return self.path+  end+end++function Path:home()+  return os.getenv('HOME')+end++function Path:parts()+  if self.is_windows then+    return vim.split(self.path, '/')+  else+    local parts = vim.split(self.path, '/')+    if self.path:sub(1, 1) == '/' then+      parts[1] = '/'+    end+    return parts+  end+end++function Path:is_dir()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'directory'+end++function Path:is_file()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'file'+end++function Path:is_absolute()+  if self.is_windows then+    return (self.path:match '^%a:' or self.path:match '^\\\\') or false+  else+    return self.path:match '^/' or false+  end+end++function Path:is_relative_to(root)+  local path_parts = self:parts()+  local root_parts = Path.new(root):parts()++  local root_parts_len = #root_parts+  local path_parts_len = #path_parts++  if root_parts_len > path_parts_len then+    return false+  end++  for i = 1,math.min(root_parts_len, path_parts_len) do+    if root_parts[i] ~= path_parts[i] then+      return false+      end+  end+  return true+end++function Path:is_fs_root()+  if self.is_windows then+    return self.path:match '^%a:$'+  else+    return self.path == '/'+  end+end++function Path:as_uri()+  if self.is_windows then+    return 'file:///' .. self.path+  else+    return 'file://' .. self.path+  end+end++function Path:as_posix()+  return self.path+end++function Path:as_windows()+  return self.path:gsub('/', '\\')+end++function Path:parent()+  local strip_dir_pat = '/([^/]+)$'+  local strip_sep_pat = '/$'+  if not self.path or #self.path == 0 then+    return+  end+  local result = self.path:gsub(strip_sep_pat, ''):gsub(strip_dir_pat, '')+  if #result == 0 then+    if self.is_windows then+      return Path.new(self.path:sub(1, 2))+    else+      return Path.new('/')+    end+  end+  return Path.new(result)+end++function Path.new(path)+  local self = setmetatable({+    is_windows = uv.os_uname().version:match('Windows') or false,+    path = path+  }, Path)++  if self.is_windows then+    if self.is_absolute() then+      path = path:sub(1, 1):upper() .. path:sub(2)+    end+    self.path = path:gsub('\\', '/')+  end++  return self+end++setmetatable(Path, {+  __call = function(_, path)+    return Path.new(path)+  end+})++local function join(...)+  local to_join = vim.map(tostring, vim.tbl_flatten(...))+  return Path.new(table.concat(to_join, '/'))+end++return {+  Path=Path,+  join=join",How would one use this to solve use cases like here:https://github.com/neovim/neovim/blob/c46f7caad0bef587d189de2310435f48f9bd9ad8/runtime/lua/vim/lsp/log.lua#L21-L25Where you want to have system specific separators? There is `as_windows()` and `as_posix` but this requires the call-site to know which system they're on. Maybe we'd need something as like `as_native()` ?Bringing this up because this would be the nr1 use-case for me currently. For everything else it's usually easy enough to use `fnamemodify` or the vim.loop functions.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16594,776359517,2021-12-29T14:43:14Z,src/nvim/api/keysets.lua,"@@ -29,6 +29,9 @@ return {     ""script"";     ""expr"";     ""unique"";+    ""callback"";+    ""cb"";","These two look duplicate, we should settle for one. (normally we would use `on_xx` for callback args though I am not sure what xx would be..)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,776383501,2021-12-29T15:37:12Z,src/nvim/api/private/helpers.c,"@@ -604,6 +605,12 @@ void modify_keymap(Buffer buffer, bool is_unmap, String mode, String lhs, String     return;   } +  if (opts != NULL && opts->callback.type == kObjectTypeLuaRef) {+    lua_funcref = opts->callback.data.luaref;",I think we should use `api_new_luaref` here rather than in `getchar.c`.```suggestion    lua_funcref = api_new_luaref(opts->callback.data.luaref);```Will also need to add the corresponding cleanup to the `fail_and_free` label:```cNLUA_CLEAR_REF(lua_funcref);```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,776388767,2021-12-29T15:49:16Z,src/nvim/getchar.c,"@@ -15,6 +15,7 @@ #include <stdbool.h> #include <string.h> +#include ""nvim/api/private/helpers.h""","Including private API helpers in `getchar` seems like a code smell to me. It looks like this is needed for `api_free_object` and `api_clear_error`, but that should be done in a separate function in the API layer rather than here so that we can maintain clean separation.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,776391443,2021-12-29T15:55:35Z,src/nvim/getchar.c,"@@ -3934,15 +4007,33 @@ static char_u *eval_map_expr(char_u *str, int c)   save_cursor = curwin->w_cursor;   save_msg_col = msg_col;   save_msg_row = msg_row;-  p = eval_to_string(expr, NULL, false);+  if (mp->m_luaref != LUA_NOREF) {+    Error err = ERROR_INIT;+    Array args = ARRAY_DICT_INIT;+    if (mp->m_expr) {+      Object ret = nlua_call_ref(mp->m_luaref, NULL, args, true, &err);+      if (ret.type == kObjectTypeString) {+        p = (char_u *)xstrndup(ret.data.string.data, ret.data.string.size);+      }+      api_free_object(ret);+    } else {+      nlua_call_ref(mp->m_luaref, NULL, args, false, &err);+    }+    if (err.type != kErrorTypeNone) {+      semsg_multiline(""E5108: %s"", err.msg);+      api_clear_error(&err);+    }",This whole block should go into `lua/executor.c` in a new `nlua_eval_map` or something similar. That way we're not mixing `api` and `nlua` functions around in `getchar.c`.See `nlua_do_ucmd` from #16752 as an example.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,776391779,2021-12-29T15:56:22Z,src/nvim/getchar.c,"@@ -4560,3 +4656,47 @@ char_u *getcmdkeycmd(int promptc, void *cookie, int indent, bool do_concat)    return (char_u *)line_ga.ga_data; }++bool map_execute_lua(void)",I also think this should go in `lua/executor.c` as `nlua_execute_map` or something similar.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,776394323,2021-12-29T16:02:21Z,src/nvim/getchar.c,"@@ -3447,6 +3513,11 @@ static void showmap(mapblock_T *mp, bool local)     msg_outtrans_special(s, false, 0);     xfree(s);   }++  if (mp->m_desc != NULL) {+    msg_puts(""\n                 "");  // Shift line to same level as rhs.+    msg_puts(mp->m_desc);",Not sure about putting `desc` on a newline. If plugins or scripts depend on there being one mapping per line this would break that.Knowing the number of the Lua ref is (imo) not that useful or interesting. What if instead we indicate a mapping uses a Lua function by prepending it with an `L` or `#` (similar to how buffer-local mappings have a `@` and non-remappable mappings use `*`). So e.g. `:map` would show```n  ZT          L Open a new tab```This should be pretty straightforward to add. The relevant code is at line 3486 in `getchar.c` and the docs under `|map-listing|`.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16594,776426500,2021-12-29T17:25:01Z,src/nvim/api/private/helpers.c,"@@ -1073,8 +1093,19 @@ ArrayOf(Dictionary) keymap_array(String mode, buf_T *buf)       // Check for correct mode       if (int_mode & current_maphash->m_mode) {         mapblock_fill_dict(dict, current_maphash, buffer_value, false);-        ADD(mappings, vim_to_object((typval_T[]) { { .v_type = VAR_DICT, .vval.v_dict = dict } }));-+        Object api_dict = vim_to_object((typval_T[]) { { .v_type = VAR_DICT,+                                                         .vval.v_dict = dict } });+        if (from_lua) {+          Dictionary d = api_dict.data.dictionary;+          for (size_t j = 0; j < d.size; j++) {+            if (strequal(""callback"", d.items[j].key.data)) {+              d.items[j].value.type = kObjectTypeLuaRef;+              d.items[j].value.data.luaref = api_new_luaref((LuaRef)d.items[j].value.data.integer);","Yes but you are making a new copy of the ref with `api_new_luaref`. The ref attached to the keymap will be freed when the keymap is deleted, but in this function you are only listing existing mappings. So when are those new copies freed?Basically, does this work if you remove `api_new_luaref` and just copy the integer value directly?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16816,776747525,2021-12-30T14:25:14Z,src/nvim/api/vim.c,"@@ -2391,11 +2391,14 @@ Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error * ///                 - mods: (string) Command modifiers, if any |<mods>| /// @param  opts    Optional command attributes. See |command-attributes| for more details. To use ///                 boolean attributes (such as |:command-bang| or |:command-bar|) set the value to-///                 ""true"". When using a Lua function for {command} you can also provide a ""desc""-///                 key that will be displayed when listing commands. In addition to the string-///                 options listed in |:command-complete|, the ""complete"" key also accepts a Lua-///                 function which works like the ""customlist"" completion mode-///                 |:command-complete-customlist|.+///                 ""true"". In addition to the string options listed in |:command-complete|, the+///                 ""complete"" key also accepts a Lua function which works like the ""customlist""+///                 completion mode |:command-complete-customlist|.",It looks like https://github.com/neovim/neovim/pull/16834 overrode https://github.com/neovim/neovim/pull/16821.```suggestion///                 completion mode |:command-completion-customlist|.```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16828,776918752,2021-12-31T03:47:00Z,src/nvim/ops.c,"@@ -915,24 +915,43 @@ int do_record(int c)       apply_autocmds(EVENT_RECORDINGENTER, NULL, NULL, false, curbuf);     }   } else {  // stop recording+    save_v_event_T save_v_event;+    // Set the v:event dictionary with information about the recording.+    dict_T *dict = get_v_event(&save_v_event);++    // The recorded text contents.+    list_T *const list = tv_list_alloc(1);+    p = get_recorded();+    if (p != NULL) {+      // Remove escaping for CSI and K_SPECIAL in multi-byte chars.+      vim_unescape_csi(p);++      tv_list_append_string(list, (const char *)p, -1);",Why use a list for `regcontents`?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16849,777014912,2021-12-31T14:31:27Z,src/nvim/memline.c,"@@ -1032,9 +1032,7 @@ void ml_recover(bool checkext)   line_count = 0;   idx = 0;              // start with first index in block 1   error = 0;-  buf->b_ml.ml_stack_top = 0;",Hmm I think resetting `size` (and this index) is a good habit when clearing the corresponding pointer. what is the _other_ assignment this is duplicate to?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16594,777041915,2021-12-31T18:18:04Z,src/nvim/getchar.c,"@@ -3934,15 +3978,33 @@ static char_u *eval_map_expr(char_u *str, int c)   save_cursor = curwin->w_cursor;   save_msg_col = msg_col;   save_msg_row = msg_row;-  p = eval_to_string(expr, NULL, false);+  if (mp->m_luaref != LUA_NOREF) {+    Error err = ERROR_INIT;+    Array args = ARRAY_DICT_INIT;+    if (mp->m_expr) {+      Object ret = nlua_call_ref(mp->m_luaref, NULL, args, true, &err);+      if (ret.type == kObjectTypeString) {+        p = (char_u *)xstrndup(ret.data.string.data, ret.data.string.size);+      }+      api_free_object(ret);+    } else {+      nlua_call_ref(mp->m_luaref, NULL, args, false, &err);","isn't this branch dead now, that non-expr lua mappings are handled elsewhere?",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16828,777048969,2021-12-31T19:38:06Z,src/nvim/ops.c,"@@ -915,24 +915,43 @@ int do_record(int c)       apply_autocmds(EVENT_RECORDINGENTER, NULL, NULL, false, curbuf);     }   } else {  // stop recording+    save_v_event_T save_v_event;+    // Set the v:event dictionary with information about the recording.+    dict_T *dict = get_v_event(&save_v_event);++    // The recorded text contents.+    list_T *const list = tv_list_alloc(1);+    p = get_recorded();+    if (p != NULL) {+      // Remove escaping for CSI and K_SPECIAL in multi-byte chars.+      vim_unescape_csi(p);++      tv_list_append_string(list, (const char *)p, -1);","Hmm, `TextYankPost` does it that way because you can yank multiple lines and it puts them in one line per list entry. I am not sure that makes sense for a macro recording however. But still, the consistency might be good.I would lean toward making it just a string, but curious what @bfredl thinks.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16828,777057110,2021-12-31T21:25:56Z,src/nvim/ops.c,"@@ -915,24 +915,43 @@ int do_record(int c)       apply_autocmds(EVENT_RECORDINGENTER, NULL, NULL, false, curbuf);     }   } else {  // stop recording+    save_v_event_T save_v_event;+    // Set the v:event dictionary with information about the recording.+    dict_T *dict = get_v_event(&save_v_event);++    // The recorded text contents.+    list_T *const list = tv_list_alloc(1);+    p = get_recorded();+    if (p != NULL) {+      // Remove escaping for CSI and K_SPECIAL in multi-byte chars.+      vim_unescape_csi(p);++      tv_list_append_string(list, (const char *)p, -1);",well a register needs the linelist as it could contain NUL. I don't think a recording ever will contain NUL so it is probably fine.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16591,777131920,2022-01-01T19:21:21Z,runtime/lua/vim/keymap.lua,"@@ -0,0 +1,127 @@+local keymap = {}++--- Add a new keymap.+--- Examples:+--- <pre>+---   -- You can make keymaps worth lua functions+---   vim.keymap.set('n', 'lhs', function() print(""real lua function"") end)+---+---   -- Can use it to map multiple modes+---   vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { silent = true, buffer=true })+---+---   -- You can map a key for specific buffer+---   vim.keymap.set('n', '<leader>w', ""<cmd>w<cr>"", { silent = true, buffer = 5 })+---+---   -- Also expr keymaps too. Notice the replace_termcodes when making lua expr maps.+---   vim.keymap.set('i', '<Tab>', function()+---     return vim.fn.pumvisible() == 1 and ""<C-n>"" or ""<Tab>""+---   end, { silent = true, expr = true, replace_termcodes = true })+---   -- While setting <Plug> mapping remember to set remap to true+---   vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)', {silent = true, remap = true })+--- </pre>+--@param mode (string|table):   Same mode short names as |nvim_set_keymap|.+---                             Can also be list of modes to create keymap on multiple modes.+--@param lhs (string):          Left-hand-side |{lhs}| of the mapping.+--@param rhs (string|function): Right-hand-side |{rhs}| of the mapping. Can also be a lua function.+--+--@param opts (table): A table of |:map-arguments| such as ""silent"". See |nvim_set_keymap()|+---       along with ""replace_termcodes"". When replace_termcodes is true with+---       lua function expr maps |nvim_replace_termcodes| is applied to return+---       value of mapped function.+---       One difference compared to |nvim_set_keymap| is here ""remap"" used as option+---       instead of |noremap| . It's meaning is opposite of |noremap| and it's false by default.+--@see |nvim_set_keymap|+---","```suggestion---@param opts table A table of |:map-arguments| such as ""silent"". In addition to the options---                  listed in |nvim_set_keymap()|, this table also accepts the following keys:---                  - replace_termcodes: (boolean, default false) when ""true"",---                  |nvim_replace_termcodes()| is applied to the result of Lua expr maps.---                  - remap: (boolean, default false) Make the mapping recursive. This is the---                  inverse of the ""noremap"" option from |nvim_set_keymap()|.---@see |nvim_set_keymap()|```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16591,777135789,2022-01-01T20:22:26Z,runtime/lua/vim/keymap.lua,"@@ -0,0 +1,127 @@+local keymap = {}++--- Add a new keymap.+--- Examples:+--- <pre>+---   -- You can make keymaps worth lua functions+---   vim.keymap.set('n', 'lhs', function() print(""real lua function"") end)+---+---   -- Can use it to map multiple modes+---   vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { silent = true, buffer=true })+---+---   -- You can map a key for specific buffer+---   vim.keymap.set('n', '<leader>w', ""<cmd>w<cr>"", { silent = true, buffer = 5 })+---+---   -- Also expr keymaps too. Notice the replace_termcodes when making lua expr maps.+---   vim.keymap.set('i', '<Tab>', function()+---     return vim.fn.pumvisible() == 1 and ""<C-n>"" or ""<Tab>""+---   end, { silent = true, expr = true, replace_termcodes = true })+---   -- While setting <Plug> mapping remember to set remap to true+---   vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)', {silent = true, remap = true })+--- </pre>","Agreed; much of the issue is that we simply haven't worked out best practices around these new Lua variants of well-established vimscript patterns. (@nanotee to the rescue ;))I'll have to play around whether `loadstring` or anonymous functions are the more convenient pattern (or what the exact trade-offs are for each); in any case, both are supported in the current API, so any further improvement can -- and should! -- come later.(The _real_ drawback with the `function()` thing is that `stylua` insists on making it multiline...)",
4466899,tjdevries,https://api.github.com/repos/neovim/neovim/pulls/16591,777162741,2022-01-02T03:53:03Z,runtime/lua/vim/keymap.lua,"@@ -0,0 +1,127 @@+local keymap = {}++--- Add a new keymap.+--- Examples:+--- <pre>+---   -- You can make keymaps worth lua functions+---   vim.keymap.set('n', 'lhs', function() print(""real lua function"") end)+---+---   -- Can use it to map multiple modes+---   vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { silent = true, buffer=true })+---+---   -- You can map a key for specific buffer+---   vim.keymap.set('n', '<leader>w', ""<cmd>w<cr>"", { silent = true, buffer = 5 })+---+---   -- Also expr keymaps too. Notice the replace_termcodes when making lua expr maps.+---   vim.keymap.set('i', '<Tab>', function()+---     return vim.fn.pumvisible() == 1 and ""<C-n>"" or ""<Tab>""+---   end, { silent = true, expr = true, replace_termcodes = true })+---   -- While setting <Plug> mapping remember to set remap to true+---   vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)', {silent = true, remap = true })+--- </pre>",you could also do `require_on_call` (https://github.com/tjdevries/lazy.nvim/blob/master/lua/lazy.lua#L49-L72) but people will have different preferences on how to do so I think.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16591,777211402,2022-01-02T13:33:56Z,runtime/lua/vim/keymap.lua,"@@ -0,0 +1,127 @@+local keymap = {}++--- Add a new keymap.+--- Examples:+--- <pre>+---   -- You can make keymaps worth lua functions+---   vim.keymap.set('n', 'lhs', function() print(""real lua function"") end)+---+---   -- Can use it to map multiple modes+---   vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { silent = true, buffer=true })+---+---   -- You can map a key for specific buffer+---   vim.keymap.set('n', '<leader>w', ""<cmd>w<cr>"", { silent = true, buffer = 5 })+---+---   -- Also expr keymaps too. Notice the replace_termcodes when making lua expr maps.+---   vim.keymap.set('i', '<Tab>', function()+---     return vim.fn.pumvisible() == 1 and ""<C-n>"" or ""<Tab>""+---   end, { silent = true, expr = true, replace_termcodes = true })+---   -- While setting <Plug> mapping remember to set remap to true+---   vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)', {silent = true, remap = true })+--- </pre>","I think ""lazy require"" is a good idea but independent from this PR (as in, I don't see how the implementation or API would change if that were available), so it's better to discuss this as part of the general ""require goes *brrrr*"" discussion around caching etc., for example in https://github.com/neovim/neovim/pull/15436.Mentioning that Lua functions are actually accessed during `set` (so `require` is executed) and mentioning the `function` wrapper workaround is enough here. I'd prefer it if this PR got merged early and then iterated on during the 0.7 development cycle. (It's opt-in, after all.)",
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/16859,777236891,2022-01-02T17:42:29Z,CMakeLists.txt,"@@ -545,7 +545,7 @@ message(STATUS ""Using Lua interpreter: ${LUA_PRG}"")  option(COMPILE_LUA ""Pre-compile Lua sources into bytecode (for sources that are included in the binary)"" ON)",Thanks I had actually tried something similar earlier today but it didn't work for some reason back then . This works fine .,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/16895,777580751,2022-01-03T16:32:57Z,scripts/vim-patch.sh,"@@ -565,13 +576,13 @@ show_vimpatches() {     runtime_commits[$commit]=1   done -  list_missing_vimpatches 1 ""$@"" | while read -r vim_commit; do+  while read -r vim_commit; do","We're not making any changes inside the loop that need to be visible outside of it, so SC2030 is technically a false positive here.",
95099980,MurdeRM3L0DY,https://api.github.com/repos/neovim/neovim/pulls/16591,777619027,2022-01-03T17:48:36Z,runtime/lua/vim/keymap.lua,"@@ -0,0 +1,138 @@+local keymap = {}++--- Add a new |mapping|.+--- Examples:+--- <pre>+---   -- Can add mapping to Lua functions+---   vim.keymap.set('n', 'lhs', function() print(""real lua function"") end)+---+---   -- Can use it to map multiple modes+---   vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { buffer=true })+---+---   -- Can add mapping for specific buffer+---   vim.keymap.set('n', '<leader>w', ""<cmd>w<cr>"", { silent = true, buffer = 5 })+---+---   -- Expr mappings+---   vim.keymap.set('i', '<Tab>', function()+---     return vim.fn.pumvisible() == 1 and ""<C-n>"" or ""<Tab>""+---   end, { expr = true })+---   -- <Plug> mappings+---   vim.keymap.set('n', '[%%', '<Plug>(MatchitNormalMultiBackward)')+--- </pre>+---+--- Note that in a mapping like:+--- <pre>+---    vim.keymap.set('n', 'asdf', require('jkl').my_fun)+--- </pre>+---+--- the require('jkl') gets evaluated during this call in order to access the function. If you want to+--- avoid this cost at startup you can wrap it in a function, for example:+--- <pre>+---    vim.keymap.set('n', 'asdf', function() return require('jkl').my_fun() end)+--- </pre>+---+---@param mode string|table   Same mode short names as |nvim_set_keymap()|.+---                            Can also be list of modes to create mapping on multiple modes.+---@param lhs string          Left-hand side |{lhs}| of the mapping.+---@param rhs string|function  Right-hand side |{rhs}| of the mapping. Can also be a Lua function.+--+---@param opts table A table of |:map-arguments| such as ""silent"". In addition to the options+---                  listed in |nvim_set_keymap()|, this table also accepts the following keys:+---                  - replace_termcodes: (boolean, default true) When both this and expr is ""true"",+---                  |nvim_replace_termcodes()| is applied to the result of Lua expr maps.+---                  - remap: (boolean) Make the mapping recursive. This is the+---                  inverse of the ""noremap"" option from |nvim_set_keymap()|.+---                  Default `true` if `lhs` is a string starting with `<plug>` (case-insensitive), `false` otherwise.+---@see |nvim_set_keymap()|+function keymap.set(mode, lhs, rhs, opts)+  vim.validate {+    mode = {mode, {'s', 't'}},+    lhs = {lhs, 's'},+    rhs = {rhs, {'s', 'f'}},+    opts = {opts, 't', true}+  }++  opts = opts or {}+  local buffer = false+  local is_rhs_lua = type(rhs) == ""function""+  mode = type(mode) == 'string' and {mode} or mode++  if opts.buffer ~= nil then+    buffer = opts.buffer == true and 0 or opts.buffer+    opts.buffer = nil+  end++  if is_rhs_lua and opts.expr and opts.replace_termcodes ~= false then+    local user_rhs = rhs+    rhs = function ()+      return vim.api.nvim_replace_termcodes(user_rhs(), true, true, true)","> or even> > ```lua> vim.keymap.set('i', '<tab>', function()>   if require""luasnip"".expand_or_jumpable() then>     require'luasnip'.expand_or_jump()>   else>     return ""<tab>"">   end> end, { expr = true })> ```Yes, I use a similar mapping.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/16800,777722801,2022-01-03T21:54:42Z,runtime/lua/vim/path.lua,"@@ -0,0 +1,146 @@+local uv = vim.loop++local Path = {}+Path.__index = Path++function Path:__tostring()+  return self.path+end++function Path:exists()+  return uv.fs_realpath(self.path) and true+end++function Path:expanduser()+  if self.path:match '^~/' then+    return os.getenv('HOME') .. self.path:sub(2)+  else+    return self.path+  end+end++function Path:home()+  return os.getenv('HOME')+end++function Path:parts()+  if self.is_windows then+    return vim.split(self.path, '/')+  else+    local parts = vim.split(self.path, '/')+    if self.path:sub(1, 1) == '/' then+      parts[1] = '/'+    end+    return parts+  end+end++function Path:is_dir()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'directory'+end++function Path:is_file()+  local stat = uv.fs_realpath(self.path)+  return stat and stat == 'file'+end++function Path:is_absolute()+  if self.is_windows then+    return (self.path:match '^%a:' or self.path:match '^\\\\') or false+  else+    return self.path:match '^/' or false+  end+end++function Path:is_relative_to(root)+  local path_parts = self:parts()+  local root_parts = Path.new(root):parts()++  local root_parts_len = #root_parts+  local path_parts_len = #path_parts++  if root_parts_len > path_parts_len then+    return false+  end++  for i = 1,math.min(root_parts_len, path_parts_len) do+    if root_parts[i] ~= path_parts[i] then+      return false+      end+  end+  return true+end++function Path:is_fs_root()+  if self.is_windows then+    return self.path:match '^%a:$'+  else+    return self.path == '/'+  end+end++function Path:as_uri()+  if self.is_windows then+    return 'file:///' .. self.path+  else+    return 'file://' .. self.path+  end+end++function Path:as_posix()+  return self.path+end++function Path:as_windows()+  return self.path:gsub('/', '\\')+end++function Path:parent()+  local strip_dir_pat = '/([^/]+)$'+  local strip_sep_pat = '/$'+  if not self.path or #self.path == 0 then+    return+  end+  local result = self.path:gsub(strip_sep_pat, ''):gsub(strip_dir_pat, '')+  if #result == 0 then+    if self.is_windows then+      return Path.new(self.path:sub(1, 2))+    else+      return Path.new('/')+    end+  end+  return Path.new(result)+end++function Path.new(path)+  local self = setmetatable({+    is_windows = uv.os_uname().version:match('Windows') or false,+    path = path+  }, Path)++  if self.is_windows then+    if self.is_absolute() then+      path = path:sub(1, 1):upper() .. path:sub(2)+    end+    self.path = path:gsub('\\', '/')+  end++  return self+end++setmetatable(Path, {+  __call = function(_, path)+    return Path.new(path)+  end+})++local function join(...)+  local to_join = vim.map(tostring, vim.tbl_flatten(...))+  return Path.new(table.concat(to_join, '/'))+end++return {+  Path=Path,+  join=join",I'm mixed because for our internal use returning non normalized paths actually undercuts one of the reasons for the path library. In lspconfig we would then need to explicitly returns paths as Unix (always),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16923,778362970,2022-01-04T20:19:56Z,runtime/lua/vim/filetype.lua,"@@ -635,6 +644,12 @@ local extension = {   tssop = ""tssop"",   tutor = ""tutor"",   twig = ""twig"",+  ts = function(name, buf)+    if starts_with(buf, '<?xml') then+      return 'xml'+    end+    return 'typescript'+  end,","1. `<?xml` doesn't need to be at the very beginning. According to the pattern in `filetype.vim`, it can be anywhere in the first line so use `string.find` rather than `starts_with`. (this is the case for most of the patterns in `filetype.vim`, so I don't think we actually need `starts_with` as a helper function).2. The `?` character needs to be escaped with `%` since Lua interprets `?` as a pattern operator.3. We don't have a standard convention across our Lua code base, but in order to at least stay consistent within this one file, use double quotes.```suggestion  ts = function(name, bufnr)    if string.find(getline(bufnr, 1), ""<%?xml"") then      return ""xml""    end    return ""typescript""  end,```I'm being a bit picky because we want to set a standard for future contributions, and most people will just follow whatever conventions are established in the file. So I want to make sure we start off right.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16923,778366826,2022-01-04T20:27:06Z,runtime/lua/vim/filetype.lua,"@@ -635,6 +639,12 @@ local extension = {   tssop = ""tssop"",   tutor = ""tutor"",   twig = ""twig"",+  ts = function(name, bufnr)+    if string.find(getline(bufnr, 1), ""<%?xml"") then","can just be `getline(bufnr, 1):find(""<%?xml"")````suggestion    if getline(bufnr, 1):find(""<%?xml"") then```(unless @gpanders wanted the ""long form"" intentionally?)",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16923,778369261,2022-01-04T20:31:37Z,runtime/lua/vim/filetype.lua,"@@ -635,6 +639,12 @@ local extension = {   tssop = ""tssop"",   tutor = ""tutor"",   twig = ""twig"",+  ts = function(name, bufnr)+    if string.find(getline(bufnr, 1), ""<%?xml"") then","> unless @gpanders wanted the ""long form"" intentionally?No this is fine ���� ",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16923,778374864,2022-01-04T20:41:28Z,runtime/lua/vim/filetype.lua,"@@ -19,6 +19,10 @@ local function starsetf(ft)   }} end +local function getline(buf, line)+  return api.nvim_buf_get_lines(buf, line-1, line, true)[1]+end","Hmm, the `nvim_buf_get_lines` docs say that `false` means out of bounds indices are ""clamped to the nearest value"", which implies that e.g. if line 2 doesn't exist, it will return whatever's on line 1 (which we do not want). But in practice it looks like it just returns an empty list. So that should work.```suggestionlocal function getline(bufnr, lnum)  return api.nvim_buf_get_lines(bufnr, lnum-1, lnum, false)[1]end```",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/16926,778413205,2022-01-04T21:54:13Z,runtime/lua/vim/filetype.lua,"@@ -1312,6 +1319,7 @@ local pattern = {   [""tmac%..*""] = starsetf('nroff'),   [""zlog.*""] = starsetf('zsh'),   [""zsh.*""] = starsetf('zsh'),+  [""ae%d+%.txt""] = 'mail',","Wait, no, I forgot a case. Patterns come before extensions, so a file `ae3.txt` is correctly classified as `mail`, but putting the right modeline in there won't make it a help file.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/16926,778415010,2022-01-04T21:57:54Z,runtime/lua/vim/filetype.lua,"@@ -1312,6 +1319,7 @@ local pattern = {   [""tmac%..*""] = starsetf('nroff'),   [""zlog.*""] = starsetf('zsh'),   [""zsh.*""] = starsetf('zsh'),+  [""ae%d+%.txt""] = 'mail',","There's a duplication here, see https://github.com/neovim/neovim/blob/master/runtime/filetype.vim#L2404. I figured that the location is superflous when checking for the modeline (that's what the comment indicates at least).",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16926,778418499,2022-01-04T22:05:04Z,runtime/lua/vim/filetype.lua,"@@ -1312,6 +1319,7 @@ local pattern = {   [""tmac%..*""] = starsetf('nroff'),   [""zlog.*""] = starsetf('zsh'),   [""zsh.*""] = starsetf('zsh'),+  [""ae%d+%.txt""] = 'mail',","It's not a duplication; the order in Vim is (likely) intentional to have the right behavior (make `txt` files in those directories `help`; unless they're not help files, then mark as `text` -- you're porting here only the second branch). We should instead use explicit conditionals or priorities.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/16926,778422329,2022-01-04T22:12:50Z,runtime/lua/vim/filetype.lua,"@@ -1312,6 +1319,7 @@ local pattern = {   [""tmac%..*""] = starsetf('nroff'),   [""zlog.*""] = starsetf('zsh'),   [""zsh.*""] = starsetf('zsh'),+  [""ae%d+%.txt""] = 'mail',","Note that all txt files in `$VIMRUNTIME/doc` do indeed have that modeline and are correctly classified, so right now the pattern isn't needed. That leaves the case of a `ae%d+%.txt` file containing a help modeline, but I'm not exactly sure it matters (then again, I'm not sure why we need to check the modeline anyways, shouldn't that be run after all builtin code anyways?).",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16926,778424689,2022-01-04T22:17:54Z,runtime/lua/vim/filetype.lua,"@@ -774,6 +774,12 @@ local extension = {   xml = function() vim.fn[""dist#ft#FTxml""]() end,   y = function() vim.fn[""dist#ft#FTy""]() end,   zsql = function() vim.fn[""dist#ft#SQL""]() end,+  txt = function(_, bufnr)+    --helpfiles match *.txt, but should have a modeline as last line+    if not vim.fn.getbufline(bufnr,'$')[1]:match(""vim:.*ft=help"") then",It's on master: https://github.com/neovim/neovim/blob/60d3bb745d72cbf7dd3d83660e6f4d8c1a9dd770/runtime/lua/vim/filetype.lua#L22-L24,
13149513,shadmansaleh,https://api.github.com/repos/neovim/neovim/pulls/16933,778563270,2022-01-05T05:56:20Z,src/nvim/lua/vim.lua,"@@ -666,4 +666,15 @@ vim._expand_pat_get_parts = function(lua_string)   return parts, search_index end +---@private+function vim._pretty_print(...)",inspect module is already exposed as `vim.inspect` and I wanted to use `vim._pretty_print` as a helper for this . Though I have no issue in exposing this to user as `vim.pretty_print` if that's what's wanted . I that case we should return the args too so it can be placed in middle of expressions. I guess almost everyone has a pretty print function in their config . So making this public isn't a bad idea.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/16945,779072802,2022-01-05T19:12:49Z,test/functional/treesitter/parser_spec.lua,"@@ -167,6 +167,27 @@ void ui_refresh(void)     eq('variable', ret)   end) +  it(""supports caching queries"", function()+    local long_query = query:rep(100)+    local first_run = exec_lua ([[+      local before = vim.loop.hrtime()+      cquery = vim.treesitter.parse_query(""c"", ...)+      local after = vim.loop.hrtime()+      return after - before+    ]], long_query)++    local subsequent_runs = exec_lua ([[+      local before = vim.loop.hrtime()+      for i=1,100,1 do+        cquery = vim.treesitter.parse_query(""c"", ...)+      end+      local after = vim.loop.hrtime()+      return after - before+    ]], long_query)++    assert.True(1000 * subsequent_runs < first_run)+  end)+",also asking for permission to split `parser_spec.lua` into `parser_spec.lua` and `query_spec.lua` to better align with the source files and avoid long test files. Maybe a different PR...,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16936,779212146,2022-01-05T23:51:36Z,src/nvim/getchar.c,"@@ -4041,20 +4012,17 @@ char_u *vim_strsave_escape_csi(char_u *p)   return res; } -/*- * Remove escaping from CSI and K_SPECIAL characters.  Reverse of- * vim_strsave_escape_csi().  Works in-place.- */-void vim_unescape_csi(char_u *p)+/// Remove escaping from CSI and K_SPECIAL characters.  Reverse of+/// vim_strsave_escape_ks().  Works in-place.+void vim_unescape_ks_csi(char_u *p) {   char_u *s = p, *d = p;    while (*s != NUL) {     if (s[0] == K_SPECIAL && s[1] == KS_SPECIAL && s[2] == KE_FILLER) {       *d++ = K_SPECIAL;       s += 3;-    } else if ((s[0] == K_SPECIAL || s[0] == CSI)","Keeping this should be harmless, as `CSI KS_EXTRA KE_CSI` is not valid UTF-8 anyway. But since other similar unescaping code has already been removed from other functions like `vgetc()` (with the removal of `FEAT_GUI`), I'll remove this `s[0] == CSI` as well.",
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/16956,779590124,2022-01-06T14:35:20Z,src/nvim/lua/vim.lua,"@@ -439,6 +439,22 @@ function vim.notify(msg, log_level, opts) -- luacheck: no unused   end end +local warn_once = (function()+  local warned = {}+  return function(msg)+    if not warned[msg] then+      vim.api.nvim_echo({{msg, ""WarningMsg""}}, true, {})+      warned[msg] = true+    end+  end+end)()++--- Emit a warning message once per Nvim session.+---+---@param msg string Warning message to display to the user.+function vim.warn_once(msg)+  warn_once(msg)+end","Could use a do block to hide the `warned` from the module's scope.```suggestiondo  local warned = {}  --- Emit a warning message once per Nvim session.  ---  ---@param msg string Warning message to display to the user.  function vim.warn_once(msg)    if not warned[msg] then      vim.api.nvim_echo({{msg, ""WarningMsg""}}, true, {})      warned[msg] = true    end  endend```Probably personal preference and it is fine for me to keep as is, but I find this would show the intention better than the trick with the ad-hoc function.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16952,779600347,2022-01-06T14:49:14Z,runtime/lua/vim/filetype.lua,"@@ -1226,6 +1227,7 @@ local pattern = {   ["".*/%.config/systemd/user/.*%.d/.*%.conf""] = ""systemd"",   ["".*/etc/systemd/system/.*%.d/.*%.conf""] = ""systemd"",   ["".*%.t%.html""] = ""tilde"",+  ["".?tmux.*%.conf.*""] = ""tmux"",","The leading `.` needs to be escaped. And the pattern in `filetype.vim` doesn't have a `*` at the end.```suggestion  [""%.?tmux.*%.conf""] = ""tmux"",```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16953,779699638,2022-01-06T17:00:01Z,runtime/filetype.vim,"@@ -680,12 +681,8 @@ if !empty($XDG_CONFIG_HOME) endif au BufNewFile,BufRead git-rebase-todo		setf gitrebase au BufRead,BufNewFile .gitsendemail.msg.??????	setf gitsendemail-au BufNewFile,BufRead .msg.[0-9]*-      \ if getline(1) =~ '^From.*# This line is ignored.$' |-      \   setf gitsendemail |-      \ endif au BufNewFile,BufRead *.git/*-      \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |+      \ if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |       \   setf git |       \ endif",Or maybe better to include it in https://github.com/neovim/neovim/pull/16959#pullrequestreview-845786399 (which also needs a similar test).,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/13896,779819674,2022-01-06T19:47:30Z,src/nvim/lua/vim.lua,"@@ -457,6 +457,93 @@ function vim.region(bufnr, pos1, pos2, regtype, inclusive)   return region end +--- Get the region between two marks and the start and end positions for the region+---+--@param mark1 Name of mark starting the region+--@param mark2 Name of mark ending the region+--@param options Table containing the adjustment function, register type and selection mode+--@return region region between the two marks, as returned by |vim.region|+--@return start (row,col) tuple denoting the start of the region+--@return finish (row,col) tuple denoting the end of the region+function vim.get_marked_region(mark1, mark2, options)","This can use anything that can be passed to `getpos()`, which includes but is not limited to marks. Calling it `get_marked_region` is misleading and (IMO) a bit confusing.Can we modify `vim.region` to accept the special characters that `line()` and friends take (listed below), in addition to `(row, col)` tuples?```.            the cursor position$            the last line in the current buffer'x           position of mark x (if the mark is not set, 0 is             returned)w0           first line visible in current window (one if the             display isn't updated, e.g. in silent Ex mode)w$           last line visible in current window (this is one             less than ""w0"" if no lines are visible)v            In Visual mode: the start of the Visual area (the             cursor is the end).  When not in Visual mode             returns the cursor position.  Differs from |'<| in             that it's updated right away.```If so, then we wouldn't need this new function at all and we can just use `vim.region()`.",
61618751,ichigozero,https://api.github.com/repos/neovim/neovim/pulls/16952,779939668,2022-01-06T23:47:09Z,runtime/lua/vim/filetype.lua,"@@ -1226,6 +1227,7 @@ local pattern = {   ["".*/%.config/systemd/user/.*%.d/.*%.conf""] = ""systemd"",   ["".*/etc/systemd/system/.*%.d/.*%.conf""] = ""systemd"",   ["".*%.t%.html""] = ""tilde"",+  ["".?tmux.*%.conf.*""] = ""tmux"",","Thank you for the review.I doubled checked `filetype.vim` and I found that there are two entries for tmux.- [line 1887](https://github.com/neovim/neovim/blob/master/runtime/filetype.vim#L1887)  ```vim  au BufNewFile,BufRead {.,}tmux*.conf		setf tmux  ```- [line 2367](https://github.com/neovim/neovim/blob/master/runtime/filetype.vim#L2367)  ```vim  au BufNewFile,BufRead {.,}tmux*.conf*		setf tmux  ```In line 2367, the pattern does have `*` at the end. I wonder which one is correct.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/16952,779942223,2022-01-06T23:54:43Z,runtime/lua/vim/filetype.lua,"@@ -1226,6 +1227,7 @@ local pattern = {   ["".*/%.config/systemd/user/.*%.d/.*%.conf""] = ""systemd"",   ["".*/etc/systemd/system/.*%.d/.*%.conf""] = ""systemd"",   ["".*%.t%.html""] = ""tilde"",+  ["".?tmux.*%.conf.*""] = ""tmux"",","<https://github.com/vim/vim/pull/8971#issuecomment-939315001>> Adding a star at the end of a filetype pattern is tricky, because it> matches other things, such as "".gz"" or "".old"".  It should always be> checked last. ",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16952,779977382,2022-01-07T01:47:14Z,runtime/lua/vim/filetype.lua,"@@ -1226,6 +1227,7 @@ local pattern = {   ["".*/%.config/systemd/user/.*%.d/.*%.conf""] = ""systemd"",   ["".*/etc/systemd/system/.*%.d/.*%.conf""] = ""systemd"",   ["".*%.t%.html""] = ""tilde"",+  ["".?tmux.*%.conf.*""] = ""tmux"",","Hmm, I wonder why Bram didn't want to use `s:StarSetf` then? (we have our own `starsetf` function to match those). From `filetype.vim`:```"" Extra checks for when no filetype has been detected now.  Mostly used for"" patterns that end in ""*"".  E.g., ""zsh*"" matches ""zsh.vim"", but that's a Vim"" script file."" Most of these should call s:StarSetf() to avoid names ending in .gz and the"" like are used.```In any case, we can enforce priority in the patterns with the priority key. So what we want is```lua[""%.?tmux.*%.conf""] = ""tmux"",[""%.?tmux.*%.conf.*""] = { ""tmux"", { priority = -1 } }```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16953,780129498,2022-01-07T09:27:29Z,runtime/filetype.vim,"@@ -680,12 +681,8 @@ if !empty($XDG_CONFIG_HOME) endif au BufNewFile,BufRead git-rebase-todo		setf gitrebase au BufRead,BufNewFile .gitsendemail.msg.??????	setf gitsendemail-au BufNewFile,BufRead .msg.[0-9]*-      \ if getline(1) =~ '^From.*# This line is ignored.$' |-      \   setf gitsendemail |-      \ endif au BufNewFile,BufRead *.git/*-      \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |+      \ if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |       \   setf git |       \ endif","I'm merging this now while ASAN is still green, so the `git` pattern should go into the linked PR.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16945,780397885,2022-01-07T16:59:29Z,runtime/lua/vim/treesitter/query.lua,"@@ -138,6 +138,13 @@ function M.get_query(lang, query_name)   end end +local query_cache = setmetatable({}, {+  __index = function(tbl, key)+    rawset(tbl, key, {})+    return rawget(tbl, key)+  end+})","Not that I know of, but we use the same pattern in other places (e.g. diagnostics), so having a standardized implementation would maybe be a good idea",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16959,780471827,2022-01-07T19:11:10Z,runtime/lua/vim/filetype.lua,"@@ -770,6 +770,14 @@ local extension = {   mm = function() vim.fn[""dist#ft#FTmm""]() end,   mms = function() vim.fn[""dist#ft#FTmms""]() end,   p = function() vim.fn[""dist#ft#FTprogress_pascal""]() end,+  patch = function(path, bufnr)+    local firstline = vim.fn.getline(1)+    if string.find(firstline, ""From "") and string.find(firstline, ""Mon Sep 17 00:00:00 2001"") then","I don't understand why this pattern is used, but it's what filetype.vim does so ��\\\_(���)\_/�� ```suggestion    if string.find(firstline, ""^From "" .. string.rep(""%x"", 40) .. ""+ Mon Sep 17 00:00:00 2001$"") then```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/16978,780704496,2022-01-08T20:08:14Z,runtime/lua/vim/filetype.lua,"@@ -770,6 +770,14 @@ local extension = {   mm = function() vim.fn[""dist#ft#FTmm""]() end,   mms = function() vim.fn[""dist#ft#FTmms""]() end,   p = function() vim.fn[""dist#ft#FTprogress_pascal""]() end,+  patch = function(path, bufnr)+    local firstline = getline(bufnr, 1)+    if string.find(firstline, ""^From "" .. string.rep(""%x"", 40) .. ""+ Mon Sep 17 00:00:00 2001$"") then",[Yes](https://github.com/neovim/neovim/blob/master/runtime/filetype.vim#L496),
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17005,780794166,2022-01-09T15:14:56Z,runtime/lua/vim/filetype.lua,"@@ -125,6 +125,12 @@ local extension = {     end     return ""cpp""   end,+  cc = function()",Even though they���re not used in this function can you add the `path` and `bufnr` parameters to the function signature (and can you also do the same for the `cpp` function just above this one)?,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17037,782368332,2022-01-11T17:20:19Z,runtime/lua/vim/lsp/util.lua,"@@ -440,7 +422,24 @@ function M.apply_text_edits(text_edits, bufnr, offset_encoding)    -- Apply text edits.   local is_cursor_fixed = false+  local has_eol_text_edit = false   for _, text_edit in ipairs(text_edits) do+    -- Some LSP servers may return +1 range of the buffer content but nvim_buf_set_text can't accept it so we should fix it here.+    local max = vim.api.nvim_buf_line_count(bufnr)+    local len = _str_utfindex_enc(vim.api.nvim_buf_get_lines(bufnr, -2, -1, false)[1] or '', nil, offset_encoding)","Can we can guard the len computation under the union of conditions for the following two conditionals? We're doing it every time which seems excessive.Also should we first convert the text edit character to bytes (and compare that with line length), and then re-use that on line 446 and 448? Seems cleaner.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17046,782664306,2022-01-12T02:25:29Z,test/functional/editor/K_spec.lua,"@@ -33,6 +34,10 @@ describe('K', function()     feed('i'..test_file..'<ESC>K')     retry(nil, nil, function() eq(1, eval('filereadable(""'..test_file..'"")')) end)     eq({'fnord'}, eval(""readfile('""..test_file..""')""))+    -- Confirm that Neovim is still in terminal mode after K is pressed (#16692).+    eq('t', eval('mode()'))+    feed('<space>')  -- Any key, not just <space>, can be used here to escape.+    retry(nil, 5000, function() eq('n', eval('mode()')) end)",Events are only processed when there are no characters available for input:<https://github.com/neovim/neovim/blob/70fe3ce004f1c17328257349da5528757fdcd354/src/nvim/state.c#L41-L60>,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17049,782740789,2022-01-12T06:24:41Z,runtime/lua/vim/lsp/handlers.lua,"@@ -159,6 +161,28 @@ M['textDocument/codeLens'] = function(...) end  +--see: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references+M['textDocument/references'] =function(_,result, ctx, config)","I split this out into its own handler because we were taking advantage of lua to pass an invalid second argument, and this now is the offset_encoding, unlike with symbols to list.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17001,783419837,2022-01-12T20:27:34Z,src/nvim/api/extmark.c,"@@ -404,6 +404,10 @@ Array nvim_buf_get_extmarks(Buffer buffer, Integer ns_id, Object start, Object e ///                   for left). Defaults to false. ///               - priority: a priority value for the highlight group. For ///                   example treesitter highlighting uses a value of 100.+///               - strict: boolean that indicates extmark should be placed+///                   even if the line or column value is past the end of the+///                   buffer or end of the line respectively. Defaults to true.","It's just bad wording, I'll fix it.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17037,783609350,2022-01-13T03:45:06Z,runtime/lua/vim/lsp/util.lua,"@@ -440,16 +421,35 @@ function M.apply_text_edits(text_edits, bufnr, offset_encoding)    -- Apply text edits.   local is_cursor_fixed = false+  local has_eol_text_edit = false   for _, text_edit in ipairs(text_edits) do+    -- Convert from LSP style ranges to Neovim style ranges.     local e = {       start_row = text_edit.range.start.line,-      start_col = get_line_byte_from_position(bufnr, text_edit.range.start),+      start_col = get_line_byte_from_position(bufnr, text_edit.range.start, offset_encoding),       end_row = text_edit.range['end'].line,-      end_col  = get_line_byte_from_position(bufnr, text_edit.range['end']),+      end_col  = get_line_byte_from_position(bufnr, text_edit.range['end'], offset_encoding),       text = vim.split(text_edit.newText, '\n', true),     }++    -- Some LSP servers may return +1 range of the buffer content but nvim_buf_set_text can't accept it so we should fix it here.+    local max = vim.api.nvim_buf_line_count(bufnr)+    local len = #(vim.api.nvim_buf_get_lines(bufnr, -2, -1, false)[1] or '')",should we use `get_line` here instead? Also this could be guarded under the conditional `if max <= e.start_row or max <= e.end_row then` to avoid querying the buf.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/14987,783793558,2022-01-13T09:47:48Z,test/functional/api/version_spec.lua,"@@ -119,60 +116,76 @@ describe(""api metadata"", function()     end   end) -  it(""functions are compatible with old metadata or have new level"", function()+  it('functions are compatible with old metadata or have new level', function()     local funcs_new = name_table(api.functions)     local funcs_compat = {}     for level = compat, stable do-      for _,f in ipairs(old_api[level].functions) do+      for _, f in ipairs(old_api[level].functions) do         if funcs_new[f.name] == nil then           if f.since >= compat then-            error('function '..f.name..' was removed but exists in level '..-                  f.since..' which nvim should be compatible with')+            error(+              'function '+                .. f.name+                .. ' was removed but exists in level '+                .. f.since+                .. ' which nvim should be compatible with'+            )","I'd have to check, but I assume it follows the same rule as for argument lists (`foo(a,b,c,d)`): if the full list in parentheses does not fit into the same line, every item gets its own line.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17081,785076228,2022-01-14T18:46:42Z,runtime/lua/vim/lsp/buf.lua,"@@ -30,7 +30,7 @@ end --- ---@param method (string) LSP method name ---@param params (optional, table) Parameters to send to the server----@param handler (optional, functionnil) See |lsp-handler|. Follows |lsp-handler-resolution|+---@param handler (optional, function) See |lsp-handler|. Follows |lsp-handler-resolution|","I assume these changes are left over, I'm fine with them ofc but it should be collected into a bigger style cleanup PR",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/14661,785329232,2022-01-15T16:18:44Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,583 @@+#include <stdbool.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/fileio.h""+#include ""nvim/eval/typval.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define AUCMD_MAX_PATTERNS 256++#define FOREACH_KEY_VALUE(d, k, v, code) \+  for (size_t __foreach_i = 0; __foreach_i < d.size; __foreach_i++) { \+    String k = d.items[__foreach_i].key; \+    Object *v = &d.items[__foreach_i].value; \+    code; \+  }++#define FOREACH_ITEM(a, __foreach_item, code) \+  for (size_t __foreach_i = 0; __foreach_i < a.size; __foreach_i++) { \+    Object __foreach_item = a.items[__foreach_i]; \+    code; \+  }++#define CHECK_STRING_ARRAY(__array, k, v, goto_name) \+  for (size_t j = 0; j < __array.size; j++) { \+    Object item = __array.items[j]; \+    if (item.type != kObjectTypeString) { \+      api_set_error( \+          err, \+          kErrorTypeValidation, \+          ""All entries in '%s' must be strings"", \+          k); \+      goto goto_name; \+    } \+  }++#define UNPACK_STRING_OR_ARRAY(__array, k, v, goto_name) \+  if (v->type == kObjectTypeString) { \+    ADD(__array, copy_object(*v)); \+  } else if (v->type == kObjectTypeArray) { \+    CHECK_STRING_ARRAY(__array, k, v, goto_name); \+    __array = copy_array(v->data.array); \+  } else { \+    api_set_error( \+        err, \+        kErrorTypeValidation, \+        ""'%s' must be an array or a string."", \+        k); \+    goto goto_name; \+  }++#define GET_ONE_EVENT(event_nr, event_str, goto_name) \+  char_u *__next_ev; \+  event_T event_nr = \+    event_name2nr((char_u *)event_str.data.string.data, &__next_ev); \+  if (event_nr >= NUM_EVENTS) { \+    api_set_error(err, kErrorTypeValidation, ""unexpected event""); \+    goto goto_name; \+  }+++// ID for associating autocmds created via nvim_define_autocmd+// Used to delete autocmds from nvim_del_autocmd+static int64_t next_autocmd_id = 1;++/// Get autocmds that match the requirements passed to {opts}.+/// group+/// events+/// patterns+Array nvim_get_autocmds(Dictionary opts, Error *err)+  FUNC_API_SINCE(9)+{+  Array autocmd_list = ARRAY_DICT_INIT;+  char_u *pattern_filters[AUCMD_MAX_PATTERNS];+  char_u pattern_buflocal[BUFLOCAL_PAT_LEN];++  bool event_set[NUM_EVENTS] = { false };+  bool check_event = false;++  int group = 0;++  int pattern_filter_count = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(""group"", k.data)) {+      if (v.type != kObjectTypeString) {+        api_set_error(err, kErrorTypeValidation, ""group must be a string."");+        goto cleanup;+      }++      group = augroup_find((char_u *)v.data.string.data);++      if (group == AUGROUP_ERROR) {+        api_set_error(err, kErrorTypeValidation, ""invalid augroup passed."");+        goto cleanup;+      }+    } else if (strequal(""events"", k.data)) {","```suggestion    } else if (strequal(""event"", k.data)) {```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/14661,785329397,2022-01-15T16:20:57Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,583 @@+#include <stdbool.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/fileio.h""+#include ""nvim/eval/typval.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define AUCMD_MAX_PATTERNS 256++#define FOREACH_KEY_VALUE(d, k, v, code) \+  for (size_t __foreach_i = 0; __foreach_i < d.size; __foreach_i++) { \+    String k = d.items[__foreach_i].key; \+    Object *v = &d.items[__foreach_i].value; \+    code; \+  }++#define FOREACH_ITEM(a, __foreach_item, code) \+  for (size_t __foreach_i = 0; __foreach_i < a.size; __foreach_i++) { \+    Object __foreach_item = a.items[__foreach_i]; \+    code; \+  }++#define CHECK_STRING_ARRAY(__array, k, v, goto_name) \+  for (size_t j = 0; j < __array.size; j++) { \+    Object item = __array.items[j]; \+    if (item.type != kObjectTypeString) { \+      api_set_error( \+          err, \+          kErrorTypeValidation, \+          ""All entries in '%s' must be strings"", \+          k); \+      goto goto_name; \+    } \+  }++#define UNPACK_STRING_OR_ARRAY(__array, k, v, goto_name) \+  if (v->type == kObjectTypeString) { \+    ADD(__array, copy_object(*v)); \+  } else if (v->type == kObjectTypeArray) { \+    CHECK_STRING_ARRAY(__array, k, v, goto_name); \+    __array = copy_array(v->data.array); \+  } else { \+    api_set_error( \+        err, \+        kErrorTypeValidation, \+        ""'%s' must be an array or a string."", \+        k); \+    goto goto_name; \+  }++#define GET_ONE_EVENT(event_nr, event_str, goto_name) \+  char_u *__next_ev; \+  event_T event_nr = \+    event_name2nr((char_u *)event_str.data.string.data, &__next_ev); \+  if (event_nr >= NUM_EVENTS) { \+    api_set_error(err, kErrorTypeValidation, ""unexpected event""); \+    goto goto_name; \+  }+++// ID for associating autocmds created via nvim_define_autocmd+// Used to delete autocmds from nvim_del_autocmd+static int64_t next_autocmd_id = 1;++/// Get autocmds that match the requirements passed to {opts}.+/// group+/// events+/// patterns",```suggestion/// pattern```,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/14661,785329412,2022-01-15T16:21:12Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,583 @@+#include <stdbool.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/fileio.h""+#include ""nvim/eval/typval.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define AUCMD_MAX_PATTERNS 256++#define FOREACH_KEY_VALUE(d, k, v, code) \+  for (size_t __foreach_i = 0; __foreach_i < d.size; __foreach_i++) { \+    String k = d.items[__foreach_i].key; \+    Object *v = &d.items[__foreach_i].value; \+    code; \+  }++#define FOREACH_ITEM(a, __foreach_item, code) \+  for (size_t __foreach_i = 0; __foreach_i < a.size; __foreach_i++) { \+    Object __foreach_item = a.items[__foreach_i]; \+    code; \+  }++#define CHECK_STRING_ARRAY(__array, k, v, goto_name) \+  for (size_t j = 0; j < __array.size; j++) { \+    Object item = __array.items[j]; \+    if (item.type != kObjectTypeString) { \+      api_set_error( \+          err, \+          kErrorTypeValidation, \+          ""All entries in '%s' must be strings"", \+          k); \+      goto goto_name; \+    } \+  }++#define UNPACK_STRING_OR_ARRAY(__array, k, v, goto_name) \+  if (v->type == kObjectTypeString) { \+    ADD(__array, copy_object(*v)); \+  } else if (v->type == kObjectTypeArray) { \+    CHECK_STRING_ARRAY(__array, k, v, goto_name); \+    __array = copy_array(v->data.array); \+  } else { \+    api_set_error( \+        err, \+        kErrorTypeValidation, \+        ""'%s' must be an array or a string."", \+        k); \+    goto goto_name; \+  }++#define GET_ONE_EVENT(event_nr, event_str, goto_name) \+  char_u *__next_ev; \+  event_T event_nr = \+    event_name2nr((char_u *)event_str.data.string.data, &__next_ev); \+  if (event_nr >= NUM_EVENTS) { \+    api_set_error(err, kErrorTypeValidation, ""unexpected event""); \+    goto goto_name; \+  }+++// ID for associating autocmds created via nvim_define_autocmd+// Used to delete autocmds from nvim_del_autocmd+static int64_t next_autocmd_id = 1;++/// Get autocmds that match the requirements passed to {opts}.+/// group+/// events+/// patterns+Array nvim_get_autocmds(Dictionary opts, Error *err)+  FUNC_API_SINCE(9)+{+  Array autocmd_list = ARRAY_DICT_INIT;+  char_u *pattern_filters[AUCMD_MAX_PATTERNS];+  char_u pattern_buflocal[BUFLOCAL_PAT_LEN];++  bool event_set[NUM_EVENTS] = { false };+  bool check_event = false;++  int group = 0;++  int pattern_filter_count = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(""group"", k.data)) {+      if (v.type != kObjectTypeString) {+        api_set_error(err, kErrorTypeValidation, ""group must be a string."");+        goto cleanup;+      }++      group = augroup_find((char_u *)v.data.string.data);++      if (group == AUGROUP_ERROR) {+        api_set_error(err, kErrorTypeValidation, ""invalid augroup passed."");+        goto cleanup;+      }+    } else if (strequal(""events"", k.data)) {+      check_event = true;++      if (v.type == kObjectTypeString) {+        GET_ONE_EVENT(event_nr, v, cleanup);+        event_set[event_nr] = true;+      } else if (v.type == kObjectTypeArray) {+        FOREACH_ITEM(v.data.array, event_v, {+          if (event_v.type != kObjectTypeString) {+            api_set_error(+                err,+                kErrorTypeValidation,+                ""Every event must be a string in events"");+            goto cleanup;+          }++          GET_ONE_EVENT(event_nr, event_v, cleanup);+          event_set[event_nr] = true;+        })+      } else {+        api_set_error(+            err,+            kErrorTypeValidation,+            ""Not a valid 'events' value. Must be a string or an array"");+        goto cleanup;+      }+    } else if (strequal(""patterns"", k.data)) {","```suggestion    } else if (strequal(""pattern"", k.data)) {```",
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/14661,785329429,2022-01-15T16:21:33Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,583 @@+#include <stdbool.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/fileio.h""+#include ""nvim/eval/typval.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define AUCMD_MAX_PATTERNS 256++#define FOREACH_KEY_VALUE(d, k, v, code) \+  for (size_t __foreach_i = 0; __foreach_i < d.size; __foreach_i++) { \+    String k = d.items[__foreach_i].key; \+    Object *v = &d.items[__foreach_i].value; \+    code; \+  }++#define FOREACH_ITEM(a, __foreach_item, code) \+  for (size_t __foreach_i = 0; __foreach_i < a.size; __foreach_i++) { \+    Object __foreach_item = a.items[__foreach_i]; \+    code; \+  }++#define CHECK_STRING_ARRAY(__array, k, v, goto_name) \+  for (size_t j = 0; j < __array.size; j++) { \+    Object item = __array.items[j]; \+    if (item.type != kObjectTypeString) { \+      api_set_error( \+          err, \+          kErrorTypeValidation, \+          ""All entries in '%s' must be strings"", \+          k); \+      goto goto_name; \+    } \+  }++#define UNPACK_STRING_OR_ARRAY(__array, k, v, goto_name) \+  if (v->type == kObjectTypeString) { \+    ADD(__array, copy_object(*v)); \+  } else if (v->type == kObjectTypeArray) { \+    CHECK_STRING_ARRAY(__array, k, v, goto_name); \+    __array = copy_array(v->data.array); \+  } else { \+    api_set_error( \+        err, \+        kErrorTypeValidation, \+        ""'%s' must be an array or a string."", \+        k); \+    goto goto_name; \+  }++#define GET_ONE_EVENT(event_nr, event_str, goto_name) \+  char_u *__next_ev; \+  event_T event_nr = \+    event_name2nr((char_u *)event_str.data.string.data, &__next_ev); \+  if (event_nr >= NUM_EVENTS) { \+    api_set_error(err, kErrorTypeValidation, ""unexpected event""); \+    goto goto_name; \+  }+++// ID for associating autocmds created via nvim_define_autocmd+// Used to delete autocmds from nvim_del_autocmd+static int64_t next_autocmd_id = 1;++/// Get autocmds that match the requirements passed to {opts}.+/// group+/// events+/// patterns+Array nvim_get_autocmds(Dictionary opts, Error *err)+  FUNC_API_SINCE(9)+{+  Array autocmd_list = ARRAY_DICT_INIT;+  char_u *pattern_filters[AUCMD_MAX_PATTERNS];+  char_u pattern_buflocal[BUFLOCAL_PAT_LEN];++  bool event_set[NUM_EVENTS] = { false };+  bool check_event = false;++  int group = 0;++  int pattern_filter_count = 0;++  for (size_t i = 0; i < opts.size; i++) {+    String k = opts.items[i].key;+    Object v = opts.items[i].value;++    if (strequal(""group"", k.data)) {+      if (v.type != kObjectTypeString) {+        api_set_error(err, kErrorTypeValidation, ""group must be a string."");+        goto cleanup;+      }++      group = augroup_find((char_u *)v.data.string.data);++      if (group == AUGROUP_ERROR) {+        api_set_error(err, kErrorTypeValidation, ""invalid augroup passed."");+        goto cleanup;+      }+    } else if (strequal(""events"", k.data)) {+      check_event = true;++      if (v.type == kObjectTypeString) {+        GET_ONE_EVENT(event_nr, v, cleanup);+        event_set[event_nr] = true;+      } else if (v.type == kObjectTypeArray) {+        FOREACH_ITEM(v.data.array, event_v, {+          if (event_v.type != kObjectTypeString) {+            api_set_error(+                err,+                kErrorTypeValidation,+                ""Every event must be a string in events"");+            goto cleanup;+          }++          GET_ONE_EVENT(event_nr, event_v, cleanup);+          event_set[event_nr] = true;+        })+      } else {+        api_set_error(+            err,+            kErrorTypeValidation,+            ""Not a valid 'events' value. Must be a string or an array"");+        goto cleanup;+      }+    } else if (strequal(""patterns"", k.data)) {+      if (v.type == kObjectTypeString) {+        pattern_filters[pattern_filter_count] = (char_u *)v.data.string.data;+        pattern_filter_count += 1;+      } else if (v.type == kObjectTypeArray) {+        FOREACH_ITEM(v.data.array, item, {+          pattern_filters[pattern_filter_count] = (char_u *)item.data.string.data;+          pattern_filter_count += 1;+        });+      } else {+        api_set_error(+            err,+            kErrorTypeValidation,+            ""Not a valid 'patterns' value. Must be a string or an array"");","```suggestion            ""Not a valid 'pattern' value. Must be a string or an array of strings"");```",
10165741,MDeiml,https://api.github.com/repos/neovim/neovim/pulls/17099,785563458,2022-01-17T00:05:36Z,test/functional/treesitter/parser_spec.lua,"@@ -186,12 +187,18 @@ void ui_refresh(void)       { ""type"", ""primitive_type"", 8, 2, 8, 6 },       { ""keyword"", ""for"", 9, 2, 9, 5 },       { ""type"", ""primitive_type"", 9, 7, 9, 13 },+      -- captured multiple times, see https://github.com/tree-sitter/tree-sitter/issues/1591+      { ""funccall"", ""expression_statement"", 11, 4, 11, 34 },","Sry, probably wasn't to smart to add that specific test case. It's a bug in treesitter I actually spent quite a while tracking down, but it only happens with very complex queries. The bug of course doesn't come up when only one node for each capture is emitted. I'll add a better test case.",
10165741,MDeiml,https://api.github.com/repos/neovim/neovim/pulls/17099,785564091,2022-01-17T00:06:53Z,test/functional/treesitter/parser_spec.lua,"@@ -186,12 +187,18 @@ void ui_refresh(void)       { ""type"", ""primitive_type"", 8, 2, 8, 6 },       { ""keyword"", ""for"", 9, 2, 9, 5 },       { ""type"", ""primitive_type"", 9, 7, 9, 13 },+      -- captured multiple times, see https://github.com/tree-sitter/tree-sitter/issues/1591+      { ""funccall"", ""expression_statement"", 11, 4, 11, 34 },",For example this doesn't happen when the `@funccall` pattern is the only one. The issue I linked is the one I opened in the treesitter repo because of my findings.,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/17099,785663034,2022-01-17T06:21:46Z,test/functional/treesitter/parser_spec.lua,"@@ -223,7 +225,59 @@ void ui_refresh(void)       { 1, { { ""minfunc"", ""identifier"", 11, 12, 11, 15 }, { ""min_id"", ""identifier"", 11, 27, 11, 32 } } },       { 4, { { ""fieldarg"", ""identifier"", 12, 17, 12, 19 } } },       { 1, { { ""minfunc"", ""identifier"", 12, 13, 12, 16 }, { ""min_id"", ""identifier"", 12, 29, 12, 35 } } },-      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } }+      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } },+    }, res)+  end)++  it('support query and iter by capture for quantifiers', function()+    insert(test_text)++    local res = exec_lua([[+      cquery = vim.treesitter.parse_query(""c"", ...)+      parser = vim.treesitter.get_parser(0, ""c"")+      tree = parser:parse()[1]+      res = {}+      for cid, node in cquery:iter_captures(tree:root(), 0, 7, 14) do+        -- can't transmit node over RPC. just check the name and range+        table.insert(res, {cquery.captures[cid], node:type(), node:range()})+      end+      return res+    ]], '(expression_statement (assignment_expression (call_expression)))+ @funccall')",I don't see any quantifier here?It looks like you are not testing what you want...,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/17099,785663317,2022-01-17T06:22:30Z,test/functional/treesitter/parser_spec.lua,"@@ -223,7 +225,59 @@ void ui_refresh(void)       { 1, { { ""minfunc"", ""identifier"", 11, 12, 11, 15 }, { ""min_id"", ""identifier"", 11, 27, 11, 32 } } },       { 4, { { ""fieldarg"", ""identifier"", 12, 17, 12, 19 } } },       { 1, { { ""minfunc"", ""identifier"", 12, 13, 12, 16 }, { ""min_id"", ""identifier"", 12, 29, 12, 35 } } },-      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } }+      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } },+    }, res)+  end)++  it('support query and iter by capture for quantifiers', function()+    insert(test_text)++    local res = exec_lua([[+      cquery = vim.treesitter.parse_query(""c"", ...)+      parser = vim.treesitter.get_parser(0, ""c"")+      tree = parser:parse()[1]+      res = {}+      for cid, node in cquery:iter_captures(tree:root(), 0, 7, 14) do+        -- can't transmit node over RPC. just check the name and range+        table.insert(res, {cquery.captures[cid], node:type(), node:range()})+      end+      return res+    ]], '(expression_statement (assignment_expression (call_expression)))+ @funccall')++    eq({+      { ""funccall"", ""expression_statement"", 11, 4, 11, 34 },+      { ""funccall"", ""expression_statement"", 12, 4, 12, 37 },+      { ""funccall"", ""expression_statement"", 13, 4, 13, 34 },+    }, res)+  end)++  it('support query and iter by match for quantifiers', function()+    insert(test_text)++    local res = exec_lua([[+      cquery = vim.treesitter.parse_query(""c"", ...)+      parser = vim.treesitter.get_parser(0, ""c"")+      tree = parser:parse()[1]+      res = {}+      for pattern, match in cquery:iter_matches(tree:root(), 0, 7, 14) do+        -- can't transmit node over RPC. just check the name and range+        local mrepr = {}+        for cid, nodes in pairs(match) do+          for _, node in ipairs(nodes) do+            table.insert(mrepr, {cquery.captures[cid], node:type(), node:range()})+          end+        end+        table.insert(res, {pattern, mrepr})+      end+      return res+    ]], '(expression_statement (assignment_expression (call_expression)))+ @funccall')","Here again, I don't see any quantifier. ",
10165741,MDeiml,https://api.github.com/repos/neovim/neovim/pulls/17099,785832694,2022-01-17T10:34:46Z,test/functional/treesitter/parser_spec.lua,"@@ -223,7 +225,59 @@ void ui_refresh(void)       { 1, { { ""minfunc"", ""identifier"", 11, 12, 11, 15 }, { ""min_id"", ""identifier"", 11, 27, 11, 32 } } },       { 4, { { ""fieldarg"", ""identifier"", 12, 17, 12, 19 } } },       { 1, { { ""minfunc"", ""identifier"", 12, 13, 12, 16 }, { ""min_id"", ""identifier"", 12, 29, 12, 35 } } },-      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } }+      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } },+    }, res)+  end)++  it('support query and iter by capture for quantifiers', function()+    insert(test_text)++    local res = exec_lua([[+      cquery = vim.treesitter.parse_query(""c"", ...)+      parser = vim.treesitter.get_parser(0, ""c"")+      tree = parser:parse()[1]+      res = {}+      for cid, node in cquery:iter_captures(tree:root(), 0, 7, 14) do+        -- can't transmit node over RPC. just check the name and range+        table.insert(res, {cquery.captures[cid], node:type(), node:range()})+      end+      return res+    ]], '(expression_statement (assignment_expression (call_expression)))+ @funccall')",Yes the `+` is a quantifier,
39092278,vigoux,https://api.github.com/repos/neovim/neovim/pulls/17099,786181100,2022-01-17T17:08:32Z,test/functional/treesitter/parser_spec.lua,"@@ -223,7 +225,59 @@ void ui_refresh(void)       { 1, { { ""minfunc"", ""identifier"", 11, 12, 11, 15 }, { ""min_id"", ""identifier"", 11, 27, 11, 32 } } },       { 4, { { ""fieldarg"", ""identifier"", 12, 17, 12, 19 } } },       { 1, { { ""minfunc"", ""identifier"", 12, 13, 12, 16 }, { ""min_id"", ""identifier"", 12, 29, 12, 35 } } },-      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } }+      { 4, { { ""fieldarg"", ""identifier"", 13, 14, 13, 16 } } },+    }, res)+  end)++  it('support query and iter by capture for quantifiers', function()+    insert(test_text)++    local res = exec_lua([[+      cquery = vim.treesitter.parse_query(""c"", ...)+      parser = vim.treesitter.get_parser(0, ""c"")+      tree = parser:parse()[1]+      res = {}+      for cid, node in cquery:iter_captures(tree:root(), 0, 7, 14) do+        -- can't transmit node over RPC. just check the name and range+        table.insert(res, {cquery.captures[cid], node:type(), node:range()})+      end+      return res+    ]], '(expression_statement (assignment_expression (call_expression)))+ @funccall')",But this way you are not testing what you want to I think.The quantifiers in tree-sitter check for adjacent nodes repeated from what I can remember.,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17178,790287687,2022-01-23T14:54:20Z,runtime/lua/vim/filetype.lua,"@@ -892,7 +892,6 @@ local filename = {   ["".gitconfig""] = ""gitconfig"",   ["".gitmodules""] = ""gitconfig"",   [""/.config/git/config""] = ""gitconfig"",-  [""/etc/gitconfig""] = ""gitconfig"",",This looks correct but the line just above this looks suspicious. I think that should also be moved to a pattern style entry with `.*` at the beginning. Are you okay doing that as part of this PR or do you want to do it separately?,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17179,790295336,2022-01-23T15:53:24Z,runtime/doc/diff.txt,"@@ -324,8 +324,9 @@ After setting this variable, reload the syntax script: >  FINDING THE DIFFERENCES					*diff-diffexpr* -The 'diffexpr' option can be set to use something else than the standard-""diff"" program to compare two files and find the differences. *E959*+The 'diffexpr' option can be set to use something else than the internal diff+support or the standard ""diff"" program to compare two files and find the+differences. *E959*","nvim doesn't have this error since https://github.com/neovim/neovim/commit/a1e97b18f1c90fb85683bd09b597511cdf14a34e (well, it wasn't possible to trigger it anyway probably due to https://github.com/neovim/neovim/blob/bb7ef83dd33996988896891bc4ed77b92885388c/src/nvim/diff.c#L1607)",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17187,790680290,2022-01-24T12:07:57Z,src/nvim/syntax.c,"@@ -6714,6 +6714,66 @@ int lookup_color(const int idx, const bool foreground, TriState *const boldp)   return color; } +void set_hl_group(int id, HlAttrs attrs, int link_id)+{+    int idx = id - 1;  // Index is ID minus one.++    bool is_default = attrs.rgb_ae_attr & HL_DEFAULT;++    // Return if ""default"" was used and the group already has settings+    if (is_default && hl_has_settings(idx, true)) {+      return;+    }++    HlGroup *g = &HL_TABLE()[idx];++    if (link_id > 0) {+      g->sg_cleared = false;+      g->sg_link = link_id;+      return;+    }++    g->sg_cleared = false;+    g->sg_link = 0;+    g->sg_gui = attrs.rgb_ae_attr;++    g->sg_rgb_bg = attrs.rgb_bg_color;+    g->sg_rgb_fg = attrs.rgb_fg_color;+    g->sg_rgb_sp = attrs.rgb_sp_color;++    char name[8];++    struct {+      char **name; RgbValue *val;+    } cattrs[] = {+      { &g->sg_rgb_bg_name, &g->sg_rgb_bg },+      { &g->sg_rgb_fg_name, &g->sg_rgb_fg },+      { &g->sg_rgb_sp_name, &g->sg_rgb_sp },+      { NULL, 0 },+    };++    for (int j = 0; cattrs[j].name; j++) {+      if (*cattrs[j].val != -1) {+        xfree(*cattrs[j].name);+        snprintf(name, sizeof(name), ""#%06x"", *cattrs[j].val);","Admittedly, I only did this as a low effort solution to get `:highlight [name]<cr>` to work correctly since its value is used as a condition in places, e.g: https://github.com/neovim/neovim/blob/1907a9481423ccf4433f8184bbfdc633589e43f5/src/nvim/syntax.c#L7604-L7606But yeah, Ideally we should keep the name if we can.Can you spoon-feed me a bit on how to change the dict to a keyset? Is there an example in the codebase I can work off?",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17092,794391307,2022-01-28T10:42:57Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -20,12 +20,13 @@ pressing [<Esc>](<Esc>) and then [u](u) will undo the latest change. This tutorial is interactive, and there are a few things you should know. - Type [<Enter>](<Enter>) on links [like this](holy-grail    ) to open the linked help section. - Or simply type [K](K) on any word to find its documentation!+- You can close this help split with `:q`{vim}","maybe ""help window"" is better? ""split"" is a technical Vim term that beginners are likely not familiar with",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17092,794396035,2022-01-28T10:49:14Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -888,12 +891,12 @@ You can find help on just about any subject, by giving an argument to the ~~~ # Lesson 7.2: CREATE A STARTUP SCRIPT -** Enable Vim features. **+** Enable Neovim features. ** -Vim has many more features than Vi, but most of them are disabled by-default. To start using more features you have to create a ""vimrc"" file.+Neovim has many more features than Vi, but most of them are disabled by default.+To start using more features you have to create a ""init.vim"" or ""init.lua"" file.",We only refer to `init.vim` in the following; maybe keep it to that here as well. (Don't introduce complexity _without necessity_.),
33930918,RoryNesbitt,https://api.github.com/repos/neovim/neovim/pulls/17092,794596094,2022-01-28T15:18:35Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -219,15 +220,15 @@ There are a some words fun that don't belong paper in this sentence.  # Lesson 2.2: MORE DELETION COMMANDS -** Type `d$`{normal} to delete to the end of the line. **+** Type `d$`{normal} or `D`{normal} to delete to the end of the line. **","As to your inital question here however.. I'm not sure that showing both ways is better but I would say learning D is better in the long run than learning d$, I just don't want to take away from teaching what $ means by itself",
24854248,echasnovski,https://api.github.com/repos/neovim/neovim/pulls/17112,795036354,2022-01-29T10:15:26Z,src/nvim/ex_session.c,"@@ -614,7 +632,10 @@ static int makeopens(FILE *fd, char_u *dirnow)     // Similar to ses_win_rec() below, populate the tab pages first so     // later local options won't be copied to the new tabs.     FOR_ALL_TABS(tp) {-      if (tp->tp_next != NULL && put_line(fd, ""tabnew"") == FAIL) {+      // Use `bufhidden=wipe` to remove empty ""placeholder"" buffers once+      // they are not needed. This prevents creating extra buffers (see+      // cause of Vim patch 8.1.0829)+      if (tp->tp_next != NULL && put_line(fd, ""tabnew +setlocal\\ bufhidden=wipe"") == FAIL) {","Well, it seems like it actually does! Don't know why I didn't think about this way in the first place.Do you want me to use `tab split` here? This will differ from already merged Vim's implementation. Not sure which one is better though: with `bufhidden` it creates independent extra ""placholder"" buffers for every tab, which might be a good idea.",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17112,795048229,2022-01-29T12:40:55Z,src/nvim/ex_session.c,"@@ -614,7 +632,10 @@ static int makeopens(FILE *fd, char_u *dirnow)     // Similar to ses_win_rec() below, populate the tab pages first so     // later local options won't be copied to the new tabs.     FOR_ALL_TABS(tp) {-      if (tp->tp_next != NULL && put_line(fd, ""tabnew"") == FAIL) {+      // Use `bufhidden=wipe` to remove empty ""placeholder"" buffers once+      // they are not needed. This prevents creating extra buffers (see+      // cause of Vim patch 8.1.0829)+      if (tp->tp_next != NULL && put_line(fd, ""tabnew +setlocal\\ bufhidden=wipe"") == FAIL) {","> Do you want me to use tab split here?This PR looks fine to me. It was just an observation. :+1:You can consider upstreaming that change if you'd like to. If it's accepted it can be ported here later.> it creates independent extra ""placholder"" buffers for every tab, which might be a good ideaNot sure if that's useful. The restored buffers hide whatever buffer was being viewed in that tabpage anyway.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17092,795158011,2022-01-30T10:11:43Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -934,43 +953,25 @@ NOTE: Completion works for many commands. It is especially useful for `:help`{vi   4. Type `:q`{vim} to close the help window - 5. Create a vimrc startup script to keep your preferred settings.+ 5. Create a init.vim startup script to keep your preferred settings.   6. While in command mode, press `<C-d>`{normal} to see possible completions.     Press `<Tab>`{normal} to use one completion.  # CONCLUSION -This was intended to give a brief overview of the Vim editor, just enough to-allow you to use the editor fairly easily. It is far from complete as Vim has+This was intended to give a brief overview of the Neovim editor, just enough to+allow you to use it fairly easily. It is far from complete as Neovim has many many more commands. Consult the help often.--There are many resources online to learn more about vim. Here's a bunch of-them:--- *Learn Vim Progressively*:-  http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/-- *Learning Vim in 2013*:-  http://benmccormick.org/learning-vim-in-2014/-- *Vimcasts*:-  http://vimcasts.org/-- *Vim Video-Tutorials by Derek Wyatt*:-  http://derekwyatt.org/vim/tutorials/-- *Learn Vimscript the Hard Way*:-  http://learnvimscriptthehardway.stevelosh.com/-- *7 Habits of Effective Text Editing*:-  http://www.moolenaar.net/habits.html-- *vim-galore*:-  https://github.com/mhinz/vim-galore--If you prefer a book, *Practical Vim* by Drew Neil is recommended often-(the sequel, *Modern Vim*, includes material specific to nvim).+There are also countless great tutorials and videos to be found online, some+even by the maintainers of Neovim.","Why did you remove the references? Is the book really not applicable?In general, I think it's fine to also recommend Vim resources to very beginners, since the fundamentals are not different. Maybe leave them in but preface them with an explanation? (""For the basics, resources on learning Vim are also helpful since the fundamental editing model is the same, but be aware that some options may be set differently by default. Here's a partial list."")Feel free to remove resources that are too stale, though. I wouldn't stress the ""maintainers of Neovim"", either.",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17092,795162284,2022-01-30T10:47:25Z,runtime/tutor/en/vim-01-beginner.tutor,"@@ -934,43 +953,25 @@ NOTE: Completion works for many commands. It is especially useful for `:help`{vi   4. Type `:q`{vim} to close the help window - 5. Create a vimrc startup script to keep your preferred settings.+ 5. Create a init.vim startup script to keep your preferred settings.   6. While in command mode, press `<C-d>`{normal} to see possible completions.     Press `<Tab>`{normal} to use one completion.  # CONCLUSION -This was intended to give a brief overview of the Vim editor, just enough to-allow you to use the editor fairly easily. It is far from complete as Vim has+This was intended to give a brief overview of the Neovim editor, just enough to+allow you to use it fairly easily. It is far from complete as Neovim has many many more commands. Consult the help often.--There are many resources online to learn more about vim. Here's a bunch of-them:--- *Learn Vim Progressively*:-  http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/-- *Learning Vim in 2013*:-  http://benmccormick.org/learning-vim-in-2014/-- *Vimcasts*:-  http://vimcasts.org/-- *Vim Video-Tutorials by Derek Wyatt*:-  http://derekwyatt.org/vim/tutorials/-- *Learn Vimscript the Hard Way*:-  http://learnvimscriptthehardway.stevelosh.com/-- *7 Habits of Effective Text Editing*:-  http://www.moolenaar.net/habits.html-- *vim-galore*:-  https://github.com/mhinz/vim-galore--If you prefer a book, *Practical Vim* by Drew Neil is recommended often-(the sequel, *Modern Vim*, includes material specific to nvim).+There are also countless great tutorials and videos to be found online, some+even by the maintainers of Neovim.","Yeah, which drops them into a sea of bad/outdated/monetized advice ;) That's exactly why a curated list of stable resources is helpful.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,797071860,2022-02-01T22:03:04Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","Also thought about this, the bug mentioned https://github.com/neovim/neovim/pull/15723#issuecomment-955615213  is probably outside of this PR where I just assume bytes here (https://github.com/theHamsta/nvim-semantic-tokens/blob/77f5b716ecb13e4c692d4ec442da75ba850d8441/lua/nvim-semantic-tokens.lua#L58)",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15723,797074261,2022-02-01T22:05:52Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false","This is a good illustration of what the current client.request API is suboptimal. Ideally we should just cancel the request via the request ID when a user has taken an action that would invalidate the semantic tokens.This is generally a problem whenever applying highlights from the language server... In reality, if the *only* changes from the last update tick are on the current line, we should be able to apply highlights everywhere else in the document (but the current line)....@mfussenegger one option might be to expose lastline/new_lastline ranges to the handlers, like ""these were the changed ranges since the request was fired"" ",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,797075513,2022-02-01T22:07:16Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {",@zbirenbaum  I only tested this PR with clangd using this plugin https://github.com/theHamsta/nvim-semantic-tokens . It would be important to validate this PR also with other LSP implementations like zls or sumneko_lua. rust-analyzer does not use standard-conformant semantic tokens. You could test manually and dump the responses from the LSP servers on a simple file for tests.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,797117223,2022-02-01T22:54:02Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {",Really? I saw all the mapping to to highlighting in the typescript part of rust-analyzer an guessed that their implementation predated semantic tokens. But that's nice to hear!,
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/15723,797135703,2022-02-01T23:17:56Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","@theHamsta I planned to use pylance as I have it running in cli and it supports semantic tokens (unlike pyright), but don't tell microsoft, not sure it gets much less standard than that. I was unaware sumneko supported semantic tokens but I will try it with that too. Thanks for the updates and info, i'll see what I can do.Thanks for working on treesitteer by the way!",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14661,800038804,2022-02-05T09:23:45Z,src/nvim/api/autocmd.c,"@@ -0,0 +1,669 @@+#include <stdbool.h>+#include <stdio.h>++#include ""lauxlib.h""+#include ""nvim/api/autocmd.h""+#include ""nvim/api/private/defs.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/ascii.h""+#include ""nvim/buffer.h""+#include ""nvim/eval/typval.h""+#include ""nvim/fileio.h""+#include ""nvim/lua/executor.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""api/autocmd.c.generated.h""+#endif++#define AUCMD_MAX_PATTERNS 256++// Check whether every item in the array is a kObjectTypeString+#define CHECK_STRING_ARRAY(__array, k, v, goto_name) \","I think this should just be a function.```if (!check_string_array(patterns, ""pattern"", v, err)) {  goto cleanup;}```",X
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17077,800050626,2022-02-05T11:57:39Z,src/nvim/eval.c,"@@ -8191,7 +8245,11 @@ pos_T *var2fpos(const typval_T *const tv, const bool dollar_lnum, int *const ret     if (error) {       return NULL;     }-    len = (long)STRLEN(ml_get(pos.lnum));+    if (charcol) {+      len = (long)mb_charlen(ml_get(pos.lnum));+    } else {+      len = (long)STRLEN(ml_get(pos.lnum));+    }",len is int. Not sure why Vim casts to long here,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17286,800811812,2022-02-07T16:05:10Z,runtime/doc/treesitter.txt,"@@ -19,6 +19,10 @@ within `vim.treesitter.language_version`. This number is not too helpful unless you are wondering about compatibility between different versions of compiled grammars. +                                     *vim.treesitter.minimum_language_version*+This is the earliest parser ABI version that is supported by the current+version of the tree-sitter library.",```suggestionThe earliest parser ABI version that is supported by the bundled tree-sitter library.```,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17286,800812607,2022-02-07T16:06:02Z,runtime/doc/treesitter.txt,"@@ -19,6 +19,10 @@ within `vim.treesitter.language_version`. This number is not too helpful unless you are wondering about compatibility between different versions of compiled grammars.",```suggestionThe latest parser ABI version that is supported by the bundled tree-sitter library.```(I can only comment on the last line; this should replace the whole paragraph.),
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/17323,800956558,2022-02-07T18:48:13Z,.github/workflows/labeler.yml,"@@ -32,3 +32,39 @@ jobs:     - name: ""Extract commit scope and add as label""       continue-on-error: true       run: gh pr edit ""$PR_NUMBER"" --add-label ""$(echo ""$PR_TITLE"" | sed -E 's|[[:alpha:]]+\((.+)\)!?:.*|\1|')""++  add-reviewer:+    runs-on: ubuntu-latest+    needs: [""triage"", ""type-scope""]+    steps:+      - uses: actions/github-script@v5+        with:+          script: |+            const reviewers = []++            const { data: { labels: labels } } = await github.rest.pulls.get({",This should work too:```suggestion            const { data: { labels } } = await github.rest.pulls.get({```,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17337,802648576,2022-02-09T13:15:22Z,src/nvim/quickfix.c,"@@ -2723,9 +2721,7 @@ static int qf_jump_edit_buffer(qf_info_T *qi, qfline_T *qf_ptr, int forceit, win     return NOTDONE;   } -  if (old_qf_curlist != qi->qf_curlist","any specific reason these conditions are now dead, like some code that was deleted (which could have changed curlist)? mentioning it in the commit message could be useful for future reference.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/17359,803836692,2022-02-10T16:05:02Z,.github/workflows/reviews.yml,"@@ -0,0 +1,103 @@+name: ""Request reviews""+on:+  pull_request_target:+    types: [labeled]+  workflow_run:+    workflows: [Pull Request Labeler]+    types: [completed]+jobs:+  request-reviewer:+    runs-on: ubuntu-latest+    permissions:+      pull-requests: write+    steps:+      - uses: actions/github-script@v5+        with:+          script: |+            const reviewers = []++            // The number of the pull request that triggered this run. If label+            // was added manually by a person the number will be stored in current+            // context, otherwise the number will be stored in the payload.+            const pr_number = context.issue.number || context.payload.workflow_run.pull_requests[0].number++            const pr_data = await github.rest.pulls.get({+              owner: context.repo.owner,+              repo: context.repo.repo,+              pull_number: pr_number+            })+            const labels = pr_data.data.labels.map(e => e.name)++            if (labels.includes('api')) {+              reviewers.push(""bfredl"")","Instead of obliterating any existing reviewers the author may have added, what about augmenting them?  This won't handle removing people due to a label being removed, but I think that's ok.```suggestion            const reviewers = new Set(pr_data.data.reviewers.map(r => r.login))            if (labels.includes('api')) {              reviewers.add(""bfredl"")```",
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/15723,804248689,2022-02-10T23:52:06Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","> I noticed pylance has a `namespace` tokenType that is missing here. Never mind, that was what vscode sent to the server.How are you seeing the communication between pylance and vscode? Pylance was strange with this PR, as it errors stating that no server supports semantic highlights on first request, but then on the next request for them functions perfectly fine. I'm curious if it's a result of some off spec implementation or an edge case of the code in this PR that needs handling.I believe that the change to make pylance vscode-only occurred after semantic highlights were implemented in it, so anyone else who wants to test this could probably download an old version and use it without having to be forever labeled by microsoft's omniscient lawyers as a license breaker. Edit: @theHamsta  It is almost assuredly an edge case. Calling semantic_tokens_full() from autocmd causes the same issue with lua language server. It was 'fixable' by forcing the autocommand to wait to be registered until after the 'done' field was received in progress messages. Unfortunately, pylance did not have any real progress messages, and I don't love the idea of making functionality dependent on a different language server capability if there are other possibilities.I can't really think of a 'good' way to do this, but simply suppressing the output by modifying the autocommand for your plugin to: `vim.cmd[[ autocmd BufEnter,CursorHold,InsertLeave <buffer> silent! lua require'vim.lsp.buf'.semantic_tokens_full() ]]` works with all LSPs I tested it with, inelegant as it may be (although what looks like an error flashes for a few ms on opening a buffer) ",
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/15723,804436349,2022-02-11T08:24:46Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","> Well, I have the possibility to react to errors. If the error message is helpful that it sends (.i.e. not ready I could react to it. Maybe we can also check the capabilities dynamicallyHere's the output I get from opening a lua file (I have the token handler in the plugin set to print the table it receives to make sure it is working):![2022-02-11-031807_929x444_scrot](https://user-images.githubusercontent.com/32016110/153558397-649676d4-818b-49f9-9cdb-b6d1a75236ee.png)![2022-02-11-031841_1085x211_scrot](https://user-images.githubusercontent.com/32016110/153558398-01e71164-86ac-4d86-8279-fa08ee8224eb.png)I am also getting this issue with clangd, although I know for certain I was not before. This may be a side effect of rebasing the changes onto an up to date neovim. While there weren't any conflicts in doing so, and this behavior was present prior for pylance, it was not (that I can recall) for clangd and lua.Edit: Changing the au declaration to```vim.defer_fn(function()   vim.cmd[[ autocmd BufEnter,CursorHold,InsertLeave <buffer> lua require'vim.lsp.buf'.semantic_tokens_full()]]end, 100)```Fixes all issues and runs seamlessly with all 3 lsp. Unfortunately schedule_wrap-ing it is insufficient so a real delay is required, and a 100ms delay may not be enough on some slower machines...",
30515389,tiagovla,https://api.github.com/repos/neovim/neovim/pulls/15723,804672495,2022-02-11T13:56:26Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","> > I noticed pylance has a `namespace` tokenType that is missing here. Never mind, that was what vscode sent to the server.> > How are you seeing the communication between pylance and vscode? Pylance was strange with this PR, as it errors stating that no server supports semantic highlights on first request, but then on the next request for them functions perfectly fine. I'm curious if it's a result of some off spec implementation or an edge case of the code in this PR that needs handling.> > I believe that the change to make pylance vscode-only occurred after semantic highlights were implemented in it, so anyone else who wants to test this could probably download an old version and use it without having to be forever labeled by microsoft's omniscient lawyers as a license breaker.> > Edit: @theHamsta It is almost assuredly an edge case. Calling semantic_tokens_full() from autocmd causes the same issue with lua language server. It was 'fixable' by forcing the autocommand to wait to be registered until after the 'done' field was received in progress messages. Unfortunately, pylance did not have any real progress messages, and I don't love the idea of making functionality dependent on a different language server capability if there are other possibilities.> > I can't really think of a 'good' way to do this, but simply suppressing the output by modifying the autocommand for your plugin to: `vim.cmd[[ autocmd BufEnter,CursorHold,InsertLeave <buffer> silent! lua require'vim.lsp.buf'.semantic_tokens_full() ]]` works with all LSPs I tested it with, inelegant as it may be (although what looks like an error flashes for a few ms on opening a buffer)I did a wrapper around the server (ipc process) and logged the input and output. I'm also using the latest version with no issues. I'm enabling it inside the on_attach.```lualocal on_attach = function(client, bufnr)    if client.resolved_capabilities.semantic_tokens_full == true then        vim.cmd [[autocmd BufEnter,CursorHold,InsertLeave <buffer> lua vim.lsp.buf.semantic_tokens_full()]]    endend```",
4771462,disrupted,https://api.github.com/repos/neovim/neovim/pulls/15723,804789167,2022-02-11T16:02:03Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","> I noticed pylance has a `namespace` tokenType that is missing here. Never mind, that was what vscode sent to the server.well spotted! the `namespace` token is also mentioned in the LSP specification. https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#semanticTokenTypesedit: it's also already in https://github.com/theHamsta/nvim-semantic-tokens but hasn't been added here",
32016110,zbirenbaum,https://api.github.com/repos/neovim/neovim/pulls/15723,804888389,2022-02-11T18:03:11Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {"," > I did a wrapper around the server (ipc process) and logged the input and output. I'm also using the latest version with no issues. I'm enabling it inside the on_attach.> > ```lua> local on_attach = function(client, bufnr)>     if client.resolved_capabilities.semantic_tokens_full == true then>         vim.cmd [[autocmd BufEnter,CursorHold,InsertLeave <buffer> lua vim.lsp.buf.semantic_tokens_full()]]>     end> end> ```Placing that inside of attach hook works perfectly with pylance, lua, and clangd. ""== true"" is a bit repetitive and can be simplified to: `if client.resolved_capabilities.semantic_tokens_full then ...`but I would recommend putting the snippet you provided with that slight adjustment into in the official documentation for this PR.",
11534587,glacambre,https://api.github.com/repos/neovim/neovim/pulls/17325,804898744,2022-02-11T18:17:48Z,runtime/doc/builtin.txt,"@@ -7412,6 +7412,9 @@ stdioopen({opts})			 *stdioopen()*  		{opts} is a dictionary with these keys: 		  |on_stdin| : callback invoked when stdin is written to.+		  |on_print| : callback invoked when neovim needs to print+			     a message, with the message (whose type is+			     string) as sole argument.","No return value. The callback doesn't have to do anything, but for example, in firenvim, it stores the message in a global list that is later on read and displayed through the browser's UI. This helps with troubleshooting as messages printed to stdout/stderr are otherwise lost (browser extensions can't read them at all).",
30515389,tiagovla,https://api.github.com/repos/neovim/neovim/pulls/15723,805102455,2022-02-12T02:08:21Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,162 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+--- +--- This function can be configured with |vim.lsp.with()| with the following options for `config`+--- +--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line       -- line number 0-based+---         start_char -- start character 0-based+---         length     -- length in characters of this token+---         type       -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers  -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens +---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {","Another thing I noticed is that pylance's `textDocument/semanticTokens/full/delta` is just a copy of its `textDocument/semanticTokens/full`, all tokens are sent, clangd's `textDocument/semanticTokens/full/delta` works like in the lsp specs. Clangd's `textDocument/semanticTokens/range` is not implemented, but pylance's is. This might or might not help you test those features.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16897,805161403,2022-02-12T13:29:59Z,src/nvim/buffer.c,"@@ -5475,6 +5480,17 @@ int buf_signcols(buf_T *buf)         linesum++;       }     }++    if (curline > 0) {+      linesum += decor_signcols(buf, &decor_state, (int)curline-1, (int)curline-1);+    }+    if (linesum > signcols) {+      signcols = linesum;+    }++    // Check extmarks between signs+    linesum = decor_signcols(buf, &decor_state, 0, (int)buf->b_ml.ml_line_count-1);","There is a problem here. Given that `buf_signcols` is called often, this means the entire tree has to be rescanned each time, sometimes on each line change (as `mark_adjust` will invalidate the signcol count). This is what the inherited code from vim does, but our code aims to scale much better to huge amount of marks.I'd suggest, for now only keep track of whether the buffer does contain extsigns or not. This can be done with a counter similar to `buf->b_virt_line_blocks` , and then we say extsigns always contribute 1 to `signcols` when there is at least one the buffer. This will be good enough in many cases, including the default configuration. Then we can consider how to support `auto:[MANY]` effectively as a follow-up. ",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/16897,805165322,2022-02-12T14:13:45Z,src/nvim/buffer.c,"@@ -5475,6 +5480,17 @@ int buf_signcols(buf_T *buf)         linesum++;       }     }++    if (curline > 0) {+      linesum += decor_signcols(buf, &decor_state, (int)curline-1, (int)curline-1);+    }+    if (linesum > signcols) {+      signcols = linesum;+    }++    // Check extmarks between signs+    linesum = decor_signcols(buf, &decor_state, 0, (int)buf->b_ml.ml_line_count-1);","Hmm, it's important to me that `auto` works properly. I'll go ahead with your suggestion, but I'd want to follow this up pretty quickly, preferably before release. Do you have any ideas on how we can do this more efficiently? My only idea would be to store sign extmarks in a different tree to avoid iterating over the buftext marks each time, they don't really benefit being stored in the same tree anyway.Personally, I would be happy to take the perf hit. Is it really that bad?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16897,805166918,2022-02-12T14:30:49Z,src/nvim/buffer.c,"@@ -5475,6 +5480,17 @@ int buf_signcols(buf_T *buf)         linesum++;       }     }++    if (curline > 0) {+      linesum += decor_signcols(buf, &decor_state, (int)curline-1, (int)curline-1);+    }+    if (linesum > signcols) {+      signcols = linesum;+    }++    // Check extmarks between signs+    linesum = decor_signcols(buf, &decor_state, 0, (int)buf->b_ml.ml_line_count-1);","> Is it really that bad?Yes, it defeats the purpose of having a B-tree, at least on the read side, if the entire tree is being read every time time there is a change.> Personally, I would be happy to take the perf hit.A compromise then is to as I suggested for yes, no, and `auto[:1]` , and the full scan only on `auto:bigger`. > My only idea would be to store sign extmarks in a different tree to avoid iterating over the buftext marks each time.This makes sense. In general having multiple trees is something I'd like to support, also for virt_lines/anticonceal.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17375,805174058,2022-02-12T15:44:48Z,src/nvim/api/vim.c,"@@ -601,7 +601,19 @@ void nvim_del_current_line(Error *err) Object nvim_get_var(String name, Error *err)   FUNC_API_SINCE(1) {-  return dict_get_value(&globvardict, name, err);+  dictitem_T *di = tv_dict_find(&globvardict, name.data, (ptrdiff_t)name.size);+  if (di == NULL) {  // try to autoload script+    if (!script_autoload(name.data, name.size, false || aborting())) {","From looking at the code base, `aborting()` should be outside of the function parameters. Since now you are actually asking `script_autload` to ""reload"" the script if already loaded and actually aborting. So perhaps should be:```suggestion    if (!script_autoload(name.data, name.size, false) || aborting()) {```Both current examples in the code base do it this way https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/neovim/neovim%24+autoload.*%5Cn%3F.*aborting&patternType=regexp",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/16897,805183161,2022-02-12T17:18:04Z,src/nvim/buffer.c,"@@ -5475,6 +5480,17 @@ int buf_signcols(buf_T *buf)         linesum++;       }     }++    if (curline > 0) {+      linesum += decor_signcols(buf, &decor_state, (int)curline-1, (int)curline-1);+    }+    if (linesum > signcols) {+      signcols = linesum;+    }++    // Check extmarks between signs+    linesum = decor_signcols(buf, &decor_state, 0, (int)buf->b_ml.ml_line_count-1);","> A compromise then is to as I suggested for yes, no, and auto[:1] , and the full scan only on auto:bigger.I'll do you one better: #17383. We can merge that and I'll rebase this on top and make similar changes in the extmark loop.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15723,805183979,2022-02-12T17:25:54Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,164 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or not response or not response.data or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then","Yeah I agree, my bigger issue is with generally how we are doing invalidation, which is why I don't want to hold this up, maybe let's file an issue about it. My general idea is we should do request invalidation (cancelling) coupled with response invalidation, and we should probably expose in context the buffer tick when the request was sent.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15723,805184459,2022-02-12T17:30:54Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,165 @@+local M = {}++local semantic_tokens = setmetatable({}, {","An alternative would be storing the semantic tokens on the client object itself, I'm a bit concerned generally that we are spreading/storing client specified state across all of these different files. When the client self-terminates it should be able to cleanup it's own state (including stale semantic tokens) in on_exit.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15723,805184907,2022-02-12T17:35:17Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,164 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return (n / math.pow(2, k)) % 2+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  if err or not response or not response.data or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then","Like I said, I'm fine merging this PR as I would rather keep the changes scoped to adding the basic version of semantic token support anyways, we can do codelens + semantic tokens invalidation in a follow-up",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,805186596,2022-02-12T17:52:02Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,165 @@+local M = {}++local semantic_tokens = setmetatable({}, {","So we would probably add a per-buffer object, where clients can store their per-buffer data. So that we can clean-up on client termination or on buffer close.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15723,805186720,2022-02-12T17:53:26Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,165 @@+local M = {}++local semantic_tokens = setmetatable({}, {","Yes, I was thinking like `client.state['buffer'].{semantic_tokens,codelens}` then we could possibly register a set of callbacks on the client object that are triggered on buf detach and exit . We do something similar with our sync implementation. CC'ing @mfussenegger to see what he thinks.",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,805187185,2022-02-12T17:58:01Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,233 @@+local M = {}+local ns = vim.api.nvim_create_namespace(""lsp-semantic-tokens"")++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+	local rtn = {}+	rawset(table, key, rtn)+	return rtn+  end})+local last_tick = {}+local active_requests = {}++---@private+local function modifiers_from_number(x, modifiers_table)+  ---@private+  local function get_bit(n, k)+    --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+    if _G.bit then+      return _G.bit.band(_G.bit.rshift(n, k), 1)+    else+      return (n / math.pow(2, k)) % 2+    end+  end++  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++M.token_map = {+  namespace = ""LspNamespace"",+  type = ""LspType"",+  class = ""LspClass"",+  enum = ""LspEnum"",+  interface = ""LspInterface"",+  struct = ""LspStruct"",+  typeParameter = ""LspTypeParameter"",+  parameter = ""LspParameter"",+  variable = ""LspVariable"",+  property = ""LspProperty"",+  enumMember = ""LspEnumMember"",+  event = ""LspEvent"",+  [""function""] = ""LspFunction"",+  method = ""LspMethod"",+  macro = ""LspMacro"",+  keyword = ""LspKeyword"",+  modifier = ""LspModifier"",+  comment = ""LspComment"",+  string = ""LspString"",+  number = ""LspNumber"",+  regexp = ""LspRegexp"",+  operator = ""LspOperator""+}++M.modifiers_map = {+  declaration = ""LspDeclaration"",+  definition = ""LspDefinition"",+  readonly = ""LspReadonly"",+  static = ""LspStatic"",+  deprecated = ""LspDeprecated"",+  abstract = ""LspAbstract"",+  async = ""LspAsync"",+  modification = ""LspModification"",+  documentation = ""LspDocumentation"",+  defaultLibrary = ""LspDefaultLibrary""+}++---@private+local function make_cache(base_map)+  return setmetatable({}, { __index = function(outer_table, ft)+    local rtn = setmetatable({}, { __index = function(inner_table, key)+      local hl = base_map[key]+      if hl then+	local prefixed+	if type(hl) == ""table"" then+	  prefixed = {}+	  for k, v in pairs(hl) do+	    local prefixed_v = ft..v+	    vim.cmd(""highlight default link "" .. prefixed_v .. "" "" .. v)+	    prefixed[k] = prefixed_v+	  end+	else+	  prefixed = ft..hl+	  vim.cmd(""highlight default link "" .. prefixed .. "" "" .. hl)+	end+	rawset(inner_table, key, prefixed)+	return prefixed+      end+      return hl+    end})+    rawset(outer_table, ft, rtn)+    return rtn+  end})+end++local token_cache = make_cache(M.token_map)+local modifiers_cache = make_cache(M.modifiers_map)++---@private+local function highlight(buf, token, hl)+  vim.highlight.range(buf, ns, hl, {token.line, token.start_char}, {token.line, token.start_char + token.length})+end++---@private+local function highlight_token(buf, token, ft_token_cache, ft_modifiers_cache)+  local hl = ft_token_cache[token.type]+  if hl then+    highlight(buf, token, hl)+  end+  for _, m in pairs(token.modifiers) do+    hl = ft_modifiers_cache[m]+    -- modifiers can have a per-type mapping+    -- e.g. readonly = { variable = ""ReadOnlyVariable"" }+    if type(hl) == ""table"" then+      hl = hl[token.type]+    end+    if hl then+      highlight(buf, token, hl)+    end+  end+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+function M.on_full(err, response, ctx, _)+  if not ctx.bufnr or not ctx.client_id then return end+  active_requests[ctx.bufnr] = false+  vim.api.nvim_buf_clear_namespace(ctx.bufnr, ns, 0, -1)+  -- if tick is has changed our response is outdated!+  if err or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    semantic_tokens[ctx.bufnr][ctx.client_id] = {}+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data+  local ft = vim.api.nvim_buf_get_option(ctx.bufnr, ""filetype"")+  local ft_token_cache = token_cache[ft]+  local ft_modifiers_cache = modifiers_cache[ft]++  local tokens = {}+  local line, start_char = nil, 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {+      line = line,+      start_char = start_char,+      length = data[i + 2],+      type = token_type,+      modifiers = modifiers+    }+    tokens[line + 1] = tokens[line + 1] or {}",If you want to use semantic tokens for an application you can now either attach a handler that handles `on_token` or you look at the cached state where you can look whether there are tokens at specific lines. Otherwise you would need to bisect the tokens or walk the whole list.We could also remove the caching altogether and require that a highlighting callback manages their own state if required. The state itself is often not that useful since you need to know when an update is required.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/16897,805323287,2022-02-13T11:53:43Z,src/nvim/buffer.c,"@@ -5464,6 +5465,10 @@ static int buf_signcols_inner(buf_T *buf, int maximum)    FOR_ALL_SIGNS_IN_BUF(buf, sign) {     if (sign->se_lnum > curline) {+      // Counted all signs, now add extmark signs+      if (curline > 0) {+        linesum += decor_signcols(buf, &decor_state, (int)curline-1, (int)curline-1, maximum-linesum);",Clint complains that this line is too long (>100 columns).,
59826753,kylo252,https://api.github.com/repos/neovim/neovim/pulls/16336,805787451,2022-02-14T12:20:40Z,src/nvim/regexp.c,,"I don't see this one anymore, was it this one? https://github.com//kylo252/neovim/blob/b43ade5d71d14dce27522bcb09c0aa4842a8ff21/src/nvim/regexp_bt.c#L3836-L3837",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17422,807605448,2022-02-16T06:59:26Z,src/nvim/getchar.c,"@@ -3435,7 +3434,8 @@ static void showmap(mapblock_T *mp, bool local)   size_t len = 1;    if (message_filtered(mp->m_keys)-      && mp->m_str != NULL && message_filtered(mp->m_str)) {+      && message_filtered(mp->m_str[0] != NUL ? mp->m_str : (char_u *)""<Nop>"")",In `map.txt`:```The |:filter| command can be used to select what mappings to list.  Thepattern is matched against the {lhs} and {rhs} in the raw form.```Related: <https://github.com/vim/vim/issues/9091>,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17426,807755415,2022-02-16T10:09:00Z,runtime/doc/map.txt,"@@ -502,10 +509,7 @@ Note: When using mappings for Visual mode, you can use the ""'<"" mark, which is the start of the last selected Visual area in the current buffer |'<|.  The |:filter| command can be used to select what mappings to list.  The-pattern is matched against the {lhs} and {rhs} in the raw form.  If a-description was added using |nvim_set_keymap()| or |nvim_buf_set_keymap()|-then the pattern is also matched against it.-+pattern is matched against the {lhs}, {rhs} and {desc} in the raw form. ","```suggestionpattern is matched against the {lhs}, {rhs} and <desc> in the raw form. ```",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17421,808345787,2022-02-16T18:44:56Z,src/nvim/syntax.c,"@@ -6758,16 +6758,27 @@ void set_hl_group(int id, HlAttrs attrs, Dict(highlight) *dict, int link_id)     { NULL, -1, NIL },   }; +  char hex_name[8];+  char *name;+   for (int j = 0; cattrs[j].dest; j++) {-    if (cattrs[j].val != -1) {+    if (cattrs[j].val < 0) {+      XFREE_CLEAR(*cattrs[j].dest);+      continue;+    }++    if (cattrs[j].name.type == kObjectTypeString+        && cattrs[j].name.data.string.size) {","Personally I prefer it this way given how long each term is.As I do most work in splits on a laptop, I usually keep *most* code within 80 chars as a soft limit, with 100 being the hard limit.If you insist, I don't mind changing it.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17421,808349873,2022-02-16T18:50:01Z,src/nvim/syntax.c,"@@ -6758,16 +6758,27 @@ void set_hl_group(int id, HlAttrs attrs, Dict(highlight) *dict, int link_id)     { NULL, -1, NIL },   }; +  char hex_name[8];+  char *name;+   for (int j = 0; cattrs[j].dest; j++) {-    if (cattrs[j].val != -1) {+    if (cattrs[j].val < 0) {+      XFREE_CLEAR(*cattrs[j].dest);+      continue;+    }++    if (cattrs[j].name.type == kObjectTypeString+        && cattrs[j].name.data.string.size) {","I understand and appreciate the desire to keep a 80 char limit (I actually pushed against the increase to 100 chars to begin with), but I personally find the two line condition harder to read and parse.That said this isn't a hill I'm going to die on. It is fine with me -- other folks can chime in if they have an opinion.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/17427,809468288,2022-02-17T21:08:45Z,.github/workflows/ci.yml,"@@ -30,30 +30,11 @@ jobs:       - name: Install apt packages         run: |           sudo apt-get update-          sudo apt-get install -y autoconf automake build-essential ccache cmake cpanminus gettext gperf language-pack-tr libtool-bin locales ninja-build pkg-config python3 python3-pip python3-setuptools unzip flake8","We build third-party for clint, so I'm not sure why all of this needs to be removed, but clearly not all of it is needed since we successfully ran clint.  That also implies some of it may no longer be necessary for the other CI jobs.For lint in particular, getting rid of the `Setup interpreter packages` step and the cpanminus, language-pack-tr, python3, python3-pip, python3-setuptools, and unzip package installs looks legit.We should keep the `Build third-party` and cache steps so we reduce the CI cost of those.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17398,809558848,2022-02-17T23:38:21Z,runtime/doc/diff.txt,"@@ -354,13 +354,21 @@ The ""1a2"" item appends the line ""bbb"". The ""4d4"" item deletes the line ""111"". The ""7c7"" item replaces the line ""GGG"" with ""ggg"". -When 'diffexpr' is not empty, Vim evaluates it to obtain a diff file in the-format mentioned.  These variables are set to the file names used:+When 'diffexpr' is a non-empty expresion, Vim evaluates it to obtain a diff file+in the format mentioned.  These variables are set to the file names used:  	v:fname_in		original file 	v:fname_new		new version of the same file 	v:fname_out		where to write the resulting diff file +When 'diffexpr' is an expression prefixed with '->', Vim evaluates it to obtain","In my proposal in #17210 I said:> if the expression begins with a ->, then the value is treated as a function refHere you are still treating it as an expression.By treating it directly as a function ref, it doesn't need to be parsed so you can call `call_func_retlist` directly instead of `eval_to_bool`.",
10091387,iago-lito,https://api.github.com/repos/neovim/neovim/pulls/17398,809762150,2022-02-18T08:13:01Z,runtime/doc/diff.txt,"@@ -354,13 +354,21 @@ The ""1a2"" item appends the line ""bbb"". The ""4d4"" item deletes the line ""111"". The ""7c7"" item replaces the line ""GGG"" with ""ggg"". -When 'diffexpr' is not empty, Vim evaluates it to obtain a diff file in the-format mentioned.  These variables are set to the file names used:+When 'diffexpr' is a non-empty expresion, Vim evaluates it to obtain a diff file+in the format mentioned.  These variables are set to the file names used:  	v:fname_in		original file 	v:fname_new		new version of the same file 	v:fname_out		where to write the resulting diff file +When 'diffexpr' is an expression prefixed with '->', Vim evaluates it to obtain","Cool. I did this because I wasn't sure how to pass `bufnr_in` and `bufnr_new` as arguments to the ref-ed function, and how to retrieve `diff_chunks` value in return. So I copied traditional `diffexpr` behaviour. I'll investigate into `call_func_retlist` instead :)",
10091387,iago-lito,https://api.github.com/repos/neovim/neovim/pulls/17398,809765065,2022-02-18T08:17:42Z,src/nvim/diff.c,"@@ -1074,6 +1092,69 @@ static int diff_file_internal(diffio_T *diffio)   memset(&emit_cfg, 0, sizeof(emit_cfg));   memset(&emit_cb, 0, sizeof(emit_cb)); +  if (diffexpr_internal_prefix()) {","Okay, I'll refactor this. This is (yet) another consequence of me not being comfortable with `call_func_retlist` and having fallen back to `eval_to_bool` instead.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17200,809850177,2022-02-18T10:01:03Z,src/nvim/lua/executor.c,"@@ -1249,11 +1249,27 @@ bool nlua_exec_file(const char *path) {   lua_State *const lstate = global_lstate; -  if (luaL_loadfile(lstate, path)) {+  lua_getglobal(lstate, ""loadfile"");+  lua_pushstring(lstate, path);++  lua_call(lstate, 1, 2);",let's use `lua_pcall` to be sure. A user override might cause an uncaught exception. (we can use the same error format E5112 for this),
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15723,810058804,2022-02-18T14:40:10Z,runtime/lua/vim/lsp/handlers.lua,"@@ -3,6 +3,7 @@ local protocol = require 'vim.lsp.protocol' local util = require 'vim.lsp.util' local vim = vim local api = vim.api+local semantic_tokens = require 'vim.lsp.semantic_tokens'",Not sure if it's worth it - but we could do the import lazy to reduce startup time.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15723,810071939,2022-02-18T14:54:49Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,167 @@+local M = {}++local semantic_tokens = setmetatable({}, {+  __index = function(table, key)+    local rtn = {}+    rawset(table, key, rtn)+    return rtn+  end,+})+local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return math.floor((n / math.pow(2, k)) % 2)+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  -- FIXME: this is should be done properly here and in the codelens implementation. Handlers should+  -- not be responsible of checking whether their responses are still valid.+  if err or not response or not response.data or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then",```suggestion  if err or not response or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then```Looks like data must be present if there is a result:```export interface [SemanticTokens](https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#semanticTokens) {	/**	 * An optional result id. If provided and clients support delta updating	 * the client will include the result id in the next semantic token request.	 * A server can then instead of computing all semantic tokens again simply	 * send a delta.	 */	resultId?: string;	/**	 * The actual tokens.	 */	data: [uinteger](https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#uinteger)[];}``````export interface SemanticTokensPartialResult {	data: uinteger[];}```It's not marked as nullable and an empty table is truthy in lua,
10091387,iago-lito,https://api.github.com/repos/neovim/neovim/pulls/17398,810361730,2022-02-18T21:50:47Z,src/nvim/diff.c,"@@ -1104,21 +1185,32 @@ static int diff_file_internal(diffio_T *diffio) /// Make a diff between files ""tmp_orig"" and ""tmp_new"", results in ""tmp_diff"". /// /// @param dio+/// @param idx_orig Buffer number of original file.+/// @param idx_new Buffer number of new version of the file. /// /// @return OK or FAIL-static int diff_file(diffio_T *dio)+static int diff_file(diffio_T *dio, const int idx_orig, const int idx_new) {   char *tmp_orig = (char *)dio->dio_orig.din_fname;   char *tmp_new = (char *)dio->dio_new.din_fname;   char *tmp_diff = (char *)dio->dio_diff.dout_fname;+  list_T* chunks;+   if (*p_dex != NUL) {-    // Use 'diffexpr' to generate the diff file.-    eval_diff(tmp_orig, tmp_new, tmp_diff);-    return OK;+    // Evaluate function with `in_bufnr` and `new_bufnr` arguments.+    if (diffexpr_internal_prefix()) {+      // Ignore the first two '->' characters of the option,+      // they are not part of the expression to evaluate.+      chunks = eval_idifffn(idx_orig, idx_new, p_dex + 2);+    } else {+      // Otherwise use 'diffexpr' to generate the diff file.+      eval_diff(tmp_orig, tmp_new, tmp_diff);+      return OK;+    }   }   // Use xdiff for generating the diff.   if (dio->dio_internal) {-    return diff_file_internal(dio);+    return diff_file_internal(dio, chunks);","Yupe, that's confusion on my side. I thought that `diff_file` was supposed to both fill up `dio` data then display the chunks, but it's only the first and the second is rather `diff_read`. So yes, I can return earlier.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17398,810374913,2022-02-18T22:20:37Z,src/nvim/eval.c,"@@ -700,6 +702,18 @@ void eval_diff(const char *const origfile, const char *const newfile, const char   set_vim_var_string(VV_FNAME_OUT, NULL, -1); } +// Return list of chunks calculated by user.+list_T *eval_diff_fn(const int idx_orig, const int idx_new, char_u *fn_name)+{+  typval_T args[2];+  args[0].v_type = VAR_NUMBER;+  args[1].v_type = VAR_NUMBER;+  args[0].vval.v_number = idx_orig;+  args[1].vval.v_number = idx_new;+  list_T *chunks = call_func_retlist(fn_name, 2, args);+  return chunks;","```suggestion  return call_func_retlist(fn_name, 2, args);```",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17398,810376512,2022-02-18T22:24:26Z,src/nvim/diff.c,"@@ -1101,20 +1111,104 @@ static int diff_file_internal(diffio_T *diffio)   return OK; } +///+/// Post-process the user-produced chunks so they fit into diffio_T logic.+/// Responsible for freeing the chunks list.+///+static int translate_chunks(diffio_T *const diffio, list_T *const chunks)+{+  // If a custom expression has been used,+  // translate received user chunks into diffio data.+  listitem_T *c = tv_list_first(chunks);+  list_T *i;  // chunk (i)nformation is made of 4 (n)umbers.+  listitem_T *n;+  typval_T *c_val;+  typval_T *n_val;+  int i_size;+  long start_a;+  long count_a;+  long start_b;+  long count_b;+  int success = FAIL;+  if (c != NULL) {+    for (; c != NULL; c = TV_LIST_ITEM_NEXT(chunks, c)) {+      c_val = TV_LIST_ITEM_TV(c);+      if (c_val->v_type == VAR_LIST) {+        i = c_val->vval.v_list;+        i_size = tv_list_len(i);+        if (i_size == 4) {+          n = tv_list_first(i);+          // Check information types.+          for (; n != NULL; n = TV_LIST_ITEM_NEXT(i, n)) {+            n_val = TV_LIST_ITEM_TV(n);+            if (n_val->v_type != VAR_NUMBER) {+              emsg(""Invalid chunk element received: must be a number."");+              goto theend;+            }+          }+          // Types are ok: setup diff information.+          n = tv_list_first(i);+          start_a = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          count_a = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          start_b = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          count_b = TV_LIST_ITEM_TV(n)->vval.v_number;+          // Counter-mimic extra offsets done by xdiff.+          if (count_a > 0) {+            start_a -= 1;+          }+          if (count_b > 0) {+            start_b -= 1;+          }+          // For some reason, the a and b expected by xdiff_out+          // are reversed compared to the chunks produced by vim.diff.+          xdiff_out(start_b, count_b, start_a, count_a, &diffio->dio_diff);+        } else {+          emsg(""Invalid chunk received: must contain 4 numbers."");+          goto theend;+        }+      } else {+        semsg(""Invalid chunk type received (%i), expected list (%i)."", c_val->v_type, VAR_LIST);+        goto theend;+      }+    }+  }+  success = OK;+theend:+  tv_list_unref(chunks);+  return success;+}+ /// Make a diff between files ""tmp_orig"" and ""tmp_new"", results in ""tmp_diff"". /// /// @param dio+/// @param idx_orig Buffer number of original file.+/// @param idx_new Buffer number of new version of the file. /// /// @return OK or FAIL-static int diff_file(diffio_T *dio)+static int diff_file(diffio_T *dio, const int idx_orig, const int idx_new) {   char *tmp_orig = (char *)dio->dio_orig.din_fname;   char *tmp_new = (char *)dio->dio_new.din_fname;   char *tmp_diff = (char *)dio->dio_diff.dout_fname;   if (*p_dex != NUL) {-    // Use 'diffexpr' to generate the diff file.-    eval_diff(tmp_orig, tmp_new, tmp_diff);-    return OK;+    // Evaluate function with `in_bufnr` and `new_bufnr` arguments.+    if (diffexpr_internal_prefix()) {+      // Ignore the first two '->' characters of the option,+      // they are not part of the function identifier.+      char_u *fn_name = p_dex + 2;+      list_T* chunks = eval_diff_fn(idx_orig, idx_new, fn_name);","```suggestion      list_T* chunks = eval_diff_fn(idx_orig, idx_new, p_dex + 2);```",
10091387,iago-lito,https://api.github.com/repos/neovim/neovim/pulls/17398,810481378,2022-02-19T11:40:41Z,src/nvim/diff.c,"@@ -1101,20 +1111,104 @@ static int diff_file_internal(diffio_T *diffio)   return OK; } +///+/// Post-process the user-produced chunks so they fit into diffio_T logic.+/// Responsible for freeing the chunks list.+///+static int translate_chunks(diffio_T *const diffio, list_T *const chunks)+{+  // If a custom expression has been used,+  // translate received user chunks into diffio data.+  listitem_T *c = tv_list_first(chunks);+  list_T *i;  // chunk (i)nformation is made of 4 (n)umbers.+  listitem_T *n;+  typval_T *c_val;+  typval_T *n_val;+  int i_size;+  long start_a;+  long count_a;+  long start_b;+  long count_b;+  int success = FAIL;+  if (c != NULL) {+    for (; c != NULL; c = TV_LIST_ITEM_NEXT(chunks, c)) {+      c_val = TV_LIST_ITEM_TV(c);+      if (c_val->v_type == VAR_LIST) {+        i = c_val->vval.v_list;+        i_size = tv_list_len(i);+        if (i_size == 4) {+          n = tv_list_first(i);+          // Check information types.+          for (; n != NULL; n = TV_LIST_ITEM_NEXT(i, n)) {+            n_val = TV_LIST_ITEM_TV(n);+            if (n_val->v_type != VAR_NUMBER) {+              emsg(""Invalid chunk element received: must be a number."");+              goto theend;+            }+          }+          // Types are ok: setup diff information.+          n = tv_list_first(i);+          start_a = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          count_a = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          start_b = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          count_b = TV_LIST_ITEM_TV(n)->vval.v_number;+          // Counter-mimic extra offsets done by xdiff.+          if (count_a > 0) {+            start_a -= 1;+          }+          if (count_b > 0) {+            start_b -= 1;+          }+          // For some reason, the a and b expected by xdiff_out+          // are reversed compared to the chunks produced by vim.diff.+          xdiff_out(start_b, count_b, start_a, count_a, &diffio->dio_diff);+        } else {+          emsg(""Invalid chunk received: must contain 4 numbers."");+          goto theend;+        }+      } else {+        semsg(""Invalid chunk type received (%i), expected list (%i)."", c_val->v_type, VAR_LIST);+        goto theend;+      }+    }+  }+  success = OK;+theend:+  tv_list_unref(chunks);+  return success;+}+ /// Make a diff between files ""tmp_orig"" and ""tmp_new"", results in ""tmp_diff"". /// /// @param dio+/// @param idx_orig Buffer number of original file.+/// @param idx_new Buffer number of new version of the file. /// /// @return OK or FAIL-static int diff_file(diffio_T *dio)+static int diff_file(diffio_T *dio, const int idx_orig, const int idx_new) {   char *tmp_orig = (char *)dio->dio_orig.din_fname;   char *tmp_new = (char *)dio->dio_new.din_fname;   char *tmp_diff = (char *)dio->dio_diff.dout_fname;   if (*p_dex != NUL) {-    // Use 'diffexpr' to generate the diff file.-    eval_diff(tmp_orig, tmp_new, tmp_diff);-    return OK;+    // Evaluate function with `in_bufnr` and `new_bufnr` arguments.+    if (diffexpr_internal_prefix()) {","Hm, this would duplicate the hardcoded definition of the `->` prefix. For now it is used once on line [1198](https://github.com/iago-lito/neovim/blob/70d78aef1516022c5d4b101508fa59e6bdb16b40/src/nvim/diff.c#L1198) and once on line [898](https://github.com/iago-lito/neovim/blob/70d78aef1516022c5d4b101508fa59e6bdb16b40/src/nvim/diff.c#L898). I'd find it more DRY that the check be factorized this way in a dedicated function like `diffexpr_internal_prefix`.. maybe you'd prefer a different name?",
10091387,iago-lito,https://api.github.com/repos/neovim/neovim/pulls/17398,810482318,2022-02-19T11:51:56Z,src/nvim/diff.c,"@@ -1101,20 +1111,104 @@ static int diff_file_internal(diffio_T *diffio)   return OK; } +///+/// Post-process the user-produced chunks so they fit into diffio_T logic.+/// Responsible for freeing the chunks list.+///+static int translate_chunks(diffio_T *const diffio, list_T *const chunks)+{+  // If a custom expression has been used,+  // translate received user chunks into diffio data.+  listitem_T *c = tv_list_first(chunks);+  list_T *i;  // chunk (i)nformation is made of 4 (n)umbers.+  listitem_T *n;+  typval_T *c_val;+  typval_T *n_val;+  int i_size;+  long start_a;+  long count_a;+  long start_b;+  long count_b;+  int success = FAIL;+  if (c != NULL) {+    for (; c != NULL; c = TV_LIST_ITEM_NEXT(chunks, c)) {+      c_val = TV_LIST_ITEM_TV(c);+      if (c_val->v_type == VAR_LIST) {+        i = c_val->vval.v_list;+        i_size = tv_list_len(i);+        if (i_size == 4) {+          n = tv_list_first(i);+          // Check information types.+          for (; n != NULL; n = TV_LIST_ITEM_NEXT(i, n)) {+            n_val = TV_LIST_ITEM_TV(n);+            if (n_val->v_type != VAR_NUMBER) {+              emsg(""Invalid chunk element received: must be a number."");+              goto theend;+            }+          }+          // Types are ok: setup diff information.+          n = tv_list_first(i);+          start_a = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          count_a = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          start_b = TV_LIST_ITEM_TV(n)->vval.v_number;+          n = TV_LIST_ITEM_NEXT(i, n);+          count_b = TV_LIST_ITEM_TV(n)->vval.v_number;+          // Counter-mimic extra offsets done by xdiff.+          if (count_a > 0) {+            start_a -= 1;+          }+          if (count_b > 0) {+            start_b -= 1;+          }+          // For some reason, the a and b expected by xdiff_out+          // are reversed compared to the chunks produced by vim.diff.+          xdiff_out(start_b, count_b, start_a, count_a, &diffio->dio_diff);+        } else {+          emsg(""Invalid chunk received: must contain 4 numbers."");+          goto theend;+        }+      } else {+        semsg(""Invalid chunk type received (%i), expected list (%i)."", c_val->v_type, VAR_LIST);+        goto theend;+      }+    }+  }+  success = OK;+theend:+  tv_list_unref(chunks);+  return success;+}+ /// Make a diff between files ""tmp_orig"" and ""tmp_new"", results in ""tmp_diff"". /// /// @param dio+/// @param idx_orig Buffer number of original file.+/// @param idx_new Buffer number of new version of the file. /// /// @return OK or FAIL-static int diff_file(diffio_T *dio)+static int diff_file(diffio_T *dio, const int idx_orig, const int idx_new) {   char *tmp_orig = (char *)dio->dio_orig.din_fname;   char *tmp_new = (char *)dio->dio_new.din_fname;   char *tmp_diff = (char *)dio->dio_diff.dout_fname;   if (*p_dex != NUL) {-    // Use 'diffexpr' to generate the diff file.-    eval_diff(tmp_orig, tmp_new, tmp_diff);-    return OK;+    // Evaluate function with `in_bufnr` and `new_bufnr` arguments.+    if (diffexpr_internal_prefix()) {+      // Ignore the first two '->' characters of the option,+      // they are not part of the function identifier.+      char_u *fn_name = p_dex + 2;+      list_T* chunks = eval_diff_fn(idx_orig, idx_new, fn_name);","[Similarly](https://github.com/neovim/neovim/pull/17398#discussion_r810481378), I did not like seeing `pdex + 2` appearing twice (once in [argument](https://github.com/iago-lito/neovim/blob/70d78aef1516022c5d4b101508fa59e6bdb16b40/src/nvim/diff.c#L1202) to `eval_diff_fn`, once in [error message](https://github.com/iago-lito/neovim/blob/70d78aef1516022c5d4b101508fa59e6bdb16b40/src/nvim/diff.c#L1204))... but maybe I'm missing one tradeoff here. Is it important, for some other reason, to keep the number of variables/functions low in nvim sources?",
10091387,iago-lito,https://api.github.com/repos/neovim/neovim/pulls/17398,810482918,2022-02-19T11:58:28Z,src/nvim/diff.c,"@@ -1101,20 +1111,104 @@ static int diff_file_internal(diffio_T *diffio)   return OK; } +///+/// Post-process the user-produced chunks so they fit into diffio_T logic.+/// Responsible for freeing the chunks list.+///+static int translate_chunks(diffio_T *const diffio, list_T *const chunks)+{+  // If a custom expression has been used,+  // translate received user chunks into diffio data.+  listitem_T *c = tv_list_first(chunks);+  list_T *i;  // chunk (i)nformation is made of 4 (n)umbers.+  listitem_T *n;+  typval_T *c_val;+  typval_T *n_val;+  int i_size;+  long start_a;+  long count_a;+  long start_b;+  long count_b;+  int success = FAIL;+  if (c != NULL) {","Well, [IIUC](https://github.com/iago-lito/neovim/blob/70d78aef1516022c5d4b101508fa59e6bdb16b40/src/nvim/eval.c#L1184) this would leak `chunks`, right? But I get the idea: I'll just `goto theend;` instead of `return FAIL;`.",
866010,rktjmp,https://api.github.com/repos/neovim/neovim/pulls/17459,810491562,2022-02-19T13:33:02Z,src/nvim/lua/executor.c,"@@ -78,7 +78,22 @@ static void nlua_error(lua_State *const lstate, const char *const msg)   FUNC_ATTR_NONNULL_ALL {   size_t len;-  const char *const str = lua_tolstring(lstate, -1, &len);+  const char *str = NULL;++  if (luaL_getmetafield(lstate, -1, ""__tostring"")) {+    if (lua_isfunction(lstate, -1) && luaL_callmeta(lstate, -2, ""__tostring"")) {+      // has __tostring and is a function, call it, convert the result and pop.+      str = lua_tolstring(lstate, -1, &len);+      lua_pop(lstate, 1);+    }","Possible to add an `else` here along the lines of ""you gave a `__tostring` but it wasnt callable"" if desired, right now we just  revert to the current behaviour of outputting `[NULL]` (via `lua_tolstring(<some-table>)`).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/14661,810496022,2022-02-19T14:20:04Z,src/nvim/eval/typval.c,"@@ -1142,13 +1145,37 @@ void callback_free(Callback *callback)   case kCallbackPartial:     partial_unref(callback->data.partial);     break;+  case kCallbackLua:+    NLUA_CLEAR_REF(callback->data.luaref);+    break;   case kCallbackNone:     break;   }   callback->type = kCallbackNone;   callback->data.funcref = NULL; } +/// Check if callback is freed+bool callback_is_freed(Callback callback)+{+  switch (callback.type) {+  case kCallbackFuncref:+    return false;+    break;+  case kCallbackPartial:+    return false;+    break;+  case kCallbackLua:+    return callback.data.luaref == LUA_NOREF;","why not set `calback.type = kCallbackNone` instead of `{.type = kCallbackLua, .data.luaref = LUA_NOREF}` when clearing? Then this function can be deleted, and we can just check `callback.type == kCallbackNone` at the callsite.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,810628497,2022-02-20T13:46:06Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of jumplist bounds under or over.+fmark_T *get_jumplist(win_T *win, int count) {-  pos_T *pos;-  xfmark_T *jmp;+  xfmark_T *jmp = NULL; -  cleanup_jumplist(curwin, true);+  cleanup_jumplist(win, true); -  if (curwin->w_jumplistlen == 0) {         // nothing to jump to-    return (pos_T *)NULL;+  if (win->w_jumplistlen == 0) {         // nothing to jump to+    return NULL;   }    for (;;) {-    if (curwin->w_jumplistidx + count < 0-        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen) {-      return (pos_T *)NULL;+    if (win->w_jumplistidx + count < 0+        || win->w_jumplistidx + count >= win->w_jumplistlen) {+      return NULL;     } -    /*-     * if first CTRL-O or CTRL-I command after a jump, add cursor position-     * to list.  Careful: If there are duplicates (CTRL-O immediately after-     * starting Vim on a file), another entry may have been removed.-     */-    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {+    // if first CTRL-O or CTRL-I command after a jump, add cursor position+    // to list.  Careful: If there are duplicates (CTRL-O immediately after+    // starting Vim on a file), another entry may have been removed.+    if (win->w_jumplistidx == win->w_jumplistlen) {       setpcmark();-      --curwin->w_jumplistidx;          // skip the new entry-      if (curwin->w_jumplistidx + count < 0) {-        return (pos_T *)NULL;+      win->w_jumplistidx--;          // skip the new entry+      if (win->w_jumplistidx + count < 0) {+        return NULL;       }     } -    curwin->w_jumplistidx += count;+    win->w_jumplistidx += count; -    jmp = curwin->w_jumplist + curwin->w_jumplistidx;+    jmp = win->w_jumplist + win->w_jumplistidx;     if (jmp->fmark.fnum == 0) {+      // Resolve the fnum (buff number) in the mark before returning it (shada)       fname2fnum(jmp);     }     if (jmp->fmark.fnum != curbuf->b_fnum) {-      // jump to other file-      if (buflist_findnr(jmp->fmark.fnum) == NULL) {  // Skip this one ..+      // Needs to switch buffer, if it can't find it skip the mark+      if (buflist_findnr(jmp->fmark.fnum) == NULL) {         count += count < 0 ? -1 : 1;         continue;       }-      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,-                          0, FALSE) == FAIL) {-        return (pos_T *)NULL;-      }-      // Set lnum again, autocommands my have changed it-      curwin->w_cursor = jmp->fmark.mark;-      pos = (pos_T *)-1;-    } else {-      pos = &(jmp->fmark.mark);     }-    return pos;+    break;   }+  return jmp != NULL ? &jmp->fmark : NULL; } -/*- * Move ""count"" positions in the changelist (count may be negative).- */-pos_T *movechangelist(int count)+/// Get mark in ""count"" position in the |changelist| relative to the current index.+///+/// @note  Changes the win->w_changelistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of bounds under or over.+fmark_T *get_changelist(buf_T *buf, win_T *win, int count) {   int n;+  fmark_T *fm; -  if (curbuf->b_changelistlen == 0) {       // nothing to jump to-    return (pos_T *)NULL;+  if (buf->b_changelistlen == 0) {       // nothing to jump to+    return NULL;   } -  n = curwin->w_changelistidx;+  n = win->w_changelistidx;   if (n + count < 0) {     if (n == 0) {-      return (pos_T *)NULL;+      return NULL;     }     n = 0;-  } else if (n + count >= curbuf->b_changelistlen) {-    if (n == curbuf->b_changelistlen - 1) {-      return (pos_T *)NULL;+  } else if (n + count >= buf->b_changelistlen) {+    if (n == buf->b_changelistlen - 1) {+      return NULL;     }-    n = curbuf->b_changelistlen - 1;+    n = buf->b_changelistlen - 1;   } else {     n += count;   }-  curwin->w_changelistidx = n;-  return &(curbuf->b_changelist[n].mark);+  win->w_changelistidx = n;+  fm = &(buf->b_changelist[n]);+  // Changelist marks are always buffer local, Shada does not set it when loading+  fm->fnum = curbuf->handle;+  return &(buf->b_changelist[n]); } -/*- * Find mark ""c"" in buffer pointed to by ""buf"".- * If ""changefile"" is TRUE it's allowed to edit another file for '0, 'A, etc.- * If ""fnum"" is not NULL store the fnum there for '0, 'A etc., don't edit- * another file.- * Returns:- * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is- *   in another file which can't be gotten. (caller needs to check lnum!)- * - NULL if there is no mark called 'c'.- * - -1 if mark is in other file and jumped there (only if changefile is TRUE)- */-pos_T *getmark_buf(buf_T *buf, int c, bool changefile)+/// Get a named mark.+///+/// All types of marks, even those that are not technically a mark will be returned as such, to then+/// move to the mark use mark_move_to().",The `not technically a mark` is explained [here](https://github.com/muniter/neovim/blob/825727875b081a9ace8dce251b9536bee7eebe3d/src/nvim/mark.c#L385). Perhaps I should link this comments to this explanation?,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,810630459,2022-02-20T14:00:47Z,src/nvim/mark_defs.h,"@@ -10,6 +10,34 @@  * (a normal mark is a lnum/col pair, the same as a file position)  */ +/// Flags for outcomes when moving to a mark.+typedef enum {+  kMarkMoveSuccess = 1,  /// Successful move.",I went by the [dev_style](https://github.com/muniter/neovim/blob/825727875b081a9ace8dce251b9536bee7eebe3d/runtime/doc/dev_style.txt#L551) examples.,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,810630578,2022-02-20T14:01:30Z,src/nvim/mark_defs.h,"@@ -25,24 +53,39 @@ /// but they are not saved in ShaDa files. #define NLOCALMARKS     (NMARKS + 3) +/// Max value of local mark+#define NMARK_LOCAL_MAX 126  // Index of '~'+ /// Maximum number of marks in jump list #define JUMPLISTSIZE    100  /// Maximum number of tags in tag stack #define TAGSTACKSIZE    20 +/// Represetns view in which the mark was created+typedef struct fmarkv {+  linenr_T topline_offset;  // Amount of lines from the mark lnum to the top of the window.+} fmarkv_T;++#define INIT_FMARKV { 0 }+ /// Structure defining single local mark typedef struct filemark {-  pos_T mark;           ///< Cursor position.","I went by the [dev_style](https://github.com/muniter/neovim/blob/825727875b081a9ace8dce251b9536bee7eebe3d/runtime/doc/dev_style.txt#L551) examples. Since I added something I went for the same style, I'm happy to revert.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/15831,810638223,2022-02-20T14:56:47Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of jumplist bounds under or over.+fmark_T *get_jumplist(win_T *win, int count) {-  pos_T *pos;-  xfmark_T *jmp;+  xfmark_T *jmp = NULL; -  cleanup_jumplist(curwin, true);+  cleanup_jumplist(win, true); -  if (curwin->w_jumplistlen == 0) {         // nothing to jump to-    return (pos_T *)NULL;+  if (win->w_jumplistlen == 0) {         // nothing to jump to+    return NULL;   }    for (;;) {-    if (curwin->w_jumplistidx + count < 0-        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen) {-      return (pos_T *)NULL;+    if (win->w_jumplistidx + count < 0+        || win->w_jumplistidx + count >= win->w_jumplistlen) {+      return NULL;     } -    /*-     * if first CTRL-O or CTRL-I command after a jump, add cursor position-     * to list.  Careful: If there are duplicates (CTRL-O immediately after-     * starting Vim on a file), another entry may have been removed.-     */-    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {+    // if first CTRL-O or CTRL-I command after a jump, add cursor position+    // to list.  Careful: If there are duplicates (CTRL-O immediately after+    // starting Vim on a file), another entry may have been removed.+    if (win->w_jumplistidx == win->w_jumplistlen) {       setpcmark();-      --curwin->w_jumplistidx;          // skip the new entry-      if (curwin->w_jumplistidx + count < 0) {-        return (pos_T *)NULL;+      win->w_jumplistidx--;          // skip the new entry+      if (win->w_jumplistidx + count < 0) {+        return NULL;       }     } -    curwin->w_jumplistidx += count;+    win->w_jumplistidx += count; -    jmp = curwin->w_jumplist + curwin->w_jumplistidx;+    jmp = win->w_jumplist + win->w_jumplistidx;     if (jmp->fmark.fnum == 0) {+      // Resolve the fnum (buff number) in the mark before returning it (shada)       fname2fnum(jmp);     }     if (jmp->fmark.fnum != curbuf->b_fnum) {-      // jump to other file-      if (buflist_findnr(jmp->fmark.fnum) == NULL) {  // Skip this one ..+      // Needs to switch buffer, if it can't find it skip the mark+      if (buflist_findnr(jmp->fmark.fnum) == NULL) {         count += count < 0 ? -1 : 1;         continue;       }-      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,-                          0, FALSE) == FAIL) {-        return (pos_T *)NULL;-      }-      // Set lnum again, autocommands my have changed it-      curwin->w_cursor = jmp->fmark.mark;-      pos = (pos_T *)-1;-    } else {-      pos = &(jmp->fmark.mark);     }-    return pos;+    break;   }+  return jmp != NULL ? &jmp->fmark : NULL; } -/*- * Move ""count"" positions in the changelist (count may be negative).- */-pos_T *movechangelist(int count)+/// Get mark in ""count"" position in the |changelist| relative to the current index.+///+/// @note  Changes the win->w_changelistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of bounds under or over.+fmark_T *get_changelist(buf_T *buf, win_T *win, int count) {   int n;+  fmark_T *fm; -  if (curbuf->b_changelistlen == 0) {       // nothing to jump to-    return (pos_T *)NULL;+  if (buf->b_changelistlen == 0) {       // nothing to jump to+    return NULL;   } -  n = curwin->w_changelistidx;+  n = win->w_changelistidx;   if (n + count < 0) {     if (n == 0) {-      return (pos_T *)NULL;+      return NULL;     }     n = 0;-  } else if (n + count >= curbuf->b_changelistlen) {-    if (n == curbuf->b_changelistlen - 1) {-      return (pos_T *)NULL;+  } else if (n + count >= buf->b_changelistlen) {+    if (n == buf->b_changelistlen - 1) {+      return NULL;     }-    n = curbuf->b_changelistlen - 1;+    n = buf->b_changelistlen - 1;   } else {     n += count;   }-  curwin->w_changelistidx = n;-  return &(curbuf->b_changelist[n].mark);+  win->w_changelistidx = n;+  fm = &(buf->b_changelist[n]);+  // Changelist marks are always buffer local, Shada does not set it when loading+  fm->fnum = curbuf->handle;+  return &(buf->b_changelist[n]); } -/*- * Find mark ""c"" in buffer pointed to by ""buf"".- * If ""changefile"" is TRUE it's allowed to edit another file for '0, 'A, etc.- * If ""fnum"" is not NULL store the fnum there for '0, 'A etc., don't edit- * another file.- * Returns:- * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is- *   in another file which can't be gotten. (caller needs to check lnum!)- * - NULL if there is no mark called 'c'.- * - -1 if mark is in other file and jumped there (only if changefile is TRUE)- */-pos_T *getmark_buf(buf_T *buf, int c, bool changefile)+/// Get a named mark.+///+/// All types of marks, even those that are not technically a mark will be returned as such, to then+/// move to the mark use mark_move_to().+/// @param buf  Buffer to get the mark from.+/// @param win  Window to get or calculate the mark from (motion type marks, context mark).+/// @param flag  kMarkAll (default) returns any mark found, if global it resolves it's fnum.+///              kMarkBufLocal return only marks that belong to buf, kMarkAllNoResolve same as+///              kMarkAll but does not resolve the fnum.+///+/// @return          Mark, if not found returns NULL, if kMarkBufLocal returns NULL when+///                  mark->fnum != buf->handle.+/// @return[static]  Marks that need ""wrapping"", are statically allocated see get_local_mark,+///                  get_motion_mark for an explanation.+fmark_T *mark_get(buf_T *buf, win_T *win, MarkGet flag, int name) {-  return getmark_buf_fnum(buf, c, changefile, NULL);+  fmark_T *fm = NULL;+  if (ASCII_ISUPPER(name) || ascii_isdigit(name)) {+    // Global marks+    xfmark_T *xfm = mark_get_global(!(flag & kMarkAllNoResolve), name);+    fm = &xfm->fmark;+    // Only wanted marks belonging to the buffer+    if (flag & kMarkBufLocal && xfm->fmark.fnum != buf->handle) {+      return NULL;+    }+  } else if (name > 0 && name < NMARK_LOCAL_MAX) {+    // Local Marks+    fm = mark_get_local(buf, win, name);+  }+  return fm; } -pos_T *getmark(int c, bool changefile)+/// Get a global mark {A-Z0-9}.+///+/// @note  input must be validated previously otherwise undefined behavior.+/// @param name  the name of the mark.+/// @param resolve  If true try resolving the mark fnum, meaning load the buffer stored in+///                 the mark fname and update the xfmark_T (expensive).+///+/// @return  Mark, undefined behavior if input is not validated.+xfmark_T *mark_get_global(bool resolve, int name) {-  return getmark_buf_fnum(curbuf, c, changefile, NULL);+  xfmark_T *mark;++  assert(ASCII_ISUPPER(name) || ascii_isdigit(name));+  if (ascii_isdigit(name)) {+    name = name - '0' + NMARKS;+  } else {+    name -= 'A';+  }+  mark = &namedfm[name];++  if (resolve && mark->fmark.fnum == 0) {+    // Resolve filename to fnum (SHADA marks)+    fname2fnum(mark);+  }+  return mark; } -pos_T *getmark_buf_fnum(buf_T *buf, int c, bool changefile, int *fnum)++/// Get a local mark (lowercase and symbols).+///+/// Some marks are not actually marks, but positions that are never adjusted or motions presented as+/// marks. It searches first for marks and falls back to finding motion type marks. If it's known+/// ahead of time that the marks is actually a motion use the function mark_get_motion directly.+///+/// @note  Lowercase, last_cursor '""', last insert '^', last change '.' are not statically+/// allocated.+/// @param name  the name of the mark.+/// @param win  window to retrieve marks that belong to it (motions and context mark).+/// @param buf  buf to retrieve marks that belong to it.+///+/// @return  Mark, NULL if not found.+fmark_T *mark_get_local(buf_T *buf, win_T *win, int name) {-  pos_T *posp;-  pos_T *startp, *endp;-  static pos_T pos_copy;+  fmark_T *mark = NULL;+  if (ASCII_ISLOWER(name)) {+    // normal named mark+    mark = &buf->b_namedm[name - 'a'];+    // to start of previous operator+  } else if (name == '[') {+    mark = pos_to_mark(buf, buf->b_op_start);+    // to end of previous operator+  } else if (name == ']') {+    mark = pos_to_mark(buf, buf->b_op_end);+    // visual marks+  } else if (name == '<' || name == '>') {+    mark = mark_get_visual(buf, name);+    // previous context mark+  } else if (name == '\'' || name == '`') {+    // TODO(muniter): w_pcmark should be stored as a mark, but causes a nasty bug.+    mark = pos_to_mark(curbuf, win->w_pcmark);+    // to position when leaving buffer+  } else if (name == '""') {+    mark = &(buf->b_last_cursor);+    // to where last Insert mode stopped+  } else if (name == '^') {+    mark = &(buf->b_last_insert);+    // to where last change was made+  } else if (name == '.') {+    mark = &buf->b_last_change;+    // Mark that are actually not marks but motions, e.g {, }, (, ), ...+  } else {+    mark = mark_get_motion(buf, win, name);+  } -  posp = NULL;+  return mark;+} -  // Check for special key, can't be a mark name and might cause islower()-  // to crash.-  if (c < 0) {-    return posp;-  }-  if (c > '~') {                        // check for islower()/isupper()-  } else if (c == '\'' || c == '`') {   // previous context mark-    pos_copy = curwin->w_pcmark;        // need to make a copy because-    posp = &pos_copy;                   //   w_pcmark may be changed soon-  } else if (c == '""') {                // to pos when leaving buffer-    posp = &(buf->b_last_cursor.mark);-  } else if (c == '^') {                // to where Insert mode stopped-    posp = &(buf->b_last_insert.mark);-  } else if (c == '.') {                // to where last change was made-    posp = &(buf->b_last_change.mark);-  } else if (c == '[') {                // to start of previous operator-    posp = &(buf->b_op_start);-  } else if (c == ']') {                // to end of previous operator-    posp = &(buf->b_op_end);-  } else if (c == '{' || c == '}') {    // to previous/next paragraph-    pos_T pos;+/// Get marks that are actually motions but return them as marks+///+/// Gets the following motions as marks: '{', '}', '(', ')'+/// @param name  name of the mark+/// @param win  window to retrieve the cursor to calculate the mark.+/// @param buf  buf to wrap motion marks with it's buffer number (fm->fnum).+///+/// @return[static] Mark.+fmark_T *mark_get_motion(buf_T *buf, win_T *win, int name)+{+  fmark_T *mark = NULL;+  if (name == '{' || name == '}') {+    // to previous/next paragraph     oparg_T oa;     bool slcb = listcmd_busy;+    listcmd_busy = true;  // avoid that '' is changed -    pos = curwin->w_cursor;-    listcmd_busy = true;            // avoid that '' is changed     if (findpar(&oa.inclusive,-                c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {-      pos_copy = curwin->w_cursor;-      posp = &pos_copy;+                name == '}' ? FORWARD : BACKWARD, 1L, NUL, false)) {+      mark = pos_to_mark(buf, win->w_cursor);     }-    curwin->w_cursor = pos;     listcmd_busy = slcb;-  } else if (c == '(' || c == ')') {  // to previous/next sentence-    pos_T pos;+    // to previous/next sentence+  } else if (name == '(' || name == ')') {     bool slcb = listcmd_busy;+    listcmd_busy = true;  // avoid that '' is changed -    pos = curwin->w_cursor;-    listcmd_busy = true;            // avoid that '' is changed-    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {-      pos_copy = curwin->w_cursor;-      posp = &pos_copy;+    if (findsent(name == ')' ? FORWARD : BACKWARD, 1L)) {+      mark = pos_to_mark(buf, win->w_cursor);     }-    curwin->w_cursor = pos;     listcmd_busy = slcb;-  } else if (c == '<' || c == '>') {  // start/end of visual area-    startp = &buf->b_visual.vi_start;-    endp = &buf->b_visual.vi_end;-    if (((c == '<') == lt(*startp, *endp) || endp->lnum == 0)-        && startp->lnum != 0) {-      posp = startp;+  }+  return mark;+}++/// Get visual marks '<', '>'+///+/// This marks are different to normal marks:+/// 1. Never adjusted.+/// 2. Different behavior depending on editor state (visual mode).+/// 3. Not saved in shada.+/// 4. Re-ordered when defined in reverse.+/// @param buf  Buffer to get the mark from.+/// @param name  Mark name '<' or '>'.+///+/// @return[static]  Mark+fmark_T *mark_get_visual(buf_T *buf, int name)+{+  fmark_T *mark = NULL;+  if (name == '<' || name == '>') {+    // start/end of visual area+    pos_T startp = buf->b_visual.vi_start;+    pos_T endp = buf->b_visual.vi_end;+    if (((name == '<') == lt(startp, endp) || endp.lnum == 0)+        && startp.lnum != 0) {+      mark = pos_to_mark(buf, startp);     } else {-      posp = endp;+      mark = pos_to_mark(buf, endp);     } -    // For Visual line mode, set mark at begin or end of line-    if (buf->b_visual.vi_mode == 'V') {-      pos_copy = *posp;-      posp = &pos_copy;-      if (c == '<') {-        pos_copy.col = 0;+    if (mark != NULL && buf->b_visual.vi_mode == 'V') {+      if (name == '<') {+        mark->mark.col = 0;       } else {-        pos_copy.col = MAXCOL;+        mark->mark.col = MAXCOL;       }-      pos_copy.coladd = 0;+      mark->mark.coladd = 0;     }-  } else if (ASCII_ISLOWER(c)) {      // normal named mark-    posp = &(buf->b_namedm[c - 'a'].mark);-  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    // named file mark-    if (ascii_isdigit(c)) {-      c = c - '0' + NMARKS;-    } else {-      c -= 'A';-    }-    posp = &(namedfm[c].fmark.mark);+  }+  return mark;+}++/// Wrap a pos_T into an fmark_T, used to abstract marks hadnling.+/// @note  view fields are set to 0.+/// @param buf  for fmark->fnum.+/// @param pos  for fmrak->mark.+///+/// @return[static] Mark with the given information.+fmark_T *pos_to_mark(buf_T *buf, pos_T pos)+{+  static fmark_T mark = INIT_FMARK;",Also wanted to point out that in the current [implementation on master](https://github.com/neovim/neovim/blob/4b3fb4b17796ee6d9c8d7e8135a93b60cf09b016/src/nvim/mark.c#L337) is not safe to cache pointers from marks. It also has a `static pos_T` that it returns sometimes.,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/15181,810645382,2022-02-20T15:48:58Z,src/nvim/api/private/helpers.c,"@@ -758,6 +757,44 @@ bool buf_collect_lines(buf_T *buf, size_t n, int64_t start, bool replace_nl, Arr   return true; } +/// Returns a substring of a buffer line+String buf_get_line(buf_T *buf, int64_t lnum, int64_t start_col, int64_t end_col, bool replace_nl,","Minor nit, but it's a little confusing to have buf_get_line here have different semantics than nvim_buf_get_lines since this is slicing a line and the latter is retrieving lines.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/15181,810659869,2022-02-20T17:38:57Z,src/nvim/api/buffer.c,"@@ -757,6 +756,115 @@ void nvim_buf_set_text(uint64_t channel_id, Buffer buffer, Integer start_row, In   try_end(err); } +/// Gets a range from the buffer.+///+/// This differs from |nvim_buf_get_lines()| in that it allows retrieving only+/// portions of a line.+///+/// Indexing is zero-based. Column indices are end-exclusive.+///+/// Prefer |nvim_buf_get_lines()| when retrieving entire lines.+///+/// @param channel_id+/// @param buffer           Buffer handle, or 0 for current buffer+/// @param start_row        First line index+/// @param start_column     Starting byte offset of first line+/// @param end_row          Last line index+/// @param end_column       Ending byte offset of last line (exclusive)+/// @param opts             Optional parameters. Currently unused.+/// @param[out] err         Error details, if any+/// @return Array of lines, or empty array for unloaded buffer.+ArrayOf(String) nvim_buf_get_text(uint64_t channel_id, Buffer buffer,+                                  Integer start_row, Integer start_col,+                                  Integer end_row, Integer end_col,+                                  Dictionary opts FUNC_ATTR_UNUSED,",shouldn't be unused. rather explicitly check it is empty (as all keys are currently invalid).,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/15831,810666910,2022-02-20T18:38:31Z,src/nvim/mark.c,"@@ -221,245 +228,402 @@ void checkpcmark(void)   } } -/*- * move ""count"" positions in the jump list (count may be negative)- */-pos_T *movemark(int count)+/// Get mark in ""count"" position in the |jumplist| relative to the current index.+///+/// If the mark needs to switch buffers it makes sure the buffer exists, if it+/// doesn't exist it will skip it and try with the next one.+/// @note It will run cleanup_jumplist, removing duplicate marks, and will also+///       change win->w_jumplistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of jumplist bounds under or over.+fmark_T *get_jumplist(win_T *win, int count) {-  pos_T *pos;-  xfmark_T *jmp;+  xfmark_T *jmp = NULL; -  cleanup_jumplist(curwin, true);+  cleanup_jumplist(win, true); -  if (curwin->w_jumplistlen == 0) {         // nothing to jump to-    return (pos_T *)NULL;+  if (win->w_jumplistlen == 0) {         // nothing to jump to+    return NULL;   }    for (;;) {-    if (curwin->w_jumplistidx + count < 0-        || curwin->w_jumplistidx + count >= curwin->w_jumplistlen) {-      return (pos_T *)NULL;+    if (win->w_jumplistidx + count < 0+        || win->w_jumplistidx + count >= win->w_jumplistlen) {+      return NULL;     } -    /*-     * if first CTRL-O or CTRL-I command after a jump, add cursor position-     * to list.  Careful: If there are duplicates (CTRL-O immediately after-     * starting Vim on a file), another entry may have been removed.-     */-    if (curwin->w_jumplistidx == curwin->w_jumplistlen) {+    // if first CTRL-O or CTRL-I command after a jump, add cursor position+    // to list.  Careful: If there are duplicates (CTRL-O immediately after+    // starting Vim on a file), another entry may have been removed.+    if (win->w_jumplistidx == win->w_jumplistlen) {       setpcmark();-      --curwin->w_jumplistidx;          // skip the new entry-      if (curwin->w_jumplistidx + count < 0) {-        return (pos_T *)NULL;+      win->w_jumplistidx--;          // skip the new entry+      if (win->w_jumplistidx + count < 0) {+        return NULL;       }     } -    curwin->w_jumplistidx += count;+    win->w_jumplistidx += count; -    jmp = curwin->w_jumplist + curwin->w_jumplistidx;+    jmp = win->w_jumplist + win->w_jumplistidx;     if (jmp->fmark.fnum == 0) {+      // Resolve the fnum (buff number) in the mark before returning it (shada)       fname2fnum(jmp);     }     if (jmp->fmark.fnum != curbuf->b_fnum) {-      // jump to other file-      if (buflist_findnr(jmp->fmark.fnum) == NULL) {  // Skip this one ..+      // Needs to switch buffer, if it can't find it skip the mark+      if (buflist_findnr(jmp->fmark.fnum) == NULL) {         count += count < 0 ? -1 : 1;         continue;       }-      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,-                          0, FALSE) == FAIL) {-        return (pos_T *)NULL;-      }-      // Set lnum again, autocommands my have changed it-      curwin->w_cursor = jmp->fmark.mark;-      pos = (pos_T *)-1;-    } else {-      pos = &(jmp->fmark.mark);     }-    return pos;+    break;   }+  return jmp != NULL ? &jmp->fmark : NULL; } -/*- * Move ""count"" positions in the changelist (count may be negative).- */-pos_T *movechangelist(int count)+/// Get mark in ""count"" position in the |changelist| relative to the current index.+///+/// @note  Changes the win->w_changelistidx.+/// @param[in] win  window to get jumplist from.+/// @param[in] count  count to move may be negative.+///+/// @return  mark, NULL if out of bounds under or over.+fmark_T *get_changelist(buf_T *buf, win_T *win, int count) {   int n;+  fmark_T *fm; -  if (curbuf->b_changelistlen == 0) {       // nothing to jump to-    return (pos_T *)NULL;+  if (buf->b_changelistlen == 0) {       // nothing to jump to+    return NULL;   } -  n = curwin->w_changelistidx;+  n = win->w_changelistidx;   if (n + count < 0) {     if (n == 0) {-      return (pos_T *)NULL;+      return NULL;     }     n = 0;-  } else if (n + count >= curbuf->b_changelistlen) {-    if (n == curbuf->b_changelistlen - 1) {-      return (pos_T *)NULL;+  } else if (n + count >= buf->b_changelistlen) {+    if (n == buf->b_changelistlen - 1) {+      return NULL;     }-    n = curbuf->b_changelistlen - 1;+    n = buf->b_changelistlen - 1;   } else {     n += count;   }-  curwin->w_changelistidx = n;-  return &(curbuf->b_changelist[n].mark);+  win->w_changelistidx = n;+  fm = &(buf->b_changelist[n]);+  // Changelist marks are always buffer local, Shada does not set it when loading+  fm->fnum = curbuf->handle;+  return &(buf->b_changelist[n]); } -/*- * Find mark ""c"" in buffer pointed to by ""buf"".- * If ""changefile"" is TRUE it's allowed to edit another file for '0, 'A, etc.- * If ""fnum"" is not NULL store the fnum there for '0, 'A etc., don't edit- * another file.- * Returns:- * - pointer to pos_T if found.  lnum is 0 when mark not set, -1 when mark is- *   in another file which can't be gotten. (caller needs to check lnum!)- * - NULL if there is no mark called 'c'.- * - -1 if mark is in other file and jumped there (only if changefile is TRUE)- */-pos_T *getmark_buf(buf_T *buf, int c, bool changefile)+/// Get a named mark.+///+/// All types of marks, even those that are not technically a mark will be returned as such, to then+/// move to the mark use mark_move_to().+/// @param buf  Buffer to get the mark from.+/// @param win  Window to get or calculate the mark from (motion type marks, context mark).+/// @param flag  kMarkAll (default) returns any mark found, if global it resolves it's fnum.+///              kMarkBufLocal return only marks that belong to buf, kMarkAllNoResolve same as+///              kMarkAll but does not resolve the fnum.+///+/// @return          Mark, if not found returns NULL, if kMarkBufLocal returns NULL when+///                  mark->fnum != buf->handle.+/// @return[static]  Marks that need ""wrapping"", are statically allocated see get_local_mark,+///                  get_motion_mark for an explanation.+fmark_T *mark_get(buf_T *buf, win_T *win, MarkGet flag, int name) {-  return getmark_buf_fnum(buf, c, changefile, NULL);+  fmark_T *fm = NULL;+  if (ASCII_ISUPPER(name) || ascii_isdigit(name)) {+    // Global marks+    xfmark_T *xfm = mark_get_global(!(flag & kMarkAllNoResolve), name);+    fm = &xfm->fmark;+    // Only wanted marks belonging to the buffer+    if (flag & kMarkBufLocal && xfm->fmark.fnum != buf->handle) {+      return NULL;+    }+  } else if (name > 0 && name < NMARK_LOCAL_MAX) {+    // Local Marks+    fm = mark_get_local(buf, win, name);+  }+  return fm; } -pos_T *getmark(int c, bool changefile)+/// Get a global mark {A-Z0-9}.+///+/// @note  input must be validated previously otherwise undefined behavior.+/// @param name  the name of the mark.+/// @param resolve  If true try resolving the mark fnum, meaning load the buffer stored in+///                 the mark fname and update the xfmark_T (expensive).+///+/// @return  Mark, undefined behavior if input is not validated.+xfmark_T *mark_get_global(bool resolve, int name) {-  return getmark_buf_fnum(curbuf, c, changefile, NULL);+  xfmark_T *mark;++  assert(ASCII_ISUPPER(name) || ascii_isdigit(name));+  if (ascii_isdigit(name)) {+    name = name - '0' + NMARKS;+  } else {+    name -= 'A';+  }+  mark = &namedfm[name];++  if (resolve && mark->fmark.fnum == 0) {+    // Resolve filename to fnum (SHADA marks)+    fname2fnum(mark);+  }+  return mark; } -pos_T *getmark_buf_fnum(buf_T *buf, int c, bool changefile, int *fnum)++/// Get a local mark (lowercase and symbols).+///+/// Some marks are not actually marks, but positions that are never adjusted or motions presented as+/// marks. It searches first for marks and falls back to finding motion type marks. If it's known+/// ahead of time that the marks is actually a motion use the function mark_get_motion directly.+///+/// @note  Lowercase, last_cursor '""', last insert '^', last change '.' are not statically+/// allocated.+/// @param name  the name of the mark.+/// @param win  window to retrieve marks that belong to it (motions and context mark).+/// @param buf  buf to retrieve marks that belong to it.+///+/// @return  Mark, NULL if not found.+fmark_T *mark_get_local(buf_T *buf, win_T *win, int name) {-  pos_T *posp;-  pos_T *startp, *endp;-  static pos_T pos_copy;+  fmark_T *mark = NULL;+  if (ASCII_ISLOWER(name)) {+    // normal named mark+    mark = &buf->b_namedm[name - 'a'];+    // to start of previous operator+  } else if (name == '[') {+    mark = pos_to_mark(buf, buf->b_op_start);+    // to end of previous operator+  } else if (name == ']') {+    mark = pos_to_mark(buf, buf->b_op_end);+    // visual marks+  } else if (name == '<' || name == '>') {+    mark = mark_get_visual(buf, name);+    // previous context mark+  } else if (name == '\'' || name == '`') {+    // TODO(muniter): w_pcmark should be stored as a mark, but causes a nasty bug.+    mark = pos_to_mark(curbuf, win->w_pcmark);+    // to position when leaving buffer+  } else if (name == '""') {+    mark = &(buf->b_last_cursor);+    // to where last Insert mode stopped+  } else if (name == '^') {+    mark = &(buf->b_last_insert);+    // to where last change was made+  } else if (name == '.') {+    mark = &buf->b_last_change;+    // Mark that are actually not marks but motions, e.g {, }, (, ), ...+  } else {+    mark = mark_get_motion(buf, win, name);+  } -  posp = NULL;+  return mark;+} -  // Check for special key, can't be a mark name and might cause islower()-  // to crash.-  if (c < 0) {-    return posp;-  }-  if (c > '~') {                        // check for islower()/isupper()-  } else if (c == '\'' || c == '`') {   // previous context mark-    pos_copy = curwin->w_pcmark;        // need to make a copy because-    posp = &pos_copy;                   //   w_pcmark may be changed soon-  } else if (c == '""') {                // to pos when leaving buffer-    posp = &(buf->b_last_cursor.mark);-  } else if (c == '^') {                // to where Insert mode stopped-    posp = &(buf->b_last_insert.mark);-  } else if (c == '.') {                // to where last change was made-    posp = &(buf->b_last_change.mark);-  } else if (c == '[') {                // to start of previous operator-    posp = &(buf->b_op_start);-  } else if (c == ']') {                // to end of previous operator-    posp = &(buf->b_op_end);-  } else if (c == '{' || c == '}') {    // to previous/next paragraph-    pos_T pos;+/// Get marks that are actually motions but return them as marks+///+/// Gets the following motions as marks: '{', '}', '(', ')'+/// @param name  name of the mark+/// @param win  window to retrieve the cursor to calculate the mark.+/// @param buf  buf to wrap motion marks with it's buffer number (fm->fnum).+///+/// @return[static] Mark.+fmark_T *mark_get_motion(buf_T *buf, win_T *win, int name)+{+  fmark_T *mark = NULL;+  if (name == '{' || name == '}') {+    // to previous/next paragraph     oparg_T oa;     bool slcb = listcmd_busy;+    listcmd_busy = true;  // avoid that '' is changed -    pos = curwin->w_cursor;-    listcmd_busy = true;            // avoid that '' is changed     if (findpar(&oa.inclusive,-                c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {-      pos_copy = curwin->w_cursor;-      posp = &pos_copy;+                name == '}' ? FORWARD : BACKWARD, 1L, NUL, false)) {+      mark = pos_to_mark(buf, win->w_cursor);     }-    curwin->w_cursor = pos;     listcmd_busy = slcb;-  } else if (c == '(' || c == ')') {  // to previous/next sentence-    pos_T pos;+    // to previous/next sentence+  } else if (name == '(' || name == ')') {     bool slcb = listcmd_busy;+    listcmd_busy = true;  // avoid that '' is changed -    pos = curwin->w_cursor;-    listcmd_busy = true;            // avoid that '' is changed-    if (findsent(c == ')' ? FORWARD : BACKWARD, 1L)) {-      pos_copy = curwin->w_cursor;-      posp = &pos_copy;+    if (findsent(name == ')' ? FORWARD : BACKWARD, 1L)) {+      mark = pos_to_mark(buf, win->w_cursor);     }-    curwin->w_cursor = pos;     listcmd_busy = slcb;-  } else if (c == '<' || c == '>') {  // start/end of visual area-    startp = &buf->b_visual.vi_start;-    endp = &buf->b_visual.vi_end;-    if (((c == '<') == lt(*startp, *endp) || endp->lnum == 0)-        && startp->lnum != 0) {-      posp = startp;+  }+  return mark;+}++/// Get visual marks '<', '>'+///+/// This marks are different to normal marks:+/// 1. Never adjusted.+/// 2. Different behavior depending on editor state (visual mode).+/// 3. Not saved in shada.+/// 4. Re-ordered when defined in reverse.+/// @param buf  Buffer to get the mark from.+/// @param name  Mark name '<' or '>'.+///+/// @return[static]  Mark+fmark_T *mark_get_visual(buf_T *buf, int name)+{+  fmark_T *mark = NULL;+  if (name == '<' || name == '>') {+    // start/end of visual area+    pos_T startp = buf->b_visual.vi_start;+    pos_T endp = buf->b_visual.vi_end;+    if (((name == '<') == lt(startp, endp) || endp.lnum == 0)+        && startp.lnum != 0) {+      mark = pos_to_mark(buf, startp);     } else {-      posp = endp;+      mark = pos_to_mark(buf, endp);     } -    // For Visual line mode, set mark at begin or end of line-    if (buf->b_visual.vi_mode == 'V') {-      pos_copy = *posp;-      posp = &pos_copy;-      if (c == '<') {-        pos_copy.col = 0;+    if (mark != NULL && buf->b_visual.vi_mode == 'V') {+      if (name == '<') {+        mark->mark.col = 0;       } else {-        pos_copy.col = MAXCOL;+        mark->mark.col = MAXCOL;       }-      pos_copy.coladd = 0;+      mark->mark.coladd = 0;     }-  } else if (ASCII_ISLOWER(c)) {      // normal named mark-    posp = &(buf->b_namedm[c - 'a'].mark);-  } else if (ASCII_ISUPPER(c) || ascii_isdigit(c)) {    // named file mark-    if (ascii_isdigit(c)) {-      c = c - '0' + NMARKS;-    } else {-      c -= 'A';-    }-    posp = &(namedfm[c].fmark.mark);+  }+  return mark;+}++/// Wrap a pos_T into an fmark_T, used to abstract marks hadnling.+/// @note  view fields are set to 0.+/// @param buf  for fmark->fnum.+/// @param pos  for fmrak->mark.+///+/// @return[static] Mark with the given information.+fmark_T *pos_to_mark(buf_T *buf, pos_T pos)+{+  static fmark_T mark = INIT_FMARK;","> About caching the pointer I believe it shouldn't be done with marks, rather retrieve their value every time you need them. Reason being the buffer or window they are on can be gone any moment.I wasn't thinking long-term caching, just having multiple calls in the same scope.  I'm not really familiar with how the mark APIs are used internally, so I was just commenting on what I see, even if the way the APIs are used makes them safe as is.",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17475,810687509,2022-02-20T21:32:47Z,runtime/lua/vim/diagnostic.lua,"@@ -447,7 +447,7 @@ local function set_list(loclist, opts)     vim.fn.setqflist({}, ' ', { title = title, items = items })   end   if open then-    vim.api.nvim_command(loclist and ""lopen"" or ""copen"")+    vim.api.nvim_command(loclist and ""lopen"" or ""botright copen"")","I agree an opinionated default is a good idea, I���m saying it should still be configurable for the cases when people don���t want to use the default.But honestly in that case they can just set `open` to false and then just open it themselves after the call to setqflist(). So I actually think this is fine the way it is. ",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17475,810688001,2022-02-20T21:36:40Z,runtime/lua/vim/diagnostic.lua,"@@ -447,7 +447,7 @@ local function set_list(loclist, opts)     vim.fn.setqflist({}, ' ', { title = title, items = items })   end   if open then-    vim.api.nvim_command(loclist and ""lopen"" or ""copen"")+    vim.api.nvim_command(loclist and ""lopen"" or ""botright copen"")","If it is configurable, it should be per location list/copen, or perhaps open should itself be a boolean or string value, where string value is either lopen/copen/botrightcopen, or a function that can instead be overridden, not sure.",
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17475,810688274,2022-02-20T21:39:09Z,runtime/lua/vim/diagnostic.lua,"@@ -447,7 +447,7 @@ local function set_list(loclist, opts)     vim.fn.setqflist({}, ' ', { title = title, items = items })   end   if open then-    vim.api.nvim_command(loclist and ""lopen"" or ""copen"")+    vim.api.nvim_command(loclist and ""lopen"" or ""botright copen"")","Anyways, IMO we should merge this to bring all handlers/diagnostics in line and in a separate PR we can have a unified interface. There has been a lot of discussion/some PRs around minor additions to configurability of opening qfixlist/loclist (see https://github.com/neovim/neovim/pull/17339 for a recent one) so it would be good to figure out something uniform and update everyone.",
19373652,RenFraser,https://api.github.com/repos/neovim/neovim/pulls/17390,810866820,2022-02-21T08:13:17Z,.github/workflows/notes.md,"@@ -6,8 +6,26 @@ ${NVIM_VERSION}  ### Windows -1. Extract **nvim-win64.zip**-2. Run `nvim-qt.exe`+#### Zip++1. Download **nvim-win64.zip**+2. Extract the zip.+3. Run `nvim-qt.exe`++#### MSI++1. Download **nvim-win64.msi**+2. Run the MSI+3. Add the Neovim location to your path.+   - Default location is `C:\Program Files\Neovim`+4. Run `nvim` or `nvim.exe`++#### NSIS++1. Download **nvim-win64.exe**+2. Run the installer.+   - Ensure that the option to add the installation location to your path is checked if it's your first installation.+3. Run `nvim` or `nvim.exe`","Yes, you can search for both executables for both the MSI and the NSIS installations. Here's a screenshot of the apps when I search them using Windows 11. I'd _assume_ that a Windows user would search for `nvim-qt.exe` if they were to search using the start menu. @jamessan thinking about the `notes.md` instructions here again, it would make sense to add something along the lines of ""Search for nvim-qt.exe using the Windows start menu or run `nvim` from your shell of choice.""What do you think about that change?![nvim-qt_screenshott](https://user-images.githubusercontent.com/19373652/154913489-19c782e7-cf36-4fb6-8986-127644e81934.png)![nvim_screenshot](https://user-images.githubusercontent.com/19373652/154913497-2fe31c21-0a57-442e-9454-dc04e0744898.png)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16845,812290357,2022-02-22T19:32:40Z,src/nvim/autocmd.c,"@@ -1152,6 +1152,7 @@ void aucmd_prepbuf(aco_save_T *aco, buf_T *buf)     globaldir = NULL;      block_autocmds();  // We don't want BufEnter/WinEnter autocommands.+    make_snapshot(SNAP_AUCMD_IDX);","Is this really needed, now what we banned inserting the aucmdwin? saving/restoring window layout was the anti-pattern we aimed at getting rid of in the first place..",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17497,812326093,2022-02-22T20:22:18Z,src/nvim/shada.c,"@@ -2901,26 +2948,18 @@ static ShaDaWriteResult shada_write(ShaDaWriteDef *const sd_writer, ShaDaReadDef           }         })         if (ret == kSDWriteFailed) {-          goto shada_write_exit;+          shada_write_exit(dump_one_history, wms, removable_bufs, packer);+          return ret;         }       }     }   } -shada_write_exit:","also this one, while not strictly only for the error path, has the same functionality: destruct memory allocated locally within the function. It remains as tightly coupled to the function as before. Thus I would argue this change doesn't make the code clearer, and falls close enough within our established pattern for goto usage.",
7904185,lewis6991,https://api.github.com/repos/neovim/neovim/pulls/17516,813990481,2022-02-24T15:23:17Z,src/nvim/highlight.c,"@@ -847,6 +848,13 @@ HlAttrs dict2hlattrs(Dict(highlight) *dict, bool use_rgb, int *link_id, Error *e     return hlattrs;   } +  if (HAS_KEY(dict->blend)) {+    blend = object_to_color(dict->blend, ""blend"", true, err);",Because I'm lazy and like to blindly copy and paste stuff. ���� I guess the test passing caused me to overlook this.... I'll fix.,
38700,mfussenegger,https://api.github.com/repos/neovim/neovim/pulls/15723,814654034,2022-02-25T10:28:26Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,142 @@+local M = {}++local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return math.floor((n / math.pow(2, k)) % 2)+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  -- FIXME: this is should be done properly here and in the codelens implementation. Handlers should+  -- not be responsible of checking whether their responses are still valid.+  if err or not response or not config.on_token or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {+      line = line,+      start_char = start_char,+      length = data[i + 2],+      type = token_type,+      modifiers = modifiers,+      offset_encoding = client.offset_encoding,+    }++    if token_type and config and config.on_token then+      config.on_token(ctx, token)+    end+  end+end++--- |lsp-handler| for the method `textDocument/semanticTokens/refresh`+---+function M.on_refresh(err, _, ctx, _)+  if not err then+    for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+      M.refresh(bufnr)+    end+  end+  return vim.NIL+end++---@private+function M._save_tick(bufnr)+  bufnr = bufnr or vim.api.nvim_get_current_buf()+  last_tick[bufnr] = vim.api.nvim_buf_get_changedtick(bufnr)+  active_requests[bufnr] = true+end++--- Refresh the semantic tokens for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- <pre>+---   autocmd BufEnter,CursorHold,InsertLeave <buffer> lua require 'vim.lsp.semantic_tokens'.refresh()+--- </pre>+---+--- @param bufnr number|nil","In other places (diagnostic API for example) we use `nil` to mean ""all buffers"" and 0 for current. Maybe worth changing this here to either not accept `nil` at all or have the same semantics for consistency. ",
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,814769185,2022-02-25T13:31:20Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,142 @@+local M = {}++local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return math.floor((n / math.pow(2, k)) % 2)+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  -- FIXME: this is should be done properly here and in the codelens implementation. Handlers should+  -- not be responsible of checking whether their responses are still valid.+  if err or not response or not config.on_token or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {+      line = line,+      start_char = start_char,+      length = data[i + 2],+      type = token_type,+      modifiers = modifiers,+      offset_encoding = client.offset_encoding,+    }++    if token_type and config and config.on_token then+      config.on_token(ctx, token)+    end+  end+end++--- |lsp-handler| for the method `textDocument/semanticTokens/refresh`+---+function M.on_refresh(err, _, ctx, _)+  if not err then+    for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+      M.refresh(bufnr)+    end+  end+  return vim.NIL+end++---@private+function M._save_tick(bufnr)+  bufnr = bufnr or vim.api.nvim_get_current_buf()+  last_tick[bufnr] = vim.api.nvim_buf_get_changedtick(bufnr)+  active_requests[bufnr] = true+end++--- Refresh the semantic tokens for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- <pre>+---   autocmd BufEnter,CursorHold,InsertLeave <buffer> lua require 'vim.lsp.semantic_tokens'.refresh()+--- </pre>+---+--- @param bufnr number|nil",sample implementation: https://github.com/theHamsta/nvim-semantic-tokens it was out-factored of this PR so that we don't need to fix how the mapping from the VSCode modifiers to hl-groups should work,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/15723,814785309,2022-02-25T13:54:23Z,runtime/lua/vim/lsp/semantic_tokens.lua,"@@ -0,0 +1,142 @@+local M = {}++local last_tick = {}+local active_requests = {}++---@private+local function get_bit(n, k)+  --todo(theHamsta): remove once `bit` module is available for non-LuaJIT+  if _G.bit then+    return _G.bit.band(_G.bit.rshift(n, k), 1)+  else+    return math.floor((n / math.pow(2, k)) % 2)+  end+end++---@private+local function modifiers_from_number(x, modifiers_table)+  local modifiers = {}+  for i = 0, #modifiers_table - 1 do+    local bit = get_bit(x, i)+    if bit == 1 then+      table.insert(modifiers, 1, modifiers_table[i + 1])+    end+  end++  return modifiers+end++--- |lsp-handler| for the method `textDocument/semanticTokens/full`+---+--- This function can be configured with |vim.lsp.with()| with the following options for `config`+---+--- `on_token`: A function with signature `function(ctx, token)` that is called+---             whenever a semantic token is received from the server from context `ctx`+---             (see |lsp-handler| for the definition of `ctx`). This can be used for highlighting the tokens.+---             `token` is a table:+---+--- <pre>+---   {+---         line             -- line number 0-based+---         start_char       -- start character 0-based+---         length           -- length in characters of this token+---         type             -- token type as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         modifiers        -- token modifier as string (see https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-classification)+---         offset_encoding  -- offset encoding used by the language server (see |lsp-sync|)+---   }+--- </pre>+---+--- `on_invalidate_range`: A function with signature `function(ctx, line_start, line_end)` called whenever tokens+---                        in a specific line range (`line_start`, `line_end`) should be considered invalidated+---                        (see |lsp-handler| for the definition of `ctx`). `line_end` can be -1 to+---                        indicate invalidation until the end of the buffer.+function M.on_full(err, response, ctx, config)+  if not ctx.bufnr or not ctx.client_id then+    return+  end+  active_requests[ctx.bufnr] = false+  if config and config.on_invalidate_range then+    config.on_invalidate_range(ctx, 0, -1)+  end+  -- if tick has changed our response is outdated!+  -- FIXME: this is should be done properly here and in the codelens implementation. Handlers should+  -- not be responsible of checking whether their responses are still valid.+  if err or not response or not config.on_token or last_tick[ctx.bufnr] ~= vim.api.nvim_buf_get_changedtick(ctx.bufnr) then+    return+  end+  local client = vim.lsp.get_client_by_id(ctx.client_id)+  if not client then+    return+  end+  local legend = client.server_capabilities.semanticTokensProvider.legend+  local token_types = legend.tokenTypes+  local token_modifiers = legend.tokenModifiers+  local data = response.data++  local line+  local start_char = 0+  for i = 1, #data, 5 do+    local delta_line = data[i]+    line = line and line + delta_line or delta_line+    local delta_start = data[i + 1]+    start_char = delta_line == 0 and start_char + delta_start or delta_start++    -- data[i+3] +1 because Lua tables are 1-indexed+    local token_type = token_types[data[i + 3] + 1]+    local modifiers = modifiers_from_number(data[i + 4], token_modifiers)++    local token = {+      line = line,+      start_char = start_char,+      length = data[i + 2],+      type = token_type,+      modifiers = modifiers,+      offset_encoding = client.offset_encoding,+    }++    if token_type and config and config.on_token then+      config.on_token(ctx, token)+    end+  end+end++--- |lsp-handler| for the method `textDocument/semanticTokens/refresh`+---+function M.on_refresh(err, _, ctx, _)+  if not err then+    for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(ctx.client_id)) do+      M.refresh(bufnr)+    end+  end+  return vim.NIL+end++---@private+function M._save_tick(bufnr)+  bufnr = bufnr or vim.api.nvim_get_current_buf()+  last_tick[bufnr] = vim.api.nvim_buf_get_changedtick(bufnr)+  active_requests[bufnr] = true+end++--- Refresh the semantic tokens for the current buffer+---+--- It is recommended to trigger this using an autocmd or via keymap.+---+--- <pre>+---   autocmd BufEnter,CursorHold,InsertLeave <buffer> lua require 'vim.lsp.semantic_tokens'.refresh()+--- </pre>+---+--- @param bufnr number|nil",The intention was to make it work like https://github.com/theHamsta/neovim/blob/3b0a0c6ca6c5f4e719028be2dba11853ffec6b6b/runtime/lua/vim/lsp/codelens.lua#L231-L249,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17522,815082666,2022-02-25T19:56:42Z,src/nvim/ex_docmd.c,"@@ -5802,6 +5802,29 @@ static void ex_delcommand(exarg_T *eap)   } } +/// Split a string by unescaped whitespace (space & tab), used for f-args on commands+///+/// @note  If no separator is found start = 0 and end = length - 1+/// @param[in]  arg  String to split+/// @param[in]  iter Iteration counter+/// @param[out]  start Start of the split+/// @param[out]  end End of the split+/// @param[in]  length Length of the string+/// @return  false if it's the last split (don't call again), true otherwise (call again).+bool uc_split_args_iter(const char_u *arg, int iter, int *start, int *end, int length)","Just under this function you can see the ex function, it does a lot more it allocates and quotes every parameter, and also replaces in the whole command string I believe. So reusing is not an easy option. ",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17522,815087184,2022-02-25T20:04:45Z,src/nvim/ex_docmd.c,"@@ -5802,6 +5802,29 @@ static void ex_delcommand(exarg_T *eap)   } } +/// Split a string by unescaped whitespace (space & tab), used for f-args on commands+///+/// @note  If no separator is found start = 0 and end = length - 1+/// @param[in]  arg  String to split+/// @param[in]  iter Iteration counter+/// @param[out]  start Start of the split+/// @param[out]  end End of the split+/// @param[in]  length Length of the string+/// @return  false if it's the last split (don't call again), true otherwise (call again).+bool uc_split_args_iter(const char_u *arg, int iter, int *start, int *end, int length)",Here it's https://github.com/neovim/neovim/blob/4b0b470f237074e53853e10639f25abb5c5b04df/src/nvim/ex_docmd.c#L5831,
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17522,815187248,2022-02-25T22:09:55Z,src/nvim/ex_docmd.c,"@@ -5802,6 +5802,29 @@ static void ex_delcommand(exarg_T *eap)   } } +/// Split a string by unescaped whitespace (space & tab), used for f-args on commands+///+/// @note  If no separator is found start = 0 and end = length - 1+/// @param[in]  arg  String to split+/// @param[in]  iter Iteration counter+/// @param[out]  start Start of the split+/// @param[out]  end End of the split+/// @param[in]  length Length of the string+/// @return  false if it's the last split (don't call again), true otherwise (call again).+bool uc_split_args_iter(const char_u *arg, int iter, int *start, int *end, int length)","Just did!About the bonus, I like this comment ���� :https://github.com/neovim/neovim/blob/005a7aa1670841dfdffb7559161a7d37d6c14bc4/src/nvim/ex_docmd.c#L6005-L6007",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/17531,815334702,2022-02-26T17:30:11Z,src/nvim/window.c,"@@ -700,26 +700,26 @@ void win_set_minimal_style(win_T *wp)   } } -void win_config_float(win_T *wp, FloatConfig fconfig)+void win_config_float(win_T *wp, FloatConfig *fconfig)","This changes the semantics.  Previously, `fconfg` was copied so any changes in this function don't affect the caller.  Now, the changes do affect the caller's config.  Is that an issue?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17538,815455863,2022-02-27T15:35:08Z,src/nvim/strings.c,"@@ -354,7 +354,7 @@ char *strcase_save(const char *const orig, bool upper)     int l = utf_ptr2len((const char_u *)p);     if (c == 0) {       // overlong sequence, use only the first byte-      c = *p;+      c = (char_u)(*p);","seems like it could actually change behaviour, `*p` is likely non-ASCII here. is there any test covering this (strcase_save somehow being called with an overlong)?",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/14661,815510478,2022-02-27T23:45:23Z,src/nvim/keymap.h,"@@ -443,6 +444,8 @@ enum key_extra { #define K_COMMAND       TERMCAP2KEY(KS_EXTRA, KE_COMMAND) #define K_LUA           TERMCAP2KEY(KS_EXTRA, KE_LUA) +#define K_AUCMD_SPECIAL TERMCAP2KEY(KS_EXTRA, KE_AUCMD_SPECIAL)+",This seems unused.,
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,815654393,2022-02-28T08:04:51Z,runtime/doc/api.txt,"@@ -3108,6 +3108,195 @@ nvim_tabpage_set_var({tabpage}, {name}, {value})                     {value}    Variable value  +==============================================================================+Autocmd Functions                                                *api-autocmd*++nvim_create_augroup({*opts})                           *nvim_create_augroup()*+                Create or get an autocommand group. See |autocmd-groups|.++                To get an existing augroup id, do: >+                    local id = vim.api.nvim_create_augroup({+                      name = ""MyGroup"",+                      clear = false+                    });+<++                Parameters: ~+                    {opts}  Dictionary Parameters+                            ��� name: (string) The name of the augroup+                            ��� clear: (bool), defaults to true. Whether to+                              clear existing command or not for the group (if+                              it exists). See |autocmd-groups|.++                Return: ~+                    Integer The id of the created augroup.++                See also: ~+                    autocmd-groups++nvim_create_autocmd({*opts})                           *nvim_create_autocmd()*+                Define a new autocommand, See |autocmd|.++                Example: >+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      callback = function() print(""This buffer enters"") end, +                      once = false,+                    })+<++                Example values for patterns: >+                  pattern = ""*.py,*.pyi""+                  pattern = ""*.py""+                  pattern = {""*.py""}+                  pattern = { ""*.py"", ""*.pyi"" }+                  -- NOT supported+                  pattern = {""*.py,*.pyi""}+<++                Examples values for events: >+                  event = ""FileType,CursorHold""+                  event = ""BufPreWrite""+                  event = {""BufPostWrite""}+                  event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+<++                NOTE: Requires one of pattern or buffer, requires one of+                callback or command,","Hmm, that belongs to the parameters list, and isn't fully reflected there. I'll have to think how to best fold that in.",
40318218,CppCXY,https://api.github.com/repos/neovim/neovim/pulls/17547,815926124,2022-02-28T14:14:45Z,runtime/lua/vim/lsp/handlers.lua,"@@ -157,25 +157,25 @@ M['workspace/workspaceFolders'] = function(_, _, ctx)   local client_id = ctx.client_id   local client = vim.lsp.get_client_by_id(client_id)   if not client then-    err_message(""LSP[id="", client_id, ""] client has shut down after sending the message"")+    err_message('LSP[id=', client_id, '] client has shut down after sending the message')     return   end   return client.workspace_folders or vim.NIL end  M['textDocument/publishDiagnostics'] = function(...)-  return require('vim.lsp.diagnostic').on_publish_diagnostics(...)+  return require 'vim.lsp.diagnostic'.on_publish_diagnostics(...) end  M['textDocument/codeLens'] = function(...)-  return require('vim.lsp.codelens').on_codelens(...)+  return require 'vim.lsp.codelens'.on_codelens(...)",this feature has been implement by option```call_arg_parentheses = unambiguous_remove_string_only```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17545,816034715,2022-02-28T16:12:21Z,src/nvim/api/autocmd.c,"@@ -256,39 +281,72 @@ Array nvim_get_autocmds(Dict(get_autocmds) *opts, Error *err)   return autocmd_list; } -/// Define an autocmd.-/// @param opts Dictionary-///          Required keys:-///              event: string | ArrayOf(string)-/// event = ""pat1,pat2,pat3"",-/// event = ""pat1""-/// event = {""pat1""}-/// event = {""pat1"", ""pat2"", ""pat3""}+/// Define a new autocommand, See |autocmd|.+///+/// The API allows for two types of actions to be executed (mutually exclusive) when the autocommand+/// triggers: A callback function (Lua or Vimscript), or a command (like regular autocmds). ///+/// Example using callback:+/// <pre>+///     -- Lua function+///     local myluafun = function() print(""This buffer enters"") end+///+///     -- Vimscript function name (as a string)+///     local myvimfun = ""g:MyVimFunction""+///+///     vim.api.nvim_create_autocmd({+///       event = {""BufEnter"", ""BufWinEnter""},+///       pattern = {""*.c"", ""*.h""},+///       callback = myluafun,  -- Or myvimfun+///     })+/// </pre> ///-/// -- @param {string} name - augroup name-/// -- @param {string | table} event - event or events to match against-/// -- @param {string | table} pattern - pattern or patterns to match against-/// -- @param {string | function} callback - function or string to execute on autocmd-/// -- @param {string} command - optional, vimscript command-///          Eg. command = ""let g:value_set = v:true""-/// -- @param {boolean} once - optional, defaults to false+/// Example using command:+/// <pre>+///     vim.api.nvim_create_autocmd({+///       event = {""BufEnter"", ""BufWinEnter""},+///       pattern = {""*.c"", ""*.h""},+///       command = ""echo 'Entering a C or C++ file'"",+///     })+/// </pre> ///-/// -- pattern = comma delimited list of patterns | pattern | { pattern, ... }+/// Example values for patterns:+/// <pre>+///   pattern = ""*.py,*.pyi""+///   pattern = ""*.py""+///   pattern = {""*.py""}+///   pattern = { ""*.py"", ""*.pyi"" }+///   -- NOT supported+///   pattern = {""*.py,*.pyi""}+/// </pre> ///-/// pattern = ""*.py,*.pyi""-/// pattern = ""*.py""-/// pattern = {""*.py""}-/// pattern = { ""*.py"", ""*.pyi"" }+/// Examples values for events:+/// <pre>+///   event = ""FileType,CursorHold""+///   event = ""BufPreWrite""+///   event = {""BufPostWrite""}+///   event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+/// </pre> ///-/// -- not supported-/// pattern = {""*.py,*.pyi""}+/// @param opts Dictionary of autocommand options.+///             - group: (string) optional, the group name |autocmd-groups|.+///             - event: (string|array) required, event or events to match against. See+///             |autocmd-events|.+///             - pattern: (string|array) optional, pattern or patterns to match against. See+///             |autocmd-pattern|.","```suggestion///             - pattern: (string|array) optional, pattern or patterns to match against |autocmd-pattern|.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17545,816034959,2022-02-28T16:12:38Z,src/nvim/api/autocmd.c,"@@ -256,39 +281,72 @@ Array nvim_get_autocmds(Dict(get_autocmds) *opts, Error *err)   return autocmd_list; } -/// Define an autocmd.-/// @param opts Dictionary-///          Required keys:-///              event: string | ArrayOf(string)-/// event = ""pat1,pat2,pat3"",-/// event = ""pat1""-/// event = {""pat1""}-/// event = {""pat1"", ""pat2"", ""pat3""}+/// Define a new autocommand, See |autocmd|.+///+/// The API allows for two types of actions to be executed (mutually exclusive) when the autocommand+/// triggers: A callback function (Lua or Vimscript), or a command (like regular autocmds). ///+/// Example using callback:+/// <pre>+///     -- Lua function+///     local myluafun = function() print(""This buffer enters"") end+///+///     -- Vimscript function name (as a string)+///     local myvimfun = ""g:MyVimFunction""+///+///     vim.api.nvim_create_autocmd({+///       event = {""BufEnter"", ""BufWinEnter""},+///       pattern = {""*.c"", ""*.h""},+///       callback = myluafun,  -- Or myvimfun+///     })+/// </pre> ///-/// -- @param {string} name - augroup name-/// -- @param {string | table} event - event or events to match against-/// -- @param {string | table} pattern - pattern or patterns to match against-/// -- @param {string | function} callback - function or string to execute on autocmd-/// -- @param {string} command - optional, vimscript command-///          Eg. command = ""let g:value_set = v:true""-/// -- @param {boolean} once - optional, defaults to false+/// Example using command:+/// <pre>+///     vim.api.nvim_create_autocmd({+///       event = {""BufEnter"", ""BufWinEnter""},+///       pattern = {""*.c"", ""*.h""},+///       command = ""echo 'Entering a C or C++ file'"",+///     })+/// </pre> ///-/// -- pattern = comma delimited list of patterns | pattern | { pattern, ... }+/// Example values for patterns:+/// <pre>+///   pattern = ""*.py,*.pyi""+///   pattern = ""*.py""+///   pattern = {""*.py""}+///   pattern = { ""*.py"", ""*.pyi"" }+///   -- NOT supported+///   pattern = {""*.py,*.pyi""}+/// </pre> ///-/// pattern = ""*.py,*.pyi""-/// pattern = ""*.py""-/// pattern = {""*.py""}-/// pattern = { ""*.py"", ""*.pyi"" }+/// Examples values for events:+/// <pre>+///   event = ""FileType,CursorHold""+///   event = ""BufPreWrite""+///   event = {""BufPostWrite""}+///   event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+/// </pre> ///-/// -- not supported-/// pattern = {""*.py,*.pyi""}+/// @param opts Dictionary of autocommand options.+///             - group: (string) optional, the group name |autocmd-groups|.+///             - event: (string|array) required, event or events to match against. See+///             |autocmd-events|.+///             - pattern: (string|array) optional, pattern or patterns to match against. See+///             |autocmd-pattern|.+///             - buffer: (integer) optional, buffer number for buffer local autocmds (can't be used+///             together with pattern). See |autocmd-buflocal|.","```suggestion///             - buffer: (integer) optional, buffer number for buffer local autocmds (can't be used///             together with pattern) |autocmd-buflocal|.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17545,816036415,2022-02-28T16:14:16Z,src/nvim/api/autocmd.c,"@@ -554,30 +617,42 @@ Integer nvim_create_augroup(uint64_t channel_id, Dict(create_augroup) *opts, Err   return augroup; } -/// NOTE: behavior differs from augroup-delete.-/// When deleting an augroup, autocmds contained by this augroup will also be deleted and cleared.-/// This augroup will no longer exist+/// Delete an autocommand group by id.+///+/// NOTE: behavior differs from |augroup-delete|. When deleting an augroup, autocmds contained by+/// this augroup will also be deleted and cleared. This augroup will no longer exist+/// @param id Integer The id returned by nvim_create_augroup.+/// @see nvim_del_augroup_by_name+/// @see nvim_create_augroup void nvim_del_augroup_by_id(Integer id)   FUNC_API_SINCE(9) {   char *name = augroup_name((int)id);   augroup_del(name, false); } -/// NOTE: behavior differs from augroup-delete.-/// When deleting an augroup, autocmds contained by this augroup will also be deleted and cleared.-/// This augroup will no longer exist+/// Delete an autocommand group by name.+///+/// NOTE: behavior differs from |augroup-delete|. When deleting an augroup, autocmds contained by+/// this augroup will also be deleted and cleared. This augroup will no longer exist.+/// @see autocommand-groups void nvim_del_augroup_by_name(String name)   FUNC_API_SINCE(9) {   augroup_del(name.data, false); } -/// -- @param {string} group - autocmd group name-/// -- @param {number} buffer - buffer number-/// -- @param {string | table} event - event or events to match against-/// -- @param {string | table} pattern - optional, defaults to ""*"".-/// vim.api.nvim_do_autcmd({ group, buffer, pattern, event, modeline })+/// Execute an autocommand |autocmd-execute|.+/// @param opts Dictionary of autocommand options.+///             - event: (string|array) required, event or events to match against. See+///             |autocmd-events|.+///             - group: (string) optional, group name. See |autocmd-groups|.+///             - pattern: (string|array) optional, defaults to ""*"". See |autocmd-pattern|.","```suggestion///             - pattern: (string|array) optional, defaults to ""*"" |autocmd-pattern|.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17545,816036582,2022-02-28T16:14:27Z,src/nvim/api/autocmd.c,"@@ -554,30 +617,42 @@ Integer nvim_create_augroup(uint64_t channel_id, Dict(create_augroup) *opts, Err   return augroup; } -/// NOTE: behavior differs from augroup-delete.-/// When deleting an augroup, autocmds contained by this augroup will also be deleted and cleared.-/// This augroup will no longer exist+/// Delete an autocommand group by id.+///+/// NOTE: behavior differs from |augroup-delete|. When deleting an augroup, autocmds contained by+/// this augroup will also be deleted and cleared. This augroup will no longer exist+/// @param id Integer The id returned by nvim_create_augroup.+/// @see nvim_del_augroup_by_name+/// @see nvim_create_augroup void nvim_del_augroup_by_id(Integer id)   FUNC_API_SINCE(9) {   char *name = augroup_name((int)id);   augroup_del(name, false); } -/// NOTE: behavior differs from augroup-delete.-/// When deleting an augroup, autocmds contained by this augroup will also be deleted and cleared.-/// This augroup will no longer exist+/// Delete an autocommand group by name.+///+/// NOTE: behavior differs from |augroup-delete|. When deleting an augroup, autocmds contained by+/// this augroup will also be deleted and cleared. This augroup will no longer exist.+/// @see autocommand-groups void nvim_del_augroup_by_name(String name)   FUNC_API_SINCE(9) {   augroup_del(name.data, false); } -/// -- @param {string} group - autocmd group name-/// -- @param {number} buffer - buffer number-/// -- @param {string | table} event - event or events to match against-/// -- @param {string | table} pattern - optional, defaults to ""*"".-/// vim.api.nvim_do_autcmd({ group, buffer, pattern, event, modeline })+/// Execute an autocommand |autocmd-execute|.+/// @param opts Dictionary of autocommand options.+///             - event: (string|array) required, event or events to match against. See+///             |autocmd-events|.+///             - group: (string) optional, group name. See |autocmd-groups|.+///             - pattern: (string|array) optional, defaults to ""*"". See |autocmd-pattern|.+///             - buffer: (integer) buffer number, can't be used together with pattern. See+///             |autocmd-buflocal|.","```suggestion///             - buffer: (integer) buffer number, can't be used together with pattern |autocmd-buflocal|.```",
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17545,816039898,2022-02-28T16:17:56Z,src/nvim/api/autocmd.c,"@@ -61,13 +61,38 @@ static int64_t next_autocmd_id = 1;  /// Get autocmds that match the requirements passed to {opts}.-/// group-/// event-/// pattern ///-/// -- @param {string} event - event or events to match against-/// vim.api.nvim_get_autocmds({ event = ""FileType"" })+/// This examples will get autocommands matching ALL the given criteria:+/// <pre>+///   -- Matches all criteria+///   autocommands = vim.api.nvim_get_autocmds({+///     group = ""MyGroup"",+///     event = {""BufEnter"", ""BufWinEnter""},+///     pattern = {""*.c"", ""*.h""}+///   })+///+///   -- All commands from one group+///   autocommands = vim.api.nvim_get_autocmds({+///     group = ""MyGroup"",+///   })+/// </pre> ///+/// @param opts Dictionary with at least one of the following.+///             - group: (string) the autocmd group to match against.+///             - event: (string|array) event or events to match against. See |autocmd-events|.+///             - pattern: (string|array) pattern or patterns to match against. See+///             |autocmd-pattern|.",```suggestion///             - pattern: (string|array) pattern or patterns to match against |autocmd-pattern|.```,
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/17542,816239810,2022-02-28T20:49:34Z,ci/build.ps1,"@@ -167,14 +167,15 @@ if (-not $NoTests) {   # Old tests   # Add MSYS to path, required for e.g. `find` used in test scripts.   # But would break functionaltests, where its `more` would be used then.-  $OldPath = $env:PATH-  $env:PATH = ""C:\msys64\usr\bin;$env:PATH""-  & ""C:\msys64\mingw$bits\bin\mingw32-make.exe"" -C $(Convert-Path ..\src\nvim\testdir) VERBOSE=1 ; exitIfFailed-  $env:PATH = $OldPath--  if ($uploadToCodecov) {-    bash -l /c/projects/neovim/ci/common/submit_coverage.sh oldtest-  }+  +  # $OldPath = $env:PATH","Absolutely, good call. I don't think we want to remove the code since the end goal is to actually use it, this was just intended as a temporary fix until the oldtests are functional again on windows (they currently hang on some test making all windows jobs time out). But maybe it's better to just try to fix the test directly instead :thinking: . I'll need to think about it. Drafting this for now.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17558,816919661,2022-03-01T16:11:06Z,runtime/ftplugin/man.vim,"@@ -22,7 +22,8 @@ setlocal tagfunc=man#goto_tag if !exists('g:no_plugin_maps') && !exists('g:no_man_maps')   nnoremap <silent> <buffer> j             gj   nnoremap <silent> <buffer> k             gk-  nnoremap <silent> <buffer> gO            :call man#show_toc()<CR>+  nnoremap <silent> <buffer> gF            :call man#show_flags()<CR>","I think `gF` might not be ideal, since it's a default mapping for navigation to a filename under cursor and in man pages is usual to find said filenames, I personally navigate often to the listed ones in manpages.I personally prefer to see the flags as subcategories in the TOC, or in a mapping like `[count]gO`.",
17462095,mxteries,https://api.github.com/repos/neovim/neovim/pulls/17510,817307204,2022-03-02T02:56:01Z,runtime/doc/diagnostic.txt,"@@ -39,16 +39,18 @@ modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it requires a namespace.  							*diagnostic-structure*-A diagnostic is a Lua table with the following keys:+A diagnostic is a Lua table with the following keys. Required keys are+indicated with (*):  	bufnr: Buffer number-	lnum: The starting line of the diagnostic+	lnum(*): The starting line of the diagnostic 	end_lnum: The final line of the diagnostic-	col: The starting column of the diagnostic+	col(*): The starting column of the diagnostic 	end_col: The final column of the diagnostic 	severity: The severity of the diagnostic |vim.diagnostic.severity|-	message: The diagnostic text+	message(*): The diagnostic text","Something to note: `message` is supposed to be a required field, but there's no `assert` that's checking for it like there is with `lnum` and `col`: https://github.com/neovim/neovim/blob/4c24fcb91f7740410b94638b3156ba20647df579/runtime/lua/vim/diagnostic.lua#L272-L276So I can `vim.diagnostic.set()` a diagnostic without a message, but when I try to `vim.diagnostic.open_float()` it, the call fails. If that is indeed unintended, then I can open an issue for it. It's technically a breaking change so I'm not sure if I should address it in this PR",
17462095,mxteries,https://api.github.com/repos/neovim/neovim/pulls/17510,817307930,2022-03-02T02:58:02Z,runtime/lua/vim/lsp/diagnostic.lua,"@@ -120,7 +122,8 @@ end ---@private local function diagnostic_vim_to_lsp(diagnostics)   return vim.tbl_map(function(diagnostic)-    return vim.tbl_extend(""error"", {+    return vim.tbl_extend(""keep"", {+      -- ""keep"" the below fields over any duplicate fields in diagnostic.user_data.lsp",This function looks like it's only called by deprecated `vim.lsp.diagnostic` functions. Should I just not change this function if that's the case?,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/17563,818053064,2022-03-02T19:56:56Z,.builds/openbsd.yml,"@@ -35,9 +35,13 @@ tasks:     cmake -G Ninja $CMAKE_EXTRA_FLAGS ..     cmake --build . --config RelWithDebInfo     ./bin/nvim --version-- functionaltest: |-    cd neovim/build-    cmake --build . --config RelWithDebInfo --target functionaltest",We don't actually know how much is impacted.  The tests always hang on a buffer_updates_spec.lua.  What if we instead skip that test and let the rest run?```env BUSTED_ARGS=--exclude-pattern=buffer_updates cmake --build . --config RelWithDebInfo --target functionaltest```,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/16897,820075701,2022-03-05T09:45:25Z,src/nvim/decoration.c,"@@ -201,25 +232,25 @@ bool decor_redraw_start(buf_T *buf, int top_row, DecorState *state)     }  next_mark:-    if (marktree_itr_node_done(state->itr)) {-      marktree_itr_next(buf->b_marktree, state->itr);-      break;-    }+    // TODO(lewis6991): Need to iter the full tree for signs.+    // if (marktree_itr_node_done(state->itr)) {+    //   marktree_itr_next(buf->b_marktree, state->itr);+    //   break;+    // }","@lewis6991 More or less. but for now we should just allow such signs to go missing rather scanning the entire tree, before #13243 is done (realistically, I'll could get it done for 0.8). This already works well enough for multi-line highlights, those work if they are small and don't overlap too many other marks (the common case), and if they are big we are already using multiple marks as a work around (or ephemerals, which completely lack this issue, in the case of tree-sitter). Scanning the entire tree here defeats the purpose of having the btree data structure in the first place.",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/17538,820088287,2022-03-05T11:49:49Z,src/nvim/strings.c,"@@ -354,7 +354,7 @@ char *strcase_save(const char *const orig, bool upper)     int l = utf_ptr2len((const char_u *)p);     if (c == 0) {       // overlong sequence, use only the first byte-      c = *p;+      c = (char_u)(*p);","@bfredl: I don't know what an overlong is. I've tested different alphabets, take a look and see if it's sufficent enough testing or if we need more.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17538,820089297,2022-03-05T11:59:34Z,src/nvim/strings.c,"@@ -354,7 +354,7 @@ char *strcase_save(const char *const orig, bool upper)     int l = utf_ptr2len((const char_u *)p);     if (c == 0) {       // overlong sequence, use only the first byte-      c = *p;+      c = (char_u)(*p);","It means an UTF-8 sequence which is invalid because there is a compacter representation, like `""\xc0\x80""` would be an overlong representation of NUL, or (perhaps more relevantly) `""\xc1\x81""` would be an overlong `A` ",
67177269,dhruvmanila,https://api.github.com/repos/neovim/neovim/pulls/17559,820194885,2022-03-06T07:54:14Z,src/nvim/autocmd.c,"@@ -105,17 +105,28 @@ static char_u *old_termresponse = NULL; #define FOR_ALL_AUPATS_IN_EVENT(event, ap) \   for (AutoPat *ap = first_autopat[event]; ap != NULL; ap = ap->next)  // NOLINT -// Map of autocmd group names.+// Map of autocmd group names and ids. //  name -> ID-static Map(String, int) augroup_map = MAP_INIT;+//  ID -> name+static Map(String, int) map_augroup_name_to_id = MAP_INIT;+static Map(int, String) map_augroup_id_to_name = MAP_INIT; -static void augroup_map_del(char *name)+static void augroup_name_map_del(char *name) {-  String key = map_key(String, int)(&augroup_map, cstr_as_string(name));-  map_del(String, int)(&augroup_map, key);+  String key = map_key(String, int)(&map_augroup_name_to_id, cstr_as_string(name));+  map_del(String, int)(&map_augroup_name_to_id, key);   api_free_string(key); } +static void augroup_id_map_del(int id)","Actually, I want the entry to be deleted from id->name map, and _not_ from name->id map.I could pass in a `NULL` for `name` parameter and put a conditional for it.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17622,820245048,2022-03-06T14:52:00Z,src/nvim/regexp.c,"@@ -5043,7 +5043,7 @@ static bool regmatch(             } else {               MB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);               if (limit > 0-                  && (long)(behind_pos.rs_u.ptr+                  && (long)(behind_pos.rs_u.ptr  // NOLINT(google-readability-casting)                             - rp->rs_un.regsave.rs_u.ptr) > limit) {",perhaps we should cast limit to `ptrdiff_t` instead? (semantically preferred as `sizeof(ptr) >= sizeof(long)` ),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17622,820245567,2022-03-06T14:56:26Z,src/nvim/eval/funcs.c,"@@ -7494,17 +7494,17 @@ static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)          * small, to avoid repeatedly 'allocing' large and          * 'reallocing' small. */         if (prevsize == 0) {-          prevsize = (long)(p - start);+          prevsize = (long)(p - start);  // NOLINT(google-readability-casting)","urgl, this is also a (pattern of) valid cast which shouldn't be an error.. (though maybe the real issue is that we should get rid of `long` eventually, it is an useless type which is size of ptr everywhere except for 64-bit MSVC)",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/17622,820249045,2022-03-06T15:24:17Z,src/nvim/eval/funcs.c,"@@ -7494,17 +7494,17 @@ static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)          * small, to avoid repeatedly 'allocing' large and          * 'reallocing' small. */         if (prevsize == 0) {-          prevsize = (long)(p - start);+          prevsize = (long)(p - start);  // NOLINT(google-readability-casting)","Would it be too janky to have a macro that only casts when it needs to? Something like (pseudocode):```c#ifdef WIN32  #define CAST_TO_LONG (long)#else  #define CAST_TO_LONG#endif```Alternatively I'm fine with just reverting this and the ones similar to this one, there are so few of them that it's not a big deal IMO. ",
67177269,dhruvmanila,https://api.github.com/repos/neovim/neovim/pulls/17559,820263279,2022-03-06T17:25:47Z,src/nvim/api/autocmd.c,"@@ -55,19 +55,27 @@ Array nvim_get_autocmds(Dict(get_autocmds) *opts, Error *err)    int group = 0; -  if (opts->group.type != kObjectTypeNil) {-    Object v = opts->group;-    if (v.type != kObjectTypeString) {-      api_set_error(err, kErrorTypeValidation, ""group must be a string."");-      goto cleanup;-    }--    group = augroup_find(v.data.string.data);--    if (group < 0) {-      api_set_error(err, kErrorTypeValidation, ""invalid augroup passed."");+  switch (opts->group.type) {+    case kObjectTypeNil:+      break;+    case kObjectTypeString:+      group = augroup_find(opts->group.data.string.data);+      if (group < 0) {",No: https://github.com/neovim/neovim/blob/3800615da9eaf9e8b26d9040c882c74084d688e4/src/nvim/autocmd.c#L950-L951,
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17616,820276536,2022-03-06T19:29:03Z,test/functional/legacy/autochdir_spec.lua,"@@ -1,28 +1,79 @@ local lfs = require('lfs') local helpers = require('test.functional.helpers')(after_each) local clear, eq, matches = helpers.clear, helpers.eq, helpers.matches-local eval, command, call = helpers.eval, helpers.command, helpers.call-local exec_capture = helpers.exec_capture+local eval, command, call, meths = helpers.eval, helpers.command, helpers.call, helpers.meths+local source, exec_capture = helpers.source, helpers.exec_capture++local function expected_empty()+  eq({}, meths.get_vvar('errors'))+end  describe('autochdir behavior', function()   local dir = 'Xtest_functional_legacy_autochdir'    before_each(function()     lfs.mkdir(dir)     clear()+    command('set shellslash')   end)    after_each(function()     helpers.rmdir(dir)   end) -  -- Tests vim/vim/777 without test_autochdir().+  -- Tests vim/vim#777 without test_autochdir().   it('sets filename', function()     command('set acd')     command('new')     command('w '..dir..'/Xtest')     eq('Xtest', eval(""expand('%')""))-    eq(dir, eval([[substitute(getcwd(), '.*[/\\]\(\k*\)', '\1', '')]]))+    eq(dir, eval([[substitute(getcwd(), '.*/\(\k*\)', '\1', '')]]))+  end)++  it(':file in win_execute() does not cause wrong directory', function()+    command('cd '..dir)+    source([[+      func Test_set_filename_other_window()+        let cwd = getcwd()+        call mkdir('Xa')+        call mkdir('Xb')+        call mkdir('Xc')+        try+          args Xa/aaa.txt Xb/bbb.txt+          set acd+          let winid = win_getid()+          snext+          call assert_equal('Xb', substitute(getcwd(), '.*/\([^/]*\)$', '\1', ''))+          call win_execute(winid, 'file ' .. cwd .. '/Xc/ccc.txt')+          call assert_equal('Xb', substitute(getcwd(), '.*/\([^/]*\)$', '\1', ''))+        finally+          set noacd+          call chdir(cwd)+          call delete('Xa', 'rf')+          call delete('Xb', 'rf')+          call delete('Xc', 'rf')+          bwipe! aaa.txt+          bwipe! bbb.txt+          bwipe! ccc.txt+        endtry+      endfunc+    ]])+    call('Test_set_filename_other_window')+    expected_empty()+  end)++  it('win_execute() does not change directory', function()+    local subdir = 'Xfile'+    command('cd '..dir)+    command('set acd')+    call('mkdir', subdir)+    local winid = eval('win_getid()')+    command('new '..subdir..'/file')+    matches('.*'..dir..'/'..subdir, eval('getcwd()'))+    command('cd ..')+    matches('.*'..dir, eval('getcwd()'))+    call('win_execute', winid, 'echo')+    matches('.*'..dir, eval('getcwd()'))","minor, but maybe a pattern closer to what assert_match uses can be used:```suggestion    matches(dir..'/'..subdir..'$', eval('getcwd()'))    command('cd ..')    matches(dir..'$', eval('getcwd()'))    call('win_execute', winid, 'echo')    matches(dir..'$', eval('getcwd()'))```tbh this can maybe apply to other matches in the file; it's not so important",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/17673,824666267,2022-03-11T12:23:11Z,src/nvim/buffer.c,"@@ -2059,10 +2037,8 @@ void buflist_getfpos(void)   } } -/*- * Find file in buffer list by name (it has to be for the current window).- * Returns NULL if not found.- */+/// Find file in buffer list by name (it has to be for the current window).+/// Returns NULL if not found.",`@return buffer or NULL if not found` (and similar for functions below),
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,825336571,2022-03-12T18:51:27Z,src/nvim/api/autocmd.c,"@@ -256,39 +281,73 @@ Array nvim_get_autocmds(Dict(get_autocmds) *opts, Error *err)   return autocmd_list; } -/// Define an autocmd.-/// @param opts Dictionary-///          Required keys:-///              event: string | ArrayOf(string)-/// event = ""pat1,pat2,pat3"",-/// event = ""pat1""-/// event = {""pat1""}-/// event = {""pat1"", ""pat2"", ""pat3""}+/// Define a new autocommand |autocmd|.+///+/// The API allows for two types of actions to be executed (mutually exclusive) when the autocommand+/// triggers: a callback function (Lua or Vimscript), or a command (like regular autocommands). ///+/// Example using callback:+/// <pre>+///     -- Lua function+///     local myluafun = function() print(""This buffer enters"") end+///+///     -- Vimscript function name (as a string)+///     local myvimfun = ""g:MyVimFunction""+///+///     vim.api.nvim_create_autocmd({+///       event = {""BufEnter"", ""BufWinEnter""},+///       pattern = {""*.c"", ""*.h""},+///       callback = myluafun,  -- Or myvimfun+///     })+/// </pre> ///-/// -- @param {string} name - augroup name-/// -- @param {string | table} event - event or events to match against-/// -- @param {string | table} pattern - pattern or patterns to match against-/// -- @param {string | function} callback - function or string to execute on autocmd-/// -- @param {string} command - optional, vimscript command-///          Eg. command = ""let g:value_set = v:true""-/// -- @param {boolean} once - optional, defaults to false+/// Example using command:+/// <pre>+///     vim.api.nvim_create_autocmd({+///       event = {""BufEnter"", ""BufWinEnter""},+///       pattern = {""*.c"", ""*.h""},+///       command = ""echo 'Entering a C or C++ file'"",+///     })+/// </pre> ///-/// -- pattern = comma delimited list of patterns | pattern | { pattern, ... }+/// Example values for patterns:+/// <pre>+///   pattern = ""*.py,*.pyi""+///   pattern = ""*.py""+///   pattern = {""*.py""}+///   pattern = { ""*.py"", ""*.pyi"" }+///   -- NOT supported+///   pattern = {""*.py,*.pyi""}+/// </pre> ///-/// pattern = ""*.py,*.pyi""-/// pattern = ""*.py""-/// pattern = {""*.py""}-/// pattern = { ""*.py"", ""*.pyi"" }+/// Examples values for events:+/// <pre>+///   event = ""FileType,CursorHold""+///   event = ""BufPreWrite""+///   event = {""BufPostWrite""}+///   event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+/// </pre> ///-/// -- not supported-/// pattern = {""*.py,*.pyi""}+/// @param opts Dictionary of autocommand options:+///             - group: (string) optional, the group name |autocmd-groups|.",```suggestion///             - group (string) optional: the group name |autocmd-groups|.```and similar for the other options here and below,
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17697,825363740,2022-03-12T23:29:13Z,src/nvim/screen.c,"@@ -4569,20 +4549,62 @@ static bool use_cursor_line_sign(win_T *wp, linenr_T lnum)          && (wp->w_p_culopt_flags & CULOPT_NBR); } +// Return true if CursorLine highlight is to be used.+static bool use_cursor_line(win_T *wp, linenr_T lnum, int row, int startrow, int filler_lines)+{+  return wp->w_p_cul+         && lnum == wp->w_cursor.lnum+         && (wp->w_p_culopt_flags & CULOPT_NBR)+         && (row == startrow + filler_lines+             || (row > startrow + filler_lines+                 && wp->w_p_culopt_flags & CULOPT_LINE));+}++static int get_number_attr(win_T *wp, linenr_T lnum, int row, int startrow, int filler_lines,+                           sign_attrs_T *sattrs)+{+  sign_attrs_T *num_sattr = sign_get_attr(SIGN_NUMHL, sattrs, 0, 1);+  if (num_sattr != NULL) {+    // :sign defined with ""numhl"" highlight.+    return num_sattr->sat_numhl;+  }++  if (wp->w_p_rnu) {+    if (lnum < wp->w_cursor.lnum) {+      // Use LineNrAbove+      return win_hl_attr(wp, HLF_LNA);+    }+    if (lnum > wp->w_cursor.lnum) {+      // Use LineNrBelow+      return win_hl_attr(wp, HLF_LNB);+    }+  }++  if (use_cursor_line(wp, lnum, row, startrow, filler_lines)) {+    // When 'cursorline' is set highlight the line number of+    // the current line differently.+    // When 'cursorlineopt' has ""screenline"" only highlight+    // the line number itself.+    // TODO(vim): Can we use CursorLine instead of CursorLineNr+    // when CursorLineNr isn't set?","I meant these comments here. These comments describe the conditions inside `use_cursor_line()`, so making `use_cursor_line()` a separate function make them look strange. BTW, there comments can now be moved above the `if` line now. They previously appear above the `if` line, and were moved below in <https://github.com/neovim/neovim/commit/bddcbbb5716a005001da3bacb4c1df4ae05e51bc>. Now that there is no longer an `else` branch, they can be moved above again.",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17702,825379990,2022-03-13T03:22:40Z,src/nvim/quickfix.c,"@@ -1739,22 +1739,23 @@ static void ll_free_all(qf_info_T **pqi)   }   *pqi = NULL;          // Remove reference to this list +  // If the location list is still in use, then queue the delete request+  // to be processed later.+  if (quickfix_busy > 0) {+    locstack_queue_delreq(qi);+    return;+  }+   qi->qf_refcount--;   if (qi->qf_refcount < 1) {     // No references to this location list.-    // If the location list is still in use, then queue the delete request-    // to be processed later.-    if (quickfix_busy > 0) {-      locstack_queue_delreq(qi);-    } else {-      // If the quickfix window buffer is loaded, then wipe it-      wipe_qf_buffer(qi);+    // If the quickfix window buffer is loaded, then wipe it+    wipe_qf_buffer(qi); -      for (i = 0; i < qi->qf_listcount; i++) {-        qf_free(qf_get_list(qi, i));-      }-      xfree(qi);+    for (i = 0; i < qi->qf_listcount; i++) {+      qf_free(&qi->qf_lists[i]);","```suggestion      qf_free(qf_get_list(qi, i));```",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17702,825381391,2022-03-13T03:44:55Z,src/nvim/quickfix.c,"@@ -6065,6 +6074,9 @@ static int qf_getprop_keys2flags(const dict_T *what, bool loclist)   if (tv_dict_find(what, S_LEN(""quickfixtextfunc"")) != NULL) {     flags |= QF_GETLIST_QFTF;   }+  if (tv_dict_find(what, S_LEN(""qfbufnr"")) != NULL) {+    flags |= QF_GETLIST_QFBUFNR;+  }","pedantic, but I'd add this before `quickfixtextfunc`'s check to match Vim's order",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17747,829463394,2022-03-17T20:16:02Z,src/nvim/tui/input.c,"@@ -124,16 +125,34 @@ static void tinput_wait_enqueue(void **argv)     const String keys = { .data = buf, .size = len };     if (input->paste) {       String copy = copy_string(keys);-      multiqueue_put(main_loop.events, tinput_paste_event, 3,-                     copy.data, copy.size, (intptr_t)input->paste);+      if (ui_client_channel_id) {+        Array args = ARRAY_DICT_INIT;+        ADD(args, STRING_OBJ(copy_string(keys)));  // 'data'",I meant  `copy` is unused when this path is chosen. I'll fix this in #17754.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16064,830566726,2022-03-20T06:36:08Z,test/functional/legacy/memory_usage_spec.lua,"@@ -136,21 +137,19 @@ describe('memory usage', function()   it('function capture lvars', function()     local pid = eval('getpid()')     local before = monitor_memory_usage(pid)-    local fname = source([[-      if !exists('s:defined_func')-        func s:f()-          let x = l:-        endfunc-      endif-      let s:defined_func = 1+    insert([[+      func s:f()+        let x = l:+      endfunc       for _ in range(10000)         call s:f()       endfor     ]])+    command('source')     poke_eventloop()     local after = monitor_memory_usage(pid)     for _ = 1, 3 do-      feed_command('so '..fname)+      command('source')","using command() instead of feed_command() fails (on `master`), does that imply a race (i.e. the test was passing accidentally)?",
6256228,seandewar,https://api.github.com/repos/neovim/neovim/pulls/17760,830578376,2022-03-20T08:29:43Z,src/nvim/highlight_group.c,"@@ -2797,3 +2807,1164 @@ int name_to_ctermcolor(const char *name)   TriState bold = kNone;   return lookup_color(i, false, &bold); }++/// Add match to the match list of window 'wp'.  The pattern 'pat' will be+/// highlighted with the group 'grp' with priority 'prio'.+/// Optionally, a desired ID 'id' can be specified (greater than or equal to 1).+///+/// @param[in] id a desired ID 'id' can be specified+///               (greater than or equal to 1). -1 must be specified if no+///               particular ID is desired+/// @param[in] conceal_char pointer to conceal replacement char+/// @return ID of added match, -1 on failure.+int match_add(win_T *wp, const char *const grp, const char *const pat, int prio, int id,+              list_T *pos_list, const char *const conceal_char)+  FUNC_ATTR_NONNULL_ARG(1, 2)+{+  matchitem_T *cur;+  matchitem_T *prev;+  matchitem_T *m;+  int hlg_id;+  regprog_T *regprog = NULL;+  int rtype = SOME_VALID;++  if (*grp == NUL || (pat != NULL && *pat == NUL)) {+    return -1;+  }+  if (id < -1 || id == 0) {+    semsg(_(""E799: Invalid ID: %"" PRId64+            "" (must be greater than or equal to 1)""),+          (int64_t)id);+    return -1;+  }+  if (id != -1) {+    cur = wp->w_match_head;+    while (cur != NULL) {+      if (cur->id == id) {+        semsg(_(""E801: ID already taken: %"" PRId64), (int64_t)id);+        return -1;+      }+      cur = cur->next;+    }+  }+  if ((hlg_id = syn_check_group(grp, strlen(grp))) == 0) {+    return -1;+  }+  if (pat != NULL && (regprog = vim_regcomp((char_u *)pat, RE_MAGIC)) == NULL) {+    semsg(_(e_invarg2), pat);+    return -1;+  }++  // Find available match ID.+  while (id == -1) {+    cur = wp->w_match_head;+    while (cur != NULL && cur->id != wp->w_next_match_id) {+      cur = cur->next;+    }+    if (cur == NULL) {+      id = wp->w_next_match_id;+    }+    wp->w_next_match_id++;+  }++  // Build new match.+  m = xcalloc(1, sizeof(matchitem_T));+  m->id = id;+  m->priority = prio;+  m->pattern = pat == NULL ? NULL: (char_u *)xstrdup(pat);+  m->hlg_id = hlg_id;+  m->match.regprog = regprog;+  m->match.rmm_ic = false;+  m->match.rmm_maxcol = 0;+  m->conceal_char = 0;+  if (conceal_char != NULL) {+    m->conceal_char = utf_ptr2char((const char_u *)conceal_char);+  }++  // Set up position matches+  if (pos_list != NULL) {+    linenr_T toplnum = 0;+    linenr_T botlnum = 0;++    int i = 0;+    TV_LIST_ITER(pos_list, li, {+      linenr_T lnum = 0;+      colnr_T col = 0;+      int len = 1;+      bool error = false;++      if (TV_LIST_ITEM_TV(li)->v_type == VAR_LIST) {+        const list_T *const subl = TV_LIST_ITEM_TV(li)->vval.v_list;+        const listitem_T *subli = tv_list_first(subl);+        if (subli == NULL) {+          semsg(_(""E5030: Empty list at position %d""),+                (int)tv_list_idx_of_item(pos_list, li));+          goto fail;+        }+        lnum = tv_get_number_chk(TV_LIST_ITEM_TV(subli), &error);+        if (error) {+          goto fail;+        }+        if (lnum <= 0) {+          continue;+        }+        m->pos.pos[i].lnum = lnum;+        subli = TV_LIST_ITEM_NEXT(subl, subli);+        if (subli != NULL) {+          col = (colnr_T)tv_get_number_chk(TV_LIST_ITEM_TV(subli), &error);+          if (error) {+            goto fail;+          }+          if (col < 0) {+            continue;+          }+          subli = TV_LIST_ITEM_NEXT(subl, subli);+          if (subli != NULL) {+            len = (colnr_T)tv_get_number_chk(TV_LIST_ITEM_TV(subli), &error);+            if (len < 0) {+              continue;+            }+            if (error) {+              goto fail;+            }+          }+        }+        m->pos.pos[i].col = col;+        m->pos.pos[i].len = len;+      } else if (TV_LIST_ITEM_TV(li)->v_type == VAR_NUMBER) {+        if (TV_LIST_ITEM_TV(li)->vval.v_number <= 0) {+          continue;+        }+        m->pos.pos[i].lnum = TV_LIST_ITEM_TV(li)->vval.v_number;+        m->pos.pos[i].col = 0;+        m->pos.pos[i].len = 0;+      } else {+        semsg(_(""E5031: List or number required at position %d""),+              (int)tv_list_idx_of_item(pos_list, li));+        goto fail;+      }+      if (toplnum == 0 || lnum < toplnum) {+        toplnum = lnum;+      }+      if (botlnum == 0 || lnum >= botlnum) {+        botlnum = lnum + 1;+      }+      i++;+      if (i >= MAXPOSMATCH) {+        break;+      }+    });++    // Calculate top and bottom lines for redrawing area+    if (toplnum != 0) {+      if (wp->w_buffer->b_mod_set) {+        if (wp->w_buffer->b_mod_top > toplnum) {+          wp->w_buffer->b_mod_top = toplnum;+        }+        if (wp->w_buffer->b_mod_bot < botlnum) {+          wp->w_buffer->b_mod_bot = botlnum;+        }+      } else {+        wp->w_buffer->b_mod_set = true;+        wp->w_buffer->b_mod_top = toplnum;+        wp->w_buffer->b_mod_bot = botlnum;+        wp->w_buffer->b_mod_xlines = 0;+      }+      m->pos.toplnum = toplnum;+      m->pos.botlnum = botlnum;+      rtype = VALID;+    }+  }++  // Insert new match.  The match list is in ascending order with regard to+  // the match priorities.+  cur = wp->w_match_head;+  prev = cur;+  while (cur != NULL && prio >= cur->priority) {+    prev = cur;+    cur = cur->next;+  }+  if (cur == prev) {+    wp->w_match_head = m;+  } else {+    prev->next = m;+  }+  m->next = cur;++  redraw_later(wp, rtype);+  return id;++fail:+  xfree(m);+  return -1;+}++/// Delete match with ID 'id' in the match list of window 'wp'.+///+/// @param perr  print error messages if true.+int match_delete(win_T *wp, int id, bool perr)+{+  matchitem_T *cur = wp->w_match_head;+  matchitem_T *prev = cur;+  int rtype = SOME_VALID;++  if (id < 1) {+    if (perr) {+      semsg(_(""E802: Invalid ID: %"" PRId64+              "" (must be greater than or equal to 1)""),+            (int64_t)id);+    }+    return -1;+  }+  while (cur != NULL && cur->id != id) {+    prev = cur;+    cur = cur->next;+  }+  if (cur == NULL) {+    if (perr) {+      semsg(_(""E803: ID not found: %"" PRId64), (int64_t)id);+    }+    return -1;+  }+  if (cur == prev) {+    wp->w_match_head = cur->next;+  } else {+    prev->next = cur->next;+  }+  vim_regfree(cur->match.regprog);+  xfree(cur->pattern);+  if (cur->pos.toplnum != 0) {+    if (wp->w_buffer->b_mod_set) {+      if (wp->w_buffer->b_mod_top > cur->pos.toplnum) {+        wp->w_buffer->b_mod_top = cur->pos.toplnum;+      }+      if (wp->w_buffer->b_mod_bot < cur->pos.botlnum) {+        wp->w_buffer->b_mod_bot = cur->pos.botlnum;+      }+    } else {+      wp->w_buffer->b_mod_set = true;+      wp->w_buffer->b_mod_top = cur->pos.toplnum;+      wp->w_buffer->b_mod_bot = cur->pos.botlnum;+      wp->w_buffer->b_mod_xlines = 0;+    }+    rtype = VALID;+  }+  xfree(cur);+  redraw_later(wp, rtype);+  return 0;+}++/// Delete all matches in the match list of window 'wp'.+void clear_matches(win_T *wp)+{+  matchitem_T *m;++  while (wp->w_match_head != NULL) {+    m = wp->w_match_head->next;+    vim_regfree(wp->w_match_head->match.regprog);+    xfree(wp->w_match_head->pattern);+    xfree(wp->w_match_head);+    wp->w_match_head = m;+  }+  redraw_later(wp, SOME_VALID);+}++/// Get match from ID 'id' in window 'wp'.+/// Return NULL if match not found.+matchitem_T *get_match(win_T *wp, int id)+{+  matchitem_T *cur = wp->w_match_head;++  while (cur != NULL && cur->id != id) {+    cur = cur->next;+  }+  return cur;+}++/// Init for calling prepare_search_hl().+void init_search_hl(win_T *wp, match_T *search_hl)+  FUNC_ATTR_NONNULL_ALL+{+  // Setup for match and 'hlsearch' highlighting.  Disable any previous+  // match+  matchitem_T *cur = wp->w_match_head;+  while (cur != NULL) {+    cur->hl.rm = cur->match;+    if (cur->hlg_id == 0) {+      cur->hl.attr = 0;+    } else {+      cur->hl.attr = syn_id2attr(cur->hlg_id);+    }+    cur->hl.buf = wp->w_buffer;+    cur->hl.lnum = 0;+    cur->hl.first_lnum = 0;+    // Set the time limit to 'redrawtime'.+    cur->hl.tm = profile_setlimit(p_rdt);+    cur = cur->next;+  }+  search_hl->buf = wp->w_buffer;+  search_hl->lnum = 0;+  search_hl->first_lnum = 0;+  search_hl->attr = win_hl_attr(wp, HLF_L);++  // time limit is set at the toplevel, for all windows+}++/// @param shl       points to a match. Fill on match.+/// @param posmatch  match positions+/// @param mincol    minimal column for a match+///+/// @return one on match, otherwise return zero.+int next_search_hl_pos(match_T *shl, linenr_T lnum, posmatch_T *posmatch, colnr_T mincol)+  FUNC_ATTR_NONNULL_ALL+{+  int i;+  int found = -1;++  shl->lnum = 0;+  for (i = posmatch->cur; i < MAXPOSMATCH; i++) {+    llpos_T *pos = &posmatch->pos[i];++    if (pos->lnum == 0) {+      break;+    }+    if (pos->len == 0 && pos->col < mincol) {+      continue;+    }+    if (pos->lnum == lnum) {+      if (found >= 0) {+        // if this match comes before the one at ""found"" then swap+        // them+        if (pos->col < posmatch->pos[found].col) {+          llpos_T tmp = *pos;++          *pos = posmatch->pos[found];+          posmatch->pos[found] = tmp;+        }+      } else {+        found = i;+      }+    }+  }+  posmatch->cur = 0;+  if (found >= 0) {+    colnr_T start = posmatch->pos[found].col == 0+                    ? 0: posmatch->pos[found].col - 1;+    colnr_T end = posmatch->pos[found].col == 0+                  ? MAXCOL : start + posmatch->pos[found].len;++    shl->lnum = lnum;+    shl->rm.startpos[0].lnum = 0;+    shl->rm.startpos[0].col = start;+    shl->rm.endpos[0].lnum = 0;+    shl->rm.endpos[0].col = end;+    shl->is_addpos = true;+    posmatch->cur = found + 1;+    return 1;+  }+  return 0;+}++/// Search for a next 'hlsearch' or match.+/// Uses shl->buf.+/// Sets shl->lnum and shl->rm contents.+/// Note: Assumes a previous match is always before ""lnum"", unless+/// shl->lnum is zero.+/// Careful: Any pointers for buffer lines will become invalid.+///+/// @param shl     points to search_hl or a match+/// @param mincol  minimal column for a match+/// @param cur     to retrieve match positions if any+static void next_search_hl(win_T *win, match_T *search_hl, match_T *shl, linenr_T lnum,+                           colnr_T mincol, matchitem_T *cur)+  FUNC_ATTR_NONNULL_ARG(2)+{+  linenr_T l;+  colnr_T matchcol;+  long nmatched = 0;+  int save_called_emsg = called_emsg;++  // for :{range}s/pat only highlight inside the range+  if (lnum < search_first_line || lnum > search_last_line) {+    shl->lnum = 0;+    return;+  }++  if (shl->lnum != 0) {+    // Check for three situations:+    // 1. If the ""lnum"" is below a previous match, start a new search.+    // 2. If the previous match includes ""mincol"", use it.+    // 3. Continue after the previous match.+    l = shl->lnum + shl->rm.endpos[0].lnum - shl->rm.startpos[0].lnum;+    if (lnum > l) {+      shl->lnum = 0;+    } else if (lnum < l || shl->rm.endpos[0].col > mincol) {+      return;+    }+  }++  // Repeat searching for a match until one is found that includes ""mincol""+  // or none is found in this line.+  called_emsg = false;+  for (;;) {+    // Stop searching after passing the time limit.+    if (profile_passed_limit(shl->tm)) {+      shl->lnum = 0;                    // no match found in time+      break;+    }+    // Three situations:+    // 1. No useful previous match: search from start of line.+    // 2. Not Vi compatible or empty match: continue at next character.+    //    Break the loop if this is beyond the end of the line.+    // 3. Vi compatible searching: continue at end of previous match.+    if (shl->lnum == 0) {+      matchcol = 0;+    } else if (vim_strchr(p_cpo, CPO_SEARCH) == NULL+               || (shl->rm.endpos[0].lnum == 0+                   && shl->rm.endpos[0].col <= shl->rm.startpos[0].col)) {+      char_u *ml;++      matchcol = shl->rm.startpos[0].col;+      ml = ml_get_buf(shl->buf, lnum, false) + matchcol;+      if (*ml == NUL) {+        matchcol++;+        shl->lnum = 0;+        break;+      }+      matchcol += utfc_ptr2len(ml);+    } else {+      matchcol = shl->rm.endpos[0].col;+    }++    shl->lnum = lnum;+    if (shl->rm.regprog != NULL) {+      // Remember whether shl->rm is using a copy of the regprog in+      // cur->match.+      bool regprog_is_copy = (shl != search_hl+                              && cur != NULL+                              && shl == &cur->hl+                              && cur->match.regprog == cur->hl.rm.regprog);+      int timed_out = false;++      nmatched = vim_regexec_multi(&shl->rm, win, shl->buf, lnum, matchcol,+                                   &(shl->tm), &timed_out);+      // Copy the regprog, in case it got freed and recompiled.+      if (regprog_is_copy) {+        cur->match.regprog = cur->hl.rm.regprog;+      }+      if (called_emsg || got_int || timed_out) {+        // Error while handling regexp: stop using this regexp.+        if (shl == search_hl) {+          // don't free regprog in the match list, it's a copy+          vim_regfree(shl->rm.regprog);+          set_no_hlsearch(true);+        }+        shl->rm.regprog = NULL;+        shl->lnum = 0;+        got_int = false;  // avoid the ""Type :quit to exit Vim"" message+        break;+      }+    } else if (cur != NULL) {+      nmatched = next_search_hl_pos(shl, lnum, &(cur->pos), matchcol);+    }+    if (nmatched == 0) {+      shl->lnum = 0;                    // no match found+      break;+    }+    if (shl->rm.startpos[0].lnum > 0+        || shl->rm.startpos[0].col >= mincol+        || nmatched > 1+        || shl->rm.endpos[0].col > mincol) {+      shl->lnum += shl->rm.startpos[0].lnum;+      break;                            // useful match found+    }++    // Restore called_emsg for assert_fails().+    called_emsg = save_called_emsg;+  }+}++/// Advance to the match in window ""wp"" line ""lnum"" or past it.+void prepare_search_hl(win_T *wp, match_T *search_hl, linenr_T lnum)+  FUNC_ATTR_NONNULL_ALL+{+  matchitem_T *cur;             // points to the match list+  match_T *shl;             // points to search_hl or a match+  bool shl_flag;                // flag to indicate whether search_hl+                                // has been processed or not++  // When using a multi-line pattern, start searching at the top+  // of the window or just after a closed fold.+  // Do this both for search_hl and the match list.+  cur = wp->w_match_head;+  shl_flag = false;+  while (cur != NULL || shl_flag == false) {+    if (shl_flag == false) {+      shl = search_hl;+      shl_flag = true;+    } else {+      shl = &cur->hl;  // -V595+    }+    if (shl->rm.regprog != NULL+        && shl->lnum == 0+        && re_multiline(shl->rm.regprog)) {+      if (shl->first_lnum == 0) {+        for (shl->first_lnum = lnum;+             shl->first_lnum > wp->w_topline;+             shl->first_lnum--) {+          if (hasFoldingWin(wp, shl->first_lnum - 1, NULL, NULL, true, NULL)) {+            break;+          }+        }+      }+      if (cur != NULL) {+        cur->pos.cur = 0;+      }+      bool pos_inprogress = true;  // mark that a position match search is+                                   // in progress+      int n = 0;+      while (shl->first_lnum < lnum && (shl->rm.regprog != NULL+                                        || (cur != NULL && pos_inprogress))) {+        next_search_hl(wp, search_hl, shl, shl->first_lnum, (colnr_T)n,+                       shl == search_hl ? NULL : cur);+        pos_inprogress = !(cur == NULL || cur->pos.cur == 0);+        if (shl->lnum != 0) {+          shl->first_lnum = shl->lnum+                            + shl->rm.endpos[0].lnum+                            - shl->rm.startpos[0].lnum;+          n = shl->rm.endpos[0].col;+        } else {+          shl->first_lnum++;+          n = 0;+        }+      }+    }+    if (shl != search_hl && cur != NULL) {+      cur = cur->next;+    }+  }+}++/// Prepare for 'hlsearch' and match highlighting in one window line.+/// Return TRUE if there is such highlighting and set ""search_attr"" to the+/// current highlight attribute.+int prepare_search_hl_line(win_T *wp, linenr_T lnum, colnr_T mincol, char_u **line,+                           match_T *search_hl, int *search_attr, bool *search_attr_from_match,+                           bool has_fold, bool end_fill)+{+  // Handle highlighting the last used search pattern and matches.+  // Do this for both search_hl and the match list.+  matchitem_T *cur = wp->w_match_head;  // points to the match list+  match_T     *shl;                     // points to search_hl or a match+  int          shl_flag = false;        // flag to indicate whether search_hl+                                        // has been processed or not+  bool         area_highlighting = false;+++  while ((cur != NULL || !shl_flag) && !has_fold && !end_fill) {+    if (!shl_flag) {+      shl = search_hl;+      shl_flag = true;+    } else {+      shl = &cur->hl;  // -V595+    }+    shl->startcol = MAXCOL;+    shl->endcol = MAXCOL;+    shl->attr_cur = 0;+    shl->is_addpos = false;+    if (cur != NULL) {+      cur->pos.cur = 0;+    }+    next_search_hl(wp, search_hl, shl, lnum, mincol,+                   shl == search_hl ? NULL : cur);++    // Need to get the line again, a multi-line regexp may have made it+    // invalid.+    *line = ml_get_buf(wp->w_buffer, lnum, false);++    if (shl->lnum != 0 && shl->lnum <= lnum) {+      if (shl->lnum == lnum) {+        shl->startcol = shl->rm.startpos[0].col;+      } else {+        shl->startcol = 0;+      }+      if (lnum == shl->lnum + shl->rm.endpos[0].lnum+          - shl->rm.startpos[0].lnum) {+        shl->endcol = shl->rm.endpos[0].col;+      } else {+        shl->endcol = MAXCOL;+      }+      // Highlight one character for an empty match.+      if (shl->startcol == shl->endcol) {+        if ((*line)[shl->endcol] != NUL) {+          shl->endcol += utfc_ptr2len(*line + shl->endcol);+        } else {+          shl->endcol++;+        }+      }+      if ((long)shl->startcol < mincol) {   // match at leftcol+        shl->attr_cur = shl->attr;+        *search_attr = shl->attr;+        *search_attr_from_match = shl != search_hl;+      }+      area_highlighting = true;+    }+    if (shl != search_hl && cur != NULL) {+      cur = cur->next;+    }+  }+  return area_highlighting;+}++/// For a position in a line: Check for start/end of 'hlsearch' and other+/// matches.+/// After end, check for start/end of next match.+/// When another match, have to check for start again.+/// Watch out for matching an empty string!+/// Return the udpated search_attr.+int update_search_hl(win_T *wp, linenr_T lnum, colnr_T col, char_u **line, match_T *search_hl,+                     int *has_match_conc, int *match_conc, int lcs_eol_one,+                     bool *search_attr_from_match)+{+  matchitem_T *cur = wp->w_match_head;  // points to the match list+  match_T     *shl;                     // points to search_hl or a match+  int          shl_flag = false;        // flag to indicate whether search_hl+                                        // has been processed or not+  int          search_attr = 0;++  while (cur != NULL || !shl_flag) {",```suggestion  // Do this for 'search_hl' and the match list (ordered by priority).  while (cur != NULL || !shl_flag) {```,
8965202,gpanders,https://api.github.com/repos/neovim/neovim/pulls/17786,830642239,2022-03-20T16:39:46Z,src/nvim/api/autocmd.c,"@@ -315,8 +315,13 @@ Array nvim_get_autocmds(Dict(get_autocmds) *opts, Error *err) /// /// @param opts Optional Parameters: ///         - callback: (string|function)-///             - (string): The name of the viml function to execute when triggering this autocmd-///             - (function): The lua function to execute when triggering this autocmd+///             - (string): The name of the Vimscript function to execute when this autocmd is+///                         triggered.+///             - (function): Lua function to call when triggering this autocmd.+///             - The function is passed a dict or table with the keys ""match"", ""file"", and ""buf""+///               with values corresponding to the expanded values of |<amatch>|, |<afile>|, and+///               |<abuf>|, respectively. If the callback function returns |v:true|, then the"," The use of `v:true` was intentional: Vimscript functions must return `v:true` explicitly, not any ���true��� value. Saying it must return `true` is ambiguous, because in Vimscript `1` is true, but does not remove the autocommand.It is less ambiguous to infer that `v:true` == `true` in Lua than the other way around. ",
67177269,dhruvmanila,https://api.github.com/repos/neovim/neovim/pulls/17698,831021651,2022-03-21T11:52:26Z,src/nvim/api/autocmd.c,"@@ -763,10 +782,119 @@ static bool unpack_string_or_array(Array *array, Object *v, char *k, Error *err)     }     *array = copy_array(v->data.array);   } else {-    api_set_error(err,-                  kErrorTypeValidation,-                  ""'%s' must be an array or a string."",-                  k);+    if (required) {+      api_set_error(err,+                    kErrorTypeValidation,+                    ""'%s' must be an array or a string."",+                    k);+      return false;+    }+  }++  return true;+}++// Returns AUGROUP_ERROR if there was a problem with {group}+static int get_augroup_from_object(Object group, Error *err)",I think this could be used in two more functions: [`nvim_get_autocmds`](https://github.com/neovim/neovim/blob/d8bf4b413574c4b12526b97ee73445e026a7ea29/src/nvim/api/autocmd.c#L65-L86) and [`nvim_do_autocmd`](https://github.com/neovim/neovim/blob/d8bf4b413574c4b12526b97ee73445e026a7ea29/src/nvim/api/autocmd.c#L680-L703) in a similar way as done in `nvim_create_autocmd`.,
7189118,theHamsta,https://api.github.com/repos/neovim/neovim/pulls/17802,831095077,2022-03-21T13:17:49Z,runtime/lua/vim/treesitter/query.lua,"@@ -114,9 +114,12 @@ local explicit_queries = setmetatable({}, { --- ---@param lang string: The language to use for the query ---@param query_name string: The name of the query (i.e. ""highlights"")----@param text string: The query text (unparsed).-function M.set_query(lang, query_name, text)-  explicit_queries[lang][query_name] = M.parse_query(lang, text)+---@param query string or Query: The query text (either unparsed or parsed).+function M.set_query(lang, query_name, query)",Isn't this API call always bad and should be deprecated? Ideally you want always to be able to set unparsed queries and having them parsed only once they are needed. Like setting the queries for all the filetypes in your config and only parse when you open the filetypes instead of making the loading of your config slower,X
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/16064,831121677,2022-03-21T13:43:46Z,runtime/doc/vim_diff.txt,"@@ -180,6 +180,7 @@ Commands:   |:Man| is available by default, with many improvements such as completion   |:sign-define| accepts a `numhl` argument, to highlight the line number   |:match| can be invoked before highlight group is defined+  |:source| works with Lua and anonymous (no file) scripts","Thanks. I'm going to leave this for now, even though it's not technically accurate. This differences list is partly to call out new features that weren't available in Vim at time of writing. The fact that Vim might merge a Neovim feature later doesn't really change the function of calling out new Nvim features that users would not otherwise discover.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/17795,831198023,2022-03-21T14:52:21Z,src/nvim/tui/tui.c,"@@ -135,6 +136,7 @@ typedef struct {   char *space_buf; } TUIData; +static bool volatile first_resize = true;","usual convention is ""did"" prefix. What is the difference semantically with `did_user_set_dimensions` ? Do we still need both? Can we eliminate any of the `did_user_set_dimensions` logic?```suggestionstatic bool volatile did_resize = false;```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/17809,831533958,2022-03-21T20:53:59Z,src/nvim/ops.c,"@@ -3893,7 +3893,8 @@ void ex_display(exarg_T *eap)             msg_puts_attr(""^J"", attr);             n -= 2;           }-          for (p = yb->y_array[j]; *p && (n -= ptr2cells(p)) >= 0; p++) {+          for (p = yb->y_array[j]; *p && n >= 0; p++) {+            n -= ptr2cells(p);","Ughhhh, you're right. I did make a small test to see if it was correct but it was a bad test it turns out. Thanks for the catch.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17795,831600042,2022-03-21T22:41:39Z,src/nvim/tui/tui.c,"@@ -135,6 +136,7 @@ typedef struct {   char *space_buf; } TUIData; +static bool volatile first_resize = true;","Went ahead an renamed, and also moved into scope where I think its purpose clearer, it also didn't need `volatile`.Semantically `did_user_set_dimensions` is to not resize the **host terminal window**.This PR and the new variable `did_first_resize` is about resizing the **TUI** correctly and **only at startup**.",
9699804,muniter,https://api.github.com/repos/neovim/neovim/pulls/17768,831734136,2022-03-22T03:16:58Z,.github/workflows/api-docs.yml,"@@ -44,6 +53,12 @@ jobs:           python3 scripts/gen_vimdoc.py           printf '::set-output name=UPDATED_DOCS::%s\n' $([ -z ""$(git diff)"" ]; echo $?) +      - name: FAIL, PR has not commited doc changes+        if: ${{ steps.docs.outputs.UPDATED_DOCS != 0 && inputs.check_only }}+        run: |+          echo ""Job failed, run ./scripts/gen_vimdoc.py and commit your doc changes""+          exit 1+       - name: Automatic PR         if: ${{ steps.docs.outputs.UPDATED_DOCS != 0 }}","Yeah this must be it, `check_only` is false and `UPDATE_DOCS != 0`.That's the only way it reaches this line from a workflow_call and fail because of permissions. But the weird thing is the only workflow call comes from [here](https://github.com/muniter/neovim/blob/91914010252a1f5c8a3358d09c3be92f30585ee3/.github/workflows/api-docs-check.yml#L17) where we pass `check_only` true.@zeertzjq Did you get this error from a rerun of the job perhaps?cc @dundargoc ",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/17783,832602258,2022-03-22T20:35:36Z,src/nvim/CMakeLists.txt,"@@ -213,6 +213,8 @@ if(CLANG_ASAN_UBSAN OR CLANG_MSAN OR CLANG_TSAN)   list(APPEND gen_cflags ""-DEXITFREE"") endif() +set(CMAKE_C_FLAGS_DEBUG ""-DEXITFREE"")","The way this is currently being done means it doesn't show up in `nvim --version`.  Especially since this changes the behavior of the resulting binary, I think it should show up there.I think a better change would be to move the whole```cmakeif(CLANG_ASAN_UBSAN OR CLANG_MSAN OR CLANG_TSAN)  list(APPEND gen_cflags ""-DEXITFREE"")endif()```up to line 205 and change it to```cmakeif(DEBUG OR CLANG_ASAN_UBSAN OR CLANG_MSAN OR CLANG_TSAN)  add_definitions(-DEXITFREE)endif()```This should also allow removing the```cmakeset_property(TARGET nvim APPEND PROPERTY COMPILE_DEFINITIONS EXITFREE)```further down in this file (lines 710, 715, 720).",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17829,833775131,2022-03-23T22:33:35Z,runtime/autoload/health/nvim.vim,"@@ -144,6 +144,23 @@ function! s:check_performance() abort           \ ['Install a different Nvim package, or rebuild with `CMAKE_BUILD_TYPE=RelWithDebInfo`.',           \  s:suggest_faq])   endif++  "" check for slow shell invocation+  let shell_cmd = 'ls'","How long `ls` takes can depend on the filesystem and the working directory, and it may also be missing on Windows. I'd suggest `echo`.",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17740,833781131,2022-03-23T22:45:55Z,src/nvim/memline.c,"@@ -1616,9 +1596,9 @@ static time_t swapfile_info(char_u *fname)   return x; } -/// @return  true if the swap file looks OK and there are no changes, thus it+/// @return  TRUE if the swap file looks OK and there are no changes, thus it ///          can be safely deleted.-static bool swapfile_unchanged(char *fname)+static time_t swapfile_unchanged(char *fname)",This no longer needs change.,
13316262,mjlbach,https://api.github.com/repos/neovim/neovim/pulls/17831,833806867,2022-03-23T23:44:58Z,runtime/lua/vim/shared.lua,"@@ -347,6 +347,30 @@ function vim.tbl_add_reverse_lookup(o)   return o end +--- Index into a table using a list of keys. Return `nil` if the key does not exist.+--- Examples:+--- <pre>+---  vim.tbl_get({ key = { nested_key = true }}, {'key', 'nested_key'}) == true+---  vim.tbl_get({ key = {}}, {'key', 'nested_key'}) == nil+--- </pre>+---+---@param o Table to index+---@param keys List of indices via which to index the table+---+---@returns nested value indexed by key if it exists, else nil+function vim.tbl_get(o, keys)","The main reason I didn't do this is because I optimized for the case of passing the list retrieved from a given table, such as here: https://github.com/neovim/neovim/pull/17814/files#diff-c6a4160a416b22cd1fd833b8f852c4fbaf1f25adf75053e82a1025aa2c607ac9R35-R54https://github.com/neovim/neovim/pull/17814/files#diff-c6a4160a416b22cd1fd833b8f852c4fbaf1f25adf75053e82a1025aa2c607ac9R973-R977",
35768171,zeertzjq,https://api.github.com/repos/neovim/neovim/pulls/17842,834315623,2022-03-24T13:37:19Z,runtime/lua/vim/keymap.lua,"@@ -59,7 +61,12 @@ function keymap.set(mode, lhs, rhs, opts)   if is_rhs_luaref and opts.expr and opts.replace_keycodes ~= false then     local user_rhs = rhs     rhs = function ()-      return vim.api.nvim_replace_termcodes(user_rhs(), true, true, true)+      local res = user_rhs()+      if not res then+        return '<nop>'","In `:h :map-expr`:```In case you want the mapping to not do anything, you can have the expressionevaluate to an empty string.  If something changed that requires Vim togo through the main loop (e.g. to update the display), return ""\<Ignore>"".This is similar to ""nothing"" but makes Vim return from the loop that waits forinput.```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,835232991,2022-03-25T12:40:55Z,runtime/doc/api.txt,"@@ -3152,129 +3152,203 @@ nvim_tabpage_set_var({tabpage}, {name}, {value}) Autocmd Functions                                                *api-autocmd*  nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*-                Create or get an augroup.+                Create or get an autocommand group |autocmd-groups|. -                To get an existing augroup ID, do: >-                    local id = vim.api.nvim_create_augroup(name, {+                To get an existing group id, do: >+                    local id = vim.api.nvim_create_augroup(""MyGroup"", {                         clear = false                     }) <                  Parameters: ~-                    {name}  String: The name of the augroup to create-                    {opts}  Parameters-                            ��� clear (bool): Whether to clear existing commands-                              or not. Defaults to true. See |autocmd-groups|+                    {name}  String: The name of the group+                    {opts}  Dictionary Parameters+                            ��� clear (bool) optional: defaults to true. Clear+                              existing commands if the group already exists+                              |autocmd-groups|.                  Return: ~-                    opaque value to use with nvim_del_augroup_by_id+                    Integer id of the created group.++                See also: ~+                    |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-                Create an autocmd.+                Create an autocommand |autocmd|. -                Examples:-                ��� event: ""pat1,pat2,pat3"",-                ��� event: ""pat1""-                ��� event: { ""pat1"" }-                ��� event: { ""pat1"", ""pat2"", ""pat3"" }+                The API allows for two types of actions to be executed+                (mutually exclusive) when the autocommand triggers: a callback+                function (Lua or Vimscript), or a command (like regular+                autocommands). -                Parameters: ~-                    {event}  The event or events to register this autocmd-                             Required keys: event: string | ArrayOf(string)+                Example using callback: >+                    -- Lua function+                    local myluafun = function() print(""This buffer enters"") end -                Parameters: ~-                    {opts}  Optional Parameters:-                            ��� callback: (string|function)-                              ��� (string): The name of the viml function to-                                execute when triggering this autocmd-                              ��� (function): The lua function to execute when-                                triggering this autocmd-                              ��� NOTE: Cannot be used with {command}+                    -- Vimscript function name (as a string)+                    local myvimfun = ""g:MyVimFunction"" -                            ��� command: (string) command-                              ��� vimscript command-                              ��� NOTE: Cannot be used with {callback} Eg.-                                command = ""let g:value_set = v:true""+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      callback = myluafun,  -- Or myvimfun+                    })+<++                Example using command: >+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      command = ""echo 'Entering a C or C++ file'"",+                    })+< -                            ��� pattern: (string|table)-                              ��� pattern or patterns to match against-                              ��� defaults to ""*"".-                              ��� NOTE: Cannot be used with {buffer}+                Example values for pattern: >+                  pattern = ""*.py""+                  pattern = { ""*.py"", ""*.pyi"" }+< -                            ��� buffer: (bufnr)-                              ��� create a |autocmd-buflocal| autocmd.-                              ��� NOTE: Cannot be used with {pattern}+                Examples values for event: >+                  event = ""BufPreWrite""+                  event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+< -                            ��� group: (string|int) The augroup name or id-                            ��� once: (boolean) - See |autocmd-once|-                            ��� nested: (boolean) - See |autocmd-nested|-                            ��� desc: (string) - Description of the autocmd+                Parameters: ~+                    {event}  (String|Array) The event or events to register+                             this autocmd","```suggestion                             this autocommand```(and similar for the `{opts}` description).Big �������� on standardizing these, and opting for the full term!",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,835233915,2022-03-25T12:42:14Z,runtime/doc/api.txt,"@@ -3152,129 +3152,203 @@ nvim_tabpage_set_var({tabpage}, {name}, {value}) Autocmd Functions                                                *api-autocmd*  nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*-                Create or get an augroup.+                Create or get an autocommand group |autocmd-groups|. -                To get an existing augroup ID, do: >-                    local id = vim.api.nvim_create_augroup(name, {+                To get an existing group id, do: >+                    local id = vim.api.nvim_create_augroup(""MyGroup"", {                         clear = false                     }) <                  Parameters: ~-                    {name}  String: The name of the augroup to create-                    {opts}  Parameters-                            ��� clear (bool): Whether to clear existing commands-                              or not. Defaults to true. See |autocmd-groups|+                    {name}  String: The name of the group+                    {opts}  Dictionary Parameters+                            ��� clear (bool) optional: defaults to true. Clear+                              existing commands if the group already exists+                              |autocmd-groups|.                  Return: ~-                    opaque value to use with nvim_del_augroup_by_id+                    Integer id of the created group.++                See also: ~+                    |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-                Create an autocmd.+                Create an autocommand |autocmd|. -                Examples:-                ��� event: ""pat1,pat2,pat3"",-                ��� event: ""pat1""-                ��� event: { ""pat1"" }-                ��� event: { ""pat1"", ""pat2"", ""pat3"" }+                The API allows for two types of actions to be executed+                (mutually exclusive) when the autocommand triggers: a callback+                function (Lua or Vimscript), or a command (like regular+                autocommands). -                Parameters: ~-                    {event}  The event or events to register this autocmd-                             Required keys: event: string | ArrayOf(string)+                Example using callback: >+                    -- Lua function+                    local myluafun = function() print(""This buffer enters"") end -                Parameters: ~-                    {opts}  Optional Parameters:-                            ��� callback: (string|function)-                              ��� (string): The name of the viml function to-                                execute when triggering this autocmd-                              ��� (function): The lua function to execute when-                                triggering this autocmd-                              ��� NOTE: Cannot be used with {command}+                    -- Vimscript function name (as a string)+                    local myvimfun = ""g:MyVimFunction"" -                            ��� command: (string) command-                              ��� vimscript command-                              ��� NOTE: Cannot be used with {callback} Eg.-                                command = ""let g:value_set = v:true""+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      callback = myluafun,  -- Or myvimfun+                    })+<++                Example using command: >+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      command = ""echo 'Entering a C or C++ file'"",+                    })+< -                            ��� pattern: (string|table)-                              ��� pattern or patterns to match against-                              ��� defaults to ""*"".-                              ��� NOTE: Cannot be used with {buffer}+                Example values for pattern: >+                  pattern = ""*.py""+                  pattern = { ""*.py"", ""*.pyi"" }+< -                            ��� buffer: (bufnr)-                              ��� create a |autocmd-buflocal| autocmd.-                              ��� NOTE: Cannot be used with {pattern}+                Examples values for event: >+                  event = ""BufPreWrite""+                  event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+< -                            ��� group: (string|int) The augroup name or id-                            ��� once: (boolean) - See |autocmd-once|-                            ��� nested: (boolean) - See |autocmd-nested|-                            ��� desc: (string) - Description of the autocmd+                Parameters: ~+                    {event}  (String|Array) The event or events to register+                             this autocmd+                    {opts}   Dictionary of autocommand options:+                             ��� group (string|integer) optional: the autocmd+                               group name or id to match against.+                             ��� pattern (string|array) optional: pattern or+                               patterns to match against |autocmd-pattern|.+                             ��� buffer (integer) optional: buffer number for+                               buffer local autocmds |autocmd-buflocal|.+                               Cannot be used with {pattern}.+                             ��� desc (string) optional: description of the+                               autocmd.+                             ��� callback (function|string) optional: Lua+                               function or Vim function (as string) to execute+                               on event. Cannot be used with {command}+                             ��� command (string) optional: Vim command to+                               execute on event Cannot be used with {callback}+                             ��� once (boolean) optional: defaults to false. Run+                               the autocmd only once |autocmd-once|.+                             ��� nested (boolean) optional: defaults to false.+                               Run nested autocmds |autocmd-nested|.++                Return: ~+                    Integer id of the created autocommand. -                Return: ~-                    opaque value to use with nvim_del_autocmd+                See also: ~+                    |autocmd|+                    |nvim_del_autocmd()|  nvim_del_augroup_by_id({id})                        *nvim_del_augroup_by_id()*-                Delete an augroup by {id}. {id} can only be returned when-                augroup was created with |nvim_create_augroup|.+                Delete an autocommand group by id. -                NOTE: behavior differs from augroup-delete.+                To get a group id one can use |nvim_get_autocmds()|. -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist","```suggestion                NOTE: behavior differs from |augroup-delete|. When deleting a                group, autocommands contained in this group will also be                deleted and cleared. This group will no longer exist.```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,835234387,2022-03-25T12:42:49Z,runtime/doc/api.txt,"@@ -3152,129 +3152,203 @@ nvim_tabpage_set_var({tabpage}, {name}, {value}) Autocmd Functions                                                *api-autocmd*  nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*-                Create or get an augroup.+                Create or get an autocommand group |autocmd-groups|. -                To get an existing augroup ID, do: >-                    local id = vim.api.nvim_create_augroup(name, {+                To get an existing group id, do: >+                    local id = vim.api.nvim_create_augroup(""MyGroup"", {                         clear = false                     }) <                  Parameters: ~-                    {name}  String: The name of the augroup to create-                    {opts}  Parameters-                            ��� clear (bool): Whether to clear existing commands-                              or not. Defaults to true. See |autocmd-groups|+                    {name}  String: The name of the group+                    {opts}  Dictionary Parameters+                            ��� clear (bool) optional: defaults to true. Clear+                              existing commands if the group already exists+                              |autocmd-groups|.                  Return: ~-                    opaque value to use with nvim_del_augroup_by_id+                    Integer id of the created group.++                See also: ~+                    |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-                Create an autocmd.+                Create an autocommand |autocmd|. -                Examples:-                ��� event: ""pat1,pat2,pat3"",-                ��� event: ""pat1""-                ��� event: { ""pat1"" }-                ��� event: { ""pat1"", ""pat2"", ""pat3"" }+                The API allows for two types of actions to be executed+                (mutually exclusive) when the autocommand triggers: a callback+                function (Lua or Vimscript), or a command (like regular+                autocommands). -                Parameters: ~-                    {event}  The event or events to register this autocmd-                             Required keys: event: string | ArrayOf(string)+                Example using callback: >+                    -- Lua function+                    local myluafun = function() print(""This buffer enters"") end -                Parameters: ~-                    {opts}  Optional Parameters:-                            ��� callback: (string|function)-                              ��� (string): The name of the viml function to-                                execute when triggering this autocmd-                              ��� (function): The lua function to execute when-                                triggering this autocmd-                              ��� NOTE: Cannot be used with {command}+                    -- Vimscript function name (as a string)+                    local myvimfun = ""g:MyVimFunction"" -                            ��� command: (string) command-                              ��� vimscript command-                              ��� NOTE: Cannot be used with {callback} Eg.-                                command = ""let g:value_set = v:true""+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      callback = myluafun,  -- Or myvimfun+                    })+<++                Example using command: >+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      command = ""echo 'Entering a C or C++ file'"",+                    })+< -                            ��� pattern: (string|table)-                              ��� pattern or patterns to match against-                              ��� defaults to ""*"".-                              ��� NOTE: Cannot be used with {buffer}+                Example values for pattern: >+                  pattern = ""*.py""+                  pattern = { ""*.py"", ""*.pyi"" }+< -                            ��� buffer: (bufnr)-                              ��� create a |autocmd-buflocal| autocmd.-                              ��� NOTE: Cannot be used with {pattern}+                Examples values for event: >+                  event = ""BufPreWrite""+                  event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+< -                            ��� group: (string|int) The augroup name or id-                            ��� once: (boolean) - See |autocmd-once|-                            ��� nested: (boolean) - See |autocmd-nested|-                            ��� desc: (string) - Description of the autocmd+                Parameters: ~+                    {event}  (String|Array) The event or events to register+                             this autocmd+                    {opts}   Dictionary of autocommand options:+                             ��� group (string|integer) optional: the autocmd+                               group name or id to match against.+                             ��� pattern (string|array) optional: pattern or+                               patterns to match against |autocmd-pattern|.+                             ��� buffer (integer) optional: buffer number for+                               buffer local autocmds |autocmd-buflocal|.+                               Cannot be used with {pattern}.+                             ��� desc (string) optional: description of the+                               autocmd.+                             ��� callback (function|string) optional: Lua+                               function or Vim function (as string) to execute+                               on event. Cannot be used with {command}+                             ��� command (string) optional: Vim command to+                               execute on event Cannot be used with {callback}+                             ��� once (boolean) optional: defaults to false. Run+                               the autocmd only once |autocmd-once|.+                             ��� nested (boolean) optional: defaults to false.+                               Run nested autocmds |autocmd-nested|.++                Return: ~+                    Integer id of the created autocommand. -                Return: ~-                    opaque value to use with nvim_del_autocmd+                See also: ~+                    |autocmd|+                    |nvim_del_autocmd()|  nvim_del_augroup_by_id({id})                        *nvim_del_augroup_by_id()*-                Delete an augroup by {id}. {id} can only be returned when-                augroup was created with |nvim_create_augroup|.+                Delete an autocommand group by id. -                NOTE: behavior differs from augroup-delete.+                To get a group id one can use |nvim_get_autocmds()|. -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist -nvim_del_augroup_by_name({name})                  *nvim_del_augroup_by_name()*-                Delete an augroup by {name}.+                Parameters: ~+                    {id}  Integer The id of the augroup. -                NOTE: behavior differs from augroup-delete.+                See also: ~+                    |nvim_del_augroup_by_name()|+                    |nvim_create_augroup()| -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+nvim_del_augroup_by_name({name})                  *nvim_del_augroup_by_name()*+                Delete an autocommand group by name. -nvim_del_autocmd({id})                                    *nvim_del_autocmd()*-                Delete an autocmd by {id}. Autocmds only return IDs when-                created via the API. Will not error if called and no autocmds-                match the {id}.+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist.","```suggestion                NOTE: behavior differs from |augroup-delete|. When deleting a                group, autocommands contained in this group will also be                deleted and cleared. This group will no longer exist.```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,835234884,2022-03-25T12:43:32Z,runtime/doc/api.txt,"@@ -3152,129 +3152,203 @@ nvim_tabpage_set_var({tabpage}, {name}, {value}) Autocmd Functions                                                *api-autocmd*  nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*-                Create or get an augroup.+                Create or get an autocommand group |autocmd-groups|. -                To get an existing augroup ID, do: >-                    local id = vim.api.nvim_create_augroup(name, {+                To get an existing group id, do: >+                    local id = vim.api.nvim_create_augroup(""MyGroup"", {                         clear = false                     }) <                  Parameters: ~-                    {name}  String: The name of the augroup to create-                    {opts}  Parameters-                            ��� clear (bool): Whether to clear existing commands-                              or not. Defaults to true. See |autocmd-groups|+                    {name}  String: The name of the group+                    {opts}  Dictionary Parameters+                            ��� clear (bool) optional: defaults to true. Clear+                              existing commands if the group already exists+                              |autocmd-groups|.                  Return: ~-                    opaque value to use with nvim_del_augroup_by_id+                    Integer id of the created group.++                See also: ~+                    |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-                Create an autocmd.+                Create an autocommand |autocmd|. -                Examples:-                ��� event: ""pat1,pat2,pat3"",-                ��� event: ""pat1""-                ��� event: { ""pat1"" }-                ��� event: { ""pat1"", ""pat2"", ""pat3"" }+                The API allows for two types of actions to be executed+                (mutually exclusive) when the autocommand triggers: a callback+                function (Lua or Vimscript), or a command (like regular+                autocommands). -                Parameters: ~-                    {event}  The event or events to register this autocmd-                             Required keys: event: string | ArrayOf(string)+                Example using callback: >+                    -- Lua function+                    local myluafun = function() print(""This buffer enters"") end -                Parameters: ~-                    {opts}  Optional Parameters:-                            ��� callback: (string|function)-                              ��� (string): The name of the viml function to-                                execute when triggering this autocmd-                              ��� (function): The lua function to execute when-                                triggering this autocmd-                              ��� NOTE: Cannot be used with {command}+                    -- Vimscript function name (as a string)+                    local myvimfun = ""g:MyVimFunction"" -                            ��� command: (string) command-                              ��� vimscript command-                              ��� NOTE: Cannot be used with {callback} Eg.-                                command = ""let g:value_set = v:true""+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      callback = myluafun,  -- Or myvimfun+                    })+<++                Example using command: >+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      command = ""echo 'Entering a C or C++ file'"",+                    })+< -                            ��� pattern: (string|table)-                              ��� pattern or patterns to match against-                              ��� defaults to ""*"".-                              ��� NOTE: Cannot be used with {buffer}+                Example values for pattern: >+                  pattern = ""*.py""+                  pattern = { ""*.py"", ""*.pyi"" }+< -                            ��� buffer: (bufnr)-                              ��� create a |autocmd-buflocal| autocmd.-                              ��� NOTE: Cannot be used with {pattern}+                Examples values for event: >+                  event = ""BufPreWrite""+                  event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+< -                            ��� group: (string|int) The augroup name or id-                            ��� once: (boolean) - See |autocmd-once|-                            ��� nested: (boolean) - See |autocmd-nested|-                            ��� desc: (string) - Description of the autocmd+                Parameters: ~+                    {event}  (String|Array) The event or events to register+                             this autocmd+                    {opts}   Dictionary of autocommand options:+                             ��� group (string|integer) optional: the autocmd+                               group name or id to match against.+                             ��� pattern (string|array) optional: pattern or+                               patterns to match against |autocmd-pattern|.+                             ��� buffer (integer) optional: buffer number for+                               buffer local autocmds |autocmd-buflocal|.+                               Cannot be used with {pattern}.+                             ��� desc (string) optional: description of the+                               autocmd.+                             ��� callback (function|string) optional: Lua+                               function or Vim function (as string) to execute+                               on event. Cannot be used with {command}+                             ��� command (string) optional: Vim command to+                               execute on event Cannot be used with {callback}+                             ��� once (boolean) optional: defaults to false. Run+                               the autocmd only once |autocmd-once|.+                             ��� nested (boolean) optional: defaults to false.+                               Run nested autocmds |autocmd-nested|.++                Return: ~+                    Integer id of the created autocommand. -                Return: ~-                    opaque value to use with nvim_del_autocmd+                See also: ~+                    |autocmd|+                    |nvim_del_autocmd()|  nvim_del_augroup_by_id({id})                        *nvim_del_augroup_by_id()*-                Delete an augroup by {id}. {id} can only be returned when-                augroup was created with |nvim_create_augroup|.+                Delete an autocommand group by id. -                NOTE: behavior differs from augroup-delete.+                To get a group id one can use |nvim_get_autocmds()|. -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist -nvim_del_augroup_by_name({name})                  *nvim_del_augroup_by_name()*-                Delete an augroup by {name}.+                Parameters: ~+                    {id}  Integer The id of the augroup. -                NOTE: behavior differs from augroup-delete.+                See also: ~+                    |nvim_del_augroup_by_name()|+                    |nvim_create_augroup()| -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+nvim_del_augroup_by_name({name})                  *nvim_del_augroup_by_name()*+                Delete an autocommand group by name. -nvim_del_autocmd({id})                                    *nvim_del_autocmd()*-                Delete an autocmd by {id}. Autocmds only return IDs when-                created via the API. Will not error if called and no autocmds-                match the {id}.+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist.                  Parameters: ~-                    {id}  Integer The ID returned by nvim_create_autocmd+                    {name}  String The name of the augroup. -nvim_do_autocmd({event}, {*opts})                          *nvim_do_autocmd()*-                Do one autocmd.+                See also: ~+                    |autocommand-groups|++nvim_del_autocmd({id})                                    *nvim_del_autocmd()*+                Delete an autocommand by id.++                NOTE: Only autocommands created via the API have an id.                  Parameters: ~-                    {event}  The event or events to execute-                    {opts}   Optional Parameters:-                             ��� buffer (number) - buffer number-                               ��� NOTE: Cannot be used with {pattern}+                    {id}  Integer The id returned by nvim_create_autocmd -                             ��� pattern (string|table) - optional, defaults to-                               ""*"".-                               ��� NOTE: Cannot be used with {buffer}+                See also: ~+                    |nvim_create_autocmd()|++nvim_do_autocmd({event}, {*opts})                          *nvim_do_autocmd()*+                Execute an autocommand |autocmd-execute|.++                Parameters: ~+                    {event}  (String|Array) The event or events to execute+                    {opts}   Dictionary of autocommand options:+                             ��� group (string|integer) optional: the autocmd+                               group name or id to match against.+                               |autocmd-groups|.+                             ��� pattern (string|array) optional: defaults to+                               ""*"" |autocmd-pattern|.Cannot be used with","```suggestion                               ""*"" |autocmd-pattern|. Cannot be used with```",
2361214,clason,https://api.github.com/repos/neovim/neovim/pulls/17545,835235835,2022-03-25T12:44:55Z,runtime/doc/api.txt,"@@ -3152,129 +3152,203 @@ nvim_tabpage_set_var({tabpage}, {name}, {value}) Autocmd Functions                                                *api-autocmd*  nvim_create_augroup({name}, {*opts})                   *nvim_create_augroup()*-                Create or get an augroup.+                Create or get an autocommand group |autocmd-groups|. -                To get an existing augroup ID, do: >-                    local id = vim.api.nvim_create_augroup(name, {+                To get an existing group id, do: >+                    local id = vim.api.nvim_create_augroup(""MyGroup"", {                         clear = false                     }) <                  Parameters: ~-                    {name}  String: The name of the augroup to create-                    {opts}  Parameters-                            ��� clear (bool): Whether to clear existing commands-                              or not. Defaults to true. See |autocmd-groups|+                    {name}  String: The name of the group+                    {opts}  Dictionary Parameters+                            ��� clear (bool) optional: defaults to true. Clear+                              existing commands if the group already exists+                              |autocmd-groups|.                  Return: ~-                    opaque value to use with nvim_del_augroup_by_id+                    Integer id of the created group.++                See also: ~+                    |autocmd-groups|  nvim_create_autocmd({event}, {*opts})                  *nvim_create_autocmd()*-                Create an autocmd.+                Create an autocommand |autocmd|. -                Examples:-                ��� event: ""pat1,pat2,pat3"",-                ��� event: ""pat1""-                ��� event: { ""pat1"" }-                ��� event: { ""pat1"", ""pat2"", ""pat3"" }+                The API allows for two types of actions to be executed+                (mutually exclusive) when the autocommand triggers: a callback+                function (Lua or Vimscript), or a command (like regular+                autocommands). -                Parameters: ~-                    {event}  The event or events to register this autocmd-                             Required keys: event: string | ArrayOf(string)+                Example using callback: >+                    -- Lua function+                    local myluafun = function() print(""This buffer enters"") end -                Parameters: ~-                    {opts}  Optional Parameters:-                            ��� callback: (string|function)-                              ��� (string): The name of the viml function to-                                execute when triggering this autocmd-                              ��� (function): The lua function to execute when-                                triggering this autocmd-                              ��� NOTE: Cannot be used with {command}+                    -- Vimscript function name (as a string)+                    local myvimfun = ""g:MyVimFunction"" -                            ��� command: (string) command-                              ��� vimscript command-                              ��� NOTE: Cannot be used with {callback} Eg.-                                command = ""let g:value_set = v:true""+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      callback = myluafun,  -- Or myvimfun+                    })+<++                Example using command: >+                    vim.api.nvim_create_autocmd({+                      event = {""BufEnter"", ""BufWinEnter""},+                      pattern = {""*.c"", ""*.h""},+                      command = ""echo 'Entering a C or C++ file'"",+                    })+< -                            ��� pattern: (string|table)-                              ��� pattern or patterns to match against-                              ��� defaults to ""*"".-                              ��� NOTE: Cannot be used with {buffer}+                Example values for pattern: >+                  pattern = ""*.py""+                  pattern = { ""*.py"", ""*.pyi"" }+< -                            ��� buffer: (bufnr)-                              ��� create a |autocmd-buflocal| autocmd.-                              ��� NOTE: Cannot be used with {pattern}+                Examples values for event: >+                  event = ""BufPreWrite""+                  event = {""CursorHold"", ""BufPreWrite"", ""BufPostWrite""}+< -                            ��� group: (string|int) The augroup name or id-                            ��� once: (boolean) - See |autocmd-once|-                            ��� nested: (boolean) - See |autocmd-nested|-                            ��� desc: (string) - Description of the autocmd+                Parameters: ~+                    {event}  (String|Array) The event or events to register+                             this autocmd+                    {opts}   Dictionary of autocommand options:+                             ��� group (string|integer) optional: the autocmd+                               group name or id to match against.+                             ��� pattern (string|array) optional: pattern or+                               patterns to match against |autocmd-pattern|.+                             ��� buffer (integer) optional: buffer number for+                               buffer local autocmds |autocmd-buflocal|.+                               Cannot be used with {pattern}.+                             ��� desc (string) optional: description of the+                               autocmd.+                             ��� callback (function|string) optional: Lua+                               function or Vim function (as string) to execute+                               on event. Cannot be used with {command}+                             ��� command (string) optional: Vim command to+                               execute on event Cannot be used with {callback}+                             ��� once (boolean) optional: defaults to false. Run+                               the autocmd only once |autocmd-once|.+                             ��� nested (boolean) optional: defaults to false.+                               Run nested autocmds |autocmd-nested|.++                Return: ~+                    Integer id of the created autocommand. -                Return: ~-                    opaque value to use with nvim_del_autocmd+                See also: ~+                    |autocmd|+                    |nvim_del_autocmd()|  nvim_del_augroup_by_id({id})                        *nvim_del_augroup_by_id()*-                Delete an augroup by {id}. {id} can only be returned when-                augroup was created with |nvim_create_augroup|.+                Delete an autocommand group by id. -                NOTE: behavior differs from augroup-delete.+                To get a group id one can use |nvim_get_autocmds()|. -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist -nvim_del_augroup_by_name({name})                  *nvim_del_augroup_by_name()*-                Delete an augroup by {name}.+                Parameters: ~+                    {id}  Integer The id of the augroup. -                NOTE: behavior differs from augroup-delete.+                See also: ~+                    |nvim_del_augroup_by_name()|+                    |nvim_create_augroup()| -                When deleting an augroup, autocmds contained by this augroup-                will also be deleted and cleared. This augroup will no longer-                exist+nvim_del_augroup_by_name({name})                  *nvim_del_augroup_by_name()*+                Delete an autocommand group by name. -nvim_del_autocmd({id})                                    *nvim_del_autocmd()*-                Delete an autocmd by {id}. Autocmds only return IDs when-                created via the API. Will not error if called and no autocmds-                match the {id}.+                NOTE: behavior differs from |augroup-delete|. When deleting an+                augroup, autocmds contained by this augroup will also be+                deleted and cleared. This augroup will no longer exist.                  Parameters: ~-                    {id}  Integer The ID returned by nvim_create_autocmd+                    {name}  String The name of the augroup. -nvim_do_autocmd({event}, {*opts})                          *nvim_do_autocmd()*-                Do one autocmd.+                See also: ~+                    |autocommand-groups|++nvim_del_autocmd({id})                                    *nvim_del_autocmd()*+                Delete an autocommand by id.++                NOTE: Only autocommands created via the API have an id.                  Parameters: ~-                    {event}  The event or events to execute-                    {opts}   Optional Parameters:-                             ��� buffer (number) - buffer number-                               ��� NOTE: Cannot be used with {pattern}+                    {id}  Integer The id returned by nvim_create_autocmd -                             ��� pattern (string|table) - optional, defaults to-                               ""*"".-                               ��� NOTE: Cannot be used with {buffer}+                See also: ~+                    |nvim_create_autocmd()|++nvim_do_autocmd({event}, {*opts})                          *nvim_do_autocmd()*+                Execute an autocommand |autocmd-execute|.++                Parameters: ~+                    {event}  (String|Array) The event or events to execute+                    {opts}   Dictionary of autocommand options:+                             ��� group (string|integer) optional: the autocmd+                               group name or id to match against.+                               |autocmd-groups|.+                             ��� pattern (string|array) optional: defaults to+                               ""*"" |autocmd-pattern|.Cannot be used with+                               {buffer}+                             ��� buffer (integer) optional: buffer number+                               |autocmd-buflocal|. Cannot be used with+                               {pattern}.+                             ��� modeline (bool) optional: defaults to true.+                               Process the modeline after the autocommands+                               |<nomodeline>|. -                             ��� group (string|int) - autocmd group name or id-                             ��� modeline (boolean) - Default true, see-                               |<nomodeline>|+                See also: ~+                    |:doautocmd|  nvim_get_autocmds({*opts})                               *nvim_get_autocmds()*                 Get autocmds that match the requirements passed to {opts}. -                Parameters: ~-                    {opts}  Optional Parameters:-                            ��� event : Name or list of name of events to match-                              against-                            ��� group (string|int): Name or id of group to match-                              against-                            ��� pattern: Pattern or list of patterns to match-                              against. Cannot be used with {buffer}-                            ��� buffer: Buffer number or list of buffer numbers-                              for buffer local autocommands-                              |autocmd-buflocal|. Cannot be used with-                              {pattern}+                These examples will get autocommands matching ALL the given+                criteria: >+                  -- Matches all criteria+                  autocommands = vim.api.nvim_get_autocmds({+                    group = ""MyGroup"",+                    event = {""BufEnter"", ""BufWinEnter""},+                    pattern = {""*.c"", ""*.h""}+                  })++                  -- All commands from one group+                  autocommands = vim.api.nvim_get_autocmds({+                    group = ""MyGroup"",+                  })+< -                Return: ~-                    A list of autocmds that match+                NOTE: When multiple patterns or events are provided, if finds+                all autocommand that matches any combination of them.","```suggestion                NOTE: When multiple patterns or events are provided, will find                all autocommand that matches any combination of them.```",
33953936,dundargoc,https://api.github.com/repos/neovim/neovim/pulls/17863,835749778,2022-03-26T10:41:41Z,src/mpack/conv.c,"@@ -327,8 +327,6 @@ static mpack_value_t mpack_pack_ieee754(double v, unsigned mantbits,   double mant;    if (v == 0) {-    rv.lo = 0;","You mean pass as in the warning will disappear? Can't say for certain since the PVS list updates the next day, but I think that also should also work if you prefer it that way instead.",