user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/22317,1324948002,2023-09-13T19:03:42Z,server-spi/src/main/java/org/keycloak/theme/ThemeProperties.java,"@@ -0,0 +1,26 @@+/*+ * Copyright 2016 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.theme;++/**+ * Property keys for theme.properties files.+ */+public final class ThemeProperties {",I would avoid creating this class and move these constants to `org.keycloak.theme.Theme`. Not sure if we need another class to hold constants.In the `Theme` class there is an enum already for each theme type. That is why I think we can just add these constants there too as they are related to a theme.,x
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/8679,1324966925,2023-09-13T19:23:12Z,services/src/main/java/org/keycloak/services/managers/DefaultBruteForceProtector.java,"@@ -82,16 +85,58 @@ public ShutdownEvent() {     protected class FailedLogin extends LoginEvent {         protected final CountDownLatch latch = new CountDownLatch(1); -        public FailedLogin(String realmId, String userId, String ip) {-            super(realmId, userId, ip);+        public FailedLogin(String realmId, String userId, ClientConnection clientConnection) {+            super(realmId, userId, clientConnection);         }     }      protected class SuccessfulLogin extends LoginEvent {         protected final CountDownLatch latch = new CountDownLatch(1); -        public SuccessfulLogin(String realmId, String userId, String ip) {-            super(realmId, userId, ip);+        public SuccessfulLogin(String realmId, String userId, ClientConnection clientConnection) {+            super(realmId, userId, clientConnection);+        }+    }++    protected static class AdaptedClientConnection implements ClientConnection {",Could you please elaborate on why we need to copy values from client connection to instances of this class?Is it related to using it from the background task and making sure the information is kept even though the request has ended?Perhaps we could just have those fields in the `LoginEvent` itself rather than create a new class to just store them.,x
642289,douglaspalmer,https://api.github.com/repos/keycloak/keycloak/pulls/8679,1325062755,2023-09-13T20:47:21Z,services/src/main/java/org/keycloak/services/managers/DefaultBruteForceProtector.java,"@@ -82,16 +85,58 @@ public ShutdownEvent() {     protected class FailedLogin extends LoginEvent {         protected final CountDownLatch latch = new CountDownLatch(1); -        public FailedLogin(String realmId, String userId, String ip) {-            super(realmId, userId, ip);+        public FailedLogin(String realmId, String userId, ClientConnection clientConnection) {+            super(realmId, userId, clientConnection);         }     }      protected class SuccessfulLogin extends LoginEvent {         protected final CountDownLatch latch = new CountDownLatch(1); -        public SuccessfulLogin(String realmId, String userId, String ip) {-            super(realmId, userId, ip);+        public SuccessfulLogin(String realmId, String userId, ClientConnection clientConnection) {+            super(realmId, userId, clientConnection);+        }+    }++    protected static class AdaptedClientConnection implements ClientConnection {",I'm guessing they want the additional data for their SPI to email users. The rest of the PR seems to only read the remote address.,
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/23221,1325704449,2023-09-14T09:53:40Z,services/src/main/java/org/keycloak/services/HttpRequestImpl.java,"@@ -61,8 +65,19 @@ public MultivaluedMap<String, String> getDecodedFormParameters() {         }         MediaType mediaType = getHttpHeaders().getMediaType();         if (mediaType == null || !mediaType.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded""))) {-            return new MultivaluedHashMap<>();+            throw new BadRequestException(""MediaType is not compatible"");+        } +        +        String charsetName = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);+        +        if(charsetName != null) {+            try {+                Charset.isSupported(charsetName);+            } catch (Exception e) {+                throw new BadRequestException(""Charset "" + charsetName +"" is not supported"");+            }         }+                 return delegate.getDecodedFormParameters();","As we should probably also try/catch the `getDecodedFormParameters` call I would save the charset check completely. What do you think about doing the try/catch around the return and creating something like `new BadRequestException(""Incorrect form parameters: "" + e.getMessage(), e)`? I think we cover this particular error and other possible exceptions.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22148,1325715375,2023-09-14T10:02:36Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/AllowedWebOriginsProtocolMapper.java,"@@ -37,13 +37,16 @@  *  * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>  */-public class AllowedWebOriginsProtocolMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper {+public class AllowedWebOriginsProtocolMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper, TokenIntrospectionTokenMapper {      private static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();       public static final String PROVIDER_ID = ""oidc-allowed-origins-mapper""; +    static {+        OIDCAttributeMapperHelper.addIncludeInTokensConfig(configProperties, AllowedWebOriginsProtocolMapper.class);","There is similar issue like in `AbstractPairwiseSubMapper`. This PR introduces options `Add to access token` in addition to `Add to introspection endpoint` . When I am creating new mapper, they are both ON by default, which is OKHowever I think that when migrating from previous version, those are OFF currently in your PR, which is incorrect.Moreover, when I start Keycloak from scratch, I see that built-in protocol mapper `allowed web origins` in the built-in client scope `web-origins` has both switches OFF by default, which is incorrect.We need to make sure that behaviour is backwards compatible with previous version.I think that we need both switches (as we need to have a way to remove `web-origins` from access token).So it seems we will need to have some ""migration"" script, which will make sure that `Add to access token` and `Add to introspection endpoint ` are ON by default after migration",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22148,1325718472,2023-09-14T10:05:26Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/AudienceResolveProtocolMapper.java,"@@ -38,10 +38,12 @@  *  * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>  */-public class AudienceResolveProtocolMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper {+public class AudienceResolveProtocolMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper, TokenIntrospectionTokenMapper {      private static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();-+    static {+        OIDCAttributeMapperHelper.addIncludeInTokensConfig(configProperties, AudienceResolveProtocolMapper.class);","There is same issue like in `AllowedWebOriginsProtocolMapper`.The built-in protocol mapper `audience resolve` in the built-in client scope `roles` has both switches OFF by default, which is incorrect (similar issue like for client scope `web-origins` and it's mapper `allowed web origins`)We need to make sure that behaviour is backwards compatible with previous version.I think that we need both switches (as we need to have a way to remove audience from access token).So it seems we will need to have some ""migration"" script, which will make sure that Add to access token and Add to introspection endpoint are ON by default after migration",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/23203,1326062138,2023-09-14T14:40:53Z,saml-core/src/main/java/org/keycloak/saml/processing/core/util/XMLEncryptionUtil.java,"@@ -252,27 +253,25 @@ public static Element decryptElementInDocument(Document documentWithEncryptedEle         if (encDataElement == null)             throw logger.domMissingElementError(""No element representing the encrypted data found""); -        // Look at siblings for the key-        Element encKeyElement = getNextElementNode(encDataElement.getNextSibling());-        if (encKeyElement == null) {-            // Search the enc data element for enc key-            NodeList nodeList = encDataElement.getElementsByTagNameNS(EncryptionConstants.EncryptionSpecNS, EncryptionConstants._TAG_ENCRYPTEDKEY);--            if (nodeList == null || nodeList.getLength() == 0)-                throw logger.nullValueError(""Encrypted Key not found in the enc data"");--            encKeyElement = (Element) nodeList.item(0);-        }-         XMLCipher cipher;         EncryptedData encryptedData;         EncryptedKey encryptedKey;         try {             cipher = XMLCipher.getInstance();             cipher.init(XMLCipher.DECRYPT_MODE, null);             encryptedData = cipher.loadEncryptedData(documentWithEncryptedElement, encDataElement);-            encryptedKey = cipher.loadEncryptedKey(documentWithEncryptedElement, encKeyElement);-        } catch (XMLEncryptionException e1) {+            if (encryptedData.getKeyInfo() == null) {+                throw logger.domMissingElementError(""No element representing KeyInfo found in the EncryptedData"");+            }++            encryptedKey = encryptedData.getKeyInfo().itemEncryptedKey(0);","If KeyInfo is null there is an exception in the previous line. Currently the KeyInfo is not optional for decrypting a symmetric key, it should contain the EncryptionKey or (in case of Okta, the RetrievalMethod to point to another place where the EncryptionKey is). If it's empty there is no secret key to decrypt and we cannot proceed. The same is also checked inside [SAMLDecryptionKeysLocator](https://github.com/keycloak/keycloak/blob/22.0.3/services/src/main/java/org/keycloak/protocol/saml/SAMLDecryptionKeysLocator.java#L115-L118). So I think we are safe, a exception was thrown before this commit too. Maybe when we support more encryption types this changes, but I think we are safe for now.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/23259,1326339809,2023-09-14T18:01:08Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/services/resources/QuarkusWelcomeResource.java,"@@ -16,209 +16,24 @@  */ package org.keycloak.quarkus.runtime.services.resources; -import org.jboss.logging.Logger;-import org.keycloak.common.ClientConnection;-import org.keycloak.common.Profile;-import org.keycloak.common.Version;-import org.keycloak.common.util.Base64Url;-import org.keycloak.common.util.MimeTypeUtil;-import org.keycloak.common.util.SecretGenerator;-import org.keycloak.http.HttpRequest;-import org.keycloak.models.KeycloakSession; import org.keycloak.quarkus.runtime.configuration.Configuration;-import org.keycloak.services.ForbiddenException;-import org.keycloak.services.ServicesLogger;-import org.keycloak.services.managers.ApplianceBootstrap;-import org.keycloak.services.util.CacheControlUtil;-import org.keycloak.services.util.CookieHelper;-import org.keycloak.theme.Theme;-import org.keycloak.theme.freemarker.FreeMarkerProvider;-import org.keycloak.urls.UrlType;-import org.keycloak.utils.MediaType;+import org.keycloak.services.resources.WelcomeResource; -import io.quarkus.logging.Log;--import jakarta.ws.rs.Consumes;-import jakarta.ws.rs.GET;-import jakarta.ws.rs.POST; import jakarta.ws.rs.Path;-import jakarta.ws.rs.PathParam;-import jakarta.ws.rs.Produces;-import jakarta.ws.rs.WebApplicationException;-import jakarta.ws.rs.core.Context;-import jakarta.ws.rs.core.Cookie;-import jakarta.ws.rs.core.HttpHeaders;-import jakarta.ws.rs.core.MultivaluedMap;-import jakarta.ws.rs.core.Response;-import jakarta.ws.rs.core.Response.ResponseBuilder;-import jakarta.ws.rs.core.Response.Status;-import java.io.IOException;-import java.io.InputStream;-import java.net.InetAddress;-import java.net.URI;-import java.net.URISyntaxException;-import java.net.UnknownHostException;-import java.util.HashMap;-import java.util.Map;-import java.util.Objects;-import java.util.concurrent.atomic.AtomicBoolean;  /**  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>  */ @Path(""/"")-public class QuarkusWelcomeResource {--    private static final Logger logger = Logger.getLogger(QuarkusWelcomeResource.class);-    private static final String KEYCLOAK_STATE_CHECKER = ""WELCOME_STATE_CHECKER"";--    private AtomicBoolean shouldBootstrap;--    @Context-    KeycloakSession session;--    /**-     * Welcome page of Keycloak-     */-    @GET-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getWelcomePage() throws URISyntaxException {-        String requestUri = session.getContext().getUri().getRequestUri().toString();-        if (!requestUri.endsWith(""/"")) {-            return Response.seeOther(new URI(requestUri + ""/"")).build();-        } else {-            return createWelcomePage(null, null);-        }-    }--    @POST-    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response createUser() {-        HttpRequest request = session.getContext().getHttpRequest();-        MultivaluedMap<String, String> formData = request.getDecodedFormParameters();--        if (!shouldBootstrap()) {-            return createWelcomePage(null, null);-        } else {-            if (!isLocal()) {-                ServicesLogger.LOGGER.rejectedNonLocalAttemptToCreateInitialUser(session.getContext().getConnection().getRemoteAddr());-                throw new WebApplicationException(Response.Status.BAD_REQUEST);-            }--            csrfCheck(formData);--            String username = formData.getFirst(""username"");-            String password = formData.getFirst(""password"");-            String passwordConfirmation = formData.getFirst(""passwordConfirmation"");--            if (username != null) {-                username = username.trim();-            }--            if (username == null || username.length() == 0) {-                return createWelcomePage(null, ""Username is missing"");-            }--            if (password == null || password.length() == 0) {-                return createWelcomePage(null, ""Password is missing"");-            }--            if (!password.equals(passwordConfirmation)) {-                return createWelcomePage(null, ""Password and confirmation doesn't match"");-            }--            expireCsrfCookie();--            ApplianceBootstrap applianceBootstrap = new ApplianceBootstrap(session);-            applianceBootstrap.createMasterRealmUser(username, password);--            shouldBootstrap.set(false);-            ServicesLogger.LOGGER.createdInitialAdminUser(username);-            return createWelcomePage(""User created"", null);-        }-    }--    /**-     * Resources for welcome page-     */-    @GET-    @Path(""/welcome-content/{path}"")-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getResource(@PathParam(""path"") String path) {-        try {-            InputStream resource = getTheme().getResourceAsStream(path);-            if (resource != null) {-                String contentType = MimeTypeUtil.getContentType(path);-                Response.ResponseBuilder builder = Response.ok(resource).type(contentType).cacheControl(CacheControlUtil.getDefaultCacheControl());-                return builder.build();-            } else {-                return Response.status(Response.Status.NOT_FOUND).build();-            }-        } catch (IOException e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }-    }--    private Response createWelcomePage(String successMessage, String errorMessage) {-        try {-            Theme theme = getTheme();--            if(Objects.isNull(theme)) {-                Log.error(""Theme is null please check the \""--spi-theme-default\"" parameter"");-                errorMessage = ""The theme is null"";-                ResponseBuilder rb = Response.status(Status.BAD_REQUEST)-                        .entity(errorMessage)-                        .cacheControl(CacheControlUtil.noCache());-                return rb.build();-            }--            Map<String, Object> map = new HashMap<>();--            map.put(""adminConsoleEnabled"", isAdminConsoleEnabled());-            map.put(""productName"", Version.NAME);--            map.put(""properties"", theme.getProperties());-            map.put(""adminUrl"", session.getContext().getUri(UrlType.ADMIN).getBaseUriBuilder().path(""/admin/"").build());--            map.put(""resourcesPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/"" + theme.getType().toString().toLowerCase() +""/"" + theme.getName());-            map.put(""resourcesCommonPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/common/keycloak"");+public class QuarkusWelcomeResource extends WelcomeResource { -            boolean bootstrap = shouldBootstrap();-            map.put(""bootstrap"", bootstrap);-            if (bootstrap) {-                boolean isLocal = isLocal();-                map.put(""localUser"", isLocal);--                String localAdminUrl = getLocalAdminUrl();--                map.put(""localAdminUrl"", localAdminUrl);-                map.put(""adminUserCreationMessage"", ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"");--                if (isLocal) {-                    String stateChecker = setCsrfCookie();-                    map.put(""stateChecker"", stateChecker);-                }-            }-            if (successMessage != null) {-                map.put(""successMessage"", successMessage);-            }-            if (errorMessage != null) {-                map.put(""errorMessage"", errorMessage);-            }-            FreeMarkerProvider freeMarkerUtil = session.getProvider(FreeMarkerProvider.class);-            String result = freeMarkerUtil.processTemplate(map, ""index.ftl"", theme);--            ResponseBuilder rb = Response.status(errorMessage == null ? Status.OK : Status.BAD_REQUEST)-                    .entity(result)-                    .cacheControl(CacheControlUtil.noCache());-            return rb.build();-        } catch (Exception e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }+    @Override+    protected String getAdminCreationMessage() {",I think we can change the message on `WelcomeResource` and remove more code from this class. The message from `WelcomeResource` does not make sense anymore.,x
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/23259,1326386963,2023-09-14T18:47:21Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/services/resources/QuarkusWelcomeResource.java,"@@ -16,209 +16,24 @@  */ package org.keycloak.quarkus.runtime.services.resources; -import org.jboss.logging.Logger;-import org.keycloak.common.ClientConnection;-import org.keycloak.common.Profile;-import org.keycloak.common.Version;-import org.keycloak.common.util.Base64Url;-import org.keycloak.common.util.MimeTypeUtil;-import org.keycloak.common.util.SecretGenerator;-import org.keycloak.http.HttpRequest;-import org.keycloak.models.KeycloakSession; import org.keycloak.quarkus.runtime.configuration.Configuration;-import org.keycloak.services.ForbiddenException;-import org.keycloak.services.ServicesLogger;-import org.keycloak.services.managers.ApplianceBootstrap;-import org.keycloak.services.util.CacheControlUtil;-import org.keycloak.services.util.CookieHelper;-import org.keycloak.theme.Theme;-import org.keycloak.theme.freemarker.FreeMarkerProvider;-import org.keycloak.urls.UrlType;-import org.keycloak.utils.MediaType;+import org.keycloak.services.resources.WelcomeResource; -import io.quarkus.logging.Log;--import jakarta.ws.rs.Consumes;-import jakarta.ws.rs.GET;-import jakarta.ws.rs.POST; import jakarta.ws.rs.Path;-import jakarta.ws.rs.PathParam;-import jakarta.ws.rs.Produces;-import jakarta.ws.rs.WebApplicationException;-import jakarta.ws.rs.core.Context;-import jakarta.ws.rs.core.Cookie;-import jakarta.ws.rs.core.HttpHeaders;-import jakarta.ws.rs.core.MultivaluedMap;-import jakarta.ws.rs.core.Response;-import jakarta.ws.rs.core.Response.ResponseBuilder;-import jakarta.ws.rs.core.Response.Status;-import java.io.IOException;-import java.io.InputStream;-import java.net.InetAddress;-import java.net.URI;-import java.net.URISyntaxException;-import java.net.UnknownHostException;-import java.util.HashMap;-import java.util.Map;-import java.util.Objects;-import java.util.concurrent.atomic.AtomicBoolean;  /**  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>  */ @Path(""/"")-public class QuarkusWelcomeResource {--    private static final Logger logger = Logger.getLogger(QuarkusWelcomeResource.class);-    private static final String KEYCLOAK_STATE_CHECKER = ""WELCOME_STATE_CHECKER"";--    private AtomicBoolean shouldBootstrap;--    @Context-    KeycloakSession session;--    /**-     * Welcome page of Keycloak-     */-    @GET-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getWelcomePage() throws URISyntaxException {-        String requestUri = session.getContext().getUri().getRequestUri().toString();-        if (!requestUri.endsWith(""/"")) {-            return Response.seeOther(new URI(requestUri + ""/"")).build();-        } else {-            return createWelcomePage(null, null);-        }-    }--    @POST-    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response createUser() {-        HttpRequest request = session.getContext().getHttpRequest();-        MultivaluedMap<String, String> formData = request.getDecodedFormParameters();--        if (!shouldBootstrap()) {-            return createWelcomePage(null, null);-        } else {-            if (!isLocal()) {-                ServicesLogger.LOGGER.rejectedNonLocalAttemptToCreateInitialUser(session.getContext().getConnection().getRemoteAddr());-                throw new WebApplicationException(Response.Status.BAD_REQUEST);-            }--            csrfCheck(formData);--            String username = formData.getFirst(""username"");-            String password = formData.getFirst(""password"");-            String passwordConfirmation = formData.getFirst(""passwordConfirmation"");--            if (username != null) {-                username = username.trim();-            }--            if (username == null || username.length() == 0) {-                return createWelcomePage(null, ""Username is missing"");-            }--            if (password == null || password.length() == 0) {-                return createWelcomePage(null, ""Password is missing"");-            }--            if (!password.equals(passwordConfirmation)) {-                return createWelcomePage(null, ""Password and confirmation doesn't match"");-            }--            expireCsrfCookie();--            ApplianceBootstrap applianceBootstrap = new ApplianceBootstrap(session);-            applianceBootstrap.createMasterRealmUser(username, password);--            shouldBootstrap.set(false);-            ServicesLogger.LOGGER.createdInitialAdminUser(username);-            return createWelcomePage(""User created"", null);-        }-    }--    /**-     * Resources for welcome page-     */-    @GET-    @Path(""/welcome-content/{path}"")-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getResource(@PathParam(""path"") String path) {-        try {-            InputStream resource = getTheme().getResourceAsStream(path);-            if (resource != null) {-                String contentType = MimeTypeUtil.getContentType(path);-                Response.ResponseBuilder builder = Response.ok(resource).type(contentType).cacheControl(CacheControlUtil.getDefaultCacheControl());-                return builder.build();-            } else {-                return Response.status(Response.Status.NOT_FOUND).build();-            }-        } catch (IOException e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }-    }--    private Response createWelcomePage(String successMessage, String errorMessage) {-        try {-            Theme theme = getTheme();--            if(Objects.isNull(theme)) {-                Log.error(""Theme is null please check the \""--spi-theme-default\"" parameter"");-                errorMessage = ""The theme is null"";-                ResponseBuilder rb = Response.status(Status.BAD_REQUEST)-                        .entity(errorMessage)-                        .cacheControl(CacheControlUtil.noCache());-                return rb.build();-            }--            Map<String, Object> map = new HashMap<>();--            map.put(""adminConsoleEnabled"", isAdminConsoleEnabled());-            map.put(""productName"", Version.NAME);--            map.put(""properties"", theme.getProperties());-            map.put(""adminUrl"", session.getContext().getUri(UrlType.ADMIN).getBaseUriBuilder().path(""/admin/"").build());--            map.put(""resourcesPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/"" + theme.getType().toString().toLowerCase() +""/"" + theme.getName());-            map.put(""resourcesCommonPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/common/keycloak"");+public class QuarkusWelcomeResource extends WelcomeResource { -            boolean bootstrap = shouldBootstrap();-            map.put(""bootstrap"", bootstrap);-            if (bootstrap) {-                boolean isLocal = isLocal();-                map.put(""localUser"", isLocal);--                String localAdminUrl = getLocalAdminUrl();--                map.put(""localAdminUrl"", localAdminUrl);-                map.put(""adminUserCreationMessage"", ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"");--                if (isLocal) {-                    String stateChecker = setCsrfCookie();-                    map.put(""stateChecker"", stateChecker);-                }-            }-            if (successMessage != null) {-                map.put(""successMessage"", successMessage);-            }-            if (errorMessage != null) {-                map.put(""errorMessage"", errorMessage);-            }-            FreeMarkerProvider freeMarkerUtil = session.getProvider(FreeMarkerProvider.class);-            String result = freeMarkerUtil.processTemplate(map, ""index.ftl"", theme);--            ResponseBuilder rb = Response.status(errorMessage == null ? Status.OK : Status.BAD_REQUEST)-                    .entity(result)-                    .cacheControl(CacheControlUtil.noCache());-            return rb.build();-        } catch (Exception e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }+    @Override+    protected String getAdminCreationMessage() {+        return ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"";     } -    private String getLocalAdminUrl() {+    @Override+    protected String getLocalAdminUrl() {","I think we can remove this method too and then finally remove the class. For that, we can add a URL type `org.keycloak.urls.UrlType.LOCAL_ADMIN` and resolve this URL from the hostname provider itself.If you want I can give it a try.@stianst wdyt?",x
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1326908381,2023-09-15T07:28:34Z,model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java,"@@ -634,7 +657,14 @@ public KeycloakSession getKeycloakSession() {         session.users().preRemove(realm, group);          realm.removeDefaultGroup(group);-        group.getSubGroupsStream().forEach(realm::removeGroup);++        // TODO: this batch size could potentially be stored somewhere (config?) as a variable+        // calculate out batches of subgroups to delete from the parent group to avoid grinding the server to a halt at large scale+        // especially helpful for freeing up some amount of database time for other requests+        long batches = (long) Math.ceil(session.groups().getSubGroupsCount(realm, group.getId()) / 1000.0);","I'm not a fan of calculating the number of batches beforehand - with ""read committed"" isolation, the items listed can change in a concurrent setup, so I'd prefer to loop until the result is empty. I wonder if you've added `em.flush()` and the batching here to avoid performance problems. Calling `em.flush()` will write the changes to the current database transaction, still the entities will remain the Hibernate persistence context. Usually the large persistence context causes problems in performance, and only calling `em.flush()` doesn't solve this. Whenever one selects data from the database, a `em.flush()` is called anyway, so there is no need to call it here again IMHO.There is currently no good solution to deletion and batching available. I could imagine an async deletion of groups, that would iteratively create a group and the subgroups in a background task, but that would require more thoughts and would be out-of-scope for this.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/23221,1326934337,2023-09-15T07:53:26Z,services/src/main/java/org/keycloak/services/HttpRequestImpl.java,"@@ -61,8 +65,19 @@ public MultivaluedMap<String, String> getDecodedFormParameters() {         }         MediaType mediaType = getHttpHeaders().getMediaType();         if (mediaType == null || !mediaType.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded""))) {-            return new MultivaluedHashMap<>();+            throw new BadRequestException(""MediaType is not compatible"");+        } +        +        String charsetName = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);+        +        if(charsetName != null) {+            try {+                Charset.isSupported(charsetName);+            } catch (Exception e) {+                throw new BadRequestException(""Charset "" + charsetName +"" is not supported"");+            }         }+                 return delegate.getDecodedFormParameters();","I think the charset is going to be OK 99.99% of the times. Reasteasy is also checking the charset so I was thinking in saving that time, delete the check completely and just use the general catch later. The message will be something like: `Incorrect form parameters: java.io.UnsupportedEncodingException: 'utf-8'`.  It could be better but that's not our fault. WDYT?",
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1327002227,2023-09-15T08:50:43Z,model/legacy-private/src/main/java/org/keycloak/storage/GroupStorageManager.java,"@@ -80,6 +80,15 @@ public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String se          return Stream.concat(local, ext);     }++    @Override+    public Stream<GroupModel> searchForSubgroupsByParentIdNameStream(RealmModel realm, String id, String search, Integer firstResult, Integer maxResults) {+        Stream<GroupModel> local = localStorage().searchForSubgroupsByParentIdNameStream(realm, id, search, firstResult, maxResults);+        // TODO: not really sure if this is actually external or internal behavior... need to learn more about what's going on with this steorage manager class and legacy providers+        Stream<GroupModel> ext = flatMapEnabledStorageProvidersWithTimeout(realm, GroupLookupProvider.class, p -> p.searchForSubgroupsByParentIdNameStream(realm, id, search, firstResult, maxResults));+        return Stream.concat(local, ext);","Nice catch @ahus1! It probably won't. We would need to introduce something similar to this: https://github.com/keycloak/keycloak/blob/3a3df50f74e7e598e89c6b739c50e6122faad09f/model/legacy-private/src/main/java/org/keycloak/storage/UserStorageManager.java#L219-L309 to GroupStorageManager.Maybe we can do it as a follow-up though, as this behavior is already broken in other methods.",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327125042,2023-09-15T10:47:43Z,operator/src/test/java/org/keycloak/operator/testsuite/unit/IngressLogicTest.java,"@@ -204,17 +212,30 @@ public void testUpdateCustomAnnotation() {      @Test     public void testIngressSpecDefinedWithoutClassName() {-        var kc = new MockKeycloakIngress(true, new IngressSpec());+        var kc = new MockKeycloakIngress(getKeycloak(true, new IngressSpec()));         Optional<HasMetadata> reconciled = kc.getReconciledResource();         Ingress ingress = reconciled.map(Ingress.class::cast).orElseThrow();         assertNull(ingress.getSpec().getIngressClassName());     }      @Test     public void testIngressSpecDefinedWithClassName() {-        var kc = new MockKeycloakIngress(true, new IngressSpecBuilder().withIngressClassName(""my-class"").build());+        var kc = new MockKeycloakIngress(getKeycloak(true, new IngressSpecBuilder().withIngressClassName(""my-class"").build()));         Optional<HasMetadata> reconciled = kc.getReconciledResource();         Ingress ingress = reconciled.map(Ingress.class::cast).orElseThrow();         assertEquals(""my-class"", ingress.getSpec().getIngressClassName());     }++    @Test+    public void testOpenShiftIngressWithGeneratedHostname() {+        Keycloak kc = getKeycloak(false, new IngressSpecBuilder().withIngressClassName(""openshift-default"").build());+        kc.getSpec().getHostnameSpec().setHostname(null);+        var mock = new MockKeycloakIngress(kc);+        Mockito.when(mock.getContext().getSecondaryResource(io.fabric8.openshift.api.model.config.v1.Ingress.class))+                .thenReturn(Optional.of(new IngressBuilder().withNewSpec().withDomain(""openshift.com"").endSpec().build()));",Mockito is ok but only as a temporary solution until we figure out #21855. I'd like to get rid of it and test actual OCP API as soon as possible.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327129371,2023-09-15T10:52:43Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakIngressDependentResource.java,"@@ -105,14 +106,27 @@ public Ingress desired(Keycloak keycloak, Context<Keycloak> context) {                 .endSpec()                 .build(); -        final var hostnameSpec = keycloak.getSpec().getHostnameSpec();-        if (hostnameSpec != null && hostnameSpec.getHostname() != null) {-            ingress.getSpec().getRules().get(0).setHost(hostnameSpec.getHostname());-        }+        getHostname(keycloak, context).ifPresent(hostname -> ingress.getSpec().getRules().get(0).setHost(hostname));          return ingress;     } +    public static Optional<String> getHostname(Keycloak keycloak, Context<Keycloak> context) {+        return Optional.ofNullable(keycloak.getSpec().getHostnameSpec()).map(HostnameSpec::getHostname)+                .or(() -> Optional.ofNullable(keycloak.getSpec().getIngressSpec()).filter(is -> ""openshift-default"".equals(is.getIngressClassName()))+                        .flatMap(is -> getAppsDomain(context).map(s -> String.format(""%s-%s.%s"", getName(keycloak),+                                KeycloakServiceDependentResource.getServiceName(keycloak), s))));+    }++    public static Optional<String> getAppsDomain(Context<Keycloak> context) {+        try {+            return context.getSecondaryResource(io.fabric8.openshift.api.model.config.v1.Ingress.class)+                    .map(i -> Optional.ofNullable(i.getSpec().getAppsDomain()).orElse(i.getSpec().getDomain()));+        } catch (IllegalArgumentException e) {+            return Optional.empty();+        }+    }",This is quite hard to read and debug. I'd suggest using a bit less lambda expressions. I'd rather have here a bit longer code with some `if`s that's easy to read/debug/maintain than a compact and hard to read code.,x
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22148,1327140142,2023-09-15T11:04:38Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oidc/LightWeightAccessTokenMapperTest.java,"@@ -0,0 +1,521 @@+package org.keycloak.testsuite.oidc;++import jakarta.ws.rs.NotFoundException;+import org.junit.Before;+import org.junit.Test;+import org.keycloak.admin.client.resource.ClientScopeResource;+import org.keycloak.admin.client.resource.ProtocolMappersResource;+import org.keycloak.admin.client.resource.RealmResource;+import org.keycloak.common.Profile;+import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.utils.ModelToRepresentation;+import org.keycloak.protocol.oidc.OIDCLoginProtocol;+import org.keycloak.protocol.oidc.mappers.AudienceProtocolMapper;+import org.keycloak.protocol.oidc.mappers.GroupMembershipMapper;+import org.keycloak.protocol.oidc.mappers.HardcodedClaim;+import org.keycloak.protocol.oidc.mappers.HardcodedRole;+import org.keycloak.protocol.oidc.mappers.OIDCAttributeMapperHelper;+import org.keycloak.protocol.oidc.mappers.RoleNameMapper;+import org.keycloak.protocol.oidc.mappers.SHA256PairwiseSubMapper;+import org.keycloak.protocol.oidc.mappers.UserSessionNoteMapper;+import org.keycloak.representations.AccessToken;+import org.keycloak.representations.idm.ClientRepresentation;+import org.keycloak.representations.idm.ProtocolMapperRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.testsuite.AbstractKeycloakTest;+import org.keycloak.testsuite.admin.ApiUtil;+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;+import org.keycloak.testsuite.util.ClientManager;+import org.keycloak.testsuite.util.KeycloakModelUtils;+import org.keycloak.testsuite.util.OAuthClient;+import org.keycloak.testsuite.util.ProtocolMapperUtil;+import org.keycloak.util.JsonSerialization;+import org.wildfly.common.Assert;++import java.io.IOException;+import java.util.ArrayList;+import java.util.Arrays;+import java.util.HashMap;+import java.util.List;+import java.util.Map;++import static org.keycloak.protocol.ProtocolMapperUtils.USER_SESSION_NOTE;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.ACR;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.ACR_SCOPE;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.ADDRESS;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.ALLOWED_WEB_ORIGINS;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.AUDIENCE_RESOLVE;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.CLIENT_ROLES;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.EMAIL;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.EMAIL_VERIFIED;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.FAMILY_NAME;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.FULL_NAME;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.GIVEN_NAME;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.PROFILE_CLAIM;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.REALM_ROLES;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.ROLES_SCOPE;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.USERNAME;+import static org.keycloak.protocol.oidc.OIDCLoginProtocolFactory.WEB_ORIGINS_SCOPE;+import static org.keycloak.protocol.oidc.mappers.AbstractPairwiseSubMapper.PROVIDER_ID_SUFFIX;+import static org.keycloak.protocol.oidc.mappers.AudienceProtocolMapper.INCLUDED_CLIENT_AUDIENCE;+import static org.keycloak.protocol.oidc.mappers.HardcodedClaim.CLAIM_VALUE;+import static org.keycloak.protocol.oidc.mappers.LightWeightAccessTokenMapper.EXCLUDE_FROM_ACCESS_TOKEN;+import static org.keycloak.protocol.oidc.mappers.LightWeightAccessTokenMapper.LIGHT_WEIGHT_ACCESS_TOKEN_PROVIDER_ID;+import static org.keycloak.protocol.oidc.mappers.OIDCAttributeMapperHelper.INCLUDE_IN_ACCESS_TOKEN;+import static org.keycloak.protocol.oidc.mappers.OIDCAttributeMapperHelper.INCLUDE_IN_INTROSPECTION;+import static org.keycloak.protocol.oidc.mappers.PairwiseSubMapperHelper.PAIRWISE_SUB_ALGORITHM_SALT;+import static org.keycloak.protocol.oidc.mappers.RoleNameMapper.NEW_ROLE_NAME;+import static org.keycloak.protocol.oidc.mappers.RoleNameMapper.ROLE_CONFIG;+import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson;+import static org.keycloak.testsuite.auth.page.AuthRealm.TEST;++@EnableFeature(value = Profile.Feature.TOKEN_EXCHANGE, skipRestart = true)+@EnableFeature(value = Profile.Feature.LIGHT_WEIGHT_ACCESS_TOKEN, skipRestart = true)+public class LightWeightAccessTokenMapperTest extends AbstractKeycloakTest {++    @Before+    public void clientConfiguration() {+        ClientManager.realm(adminClient.realm(""test"")).clientId(""test-app"").directAccessGrant(true).setServiceAccountsEnabled(true);+        ClientManager.realm(adminClient.realm(""test"")).clientId(""resource-server"").directAccessGrant(true);+    }++    @Override+    public void addTestRealms(List<RealmRepresentation> testRealms) {+        RealmRepresentation realm = loadJson(getClass().getResourceAsStream(""/testrealm.json""), RealmRepresentation.class);+        ClientRepresentation confApp = KeycloakModelUtils.createClient(realm, ""resource-server"");+        confApp.setSecret(""password"");+        confApp.setServiceAccountsEnabled(Boolean.TRUE);+        testRealms.add(realm);+    }++    @Test+    public void accessTokenFalseIntrospectionTrueTest() throws IOException {+        ProtocolMappersResource protocolMappers = setProtocolMappers(false, true, true);++        oauth.nonce(""123456"");+        oauth.scope(""address"");+        oauth.clientId(""test-app"");+        OAuthClient.AccessTokenResponse response = browserLogin(""password"", ""test-user@localhost"", ""password"");+        String accessToken = response.getAccessToken();+        System.out.println(""accessToken:"" + accessToken);+        assertAccessToken(oauth.verifyToken(accessToken), true);++        oauth.clientId(""resource-server"");+        String tokenResponse = oauth.introspectAccessTokenWithClientCredential(""resource-server"", ""password"", accessToken);+        System.out.println(""tokenResponse:"" + tokenResponse);+        assertTokenIntrospectionResponse(JsonSerialization.readValue(tokenResponse, AccessToken.class), true);++        deleteProtocolMappers(protocolMappers);","Is it possible to move `deleteProtocolMappers` in the ""finally"" block? So something like:```ProtocolMappersResource protocolMappers = setProtocolMappers(false, true, true);try {  ....} finally {    deleteProtocolMappers(protocolMappers);}```This is good practice, which helps, so one failing test doesn't makes the whole class to fail.It will be good to update this way in all test methods of this class (I did not updated it in my PR, so you can better track the changes I did in my PR as this one means update of all the lines of the tests).",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327216898,2023-09-15T12:26:23Z,operator/src/main/java/org/keycloak/operator/crds/v2alpha1/deployment/KeycloakStatus.java,"@@ -87,6 +88,14 @@ public void setObservedGeneration(Long generation) {         this.observedGeneration = generation;     } +    public String getHostname() {+        return hostname;+    }++    public void setHostname(String hostname) {+        this.hostname = hostname;+    }","I think exposing hostname in the status might be a bit confusing in the current state. IMHO it's not what was originally desired in #21741 (CC @pgodowski), and I don't see much benefit in exposing it just through status either. I know it's mimicking e.g. with Route status but I'm not sure it makes so much sense for Keycloak CR if Keycloak actually doesn't use this hostname.Reading #21741 and also considering how old Operator behaved, I think the main expectation from this feature is that the `hostname` will get a default auto-generated value if not specified by user. I.e. the Operator would set the field on the CR spec directly. Alternatively, pass the auto-generated hostname to Keycloak – i.e. behave as it was set in the CR spec.On the other hand, hostname could be also baked in the image. The Operator currently has no idea what configuration comes from the CR and what is already set by a different config source, typically a properties file in a custom image. If we specify the auto-generated value in the CR, it might override what is set e.g. in a properties file in custom image.I can see a few option here but I'm not too happy about either:1. Check if Keycloak truly has no hostname set (related to #21816). Only if really no hostname is specified by user, Operator generates one.2. We introduce a new switch in the CR, something like `hostname.generate: true`, that'd make the Operator set a default hostname only if explicitly enabled to do so.3. We just go ahead and set the default auto-generated hostname when it's not specified in the CR regardless if it's defined in some other config source. In the end, we do something similar e.g. for ports – we also assume only CR values and not other config sources.I'm probably most inclined towards option 3 to keep it simple. It'd be of course a breaking change which we'd need to document. WDYT?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327234838,2023-09-15T12:41:24Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakController.java,"@@ -93,9 +103,36 @@ public Map<String, EventSource> prepareEventSources(EventSourceContext<Keycloak>         sources.put(""serviceSource"", servicesEvent);         sources.putAll(EventSourceInitializer.nameEventSources(statefulSetEvent,                 watchedSecrets.getWatchedSecretsEventSource()));++        if (context.getClient().supports(Ingress.class)) {+            watchOpenShiftIngress(context, sources);+        }+         return sources;     } +    private void watchOpenShiftIngress(EventSourceContext<Keycloak> context, Map<String, EventSource> sources) {+        InformerConfiguration<Ingress> ingressIC = InformerConfiguration.from(Ingress.class)+                .withOnUpdateFilter((oldResource,+                        newResource) -> CLUSTER_CONFIG_NAME.equals(newResource.getMetadata().getName())+                                && (!Objects.equals(newResource.getSpec().getAppsDomain(), oldResource.getSpec().getAppsDomain()))+                                || !Objects.equals(newResource.getSpec().getDomain(), oldResource.getSpec().getDomain()))+                .withPrimaryToSecondaryMapper(primary -> Set.of(new ResourceID(CLUSTER_CONFIG_NAME)))+                .withSecondaryToPrimaryMapper(dependentResource -> {+                    if (!CLUSTER_CONFIG_NAME.equals(dependentResource.getMetadata().getName())) {+                        return Collections.emptySet();+                    }+                    return context.getPrimaryCache().list()+                            .filter(kc -> (kc.getSpec().getIngressSpec() == null+                                    || kc.getSpec().getIngressSpec().isIngressEnabled())+                                    && Optional.ofNullable(kc.getSpec().getHostnameSpec())+                                            .map(HostnameSpec::getHostname).isEmpty())+                            .map(ResourceID::fromResource).collect(Collectors.toSet());+                }).build();+        EventSource ingressEvent = new InformerEventSource<>(ingressIC, context);+        sources.putAll(EventSourceInitializer.nameEventSources(ingressEvent));+    }","This feels to me like maybe a bit too much of added complexity for only a potential corner case when the root hostname for the cluster changes.If we just directly set the generated hostname on the CR spec (i.e. treat it as a default value that gets persited with the CR), we don't need this.",x
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/23259,1327236818,2023-09-15T12:43:24Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/services/resources/QuarkusWelcomeResource.java,"@@ -16,209 +16,24 @@  */ package org.keycloak.quarkus.runtime.services.resources; -import org.jboss.logging.Logger;-import org.keycloak.common.ClientConnection;-import org.keycloak.common.Profile;-import org.keycloak.common.Version;-import org.keycloak.common.util.Base64Url;-import org.keycloak.common.util.MimeTypeUtil;-import org.keycloak.common.util.SecretGenerator;-import org.keycloak.http.HttpRequest;-import org.keycloak.models.KeycloakSession; import org.keycloak.quarkus.runtime.configuration.Configuration;-import org.keycloak.services.ForbiddenException;-import org.keycloak.services.ServicesLogger;-import org.keycloak.services.managers.ApplianceBootstrap;-import org.keycloak.services.util.CacheControlUtil;-import org.keycloak.services.util.CookieHelper;-import org.keycloak.theme.Theme;-import org.keycloak.theme.freemarker.FreeMarkerProvider;-import org.keycloak.urls.UrlType;-import org.keycloak.utils.MediaType;+import org.keycloak.services.resources.WelcomeResource; -import io.quarkus.logging.Log;--import jakarta.ws.rs.Consumes;-import jakarta.ws.rs.GET;-import jakarta.ws.rs.POST; import jakarta.ws.rs.Path;-import jakarta.ws.rs.PathParam;-import jakarta.ws.rs.Produces;-import jakarta.ws.rs.WebApplicationException;-import jakarta.ws.rs.core.Context;-import jakarta.ws.rs.core.Cookie;-import jakarta.ws.rs.core.HttpHeaders;-import jakarta.ws.rs.core.MultivaluedMap;-import jakarta.ws.rs.core.Response;-import jakarta.ws.rs.core.Response.ResponseBuilder;-import jakarta.ws.rs.core.Response.Status;-import java.io.IOException;-import java.io.InputStream;-import java.net.InetAddress;-import java.net.URI;-import java.net.URISyntaxException;-import java.net.UnknownHostException;-import java.util.HashMap;-import java.util.Map;-import java.util.Objects;-import java.util.concurrent.atomic.AtomicBoolean;  /**  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>  */ @Path(""/"")-public class QuarkusWelcomeResource {--    private static final Logger logger = Logger.getLogger(QuarkusWelcomeResource.class);-    private static final String KEYCLOAK_STATE_CHECKER = ""WELCOME_STATE_CHECKER"";--    private AtomicBoolean shouldBootstrap;--    @Context-    KeycloakSession session;--    /**-     * Welcome page of Keycloak-     */-    @GET-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getWelcomePage() throws URISyntaxException {-        String requestUri = session.getContext().getUri().getRequestUri().toString();-        if (!requestUri.endsWith(""/"")) {-            return Response.seeOther(new URI(requestUri + ""/"")).build();-        } else {-            return createWelcomePage(null, null);-        }-    }--    @POST-    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response createUser() {-        HttpRequest request = session.getContext().getHttpRequest();-        MultivaluedMap<String, String> formData = request.getDecodedFormParameters();--        if (!shouldBootstrap()) {-            return createWelcomePage(null, null);-        } else {-            if (!isLocal()) {-                ServicesLogger.LOGGER.rejectedNonLocalAttemptToCreateInitialUser(session.getContext().getConnection().getRemoteAddr());-                throw new WebApplicationException(Response.Status.BAD_REQUEST);-            }--            csrfCheck(formData);--            String username = formData.getFirst(""username"");-            String password = formData.getFirst(""password"");-            String passwordConfirmation = formData.getFirst(""passwordConfirmation"");--            if (username != null) {-                username = username.trim();-            }--            if (username == null || username.length() == 0) {-                return createWelcomePage(null, ""Username is missing"");-            }--            if (password == null || password.length() == 0) {-                return createWelcomePage(null, ""Password is missing"");-            }--            if (!password.equals(passwordConfirmation)) {-                return createWelcomePage(null, ""Password and confirmation doesn't match"");-            }--            expireCsrfCookie();--            ApplianceBootstrap applianceBootstrap = new ApplianceBootstrap(session);-            applianceBootstrap.createMasterRealmUser(username, password);--            shouldBootstrap.set(false);-            ServicesLogger.LOGGER.createdInitialAdminUser(username);-            return createWelcomePage(""User created"", null);-        }-    }--    /**-     * Resources for welcome page-     */-    @GET-    @Path(""/welcome-content/{path}"")-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getResource(@PathParam(""path"") String path) {-        try {-            InputStream resource = getTheme().getResourceAsStream(path);-            if (resource != null) {-                String contentType = MimeTypeUtil.getContentType(path);-                Response.ResponseBuilder builder = Response.ok(resource).type(contentType).cacheControl(CacheControlUtil.getDefaultCacheControl());-                return builder.build();-            } else {-                return Response.status(Response.Status.NOT_FOUND).build();-            }-        } catch (IOException e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }-    }--    private Response createWelcomePage(String successMessage, String errorMessage) {-        try {-            Theme theme = getTheme();--            if(Objects.isNull(theme)) {-                Log.error(""Theme is null please check the \""--spi-theme-default\"" parameter"");-                errorMessage = ""The theme is null"";-                ResponseBuilder rb = Response.status(Status.BAD_REQUEST)-                        .entity(errorMessage)-                        .cacheControl(CacheControlUtil.noCache());-                return rb.build();-            }--            Map<String, Object> map = new HashMap<>();--            map.put(""adminConsoleEnabled"", isAdminConsoleEnabled());-            map.put(""productName"", Version.NAME);--            map.put(""properties"", theme.getProperties());-            map.put(""adminUrl"", session.getContext().getUri(UrlType.ADMIN).getBaseUriBuilder().path(""/admin/"").build());--            map.put(""resourcesPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/"" + theme.getType().toString().toLowerCase() +""/"" + theme.getName());-            map.put(""resourcesCommonPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/common/keycloak"");+public class QuarkusWelcomeResource extends WelcomeResource { -            boolean bootstrap = shouldBootstrap();-            map.put(""bootstrap"", bootstrap);-            if (bootstrap) {-                boolean isLocal = isLocal();-                map.put(""localUser"", isLocal);--                String localAdminUrl = getLocalAdminUrl();--                map.put(""localAdminUrl"", localAdminUrl);-                map.put(""adminUserCreationMessage"", ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"");--                if (isLocal) {-                    String stateChecker = setCsrfCookie();-                    map.put(""stateChecker"", stateChecker);-                }-            }-            if (successMessage != null) {-                map.put(""successMessage"", successMessage);-            }-            if (errorMessage != null) {-                map.put(""errorMessage"", errorMessage);-            }-            FreeMarkerProvider freeMarkerUtil = session.getProvider(FreeMarkerProvider.class);-            String result = freeMarkerUtil.processTemplate(map, ""index.ftl"", theme);--            ResponseBuilder rb = Response.status(errorMessage == null ? Status.OK : Status.BAD_REQUEST)-                    .entity(result)-                    .cacheControl(CacheControlUtil.noCache());-            return rb.build();-        } catch (Exception e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }+    @Override+    protected String getAdminCreationMessage() {+        return ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"";     } -    private String getLocalAdminUrl() {+    @Override+    protected String getLocalAdminUrl() {","That is the thing ... This URL type would be used only here.However, having it resolved from the hostname provider should make life a lot easier because we don't need to deal with the differences around the runtime (e.g.: undertow vs quarkus). And ultimately removing this class completely.In the [hostname provider](https://github.com/keycloak/keycloak/blob/main/quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/hostname/DefaultHostnameProvider.java) we already have similar code to resolve the scheme and the port.",x
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327310501,2023-09-15T13:44:22Z,operator/src/main/java/org/keycloak/operator/crds/v2alpha1/deployment/KeycloakStatus.java,"@@ -87,6 +88,14 @@ public void setObservedGeneration(Long generation) {         this.observedGeneration = generation;     } +    public String getHostname() {+        return hostname;+    }++    public void setHostname(String hostname) {+        this.hostname = hostname;+    }","> IMHO it's not what was originally desired in https://github.com/keycloak/keycloak/issues/21741 (CC @pgodowski), and I don't see much benefit in exposing it just through status either.If the operator takes responsibility for creating the hostname, it should provide that to the user rather than requiring a secondary lookup via the route.> We introduce a new switch in the CR, something like hostname.generate: true, that'd make the Operator set a default hostname only if explicitly enabled to do so.Rather than introduce another flag, and especially if this feature is going to be static - that is generated only once and stored on the cr, I'd argue instead for dropping the feature entirely and just make the user responsible for filling in some hostname using the apps domain.As an aside the fundemental issue here is that openshift is basically violating the contract of ingress.  The ingress docs make it clear that the hostname is optional: https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-rules - obviously though there would quickly be routing conflicts if that were honored, especially if everything is using the default ingresscontroller.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/22148,1327382426,2023-09-15T14:38:21Z,services/src/main/java/org/keycloak/protocol/oidc/mappers/LightWeightAccessTokenMapper.java,"@@ -0,0 +1,75 @@+package org.keycloak.protocol.oidc.mappers;+import org.keycloak.common.Profile;+import org.keycloak.common.util.Time;+import org.keycloak.models.ClientSessionContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.models.ProtocolMapperModel;+import org.keycloak.models.SingleUseObjectProvider;++import org.keycloak.models.UserSessionModel;+import org.keycloak.provider.EnvironmentDependentProviderFactory;+import org.keycloak.provider.ProviderConfigProperty;+import org.keycloak.representations.AccessToken;++import java.util.ArrayList;++import java.util.HashMap;+import java.util.List;+import java.util.Map;++import static org.keycloak.representations.IDToken.SESSION_ID;+import static org.keycloak.representations.JsonWebToken.AZP;++public class LightWeightAccessTokenMapper extends AbstractOIDCProtocolMapper implements OIDCAccessTokenMapper, EnvironmentDependentProviderFactory {+    public static String LIGHT_WEIGHT_ACCESS_TOKEN_PROVIDER_ID = ""oidc-light-weight-access-token-mapper"";+    private static final List<ProviderConfigProperty> configProperties = new ArrayList<>();+    @Override+    public String getDisplayCategory() {+        return TOKEN_MAPPER_CATEGORY;+    }++    @Override+    public String getDisplayType() {+        return ""Light weight access token"";+    }++    @Override+    public String getHelpText() {+        return ""Delete the information contained by default in the access token. "" ++                ""The deleted information can be obtained at the token introspection endpoint."";+    }++    @Override+    public List<ProviderConfigProperty> getConfigProperties() {+        return configProperties;+    }++    @Override+    public String getId() {+        return LIGHT_WEIGHT_ACCESS_TOKEN_PROVIDER_ID;+    }++    @Override+    public AccessToken transformAccessToken(AccessToken token, ProtocolMapperModel mappingModel, KeycloakSession session,",> I am reffering to [JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens documentation](https://datatracker.ietf.org/doc/html/rfc9068#name-data-structure).You have a good point here and we should probably choose the basic claims a lightweight token should have based on this spec. It already provides the minimal set (similar to ID Token) of claims and that spec was based on feedback from different vendors and use cases.,
8390247,pedro-hos,https://api.github.com/repos/keycloak/keycloak/pulls/23221,1327443646,2023-09-15T15:17:19Z,services/src/main/java/org/keycloak/services/HttpRequestImpl.java,"@@ -61,8 +65,19 @@ public MultivaluedMap<String, String> getDecodedFormParameters() {         }         MediaType mediaType = getHttpHeaders().getMediaType();         if (mediaType == null || !mediaType.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded""))) {-            return new MultivaluedHashMap<>();+            throw new BadRequestException(""MediaType is not compatible"");+        } +        +        String charsetName = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);+        +        if(charsetName != null) {+            try {+                Charset.isSupported(charsetName);+            } catch (Exception e) {+                throw new BadRequestException(""Charset "" + charsetName +"" is not supported"");+            }         }+                 return delegate.getDecodedFormParameters();","I don't know why, but without the following, the RestEasy is not validating the `'utf-8'`:```java            if(charsetName != null) {                Charset.isSupported(charsetName);            }```and we get the message: `""Incorrect form parameters: 'utf-8'""`. However, if we test with `utf-88`, than the message is: `Incorrect form parameters: java.io.UnsupportedEncodingException: utf-88`. So, I need to keep that validation. Another point is that sometimes the charset comes as `null`, and the `Charset.isSupported(charsetName);` throws an error since `null`  is not valid and we accept `null`, that's the reason that `if(...)` there. ",x
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/23259,1327460238,2023-09-15T15:28:14Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/services/resources/QuarkusWelcomeResource.java,"@@ -16,209 +16,24 @@  */ package org.keycloak.quarkus.runtime.services.resources; -import org.jboss.logging.Logger;-import org.keycloak.common.ClientConnection;-import org.keycloak.common.Profile;-import org.keycloak.common.Version;-import org.keycloak.common.util.Base64Url;-import org.keycloak.common.util.MimeTypeUtil;-import org.keycloak.common.util.SecretGenerator;-import org.keycloak.http.HttpRequest;-import org.keycloak.models.KeycloakSession; import org.keycloak.quarkus.runtime.configuration.Configuration;-import org.keycloak.services.ForbiddenException;-import org.keycloak.services.ServicesLogger;-import org.keycloak.services.managers.ApplianceBootstrap;-import org.keycloak.services.util.CacheControlUtil;-import org.keycloak.services.util.CookieHelper;-import org.keycloak.theme.Theme;-import org.keycloak.theme.freemarker.FreeMarkerProvider;-import org.keycloak.urls.UrlType;-import org.keycloak.utils.MediaType;+import org.keycloak.services.resources.WelcomeResource; -import io.quarkus.logging.Log;--import jakarta.ws.rs.Consumes;-import jakarta.ws.rs.GET;-import jakarta.ws.rs.POST; import jakarta.ws.rs.Path;-import jakarta.ws.rs.PathParam;-import jakarta.ws.rs.Produces;-import jakarta.ws.rs.WebApplicationException;-import jakarta.ws.rs.core.Context;-import jakarta.ws.rs.core.Cookie;-import jakarta.ws.rs.core.HttpHeaders;-import jakarta.ws.rs.core.MultivaluedMap;-import jakarta.ws.rs.core.Response;-import jakarta.ws.rs.core.Response.ResponseBuilder;-import jakarta.ws.rs.core.Response.Status;-import java.io.IOException;-import java.io.InputStream;-import java.net.InetAddress;-import java.net.URI;-import java.net.URISyntaxException;-import java.net.UnknownHostException;-import java.util.HashMap;-import java.util.Map;-import java.util.Objects;-import java.util.concurrent.atomic.AtomicBoolean;  /**  * @author <a href=""mailto:sthorger@redhat.com"">Stian Thorgersen</a>  */ @Path(""/"")-public class QuarkusWelcomeResource {--    private static final Logger logger = Logger.getLogger(QuarkusWelcomeResource.class);-    private static final String KEYCLOAK_STATE_CHECKER = ""WELCOME_STATE_CHECKER"";--    private AtomicBoolean shouldBootstrap;--    @Context-    KeycloakSession session;--    /**-     * Welcome page of Keycloak-     */-    @GET-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getWelcomePage() throws URISyntaxException {-        String requestUri = session.getContext().getUri().getRequestUri().toString();-        if (!requestUri.endsWith(""/"")) {-            return Response.seeOther(new URI(requestUri + ""/"")).build();-        } else {-            return createWelcomePage(null, null);-        }-    }--    @POST-    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response createUser() {-        HttpRequest request = session.getContext().getHttpRequest();-        MultivaluedMap<String, String> formData = request.getDecodedFormParameters();--        if (!shouldBootstrap()) {-            return createWelcomePage(null, null);-        } else {-            if (!isLocal()) {-                ServicesLogger.LOGGER.rejectedNonLocalAttemptToCreateInitialUser(session.getContext().getConnection().getRemoteAddr());-                throw new WebApplicationException(Response.Status.BAD_REQUEST);-            }--            csrfCheck(formData);--            String username = formData.getFirst(""username"");-            String password = formData.getFirst(""password"");-            String passwordConfirmation = formData.getFirst(""passwordConfirmation"");--            if (username != null) {-                username = username.trim();-            }--            if (username == null || username.length() == 0) {-                return createWelcomePage(null, ""Username is missing"");-            }--            if (password == null || password.length() == 0) {-                return createWelcomePage(null, ""Password is missing"");-            }--            if (!password.equals(passwordConfirmation)) {-                return createWelcomePage(null, ""Password and confirmation doesn't match"");-            }--            expireCsrfCookie();--            ApplianceBootstrap applianceBootstrap = new ApplianceBootstrap(session);-            applianceBootstrap.createMasterRealmUser(username, password);--            shouldBootstrap.set(false);-            ServicesLogger.LOGGER.createdInitialAdminUser(username);-            return createWelcomePage(""User created"", null);-        }-    }--    /**-     * Resources for welcome page-     */-    @GET-    @Path(""/welcome-content/{path}"")-    @Produces(MediaType.TEXT_HTML_UTF_8)-    public Response getResource(@PathParam(""path"") String path) {-        try {-            InputStream resource = getTheme().getResourceAsStream(path);-            if (resource != null) {-                String contentType = MimeTypeUtil.getContentType(path);-                Response.ResponseBuilder builder = Response.ok(resource).type(contentType).cacheControl(CacheControlUtil.getDefaultCacheControl());-                return builder.build();-            } else {-                return Response.status(Response.Status.NOT_FOUND).build();-            }-        } catch (IOException e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }-    }--    private Response createWelcomePage(String successMessage, String errorMessage) {-        try {-            Theme theme = getTheme();--            if(Objects.isNull(theme)) {-                Log.error(""Theme is null please check the \""--spi-theme-default\"" parameter"");-                errorMessage = ""The theme is null"";-                ResponseBuilder rb = Response.status(Status.BAD_REQUEST)-                        .entity(errorMessage)-                        .cacheControl(CacheControlUtil.noCache());-                return rb.build();-            }--            Map<String, Object> map = new HashMap<>();--            map.put(""adminConsoleEnabled"", isAdminConsoleEnabled());-            map.put(""productName"", Version.NAME);--            map.put(""properties"", theme.getProperties());-            map.put(""adminUrl"", session.getContext().getUri(UrlType.ADMIN).getBaseUriBuilder().path(""/admin/"").build());--            map.put(""resourcesPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/"" + theme.getType().toString().toLowerCase() +""/"" + theme.getName());-            map.put(""resourcesCommonPath"", ""resources/"" + Version.RESOURCES_VERSION + ""/common/keycloak"");+public class QuarkusWelcomeResource extends WelcomeResource { -            boolean bootstrap = shouldBootstrap();-            map.put(""bootstrap"", bootstrap);-            if (bootstrap) {-                boolean isLocal = isLocal();-                map.put(""localUser"", isLocal);--                String localAdminUrl = getLocalAdminUrl();--                map.put(""localAdminUrl"", localAdminUrl);-                map.put(""adminUserCreationMessage"", ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"");--                if (isLocal) {-                    String stateChecker = setCsrfCookie();-                    map.put(""stateChecker"", stateChecker);-                }-            }-            if (successMessage != null) {-                map.put(""successMessage"", successMessage);-            }-            if (errorMessage != null) {-                map.put(""errorMessage"", errorMessage);-            }-            FreeMarkerProvider freeMarkerUtil = session.getProvider(FreeMarkerProvider.class);-            String result = freeMarkerUtil.processTemplate(map, ""index.ftl"", theme);--            ResponseBuilder rb = Response.status(errorMessage == null ? Status.OK : Status.BAD_REQUEST)-                    .entity(result)-                    .cacheControl(CacheControlUtil.noCache());-            return rb.build();-        } catch (Exception e) {-            throw new WebApplicationException(e, Response.Status.INTERNAL_SERVER_ERROR);-        }+    @Override+    protected String getAdminCreationMessage() {+        return ""or set the environment variables KEYCLOAK_ADMIN and KEYCLOAK_ADMIN_PASSWORD before starting the server"";     } -    private String getLocalAdminUrl() {+    @Override+    protected String getLocalAdminUrl() {","> In the [hostname provider](https://github.com/keycloak/keycloak/blob/main/quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/hostname/DefaultHostnameProvider.java) we already have similar code to resolve the scheme and the port.I've updated the pr with a simplistic refactoring that moves the local admin to the hostnameprovider.  However I didn't want to guess too much about what could be consolidated with the quarkus DefaultHostnameProvider, since the local admin construction logic was subtly different.Is this along the lines of what you are thinking?",x
11057277,pgodowski,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327505676,2023-09-15T16:01:36Z,operator/src/main/java/org/keycloak/operator/crds/v2alpha1/deployment/KeycloakStatus.java,"@@ -87,6 +88,14 @@ public void setObservedGeneration(Long generation) {         this.observedGeneration = generation;     } +    public String getHostname() {+        return hostname;+    }++    public void setHostname(String hostname) {+        this.hostname = hostname;+    }","> > IMHO it's not what was originally desired in #21741 (CC @pgodowski), and I don't see much benefit in exposing it just through status either.> > If the operator takes responsibility for creating the hostname, it should provide that to the user rather than requiring a secondary lookup via the route.> While I haven't asked for `.status.hostname` (since the connection binding information would be handled differently in my specific use case), I agree it makes sense to put it back into Keycloak status, instead of the secondary lookup. I understand that this hostname is not only used by Route, but also used by Keycloak operand, thus I think it deserves to be put into Keycloak `.status`.",x
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/23221,1327512442,2023-09-15T16:08:06Z,services/src/main/java/org/keycloak/services/HttpRequestImpl.java,"@@ -61,8 +65,19 @@ public MultivaluedMap<String, String> getDecodedFormParameters() {         }         MediaType mediaType = getHttpHeaders().getMediaType();         if (mediaType == null || !mediaType.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded""))) {-            return new MultivaluedHashMap<>();+            throw new BadRequestException(""MediaType is not compatible"");+        } +        +        String charsetName = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);+        +        if(charsetName != null) {+            try {+                Charset.isSupported(charsetName);+            } catch (Exception e) {+                throw new BadRequestException(""Charset "" + charsetName +"" is not supported"");+            }         }+                 return delegate.getDecodedFormParameters();","Maybe it's because you are re-catching the exception. What happens if you just do the following?```java        MediaType mediaType = getHttpHeaders().getMediaType();        if (mediaType == null || !mediaType.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded""))) {            throw new BadRequestException(""MediaType "" + mediaType + "" is not application/x-www-form-urlencoded compatible"");        }        try {            return delegate.getDecodedFormParameters();        } catch (Exception e) {            throw new BadRequestException(""Incorrect form parameters: "" + e.getMessage(), e);        }```I'd say that the message should be: `Incorrect form parameters: java.io.UnsupportedEncodingException: 'utf-8'`.",
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/22859,1327561315,2023-09-15T16:52:31Z,operator/src/main/java/org/keycloak/operator/crds/v2alpha1/deployment/KeycloakStatus.java,"@@ -87,6 +88,14 @@ public void setObservedGeneration(Long generation) {         this.observedGeneration = generation;     } +    public String getHostname() {+        return hostname;+    }++    public void setHostname(String hostname) {+        this.hostname = hostname;+    }","> IMHO if the Operator generates a hostname, it should also configure Keycloak to use it, not just expose it in status.The generated hostname in this pr is provided to Keycloak, so this does provide what you are calling option 2.edit - sorry I thought you meant the route, you mean where the hostname is picked up from the KeycloakDistConfigurator, no I missed that.> I think this might be the simplest approach.I see that your preferred solution is to look up the appsDomain each time and to populate on the CR.  It is simpler, but not quite as simple as you'd think - https://github.com/keycloak/keycloak/pull/22859#discussion_r1327286266 By doing it this way I think you are also trying to side step having to do a status update.  To be honest I'm not a big fan of the controllers making spec updates as it can get confusing on round-tripping and makes the stored version of the resource read less intentionally than what the user supplied.However double checking the openshift logic - there's no expectation that existing routes will change if the appsDomain is changed, but newly created routes will have the updated appsDomain.  The user is expected to update existing ones. To corollary here is that if we populate the hostname someone will have to remove it, or set it to the new expected value.  If we don't populate the hostname and aren't watching, then something will need to trigger another reconciliation.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22821,1328579310,2023-09-18T11:24:02Z,operator/scripts/olm-testing.sh,"@@ -3,6 +3,10 @@ set -euxo pipefail  UUID=${1:-$(git rev-parse --short HEAD)} +INSTALL_NAMESPACE=${2:-default}++TARGET_NAMESPACES=${3-$INSTALL_NAMESPACE}","This is actually currently unused, at least not used by the CI. Do we need it?",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22821,1328582310,2023-09-18T11:27:25Z,operator/scripts/create-olm-test-resources.sh,"@@ -27,23 +29,28 @@ spec:       interval: 10m EOF -cat << EOF >> $SCRIPT_DIR/../olm/testing-resources/operatorgroup.yaml++OPERATOR_GROUP_FILE=$SCRIPT_DIR/../olm/testing-resources/operatorgroup.yaml++cat << EOF >> $OPERATOR_GROUP_FILE kind: OperatorGroup apiVersion: operators.coreos.com/v1 metadata:-  name: og-single-  namespace: default+  name: og spec:-  targetNamespaces:-  - default EOF +IFS=', ' read -r -a array <<< ""$TARGET_NAMESPACES""+for element in ""${array[@]}""+do+    yq ea -i "".spec.targetNamespaces += [\""$element\""]"" $OPERATOR_GROUP_FILE","`spec.TargetNamespaces` seems to be kinda [deprecated](https://docs.openshift.com/container-platform/4.13/operators/understanding/olm/olm-understanding-operatorgroups.html#olm-operatorgroups-target-namespace_olm-understanding-operatorgroups)? But maybe we don't even need it (specifying multiple namespaces here), see my comment above.",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22821,1328897210,2023-09-18T15:22:58Z,operator/scripts/create-olm-test-resources.sh,"@@ -27,23 +29,28 @@ spec:       interval: 10m EOF -cat << EOF >> $SCRIPT_DIR/../olm/testing-resources/operatorgroup.yaml++OPERATOR_GROUP_FILE=$SCRIPT_DIR/../olm/testing-resources/operatorgroup.yaml++cat << EOF >> $OPERATOR_GROUP_FILE kind: OperatorGroup apiVersion: operators.coreos.com/v1 metadata:-  name: og-single-  namespace: default+  name: og spec:-  targetNamespaces:-  - default EOF +IFS=', ' read -r -a array <<< ""$TARGET_NAMESPACES""+for element in ""${array[@]}""+do+    yq ea -i "".spec.targetNamespaces += [\""$element\""]"" $OPERATOR_GROUP_FILE","Thanks for double checking!> So on the script changes if you want I can either backout everything and we won't bother with those changes for now, or it could be updated to be based upon a label, or a label and target namespaces (such that the script adds the label to the targets).I'd keep only what's strictly necessary for testing these two scenarios in the CI:* Operator watching and being installed in a single namespace.* Operator watching all namespaces, i.e. empty watched namespaces.* And maybe one more scenario that we currently miss. That the Operator can watch a list of namespaces (MultiNamespace mode). I think we technically ""support"" this now. But we could add this test scenario later as a follow-up.Which means we can keep everything in the scripts as we'd use `targetNamespaces` for the last scenario.",
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/23324,1328936980,2023-09-18T15:48:29Z,operator/src/main/kubernetes/kubernetes.yml,"@@ -61,6 +58,14 @@ rules:       - delete       - patch       - update+  - apiGroups:+      - config.openshift.io+    resources:+      - ingresses+    verbs:+      - get+      - list+      - watch",> I think we don't need the watch permission anymore.I can narrow it to get if you want.  Since this is a singleton resource these no real expansion of rights providing all of the read-only options.,
8390247,pedro-hos,https://api.github.com/repos/keycloak/keycloak/pulls/23221,1328952723,2023-09-18T16:01:03Z,services/src/main/java/org/keycloak/services/HttpRequestImpl.java,"@@ -61,8 +65,19 @@ public MultivaluedMap<String, String> getDecodedFormParameters() {         }         MediaType mediaType = getHttpHeaders().getMediaType();         if (mediaType == null || !mediaType.isCompatible(MediaType.valueOf(""application/x-www-form-urlencoded""))) {-            return new MultivaluedHashMap<>();+            throw new BadRequestException(""MediaType is not compatible"");+        } +        +        String charsetName = mediaType.getParameters().get(MediaType.CHARSET_PARAMETER);+        +        if(charsetName != null) {+            try {+                Charset.isSupported(charsetName);+            } catch (Exception e) {+                throw new BadRequestException(""Charset "" + charsetName +"" is not supported"");+            }         }+                 return delegate.getDecodedFormParameters();",@rmartinc my bad man! The way that you said works =D Sending the correct PR now! I don't know why the CI is failing. All tests are passing locally,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23353,1329975990,2023-09-19T11:35:59Z,js/apps/account-ui/test/login.ts,"@@ -11,6 +11,6 @@ export const login = async (       process.env.CI ? `/realms/${realm}/account` : `/?realm=${realm}`,     );   await page.getByLabel(""Username"").fill(username);-  await page.getByLabel(""Password"").fill(password);+  await page.getByText(""Password"").fill(password);","We could also use the [`exact` option](https://playwright.dev/docs/api/class-page#page-get-by-label-option-exact) here, which should match the correct element.```suggestion  await page.getByLabel(""Password"", { exact: true }).fill(password);```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/23323,1330099785,2023-09-19T13:08:46Z,services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java,"@@ -321,6 +321,9 @@ private void updateAuthenticationSession() {         if (request.getMaxAge() != null) authenticationSession.setClientNote(OIDCLoginProtocol.MAX_AGE_PARAM, String.valueOf(request.getMaxAge()));         if (request.getUiLocales() != null) authenticationSession.setClientNote(LocaleSelectorProvider.CLIENT_REQUEST_LOCALE, request.getUiLocales()); +        // TODO: what about clientNote? should it be set as well? (with my limited understanding of the domain I say 'no', but loginHint param triggers setting clientNote only)+        if (request.getIdTokenHint() != null) authenticationSession.setAuthNote(OIDCLoginProtocol.ID_TOKEN_HINT, request.getIdTokenHint());","I would say that it should set clientNote instead of authNote? Or is something broken when `id_token_hint` is not sent in authNote?In general, clientNotes are reserved for the parameters, which are sent from the client. And `id_token_hint` is one of the parameters. Also you can see that most of other parameters are also saved in clientNotes. The authNotes are usually used by authenticators to save/load some data related to authentication process itself.",x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22443,1330329442,2023-09-19T15:34:36Z,quarkus/runtime/src/test/java/org/keycloak/quarkus/runtime/configuration/test/IgnoredArtifactsTest.java,"@@ -74,4 +84,46 @@ public void ignoredMapStorage() {         assertStorage.accept(""file"");         assertStorage.accept(""chm"");     }++    @Test+    public void jdbcH2() {+        assertJdbc(""h2"", JDBC_H2);+    }++    @Test+    public void jdbcMssql() {+        assertJdbc(""mssql"", JDBC_MSSQL);+    }++    @Test+    public void jdbcMariadb() {+        assertJdbc(""mariadb"", JDBC_MARIADB);+    }++    @Test+    public void jdbcMysql() {+        assertJdbc(""mysql"", JDBC_MYSQL);+    }++    @Test+    public void jdbcOracle() {+        assertJdbc(""oracle"", JDBC_ORACLE);+    }++    @Test+    public void jdbcPostgres() {+        assertJdbc(""postgres"", JDBC_POSTGRES);+    }++    private void assertJdbc(String vendor, Set<String> notIgnored) {",I think we could also check the unused DB artifacts are not present.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/23324,1330392366,2023-09-19T16:19:21Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakController.java,"@@ -103,16 +109,31 @@ public UpdateControl<Keycloak> reconcile(Keycloak kc, Context<Keycloak> context)          Log.infof(""--- Reconciling Keycloak: %s in namespace: %s"", kcName, namespace); +        boolean modifiedSpec = false;         if (kc.getSpec().getInstances() == null) {             // explicitly set defaults - and let another reconciliation happen             // this avoids ensuring unintentional modifications have not been made to the cr             kc.getSpec().setInstances(1);+            modifiedSpec = true;+        }+        if (kc.getSpec().getIngressSpec() != null && kc.getSpec().getIngressSpec().isIngressEnabled()","After the recent changes, we now require ingress class name to be always set. [Before](https://github.com/keycloak/keycloak/blob/9d0b884cef189f5440bf22805cd099bce7ce6ea0/operator/src/main/java/org/keycloak/operator/controllers/KeycloakController.java#L116) you could omit the ingress spec completely. I wonder if it might be quite user friendly if we detect the default IngressClass on the cluster and if it matches `openshift-default`, we would not require users to explicitly specify it. WDYT @shawkins?",
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/23324,1330413173,2023-09-19T16:34:18Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakController.java,"@@ -103,16 +109,31 @@ public UpdateControl<Keycloak> reconcile(Keycloak kc, Context<Keycloak> context)          Log.infof(""--- Reconciling Keycloak: %s in namespace: %s"", kcName, namespace); +        boolean modifiedSpec = false;         if (kc.getSpec().getInstances() == null) {             // explicitly set defaults - and let another reconciliation happen             // this avoids ensuring unintentional modifications have not been made to the cr             kc.getSpec().setInstances(1);+            modifiedSpec = true;+        }+        if (kc.getSpec().getIngressSpec() != null && kc.getSpec().getIngressSpec().isIngressEnabled()","The ingress class name isn't considered required (yet).You could consider setting it automatically, that will work most of the time.  It will be confusing though if/when it changes and then there's behavioral differences due to implementation details in the ingress.  We ran into a similar case with the notion of the default storage class with managed kafka - assuming the default seemed fine, until the default changed across openshift versions.",
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/23324,1330485491,2023-09-19T17:33:14Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakController.java,"@@ -103,16 +109,31 @@ public UpdateControl<Keycloak> reconcile(Keycloak kc, Context<Keycloak> context)          Log.infof(""--- Reconciling Keycloak: %s in namespace: %s"", kcName, namespace); +        boolean modifiedSpec = false;         if (kc.getSpec().getInstances() == null) {             // explicitly set defaults - and let another reconciliation happen             // this avoids ensuring unintentional modifications have not been made to the cr             kc.getSpec().setInstances(1);+            modifiedSpec = true;+        }+        if (kc.getSpec().getIngressSpec() != null && kc.getSpec().getIngressSpec().isIngressEnabled()","Sorry I'm not describing the situation fully.  One proposal for specifying the storage class in managed kafka was just to use the system default if it wasn't specified in the cr - mostly because the assumption was that the system default matched what had been tested / approved for use and there would be less to capture about cross-platform support. However openshift 4.something changed their default storage class from from gp2 to gp3, which was not something that had been tested / approved, so the system default was considered too much of a free variable from a management perspective.As long as there's documentation somewhere saying that we're automatically filling in the ingress classname based upon our initial observation at the time of deployment such that an update that omits the classname, or subsequent deployments may pick up a different default.",x
13901995,mhajas,https://api.github.com/repos/keycloak/keycloak/pulls/8430,1331256224,2023-09-20T08:42:28Z,server-spi/src/main/java/org/keycloak/storage/group/GroupLookupProvider.java,"@@ -42,10 +42,13 @@ public interface GroupLookupProvider {      * @return GroupModel with the corresponding name.      */     default GroupModel getGroupByName(RealmModel realm, GroupModel parent, String name) {-        return searchForGroupByNameStream(realm, name, true, null, null)-                .filter(groupModel -> parent == null-                        ? groupModel.getParent() == null-                        : parent.getId().equals(groupModel.getParentId())).findFirst().orElse(null);+        if (parent == null) {+            return searchForGroupByNameStream(realm, name, true, null, null)+                    .filter(groupModel -> groupModel.getName().equals(name)).findFirst().orElse(null);","@bohmber I am not following your latest change. What was wrong with the previous implementation? Also, this line is wrong, all groups in the stream will pass this condition.",
18034775,bohmber,https://api.github.com/repos/keycloak/keycloak/pulls/8430,1331587427,2023-09-20T12:53:56Z,server-spi/src/main/java/org/keycloak/storage/group/GroupLookupProvider.java,"@@ -42,10 +42,13 @@ public interface GroupLookupProvider {      * @return GroupModel with the corresponding name.      */     default GroupModel getGroupByName(RealmModel realm, GroupModel parent, String name) {-        return searchForGroupByNameStream(realm, name, true, null, null)-                .filter(groupModel -> parent == null-                        ? groupModel.getParent() == null-                        : parent.getId().equals(groupModel.getParentId())).findFirst().orElse(null);+        if (parent == null) {+            return searchForGroupByNameStream(realm, name, true, null, null)+                    .filter(groupModel -> groupModel.getName().equals(name)).findFirst().orElse(null);",@mhajs that's a much better idea. If you have a lot of toplevel Groups it might be slower und faster in case of a lot of nested groups. But that is less confusing and that is the default impl. If someone reports it's slow it can implemented in the class more efficient.,x
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/23407,1332628420,2023-09-21T07:49:55Z,.github/workflows/documentation.yml,"@@ -7,6 +7,11 @@ on:       - dependabot/**   pull_request:   workflow_dispatch:+    inputs:+      is-quarkus-nightly:+        description: 'Testing Keycloak with the nightly Quarkus release'+        required: false+        default: false","On the other hand, if we keep it in every workflow, we can then conditionally skip those. We don't need to test e.g. JS CI when `is-quarkus-nightly = true`.",
12138171,Pepo48,https://api.github.com/repos/keycloak/keycloak/pulls/23407,1332863376,2023-09-21T10:48:00Z,.github/workflows/documentation.yml,"@@ -7,6 +7,11 @@ on:       - dependabot/**   pull_request:   workflow_dispatch:+    inputs:+      is-quarkus-nightly:+        description: 'Testing Keycloak with the nightly Quarkus release'+        required: false+        default: false","Which actually got me to another thing - if we want to run it in parallel (I think we mentioned it during one of our discussions), then it is worth to define it as a job (instead of a step), because jobs run in parallel by default.Afaik, it's possible to make even steps to run in parallel, but it requires an additional implementation.The question is then, which workflows the matrix of the separately created job should contain? Should it be the same or a different set - ci.yml and operator-ci.yml as Vašek mentioned above?",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/23407,1332894987,2023-09-21T11:16:36Z,.github/workflows/documentation.yml,"@@ -7,6 +7,11 @@ on:       - dependabot/**   pull_request:   workflow_dispatch:+    inputs:+      is-quarkus-nightly:+        description: 'Testing Keycloak with the nightly Quarkus release'+        required: false+        default: false","> if we want to run it in parallel (I think we mentioned it during one of our discussions), then it is worth to define it as a job (instead of a step), because jobs run in parallel by defaultYou mean the [step](https://github.com/keycloak/keycloak/blob/76e0e7e3f7886be819854dfaa2258c90fbadd688/.github/workflows/schedule-nightly.yml#L45-L48) in `schedule-nightly`? That's just a dispatch, it does not wait for the CI to complete before it dispatches another CI in the other step.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23425,1332899231,2023-09-21T11:20:49Z,set-version.sh,"@@ -1,24 +1,32 @@ #!/bin/bash -e  NEW_VERSION=$1+NEW_NPM_VERSION=${2:-${1}}",I still think we should not be using a seperate version for NPM. Instead the input versions should all adhere to valid semantic versions.,
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/23361,1332904006,2023-09-21T11:25:41Z,quarkus/tests/integration/src/test/java/org/keycloak/it/cli/dist/StartAutoBuildDistTest.java,,I don't think we should remove this test class completely. I believe arts of it are still valid as they focus on `--optimized` flag and build process in general etc.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1332908558,2023-09-21T11:30:04Z,server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java,"@@ -49,6 +49,7 @@ import org.keycloak.models.UserModel; import org.keycloak.protocol.oidc.OIDCConfigAttributes; import org.keycloak.representations.idm.CertificateRepresentation;+import org.keycloak.representations.idm.GroupRepresentation;",Minor: This import is likely not needed? Nothing changed in this class besides adding this import.,x
546680,pskopek,https://api.github.com/repos/keycloak/keycloak/pulls/23425,1332910281,2023-09-21T11:31:29Z,set-version.sh,"@@ -1,24 +1,32 @@ #!/bin/bash -e  NEW_VERSION=$1+NEW_NPM_VERSION=${2:-${1}}","This line has nothing to do with using valid semantic versions. It allows our downstream build script to override the NPM version if needed (mainly for debug/investigation purpose).Even if one uses set-version.sh with one parameter and specifies ""non-semantic"" version it will use it anyway (no validation of version is present).Our production build script is using ""./set-version.sh use_current"". ",x
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23406,1332912026,2023-09-21T11:33:11Z,js/apps/admin-ui/src/authentication/components/modals/AddStepModal.tsx,"@@ -142,7 +143,7 @@ export const AddStepModal = ({ name, type, onSelect }: AddStepModalProps) => {           }}           inputGroupName=""search""           inputGroupPlaceholder={t(""search"")}-          inputGroupOnEnter={setSearch}+          inputGroupOnEnter={(_) => setSearch(_.toLowerCase())}","Ah my mistake. What I meant is rather than calling `.toLowerCase()` when setting the value, it should be done when searching. So in the other logic you changed you can call `search.toLowerCase()`.This prevents accidental regressions if the value is ever set somewhere else, where one might forget to call `.toLowerCase()`.",x
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/23369,1332921042,2023-09-21T11:41:51Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LogoutTest.java,"@@ -0,0 +1,84 @@+/*+ * Copyright 2023 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.testsuite.forms;++import org.jboss.arquillian.graphene.page.Page;+import org.junit.Rule;+import org.junit.Test;+import org.keycloak.OAuth2Constants;+import org.keycloak.events.Details;+import org.keycloak.representations.idm.EventRepresentation;+import org.keycloak.representations.idm.RealmRepresentation;+import org.keycloak.representations.idm.UserRepresentation;+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;+import org.keycloak.testsuite.AssertEvents;+import org.keycloak.testsuite.pages.AppPage;+import org.keycloak.testsuite.pages.LoginPage;+import org.keycloak.testsuite.util.RealmBuilder;+import org.keycloak.testsuite.util.UserBuilder;++/**+ * @author <a href=""mailto:ariasdereyna@redhat.com"">María Arias de Reyna</a>+ */+public class LogoutTest extends AbstractTestRealmKeycloakTest {","Thanks for adding this test class. But I actually vote for remove it from this PR.As you pointed in the other comment (in `AssertEvents` class), you already needed to update events on multiple places in other tests due the fact that client is included in the logout event with your changes. So additional class for this, which already tests the same scenario as some other places is pretty redundant IMO.Besides that, we already have 2 classes in the codebase named `LogoutTest`. They are in different packages, but still it can cause confusions in theory to have test classes of same name.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1332942610,2023-09-21T12:01:10Z,server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java,"@@ -583,6 +521,8 @@ public static Map<String, String> stripRealmAttributesIncludedAsFields(Map<Strin         return a;     } +    // TODO GROUPS now that there are different mechanisms for accessing groups this could be done in a way that doesn't try to load everything",Maybe we can consider as a follow-up instead of directly address in this PR? Since this PR is already quite big.I would say we can maybe improve this for groups in the follow-up PR and add it to the groups epic https://github.com/keycloak/keycloak/issues/22261 . Also we can create separate follow-up PRs (if needed) for other objects.,
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1332965072,2023-09-21T12:21:15Z,services/src/main/java/org/keycloak/services/resources/admin/GroupResource.java,"@@ -150,6 +153,21 @@ public void deleteGroup() {         adminEvent.operation(OperationType.DELETE).resourcePath(session.getContext().getUri()).success();     } +    @GET+    @Path(""children"")+    @NoCache+    @Produces(MediaType.APPLICATION_JSON)+    @Tag(name = KeycloakOpenAPI.Admin.Tags.GROUPS)+    @Operation( summary = ""Return a paginated list of subgroups that have a parent group corresponding to the group on the URL"")+    public Stream<GroupRepresentation> getSubGroups(@QueryParam(""first"") @DefaultValue(""0"") Integer first,+        @QueryParam(""max"") @DefaultValue(""10"") Integer max,+        @QueryParam(""full"") @DefaultValue(""false"") Boolean full) {+        this.auth.groups().requireView(group);+        return session.groups().searchForSubgroupsByParentIdStream(realm, group.getId(), first, max)+            .filter(g -> auth.groups().canView() || auth.groups().canView(g))","Two comments:- I think the result of `auth.groups().canView()` can be cached somehow, so it is not needed to call for every group? This is related to my other comment in class `GroupsResource`- I think that when `session.groups().searchForSubgroupsByParentIdStream(realm, group.getId(), first, max)` returns 10 groups (assuming that first is 0 and max is 10 for example), but then for instance 3 groups are filtered by admin fine-grained permission calls to `auth.groups().canView(g)`, then this method would return only 7 groups instead of 10.This is bit misleading IMO, however I don't know if there is good solution for this, which will allow to return proper amount of groups and scale at the same time. Anyway, this problem seems to exist for all other objects using fine-grained permissions, so it is not a blocker for this PR IMO. And admin fine-grained permissions are preview feature, so we may need to discuss if/how to address this when we want to support it.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/23369,1332985564,2023-09-21T12:37:40Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/LogoutTest.java,"@@ -293,7 +293,7 @@ public void successfulKLogoutAfterEmptyBackChannelUrl() throws Exception {         }          // Assert logout event triggered for backchannel logout-        events.expectLogout(sessionId).detail(Details.REDIRECT_URI, oauth.APP_AUTH_ROOT).assertEvent();+        events.expectLogout(sessionId).client((String) null).detail(Details.REDIRECT_URI, oauth.APP_AUTH_ROOT).assertEvent();","I think we are missing a similar change (set client to event) when going through the logout endpoint. This assertion indicates we are missing the client there too when the `client_id` or `id_token_hint` is passed.Looking at the `LogoutEndpoint#logout` (GET) method, it seems we are only setting the client when there is a mismatch between `client_id` and id_token `azp`. See https://github.com/keycloak/keycloak/blob/main/services/src/main/java/org/keycloak/protocol/oidc/endpoints/LogoutEndpoint.java.",
26752730,osorionicolas,https://api.github.com/repos/keycloak/keycloak/pulls/23406,1333071203,2023-09-21T13:36:11Z,js/apps/admin-ui/src/authentication/components/modals/AddStepModal.tsx,"@@ -142,7 +143,7 @@ export const AddStepModal = ({ name, type, onSelect }: AddStepModalProps) => {           }}           inputGroupName=""search""           inputGroupPlaceholder={t(""search"")}-          inputGroupOnEnter={setSearch}+          inputGroupOnEnter={(_) => setSearch(_.toLowerCase())}",Moving the .toLowerCase() to the TableToolbar component (which is the one who does the search) involved modify the other componentes that use it. Also an exactSearch attribute was added for group searches because those are not case-insensitive in the backend.,x
3723981,potterhe,https://api.github.com/repos/keycloak/keycloak/pulls/23448,1333707172,2023-09-21T23:53:28Z,js/apps/admin-ui/public/locales/zh-CN/translation.json,"@@ -355,7 +355,7 @@   ""decisionStrategies"": {     ""UNANIMOUS"": ""无异议"",     ""AFFIRMATIVE"": ""肯定的"",-    ""CONSENSUS"": ""一致同意""+    ""CONSENSUS"": ""共识""","You can refer to lines 299 and 297. Line 358 translates ""CONSENSUS"" into the semantics of ""UNANIMOUS""",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/23425,1334069707,2023-09-22T08:31:33Z,js/libs/keycloak-js/pom.xml,"@@ -73,4 +73,63 @@             </plugin>         </plugins>     </build>+    <profiles>","This looks unnecessarily complex, and adds some custom Maven registry settings just for this module. Why not just attach the tgz with:```            <plugin>                <groupId>org.codehaus.mojo</groupId>                <artifactId>build-helper-maven-plugin</artifactId>                <executions>                    <execution>                        <id>attach-artifacts</id>                        <phase>package</phase>                        <goals>                            <goal>attach-artifact</goal>                        </goals>                        <configuration>                            <artifacts>                                <artifact>${project.basedir}/assembly.xml                                    <file>target/keycloak-js-${project.version}.tgz</file>                                    <type>tar.gz</type>                                </artifact>                            </artifacts>                        </configuration>                    </execution>                </executions>            </plugin>```and change the configuration for `maven-deploy-plugin` to `true. That way it's just uploaded along the other artifacts. ",x
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23425,1334439323,2023-09-22T14:12:30Z,set-version.sh,"@@ -1,24 +1,32 @@ #!/bin/bash -e  NEW_VERSION=$1+NEW_NPM_VERSION=${2:-${1}}","> Therefore we need two of them. See my comment in set-version.sh script.Or the version can be a valid semantic version,  in which case it would work for both.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23484,1334541674,2023-09-22T15:35:18Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -124,7 +124,11 @@ export default function EditUser() {     try {       await adminClient.users.update(         { id: user!.id! },-        toUserRepresentation(data),+        {",The `toUserRepresentation()` function still needs to be called on the data being passed here.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23509,1335685983,2023-09-25T10:17:27Z,js/apps/admin-ui/src/user/form-state.ts,"@@ -17,7 +17,9 @@ export function toUserFormFields(data: UserRepresentation): UserFormFields {  export function toUserRepresentation(data: UserFormFields): UserRepresentation {   const username = data.username?.trim();-  const attributes = keyValueToArray(data.attributes);+  const attributes = Array.isArray(data.attributes)",Under what circumstances is `data.attributes` not an array?,x
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23509,1335696774,2023-09-25T10:28:30Z,js/apps/admin-ui/src/user/UserForm.tsx,"@@ -223,8 +224,8 @@ export const UserForm = ({           <FederatedUserLink user={user} />         </FormGroup>       )}-      {isUserProfileEnabled && user?.userProfileMetadata ? (-        <UserProfileFields config={user.userProfileMetadata} />+      {isUserProfileEnabled ? (+        <UserProfileFields config={user?.userProfileMetadata || config!} />","Good catch, I was not aware we had this existing place where this config was stored. I'd still like to keep the condition if possible, as I am not a fan of circumventing the type system.Perhaps we can do the following:```tsxconst userProfileConfig = user?.userProfileMetadata ?? config;{isUserProfileEnabled && userProfileConfig ? (  <UserProfileFields config={userProfileConfig} />) : (  <>{*/ The other stuff */}</>)}```Would that still work?",x
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23509,1335763968,2023-09-25T11:38:37Z,js/apps/admin-ui/src/user/form-state.ts,"@@ -17,7 +17,9 @@ export function toUserFormFields(data: UserRepresentation): UserFormFields {  export function toUserRepresentation(data: UserFormFields): UserRepresentation {   const username = data.username?.trim();-  const attributes = keyValueToArray(data.attributes);+  const attributes = Array.isArray(data.attributes)","Ah I see, this is because we're calling the t[his piece of code](https://github.com/keycloak/keycloak/blob/c15753266ff7e86af82ff2a4a82fc26f0cbcc16f/js/apps/admin-ui/src/user/EditUser.tsx#L115) conditionally?",x
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/23509,1335773157,2023-09-25T11:47:50Z,js/apps/admin-ui/src/user/form-state.ts,"@@ -17,7 +17,9 @@ export function toUserFormFields(data: UserRepresentation): UserFormFields {  export function toUserRepresentation(data: UserFormFields): UserRepresentation {   const username = data.username?.trim();-  const attributes = keyValueToArray(data.attributes);+  const attributes = Array.isArray(data.attributes)","no, it's because the components that render the user profile already put the values in the right form e.g.```json{   ""test"": ""value""}```But we could replace the condition with `isUserProfileEnabled`",x
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23509,1335932931,2023-09-25T13:59:34Z,js/apps/admin-ui/src/user/form-state.ts,"@@ -17,7 +17,9 @@ export function toUserFormFields(data: UserRepresentation): UserFormFields {  export function toUserRepresentation(data: UserFormFields): UserRepresentation {   const username = data.username?.trim();-  const attributes = keyValueToArray(data.attributes);+  const attributes = Array.isArray(data.attributes)","I don't mind having a different value in the forms depending on whether user profile is enabled, but we should also ensure that the type is actually correct. In this case the type of `data.attributes` is either `{ key: string; value: string }[]` or `{  [key: string]: string | string[] }`, but the type does not reflect that.Personally, I think we're making a mistake not fixing the biggest problem here, which is that the returned value from the REST API is very cumbersome. Attributes should always be `{ key: string, value: string }` or even have a `type` so we don't [have to guess (wrongly)](https://github.com/keycloak/keycloak/blob/c15753266ff7e86af82ff2a4a82fc26f0cbcc16f/js/apps/admin-ui/src/user/UserProfileFields.tsx#L119-L120) what the original intention was.But this is not something we can or should fix right now, we just need to get this bug resolved. So the correct type for [`UserFormFields`](https://github.com/keycloak/keycloak/blob/a9fc29cac524fef8eab86f7b54854a20e3275a0f/js/apps/admin-ui/src/user/form-state.ts#L8-L10) should be:```tsexport type UserFormFields = Omit<  UserRepresentation,  ""attributes"" | ""userProfileMetadata""> & {  attributes?: KeyValueType[] | Record<string, string | string[]>;};```",x
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/23482,1336048715,2023-09-25T15:22:31Z,docs/documentation/securing_apps/topics/oidc/supported-grant-types.adoc,"@@ -28,10 +28,15 @@ browser history. You can somewhat mitigate this problem by using short expiratio  For more details, see the https://openid.net/specs/openid-connect-core-1_0.html#ImplicitFlowAuth[Implicit Flow] in the OpenID Connect specification. +Per current https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23#name-implicit-grant[OAuth 2.0 Security Best Current Practice] this flow should not be used.","```suggestionPer current https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23#name-implicit-grant[OAuth 2.0 Security Best Current Practice], this flow should not be used.```",x
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/23482,1336049593,2023-09-25T15:23:05Z,docs/documentation/securing_apps/topics/oidc/supported-grant-types.adoc,"@@ -28,10 +28,15 @@ browser history. You can somewhat mitigate this problem by using short expiratio  For more details, see the https://openid.net/specs/openid-connect-core-1_0.html#ImplicitFlowAuth[Implicit Flow] in the OpenID Connect specification. +Per current https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23#name-implicit-grant[OAuth 2.0 Security Best Current Practice] this flow should not be used.+This flow is removed from the future https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-09[OAuth 2.1 specification].+ [[_resource_owner_password_credentials_flow]] ==== Resource Owner Password Credentials -Resource Owner Password Credentials, referred to as Direct Grant in {project_name}, allows exchanging user credentials for tokens. Using this flow is not recommended unlesss it is essential. Examples where this flow could be useful are legacy applications and command-line interfaces.+Resource Owner Password Credentials, referred to as Direct Grant in {project_name}, allows exchanging user credentials for tokens.+Per current https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23#name-resource-owner-password-cre[OAuth 2.0 Security Best Practices]","```suggestionPer current https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-23#name-resource-owner-password-cre[OAuth 2.0 Security Best Practices],```",
546680,pskopek,https://api.github.com/repos/keycloak/keycloak/pulls/23512,1336930323,2023-09-26T09:39:25Z,set-version.sh,"@@ -2,6 +2,13 @@  NEW_VERSION=$1 +# Convert NPM version to semver compatible if needed+if [[ $NEW_VERSION =~ [0-9]+.[0-9]+.[0-9]+.[a-z] ]]; then+  NEW_NPM_VERSION=$(echo $NEW_VERSION | awk -F '.' '{ print $1"".""$2"".""$3 }').$(echo $NEW_VERSION | cut -d '.' -f 4 | sed 's/-/+/g')","This doesn't produce valid semantic version.E.g. 22.0.3.redhat-00001 -> 22.0.3.redhat+00001 Which is not valid semantic version. Valid would look like 22.0.3+redhat-00001(check here: https://regex101.com/r/ETSiwK/1)I suggest to use: NEW_NPM_VERSION=$(echo $NEW_VERSION | awk -F '.' '{ print $1"".""$2"".""$3""+""$4 }')",x
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23509,1337257246,2023-09-26T13:57:09Z,js/apps/admin-ui/src/user/UserForm.tsx,"@@ -93,12 +94,13 @@ export const UserForm = ({   const { realm: realmName } = useRealm();   const formatDate = useFormatDate();   const isFeatureEnabled = useIsFeatureEnabled();-+  const { config } = useUserProfile();","Yeah, this is something we're figuring out, as it's also highly dependent on your user role whether you can see this or not.",
51133,edewit,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1339545389,2023-09-28T05:26:00Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -203,14 +203,17 @@ export default function EditUser() {           </DropdownItem>,         ]}         onToggle={(value) =>-          save({ ...toUserFormFields(user), enabled: value })+          save({+            ...toUserFormFields(user, !!userProfileMetadata),+            enabled: value,+          })         }         isEnabled={user.enabled}       />        <PageSection variant=""light"" className=""pf-u-p-0"">         <UserProfileProvider>-          <FormProvider {...userForm}>+          <FormProvider {...form}>","Either we use the form as a parameter or we pass it in as an argument, here you do both. IMO using the `FormProvider` is a bit nicer",x
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/22112,1339596852,2023-09-28T06:31:33Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/integration/health/ReactiveHealthHandler.java,"@@ -0,0 +1,57 @@+/*+ * Copyright 2023 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.quarkus.runtime.integration.health;++import io.quarkus.smallrye.health.runtime.SmallRyeLivenessHandler;+import io.smallrye.health.SmallRyeHealth;+import io.smallrye.health.SmallRyeHealthReporter;+import io.smallrye.mutiny.Uni;+import io.vertx.core.Handler;+import io.vertx.ext.web.RoutingContext;++/**+ * This adds the possibility to have a non-blocking health handler in Quarkus.+ * <p>+ * Without a non-blocking health check, all liveness and readiness probes will enqueue in the worker thread pool. Under high load","Hi @sschu - thanks for commenting here. Infinispan has its own thread pool, and it works like this AFAIK: Keycloak / RESTEasy request: 1. Incoming request is dispatched by Quarkus in the Vert.x nonblocking event loop2. Handover of the request to RESTEasy, which uses for all blocking requests the Quarkus executor pool3. If the request processing needs data from a remote Infinispan, it will reach out to the remote Infinispan. While doing this, the Quarkus executor thread is still blocked4. The Infinispan processing will use its own threads in local and remote Infinispan  During rebalancing or node failures, the Infinispan handling will take longer due to timeouts and retries, and therefore the Quarkus executor threads will be blocked for a longer time. When the number of in-flight requests reaches the number of executor pool threads, the requests will be queued. As the default, Quarkus probes (as well as metrics) travel the same route: After being dispatched by the Vert.x event loop first, they are then handled by blocking handlers which run on the Quarkus executor pool. If they are queued, their results will exceed the Kubernetes probe timeout.This PR updates the readiness and liveness probes to use nonblocking handlers. If then all checks of the probe are non-blocking as well, the result can be assembled without using an executor thread, and thereby avoids the queueing. The liveness probe of Keycloak has as default no entries, so it will always be reactive. The readiness probe contains a check which attempts to prepare a non-blocking result when there are active DB connections, and falls back to a blocking check when there are none. Let me know if this resolves your question. ",
726590,Delawen,https://api.github.com/repos/keycloak/keycloak/pulls/23301,1339819566,2023-09-28T09:31:12Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/FlowTest.java,"@@ -315,6 +325,17 @@ public void addExecutionFlow() {          authMgmtResource.addExecutionFlow(""parent"", params);         assertAdminEvents.assertEvent(testRealmId, OperationType.CREATE, AdminEventPaths.authAddExecutionFlowPath(""parent""), params, ResourceType.AUTH_EXECUTION_FLOW);++        // add execution flow with alias that contains reserved characters+        params.put(""alias"", ""Child/of:browser"");+        try {+            authMgmtResource.addExecutionFlow(""parent"", params);","Wouldn't it be better to use some form of `assertThrows(ClientErrorException.class, ...) `?",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23574,1339872276,2023-09-28T10:10:53Z,themes/src/main/resources/theme/base/login/register.ftl,"@@ -104,6 +104,18 @@                             </span>                         </#if>                     </div>+                    <div class=""${properties.kcInputWrapperClass!}"" id=""password-entropy"" data-password-input=""password"" style=""display: none;"">+                        <div class=""progress"" style=""margin-bottom: 0; margin-top: 1px;"">+                            <div class=""progress-bar"" role=""progressbar"" aria-valuenow=""0"" aria-valuemin=""0"" aria-valuemax=""100"">","Nice, thanks for taking accessibility into account. I am not quite sure that a progress bar is the correct role though, as it is more intended for reporting progress on long-running tasks.Perhaps a more suitable role for this one would be the [`status` role](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/status_role), which is a live region that uses `polite`, and thus does not interrupt the user.```suggestion                            <div class=""progress-bar"" role=""status"">```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1339969348,2023-09-28T11:22:04Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -87,35 +87,35 @@ export default function EditUser() {   const sessionsTab = useTab(""sessions"");    useFetch(-    async () => {-      const [user, currentRealm, attackDetection] = await Promise.all([+    async () =>+      Promise.all([+        adminClient.realms.findOne({ realm: realmName }),         adminClient.users.findOne({ id: id!, userProfileMetadata: true }),-        adminClient.realms.findOne({ realm }),         adminClient.attackDetection.findOne({ id: id! }),-      ]);--      if (!user || !currentRealm || !attackDetection) {+        adminClient.users.getProfileMetadata({ realm: realmName }),",Would that contain the exact same data? @pedroigor,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1339976039,2023-09-28T11:27:35Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -87,35 +87,35 @@ export default function EditUser() {   const sessionsTab = useTab(""sessions"");    useFetch(-    async () => {-      const [user, currentRealm, attackDetection] = await Promise.all([+    async () =>+      Promise.all([+        adminClient.realms.findOne({ realm: realmName }),         adminClient.users.findOne({ id: id!, userProfileMetadata: true }),-        adminClient.realms.findOne({ realm }),         adminClient.attackDetection.findOne({ id: id! }),-      ]);--      if (!user || !currentRealm || !attackDetection) {+        adminClient.users.getProfileMetadata({ realm: realmName }),",@jonkoops The metadata is the same.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1339986950,2023-09-28T11:36:21Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -203,14 +203,17 @@ export default function EditUser() {           </DropdownItem>,         ]}         onToggle={(value) =>-          save({ ...toUserFormFields(user), enabled: value })+          save({+            ...toUserFormFields(user, !!userProfileMetadata),+            enabled: value,+          })         }         isEnabled={user.enabled}       />        <PageSection variant=""light"" className=""pf-u-p-0"">         <UserProfileProvider>-          <FormProvider {...userForm}>+          <FormProvider {...form}>","> Either we use the form as a parameter or we pass it in as an argumentAgreed, but I did not want to refactor all the forms under this provider in this PR as that would create significantly more code to review. > IMO using the `FormProvider` is a bit nicerI agree with you from a convenience perspective, it is a lot less verbose to use a context. However I disagree from a type-safety and maintenance perspective. The reason for that is when you use a context the form and it's value becomes loosely coupled from the form controls.For example, I can do the following that is perfectly valid:```tsxtype ParentForm = {  attributes: Record<string, string[]>;}const ParentWithForm =  () => {  const form = useForm();  return <FormProvider {...form}><ChildWithContext /></FormProvider>}type ChildForm = {  attributes: { key: string; value: string; }[];}const ChildWithContext =  {  const form = useFormContext();  // This will not give an error, even thought it is wrong.  // The parent form is expecting a different type.  form.setValue(""attributes"", [{ key: ""foo"", value: ""bar"" }]);}```If we pass the form down as a strongly typed prop instead, then it will suddenly not be possible to assign it to anything but the type that was specified at the root. Also it will prevent possible nested `FormProvider`s, which can cause conflicts with each other.So yeah, it  is more cumbersome, but it is also more maintainable long term, and I think that is more important than the DX in the short term. ",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1339988643,2023-09-28T11:37:48Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -87,35 +87,35 @@ export default function EditUser() {   const sessionsTab = useTab(""sessions"");    useFetch(-    async () => {-      const [user, currentRealm, attackDetection] = await Promise.all([+    async () =>+      Promise.all([+        adminClient.realms.findOne({ realm: realmName }),         adminClient.users.findOne({ id: id!, userProfileMetadata: true }),-        adminClient.realms.findOne({ realm }),         adminClient.attackDetection.findOne({ id: id! }),-      ]);--      if (!user || !currentRealm || !attackDetection) {+        adminClient.users.getProfileMetadata({ realm: realmName }),","Ok, I've changed this to use the data from the user instead :+1: ",
39240633,PhilKes,https://api.github.com/repos/keycloak/keycloak/pulls/23301,1342091248,2023-10-01T07:33:36Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/FlowTest.java,"@@ -315,6 +325,17 @@ public void addExecutionFlow() {          authMgmtResource.addExecutionFlow(""parent"", params);         assertAdminEvents.assertEvent(testRealmId, OperationType.CREATE, AdminEventPaths.authAddExecutionFlowPath(""parent""), params, ResourceType.AUTH_EXECUTION_FLOW);++        // add execution flow with alias that contains reserved characters+        params.put(""alias"", ""Child/of:browser"");+        try {+            authMgmtResource.addExecutionFlow(""parent"", params);","Thanks for your review @Delawen That would have been my first choice too, but I wanted to keep in-line with the way `ClientErrorException`s are handled in existing test cases, e.g.https://github.com/keycloak/keycloak/blob/6391651768def2e018de309fd02ffcbc426282e8/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/FlowTest.java#L378-L384I changed the tests to use `assertThrows` instead.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/22112,1342711687,2023-10-02T13:42:19Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/services/health/KeycloakReadyAsyncHealthCheck.java,"@@ -0,0 +1,108 @@+/*+ * Copyright 2020 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */+package org.keycloak.quarkus.runtime.services.health;++import io.agroal.api.AgroalDataSource;+import io.quarkus.agroal.runtime.health.DataSourceHealthCheck;+import io.smallrye.health.api.AsyncHealthCheck;+import io.smallrye.mutiny.Uni;+import io.smallrye.mutiny.infrastructure.Infrastructure;+import jakarta.annotation.PostConstruct;+import jakarta.enterprise.context.ApplicationScoped;+import jakarta.inject.Inject;+import org.eclipse.microprofile.health.HealthCheckResponse;+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;+import org.eclipse.microprofile.health.Readiness;++import java.time.Instant;+import java.time.ZoneId;+import java.time.format.DateTimeFormatter;+import java.util.concurrent.atomic.AtomicReference;++/**+ * Keycloak Healthcheck Readiness Probe.+ * <p>+ * Performs a hybrid between the passive and the active mode. If there are no healthy connections in the pool,+ * it invokes the standard <code>DataSourceHealthCheck</code> that creates a new connection and checks if it's valid.+ * <p>+ * While the check for healthy connections is non-blocking, the standard check is blocking, so it needs to be wrapped.+ * <p>+ * When NON_BLOCKING_PROBES is no longer behind a feature flag but the only option, it will replace the+ * {@link KeycloakReadyHealthCheck}.+ *+ * @see <a href=""https://github.com/keycloak/keycloak-community/pull/55"">Healthcheck API Design</a>+ */+@Readiness+@ApplicationScoped+public class KeycloakReadyAsyncHealthCheck implements AsyncHealthCheck {++    /** As the DataSourceHealthCheck doesn't exist as an application scoped bean,+    * create our own instance here which exposes the <code>init()</code> call for the delegate. */+    MyDataSourceHealthCheck delegate;++    private static class MyDataSourceHealthCheck extends DataSourceHealthCheck {+        @Override+        public void init() {+            super.init();+        }+    }++    @PostConstruct+    protected void init() {+        delegate = new MyDataSourceHealthCheck();+        delegate.init();+    }++    /**+     * Date formatter, the same as used by Quarkus. This enables users to quickly compare the date printed+     * by the probe with the logs.+     */+    static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(""yyyy-MM-dd HH:mm:ss,SSS"").withZone(ZoneId.systemDefault());++    @Inject+    AgroalDataSource agroalDataSource;++    AtomicReference<Instant> failingSince = new AtomicReference<>();++    @Override+    public Uni<HealthCheckResponse> call() {+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(""Keycloak database connections async health check"").up();+        long activeCount = agroalDataSource.getMetrics().activeCount();+        long invalidCount = agroalDataSource.getMetrics().invalidCount();+        if (activeCount < 1 || invalidCount > 0) {+            return Uni.createFrom().item(() -> {+                HealthCheckResponse activeCheckResult = delegate.call();+                if (activeCheckResult.getStatus() == HealthCheckResponse.Status.DOWN) {+                    builder.down();+                    Instant failingTime = failingSince.updateAndGet(this::createInstanceIfNeeded);+                    builder.withData(""Failing since"", DATE_FORMATTER.format(failingTime));+                }+                return builder.build();+            }).runSubscriptionOn(Infrastructure.getDefaultWorkerPool());+        } else {+            failingSince.set(null);+            return Uni.createFrom().item(builder.build());+        }+    }","```suggestion    public Uni<HealthCheckResponse> call() {        HealthCheckResponseBuilder builder = HealthCheckResponse.named(""Keycloak database connections async health check"").up();        long activeCount = agroalDataSource.getMetrics().activeCount();        long invalidCount = agroalDataSource.getMetrics().invalidCount();        if (activeCount < 1 || invalidCount > 0) {            return healthCheckFactory.callSync(() -> {                HealthCheckResponse activeCheckResult = delegate.call();                if (activeCheckResult.getStatus() == HealthCheckResponse.Status.DOWN) {                    builder.down();                    Instant failingTime = failingSince.updateAndGet(this::createInstanceIfNeeded);                    builder.withData(""Failing since"", DATE_FORMATTER.format(failingTime));                }                return builder.build();            });        } else {            failingSince.set(null);            return healthCheckFactory.callAsync(() -> Uni.createFrom().item(builder.build()));        }    }```",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/23517,1343822167,2023-10-03T09:44:22Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/ResetPasswordTest.java,"@@ -1143,34 +1140,6 @@ public void failResetPasswordServiceAccount() {         assertEquals(""Invalid username or password."", errorPage.getError());     } -    @Test-    public void resetPasswordLinkNewTabAndProperRedirectAccount() throws IOException {","Yes, exactly. Moreover, this test was not correct and it was relying on the old account console, which we already removed. The test ""accidentally"" passed before even if old account console was not present, but it did not had much sense as it was was displaying some error pages etc.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22585,1343925534,2023-10-03T11:08:25Z,docs/documentation/release_notes/topics/23_0_0.adoc,"@@ -13,3 +13,17 @@ the latest FAPI 2 draft specifications when communicating with your clients. Tha  Keycloak has preview for support for OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP). Thanks to https://github.com/tnorimat[Takashi Norimatsu] and https://github.com/dteleguin[Dmitry Telegin] for their contributions.++= kc.sh and shell metacharacters++The kc.sh no longer uses an additional shell eval on parameters and the environment variables JAVA_OPTS_APPEND and JAVA_ADD_OPENS, thus the continued use of double escaping/quoting will result in the parameter being misunderstood.  For example instead of ++```+bin/kc.sh start --db postgres --db-username keycloak --db-url ""\""jdbc:postgresql://localhost:5432/keycloak?ssl=false&connectTimeout=30\"""" --db-password keycloak --hostname localhost+```++Use a single escape:++```+bin/kc.sh start --db postgres --db-username keycloak --db-url ""jdbc:postgresql://localhost:5432/keycloak?ssl=false&connectTimeout=30"" --db-password keycloak --hostname localhost+```",This should probably be rather in the [upgrading guide](https://github.com/keycloak/keycloak/blob/f62a3a62fbf514e55c9c830410f7429b89b6f81d/docs/documentation/upgrading/topics/keycloak/changes-23_0_0.adoc).,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23667,1344444712,2023-10-03T17:01:38Z,js/apps/admin-ui/src/util.ts,"@@ -171,3 +171,17 @@ export const addTrailingSlash = (url: string) =>   url.endsWith(""/"") ? url : url + ""/"";  export const generateId = () => Math.floor(Math.random() * 1000);++export function generatePath<Path extends string>(+  originalPath: Path,+  params?: {+    [key: string]: string | null;+  },+): string {+  if (params)+    Object.entries(params).forEach(+      ([k, v]) => (params[k] = encodeURIComponent(v || """")),+    );+  //@ts-ignore as PathParam isn't an exported type+  return generateUnencodedPath(originalPath, params);+}","A couple of points here:1. Using the same name for the function as the library might cause future devs to accidentally import the one from the library, as the name is the same the IDE might autocomplete it, and it's easy to miss in review.2. In our case we always pass in `params`, so there is no need for it to be optional.3. Although React Router uses a value of `string | null` for each parameter we always pass in `string`, so we can omit the `null` fallback.4. Assigning `params[k]` in-place will mutate the original value value passed into the function, which might cause unwanted side effects. It would be better to create a copy and operate on that instead.5. We can avoid using a `@ts-ignore` here, as we only need to cast `params` to `any`.Putting that all together I think we'd be left with something like:```tsfunction generateEscapedPath<Path extends string>(  originalPath: Path,  params: Record<string, string>,): string {  const encodedParams = { ...params };  for (const [key, value] of Object.entries(encodedParams)) {    encodedParams[key] = encodeURIComponent(value);  }  // TODO: Fix type annotation once https://github.com/remix-run/react-router/pull/10719 is merged.  return generatePath<Path>(originalPath, encodedParams as any);}```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23686,1345498294,2023-10-04T09:31:39Z,js/libs/keycloak-admin-client/src/defs/authenticatorConfigInfoRepresentation.ts,"@@ -16,4 +16,5 @@ export interface ConfigPropertyRepresentation {   defaultValue?: any;   options?: string[];   secret?: boolean;+  required?: boolean;",Let's keep the naming consistent with what PatternFly expects.```suggestion  isRequired?: boolean;``````,
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/23686,1345537965,2023-10-04T10:01:56Z,js/libs/keycloak-admin-client/src/defs/authenticatorConfigInfoRepresentation.ts,"@@ -16,4 +16,5 @@ export interface ConfigPropertyRepresentation {   defaultValue?: any;   options?: string[];   secret?: boolean;+  required?: boolean;","@jonkoops Thanks for the review.Do you mean to change the attribute for the whole DTO on the server side? It'd break the naming conventions provided there. From my understanding, this should be in sync with the `ConfigPropertyRepresentation` DTO received from the server, right? Otherwise, the mapping between them would not be done correctly. Or can you elaborate on your suggestion? ",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23574,1345538688,2023-10-04T10:02:33Z,themes/src/main/resources/theme/base/login/register.ftl,"@@ -104,6 +104,17 @@                             </span>                         </#if>                     </div>+                    <div class=""${properties.kcInputWrapperClass!}"" id=""password-entropy"" data-password-input=""password"">+                        <div class=""progress"">+                            <div class=""progress-bar"" role=""status"" aria-valuenow=""0"" aria-valuemin=""0"" aria-valuemax=""100""","The `status` role doesn't understand the `value*` attributes, so they can be removed. As long as there is a human-readable text that is inside of the element it will be legible to screen readers.```suggestion                            <div class=""progress-bar"" role=""status""```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23574,1345540854,2023-10-04T10:04:11Z,themes/src/main/resources/theme/keycloak/login/resources/css/password-entropy.css,"@@ -0,0 +1,8 @@+#password-entropy {+    display: none;+}++#password-entropy > .progress {","There should be no need to use a child combinator here, using the class name should be more than specific enough.```suggestion#password-entropy .progress {```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23574,1345547096,2023-10-04T10:09:42Z,themes/src/main/resources/theme/base/login/resources/js/passwordEntropy.js,"@@ -0,0 +1,42 @@+const clamp = (number, min, max) => Math.max(min, Math.min(number, max));++const calculateEntropy = (password) => {+    let charSetSize = 0;+    if (/[a-z]/.test(password)) charSetSize += 26;+    if (/[A-Z]/.test(password)) charSetSize += 26;+    if (/[0-9]/.test(password)) charSetSize += 10;+    if (/\W|_/.test(password)) charSetSize += 32; // 149_878 available unicode chars+    return Math.log2(charSetSize ** password.length);+}++const checkEntropy = (entropyElement, password) =>  {+    if (!password.length) {+        entropyElement.style.display = ""none"";+        return;+    }++    const entropyStatus = entropyElement.children.item(0).children.item(0);++    // entropy source: https://www.baeldung.com/cs/password-entropy+    const entropy = calculateEntropy(password);++    // 00-24    poor password+    // 25-49    weak password+    // 50-74    good password+    // 75-100   strong password+    const rating = [entropyStatus.dataset.passwordPoor, entropyStatus.dataset.passwordWeak, entropyStatus.dataset.passwordGood, entropyStatus.dataset.passwordStrong];+    const ratingRange = 25;+    const ratingIndex = Math.trunc(entropy / ratingRange);+    const ratingClassNames = [""progress-bar-danger"", ""progress-bar-warning"", ""progress-bar-info"", ""progress-bar-success""];+    const clamped = clamp(ratingIndex, 0, rating.length - 1);++    ratingClassNames.forEach(name => entropyStatus.classList.remove(name));+    entropyStatus.innerText = rating[clamped];+    entropyStatus.classList.add(ratingClassNames[clamped]);+    entropyStatus.style.width = `${(clamped+1) * ratingRange}%`;+    entropyElement.style.display = ""block"";+}++const entropyElement = document.querySelector('#password-entropy');","Rather than using the `id` of the element I think we should be [doing the same](https://github.com/keycloak/keycloak/blob/ca2c5f688f03c0674eafd3368b93ab0762ad9b86/themes/src/main/resources/theme/base/login/resources/js/passwordVisibility.js#L14-L15) as we do for password visibility. Which is to use the `data` attribute to find the element on the page, and then bootstrapping all of the logic on that element.Alternatively, since we're already using modern JavaScript, we could go the extra mile and just splurge on making this a full-fledged [Web Component](https://developer.mozilla.org/en-US/docs/Web/API/Web_components).Thinking about it a bit more, I think Web Components might be a lot better of a harness than the sprinkles of JavaScript we've been doing. Also from a maintainability perspective.WDYT?",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23686,1345551863,2023-10-04T10:13:42Z,js/libs/keycloak-admin-client/src/defs/authenticatorConfigInfoRepresentation.ts,"@@ -16,4 +16,5 @@ export interface ConfigPropertyRepresentation {   defaultValue?: any;   options?: string[];   secret?: boolean;+  required?: boolean;","Ah, I did not notice this was a change to the representation, my bad. What I meant is that we should pass it around as `isRequired={required}` to React components, as there is already the convention for PatternFly to use the name `isRequired`.The representation here should remain unchanged, as we don't want to make changes to the API.",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1345584583,2023-10-04T10:40:14Z,js/libs/keycloak-admin-client/src/defs/userProfileConfig.ts,"@@ -10,7 +10,7 @@ export interface UserProfileAttribute {   validations?: Record<string, unknown>;   validators?: Record<string, unknown>;   annotations?: Record<string, unknown>;-  required?: UserProfileAttributeRequired;+  required?: boolean | UserProfileAttributeRequired;","You're right, it is a boolean.It is probably there because the interface was generated from a user profile configuration. The type exists on the server side to represent the configuration for mandatory/optional attributes and it is not exposed when querying the metadata. What you get is a calculated value based (true|false) at the end.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22585,1345791034,2023-10-04T13:22:41Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/containers/KeycloakQuarkusServerDeployableContainer.java,"@@ -176,6 +176,13 @@ protected List<String> configureArgs(List<String> args) {     private ProcessBuilder getProcessBuilder() {         Map<String, String> env = new HashMap<>();         String[] processCommands = getArgs(env).toArray(new String[0]);+        if (suiteContext.get().isAuthServerMigrationEnabled() && configuration.getImportFile() != null) {+            for (int i = 0; i < processCommands.length; i++) {+                if (processCommands[i].startsWith(""--db-url="")) {+                    processCommands[i]= ""--db-url=\"""" + processCommands[i].substring(9) + ""\"""";",I wonder if we're not hiding from the tests too much the fact that quotes need to be used.,
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/22585,1346074970,2023-10-04T15:28:46Z,testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/arquillian/containers/KeycloakQuarkusServerDeployableContainer.java,"@@ -176,6 +176,13 @@ protected List<String> configureArgs(List<String> args) {     private ProcessBuilder getProcessBuilder() {         Map<String, String> env = new HashMap<>();         String[] processCommands = getArgs(env).toArray(new String[0]);+        if (suiteContext.get().isAuthServerMigrationEnabled() && configuration.getImportFile() != null) {+            for (int i = 0; i < processCommands.length; i++) {+                if (processCommands[i].startsWith(""--db-url="")) {+                    processCommands[i]= ""--db-url=\"""" + processCommands[i].substring(9) + ""\"""";","@vmuzikar Yes, the migration tests first start an old version (IIRC it's 19 by default), then the current version to perform the upgrade, then execute the tests. The MSSQL db needs the quotes. So we are using both type of arguments in the same test (double quotes in 19, and no double quotes in current version). As @shawkins comments we can check the old version (<23 for example), but we need something similar to this. I wouldn't do something very complicated, if the migrations tests change we can also change this part.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23537,1346228979,2023-10-04T17:28:36Z,js/apps/admin-ui/src/user/EditUser.tsx,"@@ -203,14 +203,17 @@ export default function EditUser() {           </DropdownItem>,         ]}         onToggle={(value) =>-          save({ ...toUserFormFields(user), enabled: value })+          save({+            ...toUserFormFields(user, !!userProfileMetadata),+            enabled: value,+          })         }         isEnabled={user.enabled}       />        <PageSection variant=""light"" className=""pf-u-p-0"">         <UserProfileProvider>-          <FormProvider {...userForm}>+          <FormProvider {...form}>","Ah yes, my bad. I meant for the user profile fields. Doing all the other fields for the user would be a massive refactor that I don't want to get into right now.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1346963900,2023-10-05T07:53:23Z,services/src/main/java/org/keycloak/services/resources/account/AccountRestService.java,"@@ -490,9 +491,10 @@ public LinkedAccountsResource linkedAccounts() {     @GET     @NoCache     @Produces(MediaType.APPLICATION_JSON)+    //TODO GROUPS this isn't paginated","I vote for updating `AccountRestService` (and possibly account console) in a follow-up issue. This PR is already very big and hard to review properly. It is usually best to have as small PRs as possible and split things into separate PRs whenever possible due the easier review, less amount of changes needed in tests etc.",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/23560,1347079311,2023-10-05T09:17:23Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java,"@@ -74,7 +74,7 @@ public SqlStatement[] generateStatements(Database database) {         }         try {             // To check that the table already exists or not on which the index will be created.-            if (!SnapshotGeneratorFactory.getInstance()+            if (getTableName() == null || !SnapshotGeneratorFactory.getInstance()",It may happen that table name is not yet set in scenario when [`generateStatements`](https://github.com/keycloak/keycloak/blob/58131f1dccb7113cb708407d6cf90842216c8d00/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/CustomCreateIndexChange.java#L60) method is called from [`AbstractChange.supports`](https://github.com/liquibase/liquibase/blob/ae4f651d241c45f2d09d4c23d6da8a56446a6f17/liquibase-standard/src/main/java/liquibase/change/AbstractChange.java#L387) which is the case since this [change](https://github.com/liquibase/liquibase/pull/4476/files#diff-402d22cfe1bfa96a8a1ef2bc2210864d96082666359af99c266575781f40da89R109).,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23735,1347266326,2023-10-05T11:28:31Z,docs/documentation/release-details,,"This file was referencing NPM, but it seems that it was no longer used anywhere and the versions are incredibly outdated. This seems to be covered by other logic in the GitHub Actions, so I've chosen to remove it.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23735,1347282048,2023-10-05T11:37:28Z,prod-arguments.json,,"This file references some NPM related settings, but I could not find any usage of it. Presumably this is used for productionization, but perhaps it is no longer needed. I've removed this file, but I can restore it if needed.ping @iankko @ASzc @martin-kanis @drichtarik",
2271511,stianst,https://api.github.com/repos/keycloak/keycloak/pulls/22317,1347384947,2023-10-05T13:00:32Z,services/src/main/java/org/keycloak/services/resources/account/AccountLoader.java,"@@ -147,4 +149,12 @@ private ClientModel getAccountManagementClient(RealmModel realm) {         return client;     } +    private AccountResourceProvider getAccountResourceProvider(Theme theme) {+      try {+        if (theme.getProperties().containsKey(Theme.ACCOUNT_RESOURCE_PROVIDER_KEY)) {+          return session.getProvider(AccountResourceProvider.class, theme.getProperties().getProperty(Theme.ACCOUNT_RESOURCE_PROVIDER_KEY));+        }+      } catch (IOException ignore) {}+      return session.getProvider(AccountResourceProvider.class);+    }","Looking at this PR I can't figure out how the default account console provider is loaded. I would have expected this method to be:```String themeAccountProvider = theme.getProperties().containsKey(Theme.ACCOUNT_RESOURCE_PROVIDER_KEY);return themeAccountProvider != null ? session.getProvider(AccountResourceProvider.class, themeAccountProvider) : session.getProvider(AccountResourceProvider.class);```",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/23735,1347535723,2023-10-05T14:39:38Z,.github/actions/frontend-plugin-cache/action.yml,"@@ -0,0 +1,26 @@+name: Frontend Plugin Cache+description: Caches Node.js installation for the frontend-maven-plugin++runs:+  using: composite+  steps:+    - uses: actions/cache@v3+      name: Cache Node.js installation+      with:+        path: |+          node+        key: ${{ runner.os }}-frontend-plugin-node-${{ hashFiles('pom.xml') }}","For the maven-cache action, we're using a weekly cache key with no restore-key.This avoids too many caches, as `pom.xml`s change frequently, and restore-keys can make the caches grow with time. Would you consider changing this to weekly caches as well?With the Maven cache, we eventually added a `create-cache-if-it-doesnt-exist` parameter, as we would want to cache only the artifacts created in the build, and the re-use them in other workflows, as the other workflows download fewer dependencies, and would then upload only a subset of the information we want to cache. ",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/22877,1347795962,2023-10-05T18:00:30Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/user/profile/CustomUserProfileTest.java,"@@ -52,10 +54,12 @@ public void testCustomUserProfileProviderIsActive() {     }      private static void testCustomUserProfileProviderIsActive(KeycloakSession session) {-        DeclarativeUserProfileProvider provider = getDynamicUserProfileProvider(session);+        UserProfileProvider provider = getUserProfileProvider(session);         assertEquals(CustomUserProfileProvider.class.getName(), provider.getClass().getName());         assertTrue(provider instanceof  CustomUserProfileProvider);-        assertEquals(""custom-user-profile"", provider.getComponentModel().getProviderId());+        Optional<ComponentModel> component = getComponentModel(session);",@vramik We need to make sure the configuration is set before checking the component. We can add this:```provider.setConfiguration(UPConfigUtils.readDefaultConfig());```Sorry for not catching before.,
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/22877,1348624475,2023-10-06T11:55:58Z,services/src/main/java/org/keycloak/userprofile/DeclarativeUserProfileProvider.java,"@@ -151,16 +154,21 @@ protected UserProfileMetadata configureUserProfile(UserProfileMetadata metadata,             return decoratedMetadata;         } -        ComponentModel model = getComponentModelOrCreate(session);-        Map<UserProfileContext, UserProfileMetadata> metadataMap = model.getNote(PARSED_CONFIG_COMPONENT_KEY);+        ComponentModel component = getComponentModel().orElse(null);++        if (component == null) {+            return DEFAULT_METADATA.computeIfAbsent(context, (c) -> decorateUserProfileForCache(decoratedMetadata, defaultRawConfig));","This `computeIfAbsent` feeds data into a static final map `DEFAULT_METADATA`. The dependent data is from what I see dependent on the realm and user, and I don't see how much `DEFAULT_METADATA` can grow here, and how old entries are eventually cleared. ",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/22591,1348875170,2023-10-06T15:26:58Z,operator/src/test/java/org/keycloak/operator/testsuite/unit/PodTemplateTest.java,"@@ -92,9 +83,10 @@ public Map<String, String> podLabels() {          kc.setSpec(keycloakSpecBuilder.build()); -        var deployment = new KeycloakDeployment(null, config, kc, existingDeployment, ""dummy-admin"");+        Context<Keycloak> context = Mockito.mock(Context.class);+        Mockito.when(context.getSecondaryResource(StatefulSet.class)).thenReturn(Optional.ofNullable(existingDeployment));","Keycloak tries to stay away from Mockito. Even though it might make sense to use it here, we'd be creating a precedence for the project. :) Could we perhaps try keeping the previous approach, i.e. implement a custom class implementing the Context interface?",
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/22591,1348897636,2023-10-06T15:46:44Z,operator/src/test/java/org/keycloak/operator/testsuite/unit/PodTemplateTest.java,"@@ -92,9 +83,10 @@ public Map<String, String> podLabels() {          kc.setSpec(keycloakSpecBuilder.build()); -        var deployment = new KeycloakDeployment(null, config, kc, existingDeployment, ""dummy-admin"");+        Context<Keycloak> context = Mockito.mock(Context.class);+        Mockito.when(context.getSecondaryResource(StatefulSet.class)).thenReturn(Optional.ofNullable(existingDeployment));",> implement a custom class implementing the Context interface?Isn't that just boiler plate for the sake of saying that mockito won't be used?  Wouldn't it be better to just enforce some principled use of Mockito?,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23378,1349500660,2023-10-07T10:19:51Z,js/apps/admin-ui/src/realm-settings/LocalizationTab.tsx,"@@ -167,21 +174,24 @@ export const LocalizationTab = ({ save, realm }: LocalizationTabProps) => {       return { result };     },     ({ result }) => {-      const bundles = Object.entries(result).slice(first, first + max + 1);+      const bundles = Object.entries(result)+        .map<LocaleSpecificEntry>(([key, value]) => ({ key, value }))+        .sort((a, b) => a.key.localeCompare(b.key));",We have a [`useLocaleSort()` hook](https://github.com/keycloak/keycloak/blob/a65af2d25486e323c1e5ef415f65ceb8dbdc7e79/js/apps/admin-ui/src/utils/useLocaleSort.ts#L5) that can be used to determine the current user's locale and apply the sorting aware of those preferences.,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23793,1349675420,2023-10-08T10:43:32Z,services/src/main/resources/org/keycloak/protocol/oidc/endpoints/3p-cookies-step1.html,"@@ -5,15 +5,19 @@   </head>   <body>     <script type=""module"">-      // Check if the browser has granted us access to 3rd-party storage (such as cookies).-      const hasAccess = await hasStorageAccess();+      attemptCookie();","This function no longer exists, it should be calling `checkStorageAccess()` instead.```suggestion      checkStorageAccess();```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23667,1349679324,2023-10-08T11:12:46Z,js/apps/admin-ui/src/util.ts,"@@ -171,3 +171,18 @@ export const addTrailingSlash = (url: string) =>   url.endsWith(""/"") ? url : url + ""/"";  export const generateId = () => Math.floor(Math.random() * 1000);++type PathParam = { [key: string]: string | null };++export function generateUnencodedPath<Path extends string>(+  originalPath: Path,+  params: PathParam,+): string {+  const encodedParams: PathParam = {};+  Object.entries(params).forEach(+    ([k, v]) => (encodedParams[k] = encodeURIComponent(v || """")),","If we are not handling `null` values any longer we can omit the fallback here.```suggestion    ([k, v]) => (encodedParams[k] = encodeURIComponent(v)),```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1349688553,2023-10-08T12:24:23Z,js/apps/account-ui/src/resources/Resources.tsx,"@@ -18,12 +18,14 @@ const Resources = () => {         unmountOnExit       >         <Tab+          data-testId=""myResources""","Haven't seen this casing convention before. Can we keep it the consistent with the other test ids? (same goes for the others in this PR).```suggestion          data-testid=""myResources""```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1349688779,2023-10-08T12:26:08Z,js/apps/account-ui/src/resources/ShareTheResource.tsx,"@@ -138,7 +138,7 @@ export const ShareTheResource = ({           label={t(""shareUser"")}           type=""string""           helperTextInvalid={errors.usernames?.message}-          fieldId=""users""+          fielddata-testId=""users""","This doesn't seem correct. Perhaps this was accidentally replaced?```suggestion          fieldId=""users""```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23517,1349748585,2023-10-08T17:15:50Z,themes/src/main/resources/theme/base/login/resources/js/authChecker.js,"@@ -0,0 +1,76 @@++function kcAuthChecker() {+    var authChecker = this;++    // How often to check if KEYCLOAK_SESSION cookie was added in the other browser tab?+    var checkIntervalMillisecs = 2000;++    // 1 - unknown state or KEYCLOAK_SESSION present since beginning, 2 - cookie KEYCLOAK_SESSION not present, 3 - cookie KEYCLOAK_SESSION present after it+    // was not present before (possible to move here from state 2, but not from 1. Reason are ""re-authentication"" scenarios where we want login screens displayed even if SSO cookie exists)+    var sessionCookieState = 1;++     function setupTimer(authSessionId, tabId, loginRestartUrl) {+        setTimeout(function() {+            authChecker.checkCookiesAndSetTimer(authSessionId, tabId, loginRestartUrl);+        }, checkIntervalMillisecs);+    }++    authChecker.checkCookiesAndSetTimer = function(authSessionId, tabId, loginRestartUrl) {+        var sessionCookie = getCookieByName(""KEYCLOAK_SESSION"");+        if (sessionCookie) {+            if (sessionCookieState == 2) {+                sessionCookieState = 3;+                console.log(""kcAuthChecker: Cookie KEYCLOAK_SESSION added"");+            }+        } else {+            if (sessionCookieState == 1) {+                sessionCookieState = 2;+                console.log(""kcAuthChecker: Cookie KEYCLOAK_SESSION not present"");+                document.kcAuthCheckerReady = true; // For tests+            }+        }++        if (sessionCookieState == 3) {+            checkAuthSession(authSessionId, tabId, loginRestartUrl);+        } else {+            setupTimer(authSessionId, tabId, loginRestartUrl);+        }+    }++    function checkAuthSession(authSessionId, tabId, loginRestartUrl) {+        var authCookieStr = getCookieByName(""KC_AUTH_STATE"");+        if (authCookieStr) {+            var authCookie = JSON.parse(authCookieStr);+            if (authSessionId === authCookie.authSessionId && authCookie.remainingTabs.indexOf(tabId) > -1) {+                loginRestartUrl = htmlDecode(loginRestartUrl);+                window.location.href = loginRestartUrl;+            } else {+                console.log(""kcAuthChecker: Cookie KC_AUTH_STATE present, but value does not match with authentication session parameters in current browser."");+            }+        } else {+            console.log(""kcAuthChecker: Cookie KC_AUTH_STATE not present"");+        }+    }++    function htmlDecode(input) {+        var doc = new DOMParser().parseFromString(input, ""text/html"");+        return doc.documentElement.textContent;+    }++    function getCookieByName(name) {+        const cookies = {};+        var cookiesVal = document.cookie.split("";"");++        cookiesVal.forEach(cookieFunc);++        function cookieFunc(cookieVal) {+            var cookieParsed = cookieVal.split(""="");+            if (cookieParsed.length == 2) {+                cookies[cookieParsed[0].trim()] = cookieParsed[1].trim();+            }+        }++        return cookies[name];+    }","If you want a slightly more modern implementation of this function, I've already written pretty similar code for the [Session Status implementation](https://github.com/keycloak/keycloak/blob/990a54dce5783dd7890c60e723010b55104089aa/services/src/main/resources/org/keycloak/protocol/oidc/endpoints/login-status-iframe.html#L93-L102).",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/23826,1349955439,2023-10-09T07:44:01Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenIntrospectionTest.java,"@@ -322,7 +349,26 @@ public void testIntrospectAccessToken() throws Exception {         AbstractOIDCScopeTest.assertScopes(""openid email profile"", rep.getScope());     } +    @Test+    public void testIntrospectAccessTokenWithoutScope() throws Exception {+        oauth.realm(""realmWithoutScopes"").clientId(""no-scope"").openid(false).doLogin(""test-user@localhost"", ""password"");","Just a small detail, but is it possible to avoid creation of new realm, but instead just update existing ""test"" realm and possibly create some new client without scopes in it (and then cleanup this client afterwards etc)? Creation of new realm has some overhead and makes a test a bit longer to execute than necessary.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/23811,1350134765,2023-10-09T10:38:47Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakDistConfigurator.java,"@@ -86,6 +87,9 @@ void configureHostname() {                 .mapOption(""hostname-admin-url"", HostnameSpec::getAdminUrl)                 .mapOption(""hostname-strict"", HostnameSpec::isStrict)                 .mapOption(""hostname-strict-backchannel"", HostnameSpec::isStrictBackchannel);+        optionMapper(Function.identity())+                .mapOption(""proxy"", kc -> (!CRDUtils.isTlsConfigured(kc)+                        && KeycloakIngressDependentResource.isOpenshiftDefaultIngressEnabled(kc)) ? ""edge"" : null);",This will trigger a `You need to specify these fields as the first-class citizen of the CR` warning if someone tries to change proxy settings via additionalOptions. We don't have (and for now don't want) a first-class citizen `proxy` field since we might not need it at all soon after the possible hostname config redesign.,
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/23811,1350221068,2023-10-09T12:08:18Z,operator/src/main/java/org/keycloak/operator/controllers/KeycloakDistConfigurator.java,"@@ -86,6 +87,9 @@ void configureHostname() {                 .mapOption(""hostname-admin-url"", HostnameSpec::getAdminUrl)                 .mapOption(""hostname-strict"", HostnameSpec::isStrict)                 .mapOption(""hostname-strict-backchannel"", HostnameSpec::isStrictBackchannel);+        optionMapper(Function.identity())+                .mapOption(""proxy"", kc -> (!CRDUtils.isTlsConfigured(kc)+                        && KeycloakIngressDependentResource.isOpenshiftDefaultIngressEnabled(kc)) ? ""edge"" : null);","> We don't have (and for now don't want) a first-class citizen proxy field since we might not need it at all soon after the possible hostname config redesign.Right, it should be a ""second class"" or inferred setting - it can be moved to a lower priority than additionalOptions.  In this particular case though the only valid setting for proxy would be edge - any other setting would be invalid, so perhaps as second class there could also be validation.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/22585,1350366011,2023-10-09T14:13:35Z,quarkus/dist/src/main/content/bin/kc.sh,"@@ -61,10 +64,16 @@ do           break           ;;       *)+          OPT=$(esceval ""$1"")           case ""$1"" in             start-dev) CONFIG_ARGS=""$CONFIG_ARGS --profile=dev $1"";;-            -D*) SERVER_OPTS=""$SERVER_OPTS $1"";;-            *) CONFIG_ARGS=""$CONFIG_ARGS $1"";;+            -D*) SERVER_OPTS=""$SERVER_OPTS ${OPT}"";;+            *) case ""$1"" in+                 --optimized | --help | --help-all | -h) PRE_BUILD=false;;","> By the conclusion in #23071 we may not need to track --help, --help-all, nor -h in the shell scripts, or for consistency should --show-config be added? @mabartos WDYT?@shawkins @vmuzikar Yep, that's the question. Both variants might be a little bit controversial. It's true we do not need to track the `help` and `show-config` options in the script as they will not execute the augmentation phase due to this[1]. However, if they're not specified here, two processes are created. The first one, which is supposed to be for the 'pre-build', that will exit almost immediately, and then the second one, which is the application process itself. Comparison of both approaches:1) Specify the options here   **+** No additional process is created   **-**  Worse maintainability2) Do NOT specify the options here   **-** Additional process is created   **+**  Better maintainabilityI'm kinda leaning towards option 2) for now, as these scripts are already quite messy. As all the `help` and `show-config` are terminal options, we do not need to care much about the performance. As I've mentioned, the process is quickly killed and does not consume resources in some big way. Thus, I prefer maintainability in this case.**Future consideration:**I don't like our execution scripts due to multiple reasons. The first one is described above, and the other is that I think these scripts should only manage the system stuff, not any comprehensive app logic. I'd even prefer to get rid of checking the `build`, `--optimized`, `kc.config.build-and-exit`, `kc.config.built` options in these scripts and rather move the handling them to the app logic. But we can discuss details elsewhere as it's out of the scope of this PR.    [1] https://github.com/keycloak/keycloak/blob/a7d082e390ca128a44ad9e6ec6f5b8d2bfacfd0b/quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java#L130",
3024176,Mobe91,https://api.github.com/repos/keycloak/keycloak/pulls/23826,1350802057,2023-10-09T21:30:08Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenIntrospectionTest.java,"@@ -322,7 +349,26 @@ public void testIntrospectAccessToken() throws Exception {         AbstractOIDCScopeTest.assertScopes(""openid email profile"", rep.getScope());     } +    @Test+    public void testIntrospectAccessTokenWithoutScope() throws Exception {+        oauth.realm(""realmWithoutScopes"").clientId(""no-scope"").openid(false).doLogin(""test-user@localhost"", ""password"");","I actually asked about this in the [Keycloak Slack channel](https://cloud-native.slack.com/archives/C056HC17KK9/p1696537271544279) and the answer was that creating a new realm is the simplest approach.The problem is that if I apply this modification before importing the test realm it would apply to all tests and this would fail other tests (I tried this). So I would have to somehow conditionally apply this modification for only this test case or extract this one testcase into a new test class. Not so nice I think...Alternatively, I could try to update the already imported realm as part of the test case using the adminClient - I have not explored this option yet. Is this what you mean?",
68421193,artur-baltabayev,https://api.github.com/repos/keycloak/keycloak/pulls/23378,1352560571,2023-10-10T13:48:49Z,js/apps/admin-ui/src/realm-settings/LocalizationTab.tsx,"@@ -167,21 +174,24 @@ export const LocalizationTab = ({ save, realm }: LocalizationTabProps) => {       return { result };     },     ({ result }) => {-      const bundles = Object.entries(result).slice(first, first + max + 1);+      const bundles = Object.entries(result)+        .map<LocaleSpecificEntry>(([key, value]) => ({ key, value }))+        .sort((a, b) => a.key.localeCompare(b.key));","@ahus1 I replaced the logic to use the [useLocaleSort() hook](https://github.com/keycloak/keycloak/blob/a65af2d25486e323c1e5ef415f65ceb8dbdc7e79/js/apps/admin-ui/src/utils/useLocaleSort.ts#L5) suggested by @jonkoops and added the ""slice"" operation back in. From my initial testing it now works as expected.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/23826,1356380874,2023-10-12T07:22:36Z,testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/oauth/TokenIntrospectionTest.java,"@@ -322,7 +349,26 @@ public void testIntrospectAccessToken() throws Exception {         AbstractOIDCScopeTest.assertScopes(""openid email profile"", rep.getScope());     } +    @Test+    public void testIntrospectAccessTokenWithoutScope() throws Exception {+        oauth.realm(""realmWithoutScopes"").clientId(""no-scope"").openid(false).doLogin(""test-user@localhost"", ""password"");","Yes, exactly. That is what I meant. The ideal is, that if some test needs something, it can be set at the beginning of the test method and then reverted at the end (to not affect other test methods, which rely on the ""default"" behaviour). We use this approach on many places. For instance this method: https://github.com/keycloak/keycloak/blob/22.0.4/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginTest.java#L181-L202This is usually sufficient and more effective than always creating new realm, which is a bit time consuming.",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/23797,1357072375,2023-10-12T16:24:31Z,quarkus/runtime/src/main/java/org/keycloak/quarkus/runtime/cli/Picocli.java,"@@ -225,6 +234,59 @@ private static boolean hasProviderChanges() {         return false;     } +    /**+     * validate the expected values of non-cli properties+     *+     * @param cliArgs+     * @param abstractCommand+     */+    public static void validateNonCliConfig(List<String> cliArgs, AbstractCommand abstractCommand) {+        IncludeOptions options = getIncludeOptions(cliArgs, abstractCommand, abstractCommand.getName());++        if (!options.includeBuildTime && !options.includeRuntime) {+            return;+        }++        for (OptionCategory category : abstractCommand.getOptionCategories()) {+            List<PropertyMapper> mappers = new ArrayList<>();+            Optional.ofNullable(PropertyMappers.getRuntimeMappers().get(category)).ifPresent(mappers::addAll);+            Optional.ofNullable(PropertyMappers.getBuildTimeMappers().get(category)).ifPresent(mappers::addAll);+            for (PropertyMapper mapper : mappers) {+                // bypass the PropertyMappingInterceptor - the transformations may cause unexpected errors+                String value = null;+                ConfigSource configSource = null;+                for (ConfigSource cs : getConfig().getConfigSources()) {+                    if (cs.getOrdinal() < 300) {+                        break; // don't consider anything below standard env properties+                    }+                    value = cs.getValue(mapper.getFrom());+                    if (value != null) {+                        configSource = cs;+                        break;+                    }+                }++                if (value == null) {+                    continue;+                }++                if (mapper.isBuildTime() && !options.includeBuildTime) {+                    // TODO for cli this is treated as unknown+                    continue;+                }+                if (mapper.isRunTime() && !options.includeRuntime) {+                    // TODO for cli this is treated as unknown+                    continue;+                }++                if (!PropertyMapperParameterConsumer.isExpectedValue(mapper.getExpectedValues(), value)) {+                    throw new NonCliPropertyException(PropertyMapperParameterConsumer.getErrorMessage(mapper.getFrom(),+                            value, mapper.getExpectedValues(), mapper.getExpectedValues()) + "". From ConfigSource "" + configSource.getName());+                }+            }","I'm not 100 % happy that we need to access config sources directly but I guess there's no other way if we want to get ""unprocessed"" value skipping the whole interceptor chain.",
1223965,mposolda,https://api.github.com/repos/keycloak/keycloak/pulls/22148,1358029370,2023-10-13T09:34:43Z,testsuite/integration-arquillian/tests/base/src/test/resources/mapper-test/testrealm.json,"@@ -0,0 +1,691 @@+{","Is it possible to remove this file from your PR and make sure that the Lightweight token test is based on the default file from `testsuite/integration-arquillian/tests/base/src/test/resources/testrealm.json` ? It looks that there are almost no changes between your file and the basic testsuite file. If any modifications are needed in the test, it is possible to either add them to the `LightWeightAccessTokenTest.addTestRealms` method (you already did some modifications here) or use admin client and update before/after particular test methods.Sorry I missed this in previous reviews (if it was present). Having many various `testrealm-*.json` files means bigger work in the future when some testsuite maintenance is needed, so it is good to avoid adding more such files unless really needed.",
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/17215,1358216887,2023-10-13T12:46:06Z,services/src/main/java/org/keycloak/jose/jwk/ServerJWKBuilder.java,"@@ -0,0 +1,121 @@+/*+ * Copyright 2023 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.jose.jwk;++import java.math.BigInteger;+import java.security.Key;+import java.security.interfaces.EdECPublicKey;+import java.security.spec.EdECPoint;+import java.util.Arrays;+import java.util.Optional;++import org.keycloak.common.util.Base64Url;+import org.keycloak.common.util.KeyUtils;+import org.keycloak.crypto.Algorithm;+import org.keycloak.crypto.KeyType;+import org.keycloak.crypto.KeyUse;++/**+ * @author <a href=""mailto:takashi.norimatsu.ws@hitachi.com"">Takashi Norimatsu</a>+ */+public class ServerJWKBuilder extends JWKBuilder {",I see this extension is just because core should maintain JDK-8 compatibility. But I'm in favor of using a multi-release here. It's simpler and I think it's good that anyone using a modern JDK can benefit of the new EdDSA keys.A multi-release example is this commit 025778fe9c745316f80b53fe3052aeb314e868ef for example.We can create abstract classes `AbstractJWKBuilder` and `AbstractJWKParser` and extend two different real `JWKBuilder` and `JWKParser` for 8 and 16 (I think `EdECPublicKey` was introduced in 16). Using multi-release avoids all this `Server*` classes.WDYT? Or do you have other reasons to create this server classes?,
26901232,rmartinc,https://api.github.com/repos/keycloak/keycloak/pulls/17215,1358220955,2023-10-13T12:48:35Z,services/src/main/java/org/keycloak/utils/ServerJWKSUtils.java,"@@ -0,0 +1,97 @@+/*+ * Copyright 2023 Red Hat, Inc. and/or its affiliates+ * and other contributors as indicated by the @author tags.+ *+ * Licensed under the Apache License, Version 2.0 (the ""License"");+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ * http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an ""AS IS"" BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++package org.keycloak.utils;++import java.security.PublicKey;+import java.util.ArrayList;+import java.util.List;+import java.util.Map;+import java.util.stream.Collectors;++import org.jboss.logging.Logger;+import org.keycloak.crypto.KeyUse;+import org.keycloak.crypto.KeyWrapper;+import org.keycloak.crypto.PublicKeysWrapper;+import org.keycloak.jose.jwk.JSONWebKeySet;+import org.keycloak.jose.jwk.JWK;+import org.keycloak.jose.jwk.ServerJWKParser;+import org.keycloak.util.JWKSUtils;++/**+ * @author <a href=""mailto:takashi.norimatsu.ws@hitachi.com"">Takashi Norimatsu</a>+ */+public class ServerJWKSUtils {",If we decide to use multi-release this is not needed and you can use normal `JWKSUtils` class.,
44531564,valerii15298,https://api.github.com/repos/keycloak/keycloak/pulls/23875,1359375229,2023-10-14T13:10:29Z,js/libs/keycloak-admin-client/src/utils/fetchWithError.ts,"@@ -1,8 +1,19 @@-export type NetworkErrorOptions = { response: Response; responseData: unknown };+type ResponseData =+  | string+  | number+  | boolean+  | null+  | ResponseData[]+  | { [key: string]: ResponseData };++export type NetworkErrorOptions = {+  response: Response;+  responseData: ResponseData;+};  export class NetworkError extends Error {   response: Response;-  responseData: unknown;+  responseData: ResponseData;","Maybe you are right. I do not think it is the most critical thing compared to others.The reasons why I proposed it is because previous version of keycloak had very different error handling.And basically you do not know if you can use `JSON.stringify(responseData)`, who knows if responseData has circular dependencies, so for my case I needed to read source code to understand how can I use `responseData`. Does it contain methods or functions inside? Is it safe to serialize?For me personally it was quite crucial because that was pain point for quite a while when working on error handling and logging using this library. Now I just use assertion `... as JsonValue` imported from `type-fest` the same as in this PR basically and adds the clarity of what type the responseData.Though I would like to have it natively in the library that responseData is serializable, but my custom solution above also solves this problem and also I do not know how others use it, so feel free to close this PR",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23735,1360464431,2023-10-16T10:38:20Z,.github/actions/frontend-plugin-cache/action.yml,"@@ -0,0 +1,26 @@+name: Frontend Plugin Cache+description: Caches Node.js installation for the frontend-maven-plugin++runs:+  using: composite+  steps:+    - uses: actions/cache@v3+      name: Cache Node.js installation+      with:+        path: |+          node+        key: ${{ runner.os }}-frontend-plugin-node-${{ hashFiles('pom.xml') }}","In this case it was only referencing the root POM, but I am really only interested in change to the Node.js and PNPM versions. I've changed this so the cache is only restored if `node.version` and `pnpm.version` match. This should also remove the need to keep weekly caches, as it's much more fine grained already.> With the Maven cache, we eventually added a `create-cache-if-it-doesnt-exist` parameter, as we would want to cache only the artifacts created in the build, and the re-use them in other workflows, as the other workflows download fewer dependencies, and would then upload only a subset of the information we want to cache.Mhhh, yeah I wonder if this needs/should be done for PNPM dependencies. We can always optimize this later if it causes trouble.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1360773312,2023-10-16T14:42:55Z,js/apps/account-ui/src/resources/ResourcesTab.tsx,"@@ -166,6 +166,7 @@ export const ResourcesTab = ({ isShared = false }: ResourcesTabProps) => {           >             <Tr>               <Td+                data-testId={`expand-${resource.name}`}",```suggestion                data-testid={`expand-${resource.name}`}```,
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1360773888,2023-10-16T14:43:11Z,js/apps/account-ui/src/resources/ShareTheResource.tsx,"@@ -121,7 +121,7 @@ export const ShareTheResource = ({         <Button           key=""confirm""           variant=""primary""-          id=""done""+          data-testId=""done""","```suggestion          data-testid=""done""```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1360774266,2023-10-16T14:43:22Z,js/apps/account-ui/src/resources/ShareTheResource.tsx,"@@ -147,6 +147,7 @@ export const ShareTheResource = ({           <InputGroup>             <KeycloakTextInput               id=""users""+              data-testId=""users""","```suggestion              data-testid=""users""```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1360774564,2023-10-16T14:43:29Z,js/apps/account-ui/src/resources/ShareTheResource.tsx,"@@ -160,7 +161,7 @@ export const ShareTheResource = ({             <Button               key=""add-user""               variant=""primary""-              id=""add""+              data-testId=""add""","```suggestion              data-testid=""add""```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23706,1360775039,2023-10-16T14:43:44Z,js/apps/account-ui/src/resources/SharedWith.tsx,"@@ -6,8 +6,10 @@ type SharedWithProps = {   permissions?: Permission[]; }; -export const SharedWith = ({ permissions: p = [] }: SharedWithProps) => {-  return (+export const SharedWith = ({ permissions: p = [] }: SharedWithProps) => (+  <div+    data-testId={`shared-with-${p.length ? p.map((e) => e.username) : ""none""}`}","```suggestion    data-testid={`shared-with-${p.length ? p.map((e) => e.username) : ""none""}`}```",
13906855,vmuzikar,https://api.github.com/repos/keycloak/keycloak/pulls/24018,1361924815,2023-10-17T11:00:46Z,operator/src/main/resources/application.properties,,Do we also need to change the name of the env var here?https://github.com/keycloak/keycloak/blob/5cab2a58d7a857e152f2b6d667b13d033bf88c7f/operator/src/main/resources/application.properties#L11I.e. instead that have```quarkus.kubernetes.env.vars.related-image-keycloak=${operator.keycloak.image}```This variable affects also the env var name in resulting CSV.,
2475669,shawkins,https://api.github.com/repos/keycloak/keycloak/pulls/24018,1361934198,2023-10-17T11:09:38Z,operator/src/main/resources/application.properties,,"That env is for use with our org.keycloak.operator.Config class, it should stay operator-keycloak-image to match the existing method name.",
38039883,mabartos,https://api.github.com/repos/keycloak/keycloak/pulls/24018,1361945630,2023-10-17T11:20:28Z,operator/src/main/resources/application.properties,"@@ -4,7 +4,7 @@ quarkus.docker.dockerfile-jvm-path=Dockerfile quarkus.operator-sdk.crd.validate=false  # Operator config-operator.keycloak.image=quay.io/keycloak/keycloak:nightly+operator.keycloak.image=${RELATED_IMAGE_KEYCLOAK:quay.io/keycloak/keycloak:nightly}",```suggestionoperator.keycloak.image=${RELATED_KEYCLOAK_IMAGE:quay.io/keycloak/keycloak:nightly}```Nitpick: Would be good to keep some sort of convention to the naming. WDYT?,
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/24025,1362065788,2023-10-17T12:53:29Z,services/src/main/java/org/keycloak/authentication/forms/RegistrationFormsHelper.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2023 Red Hat, Inc. and/or its affiliates+ *  and other contributors as indicated by the @author tags.+ *+ *  Licensed under the Apache License, Version 2.0 (the ""License"");+ *  you may not use this file except in compliance with the License.+ *  You may obtain a copy of the License at+ *+ *  http://www.apache.org/licenses/LICENSE-2.0+ *+ *  Unless required by applicable law or agreed to in writing, software+ *  distributed under the License is distributed on an ""AS IS"" BASIS,+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *+ *  See the License for the specific language governing permissions and+ *  limitations under the License.+ *+ */++package org.keycloak.authentication.forms;++import jakarta.ws.rs.core.MultivaluedHashMap;+import jakarta.ws.rs.core.MultivaluedMap;+import org.keycloak.authentication.FormContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.userprofile.UserProfile;+import org.keycloak.userprofile.UserProfileContext;+import org.keycloak.userprofile.UserProfileProvider;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class RegistrationFormsHelper {","I'm not 100% sure if we should filter attributes outside the user profile. The idea is to actually centralize how they are handled.As you mentioned, we are only accepting custom attributes from being recognized by the user profile engine. None of our attributes should be using the `user.attributes` prefix. There is a test now covering this behavior too.But if you really want to blacklist those password-related attributes, I think we should do it on the provider side.Wdyt?",
1897897,vramik,https://api.github.com/repos/keycloak/keycloak/pulls/24053,1362264232,2023-10-17T14:51:53Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate22_0_0_RemoveRhssoThemes.java,"@@ -43,10 +43,11 @@ protected void generateStatementsImpl() throws CustomChangeException {                 .addWhereParameter(""rh-sso""));         // remove account theme for realms         statements.add(new UpdateStatement(null, null, database.correctObjectName(""REALM"", Table.class))-                .addNewColumnValue(""ACCOUNT_THEME"", null)-                .setWhereClause(""ACCOUNT_THEME=? OR ACCOUNT_THEME=?"")+                .addNewColumnValue(""ACCOUNT_THEME"", ""keycloak.v2"")+                .setWhereClause(""ACCOUNT_THEME=? OR ACCOUNT_THEME=? OR ACCOUNT_THEME=?"")                 .addWhereParameter(""rh-sso"")-                .addWhereParameter(""rh-sso.v2""));+                .addWhereParameter(""rh-sso.v2"")","> I removed the use of the constant from services. This avoids a dependency, and at the same time this migration should migrate a specific value that is now current, and should not change when someone decides to change the value of the constant.@ahus1 thank you> I'm a bit worried to see an existing changeset which was included in 22.0.0 already change here. Does liquibase calculate the changeset hashes based on the actual SQL generated here?According to local testing it doesn't seem so. When I start Keycloak 22.0.4 e.g. with postgres db, then stop it and then start Keycloak with this change it doesn't throw any exceptions and I can see that last `EXECUTED` changeset in the `databasechangelog` table is the on with id `22.0.0-17484`. > Can you provide more details why this change was necessaryThe aim is to make migration consistent for both when migrating data already present in the database and when migrating a realm exported in previous versions of keycloak.As far as I saw there was an [PR](https://github.com/keycloak/keycloak/pull/19963) which aimed to remove `rh-sso` and `rh-sso.v2` themes. And then another one which removed old account console: https://github.com/keycloak/keycloak/pull/21098/files#diff-42324cb8460623d9089f7e7620891a25778bcdc32c6fa73ab1ccc4f3c8842454R72-R74It seems to me that desired outcome is to combine the two and this change aims to achieve it. It might be cleaner to introduce new changelog with this change. ",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/23918,1362385232,2023-10-17T16:05:11Z,js/apps/keycloak-server/package.json,"@@ -3,7 +3,9 @@   ""type"": ""module"",   ""scripts"": {     ""start"": ""wireit"",-    ""clear-data"": ""rm -r ./server/data""+    ""local"": ""wireit"",+    ""clear-data"": ""rm -r ./server/data"",+    ""clear-server"": ""rm -r ./server""","Never been a big fan of this naming convention, perhaps we can do the following?```suggestion    ""delete-data"": ""rm -r ./server/data"",    ""delete-server"": ""rm -r ./server""```WDYT?",
355702,sguilhen,https://api.github.com/repos/keycloak/keycloak/pulls/24053,1362386832,2023-10-17T16:06:38Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate22_0_0_RemoveRhssoThemes.java,"@@ -43,10 +43,11 @@ protected void generateStatementsImpl() throws CustomChangeException {                 .addWhereParameter(""rh-sso""));         // remove account theme for realms         statements.add(new UpdateStatement(null, null, database.correctObjectName(""REALM"", Table.class))-                .addNewColumnValue(""ACCOUNT_THEME"", null)-                .setWhereClause(""ACCOUNT_THEME=? OR ACCOUNT_THEME=?"")+                .addNewColumnValue(""ACCOUNT_THEME"", ""keycloak.v2"")+                .setWhereClause(""ACCOUNT_THEME=? OR ACCOUNT_THEME=? OR ACCOUNT_THEME=?"")                 .addWhereParameter(""rh-sso"")-                .addWhereParameter(""rh-sso.v2""));+                .addWhereParameter(""rh-sso.v2"")","> According to local testing it doesn't seem so. When I start Keycloak 22.0.4 e.g. with postgres db, then stop it and then start Keycloak with this change it doesn't throw any exceptions and I can see that last `EXECUTED` changeset in the `databasechangelog` table is the on with id `22.0.0-17484`.>  This is is the id of the change in `jpa-changelog-22.0.0.xml`, which Liquibase has marked as `EXECUTED` when you started KC 22.0.4. I think it doesn't attempt to re-run the `JpaUpdate22_0_0_RemoveRhssoThemes`custom change when you run Keycloak again with the changes in this PR. Have you checked the DB to see if the new values for the columns were applied? I would expect them not to be. ",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1362456632,2023-10-17T16:42:22Z,js/apps/admin-ui/cypress/support/pages/admin-ui/manage/groups/GroupPage.ts,"@@ -42,12 +42,23 @@ export default class GroupPage extends PageObject {     return this;   } -  protected search(searchField: string, searchValue: string, wait: boolean) {+  protected search(+    searchField: string,+    searchValue: string,+    wait: boolean,+    exact: boolean = true,+  ) {     if (wait) {       const searchUrl = `/admin/realms/master/**/*${searchValue}*`;       cy.intercept(searchUrl).as(""search"");     } +    if (exact) {+      cy.get(""[data-testid='exact-search']"").check();+    } else {+      cy.get(""[data-testid='exact-search']"").uncheck();+    }","We're including [Cypress Testing Library](https://testing-library.com/docs/cypress-testing-library/intro), which extends the default Cypress commands. Among these commands is `findByTestId()`, which allows us to get an element by it's 'test-id'.```suggestion    if (exact) {      cy.findByTestId(""exact-search"").check();    } else {      cy.findByTestId(""exact-search"").uncheck();    }```",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1362466383,2023-10-17T16:50:41Z,js/apps/admin-ui/src/components/group/GroupPickerDialog.tsx,"@@ -75,7 +75,7 @@ export const GroupPickerDialog = ({       let count = 0;       if (!groupId) {         groups = await fetchAdminUI<GroupRepresentation[]>(","The `fetchAdminUI()` function was originally intended as mostly a wrapper that we use for things that are not formally supported as a public API (such as our `ui-ext` endpoint). If this is now part of the regular groups API and changes are made to that publically, this implementation should be part of the [Admin Client](https://github.com/keycloak/keycloak/tree/main/js/libs/keycloak-admin-client).Our community also uses the same library, so it's nice for these kinds of enhancements to trickle down.",
695720,jonkoops,https://api.github.com/repos/keycloak/keycloak/pulls/22700,1362475025,2023-10-17T16:58:51Z,js/apps/admin-ui/src/components/group/GroupPickerDialog.tsx,"@@ -84,18 +84,25 @@ export const GroupPickerDialog = ({             isSearching ? { search: filter } : null,           ),         );-      } else if (!navigation.map(({ id }) => id).includes(groupId)) {-        group = await adminClient.groups.findOne({ id: groupId });-        if (!group) {-          throw new Error(t(""notFound""));+      } else {+        if (!navigation.map(({ id }) => id).includes(groupId)) {+          group = await adminClient.groups.findOne({ id: groupId });+          if (!group) {+            throw new Error(t(""common:notFound""));+          }         }-        groups = group.subGroups!;+        groups = await fetchAdminUI<GroupRepresentation[]>(+          `groups/${groupId}/children`,+          {+            first: `${first}`,+            max: `${max + 1}`,+          },+        );       } -      if (isSearching) {-        count = (await adminClient.groups.count({ search: filter, top: true }))-          .count;-      }+      count = (+        await adminClient.groups.count({ search: filter, top: !groupId })","Since this fetch is always done, and does not depend on any of the other requests it could be done concurrently. This reduces the 'waterfall' effect where we have requests waiting on each other to finish. This can be accomplished by using [`Promise.all()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all), which we already do [in other places](https://github.com/keycloak/keycloak/blob/dfe64f6271f18d902d0030bbcc324c8464e5f424/js/apps/admin-ui/src/clients/registration/DetailProvider.tsx#L57-L61).",
1143437,pedroigor,https://api.github.com/repos/keycloak/keycloak/pulls/24025,1363875517,2023-10-18T13:22:45Z,services/src/main/java/org/keycloak/authentication/forms/RegistrationFormsHelper.java,"@@ -0,0 +1,63 @@+/*+ * Copyright 2023 Red Hat, Inc. and/or its affiliates+ *  and other contributors as indicated by the @author tags.+ *+ *  Licensed under the Apache License, Version 2.0 (the ""License"");+ *  you may not use this file except in compliance with the License.+ *  You may obtain a copy of the License at+ *+ *  http://www.apache.org/licenses/LICENSE-2.0+ *+ *  Unless required by applicable law or agreed to in writing, software+ *  distributed under the License is distributed on an ""AS IS"" BASIS,+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ *+ *  See the License for the specific language governing permissions and+ *  limitations under the License.+ *+ */++package org.keycloak.authentication.forms;++import jakarta.ws.rs.core.MultivaluedHashMap;+import jakarta.ws.rs.core.MultivaluedMap;+import org.keycloak.authentication.FormContext;+import org.keycloak.models.KeycloakSession;+import org.keycloak.userprofile.UserProfile;+import org.keycloak.userprofile.UserProfileContext;+import org.keycloak.userprofile.UserProfileProvider;++/**+ * @author <a href=""mailto:mposolda@redhat.com"">Marek Posolda</a>+ */+public class RegistrationFormsHelper {",Actually ... I remember now what we discussed with Stian. It should be better to keep your current approach and not couple user profile providers with other components.,
48995441,andymunro,https://api.github.com/repos/keycloak/keycloak/pulls/24056,1363897560,2023-10-18T13:37:32Z,docs/guides/server/fips.adoc,"@@ -31,10 +30,10 @@ fips-mode-setup --enable  == BouncyCastle library -Keycloak internally uses the BouncyCastle library for many cryptography utilities. However, the default flavor of the BouncyCastle library that shipped with Keycloak is not FIPS compliant, -but, BouncyCastle also provides a FIPS validated version of it's library. The FIPS validated BouncyCastle library cannot be shipped with Keycloak due to license constraints and+Keycloak internally uses the BouncyCastle library for many cryptography utilities. Please note that the default version of the BouncyCastle library that shipped with Keycloak is not FIPS compliant; +however BouncyCastle also provides a FIPS validated version of its library. The FIPS validated BouncyCastle library cannot be shipped with Keycloak due to license constraints and","```suggestionhowever,  BouncyCastle also provides a FIPS validated version of its library. The FIPS validated BouncyCastle library cannot be shipped with Keycloak due to license constraints and```",
3957921,ahus1,https://api.github.com/repos/keycloak/keycloak/pulls/24053,1364559424,2023-10-18T21:25:40Z,model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate22_0_0_RemoveRhssoThemes.java,"@@ -43,10 +43,11 @@ protected void generateStatementsImpl() throws CustomChangeException {                 .addWhereParameter(""rh-sso""));         // remove account theme for realms         statements.add(new UpdateStatement(null, null, database.correctObjectName(""REALM"", Table.class))-                .addNewColumnValue(""ACCOUNT_THEME"", null)-                .setWhereClause(""ACCOUNT_THEME=? OR ACCOUNT_THEME=?"")+                .addNewColumnValue(""ACCOUNT_THEME"", ""keycloak.v2"")+                .setWhereClause(""ACCOUNT_THEME=? OR ACCOUNT_THEME=? OR ACCOUNT_THEME=?"")                 .addWhereParameter(""rh-sso"")-                .addWhereParameter(""rh-sso.v2""));+                .addWhereParameter(""rh-sso.v2"")","@vramik - when you mentioned that you tested it and it worked, this was a surprise to me. I read it up [here](https://forum.liquibase.org/t/customchange-and-checksum/379/6) and found that the Liquibase checksum depends only on the XML, and not on the SQL created in the custom change. So you were right here and I was wrong, sorry for the extra work that I've caused you.Thank you for going the extra mile and splitting this up including the precondition of changeSetExecuted, I learned something new here. This resolves it for me, so resolve the conversation if you agree. ",
16507,afh,https://api.github.com/repos/neovim/neovim/pulls/90,9981810,2014-02-24T05:58:02Z,neovim.rb,"@@ -0,0 +1,16 @@+require 'formula'++class Neovim < Formula+  homepage 'http://neovim.org'+  head 'https://github.com/neovim/neovim.git'++  depends_on 'md5sha1sum'+  depends_on 'cmake'",How about making this a build dependency by adding `=> :build`,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/85,9985569,2014-02-24T09:58:40Z,scripts/common.sh,"@@ -1,13 +1,13 @@ platform='unknown'","Normally, I'd agree.  But, the scripts aren't even marked as executable and are executed from the `Makefile` by specifying sh directly:``` text.deps/usr/lib/libuv.a:        sh -e scripts/get-libuv.sh```Also it appears that `common.sh` is meant to be a library, so I think it'd be wrong to mark it up  with a shebang since it's not meant to execute standalone.Would you like me to add it to `get-libuv.sh` and change the make invocation?  Or leave things as-is?",
351519,simendsjo,https://api.github.com/repos/neovim/neovim/pulls/222,10163300,2014-02-28T13:14:39Z,src/garray.c,"@@ -1,112 +1,149 @@-/*+/**  * Functions for handling growing arrays.  */+#include <assert.h>  #include ""vim.h"" #include ""ascii.h"" #include ""misc2.h"" #include ""garray.h""-//#include ""globals.h"" #include ""memline.h"" -/*+/**  * Clear an allocated growing array.+ *+ * The allocated memory will be freed, and it's size set to zero.+ * Note that this does not reset the current itemsize and growsize.+ *+ * It's bug to call this on an array that hasn't been initialized with ga_init+ * or ga_init2.  */ void ga_clear(garray_T *gap) {+  assert(gap);   vim_free(gap->ga_data);   ga_init(gap); } -/*+/**  * Clear a growing array that contains a list of strings.+ *+ * It's a bug to call this function if gap isn't a list of strings.  */ void ga_clear_strings(garray_T *gap) {-  int i;--  for (i = 0; i < gap->ga_len; ++i)+  assert(gap);+  for (int i = 0; i < gap->ga_len; ++i)     vim_free(((char_u **)(gap->ga_data))[i]);   ga_clear(gap); } -/*- * Initialize a growing array.	Don't forget to set ga_itemsize and- * ga_growsize!  Or use ga_init2().+/**+ * Initialize a growing array.+ *+ * Don't forget to set ga_itemsize and ga_growsize! Or use \sa ga_init2().  */ void ga_init(garray_T *gap) {-  gap->ga_data = NULL;+  assert(gap);+  gap->ga_data   = NULL;   gap->ga_maxlen = 0;-  gap->ga_len = 0;+  gap->ga_len    = 0; } +/**+ * Initialize a growing array.+ * */ void ga_init2(garray_T *gap, int itemsize, int growsize) {+  assert(gap);   ga_init(gap);   gap->ga_itemsize = itemsize;   gap->ga_growsize = growsize; } -/*- * Make room in growing array ""gap"" for at least ""n"" items.- * Return FAIL for failure, OK otherwise.+/**+ * Grow array to be able to hold at least 'n' new items.+ *+ * \returns FAIL if it fails to allocate enough memory. OK otherwise.  */ int ga_grow(garray_T *gap, int n) {-  size_t old_len;-  size_t new_len;-  char_u      *pp;--  if (gap->ga_maxlen - gap->ga_len < n) {-    if (n < gap->ga_growsize)-      n = gap->ga_growsize;-    new_len = gap->ga_itemsize * (gap->ga_len + n);-    pp = (gap->ga_data == NULL)-         ? alloc((unsigned)new_len) : vim_realloc(gap->ga_data, new_len);-    if (pp == NULL)-      return FAIL;-    old_len = gap->ga_itemsize * gap->ga_maxlen;-    vim_memset(pp + old_len, 0, new_len - old_len);-    gap->ga_maxlen = gap->ga_len + n;-    gap->ga_data = pp;-  }+  assert(gap);+  assert(n >= 0);++  if (gap->ga_maxlen - gap->ga_len >= n)+    return OK; // We already have enough room++  if (n < gap->ga_growsize)+    n = gap->ga_growsize;+  size_t new_len = gap->ga_itemsize * (gap->ga_len + n);++  char_u *pp = (gap->ga_data == NULL)+       ? alloc((unsigned)new_len) : vim_realloc(gap->ga_data, new_len);+  if (!pp)+    return FAIL;++  size_t old_len = gap->ga_itemsize * gap->ga_maxlen;+  vim_memset(pp + old_len, 0, new_len - old_len);+  gap->ga_maxlen = gap->ga_len + n;+  gap->ga_data   = pp;+   return OK; } -/*- * For a growing array that contains a list of strings: concatenate all the- * strings with a separating comma.- * Returns NULL when out of memory.+/**+ * Concatenate a list of strings by "",""+ *+ * A rewly allocated string will be returned.+ *+ * Examples:+ *   NULL -> NULL+ *   [] -> NULL+ *   [""""] -> """"+ *   [""a""] -> ""a""+ *   [""a"", ""b""] -> ""a,b""+ *   ["""", ""a"", """"] -> "",a,""+ *+ * \returns NULL when out of memory, or the list was empty.  */-char_u *ga_concat_strings(garray_T *gap)+char_u *ga_concat_strings(garray_T const *const gap) {-  int i;+  if(!gap || gap->ga_len == 0)+    return NULL; // nothing to do++#define GAP_STR ((char_u **)(gap->ga_data))   int len = 0;-  char_u      *s;--  for (i = 0; i < gap->ga_len; ++i)-    len += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + 1;--  s = alloc(len + 1);-  if (s != NULL) {-    *s = NUL;-    for (i = 0; i < gap->ga_len; ++i) {-      if (*s != NUL)-        STRCAT(s, "","");-      STRCAT(s, ((char_u **)(gap->ga_data))[i]);-    }+  for (int i = 0; i < gap->ga_len; ++i)+    len += (int)STRLEN(GAP_STR[i]);","The `+1` is for the `"",""` that will delimit the strings. `STRLEN` is needed to get the length of each string in the list so we can allocate a large enough string to hold the entire list. The `ga_len` on the next line is because I removed the `+1`s from the loop and needs to make room for all the `"",""`. It actually allocates too much though.. If there is only a single element, no `"",""` would be added, so the correct line would be `ga_len-1` - we only loose a byte though, but I'll fix it.",
603326,commonquail,https://api.github.com/repos/neovim/neovim/pulls/243,10194524,2014-03-02T08:35:31Z,src/expr.c,"@@ -0,0 +1,1415 @@+// vim: ts=8 sts=2 sw=2 tw=80+//+// NeoVim - Neo Vi IMproved+//+// Do "":help uganda""  in Vim to read copying and usage conditions.+// Do "":help credits"" in Vim to see a list of people who contributed.+// See README.txt for an overview of the Vim source code.++// expr.c: Expression parsing++#include ""vim.h""+#include ""misc2.h""+#include ""types.h""+#include ""expr.h""+#include ""charset.h""++#define MAX_FUNC_ARGS   20      /* maximum number of function arguments */++#define UP_NODE(type, error, old_top_node, top_node, next_node) \+  { \+    if ((top_node = node_alloc(type, error)) == NULL) \+      return FAIL; \+    next_node = &((*old_top_node)->next); \+    top_node->children = *old_top_node; \+    *old_top_node = top_node; \+  }++#define VALUE_NODE(type, error, node, pos, end_pos) \+  { \+    if ((*node = node_alloc(type, error)) == NULL) \+      return FAIL; \+    (*node)->position = pos; \+    (*node)->end_position = end_pos; \+  }++#define IS_SCOPE_CHAR(c) (   (c) == 'g' || (c) == 'b' || (c) == 'w' \+                          || (c) == 't' || (c) == 'v' || (c) == 'a' \+                          || (c) == 'l' || (c) == 's')++static int parse1(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error);++static ExpressionNode *node_alloc(ExpressionType type,+                                  ExpressionParserError *error)+{+  ExpressionNode *node;++  if ((node = ALLOC_CLEAR_NEW(ExpressionNode, 1)) == NULL)+    return NULL;++  node->type = type;+  return node;+}++static void free_node(ExpressionNode *node)+{+  if (node == NULL)+    return;++  free_node(node->children);+  free_node(node->next);+  vim_free(node);+}++/*+ * Return TRUE if character ""c"" can be used in a variable or function name.+ * Does not include '{' or '}' for magic braces.+ */+static int isnamechar(int c)+{+  return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;+}++/*+ * Find the end of the name of a function or internal variable.+ * ""arg"" is advanced to the first non-white character after the name.+ * Return NULL if something is wrong.+ */+static char_u *find_id_end(char_u **arg)+{+  char_u *p;++  // Find the end of the name.+  for (p = *arg; isnamechar(*p); ++p)+    ;+  if (p == *arg) // no name found+    return NULL;+  *arg = p;+  return p - 1;+}++/*+ * Return 5 if ""p"" starts with ""<SID>"" or ""<SNR>"" (ignoring case).+ * Return 2 if ""p"" starts with ""s:"".+ * Return 0 otherwise.+ */+static int get_fname_script_len(char_u *p)+{+  if (p[0] == '<' && (   STRNICMP(p + 1, ""SID>"", 4) == 0+                      || STRNICMP(p + 1, ""SNR>"", 4) == 0))+    return 5;+  if (p[0] == 's' && p[1] == ':')+    return 2;+  return 0;+}++/*+ * Only the name is recognized, does not handle "".key"" or ""[idx]"".+ * ""arg"" is advanced to the first non-white character after the name.+ */+static int parse_name(char_u **arg,+                      ExpressionNode **node,+                      ExpressionParserError *error,+                      ExpressionNode *parse1_node,+                      char_u *parse1_arg)+{+  int len;+  char_u *p;+  char_u *s;+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  if ((top_node = node_alloc(kTypeVariableName, error)) == NULL)+    return FAIL;+  next_node = &(top_node->children);+  *node = top_node;++  if (parse1_node == NULL) {+    s = *arg;+    if (   (*arg)[0] == K_SPECIAL+        && (*arg)[1] == KS_EXTRA+        && (*arg)[2] == (int)KE_SNR) {+      // hard coded <SNR>, already translated+      *arg += 3;+      if ((p = find_id_end(arg)) == NULL) {+        // FIXME Proper error message+        error->message = ""expected variable name"";+        error->position = *arg;+        return FAIL;+      }+      (*node)->type = kTypeSimpleVariableName;+      (*node)->position = s;+      (*node)->end_position = p;+      return OK;+    }++    len = get_fname_script_len(*arg);+    if (len > 0) {+      // literal ""<SID>"", ""s:"" or ""<SNR>""+      *arg += len;+    }++    p = find_id_end(arg);++    if (p == NULL && len)+      p = *arg - 1;++    if (**arg != '{') {+      if (p == NULL) {+        // FIXME Proper error message+        error->message = ""expected variable name"";+        error->position = *arg;+        return FAIL;+      }+      (*node)->type = kTypeSimpleVariableName;+      (*node)->position = s;+      (*node)->end_position = p;+      return OK;+    }+  } else {+    VALUE_NODE(kTypeCurlyName, error, next_node, *arg, NULL);+    (*next_node)->children = parse1_node;+    next_node = &((*next_node)->next);+    *arg = parse1_arg + 1;+    s = *arg;+    p = find_id_end(arg);+  }++  while (**arg == '{') {+    if (p != NULL) {+      VALUE_NODE(kTypeIdentifier, error, next_node, s, p)+      next_node = &((*next_node)->next);+    }++    s = *arg;+    ++(*arg);+    *arg = skipwhite(*arg);++    VALUE_NODE(kTypeCurlyName, error, next_node, s, NULL)++    if ((parse1(arg, &((*next_node)->children), error)) == FAIL)+      return FAIL;++    if (**arg != '}') {+      // FIXME Proper error message+      error->message = ""missing closing curly brace"";+      error->position = *arg;+      return FAIL;+    }+    ++(*arg);+    next_node = &((*next_node)->next);+    s = *arg;+    p = find_id_end(arg);+  }++  if (p != NULL) {+    VALUE_NODE(kTypeIdentifier, error, next_node, s, p)+    next_node = &((*next_node)->next);+  }++  return OK;+}++/*+ * Allocate a variable for a List and fill it from ""*arg"".+ * Return OK or FAIL.+ */+static int parse_list(char_u **arg,+                      ExpressionNode **node,+                      ExpressionParserError *error)+{+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;+  char_u *s = *arg;++  UP_NODE(kTypeList, error, node, top_node, next_node)++  *arg = skipwhite(*arg + 1);+  while (**arg != ']' && **arg != NUL) {+    if (parse1(arg, next_node, error) == FAIL)+      return FAIL;++    next_node = &((*next_node)->next);++    if (**arg == ']')+      break;+    if (**arg != ',') {+      error->message = N_(""E696: Missing comma in List"");+      error->position = *arg;+      return FAIL;+    }+    *arg = skipwhite(*arg + 1);+  }++  if (**arg != ']') {+    error->message = N_(""E697: Missing end of List"");+    error->position = *arg;+    return FAIL;+  }++  *arg = skipwhite(*arg + 1);++  return OK;+}++/*+ * Allocate a variable for a Dictionary and fill it from ""*arg"".+ * Return OK or FAIL.  Returns NOTDONE for {expr}.+ */+static int parse_dictionary(char_u **arg,+                            ExpressionNode **node,+                            ExpressionParserError *error,+                            ExpressionNode **parse1_node,+                            char_u **parse1_arg)+{+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;+  char_u *start = skipwhite(*arg + 1);++  *parse1_node = NULL;++  // First check if it's not a curly-braces thing: {expr}.+  // But {} is an empty Dictionary.+  if (*start != '}') {+    *parse1_arg = start;+    if (parse1(parse1_arg, parse1_node, error) == FAIL) {+      free_node(*parse1_node);+      return FAIL;+    }+    if (**parse1_arg == '}')+      return NOTDONE;+  }++  if ((top_node = node_alloc(kTypeVariableName, error)) == NULL) {+    free_node(*parse1_node);+    return FAIL;+  }+  next_node = &(top_node->children);+  *node = top_node;++  *arg = start;+  while (**arg != '}' && **arg != NUL) {+    if (*parse1_node != NULL) {+      *next_node = *parse1_node;+      *parse1_node = NULL;+      *arg = *parse1_arg;+    }+    else if (parse1(arg, next_node, error) == FAIL) {+      return FAIL;+    }++    next_node = &((*next_node)->next);++    if (**arg != ':') {+      error->message = N_(""E720: Missing colon in Dictionary"");+      error->position = *arg;+      return FAIL;+    }++    *arg = skipwhite(*arg + 1);+    if (parse1(arg, next_node, error) == FAIL)+      return FAIL;++    next_node = &((*next_node)->next);++    if (**arg == '}')+      break;+    if (**arg != ',') {+      error->message = N_(""E722: Missing comma in Dictionary"");+      error->position = *arg;+      return FAIL;+    }+    *arg = skipwhite(*arg + 1);+  }++  if (**arg != '}') {+    error->message = N_(""E723: Missing end of Dictionary"");+    error->position = *arg;+    return FAIL;+  }++  *arg = skipwhite(*arg + 1);++  return OK;+}++/*+ * Skip over the name of an option: ""&option"", ""&g:option"" or ""&l:option"".+ * ""arg"" points to the ""&"" or '+' when called.+ * Advance ""arg"" to the first character after the name.+ * Returns NULL when no option name found.  Otherwise pointer to the last char + * of the option name.+ */+static char_u *find_option_end(char_u **arg)+{+  char_u      *p = *arg;++  ++p;+  if (*p == 'g' && p[1] == ':')+    p += 2;+  else if (*p == 'l' && p[1] == ':')+    p += 2;++  if (!ASCII_ISALPHA(*p))+    return NULL;++  if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)+    p += 4;+  else+    while (ASCII_ISALPHA(*p))+      ++p;++  *arg = p;++  return p - 1;+}++/*+ * Parse an option value.+ * ""arg"" points to the '&' or '+' before the option name.+ * ""arg"" is advanced to character after the option name.+ * Return OK or FAIL.+ */+static int parse_option(char_u **arg,+                        ExpressionNode **node,+                        ExpressionParserError *error)+{+  char_u *option_end;++  if ((option_end = find_option_end(arg)) == NULL) {+    error->message = N_(""E112: Option name missing"");+    error->position = *arg;+    return FAIL;+  }++  VALUE_NODE(kTypeOption, error, node, *arg, option_end)++  *arg = option_end;+  return OK;+}++/*+ * Find the end of an environment variable name.+ * Advance ""arg"" to the first character after the name.+ * Return NULL for error.+ */+static char_u *find_env_end(char_u **arg)+{+  char_u *p;++  for (p = *arg; vim_isIDc(*p); ++p)+    ;+  if (p == *arg)            /* no name found */+    return NULL;++  *arg = p;+  return p - 1;+}++/*+ * Parse an environment variable.+ * ""arg"" is pointing to the '$'.  It is advanced to after the name.+ * If the environment variable was not set, silently assume it is empty.+ * Always return OK.+ */+static int parse_environment_variable(char_u **arg,+                                      ExpressionNode **node,+                                      ExpressionParserError *error)+{+  char_u *s = *arg;+  char_u *e;++  ++(*arg);+  e = find_env_end(arg);+  if (e == NULL)+    e = s;++  VALUE_NODE(kTypeEnvironmentVariable, error, node, s, e)++  return OK;+}++/*+ * Parse .key subscript+ * Return OK, FAIL or NOTDONE, latter only in case handle_subscript can proceed + * handling subsequent subscripts (i.e. .key subscript was found).+ */+static int parse_dot_subscript(char_u **arg,+                               ExpressionNode **node,+                               ExpressionParserError *error)+{+  char_u *s;+  char_u *e;+  ExpressionNode *top_node = NULL;++  s = *arg;+  for (e = s + 1; ASCII_ISALNUM(*e) || *e == '_'; ++e)+    ;+  if (e == s + 1)+    return OK;+  // XXX Workaround for concat ambiguity+  if ((e - s) == 2 && *e == ':' && IS_SCOPE_CHAR(s[1]))+    return OK;+  if ((top_node = node_alloc(kTypeConcatOrSubscript, error)) == NULL)+    return FAIL;+  top_node->children = *node;+  top_node->position = s;+  top_node->end_position = e - 1;+  *node = top_node;+  *arg = e;+  return NOTDONE;+}++/*+ * Parse function call arguments+ * Return OK or FAIL.+ */+static int parse_func_call(char_u **arg,+                           ExpressionNode **node,+                           ExpressionParserError *error)+{+  char_u *argp;+  char_u *s;+  int argcount = 0;+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  UP_NODE(kTypeCall, error, node, top_node, next_node)++  // Get the arguments.+  argp = *arg;+  s = argp;+  while (argcount < MAX_FUNC_ARGS) {+    argp = skipwhite(argp + 1); // skip the '(' or ','+    if (*argp == ')' || *argp == ',' || *argp == NUL)+      break;+    if (parse1(&argp, next_node, error) == FAIL)+      return FAIL;+    next_node = &((*next_node)->next);+    ++argcount;+    if (*argp != ',')+      break;+  }++  if (*argp != ')') {+    // FIXME Proper error message+    error->message = ""expected closing parenthesis"";+    error->position = argp;+    return FAIL;+  }++  ++argp;++  *arg = skipwhite(argp);+  return OK;+}++/*+ * Parse an ""[expr]"" or ""[expr:expr]"" index.+ * ""*arg"" points to the '['.+ * Returns FAIL or OK. ""*arg"" is advanced to after the ']'.+ */+static int parse_subscript(char_u **arg,+                           ExpressionNode **node,+                           ExpressionParserError *error)+{+  char_u *s = *arg;+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  UP_NODE(kTypeSubscript, error, node, top_node, next_node)++  // Get the (first) variable from inside the [].+  *arg = skipwhite(*arg + 1); // skip the '['+  if (**arg == ':') {+    VALUE_NODE(kTypeEmptySubscript, error, next_node, *arg, NULL)+    next_node = &((*next_node)->next);+  }+  else if (parse1(arg, next_node, error) == FAIL) {+    return FAIL;+  }++  // Get the second variable from inside the [:].+  if (**arg == ':') {+    *arg = skipwhite(*arg + 1);+    if (**arg == ']')+      VALUE_NODE(kTypeEmptySubscript, error, next_node, *arg, NULL)+    else if (parse1(arg, next_node, error) == FAIL)+      return FAIL;+  }++  // Check for the ']'.+  if (**arg != ']') {+    error->message = N_(""E111: Missing ']'"");+    error->position = *arg;+    return FAIL;+  }+  *arg = skipwhite(*arg + 1); // skip the ']'++  return OK;+}++/*+ * Handle expr[expr], expr[expr:expr] subscript and .name lookup.+ * Also handle function call with Funcref variable: func(expr)+ * Can all be combined: dict.func(expr)[idx]['func'](expr)+ */+static int handle_subscript(char_u **arg,+                            ExpressionNode **node,+                            ExpressionParserError *error)+{+  while ((**arg == '[' || **arg == '.' || **arg == '(')+         && !vim_iswhite(*(*arg - 1))) {+    switch (**arg) {+      case '.': {+        int ret = parse_dot_subscript(arg, node, error);+        if (ret == FAIL)+          return FAIL;+        if (ret != NOTDONE)+          return OK;+        break;+      }+      case '(': {+        if (parse_func_call(arg, node, error) == FAIL)+          return FAIL;+        break;+      }+      case '[': {+        if (parse_subscript(arg, node, error) == FAIL)+          return FAIL;+        break;+      }+    }+  }+  return OK;+}++/*+ * Handle sixth level expression:+ *  number		number constant+ *  ""string""		string constant+ *  'string'		literal string constant+ *  &option-name	option value+ *  @r			register contents+ *  identifier		variable value+ *  function()		function call+ *  $VAR		environment variable+ *  (expression)	nested expression+ *  [expr, expr]	List+ *  {key: val, key: val}  Dictionary+ *+ *  Also handle:+ *  ! in front		logical NOT+ *  - in front		unary minus+ *  + in front		unary plus (ignored)+ *  trailing []		subscript in String or List+ *  trailing .name	entry in Dictionary+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Return OK or FAIL.+ */+static int parse7(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error,+                  int want_string)+{+  ExpressionType type = kTypeUnknown;+  ExpressionNode *parse1_node = NULL;+  char_u *parse1_arg;+  char_u *s, *e;+  char_u *start_leader, *end_leader;+  int ret = OK;++  // Skip '!' and '-' characters.  They are handled later.+  start_leader = *arg;+  while (**arg == '!' || **arg == '-' || **arg == '+')+    *arg = skipwhite(*arg + 1);+  end_leader = *arg;++  switch (**arg) {+    // Number constant.+    case '0':+    case '1':+    case '2':+    case '3':+    case '4':+    case '5':+    case '6':+    case '7':+    case '8':+    case '9': {+      char_u *p;++      s = *arg;+      p = skipdigits(*arg + 1);+      e = p - 1;+      type = kTypeNumber;++      /* We accept a float when the format matches+       * ""[0-9]\+\.[0-9]\+\([eE][+-]\?[0-9]\+\)\?"".  This is very+       * strict to avoid backwards compatibility problems.+       * Don't look for a float after the ""."" operator, so that+       * "":let vers = 1.2.3"" doesn't fail. */+      if (!want_string && p[0] == '.' && VIM_ISDIGIT(p[1])) {+        type = kTypeFloat;+        p = skipdigits(p + 2);+        if (*p == 'e' || *p == 'E') {+          ++p;+          if (*p == '-' || *p == '+')+            ++p;+          if (!VIM_ISDIGIT(*p))+            type = kTypeNumber;+          else+            p = skipdigits(p + 1);+        }+        if (ASCII_ISALPHA(*p) || *p == '.')+          type = kTypeNumber;+        if (type != kTypeNumber)+          e = p - 1;+      }+      VALUE_NODE(type, error, node, s, e)+      *arg = e + 1;+      break;+    }++    // String constant+    case '""':+    case '\'': {+      char_u *p;++      s = *arg;+      p = s + 1;++      if (*s == '""') {+        while (*p != '""' && *p != NUL)+        {+          if (*p == '\\' && p[1] != NUL)+            p += 2;+          else+            ++p;+        }+      } else {+        while (*p != '\'' && *p != NUL)+        {+          ++p;+          if (*p == '\'' && p[1] == '\'')+            p += 2;+        }+      }+      if (*p == NUL) {+        // TODO: also report which quote is missing+        error->message = N_(""E114: Missing quote"");+        error->position = s;+        return FAIL;+      }+      ++p;++      if (*s == '""')+        type = kTypeDoubleQuotedString;+      else+        type = kTypeSingleQuotedString;++      VALUE_NODE(type, error, node, s, p - 1)+      *arg = p;+      break;+    }++    // List: [expr, expr]+    case '[': {+      ret = parse_list(arg, node, error);+      break;+    }++    // Dictionary: {key: val, key: val}+    case '{': {+      ret = parse_dictionary(arg, node, error, &parse1_node, &parse1_arg);+      break;+    }++    // Option value: &name+    case '&': {+      ret = parse_option(arg, node, error);+      break;+    }++    // Environment variable: $VAR.+    case '$': {+      ret = parse_environment_variable(arg, node, error);+      break;+    }++    // Register contents: @r.+    case '@': {+      s = *arg;+      ++*arg;+      if (**arg != NUL)+        ++*arg;+      VALUE_NODE(kTypeRegister, error, node, s, *arg - 1)+      break;+    }++    // nested expression: (expression).+    case '(': {+      VALUE_NODE(kTypeExpression, error, node, *arg, NULL)+      *arg = skipwhite(*arg + 1);+      ret = parse1(arg, &((*node)->children), error);+      if (**arg == ')') {+        ++(*arg);+      }+      else if (ret == OK) {+        error->message = N_(""E110: Missing ')'"");+        error->position = *arg;+        ret = FAIL;+      }+      break;+    }++    default: {+      ret = NOTDONE;+      break;+    }+  }++  if (ret == NOTDONE) {+    // Must be a variable or function name.+    // Can also be a curly-braces kind of name: {expr}.+    ret = parse_name(arg, node, error, parse1_node, parse1_arg);+  }++  *arg = skipwhite(*arg);++  /* Handle following '[', '(' and '.' for expr[expr], expr.name,+   * expr(expr). */+  if (ret == OK)+    ret = handle_subscript(arg, node, error);++  /*+   * Apply logical NOT and unary '-', from right to left, ignore '+'.+   */+  if (ret == OK && end_leader > start_leader) {+    while (end_leader > start_leader) {+      ExpressionNode *top_node = NULL;+      --end_leader;+      switch (*end_leader) {+        case '!': {+          type = kTypeNot;+          break;+        }+        case '-': {+          type = kTypeMinus;+          break;+        }+        case '+': {+          type = kTypePlus;+          break;+        }+      }+      if ((top_node = node_alloc(type, error)) == NULL)+        return FAIL;+      top_node->children = *node;+      *node = top_node;+    }+  }++  return ret;+}++/*+ * Handle fifth level expression:+ *	*	number multiplication+ *	/	number division+ *	%	number modulo+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Return OK or FAIL.+ */+static int parse6(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error,+                  int want_string)+{+  ExpressionType type = kTypeUnknown;+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  // Get the first variable.+  if (parse7(arg, node, error, want_string) == FAIL)+    return FAIL;++  // Repeat computing, until no '*', '/' or '%' is following.+  for (;;) {+    switch (**arg) {+      case '*': {+        type = kTypeMultiply;+        break;+      }+      case '/': {+        type = kTypeDivide;+        break;+      }+      case '%': {+        type = kTypeModulo;+        break;+      }+      default: {+        type = kTypeUnknown;+        break;+      }+    }+    if (type == kTypeUnknown)+      break;++    if (top_node == NULL || top_node->type != type)+      UP_NODE(type, error, node, top_node, next_node)+    else+      next_node = &((*next_node)->next);++    // Get the second variable.+    *arg = skipwhite(*arg + 1);+    if (parse7(arg, next_node, error, want_string) == FAIL)+      return FAIL;+  }+  return OK;+}++/*+ * Handle fourth level expression:+ *	+	number addition+ *	-	number subtraction+ *	.	string concatenation+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Return OK or FAIL.+ */+static int parse5(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error)+{+  ExpressionType type = kTypeUnknown;+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  // Get the first variable.+  if (parse6(arg, node, error, FALSE) == FAIL)+    return FAIL;++  // Repeat computing, until no '+', '-' or '.' is following.+  for (;;) {+    switch (**arg) {+      case '+': {+        type = kTypeAdd;+        break;+      }+      case '-': {+        type = kTypeSubstract;+        break;+      }+      case '.': {+        type = kTypeStringConcat;+        break;+      }+      default: {+        type = kTypeUnknown;+        break;+      }+    }+    if (type == kTypeUnknown)+      break;++    if (top_node == NULL || top_node->type != type)+      UP_NODE(type, error, node, top_node, next_node)+    else+      next_node = &((*next_node)->next);++    // Get the second variable.+    *arg = skipwhite(*arg + 1);+    if (parse6(arg, next_node, error, type == kTypeStringConcat) == FAIL)+      return FAIL;+  }+  return OK;+}++/*+ * Handle third level expression:+ *	var1 == var2+ *	var1 =~ var2+ *	var1 != var2+ *	var1 !~ var2+ *	var1 > var2+ *	var1 >= var2+ *	var1 < var2+ *	var1 <= var2+ *	var1 is var2+ *	var1 isnot var2+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Return OK or FAIL.+ */+static int parse4(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error)+{+  char_u *p;+  ExpressionType type = kTypeUnknown;+  int len = 2;++  // Get the first variable.+  if (parse5(arg, node, error) == FAIL)+    return FAIL;++  p = *arg;+  switch (p[0]) {+    case '=': {+      if (p[1] == '=')+        type = kTypeEquals;+      else if (p[1] == '~')+        type = kTypeMatches;+      break;+    }+    case '!': {+      if (p[1] == '=')+        type = kTypeNotEquals;+      else if (p[1] == '~')+        type = kTypeNotMatches;+      break;+    }+    case '>': {+      if (p[1] != '=') {+        type = kTypeGreater;+        len = 1;+      } else {+        type = kTypeGreaterThanOrEqualTo;+      }+      break;+    }+    case '<': {+      if (p[1] != '=') {+        type = kTypeLess;+        len = 1;+      } else {+        type = kTypeLessThanOrEqualTo;+      }+      break;+    }+    case 'i': {+      if (p[1] == 's') {+        if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')+          len = 5;+        if (!vim_isIDc(p[len]))+          type = len == 2 ? kTypeIdentical : kTypeNotIdentical;+      }+      break;+    }+  }++  // If there is a comparative operator, use it.+  if (type != kTypeUnknown) {+    ExpressionNode *top_node = NULL;+    ExpressionNode **next_node = node;++    UP_NODE(type, error, node, top_node, next_node)++    // extra question mark appended: ignore case+    if (p[len] == '?') {+      top_node->ignore_case = kCCStrategyIgnoreCase;+      ++len;+    }+    // extra '#' appended: match case+    else if (p[len] == '#') {+      top_node->ignore_case = kCCStrategyMatchCase;+      ++len;+    }+    // nothing appended: use kCCStrategyUseOption (default)++    // Get the second variable.+    next_node = &((*next_node)->next);+    *arg = skipwhite(p + len);+    if (parse5(arg, next_node, error) == FAIL)+      return FAIL;++  }++  return OK;+}++/*+ * Handle second level expression:+ *	expr3 && expr3 && expr3	    logical AND+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Return OK or FAIL.+ */+static int parse3(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error)+{+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  // Get the first variable.+  if (parse4(arg, node, error) == FAIL)+    return FAIL;++  // Repeat until there is no following ""&&"".+  while ((*arg)[0] == '&' && (*arg)[1] == '&') {+    if (top_node == NULL)+      UP_NODE(kTypeLogicalOr, error, node, top_node, next_node)++    // Get the second variable.+    *arg = skipwhite(*arg + 2);+    if (parse4(arg, next_node, error) == FAIL)+      return FAIL;+    next_node = &((*next_node)->next);+  }++  return OK;+}++/*+ * Handle first level expression:+ *	expr2 || expr2 || expr2	    logical OR+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Return OK or FAIL.+ */+static int parse2(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error)+{+  ExpressionNode *top_node = NULL;+  ExpressionNode **next_node = node;++  // Get the first variable.+  if (parse3(arg, node, error) == FAIL)+    return FAIL;++  // Repeat until there is no following ""||"".+  while ((*arg)[0] == '|' && (*arg)[1] == '|') {+    if (top_node == NULL)+      UP_NODE(kTypeLogicalAnd, error, node, top_node, next_node)++    // Get the second variable.+    *arg = skipwhite(*arg + 2);+    if (parse3(arg, next_node, error) == FAIL)+      return FAIL;+    next_node = &((*next_node)->next);+  }++  return OK;+}++/*+ * Handle top level expression:+ *	expr2 ? expr1 : expr1+ *+ * ""arg"" must point to the first non-white of the expression.+ * ""arg"" is advanced to the next non-white after the recognized expression.+ *+ * Note: ""rettv.v_lock"" is not set.+ *+ * Return OK or FAIL.+ */+static int parse1(char_u **arg,+                  ExpressionNode **node,+                  ExpressionParserError *error)+{+  // Get the first variable.+  if (parse2(arg, node, error) == FAIL)+    return FAIL;++  if ((*arg)[0] == '?') {+    ExpressionNode *top_node;+    ExpressionNode **next_node = node;++    UP_NODE(kTypeTernaryConditional, error, node, top_node, next_node)++    // Get the second variable.+    *arg = skipwhite(*arg + 1);+    if (parse1(arg, next_node, error) == FAIL)+      return FAIL;++    // Check for the "":"".+    if (**arg != ':') {+      error->message = N_(""E109: Missing ':' after '?'"");+      error->position = *arg;+      return FAIL;+    }++    next_node = &((*next_node)->next);++    // Get the third variable.+    *arg = skipwhite(*arg + 1);+    if (parse1(arg, next_node, error) == FAIL)+      return FAIL;+  }++  return OK;+}++static ExpressionNode *parse0(char_u *arg)+{+  ExpressionNode *result = NULL;+  char_u *p;+  ExpressionParserError error;++  error.message = NULL;+  error.position = NULL;++  p = skipwhite(arg);+  if (parse1(&p, &result, &error) == FAIL)+  {+    // FIXME print error properly+    puts((char *) error.message);+    puts((char *) error.position);+    free_node(result);+    return NULL;+  }++  return result;+}++//FIXME!!!+#ifdef COMPILE_TEST_VERSION+#include <stdio.h>+static void print_node(int indent, ExpressionNode *node)+{+  char *name = NULL;+  switch (node->type) {",Everything after 1185 is temporary I believe,
155394,Olivia5k,https://api.github.com/repos/neovim/neovim/pulls/288,10282416,2014-03-05T00:17:43Z,CONTRIBUTING.md,"@@ -2,45 +2,41 @@  ## Thank you -Thanks for considering contributing to neovim. To make the process as smooth-as possible we would ask you to follow the guidelines below.+Thanks for considering contributing to neovim.+To make the process as smooth as possible we would ask you to follow+the guidelines below.+If you need support see [the wiki](https://github.com/neovim/neovim/wiki/Contributing). -## Help with contributing--See [Communicating](https://github.com/neovim/neovim/wiki/Communicating).-Raise documentation issues.--## Guidelines--### Finding something to do--Neovim uses [waffle.io](https://waffle.io/neovim/neovim), so check there-first.--You can also ask for an issues to be assigned to you.-Ideally wait until we assign it to you to minimize-work duplication.--### Reporting an issue+## Issues  - Search existing issues before raising a new one. - Include as much detail as possible. In particular, we need to know which   OS you're using. -### Pull requests+## Pull requests++### For all PRs  - Make it clear in the issue tracker what you are working on, so that-someone else doesn't duplicate the work.+  someone else doesn't duplicate the work. - Use a feature branch, not master. - Rebase your feature branch onto origin/master before raising the PR. - Keep up to date with changes in master so your PR is easy to merge. - Be descriptive in your PR message: what is it for, why is it needed, etc.-- Make sure the tests pass (TODO: we need to make this easier with travis etc.) - Squash related commits as much as possible.","Since the guideline states ""as much as possible"", I have a hard time interpreting it as not allowing discarding of commit messages. The purpose of the guideline is to make the history as clean as possible by the tools we have.Would it be better if it was phrased along the lines of ""Keep the history clean by squashing superflous commits"", so that we explicitly state that the end goal is to have a nice history?",
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/307,10339037,2014-03-06T11:31:43Z,scripts/unittest.sh,"@@ -3,4 +3,16 @@ (cd ""$pkgroot/build"" && make) || exit 1 eval ""$(luarocks path)"" -busted --pattern=.moon ./test+if [ $# == 0 ]; then # Assume full test+  busted --pattern=.moon ./test+else+  # Assume a list of unittest files+  for filename; do+    filename=./test/unit/$filename.moon","You could try `busted --pattern=.moon --pattern=""$filename"" ./test` instead of building the full path. It could ""fail"" sometimes and run more tests then you would expect, but I think it's more flexible.",
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/320,10400552,2014-03-07T21:19:45Z,scripts/unittest.sh,"@@ -3,4 +3,7 @@ (cd ""$pkgroot/build"" && make) || exit 1 eval ""$(luarocks path)"" -busted --pattern=.moon ./test+if [ -z ""$BUSTED_OUTPUT_TYPE"" ]; then+    export BUSTED_OUTPUT_TYPE=""utf_terminal""+fi+busted --pattern=.moon --output=$BUSTED_OUTPUT_TYPE ./test","Even if the documentation states that `--output=LIBRARY` is fine, this somehow only works with the short version of the option on my system:`busted --pattern=.moon -o $BUSTED_OUTPUT_TYPE ./test`",
5283042,davidzchen,https://api.github.com/repos/neovim/neovim/pulls/341,10425886,2014-03-10T11:39:47Z,src/charset.c,"@@ -65,19 +65,20 @@ static int win_nolbr_chartabsize(win_T *wp, char_u *s, colnr_T col,  * Return FAIL if 'iskeyword', 'isident', 'isfname' or 'isprint' option has an  * error, OK otherwise.  */-int init_chartab(void)         {+int init_chartab(void)+{   return buf_init_chartab(curbuf, TRUE); } -int -buf_init_chartab (-    buf_T *buf,-    int global                     /* FALSE: only set buf->b_chartab[] */-)+/*","Let's do that in a separate pass. I want this pass to be mostly code style only and completed as soon as possible to reduce merge conflicts. Doxygenating is comment-only changes, and most of the current function comments are incomplete and having no description for some of the parameters.",
5283042,davidzchen,https://api.github.com/repos/neovim/neovim/pulls/341,10426274,2014-03-10T11:56:21Z,src/diff.c,"@@ -445,62 +499,85 @@ static void diff_check_unchanged(tabpage_T *tp, diff_T *dp)   int i_org;   int i_new;   int off_org, off_new;-  char_u      *line_org;+  char_u *line_org;   int dir = FORWARD;    /* Find the first buffers, use it as the original, compare the other    * buffer lines against this one. */-  for (i_org = 0; i_org < DB_COUNT; ++i_org)-    if (tp->tp_diffbuf[i_org] != NULL)+  for (i_org = 0; i_org < DB_COUNT; ++i_org) {+    if (tp->tp_diffbuf[i_org] != NULL) {       break;-  if (i_org == DB_COUNT)        /* safety check */+    }+  }++  if (i_org == DB_COUNT) { /* safety check */     return;+  } -  if (diff_check_sanity(tp, dp) == FAIL)+  if (diff_check_sanity(tp, dp) == FAIL) {     return;+  }    /* First check lines at the top, then at the bottom. */   off_org = 0;   off_new = 0;-  for (;; ) {++  for (;;) {     /* Repeat until a line is found which is different or the number of      * lines has become zero. */     while (dp->df_count[i_org] > 0) {       /* Copy the line, the next ml_get() will invalidate it.  */-      if (dir == BACKWARD)+      if (dir == BACKWARD) {         off_org = dp->df_count[i_org] - 1;+      }       line_org = vim_strsave(ml_get_buf(tp->tp_diffbuf[i_org],-              dp->df_lnum[i_org] + off_org, FALSE));-      if (line_org == NULL)+                                        dp->df_lnum[i_org] + off_org, FALSE));++      if (line_org == NULL) {         return;+      }+       for (i_new = i_org + 1; i_new < DB_COUNT; ++i_new) {-        if (tp->tp_diffbuf[i_new] == NULL)+        if (tp->tp_diffbuf[i_new] == NULL) {           continue;-        if (dir == BACKWARD)+        }++        if (dir == BACKWARD) {           off_new = dp->df_count[i_new] - 1;+        }+         /* if other buffer doesn't have this line, it was inserted */-        if (off_new < 0 || off_new >= dp->df_count[i_new])+        if ((off_new < 0) || (off_new >= dp->df_count[i_new])) {           break;+        }+         if (diff_cmp(line_org, ml_get_buf(tp->tp_diffbuf[i_new],-                    dp->df_lnum[i_new] + off_new, FALSE)) != 0)+                                          dp->df_lnum[i_new] + off_new,+                                          FALSE)) != 0) {           break;+        }       }       vim_free(line_org);        /* Stop when a line isn't equal in all diff buffers. */-      if (i_new != DB_COUNT)+      if (i_new != DB_COUNT) {         break;+      }        /* Line matched in all buffers, remove it from the diff. */-      for (i_new = i_org; i_new < DB_COUNT; ++i_new)+      for (i_new = i_org; i_new < DB_COUNT; ++i_new) {         if (tp->tp_diffbuf[i_new] != NULL) {-          if (dir == FORWARD)+          if (dir == FORWARD) {             ++dp->df_lnum[i_new];","I think the bigger issue with increment and decrement operators is that in cases such as these, parentheses are necessary.",
5283042,davidzchen,https://api.github.com/repos/neovim/neovim/pulls/341,10426328,2014-03-10T11:58:33Z,src/diff.c,"@@ -34,25 +34,29 @@ #include ""window.h"" #include ""os/os.h"" -static int diff_busy = FALSE;           /* ex_diffgetput() is busy */+static int diff_busy = FALSE;    /* ex_diffgetput() is busy */  /* flags obtained from the 'diffopt' option */-#define DIFF_FILLER     1       /* display filler lines */-#define DIFF_ICASE      2       /* ignore case */-#define DIFF_IWHITE     4       /* ignore change in white space */-#define DIFF_HORIZONTAL 8       /* horizontal splits */-#define DIFF_VERTICAL   16      /* vertical splits */+#define DIFF_FILLER     1        /* display filler lines */+#define DIFF_ICASE      2        /* ignore case */+#define DIFF_IWHITE     4        /* ignore change in white space */+#define DIFF_HORIZONTAL 8        /* horizontal splits */+#define DIFF_VERTICAL   16       /* vertical splits */ static int diff_flags = DIFF_FILLER; -#define LBUFLEN 50              /* length of line in diff file */+#define LBUFLEN 50               /* length of line in diff file */ -static int diff_a_works = MAYBE; /* TRUE when ""diff -a"" works, FALSE when it-                                    doesn't work, MAYBE when not checked yet */+/* TRUE when ""diff -a"" works, FALSE when it doesn't work, MAYBE when not+ * checked yet */+static int diff_a_works = MAYBE;  static int diff_buf_idx(buf_T *buf); static int diff_buf_idx_tp(buf_T *buf, tabpage_T *tp);-static void diff_mark_adjust_tp(tabpage_T *tp, int idx, linenr_T line1,-                                linenr_T line2, long amount,+static void diff_mark_adjust_tp(tabpage_T *tp,",Might want to make the note more explicit that you should only split the line in a parameters list if you cannot fit the next parameter on the current line without exceeding 80 characters.,
5283042,davidzchen,https://api.github.com/repos/neovim/neovim/pulls/341,10427519,2014-03-10T12:51:02Z,src/charset.c,"@@ -65,19 +65,20 @@ static int win_nolbr_chartabsize(win_T *wp, char_u *s, colnr_T col,  * Return FAIL if 'iskeyword', 'isident', 'isfname' or 'isprint' option has an  * error, OK otherwise.  */-int init_chartab(void)         {+int init_chartab(void)+{   return buf_init_chartab(curbuf, TRUE); } -int -buf_init_chartab (-    buf_T *buf,-    int global                     /* FALSE: only set buf->b_chartab[] */-)+/*","I could change those when I move comments from the params list to the function comments, but then we will have some functions with the correct comments and many without. I could change all the comments along with the rest of the formatting, but that will make this entire process take significantly longer.Also, if you'd like, I would greatly appreciate help with this, especially since there are a number of particularly large files like `edit.c` and `eval.c`.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/353,10556851,2014-03-13T09:12:16Z,.travis.yml,"@@ -1,7 +1,5 @@ language: c-script: ./scripts/travis.sh-before_install:-  - sudo apt-get install valgrind-compiler:-  - clang-  - gcc","ISTM that the better approach might be to leave this here (at least then we get to take advantage of parallelism in Travis, since it will use two workers for the builds), and conditionalize the travis script based on whether `CC` is `gcc` or `clang`.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/353,10561514,2014-03-13T12:10:31Z,src/CMakeLists.txt,"@@ -12,8 +12,25 @@ list(APPEND NEOVIM_SOURCES ""${PROJECT_BINARY_DIR}/config/auto/pathdef.c"")  file( GLOB OS_SOURCES os/*.c ) -add_executable (nvim ${NEOVIM_SOURCES} ${OS_SOURCES})-add_library (nvim-test MODULE ${NEOVIM_SOURCES} ${OS_SOURCES})+if(CMAKE_C_COMPILER_ID MATCHES ""Clang"")+  if(DEFINED ENV{SANITIZE})+    message(STATUS ""Enabling the sanitizers"")+    add_definitions(-DEXITFREE) # is this necessary for LeakSanitizer?",That is puzzling... perhaps we could try playing with quarantine-size et al.? https://code.google.com/p/address-sanitizer/wiki/Flags,
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/346,10634205,2014-03-15T10:02:44Z,test/unit/os/fs.moon,"@@ -266,3 +273,64 @@ describe 'fs function', ->       relative_executable = './' .. executable_name       eq TRUE, (mch_can_exe relative_executable)       lfs.chdir old_dir++  describe 'file permissions', ->+    mch_getperm = (filename) ->+      perm = fs.mch_getperm (to_cstr filename)+      tonumber perm++    mch_setperm = (filename, perm) ->+      fs.mch_setperm (to_cstr filename), perm++    bit_set = (number, check_bit) ->+      if 0 == (bit.band number, check_bit) then false else true++    set_bit = (number, to_set) ->+      return bit.bor number, to_set++    unset_bit = (number, to_unset) ->+      return bit.band number, (bit.bnot to_unset)++    describe 'mch_getperm', ->+      it 'returns -1 when the given file does not exist', ->+        eq -1, mch_getperm 'non-existing-file'++      it 'returns a perm > 0 when given an existing file', -> +        assert.is_true (mch_getperm 'unit-test-directory') > 0++      it 'returns S_IRUSR when the file is readable', ->+        perm = mch_getperm 'unit-test-directory'+        assert.is_true (bit_set perm, ffi.C.kS_IRUSR)++      it 'fails if given file does not exist', ->+        eq -1, (mch_getperm 'non-existing-file')",This test is a duplicate of the test in line 295,
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/375,10640544,2014-03-16T17:35:17Z,src/fileio.c,"@@ -472,21 +469,11 @@ void filemess(buf_T *buf, char_u *name, char_u *s, int attr)   }    /*-   * for UNIX: check readonly with perm and mch_access()-   * for MSDOS and Amiga: check readonly by trying to open the file for writing+   * check readonly by trying to open the file for writing    */   file_readonly = FALSE;   if (read_stdin) {","This is implemented so that if opening with O_RDRW is failing, `file_readonly` gets set to `TRUE`.With this 'trick' we can avoid a race condition (http://en.wikipedia.org/wiki/Time_of_check_to_time_of_use) and an extra call to check the perm mask. Maybe I should make this code cleaner and add a comment to describe this. ",
1106732,ilAYAli,https://api.github.com/repos/neovim/neovim/pulls/375,10640574,2014-03-16T17:40:38Z,src/fileio.c,"@@ -472,21 +469,11 @@ void filemess(buf_T *buf, char_u *name, char_u *s, int attr)   }    /*-   * for UNIX: check readonly with perm and mch_access()-   * for MSDOS and Amiga: check readonly by trying to open the file for writing+   * check readonly by trying to open the file for writing    */   file_readonly = FALSE;   if (read_stdin) {","It was this comment that triggered my semantic alarm:""check readonly by trying to open the file for writing""",
317464,saghul,https://api.github.com/repos/neovim/neovim/pulls/289,10641784,2014-03-16T21:26:39Z,src/os/io.c,"@@ -0,0 +1,524 @@+#include <stdbool.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement+   * a simple form of memory management for incoming data without requiring+   * calls to the system memory allocator.+   *+   * Probably the 'apos' (allocated pos) pointer isn't needed, but omitting it+   * would mean we are assuming details about libuv implementation which+   * wouldn't be very robust.+   */ +  unsigned int apos, wpos, rpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t io_thread;+static uv_mutex_t io_mutex;+static uv_cond_t io_cond;+static uv_mutex_t delay_mutex;+static uv_cond_t delay_cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the io_cond */+static bool signal_consumed = false, activity = false,+            data_consumed = false, running = false, eof = false;++static void io_start(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void exit_scroll(void);+static int special_key(char_u *, char_u);+static int cursorhold_key(char_u *);+static int signal_key(char_u *);+static void io_lock();+static void io_unlock();+static void io_timedwait(long ms, bool *condition);+static void io_wait(bool *condition);+static void io_signal(bool *condition);++void io_init() {+  sigset_t set;++  /* uv_disable_stdio_inheritance(); */+  uv_mutex_init(&io_mutex);+  uv_cond_init(&io_cond);+  uv_mutex_init(&delay_mutex);+  uv_cond_init(&delay_cond);+  io_lock();+  /* The event loop runs in a background thread */+  uv_thread_create(&io_thread, io_start, NULL);+  /* Wait for the loop thread to be ready */+  io_wait(&running);+  /* Block signals in the main thread +   * TODO Search for a pure-libuv way of doing this */+  sigfillset(&set);+  pthread_sigmask(SIG_SETMASK, &set, NULL);+  io_unlock();+}++void mch_exit(int r) {+  exiting = TRUE;+  /* stop libuv loop */+  uv_async_send(&stop_loop_async);+  /* wait for the event loop thread */+  uv_thread_join(&io_thread);++  {+    settmode(TMODE_COOK);+    mch_restore_title(3);       /* restore xterm title and icon name */+    /*+     * When t_ti is not empty but it doesn't cause swapping terminal+     * pages, need to output a newline when msg_didout is set.  But when+     * t_ti does swap pages it should not go to the shell page.  Do this+     * before stoptermcap().+     */+    if (swapping_screen() && !newline_on_exit)+      exit_scroll();++    /* Stop termcap: May need to check for T_CRV response, which+     * requires RAW mode. */+    stoptermcap();++    /*+     * A newline is only required after a message in the alternate screen.+     * This is set to TRUE by wait_return().+     */+    if (!swapping_screen() || newline_on_exit)+      exit_scroll();++    /* Cursor may have been switched off without calling starttermcap()+     * when doing ""vim -u vimrc"" and vimrc contains "":q"". */+    if (full_screen)+      cursor_on();+  }+  out_flush();+  ml_close_all(TRUE);           /* remove all memfiles */++#ifdef EXITFREE+  free_all_mem();+#endif++  exit(r);+}++int next_signal() {+  /* FIXME pending_signal must be a queue of signals, right now the event loop+   * is blocking until this function is called. */+  int rv;++  io_lock();+  io_signal(&signal_consumed);+  rv = pending_signal;+  pending_signal = 0;+  io_unlock();++  return rv;+}++/*+ * This is ugly, but necessary at least until we start messing with vget*+ * functions a long time from now+ */+int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt) {+  int rv;++  io_lock();++  if (pending_signal) {+    io_unlock();+    return signal_key(buf);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    /* Take whatever data is available */+    rv = read_from_input_buf(buf, (long)maxlen);+    /* If the loop is paused due to full buffer, notify it that+     * we consumed some data and it may read more */+    io_signal(&data_consumed);+    io_unlock();+    return rv;+  }++  if (wtime >= 0) {+    /* Wait up to 'wtime' milliseconds */+    io_timedwait(wtime, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      io_unlock();+      /* Didn't read anything */+      if (eof) {+        /* Exit when stdin is closed */+        read_error_exit();+      }+      return 0;+    }++  } else {+    if (trigger_cursorhold() && maxlen >= 3) {+      /* When doing a blocking read, first block for 'updatetime' if a+       * cursorhold event can be triggered */+      io_timedwait(p_ut, &activity);++      if (pending_signal) {+        io_unlock();+        return signal_key(buf);+      }++      if (in_buffer.wpos == in_buffer.rpos) {+        io_unlock();+        return cursorhold_key(buf);+      }+    }++    /* Before blocking check for EOF first or we may end up in a deadlock */+    if (eof) {+      io_unlock();+      read_error_exit();+      return 0;+    }++    before_blocking();+    io_wait(&activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }+  }++  /* This was adapted from the original mch_inchar code.  Not sure why it's+   * here, but I guess it has something to do with netbeans support which was+   * removed.  Leave it alone for now */+  if (typebuf_changed(tb_change_cnt)) {+    io_unlock();+    return 0;+  }++  if (in_buffer.wpos == in_buffer.rpos && eof) {+    io_unlock();+    read_error_exit();+    return 0;+  }++  rv = read_from_input_buf(buf, (long)maxlen);+  io_unlock();++  return rv;+}++/* FIXME This is a temporary function, used to satisfy the way vim currently+ * reads characters. Soon it will be removed */+ssize_t mch_inchar_read(char *buf, size_t count) {+  size_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++int mch_char_avail() {+  return in_buffer.rpos < in_buffer.wpos;+}++void mch_delay(long msec, int ignoreinput) {+  int old_tmode;++  uv_mutex_lock(&delay_mutex);++  if (ignoreinput) {+    /* Go to cooked mode without echo, to allow SIGINT interrupting us+     * here.  But we don't want QUIT to kill us (CTRL-\ used in a+     * shell may produce SIGQUIT). */+    in_mch_delay = TRUE;+    old_tmode = curr_tmode;++    if (curr_tmode == TMODE_RAW)+      settmode(TMODE_SLEEP);++    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);++    settmode(old_tmode);+    in_mch_delay = FALSE;+  } else {+    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);+  }++  uv_mutex_unlock(&delay_mutex);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck() {+  /*+   * Apparently this has no effect on the tests, so leave it commented for now.+   * Soon we'll handle SIGINTs and user input in the UI, so this won't matter+   * anyway+   */+  +  if (curr_tmode == TMODE_RAW && mch_char_avail())+    fill_input_buf(FALSE);+}++static void io_start(void *arg) {+  uv_loop_t *loop;+  uv_idle_t idler; +  uv_signal_t sint, shup, squit, sabrt, sterm, swinch;+  uv_stream_t stdin_stream;++  memset(&in_buffer, 0, sizeof(in_buffer));++  UNUSED(arg);+  loop = uv_loop_new();",Better allocate the loop on stack or heap and use `uv_loop_init`. `uv_loop_new` is now considered deprecated.,
317464,saghul,https://api.github.com/repos/neovim/neovim/pulls/289,10641798,2014-03-16T21:29:02Z,src/os/io.c,"@@ -0,0 +1,524 @@+#include <stdbool.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement+   * a simple form of memory management for incoming data without requiring+   * calls to the system memory allocator.+   *+   * Probably the 'apos' (allocated pos) pointer isn't needed, but omitting it+   * would mean we are assuming details about libuv implementation which+   * wouldn't be very robust.+   */ +  unsigned int apos, wpos, rpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t io_thread;+static uv_mutex_t io_mutex;+static uv_cond_t io_cond;+static uv_mutex_t delay_mutex;+static uv_cond_t delay_cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the io_cond */+static bool signal_consumed = false, activity = false,+            data_consumed = false, running = false, eof = false;++static void io_start(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void exit_scroll(void);+static int special_key(char_u *, char_u);+static int cursorhold_key(char_u *);+static int signal_key(char_u *);+static void io_lock();+static void io_unlock();+static void io_timedwait(long ms, bool *condition);+static void io_wait(bool *condition);+static void io_signal(bool *condition);++void io_init() {+  sigset_t set;++  /* uv_disable_stdio_inheritance(); */+  uv_mutex_init(&io_mutex);+  uv_cond_init(&io_cond);+  uv_mutex_init(&delay_mutex);+  uv_cond_init(&delay_cond);+  io_lock();+  /* The event loop runs in a background thread */+  uv_thread_create(&io_thread, io_start, NULL);+  /* Wait for the loop thread to be ready */+  io_wait(&running);+  /* Block signals in the main thread +   * TODO Search for a pure-libuv way of doing this */+  sigfillset(&set);+  pthread_sigmask(SIG_SETMASK, &set, NULL);+  io_unlock();+}++void mch_exit(int r) {+  exiting = TRUE;+  /* stop libuv loop */+  uv_async_send(&stop_loop_async);+  /* wait for the event loop thread */+  uv_thread_join(&io_thread);++  {+    settmode(TMODE_COOK);+    mch_restore_title(3);       /* restore xterm title and icon name */+    /*+     * When t_ti is not empty but it doesn't cause swapping terminal+     * pages, need to output a newline when msg_didout is set.  But when+     * t_ti does swap pages it should not go to the shell page.  Do this+     * before stoptermcap().+     */+    if (swapping_screen() && !newline_on_exit)+      exit_scroll();++    /* Stop termcap: May need to check for T_CRV response, which+     * requires RAW mode. */+    stoptermcap();++    /*+     * A newline is only required after a message in the alternate screen.+     * This is set to TRUE by wait_return().+     */+    if (!swapping_screen() || newline_on_exit)+      exit_scroll();++    /* Cursor may have been switched off without calling starttermcap()+     * when doing ""vim -u vimrc"" and vimrc contains "":q"". */+    if (full_screen)+      cursor_on();+  }+  out_flush();+  ml_close_all(TRUE);           /* remove all memfiles */++#ifdef EXITFREE+  free_all_mem();+#endif++  exit(r);+}++int next_signal() {+  /* FIXME pending_signal must be a queue of signals, right now the event loop+   * is blocking until this function is called. */+  int rv;++  io_lock();+  io_signal(&signal_consumed);+  rv = pending_signal;+  pending_signal = 0;+  io_unlock();++  return rv;+}++/*+ * This is ugly, but necessary at least until we start messing with vget*+ * functions a long time from now+ */+int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt) {+  int rv;++  io_lock();++  if (pending_signal) {+    io_unlock();+    return signal_key(buf);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    /* Take whatever data is available */+    rv = read_from_input_buf(buf, (long)maxlen);+    /* If the loop is paused due to full buffer, notify it that+     * we consumed some data and it may read more */+    io_signal(&data_consumed);+    io_unlock();+    return rv;+  }++  if (wtime >= 0) {+    /* Wait up to 'wtime' milliseconds */+    io_timedwait(wtime, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      io_unlock();+      /* Didn't read anything */+      if (eof) {+        /* Exit when stdin is closed */+        read_error_exit();+      }+      return 0;+    }++  } else {+    if (trigger_cursorhold() && maxlen >= 3) {+      /* When doing a blocking read, first block for 'updatetime' if a+       * cursorhold event can be triggered */+      io_timedwait(p_ut, &activity);++      if (pending_signal) {+        io_unlock();+        return signal_key(buf);+      }++      if (in_buffer.wpos == in_buffer.rpos) {+        io_unlock();+        return cursorhold_key(buf);+      }+    }++    /* Before blocking check for EOF first or we may end up in a deadlock */+    if (eof) {+      io_unlock();+      read_error_exit();+      return 0;+    }++    before_blocking();+    io_wait(&activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }+  }++  /* This was adapted from the original mch_inchar code.  Not sure why it's+   * here, but I guess it has something to do with netbeans support which was+   * removed.  Leave it alone for now */+  if (typebuf_changed(tb_change_cnt)) {+    io_unlock();+    return 0;+  }++  if (in_buffer.wpos == in_buffer.rpos && eof) {+    io_unlock();+    read_error_exit();+    return 0;+  }++  rv = read_from_input_buf(buf, (long)maxlen);+  io_unlock();++  return rv;+}++/* FIXME This is a temporary function, used to satisfy the way vim currently+ * reads characters. Soon it will be removed */+ssize_t mch_inchar_read(char *buf, size_t count) {+  size_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++int mch_char_avail() {+  return in_buffer.rpos < in_buffer.wpos;+}++void mch_delay(long msec, int ignoreinput) {+  int old_tmode;++  uv_mutex_lock(&delay_mutex);++  if (ignoreinput) {+    /* Go to cooked mode without echo, to allow SIGINT interrupting us+     * here.  But we don't want QUIT to kill us (CTRL-\ used in a+     * shell may produce SIGQUIT). */+    in_mch_delay = TRUE;+    old_tmode = curr_tmode;++    if (curr_tmode == TMODE_RAW)+      settmode(TMODE_SLEEP);++    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);++    settmode(old_tmode);+    in_mch_delay = FALSE;+  } else {+    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);+  }++  uv_mutex_unlock(&delay_mutex);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck() {+  /*+   * Apparently this has no effect on the tests, so leave it commented for now.+   * Soon we'll handle SIGINTs and user input in the UI, so this won't matter+   * anyway+   */+  +  if (curr_tmode == TMODE_RAW && mch_char_avail())+    fill_input_buf(FALSE);+}++static void io_start(void *arg) {+  uv_loop_t *loop;+  uv_idle_t idler; +  uv_signal_t sint, shup, squit, sabrt, sterm, swinch;+  uv_stream_t stdin_stream;++  memset(&in_buffer, 0, sizeof(in_buffer));++  UNUSED(arg);+  loop = uv_loop_new();+  /* Idler for signaling the main thread when the loop is running */+  uv_idle_init(loop, &idler);+  idler.data = &stdin_stream;+  uv_idle_start(&idler, loop_running);+  /* Async watcher used by the main thread to stop the loop */+  uv_async_init(loop, &stop_loop_async, stop_loop);+  /* stdin */+  /* FIXME setting fd to non-blocking is only needed on unix */+  fcntl(read_cmd_fd, F_SETFL, fcntl(read_cmd_fd, F_GETFL, 0) | O_NONBLOCK);+  uv_pipe_init(loop, (uv_pipe_t *)&stdin_stream, 0);+  uv_pipe_open((uv_pipe_t *)&stdin_stream, read_cmd_fd);+  /* signals */+  uv_signal_init(loop, &sint);+  uv_signal_start(&sint, signal_cb, SIGINT);+  uv_signal_init(loop, &shup);+  uv_signal_start(&shup, signal_cb, SIGHUP);+  uv_signal_init(loop, &squit);+  uv_signal_start(&squit, signal_cb, SIGQUIT);+  uv_signal_init(loop, &sabrt);+  uv_signal_start(&sabrt, signal_cb, SIGABRT);+  uv_signal_init(loop, &sterm);+  uv_signal_start(&sterm, signal_cb, SIGTERM);+  uv_signal_init(loop, &swinch);+  uv_signal_start(&swinch, signal_cb, SIGWINCH);+  /* start processing events */+  uv_run(loop, UV_RUN_DEFAULT);+  /* free the event loop */+  uv_loop_delete(loop);","Use `uv_loop_close` instead, `uv_loop_delete` is now deprecated. Also, it would be a good idea to use uv_walk to close all handles, and then run the loop one last time, with `UV_RUN_ONCE` so make sure all handles have been closing before deleting the loop.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/289,10641988,2014-03-16T21:56:32Z,src/os/io.c,"@@ -0,0 +1,524 @@+#include <stdbool.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement+   * a simple form of memory management for incoming data without requiring+   * calls to the system memory allocator.+   *+   * Probably the 'apos' (allocated pos) pointer isn't needed, but omitting it+   * would mean we are assuming details about libuv implementation which+   * wouldn't be very robust.+   */ +  unsigned int apos, wpos, rpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t io_thread;+static uv_mutex_t io_mutex;+static uv_cond_t io_cond;+static uv_mutex_t delay_mutex;+static uv_cond_t delay_cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the io_cond */+static bool signal_consumed = false, activity = false,+            data_consumed = false, running = false, eof = false;++static void io_start(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void exit_scroll(void);+static int special_key(char_u *, char_u);+static int cursorhold_key(char_u *);+static int signal_key(char_u *);+static void io_lock();+static void io_unlock();+static void io_timedwait(long ms, bool *condition);+static void io_wait(bool *condition);+static void io_signal(bool *condition);++void io_init() {+  sigset_t set;++  /* uv_disable_stdio_inheritance(); */+  uv_mutex_init(&io_mutex);+  uv_cond_init(&io_cond);+  uv_mutex_init(&delay_mutex);+  uv_cond_init(&delay_cond);+  io_lock();+  /* The event loop runs in a background thread */+  uv_thread_create(&io_thread, io_start, NULL);+  /* Wait for the loop thread to be ready */+  io_wait(&running);+  /* Block signals in the main thread +   * TODO Search for a pure-libuv way of doing this */+  sigfillset(&set);+  pthread_sigmask(SIG_SETMASK, &set, NULL);+  io_unlock();+}++void mch_exit(int r) {+  exiting = TRUE;+  /* stop libuv loop */+  uv_async_send(&stop_loop_async);+  /* wait for the event loop thread */+  uv_thread_join(&io_thread);++  {+    settmode(TMODE_COOK);+    mch_restore_title(3);       /* restore xterm title and icon name */+    /*+     * When t_ti is not empty but it doesn't cause swapping terminal+     * pages, need to output a newline when msg_didout is set.  But when+     * t_ti does swap pages it should not go to the shell page.  Do this+     * before stoptermcap().+     */+    if (swapping_screen() && !newline_on_exit)+      exit_scroll();++    /* Stop termcap: May need to check for T_CRV response, which+     * requires RAW mode. */+    stoptermcap();++    /*+     * A newline is only required after a message in the alternate screen.+     * This is set to TRUE by wait_return().+     */+    if (!swapping_screen() || newline_on_exit)+      exit_scroll();++    /* Cursor may have been switched off without calling starttermcap()+     * when doing ""vim -u vimrc"" and vimrc contains "":q"". */+    if (full_screen)+      cursor_on();+  }+  out_flush();+  ml_close_all(TRUE);           /* remove all memfiles */++#ifdef EXITFREE+  free_all_mem();+#endif++  exit(r);+}++int next_signal() {+  /* FIXME pending_signal must be a queue of signals, right now the event loop+   * is blocking until this function is called. */+  int rv;++  io_lock();+  io_signal(&signal_consumed);+  rv = pending_signal;+  pending_signal = 0;+  io_unlock();++  return rv;+}++/*+ * This is ugly, but necessary at least until we start messing with vget*+ * functions a long time from now+ */+int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt) {+  int rv;++  io_lock();++  if (pending_signal) {+    io_unlock();+    return signal_key(buf);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    /* Take whatever data is available */+    rv = read_from_input_buf(buf, (long)maxlen);+    /* If the loop is paused due to full buffer, notify it that+     * we consumed some data and it may read more */+    io_signal(&data_consumed);+    io_unlock();+    return rv;+  }++  if (wtime >= 0) {+    /* Wait up to 'wtime' milliseconds */+    io_timedwait(wtime, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      io_unlock();+      /* Didn't read anything */+      if (eof) {+        /* Exit when stdin is closed */+        read_error_exit();+      }+      return 0;+    }++  } else {+    if (trigger_cursorhold() && maxlen >= 3) {+      /* When doing a blocking read, first block for 'updatetime' if a+       * cursorhold event can be triggered */+      io_timedwait(p_ut, &activity);++      if (pending_signal) {+        io_unlock();+        return signal_key(buf);+      }++      if (in_buffer.wpos == in_buffer.rpos) {+        io_unlock();+        return cursorhold_key(buf);+      }+    }++    /* Before blocking check for EOF first or we may end up in a deadlock */+    if (eof) {+      io_unlock();+      read_error_exit();+      return 0;+    }++    before_blocking();+    io_wait(&activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }+  }++  /* This was adapted from the original mch_inchar code.  Not sure why it's+   * here, but I guess it has something to do with netbeans support which was+   * removed.  Leave it alone for now */+  if (typebuf_changed(tb_change_cnt)) {+    io_unlock();+    return 0;+  }++  if (in_buffer.wpos == in_buffer.rpos && eof) {+    io_unlock();+    read_error_exit();+    return 0;+  }++  rv = read_from_input_buf(buf, (long)maxlen);+  io_unlock();++  return rv;+}++/* FIXME This is a temporary function, used to satisfy the way vim currently+ * reads characters. Soon it will be removed */+ssize_t mch_inchar_read(char *buf, size_t count) {+  size_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++int mch_char_avail() {+  return in_buffer.rpos < in_buffer.wpos;+}++void mch_delay(long msec, int ignoreinput) {+  int old_tmode;++  uv_mutex_lock(&delay_mutex);++  if (ignoreinput) {+    /* Go to cooked mode without echo, to allow SIGINT interrupting us+     * here.  But we don't want QUIT to kill us (CTRL-\ used in a+     * shell may produce SIGQUIT). */+    in_mch_delay = TRUE;+    old_tmode = curr_tmode;++    if (curr_tmode == TMODE_RAW)+      settmode(TMODE_SLEEP);++    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);++    settmode(old_tmode);+    in_mch_delay = FALSE;+  } else {+    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);+  }++  uv_mutex_unlock(&delay_mutex);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck() {+  /*+   * Apparently this has no effect on the tests, so leave it commented for now.+   * Soon we'll handle SIGINTs and user input in the UI, so this won't matter+   * anyway+   */+  +  if (curr_tmode == TMODE_RAW && mch_char_avail())+    fill_input_buf(FALSE);+}++static void io_start(void *arg) {+  uv_loop_t *loop;+  uv_idle_t idler; +  uv_signal_t sint, shup, squit, sabrt, sterm, swinch;+  uv_stream_t stdin_stream;++  memset(&in_buffer, 0, sizeof(in_buffer));++  UNUSED(arg);+  loop = uv_loop_new();+  /* Idler for signaling the main thread when the loop is running */+  uv_idle_init(loop, &idler);+  idler.data = &stdin_stream;+  uv_idle_start(&idler, loop_running);+  /* Async watcher used by the main thread to stop the loop */+  uv_async_init(loop, &stop_loop_async, stop_loop);+  /* stdin */+  /* FIXME setting fd to non-blocking is only needed on unix */+  fcntl(read_cmd_fd, F_SETFL, fcntl(read_cmd_fd, F_GETFL, 0) | O_NONBLOCK);+  uv_pipe_init(loop, (uv_pipe_t *)&stdin_stream, 0);+  uv_pipe_open((uv_pipe_t *)&stdin_stream, read_cmd_fd);+  /* signals */+  uv_signal_init(loop, &sint);+  uv_signal_start(&sint, signal_cb, SIGINT);+  uv_signal_init(loop, &shup);+  uv_signal_start(&shup, signal_cb, SIGHUP);+  uv_signal_init(loop, &squit);+  uv_signal_start(&squit, signal_cb, SIGQUIT);+  uv_signal_init(loop, &sabrt);+  uv_signal_start(&sabrt, signal_cb, SIGABRT);+  uv_signal_init(loop, &sterm);+  uv_signal_start(&sterm, signal_cb, SIGTERM);+  uv_signal_init(loop, &swinch);+  uv_signal_start(&swinch, signal_cb, SIGWINCH);+  /* start processing events */+  uv_run(loop, UV_RUN_DEFAULT);+  /* free the event loop */+  uv_loop_delete(loop);+}++/* Signal the main thread that the loop started running */+static void loop_running(uv_idle_t *handle, int status) {+  uv_idle_stop(handle);+  io_lock();+  uv_read_start((uv_stream_t *)handle->data, alloc_buffer_cb, read_cb);+  io_signal(&running);+  io_unlock();+}++static void stop_loop(uv_async_t *handle, int status) {+  UNUSED(status);+  uv_stop(handle->loop);+}++/* Called by libuv to allocate memory for reading. This uses a fixed buffer+ * through the entire stream lifetime */+static void alloc_buffer_cb(uv_handle_t *handle, size_t ssize, uv_buf_t *rv)+{+  int move_count;+  size_t available;++  UNUSED(handle);++  io_lock();++  available = BUF_SIZE - in_buffer.apos;++  if (!available) {+    if (in_buffer.rpos == 0) {+      /* Pause the stream until the main thread consumes some data. The io+       * mutex should only be unlocked when the stream is stopped in the+       * read_cb */+      rv->len = 0;+      io_unlock();+      return;+    }+    /* +     * Out of space in internal buffer, move data to the 'left' as much as+     * possible.+     */+    move_count = in_buffer.apos - in_buffer.rpos;+    memmove(in_buffer.data, in_buffer.data + in_buffer.rpos, move_count);+    in_buffer.wpos -= in_buffer.rpos;+    in_buffer.apos -= in_buffer.rpos;+    in_buffer.rpos = 0;+    available = BUF_SIZE - in_buffer.apos;+  }++  rv->base = (char *)(in_buffer.data + in_buffer.apos);+  rv->len = available;+  in_buffer.apos += available;+  io_unlock();+}++/*+ * The actual reading was already performed by libuv, this callback will do one+ * of the following:+ *    - If EOF was reached, it will set appropriate flags and signal the main+ *      thread to continue+ *    - If the alloc_buffer_cb didnt allocate anything, then it will pause the+ *      input stream.+ *    - If 'cnt' > 0, it will update the buffer write position(wpos) to reflect+ *      what was actually written.+ */+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf) {+  UNUSED(buf); /* Data is already on the buffer */++  if (cnt < 0) {++    if (cnt == UV_EOF) {+      /* EOF, stop the event loop and signal the main thread. This will cause+       * vim to exit */+      eof = true;+      io_lock();+      io_signal(&activity);+      uv_stop(stream->loop);+      io_unlock();+    } else if (cnt == UV_ENOBUFS) {+      io_lock();+      io_wait(&data_consumed);+      /* Resume reading */+      io_unlock();+    } else {+      fprintf(stderr, ""Unexpected error %ld\n"", cnt);+    }+    return;+  }++  io_lock();+  /* Data was already written, so all we need is to update 'wpos' to reflect+   * that */+  in_buffer.wpos += cnt;+  /* It's very likely that most of the ""allocated"" space wasn't used, so adjust+   * `apos` to to `wpos` */+  in_buffer.apos = in_buffer.wpos;",@saghul I'm not sure about the best way to deal with this situation. This code is here to restore unused buffer area(eg `alloc_cb` returns `buf->len == 4096` but only 1 byte was used). I'm sure this works if libuv calls `read_cb` right after `alloc_buffer_cb`. But for `alloc_cb` -> `alloc_cb` -> `read_cb` -> `read_cb`  I would probably need a stack of pointers. What do you think?,
317464,saghul,https://api.github.com/repos/neovim/neovim/pulls/289,10642052,2014-03-16T22:02:31Z,src/os/io.c,"@@ -0,0 +1,524 @@+#include <stdbool.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement+   * a simple form of memory management for incoming data without requiring+   * calls to the system memory allocator.+   *+   * Probably the 'apos' (allocated pos) pointer isn't needed, but omitting it+   * would mean we are assuming details about libuv implementation which+   * wouldn't be very robust.+   */ +  unsigned int apos, wpos, rpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t io_thread;+static uv_mutex_t io_mutex;+static uv_cond_t io_cond;+static uv_mutex_t delay_mutex;+static uv_cond_t delay_cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the io_cond */+static bool signal_consumed = false, activity = false,+            data_consumed = false, running = false, eof = false;++static void io_start(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void exit_scroll(void);+static int special_key(char_u *, char_u);+static int cursorhold_key(char_u *);+static int signal_key(char_u *);+static void io_lock();+static void io_unlock();+static void io_timedwait(long ms, bool *condition);+static void io_wait(bool *condition);+static void io_signal(bool *condition);++void io_init() {+  sigset_t set;++  /* uv_disable_stdio_inheritance(); */+  uv_mutex_init(&io_mutex);+  uv_cond_init(&io_cond);+  uv_mutex_init(&delay_mutex);+  uv_cond_init(&delay_cond);+  io_lock();+  /* The event loop runs in a background thread */+  uv_thread_create(&io_thread, io_start, NULL);+  /* Wait for the loop thread to be ready */+  io_wait(&running);+  /* Block signals in the main thread +   * TODO Search for a pure-libuv way of doing this */+  sigfillset(&set);+  pthread_sigmask(SIG_SETMASK, &set, NULL);+  io_unlock();+}++void mch_exit(int r) {+  exiting = TRUE;+  /* stop libuv loop */+  uv_async_send(&stop_loop_async);+  /* wait for the event loop thread */+  uv_thread_join(&io_thread);++  {+    settmode(TMODE_COOK);+    mch_restore_title(3);       /* restore xterm title and icon name */+    /*+     * When t_ti is not empty but it doesn't cause swapping terminal+     * pages, need to output a newline when msg_didout is set.  But when+     * t_ti does swap pages it should not go to the shell page.  Do this+     * before stoptermcap().+     */+    if (swapping_screen() && !newline_on_exit)+      exit_scroll();++    /* Stop termcap: May need to check for T_CRV response, which+     * requires RAW mode. */+    stoptermcap();++    /*+     * A newline is only required after a message in the alternate screen.+     * This is set to TRUE by wait_return().+     */+    if (!swapping_screen() || newline_on_exit)+      exit_scroll();++    /* Cursor may have been switched off without calling starttermcap()+     * when doing ""vim -u vimrc"" and vimrc contains "":q"". */+    if (full_screen)+      cursor_on();+  }+  out_flush();+  ml_close_all(TRUE);           /* remove all memfiles */++#ifdef EXITFREE+  free_all_mem();+#endif++  exit(r);+}++int next_signal() {+  /* FIXME pending_signal must be a queue of signals, right now the event loop+   * is blocking until this function is called. */+  int rv;++  io_lock();+  io_signal(&signal_consumed);+  rv = pending_signal;+  pending_signal = 0;+  io_unlock();++  return rv;+}++/*+ * This is ugly, but necessary at least until we start messing with vget*+ * functions a long time from now+ */+int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt) {+  int rv;++  io_lock();++  if (pending_signal) {+    io_unlock();+    return signal_key(buf);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    /* Take whatever data is available */+    rv = read_from_input_buf(buf, (long)maxlen);+    /* If the loop is paused due to full buffer, notify it that+     * we consumed some data and it may read more */+    io_signal(&data_consumed);+    io_unlock();+    return rv;+  }++  if (wtime >= 0) {+    /* Wait up to 'wtime' milliseconds */+    io_timedwait(wtime, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      io_unlock();+      /* Didn't read anything */+      if (eof) {+        /* Exit when stdin is closed */+        read_error_exit();+      }+      return 0;+    }++  } else {+    if (trigger_cursorhold() && maxlen >= 3) {+      /* When doing a blocking read, first block for 'updatetime' if a+       * cursorhold event can be triggered */+      io_timedwait(p_ut, &activity);++      if (pending_signal) {+        io_unlock();+        return signal_key(buf);+      }++      if (in_buffer.wpos == in_buffer.rpos) {+        io_unlock();+        return cursorhold_key(buf);+      }+    }++    /* Before blocking check for EOF first or we may end up in a deadlock */+    if (eof) {+      io_unlock();+      read_error_exit();+      return 0;+    }++    before_blocking();+    io_wait(&activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }+  }++  /* This was adapted from the original mch_inchar code.  Not sure why it's+   * here, but I guess it has something to do with netbeans support which was+   * removed.  Leave it alone for now */+  if (typebuf_changed(tb_change_cnt)) {+    io_unlock();+    return 0;+  }++  if (in_buffer.wpos == in_buffer.rpos && eof) {+    io_unlock();+    read_error_exit();+    return 0;+  }++  rv = read_from_input_buf(buf, (long)maxlen);+  io_unlock();++  return rv;+}++/* FIXME This is a temporary function, used to satisfy the way vim currently+ * reads characters. Soon it will be removed */+ssize_t mch_inchar_read(char *buf, size_t count) {+  size_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++int mch_char_avail() {+  return in_buffer.rpos < in_buffer.wpos;+}++void mch_delay(long msec, int ignoreinput) {+  int old_tmode;++  uv_mutex_lock(&delay_mutex);++  if (ignoreinput) {+    /* Go to cooked mode without echo, to allow SIGINT interrupting us+     * here.  But we don't want QUIT to kill us (CTRL-\ used in a+     * shell may produce SIGQUIT). */+    in_mch_delay = TRUE;+    old_tmode = curr_tmode;++    if (curr_tmode == TMODE_RAW)+      settmode(TMODE_SLEEP);++    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);++    settmode(old_tmode);+    in_mch_delay = FALSE;+  } else {+    (void)uv_cond_timedwait(&delay_cond, &delay_mutex, msec * 1000000);+  }++  uv_mutex_unlock(&delay_mutex);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck() {+  /*+   * Apparently this has no effect on the tests, so leave it commented for now.+   * Soon we'll handle SIGINTs and user input in the UI, so this won't matter+   * anyway+   */+  +  if (curr_tmode == TMODE_RAW && mch_char_avail())+    fill_input_buf(FALSE);+}++static void io_start(void *arg) {+  uv_loop_t *loop;+  uv_idle_t idler; +  uv_signal_t sint, shup, squit, sabrt, sterm, swinch;+  uv_stream_t stdin_stream;++  memset(&in_buffer, 0, sizeof(in_buffer));++  UNUSED(arg);+  loop = uv_loop_new();+  /* Idler for signaling the main thread when the loop is running */+  uv_idle_init(loop, &idler);+  idler.data = &stdin_stream;+  uv_idle_start(&idler, loop_running);+  /* Async watcher used by the main thread to stop the loop */+  uv_async_init(loop, &stop_loop_async, stop_loop);+  /* stdin */+  /* FIXME setting fd to non-blocking is only needed on unix */+  fcntl(read_cmd_fd, F_SETFL, fcntl(read_cmd_fd, F_GETFL, 0) | O_NONBLOCK);+  uv_pipe_init(loop, (uv_pipe_t *)&stdin_stream, 0);+  uv_pipe_open((uv_pipe_t *)&stdin_stream, read_cmd_fd);+  /* signals */+  uv_signal_init(loop, &sint);+  uv_signal_start(&sint, signal_cb, SIGINT);+  uv_signal_init(loop, &shup);+  uv_signal_start(&shup, signal_cb, SIGHUP);+  uv_signal_init(loop, &squit);+  uv_signal_start(&squit, signal_cb, SIGQUIT);+  uv_signal_init(loop, &sabrt);+  uv_signal_start(&sabrt, signal_cb, SIGABRT);+  uv_signal_init(loop, &sterm);+  uv_signal_start(&sterm, signal_cb, SIGTERM);+  uv_signal_init(loop, &swinch);+  uv_signal_start(&swinch, signal_cb, SIGWINCH);+  /* start processing events */+  uv_run(loop, UV_RUN_DEFAULT);+  /* free the event loop */+  uv_loop_delete(loop);+}++/* Signal the main thread that the loop started running */+static void loop_running(uv_idle_t *handle, int status) {+  uv_idle_stop(handle);+  io_lock();+  uv_read_start((uv_stream_t *)handle->data, alloc_buffer_cb, read_cb);+  io_signal(&running);+  io_unlock();+}++static void stop_loop(uv_async_t *handle, int status) {+  UNUSED(status);+  uv_stop(handle->loop);+}++/* Called by libuv to allocate memory for reading. This uses a fixed buffer+ * through the entire stream lifetime */+static void alloc_buffer_cb(uv_handle_t *handle, size_t ssize, uv_buf_t *rv)+{+  int move_count;+  size_t available;++  UNUSED(handle);++  io_lock();++  available = BUF_SIZE - in_buffer.apos;++  if (!available) {+    if (in_buffer.rpos == 0) {+      /* Pause the stream until the main thread consumes some data. The io+       * mutex should only be unlocked when the stream is stopped in the+       * read_cb */+      rv->len = 0;+      io_unlock();+      return;+    }+    /* +     * Out of space in internal buffer, move data to the 'left' as much as+     * possible.+     */+    move_count = in_buffer.apos - in_buffer.rpos;+    memmove(in_buffer.data, in_buffer.data + in_buffer.rpos, move_count);+    in_buffer.wpos -= in_buffer.rpos;+    in_buffer.apos -= in_buffer.rpos;+    in_buffer.rpos = 0;+    available = BUF_SIZE - in_buffer.apos;+  }++  rv->base = (char *)(in_buffer.data + in_buffer.apos);+  rv->len = available;+  in_buffer.apos += available;+  io_unlock();+}++/*+ * The actual reading was already performed by libuv, this callback will do one+ * of the following:+ *    - If EOF was reached, it will set appropriate flags and signal the main+ *      thread to continue+ *    - If the alloc_buffer_cb didnt allocate anything, then it will pause the+ *      input stream.+ *    - If 'cnt' > 0, it will update the buffer write position(wpos) to reflect+ *      what was actually written.+ */+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf) {+  UNUSED(buf); /* Data is already on the buffer */++  if (cnt < 0) {++    if (cnt == UV_EOF) {+      /* EOF, stop the event loop and signal the main thread. This will cause+       * vim to exit */+      eof = true;+      io_lock();+      io_signal(&activity);+      uv_stop(stream->loop);+      io_unlock();+    } else if (cnt == UV_ENOBUFS) {+      io_lock();+      io_wait(&data_consumed);+      /* Resume reading */+      io_unlock();+    } else {+      fprintf(stderr, ""Unexpected error %ld\n"", cnt);+    }+    return;+  }++  io_lock();+  /* Data was already written, so all we need is to update 'wpos' to reflect+   * that */+  in_buffer.wpos += cnt;+  /* It's very likely that most of the ""allocated"" space wasn't used, so adjust+   * `apos` to to `wpos` */+  in_buffer.apos = in_buffer.wpos;","Yeah, I guess that would be one way to do it. You can have the slab statically allocated (maybe making it bigger could help) and have alloc_cb return some sort of 'view' of the buffer. Then after `read_cb` you could 'return' that view and make it available for other allocations.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/377,10690322,2014-03-18T04:37:08Z,src/ex_cmds_defs.h,"@@ -571,12 +567,6 @@ enum CMD_index       RANGE|NOTADR|COUNT|TRLBAR|BANG),   EX(CMD_ltag,            ""ltag"", ex_tag,       NOTADR|TRLBAR|BANG|WORD1),-  EX(CMD_lua,             ""lua"",          ex_lua,","@justinmk these commands require some glue code. @tarruda already deleted this glue code and it's not coming back: better extensibility support is neovim's main selling point.To be fair, now that I think about it, I am not sure if the Lua commands will be preserved even with Lua being neovim's first class citizen. We should wait @tarruda's comments on this.",
1882250,mahkoh,https://api.github.com/repos/neovim/neovim/pulls/289,10693100,2014-03-18T07:41:48Z,src/os/io.c,"@@ -0,0 +1,560 @@+#include <stdbool.h>+#include <stdint.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement+   * a simple form of memory management for incoming data without requiring+   * calls to the system memory allocator.+   *+   * Probably the 'apos' (allocated pos) pointer isn't needed, but omitting it+   * would mean we are assuming details about libuv implementation which+   * wouldn't be very robust.+   */ +  unsigned int apos, wpos, rpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t io_thread;+static uv_mutex_t io_mutex;+static uv_cond_t io_cond;+static uv_mutex_t delay_mutex;+static uv_cond_t delay_cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the io_cond */+static bool signal_consumed = false, activity = false,+            data_consumed = false, running = false, eof = false;+static void io_start(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void exit_scroll(void);+static int special_key(char_u *, char_u);+static int cursorhold_key(char_u *);+static int signal_key(char_u *);+static void io_lock();+static void io_unlock();+static void io_timedwait(uint64_t ms, bool *condition);+static void io_wait(bool *condition);+static void io_signal(bool *condition);+static void delay(uint64_t ms);++void io_init() {+  sigset_t set;++  /* uv_disable_stdio_inheritance(); */+  uv_mutex_init(&io_mutex);+  uv_cond_init(&io_cond);+  uv_mutex_init(&delay_mutex);+  uv_cond_init(&delay_cond);+  io_lock();+  /* The event loop runs in a background thread */+  uv_thread_create(&io_thread, io_start, NULL);+  /* Wait for the loop thread to be ready */+  io_wait(&running);+  /* Block all signals except SIGTSTP in the main thread */+  sigfillset(&set);+  sigdelset(&set, SIGTSTP);+  pthread_sigmask(SIG_SETMASK, &set, NULL);+  io_unlock();+}++void mch_exit(int r) {+  exiting = TRUE;+  /* stop libuv loop */+  io_lock();+  /* uv_async_send may try to write on a closed FD, causing an `abort`.+   * Make sure this doesn't happen by checking if eof is set */+  if (!eof)+    uv_async_send(&stop_loop_async);+  io_unlock();+  /* wait for the event loop thread */+  uv_thread_join(&io_thread);++  {+    settmode(TMODE_COOK);+    mch_restore_title(3);       /* restore xterm title and icon name */+    /*+     * When t_ti is not empty but it doesn't cause swapping terminal+     * pages, need to output a newline when msg_didout is set.  But when+     * t_ti does swap pages it should not go to the shell page.  Do this+     * before stoptermcap().+     */+    if (swapping_screen() && !newline_on_exit)+      exit_scroll();++    /* Stop termcap: May need to check for T_CRV response, which+     * requires RAW mode. */+    stoptermcap();++    /*+     * A newline is only required after a message in the alternate screen.+     * This is set to TRUE by wait_return().+     */+    if (!swapping_screen() || newline_on_exit)+      exit_scroll();++    /* Cursor may have been switched off without calling starttermcap()+     * when doing ""vim -u vimrc"" and vimrc contains "":q"". */+    if (full_screen)+      cursor_on();+  }+  out_flush();+  ml_close_all(TRUE);           /* remove all memfiles */++#ifdef EXITFREE+  free_all_mem();+#endif++  exit(r);+}++int next_signal() {+  /* FIXME pending_signal must be a queue of signals, right now the event loop+   * is blocking until this function is called. */+  int rv;++  io_lock();+  io_signal(&signal_consumed);+  rv = pending_signal;+  pending_signal = 0;+  io_unlock();++  return rv;+}++/*+ * This is ugly, but necessary at least until we start messing with vget*+ * functions a long time from now+ */+int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt) {+  int rv;++  io_lock();++  if (pending_signal) {+    io_unlock();+    return signal_key(buf);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    /* Take whatever data is available */+    rv = read_from_input_buf(buf, (long)maxlen);+    /* If the loop is paused due to full buffer, notify it that+     * we consumed some data and it may read more */+    io_signal(&data_consumed);+    io_unlock();+    return rv;+  }++  if (wtime >= 0) {+    /* Wait up to 'wtime' milliseconds */+    io_timedwait(wtime, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      io_unlock();+      /* Didn't read anything */+      if (eof) {+        /* Exit when stdin is closed */+        read_error_exit();+      }+      return 0;+    }++  } else {+    io_timedwait(p_ut, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        /* Nothing happened in 'updatetime', if a cursorhold event can+         * be triggered, do it now. */+        io_unlock();+        return cursorhold_key(buf);+      }+      before_blocking();+      io_wait(&activity);+    }+++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }+  }++  /* This was adapted from the original mch_inchar code.  Not sure why it's+   * here, but I guess it has something to do with netbeans support which was+   * removed.  Leave it alone for now */+  if (typebuf_changed(tb_change_cnt)) {+    io_unlock();+    return 0;+  }++  if (in_buffer.wpos == in_buffer.rpos && eof) {+    io_unlock();+    read_error_exit();+    return 0;+  }++  rv = read_from_input_buf(buf, (long)maxlen);+  io_signal(&data_consumed);+  io_unlock();++  return rv;+}++/* FIXME This is a temporary function, used to satisfy the way vim currently+ * reads characters using another input buffer . */+ssize_t mch_inchar_read(char *buf, size_t count) {+  size_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++int mch_char_avail() {+  return in_buffer.rpos < in_buffer.wpos;+}++void mch_delay(long ms, int ignoreinput) {+  int old_tmode;++  uv_mutex_lock(&delay_mutex);++  if (ignoreinput) {+    /* Go to cooked mode without echo, to allow SIGINT interrupting us+     * here.  But we don't want QUIT to kill us (CTRL-\ used in a+     * shell may produce SIGQUIT). */+    in_mch_delay = TRUE;+    old_tmode = curr_tmode;++    if (curr_tmode == TMODE_RAW)+      settmode(TMODE_SLEEP);++    delay(ms);++    settmode(old_tmode);+    in_mch_delay = FALSE;+  } else {+    delay(ms);+  }++  uv_mutex_unlock(&delay_mutex);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck() {+  io_lock();++  if (curr_tmode == TMODE_RAW && mch_char_avail())+    fill_input_buf(FALSE);++  io_unlock();+}++static void io_start(void *arg) {+  sigset_t set;+  uv_loop_t *loop;+  uv_idle_t idler; +  uv_signal_t sint, shup, squit, sabrt, sterm, swinch;+  uv_stream_t stdin_stream;++#ifdef DEBUG+  memset(&in_buffer, 0, sizeof(in_buffer));+#endif++  /* Block SIGTSTP on this thread */+  sigemptyset(&set);+  sigaddset(&set, SIGTSTP);+  pthread_sigmask(SIG_SETMASK, &set, NULL);++  UNUSED(arg);+  loop = uv_loop_new();+  /* Idler for signaling the main thread when the loop is running */+  uv_idle_init(loop, &idler);+  idler.data = &stdin_stream;+  uv_idle_start(&idler, loop_running);+  /* Async watcher used by the main thread to stop the loop */+  uv_async_init(loop, &stop_loop_async, stop_loop);+  /* stdin */+  /* FIXME setting fd to non-blocking is only needed on unix */+  fcntl(read_cmd_fd, F_SETFL, fcntl(read_cmd_fd, F_GETFL, 0) | O_NONBLOCK);+  uv_pipe_init(loop, (uv_pipe_t *)&stdin_stream, 0);+  uv_pipe_open((uv_pipe_t *)&stdin_stream, read_cmd_fd);+  /* signals */+  uv_signal_init(loop, &sint);+  uv_signal_start(&sint, signal_cb, SIGINT);+  uv_signal_init(loop, &shup);+  uv_signal_start(&shup, signal_cb, SIGHUP);+  uv_signal_init(loop, &squit);+  uv_signal_start(&squit, signal_cb, SIGQUIT);+  uv_signal_init(loop, &sabrt);+  uv_signal_start(&sabrt, signal_cb, SIGABRT);+  uv_signal_init(loop, &sterm);+  uv_signal_start(&sterm, signal_cb, SIGTERM);+  uv_signal_init(loop, &swinch);+  uv_signal_start(&swinch, signal_cb, SIGWINCH);+  /* start processing events */+  uv_run(loop, UV_RUN_DEFAULT);+  /* free the event loop */+  uv_loop_delete(loop);+}++/* Signal the main thread that the loop started running */+static void loop_running(uv_idle_t *handle, int status) {+  uv_idle_stop(handle);+  io_lock();+  uv_read_start((uv_stream_t *)handle->data, alloc_buffer_cb, read_cb);+  io_signal(&running);+  io_unlock();+}++static void stop_loop(uv_async_t *handle, int status) {+  UNUSED(status);+  uv_stop(handle->loop);+}++/* Called by libuv to allocate memory for reading. This uses a fixed buffer+ * through the entire stream lifetime */+static void alloc_buffer_cb(uv_handle_t *handle, size_t ssize, uv_buf_t *rv)+{+  int move_count;+  size_t available;++  UNUSED(handle);++  io_lock();++  available = BUF_SIZE - in_buffer.apos;++  if (!available) {+    if (in_buffer.rpos == 0) {+      /* Pause the stream until the main thread consumes some data. The io+       * mutex should only be unlocked when the stream is stopped in the+       * read_cb */+      rv->len = 0;+      io_unlock();+      return;+    }+    /* +     * Out of space in internal buffer, move data to the 'left' as much as+     * possible.+     */+    move_count = in_buffer.apos - in_buffer.rpos;+    memmove(in_buffer.data, in_buffer.data + in_buffer.rpos, move_count);+    in_buffer.wpos -= in_buffer.rpos;+    in_buffer.apos -= in_buffer.rpos;+    in_buffer.rpos = 0;+    available = BUF_SIZE - in_buffer.apos;+  }++  rv->base = (char *)(in_buffer.data + in_buffer.apos);+  rv->len = available;+  in_buffer.apos += available;+  io_unlock();+}++/*+ * The actual reading was already performed by libuv, this callback will do one+ * of the following:+ *    - If EOF was reached, it will set appropriate flags and signal the main+ *      thread to continue+ *    - If the alloc_buffer_cb didnt allocate anything, then it will pause the+ *      input stream.+ *    - If 'cnt' > 0, it will update the buffer write position(wpos) to reflect+ *      what was actually written.+ */+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf) {+  UNUSED(buf); /* Data is already on the buffer */++  if (cnt < 0) {++    if (cnt == UV_EOF) {+      /* EOF, stop the event loop and signal the main thread. This will cause+       * vim to exit */+      io_lock();+      if (!eof) {+        /* Dont close the loop if it was already closed in `mch_exit` */+        eof = true;+        io_signal(&activity);+        uv_stop(stream->loop);+      }+      io_unlock();+    } else if (cnt == UV_ENOBUFS) {+      io_lock();+      io_wait(&data_consumed);+      /* Resume reading */+      io_unlock();+    } else {+      fprintf(stderr, ""Unexpected error %ld\n"", cnt);+    }+    return;+  }++  io_lock();+  /* Data was already written, so all we need is to update 'wpos' to reflect+   * that */+  in_buffer.wpos += cnt;+  /* It's very likely that most of the ""allocated"" space wasn't used, so adjust+   * `apos` to to `wpos`. FIXME This probably won't work on windows, as it+   * may call the alloc callback two times before the read callback. Quoting+   * @saghul(libuv dev):+   *+   * ""Theoretically alloc_cb calls come right before read_cb, but this could+   * not be the case on Windows. I have never seen this happen in pyuv (I use a+   * statically allocated fixed size buffer for everything, but it could be the+   * Python GIL helping me here). You should be ready to handle alloc_cb,+   * alloc_cb, read_cb, read_cb.""+   *  */+  in_buffer.apos = in_buffer.wpos;+  if (cnt > 0) {+    io_signal(&activity);+  } else {+    /* cnt == 0 means that libuv requested allocation of a buffer it didn't+     * use, ""deallocate"" it now. */+    in_buffer.apos -= buf->len;+  }++  /* After setting the read_cmd_fd to O_NONBLOCK, the bytes entered by the user+   * always have a trailing 0. Without the following 'else', typing+   * interactively will display 'garbage'(Need to figure out why) */ +  io_unlock();+}++static void signal_cb(uv_signal_t *handle, int signum) {+  io_lock();+  pending_signal = signum;+  io_signal(&activity); /* unblock */+  io_wait(&signal_consumed);+  io_unlock();+}++/*+ * Output a newline when exiting.+ * Make sure the newline goes to the same stream as the text.+ */+static void exit_scroll() {+  if (silent_mode)+    return;+  if (newline_on_exit || msg_didout) {+    if (msg_use_printf()) {+      if (info_message)+        mch_msg(""\n"");+      else+        mch_errmsg(""\r\n"");+    } else+      out_char('\n');+  } else   {+    restore_cterm_colors();             /* get original colors back */+    msg_clr_eos_force();                /* clear the rest of the display */+    windgoto((int)Rows - 1, 0);         /* may have moved the cursor */+  }+}++/* Helpers for returning special keys from mch_inchar */++static int special_key(char_u *buf, char_u k) {+  /* If nothing was typed, trigger the event */+  buf[0] = K_SPECIAL;+  buf[1] = KS_EXTRA;+  buf[2] = k;+  return 3;+}++static int cursorhold_key(char_u *buf) {+  return special_key(buf, KE_CURSORHOLD);+}++static int signal_key(char_u *buf) {+  return special_key(buf, KE_SIGNAL);+}++/* Helpers for dealing with io synchronization */+static void io_lock() {+  uv_mutex_lock(&io_mutex);+}++static void io_unlock() {+  uv_mutex_unlock(&io_mutex);+}++static void io_wait(bool *condition) {+  while (!(*condition)) uv_cond_wait(&io_cond, &io_mutex);+  *condition = false;+}++static void io_timedwait(uint64_t ms, bool *condition) {+  uint64_t hrtime;++  ms *= 1000000; /* convert to nanoseconds */++  while (ms > 0 && !(*condition)) {+    hrtime =  uv_hrtime();+    if (uv_cond_timedwait(&io_cond, &io_mutex, ms) == UV_ETIMEDOUT)+      break;+    /* If we had a spurious wakeup, ensure the next iteration will only sleep+     * for the remaining time */+    ms -= uv_hrtime() - hrtime;+  }++  *condition = false;+}++static void io_signal(bool *condition) {+  *condition = true;+  uv_cond_signal(&io_cond);+}++static void delay(uint64_t ms) {+  uint64_t hrtime;++  ms *= 1000000; /* convert to nanoseconds */++  while (ms > 0) {+    hrtime =  uv_hrtime();+    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ms) == UV_ETIMEDOUT)+      break;+    ms -= uv_hrtime() - hrtime;","This is a race condition. Consider a spurious wakeup one nanosecond before timeout and a context switch such that `uv_hrtime() - hrtime > ms`.``` cstatic void delay(uint64_t ms) {  int64_t ns;  uint64_t hrtime;  // INT64_MAX/1000000 ms are about 300 years  assert(ms < INT64_MAX/1000000);  ns = ms * 1000000;  while (ns > 0) {    hrtime = uv_hrtime();    if (uv_cond_timedwait(&delay_cond, &delay_mutex, ns) == UV_ETIMEDOUT)      break;    ns -= uv_hrtime() - hrtime;  }}```Same thing above.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/289,10697498,2014-03-18T10:48:02Z,src/os/io.c,"@@ -0,0 +1,560 @@+#include <stdbool.h>+#include <stdint.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement","`apos` is the next position that will be reserved by `alloc_buffer_cb` and `wpos` is the next position that will be ""written""(the actual copying is done by libuv) by `read_cb`.I agree that it's not currently necessary. Seeing how the IO lock is acquired in the `alloc_buffer_cb` and only released after `wpos` is updated in `read_cb`, it's not possible that the main thread will read up to `wpos` before libuv has a chance to copy the data into the buffer.I need to rethink this to deal with two consecutive calls to `alloc_cb` by libuv.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/289,10697557,2014-03-18T10:50:05Z,src/os/io.c,"@@ -0,0 +1,560 @@+#include <stdbool.h>+#include <stdint.h>+#include <pthread.h>++#include <uv.h>++#include ""./os.h""+#include ""../vim.h""+#include ""../term.h""+#include ""../os_unix.h""+#include ""../memline.h""+#include ""../misc2.h""+#include ""../ui.h""+#include ""../fileio.h""+#include ""../getchar.h""+#include ""../message.h""+#include ""../syntax.h""+#include ""../screen.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  /* +   * Input buffer structure. This contains a contiguous memory chunk and three+   * pointers(allocated, written and read positions) that are used to implement+   * a simple form of memory management for incoming data without requiring+   * calls to the system memory allocator.+   *+   * Probably the 'apos' (allocated pos) pointer isn't needed, but omitting it+   * would mean we are assuming details about libuv implementation which+   * wouldn't be very robust.+   */ +  unsigned int apos, wpos, rpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t io_thread;+static uv_mutex_t io_mutex;+static uv_cond_t io_cond;+static uv_mutex_t delay_mutex;+static uv_cond_t delay_cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the io_cond */+static bool signal_consumed = false, activity = false,+            data_consumed = false, running = false, eof = false;+static void io_start(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void exit_scroll(void);+static int special_key(char_u *, char_u);+static int cursorhold_key(char_u *);+static int signal_key(char_u *);+static void io_lock();+static void io_unlock();+static void io_timedwait(uint64_t ms, bool *condition);+static void io_wait(bool *condition);+static void io_signal(bool *condition);+static void delay(uint64_t ms);++void io_init() {+  sigset_t set;++  /* uv_disable_stdio_inheritance(); */+  uv_mutex_init(&io_mutex);+  uv_cond_init(&io_cond);+  uv_mutex_init(&delay_mutex);+  uv_cond_init(&delay_cond);+  io_lock();+  /* The event loop runs in a background thread */+  uv_thread_create(&io_thread, io_start, NULL);+  /* Wait for the loop thread to be ready */+  io_wait(&running);+  /* Block all signals except SIGTSTP in the main thread */+  sigfillset(&set);+  sigdelset(&set, SIGTSTP);+  pthread_sigmask(SIG_SETMASK, &set, NULL);+  io_unlock();+}++void mch_exit(int r) {+  exiting = TRUE;+  /* stop libuv loop */+  io_lock();+  /* uv_async_send may try to write on a closed FD, causing an `abort`.+   * Make sure this doesn't happen by checking if eof is set */+  if (!eof)+    uv_async_send(&stop_loop_async);+  io_unlock();+  /* wait for the event loop thread */+  uv_thread_join(&io_thread);++  {+    settmode(TMODE_COOK);+    mch_restore_title(3);       /* restore xterm title and icon name */+    /*+     * When t_ti is not empty but it doesn't cause swapping terminal+     * pages, need to output a newline when msg_didout is set.  But when+     * t_ti does swap pages it should not go to the shell page.  Do this+     * before stoptermcap().+     */+    if (swapping_screen() && !newline_on_exit)+      exit_scroll();++    /* Stop termcap: May need to check for T_CRV response, which+     * requires RAW mode. */+    stoptermcap();++    /*+     * A newline is only required after a message in the alternate screen.+     * This is set to TRUE by wait_return().+     */+    if (!swapping_screen() || newline_on_exit)+      exit_scroll();++    /* Cursor may have been switched off without calling starttermcap()+     * when doing ""vim -u vimrc"" and vimrc contains "":q"". */+    if (full_screen)+      cursor_on();+  }+  out_flush();+  ml_close_all(TRUE);           /* remove all memfiles */++#ifdef EXITFREE+  free_all_mem();+#endif++  exit(r);+}++int next_signal() {+  /* FIXME pending_signal must be a queue of signals, right now the event loop+   * is blocking until this function is called. */+  int rv;++  io_lock();+  io_signal(&signal_consumed);+  rv = pending_signal;+  pending_signal = 0;+  io_unlock();++  return rv;+}++/*+ * This is ugly, but necessary at least until we start messing with vget*+ * functions a long time from now+ */+int mch_inchar(char_u *buf, int maxlen, long wtime, int tb_change_cnt) {+  int rv;++  io_lock();++  if (pending_signal) {+    io_unlock();+    return signal_key(buf);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    /* Take whatever data is available */+    rv = read_from_input_buf(buf, (long)maxlen);+    /* If the loop is paused due to full buffer, notify it that+     * we consumed some data and it may read more */+    io_signal(&data_consumed);+    io_unlock();+    return rv;+  }++  if (wtime >= 0) {+    /* Wait up to 'wtime' milliseconds */+    io_timedwait(wtime, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      io_unlock();+      /* Didn't read anything */+      if (eof) {+        /* Exit when stdin is closed */+        read_error_exit();+      }+      return 0;+    }++  } else {+    io_timedwait(p_ut, &activity);++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }++    if (in_buffer.wpos == in_buffer.rpos) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        /* Nothing happened in 'updatetime', if a cursorhold event can+         * be triggered, do it now. */+        io_unlock();+        return cursorhold_key(buf);+      }+      before_blocking();+      io_wait(&activity);+    }+++    if (pending_signal) {+      io_unlock();+      return signal_key(buf);+    }+  }++  /* This was adapted from the original mch_inchar code.  Not sure why it's+   * here, but I guess it has something to do with netbeans support which was+   * removed.  Leave it alone for now */+  if (typebuf_changed(tb_change_cnt)) {+    io_unlock();+    return 0;+  }++  if (in_buffer.wpos == in_buffer.rpos && eof) {+    io_unlock();+    read_error_exit();+    return 0;+  }++  rv = read_from_input_buf(buf, (long)maxlen);+  io_signal(&data_consumed);+  io_unlock();++  return rv;+}++/* FIXME This is a temporary function, used to satisfy the way vim currently+ * reads characters using another input buffer . */+ssize_t mch_inchar_read(char *buf, size_t count) {+  size_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++int mch_char_avail() {+  return in_buffer.rpos < in_buffer.wpos;+}++void mch_delay(long ms, int ignoreinput) {+  int old_tmode;++  uv_mutex_lock(&delay_mutex);++  if (ignoreinput) {+    /* Go to cooked mode without echo, to allow SIGINT interrupting us+     * here.  But we don't want QUIT to kill us (CTRL-\ used in a+     * shell may produce SIGQUIT). */+    in_mch_delay = TRUE;+    old_tmode = curr_tmode;++    if (curr_tmode == TMODE_RAW)+      settmode(TMODE_SLEEP);++    delay(ms);++    settmode(old_tmode);+    in_mch_delay = FALSE;+  } else {+    delay(ms);+  }++  uv_mutex_unlock(&delay_mutex);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck() {+  io_lock();++  if (curr_tmode == TMODE_RAW && mch_char_avail())+    fill_input_buf(FALSE);++  io_unlock();+}++static void io_start(void *arg) {+  sigset_t set;+  uv_loop_t *loop;+  uv_idle_t idler; +  uv_signal_t sint, shup, squit, sabrt, sterm, swinch;+  uv_stream_t stdin_stream;++#ifdef DEBUG+  memset(&in_buffer, 0, sizeof(in_buffer));+#endif++  /* Block SIGTSTP on this thread */+  sigemptyset(&set);+  sigaddset(&set, SIGTSTP);+  pthread_sigmask(SIG_SETMASK, &set, NULL);++  UNUSED(arg);+  loop = uv_loop_new();+  /* Idler for signaling the main thread when the loop is running */+  uv_idle_init(loop, &idler);+  idler.data = &stdin_stream;+  uv_idle_start(&idler, loop_running);+  /* Async watcher used by the main thread to stop the loop */+  uv_async_init(loop, &stop_loop_async, stop_loop);+  /* stdin */+  /* FIXME setting fd to non-blocking is only needed on unix */+  fcntl(read_cmd_fd, F_SETFL, fcntl(read_cmd_fd, F_GETFL, 0) | O_NONBLOCK);+  uv_pipe_init(loop, (uv_pipe_t *)&stdin_stream, 0);+  uv_pipe_open((uv_pipe_t *)&stdin_stream, read_cmd_fd);+  /* signals */+  uv_signal_init(loop, &sint);+  uv_signal_start(&sint, signal_cb, SIGINT);+  uv_signal_init(loop, &shup);+  uv_signal_start(&shup, signal_cb, SIGHUP);+  uv_signal_init(loop, &squit);+  uv_signal_start(&squit, signal_cb, SIGQUIT);+  uv_signal_init(loop, &sabrt);+  uv_signal_start(&sabrt, signal_cb, SIGABRT);+  uv_signal_init(loop, &sterm);+  uv_signal_start(&sterm, signal_cb, SIGTERM);+  uv_signal_init(loop, &swinch);+  uv_signal_start(&swinch, signal_cb, SIGWINCH);+  /* start processing events */+  uv_run(loop, UV_RUN_DEFAULT);+  /* free the event loop */+  uv_loop_delete(loop);+}++/* Signal the main thread that the loop started running */+static void loop_running(uv_idle_t *handle, int status) {+  uv_idle_stop(handle);+  io_lock();+  uv_read_start((uv_stream_t *)handle->data, alloc_buffer_cb, read_cb);+  io_signal(&running);+  io_unlock();+}++static void stop_loop(uv_async_t *handle, int status) {+  UNUSED(status);+  uv_stop(handle->loop);+}++/* Called by libuv to allocate memory for reading. This uses a fixed buffer+ * through the entire stream lifetime */+static void alloc_buffer_cb(uv_handle_t *handle, size_t ssize, uv_buf_t *rv)+{+  int move_count;+  size_t available;++  UNUSED(handle);++  io_lock();++  available = BUF_SIZE - in_buffer.apos;++  if (!available) {+    if (in_buffer.rpos == 0) {+      /* Pause the stream until the main thread consumes some data. The io+       * mutex should only be unlocked when the stream is stopped in the+       * read_cb */+      rv->len = 0;+      io_unlock();+      return;+    }+    /* +     * Out of space in internal buffer, move data to the 'left' as much as+     * possible.+     */+    move_count = in_buffer.apos - in_buffer.rpos;+    memmove(in_buffer.data, in_buffer.data + in_buffer.rpos, move_count);+    in_buffer.wpos -= in_buffer.rpos;+    in_buffer.apos -= in_buffer.rpos;+    in_buffer.rpos = 0;+    available = BUF_SIZE - in_buffer.apos;+  }++  rv->base = (char *)(in_buffer.data + in_buffer.apos);+  rv->len = available;+  in_buffer.apos += available;+  io_unlock();+}++/*+ * The actual reading was already performed by libuv, this callback will do one+ * of the following:+ *    - If EOF was reached, it will set appropriate flags and signal the main+ *      thread to continue+ *    - If the alloc_buffer_cb didnt allocate anything, then it will pause the+ *      input stream.+ *    - If 'cnt' > 0, it will update the buffer write position(wpos) to reflect+ *      what was actually written.+ */+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf) {+  UNUSED(buf); /* Data is already on the buffer */++  if (cnt < 0) {++    if (cnt == UV_EOF) {+      /* EOF, stop the event loop and signal the main thread. This will cause+       * vim to exit */+      io_lock();+      if (!eof) {+        /* Dont close the loop if it was already closed in `mch_exit` */+        eof = true;+        io_signal(&activity);+        uv_stop(stream->loop);+      }+      io_unlock();+    } else if (cnt == UV_ENOBUFS) {+      io_lock();+      io_wait(&data_consumed);+      /* Resume reading */+      io_unlock();+    } else {+      fprintf(stderr, ""Unexpected error %ld\n"", cnt);+    }+    return;+  }++  io_lock();+  /* Data was already written, so all we need is to update 'wpos' to reflect+   * that */+  in_buffer.wpos += cnt;+  /* It's very likely that most of the ""allocated"" space wasn't used, so adjust+   * `apos` to to `wpos`. FIXME This probably won't work on windows, as it+   * may call the alloc callback two times before the read callback. Quoting+   * @saghul(libuv dev):+   *+   * ""Theoretically alloc_cb calls come right before read_cb, but this could+   * not be the case on Windows. I have never seen this happen in pyuv (I use a+   * statically allocated fixed size buffer for everything, but it could be the+   * Python GIL helping me here). You should be ready to handle alloc_cb,+   * alloc_cb, read_cb, read_cb.""+   *  */+  in_buffer.apos = in_buffer.wpos;+  if (cnt > 0) {+    io_signal(&activity);+  } else {+    /* cnt == 0 means that libuv requested allocation of a buffer it didn't+     * use, ""deallocate"" it now. */+    in_buffer.apos -= buf->len;",My bad,
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/289,10719752,2014-03-18T18:54:44Z,src/os/io.c,"@@ -0,0 +1,328 @@+#include <uv.h>++#include ""os/io.h""+#include ""os/time.h""+#include ""vim.h""+#include ""misc2.h""++#define UNUSED(x) (void)(x)+#define BUF_SIZE 4096++typedef struct {+  uint32_t rpos, wpos, apos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static int pending_signal = 0;+static uv_thread_t thread;+static uv_mutex_t mutex;+static uv_cond_t cond;+static uv_async_t stop_loop_async;+static input_buffer_T in_buffer;+/* Actual conditions behind the cond */+static bool signal_consumed = false, activity = false,+            input_consumed = false, running = false, eof = false;+static void event_loop(void *);+static void loop_running(uv_idle_t *, int);+static void stop_loop(uv_async_t *, int);+static void alloc_buffer_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void signal_cb(uv_signal_t *, int signum);+static void lock();+static void unlock();+static void timedwait(uint64_t ms, bool *condition);+static void wait(bool *condition);","Compile error on OSX:```/Users/stefan/Dev/neovim/src/os/io.c:34:13: error: static declaration of 'wait'      follows non-static declarationstatic void wait(bool *condition);            ^/usr/include/sys/wait.h:248:7: note: previous declaration is herepid_t   wait(int *) __DARWIN_ALIAS_C(wait);        ^/Users/stefan/Dev/neovim/src/os/io.c:49:8: error: incompatible pointer types      passing 'bool *' to parameter of type 'int *'      [-Werror,-Wincompatible-pointer-types]  wait(&running);       ^~~~~~~~/usr/include/sys/wait.h:248:17: note: passing argument to parameter herepid_t   wait(int *) __DARWIN_ALIAS_C(wait);                  ^```",
1882250,mahkoh,https://api.github.com/repos/neovim/neovim/pulls/390,10863020,2014-03-22T16:47:42Z,src/arabic.h,"@@ -1,244 +1,10 @@-/// @file arabic.h-///-/// Arabic characters are categorized into following types:-///-/// Isolated    - iso-8859-6 form         char denoted with  a_*-/// Initial     - unicode form-B start    char denoted with  a_i_*-/// Medial      - unicode form-B middle   char denoted with  a_m_*-/// Final       - unicode form-B final    char denoted with  a_f_*-/// Stand-Alone - unicode form-B isolated char denoted with  a_s_* (NOT USED)-///- #ifndef NEOVIM_ARABIC_H #define NEOVIM_ARABIC_H -// Arabic ISO-10646-1 character set definition--// Arabic ISO-8859-6 (subset of 10646; 0600 - 06FF)-#define a_COMMA                         0x060C-#define a_SEMICOLON                     0x061B-#define a_QUESTION                      0x061F-#define a_HAMZA                         0x0621-#define a_ALEF_MADDA                    0x0622-#define a_ALEF_HAMZA_ABOVE              0x0623-#define a_WAW_HAMZA                     0x0624-#define a_ALEF_HAMZA_BELOW              0x0625-#define a_YEH_HAMZA                     0x0626-#define a_ALEF                          0x0627-#define a_BEH                           0x0628-#define a_TEH_MARBUTA                   0x0629-#define a_TEH                           0x062a-#define a_THEH                          0x062b-#define a_JEEM                          0x062c-#define a_HAH                           0x062d-#define a_KHAH                          0x062e-#define a_DAL                           0x062f-#define a_THAL                          0x0630-#define a_REH                           0x0631-#define a_ZAIN                          0x0632-#define a_SEEN                          0x0633-#define a_SHEEN                         0x0634-#define a_SAD                           0x0635-#define a_DAD                           0x0636-#define a_TAH                           0x0637-#define a_ZAH                           0x0638-#define a_AIN                           0x0639-#define a_GHAIN                         0x063a-#define a_TATWEEL                       0x0640-#define a_FEH                           0x0641-#define a_QAF                           0x0642-#define a_KAF                           0x0643-#define a_LAM                           0x0644-#define a_MEEM                          0x0645-#define a_NOON                          0x0646-#define a_HEH                           0x0647-#define a_WAW                           0x0648-#define a_ALEF_MAKSURA                  0x0649-#define a_YEH                           0x064a--#define a_FATHATAN                      0x064b-#define a_DAMMATAN                      0x064c-#define a_KASRATAN                      0x064d-#define a_FATHA                         0x064e-#define a_DAMMA                         0x064f-#define a_KASRA                         0x0650-#define a_SHADDA                        0x0651-#define a_SUKUN                         0x0652--#define a_MADDA_ABOVE                   0x0653-#define a_HAMZA_ABOVE                   0x0654-#define a_HAMZA_BELOW                   0x0655--#define a_ZERO                          0x0660-#define a_ONE                           0x0661-#define a_TWO                           0x0662-#define a_THREE                         0x0663-#define a_FOUR                          0x0664-#define a_FIVE                          0x0665-#define a_SIX                           0x0666-#define a_SEVEN                         0x0667-#define a_EIGHT                         0x0668-#define a_NINE                          0x0669-#define a_PERCENT                       0x066a-#define a_DECIMAL                       0x066b-#define a_THOUSANDS                     0x066c-#define a_STAR                          0x066d-#define a_MINI_ALEF                     0x0670-// Rest of 8859-6 does not relate to Arabic--// Arabic Presentation Form-B (subset of 10646; FE70 - FEFF)-//-//  s -> isolated-//  i -> initial-//  m -> medial-//  f -> final-//-#define a_s_FATHATAN                    0xfe70-#define a_m_TATWEEL_FATHATAN            0xfe71-#define a_s_DAMMATAN                    0xfe72--#define a_s_KASRATAN                    0xfe74--#define a_s_FATHA                       0xfe76-#define a_m_FATHA                       0xfe77-#define a_s_DAMMA                       0xfe78-#define a_m_DAMMA                       0xfe79-#define a_s_KASRA                       0xfe7a-#define a_m_KASRA                       0xfe7b-#define a_s_SHADDA                      0xfe7c-#define a_m_SHADDA                      0xfe7d-#define a_s_SUKUN                       0xfe7e-#define a_m_SUKUN                       0xfe7f--#define a_s_HAMZA                       0xfe80-#define a_s_ALEF_MADDA                  0xfe81-#define a_f_ALEF_MADDA                  0xfe82-#define a_s_ALEF_HAMZA_ABOVE            0xfe83-#define a_f_ALEF_HAMZA_ABOVE            0xfe84-#define a_s_WAW_HAMZA                   0xfe85-#define a_f_WAW_HAMZA                   0xfe86-#define a_s_ALEF_HAMZA_BELOW            0xfe87-#define a_f_ALEF_HAMZA_BELOW            0xfe88-#define a_s_YEH_HAMZA                   0xfe89-#define a_f_YEH_HAMZA                   0xfe8a-#define a_i_YEH_HAMZA                   0xfe8b-#define a_m_YEH_HAMZA                   0xfe8c-#define a_s_ALEF                        0xfe8d-#define a_f_ALEF                        0xfe8e-#define a_s_BEH                         0xfe8f-#define a_f_BEH                         0xfe90-#define a_i_BEH                         0xfe91-#define a_m_BEH                         0xfe92-#define a_s_TEH_MARBUTA                 0xfe93-#define a_f_TEH_MARBUTA                 0xfe94-#define a_s_TEH                         0xfe95-#define a_f_TEH                         0xfe96-#define a_i_TEH                         0xfe97-#define a_m_TEH                         0xfe98-#define a_s_THEH                        0xfe99-#define a_f_THEH                        0xfe9a-#define a_i_THEH                        0xfe9b-#define a_m_THEH                        0xfe9c-#define a_s_JEEM                        0xfe9d-#define a_f_JEEM                        0xfe9e-#define a_i_JEEM                        0xfe9f-#define a_m_JEEM                        0xfea0-#define a_s_HAH                         0xfea1-#define a_f_HAH                         0xfea2-#define a_i_HAH                         0xfea3-#define a_m_HAH                         0xfea4-#define a_s_KHAH                        0xfea5-#define a_f_KHAH                        0xfea6-#define a_i_KHAH                        0xfea7-#define a_m_KHAH                        0xfea8-#define a_s_DAL                         0xfea9-#define a_f_DAL                         0xfeaa-#define a_s_THAL                        0xfeab-#define a_f_THAL                        0xfeac-#define a_s_REH                         0xfead-#define a_f_REH                         0xfeae-#define a_s_ZAIN                        0xfeaf-#define a_f_ZAIN                        0xfeb0-#define a_s_SEEN                        0xfeb1-#define a_f_SEEN                        0xfeb2-#define a_i_SEEN                        0xfeb3-#define a_m_SEEN                        0xfeb4-#define a_s_SHEEN                       0xfeb5-#define a_f_SHEEN                       0xfeb6-#define a_i_SHEEN                       0xfeb7-#define a_m_SHEEN                       0xfeb8-#define a_s_SAD                         0xfeb9-#define a_f_SAD                         0xfeba-#define a_i_SAD                         0xfebb-#define a_m_SAD                         0xfebc-#define a_s_DAD                         0xfebd-#define a_f_DAD                         0xfebe-#define a_i_DAD                         0xfebf-#define a_m_DAD                         0xfec0-#define a_s_TAH                         0xfec1-#define a_f_TAH                         0xfec2-#define a_i_TAH                         0xfec3-#define a_m_TAH                         0xfec4-#define a_s_ZAH                         0xfec5-#define a_f_ZAH                         0xfec6-#define a_i_ZAH                         0xfec7-#define a_m_ZAH                         0xfec8-#define a_s_AIN                         0xfec9-#define a_f_AIN                         0xfeca-#define a_i_AIN                         0xfecb-#define a_m_AIN                         0xfecc-#define a_s_GHAIN                       0xfecd-#define a_f_GHAIN                       0xfece-#define a_i_GHAIN                       0xfecf-#define a_m_GHAIN                       0xfed0-#define a_s_FEH                         0xfed1-#define a_f_FEH                         0xfed2-#define a_i_FEH                         0xfed3-#define a_m_FEH                         0xfed4-#define a_s_QAF                         0xfed5-#define a_f_QAF                         0xfed6-#define a_i_QAF                         0xfed7-#define a_m_QAF                         0xfed8-#define a_s_KAF                         0xfed9-#define a_f_KAF                         0xfeda-#define a_i_KAF                         0xfedb-#define a_m_KAF                         0xfedc-#define a_s_LAM                         0xfedd-#define a_f_LAM                         0xfede-#define a_i_LAM                         0xfedf-#define a_m_LAM                         0xfee0-#define a_s_MEEM                        0xfee1-#define a_f_MEEM                        0xfee2-#define a_i_MEEM                        0xfee3-#define a_m_MEEM                        0xfee4-#define a_s_NOON                        0xfee5-#define a_f_NOON                        0xfee6-#define a_i_NOON                        0xfee7-#define a_m_NOON                        0xfee8-#define a_s_HEH                         0xfee9-#define a_f_HEH                         0xfeea-#define a_i_HEH                         0xfeeb-#define a_m_HEH                         0xfeec-#define a_s_WAW                         0xfeed-#define a_f_WAW                         0xfeee-#define a_s_ALEF_MAKSURA                0xfeef-#define a_f_ALEF_MAKSURA                0xfef0-#define a_s_YEH                         0xfef1-#define a_f_YEH                         0xfef2-#define a_i_YEH                         0xfef3-#define a_m_YEH                         0xfef4-#define a_s_LAM_ALEF_MADDA_ABOVE        0xfef5-#define a_f_LAM_ALEF_MADDA_ABOVE        0xfef6-#define a_s_LAM_ALEF_HAMZA_ABOVE        0xfef7-#define a_f_LAM_ALEF_HAMZA_ABOVE        0xfef8-#define a_s_LAM_ALEF_HAMZA_BELOW        0xfef9-#define a_f_LAM_ALEF_HAMZA_BELOW        0xfefa-#define a_s_LAM_ALEF                    0xfefb-#define a_f_LAM_ALEF                    0xfefc--#define a_BYTE_ORDER_MARK               0xfeff--// Range of Arabic characters that might be shaped.-#define ARABIC_CHAR(c)          ((c) >= a_HAMZA && (c) <= a_MINI_ALEF)+int arabic_char(int c);",``` c/// Whether c belongs to the range of Arabic characters that might be shaped. static inline int arabic_char(int c) {     //    c >= a_HAMZA && c <= a_MINI_ALEF     return c >= 0xfe80 && c <= 0x0670; }```,
1882250,mahkoh,https://api.github.com/repos/neovim/neovim/pulls/395,10867810,2014-03-23T16:11:55Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++/* This is a replacement for the old `WaitForChar` function in os_unix.c */+static poll_result_t inbuf_poll(int32_t ms)+{+  if (input_available())+    return POLL_INPUT;++  return io_poll(ms);+}++/* Poll the system for user input */+poll_result_t io_poll(int32_t ms)+{+  bool timeout;++  if (in_buffer.rpos < in_buffer.wpos) {+    /* If there's data buffered from a previous event loop iteration, +     * let vim read it */+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  if (ms == 0) {+    return POLL_NONE;+  }++  if (!initialized) {+    /* Only initialize the event loop once */+    initialize_event_loop();+    initialized = true;+  }++  if (read_cmd_fd == UV_FILE) {+    uv_fs_read(uv_default_loop(), &read_req, read_cmd_fd, &in_buffer.uvbuf, 1,+        in_buffer.fpos, fread_cb);+  } else {+    uv_read_start(read_stream, alloc_cb, read_cb);+  }++  timeout = false;++  if (ms > 0) {+    timer_req.data = &timeout;+    uv_timer_start(&timer_req, timer_cb, ms, 0);+  }++  while (true) {+    uv_run(uv_default_loop(), UV_RUN_ONCE);++    if (in_buffer.rpos < in_buffer.wpos || eof || timeout) {+      break;+    }+  }++  if (read_cmd_fd != UV_FILE) {+    uv_read_stop(read_stream);+  }++  if (ms > 0) {+    uv_timer_stop(&timer_req);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  /* timeout */+  return POLL_NONE;+}++static void initialize_event_loop()+{+  in_buffer.wpos = in_buffer.rpos = in_buffer.apos = in_buffer.fpos = 0;+#ifdef DEBUG+  memset(&in_buffer.data, 0, BUF_SIZE);+#endif++  /* Setup stdin_stream */+  if ((read_stream_type = uv_guess_handle(read_cmd_fd)) == UV_FILE) {+    in_buffer.uvbuf.len = in_buffer.apos = BUF_SIZE;+    in_buffer.uvbuf.base = (char *)in_buffer.data;+  } else if (read_stream_type == UV_TTY) {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_tty_t));+    uv_tty_init(uv_default_loop(), (uv_tty_t *)read_stream, read_cmd_fd, 1);+  } else {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_pipe_t));+    uv_pipe_init(uv_default_loop(), (uv_pipe_t *)read_stream, 0);+    uv_pipe_open((uv_pipe_t *)read_stream, read_cmd_fd);+  }++  uv_timer_init(uv_default_loop(), &timer_req);+}++/* Called by libuv to allocate memory for reading. */",``` cstatic void alloc_cb(...){  rv->base = (char *)in_buffer.data + in_buffer.apos;  rv->len = BUF_SIZE - in_buffer.apos;  in_buffer.apos = BUF_SIZE;}```,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10886941,2014-03-24T14:42:07Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)","`RealWaitForChar` checks for data in a file descriptor by using a `poll/select` call. We are now using libuv to handle the OS calls, storing data at `in_buffer` which. `rpos < wpos` means that there's pending data to read. As far as  most of the code is concerned, `in_buffer` is now replacing `read_cmd_fd`",
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/395,10887688,2014-03-24T14:56:57Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)","@tarruda I don't agree. Surely changes to the style add some noise to the PR, but I am very bad in guessing what an abbreviation stands for which makes it hard to review the code. These changes are of the type one would like to postpone forever but it has to be done. If the style changes should go in a seperate PR, a style-PR beforehand is the way to go.I think, we should definitely stick stricter to the style guide.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/395,10888455,2014-03-24T15:11:52Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)",@tarruda I agree with @lslah. Style PR makes sense before code changes. You may want to postpone the renaming of `mch_inchar` if it's going to touch a lot of files.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10889222,2014-03-24T15:26:48Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)","They will be removed when no longer used in os_unix.c. `WaitForChar` is still used by `mch_delay`, which will be converted in #393 and `RealWaitForChar` is used by `mch_call_shell` which will also go in a separate PR.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10889321,2014-03-24T15:28:43Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++/* This is a replacement for the old `WaitForChar` function in os_unix.c */+static poll_result_t inbuf_poll(int32_t ms)+{+  if (input_available())+    return POLL_INPUT;++  return io_poll(ms);+}++/* Poll the system for user input */+poll_result_t io_poll(int32_t ms)+{+  bool timeout;++  if (in_buffer.rpos < in_buffer.wpos) {+    /* If there's data buffered from a previous event loop iteration, +     * let vim read it */+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  if (ms == 0) {+    return POLL_NONE;+  }++  if (!initialized) {+    /* Only initialize the event loop once */+    initialize_event_loop();+    initialized = true;+  }++  if (read_cmd_fd == UV_FILE) {+    uv_fs_read(uv_default_loop(), &read_req, read_cmd_fd, &in_buffer.uvbuf, 1,+        in_buffer.fpos, fread_cb);+  } else {+    uv_read_start(read_stream, alloc_cb, read_cb);+  }++  timeout = false;++  if (ms > 0) {+    timer_req.data = &timeout;+    uv_timer_start(&timer_req, timer_cb, ms, 0);+  }++  while (true) {+    uv_run(uv_default_loop(), UV_RUN_ONCE);++    if (in_buffer.rpos < in_buffer.wpos || eof || timeout) {+      break;+    }+  }++  if (read_cmd_fd != UV_FILE) {+    uv_read_stop(read_stream);+  }++  if (ms > 0) {+    uv_timer_stop(&timer_req);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  /* timeout */+  return POLL_NONE;+}++static void initialize_event_loop()+{+  in_buffer.wpos = in_buffer.rpos = in_buffer.apos = in_buffer.fpos = 0;+#ifdef DEBUG+  memset(&in_buffer.data, 0, BUF_SIZE);","Seeing how `memset` is a standard library function and we support C99 compilers, I don't see why we need a wrapper.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10889668,2014-03-24T15:35:39Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++/* This is a replacement for the old `WaitForChar` function in os_unix.c */+static poll_result_t inbuf_poll(int32_t ms)+{+  if (input_available())+    return POLL_INPUT;++  return io_poll(ms);+}++/* Poll the system for user input */+poll_result_t io_poll(int32_t ms)+{+  bool timeout;++  if (in_buffer.rpos < in_buffer.wpos) {+    /* If there's data buffered from a previous event loop iteration, +     * let vim read it */+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  if (ms == 0) {+    return POLL_NONE;+  }++  if (!initialized) {+    /* Only initialize the event loop once */+    initialize_event_loop();+    initialized = true;+  }++  if (read_cmd_fd == UV_FILE) {+    uv_fs_read(uv_default_loop(), &read_req, read_cmd_fd, &in_buffer.uvbuf, 1,+        in_buffer.fpos, fread_cb);+  } else {+    uv_read_start(read_stream, alloc_cb, read_cb);+  }++  timeout = false;++  if (ms > 0) {+    timer_req.data = &timeout;+    uv_timer_start(&timer_req, timer_cb, ms, 0);+  }++  while (true) {+    uv_run(uv_default_loop(), UV_RUN_ONCE);++    if (in_buffer.rpos < in_buffer.wpos || eof || timeout) {+      break;+    }+  }++  if (read_cmd_fd != UV_FILE) {+    uv_read_stop(read_stream);+  }++  if (ms > 0) {+    uv_timer_stop(&timer_req);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  /* timeout */+  return POLL_NONE;+}++static void initialize_event_loop()+{+  in_buffer.wpos = in_buffer.rpos = in_buffer.apos = in_buffer.fpos = 0;+#ifdef DEBUG+  memset(&in_buffer.data, 0, BUF_SIZE);+#endif++  /* Setup stdin_stream */+  if ((read_stream_type = uv_guess_handle(read_cmd_fd)) == UV_FILE) {+    in_buffer.uvbuf.len = in_buffer.apos = BUF_SIZE;+    in_buffer.uvbuf.base = (char *)in_buffer.data;+  } else if (read_stream_type == UV_TTY) {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_tty_t));","I did some thinking about this. Currently vim tries to gracefully handle memory allocation refusals, but I don't think we should do anything beyond using `x{malloc,strdup}` functions that exit the program when allocation fails.Before exiting we could do some cleanup such a flushing swaps to disk or have a static buffer to use as 'emergency memory' for `sprintf` etc, as long as the program exits when memory allocation fails since it greatly simplifies the code.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/395,10890397,2014-03-24T15:49:54Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++/* This is a replacement for the old `WaitForChar` function in os_unix.c */+static poll_result_t inbuf_poll(int32_t ms)+{+  if (input_available())+    return POLL_INPUT;++  return io_poll(ms);+}++/* Poll the system for user input */+poll_result_t io_poll(int32_t ms)+{+  bool timeout;++  if (in_buffer.rpos < in_buffer.wpos) {+    /* If there's data buffered from a previous event loop iteration, +     * let vim read it */+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  if (ms == 0) {+    return POLL_NONE;+  }++  if (!initialized) {+    /* Only initialize the event loop once */+    initialize_event_loop();+    initialized = true;+  }++  if (read_cmd_fd == UV_FILE) {+    uv_fs_read(uv_default_loop(), &read_req, read_cmd_fd, &in_buffer.uvbuf, 1,+        in_buffer.fpos, fread_cb);+  } else {+    uv_read_start(read_stream, alloc_cb, read_cb);+  }++  timeout = false;++  if (ms > 0) {+    timer_req.data = &timeout;+    uv_timer_start(&timer_req, timer_cb, ms, 0);+  }++  while (true) {+    uv_run(uv_default_loop(), UV_RUN_ONCE);++    if (in_buffer.rpos < in_buffer.wpos || eof || timeout) {+      break;+    }+  }++  if (read_cmd_fd != UV_FILE) {+    uv_read_stop(read_stream);+  }++  if (ms > 0) {+    uv_timer_stop(&timer_req);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  /* timeout */+  return POLL_NONE;+}++static void initialize_event_loop()+{+  in_buffer.wpos = in_buffer.rpos = in_buffer.apos = in_buffer.fpos = 0;+#ifdef DEBUG+  memset(&in_buffer.data, 0, BUF_SIZE);+#endif++  /* Setup stdin_stream */+  if ((read_stream_type = uv_guess_handle(read_cmd_fd)) == UV_FILE) {+    in_buffer.uvbuf.len = in_buffer.apos = BUF_SIZE;+    in_buffer.uvbuf.base = (char *)in_buffer.data;+  } else if (read_stream_type == UV_TTY) {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_tty_t));+    uv_tty_init(uv_default_loop(), (uv_tty_t *)read_stream, read_cmd_fd, 1);+  } else {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_pipe_t));+    uv_pipe_init(uv_default_loop(), (uv_pipe_t *)read_stream, 0);+    uv_pipe_open((uv_pipe_t *)read_stream, read_cmd_fd);+  }++  uv_timer_init(uv_default_loop(), &timer_req);+}++/* Called by libuv to allocate memory for reading. */+static void alloc_cb(uv_handle_t *handle, size_t ssize, uv_buf_t *rv)",Had to look `uv_alloc_cb` type definition [1] to understand what `ssize` stands for. Consider renaming `ssize` and `rv`. I can't guess what `rv` stands for here.https://github.com/thlorenz/libuv-dox/blob/master/callbacks.md#uv_alloc_cb,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10903802,2014-03-24T20:17:11Z,src/os/io.c,"@@ -0,0 +1,274 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define INPUT_BUFFER_LENGTH 4096++typedef enum {+  kPollNone,+  kPollInput,+  kPollEof+} PollResult;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[INPUT_BUFFER_LENGTH];+} InputBuffer;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static InputBuffer in_buffer;+static bool initialized = false, eof = false;",Actually I was planning to call the initalization function directly from `main`. This is just temporary,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/395,10903898,2014-03-24T20:19:17Z,src/os/io.c,"@@ -0,0 +1,274 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define INPUT_BUFFER_LENGTH 4096++typedef enum {+  kPollNone,+  kPollInput,+  kPollEof+} PollResult;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[INPUT_BUFFER_LENGTH];+} InputBuffer;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static InputBuffer in_buffer;+static bool initialized = false, eof = false;+static PollResult io_poll(int32_t ms);+static PollResult inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  PollResult result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != kPollInput) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != kPollInput) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        buf[0] = K_SPECIAL;+        buf[1] = KS_EXTRA;+        buf[2] = KE_CURSORHOLD;+        return 3;+      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == kPollEof) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0) == kPollInput;+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++/* This is a replacement for the old `WaitForChar` function in os_unix.c */+static PollResult inbuf_poll(int32_t ms)+{+  if (input_available())+    return kPollInput;++  return io_poll(ms);+}++/* Poll the system for user input */+PollResult io_poll(int32_t ms)+{+  bool timeout;++  if (in_buffer.rpos < in_buffer.wpos) {+    /* If there's data buffered from a previous event loop iteration, +     * let vim read it */+    return kPollInput;+  }++  if (eof) {+    return kPollEof;+  }++  if (ms == 0) {+    return kPollNone;+  }++  if (!initialized) {+    /* Only initialize the event loop once */+    initialize_event_loop();+    initialized = true;+  }++  /* Pin the buffer used by libuv */+  in_buffer.uvbuf.len = INPUT_BUFFER_LENGTH - in_buffer.apos;+  in_buffer.uvbuf.base = (char *)(in_buffer.data + in_buffer.apos);+  in_buffer.apos = INPUT_BUFFER_LENGTH;++  if (read_stream_type == UV_FILE) {+    uv_fs_read(+        uv_default_loop(),+        &read_req,+        read_cmd_fd,+        &in_buffer.uvbuf,+        1,+        in_buffer.fpos,+        fread_cb);+  } else {+    uv_read_start(read_stream, alloc_cb, read_cb);+  }++  timeout = false;++  if (ms > 0) {+    timer_req.data = &timeout;+    uv_timer_start(&timer_req, timer_cb, ms, 0);+  }++  while (true) {+    uv_run(uv_default_loop(), UV_RUN_ONCE);","What to do in an `alloc_cb, alloc_cb` situation (Windows)? Both allocated buffer are the same now (with the new `alloc_cb` implementation). If both buffer are used to read at least one byte then `in_buffer.data` is corrupted.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10905414,2014-03-24T20:49:07Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)+    buf[rv++] = in_buffer.data[in_buffer.rpos++];++  return rv;+}++/* This is a replacement for the old `WaitForChar` function in os_unix.c */+static poll_result_t inbuf_poll(int32_t ms)+{+  if (input_available())+    return POLL_INPUT;++  return io_poll(ms);+}++/* Poll the system for user input */+poll_result_t io_poll(int32_t ms)+{+  bool timeout;++  if (in_buffer.rpos < in_buffer.wpos) {+    /* If there's data buffered from a previous event loop iteration, +     * let vim read it */+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  if (ms == 0) {+    return POLL_NONE;+  }++  if (!initialized) {+    /* Only initialize the event loop once */+    initialize_event_loop();+    initialized = true;+  }++  if (read_cmd_fd == UV_FILE) {+    uv_fs_read(uv_default_loop(), &read_req, read_cmd_fd, &in_buffer.uvbuf, 1,+        in_buffer.fpos, fread_cb);+  } else {+    uv_read_start(read_stream, alloc_cb, read_cb);+  }++  timeout = false;++  if (ms > 0) {+    timer_req.data = &timeout;+    uv_timer_start(&timer_req, timer_cb, ms, 0);+  }++  while (true) {+    uv_run(uv_default_loop(), UV_RUN_ONCE);++    if (in_buffer.rpos < in_buffer.wpos || eof || timeout) {+      break;+    }+  }++  if (read_cmd_fd != UV_FILE) {+    uv_read_stop(read_stream);+  }++  if (ms > 0) {+    uv_timer_stop(&timer_req);+  }++  if (in_buffer.rpos < in_buffer.wpos) {+    return POLL_INPUT;+  }++  if (eof) {+    return POLL_EOF;+  }++  /* timeout */+  return POLL_NONE;+}++static void initialize_event_loop()+{+  in_buffer.wpos = in_buffer.rpos = in_buffer.apos = in_buffer.fpos = 0;+#ifdef DEBUG+  memset(&in_buffer.data, 0, BUF_SIZE);+#endif++  /* Setup stdin_stream */+  if ((read_stream_type = uv_guess_handle(read_cmd_fd)) == UV_FILE) {+    in_buffer.uvbuf.len = in_buffer.apos = BUF_SIZE;+    in_buffer.uvbuf.base = (char *)in_buffer.data;+  } else if (read_stream_type == UV_TTY) {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_tty_t));+    uv_tty_init(uv_default_loop(), (uv_tty_t *)read_stream, read_cmd_fd, 1);+  } else {+    read_stream = (uv_stream_t *)malloc(sizeof(uv_pipe_t));+    uv_pipe_init(uv_default_loop(), (uv_pipe_t *)read_stream, 0);+    uv_pipe_open((uv_pipe_t *)read_stream, read_cmd_fd);+  }++  uv_timer_init(uv_default_loop(), &timer_req);+}++/* Called by libuv to allocate memory for reading. */+static void alloc_cb(uv_handle_t *handle, size_t ssize, uv_buf_t *rv)+{+  uint32_t available;++  if ((available = BUF_SIZE - in_buffer.apos) == 0) {+    rv->len = 0;+    return;+  }++  rv->base = (char *)(in_buffer.data + in_buffer.apos);+  rv->len = available;+  in_buffer.apos += available;+}++/*+ * Callback invoked by libuv after it copies the data into the buffer provided+ * by `alloc_cb`. This is also called on EOF or when `alloc_cb` returns a+ * 0-length buffer.+ */+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{++  if (cnt < 0) {+    if (cnt == UV_EOF) {+      /* Set the EOF flag */+      eof = true;+    } else {+      fprintf(stderr, ""Unexpected error %s\n"", uv_strerror(cnt));+    }+    return;+  }++  /* Data was already written, so all we need is to update 'wpos' to reflect+   * the space actually used in the buffer. */+  in_buffer.wpos += cnt;+  relocate();+}++static void fread_cb(uv_fs_t *req)+{+  uint32_t available;++  uv_fs_req_cleanup(req);++  if (req->result <= 0) {+    if (req->result == 0) {+      /* Set the EOF flag */+      eof = true;+    } else {+      fprintf(stderr, ""Unexpected error %s\n"", uv_strerror(req->result));+    }+    return;+  }++  in_buffer.wpos += req->result;+  in_buffer.fpos += req->result;+  relocate();+  available = BUF_SIZE - in_buffer.apos;+  /* Read more */+  in_buffer.uvbuf.len = available;+  in_buffer.uvbuf.base = (char *)(in_buffer.data + in_buffer.apos);+  in_buffer.apos += available;+}++static void timer_cb(uv_timer_t *handle, int status) {+  *((bool *)handle->data) = true;+}++static void relocate()","Each co-process will have it's own input buffer, so I will extract most of the code of this module into a `ReadableStream` 'class'. For now let's leave it like this, if I extract it now it may look confusing as stdin is the only fd that uses this code.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10905768,2014-03-24T20:55:36Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)","Is this what you mean? ``` c  for (rv = 0; in_buffer.rpos < in_buffer.wpos && rv < count; rv++, in_buffer.rpos++)    buf[rv] = in_buffer.data[in_buffer.rpos];```",
1882250,mahkoh,https://api.github.com/repos/neovim/neovim/pulls/394,10908301,2014-03-24T21:49:38Z,src/os/fs.c,"@@ -140,7 +140,7 @@ int mch_get_absolute_path(char_u *fname, char_u *buf, int len, int force)   char_u *p;   *buf = NUL; -  char relative_directory[len];+  char relative_directory[MAXPATHL];",> the stack frame for calling this function will use more than 4k stack spaceI still don't see why that's a bad thing.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/395,10927329,2014-03-25T12:29:21Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)","If the reason for modifying the loop is readability, what do you think of this:``` c  for (rv = 0;  rv < count; rv++) {        buf[rv] = in_buffer.data[in_buffer.rpos];        in_buffer.rpos++;        if (in_buffer.rpos == in_buffer.wpos) {          break;        }  }```",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/395,10947795,2014-03-25T19:08:57Z,src/os/io.c,"@@ -0,0 +1,293 @@+#include <uv.h>++#include ""os/io.h""+#include ""vim.h""+#include ""misc2.h""+#include ""fileio.h""+#include ""getchar.h""+#include ""globals.h""+#include ""ui.h""++#define BUF_SIZE 4096++typedef enum {+  POLL_NONE,+  POLL_INPUT,+  POLL_EOF+} poll_result_t;++typedef struct {+  uv_buf_t uvbuf;+  uint32_t rpos, wpos, apos, fpos;+  char_u data[BUF_SIZE];+} input_buffer_T;++static uv_stream_t *read_stream;+static uv_fs_t read_req;+static uv_timer_t timer_req;+static uv_handle_type read_stream_type;+static input_buffer_T in_buffer;+static bool initialized = false, eof = false;+static poll_result_t io_poll(int32_t ms);+static int cursorhold_key(char_u *buf);+static poll_result_t inbuf_poll(int32_t ms);+static void initialize_event_loop(void);+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);+static void fread_cb(uv_fs_t *);+static void timer_cb(uv_timer_t *handle, int);+static void relocate(void);++int mch_inchar(char_u *buf, int maxlen, long ms, int tb_change_cnt)+{+  poll_result_t result;++  if (ms >= 0) {+    if ((result = inbuf_poll(ms)) != POLL_INPUT) {+      return 0;+    }+  } else {+    if ((result = inbuf_poll(p_ut)) != POLL_INPUT) {+      if (trigger_cursorhold() && maxlen >= 3 &&+          !typebuf_changed(tb_change_cnt)) {+        return cursorhold_key(buf);++      }++      before_blocking();+      result = inbuf_poll(-1);+    }+  }++  /* If input was put directly in typeahead buffer bail out here. */+  if (typebuf_changed(tb_change_cnt))+    return 0;++  if (result == POLL_EOF) {+    read_error_exit();+    return 0;+  }++  return read_from_input_buf(buf, (long)maxlen);+}++bool mch_char_avail()+{+  return inbuf_poll(0);+}++/*+ * Check for CTRL-C typed by reading all available characters.+ * In cooked mode we should get SIGINT, no need to check.+ */+void mch_breakcheck()+{+  if (curr_tmode == TMODE_RAW && in_buffer.rpos < in_buffer.wpos)+    fill_input_buf(FALSE);+}++/* Copies what was read from `read_cmd_fd` */+uint32_t io_read(char *buf, uint32_t count)+{+  uint32_t rv = 0;++  /* Copy at most 'count' to the buffer argument */+  while (in_buffer.rpos < in_buffer.wpos && rv < count)",@tarruda `&& extra_loop_condition` is better than a break block. Use @oni-link's idea and use `memcpy`. No need for loop! :),
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/404,11000210,2014-03-26T21:26:41Z,src/misc2.c,"@@ -772,43 +667,14 @@ char_u *lalloc(long_u size, int message)     return NULL;   } -#ifdef MEM_PROFILE-  mem_pre_alloc_l(&size);-#endif--   /*    * Loop when out of memory: Try to release some memfile blocks and    * if some blocks are released call malloc again.    */   for (;; ) {","I considered this, but decided it belongs to another PR.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/412,11029743,2014-03-27T16:00:37Z,src/os/input.c,"@@ -171,17 +169,24 @@ bool mch_char_avail()  */ void mch_breakcheck() {-  if (curr_tmode == TMODE_RAW && event_poll(0) == kEventInput)+  if (curr_tmode == TMODE_RAW && event_poll(0) == kInputAvail)","I forgot to update the condition to match the new boolean signature. I wonder if there is a compiler warning we can activate to prevent such mistakes in the future.The reason I used `event_poll(0)` is because the original function called `RealWaitForChar` which doesn't check the input buffer. I'm not sure about moving the `input_available()` test to `event_poll`, it might introduce a non-obvious bug",
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/415,11040536,2014-03-27T19:29:40Z,src/garray.h,"@@ -22,6 +22,7 @@ char_u *ga_concat_strings(garray_T *gap); void ga_concat(garray_T *gap, char_u *s); void ga_append(garray_T *gap, int c);+void ga_remove_duplicates(garray_T *gap);",Maybe rename this to `ga_remove_duplicate_strings` to be consistent with `ga_concat_strings` and to avoid that anyone tries to call this with another type than a string list.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/418,11061873,2014-03-28T11:07:11Z,src/screen.c,"@@ -677,7 +683,116 @@ void update_single_line(win_T *wp, linenr_T lnum) }  +/*+ * Prepare for updating one or more windows.+ * Caller must check for ""updating_screen"" already set to avoid recursiveness.+ */+    static void+update_prepare()+{+    cursor_off();+    updating_screen = TRUE;+#ifdef FEAT_GUI","This block is safe to remove, we no longer have this `gui` global variable",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/418,11061955,2014-03-28T11:09:50Z,src/screen.c,"@@ -677,7 +683,116 @@ void update_single_line(win_T *wp, linenr_T lnum) }  +/*+ * Prepare for updating one or more windows.+ * Caller must check for ""updating_screen"" already set to avoid recursiveness.+ */+    static void+update_prepare()+{+    cursor_off();+    updating_screen = TRUE;+#ifdef FEAT_GUI+    /* Remove the cursor before starting to do anything, because scrolling may+     * make it difficult to redraw the text under it. */+    if (gui.in_use)+	gui_undraw_cursor();+#endif+#ifdef FEAT_SEARCH_EXTRA+    start_search_hl();+#endif+}++/*+ * Finish updating one or more windows.+ */+    static void+update_finish()+{+    if (redraw_cmdline)+	showmode();++# ifdef FEAT_SEARCH_EXTRA+    end_search_hl();+# endif++    updating_screen = FALSE;++# ifdef FEAT_GUI",Feel free to remove all code within #ifdef which only has FEAT_GUI as a condition,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/418,11062060,2014-03-28T11:15:19Z,src/syntax.c,"@@ -7847,6 +7851,7 @@ static void highlight_list_two(int cnt, int attr)  */ char_u *get_highlight_name(expand_T *xp, int idx) {+  //TODO: 'xp' is unused",For now we still use `-Wno-unused-parameter` so leave like this for now.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/417,11093571,2014-03-29T14:46:05Z,src/eval.c,"@@ -12016,7 +12016,7 @@ static void f_readfile(typval_T *argvars, typval_T *rettv)           /* Change ""prev"" buffer to be the right size.  This way            * the bytes are only copied once, and very long lines are            * allocated only once.  */-          if ((s = realloc(prev, prevlen + len + 1)) != NULL) {+          if ((s = xrealloc(prev, prevlen + len + 1)) != NULL) {","@oni-link This if and many others. I already started working on it, but will send these changes on a separate PR.Sometimes, `return NULL` is used to pass the error through the call chain. It means that many more ifs can be removed, not only those right after allocation function calls.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/426,11094693,2014-03-29T19:02:26Z,src/misc2.h,"@@ -20,11 +23,11 @@ void check_cursor(void); void adjust_cursor_col(void); int leftcol_changed(void);-char_u *alloc(unsigned size);-char_u *alloc_clear(unsigned size);-char_u *alloc_check(unsigned size);-char_u *lalloc_clear(long_u size, int message);-char_u *lalloc(long_u size, int message);+char_u *alloc(unsigned size) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *alloc_clear(unsigned size) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *alloc_check(unsigned size) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *lalloc_clear(long_u size, int message) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *lalloc(long_u size, int message) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);","I'm not sure that having `FUNC_ATTR_ALLOC_SIZE(1)` is helping matters (from an optimization point of view).  It might be a good idea to just drop those off of there for now.  If we knew what alignment the underlying `malloc()` call was using, we could put that here and probably see some benefit.  But that's dependent on the processor and platform, and not fun to test for.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/426,11094733,2014-03-29T19:08:28Z,src/misc2.h,"@@ -20,11 +23,11 @@ void check_cursor(void); void adjust_cursor_col(void); int leftcol_changed(void);-char_u *alloc(unsigned size);-char_u *alloc_clear(unsigned size);-char_u *alloc_check(unsigned size);-char_u *lalloc_clear(long_u size, int message);-char_u *lalloc(long_u size, int message);+char_u *alloc(unsigned size) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *alloc_clear(unsigned size) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *alloc_check(unsigned size) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *lalloc_clear(long_u size, int message) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);+char_u *lalloc(long_u size, int message) FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE(1);","I think you're confusing `alloc_size` and `alloc_align`. I'm using `alloc_size`:```alloc_sizeThe alloc_size attribute is used to tell the compiler that the function return value points to memory, where the size is given by one or two of the functions parameters. GCC uses this information to improve the correctness of __builtin_object_size.The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one.For instance,          void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))          void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))```",
3405586,schmee,https://api.github.com/repos/neovim/neovim/pulls/410,11099013,2014-03-30T17:12:47Z,src/os/event.c,"@@ -3,9 +3,17 @@  #include <uv.h> +#include ""vim.h"" #include ""os/event.h"" #include ""os/input.h""+#include ""os/signal.h"" +typedef struct EventNode {",I agree. We should settle on a library of data structures for common situations like this or everyone will end up rolling their own. Then we could replace things like `garray.c` and `hashtab.c` as well.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/431,11100416,2014-03-30T21:10:16Z,src/path.c,"@@ -1298,3 +1300,438 @@ static int vim_backtick(char_u *p)   ((char_u **)gap->ga_data)[gap->ga_len++] = p; } #endif /* !NO_EXPANDPATH */++/*+ * Converts a file name into a canonical form. It simplifies a file name into+ * its simplest form by stripping out unneeded components, if any.  The+ * resulting file name is simplified in place and will either be the same+ * length as that supplied, or shorter.+ */+void simplify_filename(char_u *filename)+{+  int components = 0;+  char_u      *p, *tail, *start;+  int stripping_disabled = FALSE;+  int relative = TRUE;++  p = filename;+#ifdef BACKSLASH_IN_FILENAME+  if (p[1] == ':')          /* skip ""x:"" */+    p += 2;+#endif++  if (vim_ispathsep(*p)) {+    relative = FALSE;+    do+      ++p;+    while (vim_ispathsep(*p));+  }+  start = p;        /* remember start after ""c:/"" or ""/"" or ""///"" */++  do {+    /* At this point ""p"" is pointing to the char following a single ""/""+     * or ""p"" is at the ""start"" of the (absolute or relative) path name. */+    if (vim_ispathsep(*p))+      STRMOVE(p, p + 1);                /* remove duplicate ""/"" */+    else if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL)) {+      if (p == start && relative)+        p += 1 + (p[1] != NUL);         /* keep single ""."" or leading ""./"" */+      else {+        /* Strip ""./"" or "".///"".  If we are at the end of the file name+         * and there is no trailing path separator, either strip ""/."" if+         * we are after ""start"", or strip ""."" if we are at the beginning+         * of an absolute path name . */+        tail = p + 1;+        if (p[1] != NUL)+          while (vim_ispathsep(*tail))+            mb_ptr_adv(tail);+        else if (p > start)+          --p;                          /* strip preceding path separator */+        STRMOVE(p, tail);+      }+    } else if (p[0] == '.' && p[1] == '.' &&+               (vim_ispathsep(p[2]) || p[2] == NUL)) {+      /* Skip to after "".."" or ""../"" or ""..///"". */+      tail = p + 2;+      while (vim_ispathsep(*tail))+        mb_ptr_adv(tail);++      if (components > 0) {             /* strip one preceding component */+        int do_strip = FALSE;+        char_u saved_char;+        struct stat st;++        /* Don't strip for an erroneous file name. */+        if (!stripping_disabled) {+          /* If the preceding component does not exist in the file+           * system, we strip it.  On Unix, we don't accept a symbolic+           * link that refers to a non-existent file. */+          saved_char = p[-1];+          p[-1] = NUL;+#ifdef UNIX+          if (mch_lstat((char *)filename, &st) < 0)+#else+          if (mch_stat((char *)filename, &st) < 0)+#endif+            do_strip = TRUE;+          p[-1] = saved_char;++          --p;+          /* Skip back to after previous '/'. */+          while (p > start && !after_pathsep(start, p))+            mb_ptr_back(start, p);++          if (!do_strip) {+            /* If the component exists in the file system, check+             * that stripping it won't change the meaning of the+             * file name.  First get information about the+             * unstripped file name.  This may fail if the component+             * to strip is not a searchable directory (but a regular+             * file, for instance), since the trailing ""/.."" cannot+             * be applied then.  We don't strip it then since we+             * don't want to replace an erroneous file name by+             * a valid one, and we disable stripping of later+             * components. */+            saved_char = *tail;+            *tail = NUL;+            if (mch_stat((char *)filename, &st) >= 0)+              do_strip = TRUE;+            else+              stripping_disabled = TRUE;+            *tail = saved_char;+#ifdef UNIX+            if (do_strip) {+              struct stat new_st;++              /* On Unix, the check for the unstripped file name+               * above works also for a symbolic link pointing to+               * a searchable directory.  But then the parent of+               * the directory pointed to by the link must be the+               * same as the stripped file name.  (The latter+               * exists in the file system since it is the+               * component's parent directory.) */+              if (p == start && relative)+                (void)mch_stat(""."", &new_st);+              else {+                saved_char = *p;+                *p = NUL;+                (void)mch_stat((char *)filename, &new_st);+                *p = saved_char;+              }++              if (new_st.st_ino != st.st_ino ||+                  new_st.st_dev != st.st_dev) {+                do_strip = FALSE;+                /* We don't disable stripping of later+                 * components since the unstripped path name is+                 * still valid. */+              }+            }+#endif+          }+        }++        if (!do_strip) {+          /* Skip the "".."" or ""../"" and reset the counter for the+           * components that might be stripped later on. */+          p = tail;+          components = 0;+        } else {+          /* Strip previous component.  If the result would get empty+           * and there is no trailing path separator, leave a single+           * ""."" instead.  If we are at the end of the file name and+           * there is no trailing path separator and a preceding+           * component is left after stripping, strip its trailing+           * path separator as well. */+          if (p == start && relative && tail[-1] == '.') {+            *p++ = '.';+            *p = NUL;+          } else {+            if (p > start && tail[-1] == '.')+              --p;+            STRMOVE(p, tail);                   /* strip previous component */+          }++          --components;+        }+      } else if (p == start && !relative)       /* leading ""/.."" or ""/../"" */+        STRMOVE(p, tail);                       /* strip "".."" or ""../"" */+      else {+        if (p == start + 2 && p[-2] == '.') {           /* leading ""./../"" */+          STRMOVE(p - 2, p);                            /* strip leading ""./"" */+          tail -= 2;+        }+        p = tail;                       /* skip to char after "".."" or ""../"" */+      }+    } else {+      ++components;                     /* simple path component */+      p = getnextcomp(p);+    }+  } while (*p != NUL);+}++/*+ * Get the file name at the cursor.+ * If Visual mode is active, use the selected text if it's in one line.+ * Returns the name in allocated memory, NULL for failure.+ */+char_u *grab_file_name(long count, linenr_T *file_lnum)+{+  if (VIsual_active) {+    int len;+    char_u  *ptr;++    if (get_visual_text(NULL, &ptr, &len) == FAIL)+      return NULL;+    return find_file_name_in_path(ptr, len,+        FNAME_MESS|FNAME_EXP|FNAME_REL, count, curbuf->b_ffname);+  }+  return file_name_at_cursor(FNAME_MESS|FNAME_HYP|FNAME_EXP|FNAME_REL, count,+      file_lnum);++}++/*+ * Return the file name under or after the cursor.+ *+ * The 'path' option is searched if the file name is not absolute.+ * The string returned has been alloc'ed and should be freed by the caller.+ * NULL is returned if the file name or file is not found.+ *+ * options:+ * FNAME_MESS	    give error messages+ * FNAME_EXP	    expand to path+ * FNAME_HYP	    check for hypertext link+ * FNAME_INCL	    apply ""includeexpr""+ */+char_u *file_name_at_cursor(int options, long count, linenr_T *file_lnum)+{+  return file_name_in_line(ml_get_curline(),+      curwin->w_cursor.col, options, count, curbuf->b_ffname,+      file_lnum);+}++/*+ * Return the name of the file under or after ptr[col].+ * Otherwise like file_name_at_cursor().+ */+char_u *+file_name_in_line (","It's not clear to me that `file_name_in_line()` or `file_name_at_cursor()` belong in a general path-handling module. They require a buffer context (or apparently, window context, since they were in `window.h`), so I'm not sure that they need to be made available to other components that need general path functions.",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/445,11174206,2014-04-01T18:35:01Z,src/version.c,"@@ -225,6 +225,12 @@  static int included_patches[] = {   // Add new patch number below this line+  166,+  165,+  164,+  163,","If the patches haven't been applied, then they shouldn't be listed.  Vim handles gaps in the patch numbers just fine.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/445,11174359,2014-04-01T18:37:55Z,src/version.c,"@@ -225,6 +225,12 @@  static int included_patches[] = {   // Add new patch number below this line+  166,+  165,+  164,+  163,","@jamessan Agreed, but if a patch doesn't apply to neovim, because it fixes a bug in some component that is not longer present in neovim, does it make sense to break a plugin testing for that patch? Presumably, the plugin is testing for the patch to ensure the absence of a bug, and it makes sense to signal to the plugin that the bug isn't present in neovim, even if we didn't explicitly apply the patch.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/445,11174378,2014-04-01T18:38:22Z,src/version.c,"@@ -225,6 +225,12 @@  static int included_patches[] = {   // Add new patch number below this line+  166,+  165,+  164,+  163,",@jamessan thanks for mentioning that! It kinda makes sense too (otherwise we should just have to increment one number instead of adding to a list). That allows us to see what we skipped as well. I'm doubting a bit if we should put them commented out to signify that they've been reviewed and found N/A rather than removing them though....,
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/445,11176195,2014-04-01T19:14:16Z,src/version.c,"@@ -225,6 +225,12 @@  static int included_patches[] = {   // Add new patch number below this line+  166,+  165,+  164,+  163,","> Patch 7.4.161> Problem:    Crash in Python exception handling.> Solution:   Only use exception variables if did_throw is set. (ZyX)Shouldn't be listed because if_python was removed.> Patch 7.4.162> Problem:    Running tests in shadow dir doesn't work.> Solution:   Add testdir/sautest to the shadow target. (James McCoy)This specific instance of this problem doesn't exist because Vim's makefiles were replaced, and the incentive I have for using shadowdir (building different configurations of Vim) doesn't exist with neovim because the --with-feature configure flag and if_\* files were removed.  Regardless, this isn't something that would be relevant to a plugin.7.4.163 & 7.4.164 are both Windows IME related, so they shouldn't be listed (functionality doesn't exist, as was pointed out in #438).7.4.165 is a change to runtime files, specifically the example vimrc.  There's no need to perform a has('patchXXX') check for that, IMO, so I'd elide that as well.",
116260,mikaelj,https://api.github.com/repos/neovim/neovim/pulls/445,11176317,2014-04-01T19:17:00Z,src/version.c,"@@ -225,6 +225,12 @@  static int included_patches[] = {   // Add new patch number below this line+  166,+  165,+  164,+  163,","Is there a case when you would want to be explicit about which patches arenot applicable, as opposed to just emitting them from the included_patcheslist?2014-04-01 21:14 GMT+02:00 James McCoy notifications@github.com:> In src/version.c:> > > @@ -225,6 +225,12 @@> > > >  static int included_patches[] = {> >    // Add new patch number below this line> > -  166,> > -  165,> > -  164,> > -  163,> >  Patch 7.4.161> Problem: Crash in Python exception handling.> Solution: Only use exception variables if did_throw is set. (ZyX)> > Shouldn't be listed because if_python was removed.> > Patch 7.4.162> Problem: Running tests in shadow dir doesn't work.> Solution: Add testdir/sautest to the shadow target. (James McCoy)> > This specific instance of this problem doesn't exist because Vim's> makefiles were replaced, and the incentive I have for using shadowdir> (building different configurations of Vim) doesn't exist with neovim> because the --with-feature configure flag and if_\* files were removed.> Regardless, this isn't something that would be relevant to a plugin.> > 7.4.163 & 7.4.164 are both Windows IME related, so they shouldn't be> listed (functionality doesn't exist, as was pointed out in #438https://github.com/neovim/neovim/issues/438> ).> > 7.4.165 is a change to runtime files, specifically the example vimrc.> There's no need to perform a has('patchXXX') check for that, IMO, so I'd> elide that as well.> > ## > > Reply to this email directly or view it on GitHubhttps://github.com/neovim/neovim/pull/445/files#r11176195> .",
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/447,11201260,2014-04-02T11:44:50Z,src/os/fs.c,"@@ -278,3 +278,17 @@ int os_file_exists(const char_u *name)   } } +int os_rename(const char_u *path, const char_u *new_path)+{+  uv_fs_t request;+  int result = uv_fs_rename(uv_default_loop(), &request,+                            (const char *)path, (const char *)new_path, NULL);+  uv_fs_req_cleanup(&request);++  if (result != 0) {","According to the [style guide](http://neovim.org/development-wiki/style-guide/style-guide.xml?showone=Conditionals#Conditionals) we have to add parentheses here``` cif (result) {  return FAIL;}return OK;```Apart from that I'd prefer the current condition `if (result != 0)` over `if (result)` since the latter reads a lot like ""if there is a result"" but instead means ""if the result is not ok"". Admittedly the reader has to know that `0` is libuvs return value for success. Maybe some constant instead of `0` would make sense here.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/447,11223230,2014-04-02T19:36:09Z,test/unit/os/fs.moon,"@@ -322,12 +323,43 @@ describe 'fs function', ->         perm = ffi.C.kS_IXUSR         eq FAIL, (os_setperm 'non-existing-file', perm) -  describe 'os_file_exists', ->+  describe 'file operations', ->     os_file_exists = (filename) ->       fs.os_file_exists (to_cstr filename) -    it 'returns FALSE when given a non-existing file', ->-      eq FALSE, (os_file_exists 'non-existing-file')--    it 'returns TRUE when given an existing file', ->-      eq TRUE, (os_file_exists 'unit-test-directory/test.file')+    os_rename = (path, new_path) ->+      fs.os_rename (to_cstr path), (to_cstr new_path)++    describe 'os_file_exists', ->+      it 'returns FALSE when given a non-existing file', ->+        eq FALSE, (os_file_exists 'non-existing-file')++      it 'returns TRUE when given an existing file', ->+        eq TRUE, (os_file_exists 'unit-test-directory/test.file')++    describe 'os_rename', ->+      test = 'unit-test-directory/test.file'+      not_exist = 'unit-test-directory/not_exist.file'++      it 'can rename file if destination file does not exist', ->+        eq OK, (os_rename test, not_exist)+        eq FALSE, (os_file_exists test)+        eq TRUE, (os_file_exists not_exist)+        eq OK, (os_rename not_exist, test)  -- restore test file",this should be in `teardown` https://github.com/Hinidu/neovim/blob/2e6e12cb4b985299f1dcba1a2b38b849bd1f0917/test/unit/os/fs.moon#L44,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/446,11225085,2014-04-02T20:13:40Z,src/macros.h,"@@ -47,34 +42,18 @@  /*  * toupper() and tolower() that use the current locale.- * On some systems toupper()/tolower() only work on lower/uppercase- * characters, first use islower() or isupper() then.  * Careful: Only call TOUPPER_LOC() and TOLOWER_LOC() with a character in the  * range 0 - 255.  toupper()/tolower() on some systems can't handle others.- * Note: It is often better to use MB_TOLOWER() and MB_TOUPPER(), because many+ * Note: It is often better to use vim_tolower() and vim_toupper(), because many  * toupper() and tolower() implementations only work for ASCII.  */-# ifdef BROKEN_TOUPPER-#  define TOUPPER_LOC(c)        (islower(c) ? toupper(c) : (c))-#  define TOLOWER_LOC(c)        (isupper(c) ? tolower(c) : (c))","Are you sure this is no longer needed for Windows (and BSD, I didn't check)? [MSDN toupper](http://msdn.microsoft.com/en-us/library/45119yx3.aspx) says: > In order for toupper to give the expected results, __isascii and isupper must both return nonzero(Which makes no sense, so I wonder if they meant ""islower""...)",
112971,jamessan,https://api.github.com/repos/neovim/neovim/pulls/447,11271244,2014-04-03T20:34:55Z,src/fileio.c,"@@ -4969,169 +4969,6 @@ int tag_fgets(char_u *buf, int size, FILE *fp) } #endif -/*- * rename() only works if both files are on the same file system, this- * function will (attempts to?) copy the file across if rename fails -- webb","Files on different filesystems/mount points aren't related to legacy systems.  It's quite common to have distinct /home and/or /tmp be different mount points than / in Linux.libuv's rename may handle everything up to the actual rename() call in vim_rename, which is still a net reduction in complexity, but we still need to handle the error case.",
3405586,schmee,https://api.github.com/repos/neovim/neovim/pulls/461,11284954,2014-04-04T07:17:54Z,src/memory.c,"@@ -0,0 +1,311 @@+ // Various routines dealing with allocation and deallocation of memory.","These memory functions seem mostly OS independant, so I'm not sure if they belong in `os/`. If it's deemed necessary we can move them later.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/470,11321226,2014-04-05T13:16:33Z,src/os/env.c,"@@ -50,3 +54,27 @@ char *os_getenvname_at_index(size_t index) # endif } ++long os_get_pid()+{+  return (long)getpid();",It seems that `getpid` is not portable too. MSDN says that this function is deprecated and recommend to use `_getpid`. Original vim define it in os_win32.h as `GetCurrentProcessId`.,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/470,11321240,2014-04-05T13:20:25Z,src/os/env.c,"@@ -50,3 +54,27 @@ char *os_getenvname_at_index(size_t index) # endif } ++long os_get_pid()+{+  return (long)getpid();+}++void os_get_hostname(char *hostname, size_t len)+{+#ifdef HAVE_SYS_UTSNAME_H",Maybe it is better to hide entire function in this #ifdef? I think that compile-time error is the best reminder that something must be fixed.,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/476,11328465,2014-04-06T22:47:03Z,src/lib/klist.h,"@@ -0,0 +1,131 @@+/* The MIT License++   Copyright (c) 2008-2009, by Attractive Chaos <attractor@live.co.uk>++   Permission is hereby granted, free of charge, to any person obtaining+   a copy of this software and associated documentation files (the+   ""Software""), to deal in the Software without restriction, including+   without limitation the rights to use, copy, modify, merge, publish,+   distribute, sublicense, and/or sell copies of the Software, and to+   permit persons to whom the Software is furnished to do so, subject to+   the following conditions:++   The above copyright notice and this permission notice shall be+   included in all copies or substantial portions of the Software.++   THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE+   SOFTWARE.+*/++#ifndef _AC_KLIST_H+#define _AC_KLIST_H++#include <stdbool.h>+#include <stdlib.h>++#include ""func_attr.h""+#include ""memory.h""++#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f)                       \+    typedef struct {                                                    \+        size_t cnt, n, max;                                             \+        kmptype_t **buf;                                                \+    } kmp_##name##_t;                                                   \+    static inline kmp_##name##_t *kmp_init_##name() {                   \+        return xcalloc(1, sizeof(kmp_##name##_t));                      \+    }                                                                   \+    static inline void kmp_destroy_##name(kmp_##name##_t *mp) {         \+        size_t k;                                                       \+        for (k = 0; k < mp->n; ++k) {                                   \+            kmpfree_f(mp->buf[k]); free(mp->buf[k]);                    \+        }                                                               \+        free(mp->buf); free(mp);                                        \+    }                                                                   \+    static inline kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) {     \+        ++mp->cnt;                                                      \+        if (mp->n == 0) return xcalloc(1, sizeof(kmptype_t));           \+        return mp->buf[--mp->n];                                        \+    }                                                                   \+    static inline void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \+        --mp->cnt;                                                      \+        if (mp->n == mp->max) {                                         \+            mp->max = mp->max? mp->max<<1 : 16;                         \+            mp->buf = xrealloc(mp->buf, sizeof(void*) * mp->max);       \+        }                                                               \+        mp->buf[mp->n++] = p;                                           \+    }++#define kmempool_t(name) kmp_##name##_t+#define kmp_init(name) kmp_init_##name()+#define kmp_destroy(name, mp) kmp_destroy_##name(mp)+#define kmp_alloc(name, mp) kmp_alloc_##name(mp)+#define kmp_free(name, mp, p) kmp_free_##name(mp, p)++#define KLIST_INIT(name, kltype_t, kmpfree_t)                           \+    struct __kl1_##name {                                               \+        kltype_t data;                                                  \+        struct __kl1_##name *next;                                      \+    };                                                                  \+    typedef struct __kl1_##name kl1_##name;                             \+    KMEMPOOL_INIT(name, kl1_##name, kmpfree_t)                          \+    typedef struct {                                                    \+        kl1_##name *head, *tail;                                        \+        kmp_##name##_t *mp;                                             \+        size_t size;                                                    \","`size` is not used anywhere except `kl_pushp` and `kl_shift`, where it is just incremented/decremented.I see three possibilities to deal with it:- remove `size` and save some memory if we will use these lists more actively- rewrite `kl_empty` as `return kl->size == 0`- create `#define kl_size` to access `size`(and maybe replace usages of `kl_empty` by `kl_size == 0`)",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/476,11328731,2014-04-06T23:44:00Z,src/lib/klist.h,"@@ -0,0 +1,131 @@+/* The MIT License++   Copyright (c) 2008-2009, by Attractive Chaos <attractor@live.co.uk>++   Permission is hereby granted, free of charge, to any person obtaining+   a copy of this software and associated documentation files (the+   ""Software""), to deal in the Software without restriction, including+   without limitation the rights to use, copy, modify, merge, publish,+   distribute, sublicense, and/or sell copies of the Software, and to+   permit persons to whom the Software is furnished to do so, subject to+   the following conditions:++   The above copyright notice and this permission notice shall be+   included in all copies or substantial portions of the Software.++   THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE+   SOFTWARE.+*/++#ifndef _AC_KLIST_H+#define _AC_KLIST_H++#include <stdbool.h>+#include <stdlib.h>++#include ""func_attr.h""+#include ""memory.h""++#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f)                       \+    typedef struct {                                                    \+        size_t cnt, n, max;                                             \+        kmptype_t **buf;                                                \+    } kmp_##name##_t;                                                   \+    static inline kmp_##name##_t *kmp_init_##name() {                   \+        return xcalloc(1, sizeof(kmp_##name##_t));                      \+    }                                                                   \+    static inline void kmp_destroy_##name(kmp_##name##_t *mp) {         \+        size_t k;                                                       \+        for (k = 0; k < mp->n; ++k) {                                   \+            kmpfree_f(mp->buf[k]); free(mp->buf[k]);                    \+        }                                                               \+        free(mp->buf); free(mp);                                        \+    }                                                                   \+    static inline kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) {     \+        ++mp->cnt;                                                      \+        if (mp->n == 0) return xcalloc(1, sizeof(kmptype_t));           \+        return mp->buf[--mp->n];                                        \+    }                                                                   \+    static inline void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \+        --mp->cnt;                                                      \+        if (mp->n == mp->max) {                                         \+            mp->max = mp->max? mp->max<<1 : 16;                         \+            mp->buf = xrealloc(mp->buf, sizeof(void*) * mp->max);       \+        }                                                               \+        mp->buf[mp->n++] = p;                                           \+    }++#define kmempool_t(name) kmp_##name##_t+#define kmp_init(name) kmp_init_##name()+#define kmp_destroy(name, mp) kmp_destroy_##name(mp)+#define kmp_alloc(name, mp) kmp_alloc_##name(mp)+#define kmp_free(name, mp, p) kmp_free_##name(mp, p)++#define KLIST_INIT(name, kltype_t, kmpfree_t)                           \+    struct __kl1_##name {                                               \+        kltype_t data;                                                  \+        struct __kl1_##name *next;                                      \+    };                                                                  \+    typedef struct __kl1_##name kl1_##name;                             \+    KMEMPOOL_INIT(name, kl1_##name, kmpfree_t)                          \+    typedef struct {                                                    \+        kl1_##name *head, *tail;                                        \+        kmp_##name##_t *mp;                                             \+        size_t size;                                                    \",Maybe we should take this upstream then? I don't know how valuable it is to keep a divergent fork of klib around...,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/476,11328967,2014-04-07T00:21:12Z,src/lib/klist.h,"@@ -0,0 +1,131 @@+/* The MIT License++   Copyright (c) 2008-2009, by Attractive Chaos <attractor@live.co.uk>++   Permission is hereby granted, free of charge, to any person obtaining+   a copy of this software and associated documentation files (the+   ""Software""), to deal in the Software without restriction, including+   without limitation the rights to use, copy, modify, merge, publish,+   distribute, sublicense, and/or sell copies of the Software, and to+   permit persons to whom the Software is furnished to do so, subject to+   the following conditions:++   The above copyright notice and this permission notice shall be+   included in all copies or substantial portions of the Software.++   THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE+   SOFTWARE.+*/++#ifndef _AC_KLIST_H+#define _AC_KLIST_H++#include <stdbool.h>+#include <stdlib.h>++#include ""func_attr.h""+#include ""memory.h""++#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f)                       \+    typedef struct {                                                    \+        size_t cnt, n, max;                                             \+        kmptype_t **buf;                                                \+    } kmp_##name##_t;                                                   \+    static inline kmp_##name##_t *kmp_init_##name() {                   \+        return xcalloc(1, sizeof(kmp_##name##_t));                      \+    }                                                                   \+    static inline void kmp_destroy_##name(kmp_##name##_t *mp) {         \+        size_t k;                                                       \+        for (k = 0; k < mp->n; ++k) {                                   \+            kmpfree_f(mp->buf[k]); free(mp->buf[k]);                    \+        }                                                               \+        free(mp->buf); free(mp);                                        \+    }                                                                   \+    static inline kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) {     \+        ++mp->cnt;                                                      \+        if (mp->n == 0) return xcalloc(1, sizeof(kmptype_t));           \+        return mp->buf[--mp->n];                                        \+    }                                                                   \+    static inline void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) { \+        --mp->cnt;                                                      \+        if (mp->n == mp->max) {                                         \+            mp->max = mp->max? mp->max<<1 : 16;                         \+            mp->buf = xrealloc(mp->buf, sizeof(void*) * mp->max);       \+        }                                                               \+        mp->buf[mp->n++] = p;                                           \+    }++#define kmempool_t(name) kmp_##name##_t+#define kmp_init(name) kmp_init_##name()+#define kmp_destroy(name, mp) kmp_destroy_##name(mp)+#define kmp_alloc(name, mp) kmp_alloc_##name(mp)+#define kmp_free(name, mp, p) kmp_free_##name(mp, p)++#define KLIST_INIT(name, kltype_t, kmpfree_t)                           \+    struct __kl1_##name {                                               \+        kltype_t data;                                                  \+        struct __kl1_##name *next;                                      \+    };                                                                  \+    typedef struct __kl1_##name kl1_##name;                             \+    KMEMPOOL_INIT(name, kl1_##name, kmpfree_t)                          \+    typedef struct {                                                    \+        kl1_##name *head, *tail;                                        \+        kmp_##name##_t *mp;                                             \+        size_t size;                                                    \","@aktau klib doesn't have docs and the author doesn't seem to merge the PRs people send. Having a divergent fork is not a problem: it's is a necessity (`kl_empty` was implemented by me, for example). As I said in the commit message:>   The whole point of abstract data structures is to avoid reimplementing>   common actions. The emptiness test seems to be such an action.@Hinidu> remove size and save some memory if we will use these lists more activelyThis makes querying for the length of the list an O(n) operation. Not an option. Specially if we're going to use these lists more actively and we will.> rewrite kl_empty as return kl->size == 0I will totally do it. My emptiness test was inspired by the iterator comparison. Testing size doesn't depend on the list type: can be a pure macro.> create #define kl_size to access size (and maybe replace usages of kl_empty by kl_size == 0)I think it's OK to use `list->size`, but `kl_empty` is still valid: `!kl_empty(list)` reads much better than `list->size != 0` or `!list->size`. ",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/476,11328985,2014-04-07T00:23:43Z,src/memory.c,"@@ -132,6 +133,27 @@ void *xmalloc(size_t size)   return ret; } +void *xcalloc(size_t count, size_t size)+{+  void *ret = calloc(count, size);++  if (!ret && (!count || !size))+    ret = calloc(1, 1);++  if (!ret) {+    try_to_free_memory();+    ret = calloc(count, size);+    if (!ret && (!count || !size))",These `malloc` functions look so nice like this. :) They're inspired by `git`'s implementation [1].[1] https://github.com/git/git/blob/master/wrapper.c#L45,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/476,11330517,2014-04-07T03:33:55Z,src/memory.c,"@@ -96,9 +93,7 @@ char_u *alloc_check(unsigned size)  */ char_u *lalloc_clear(long_u size, int message) {-  char_u *p = lalloc(size, message);-  memset(p, 0, (size_t)size);-  return p;+  return (char_u *)xcalloc(1, (size_t)size);",Is it correct that `message` is unused now?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/475,11351139,2014-04-07T16:05:33Z,src/os/job.c,"@@ -0,0 +1,315 @@+#include <stdint.h>+#include <stdbool.h>++#include <uv.h>++#include ""os/job_defs.h""+#include ""os/job.h""+#include ""os/time.h""+#include ""os/shell.h""+#include ""vim.h""+#include ""memory.h""+#include ""term.h""++#define EXIT_TIMEOUT 25+#define MAX_RUNNING_JOBS 100+#define JOB_BUFFER_SIZE 1024++/// Possible lock states of the job buffer+typedef enum {+  kBufferLockNone = 0, ///< No data was read+  kBufferLockStdout,   ///< Data read from stdout+  kBufferLockStderr    ///< Data read from stderr+} BufferLock;++struct _Job {+  // Job id the index in the job table plus one. +  int id;+  // Number of times the job will can be sent SIGTERM before a SIGKILL+  int exit_timeout;+  // If the job was already stopped+  bool stopped;+  // Data associated with the job+  void *data;+  // Buffer for reading from stdout or stderr+  char buffer[JOB_BUFFER_SIZE];+  // Size of the data from the last read+  uint32_t length;+  // Buffer lock state+  BufferLock lock;+  // Callback for consuming data from the buffer+  job_read_cb read_cb;+  // Structures for process spawning/management used by libuv+  uv_process_t proc;+  uv_process_options_t proc_opts;+  uv_stdio_container_t stdio[3];+  uv_pipe_t proc_stdin, proc_stdout, proc_stderr;+};++static Job *table[MAX_RUNNING_JOBS] = {NULL};+static uv_prepare_t job_prepare;++// Some helpers shared in this module+static bool is_alive(Job *job);+static Job * find_job(int id);++// Callbacks for libuv+static void job_prepare_cb(uv_prepare_t *handle, int status);+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf);+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf);+static void write_cb(uv_write_t *req, int status);+static void exit_cb(uv_process_t *proc, int64_t status, int term_signal);++void job_init()+{+  uv_disable_stdio_inheritance();+  uv_prepare_init(uv_default_loop(), &job_prepare);+  uv_prepare_start(&job_prepare, job_prepare_cb);+}++void job_teardown()+{+  uint32_t remaining_tries = 6;+  int i;+  Job *job;++  // Politely ask each job to terminate+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) != NULL) {+      uv_process_kill(&job->proc, SIGTERM);+    }+  }++  // Prepare to start shooting+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) == NULL) continue;+    if (is_alive(job)) {+      // Still alive+      if (remaining_tries--) {+        // Since this is the first time we're checking, wait 300ms so+        // every job has a chance to exit normally+        os_delay(50, 0);+      }+      uv_process_kill(&job->proc, SIGKILL);+    }+  }+}++int job_start(char **argv, void *data, job_read_cb cb)+{+  int i;+  Job *job;+ +  // Search for a free flot in the table+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if (table[i] == NULL) {+      break;+    }+  }++  if (i == MAX_RUNNING_JOBS) {+    // No free slots+    return 0;+  }++  job = xmalloc(sizeof(Job)); +  // Initialize+  job->id = i + 1;+  job->data = data;+  job->read_cb = cb;+  job->stopped = false;+  job->exit_timeout = EXIT_TIMEOUT;+  job->proc_opts.file = argv[0];+  job->proc_opts.args = argv;+  job->proc_opts.stdio = job->stdio;+  job->proc_opts.stdio_count = 3;+  job->proc_opts.flags = UV_PROCESS_WINDOWS_HIDE;+  job->proc_opts.exit_cb = exit_cb;+  job->proc_opts.cwd = NULL;+  job->proc_opts.env = NULL;++  // Initialize the job std{in,out,err}+  uv_pipe_init(uv_default_loop(), &job->proc_stdin, 0);+  job->proc_stdin.data = job;+  job->stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;+  job->stdio[0].data.stream = (uv_stream_t *)&job->proc_stdin;++  uv_pipe_init(uv_default_loop(), &job->proc_stdout, 0);+  job->proc_stdout.data = job;+  job->stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+  job->stdio[1].data.stream = (uv_stream_t *)&job->proc_stdout;++  uv_pipe_init(uv_default_loop(), &job->proc_stderr, 0);+  job->proc_stderr.data = job;+  job->stdio[2].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+  job->stdio[2].data.stream = (uv_stream_t *)&job->proc_stderr;++  // Spawn the job+  if (uv_spawn(uv_default_loop(), &job->proc, &job->proc_opts) != 0) {+    return -1;+  }+  // Start the readable streams+  uv_read_start((uv_stream_t *)&job->proc_stdout, alloc_cb, read_cb);+  uv_read_start((uv_stream_t *)&job->proc_stderr, alloc_cb, read_cb);+  // Give the callback a reference to the job+  job->proc.data = job;+  // Save the job to the table+  table[i] = job;++  return job->id;+}++bool job_stop(int id)+{+  Job *job = find_job(id);++  if (job == NULL || job->stopped) {+    return false;+  }++  uv_read_stop((uv_stream_t *)&job->proc_stdout);+  uv_read_stop((uv_stream_t *)&job->proc_stderr);+  job->stopped = true;++  return true;+}++bool job_write(int id, char *data, uint32_t len)+{+  uv_buf_t uvbuf;+  uv_write_t *req;+  Job *job = find_job(id);++  if (job == NULL || job->stopped) {+    return false;","Memory leak, `free(data)` is missing. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/475,11351341,2014-04-07T16:09:34Z,src/os_unix.c,"@@ -589,6 +590,7 @@ void mch_exit(int r) {   exiting = TRUE; +  job_teardown();",is this also needed in `preserve_exit()` or some part of that call chain?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/475,11352151,2014-04-07T16:28:23Z,src/os/job.c,"@@ -0,0 +1,315 @@+#include <stdint.h>+#include <stdbool.h>++#include <uv.h>++#include ""os/job_defs.h""+#include ""os/job.h""+#include ""os/time.h""+#include ""os/shell.h""+#include ""vim.h""+#include ""memory.h""+#include ""term.h""++#define EXIT_TIMEOUT 25+#define MAX_RUNNING_JOBS 100+#define JOB_BUFFER_SIZE 1024++/// Possible lock states of the job buffer+typedef enum {+  kBufferLockNone = 0, ///< No data was read+  kBufferLockStdout,   ///< Data read from stdout+  kBufferLockStderr    ///< Data read from stderr+} BufferLock;++struct _Job {+  // Job id the index in the job table plus one. +  int id;+  // Number of times the job will can be sent SIGTERM before a SIGKILL+  int exit_timeout;+  // If the job was already stopped+  bool stopped;+  // Data associated with the job+  void *data;+  // Buffer for reading from stdout or stderr+  char buffer[JOB_BUFFER_SIZE];+  // Size of the data from the last read+  uint32_t length;+  // Buffer lock state+  BufferLock lock;+  // Callback for consuming data from the buffer+  job_read_cb read_cb;+  // Structures for process spawning/management used by libuv+  uv_process_t proc;+  uv_process_options_t proc_opts;+  uv_stdio_container_t stdio[3];+  uv_pipe_t proc_stdin, proc_stdout, proc_stderr;+};++static Job *table[MAX_RUNNING_JOBS] = {NULL};+static uv_prepare_t job_prepare;++// Some helpers shared in this module+static bool is_alive(Job *job);+static Job * find_job(int id);++// Callbacks for libuv+static void job_prepare_cb(uv_prepare_t *handle, int status);+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf);+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf);+static void write_cb(uv_write_t *req, int status);+static void exit_cb(uv_process_t *proc, int64_t status, int term_signal);++void job_init()+{+  uv_disable_stdio_inheritance();+  uv_prepare_init(uv_default_loop(), &job_prepare);+  uv_prepare_start(&job_prepare, job_prepare_cb);+}++void job_teardown()+{+  uint32_t remaining_tries = 6;+  int i;+  Job *job;++  // Politely ask each job to terminate+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) != NULL) {+      uv_process_kill(&job->proc, SIGTERM);+    }+  }++  // Prepare to start shooting+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) == NULL) continue;+    if (is_alive(job)) {+      // Still alive+      if (remaining_tries--) {+        // Since this is the first time we're checking, wait 300ms so+        // every job has a chance to exit normally+        os_delay(50, 0);+      }+      uv_process_kill(&job->proc, SIGKILL);+    }+  }+}++int job_start(char **argv, void *data, job_read_cb cb)+{+  int i;+  Job *job;+ +  // Search for a free flot in the table+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if (table[i] == NULL) {+      break;+    }+  }++  if (i == MAX_RUNNING_JOBS) {+    // No free slots+    return 0;+  }++  job = xmalloc(sizeof(Job)); +  // Initialize+  job->id = i + 1;+  job->data = data;+  job->read_cb = cb;+  job->stopped = false;+  job->exit_timeout = EXIT_TIMEOUT;+  job->proc_opts.file = argv[0];+  job->proc_opts.args = argv;+  job->proc_opts.stdio = job->stdio;+  job->proc_opts.stdio_count = 3;+  job->proc_opts.flags = UV_PROCESS_WINDOWS_HIDE;+  job->proc_opts.exit_cb = exit_cb;+  job->proc_opts.cwd = NULL;+  job->proc_opts.env = NULL;++  // Initialize the job std{in,out,err}+  uv_pipe_init(uv_default_loop(), &job->proc_stdin, 0);+  job->proc_stdin.data = job;+  job->stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;+  job->stdio[0].data.stream = (uv_stream_t *)&job->proc_stdin;++  uv_pipe_init(uv_default_loop(), &job->proc_stdout, 0);+  job->proc_stdout.data = job;+  job->stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+  job->stdio[1].data.stream = (uv_stream_t *)&job->proc_stdout;++  uv_pipe_init(uv_default_loop(), &job->proc_stderr, 0);+  job->proc_stderr.data = job;+  job->stdio[2].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+  job->stdio[2].data.stream = (uv_stream_t *)&job->proc_stderr;++  // Spawn the job+  if (uv_spawn(uv_default_loop(), &job->proc, &job->proc_opts) != 0) {+    return -1;+  }+  // Start the readable streams+  uv_read_start((uv_stream_t *)&job->proc_stdout, alloc_cb, read_cb);+  uv_read_start((uv_stream_t *)&job->proc_stderr, alloc_cb, read_cb);+  // Give the callback a reference to the job+  job->proc.data = job;+  // Save the job to the table+  table[i] = job;++  return job->id;+}++bool job_stop(int id)+{+  Job *job = find_job(id);++  if (job == NULL || job->stopped) {+    return false;+  }++  uv_read_stop((uv_stream_t *)&job->proc_stdout);+  uv_read_stop((uv_stream_t *)&job->proc_stderr);+  job->stopped = true;++  return true;+}++bool job_write(int id, char *data, uint32_t len)+{+  uv_buf_t uvbuf;+  uv_write_t *req;+  Job *job = find_job(id);++  if (job == NULL || job->stopped) {+    return false;+  }++  req = xmalloc(sizeof(uv_write_t));+  req->data = data;+  uvbuf.base = data;+  uvbuf.len = len;+  uv_write(req, (uv_stream_t *)&job->proc_stdin, &uvbuf, 1, write_cb);++  return true;+}++void job_handle(Event event)+{+  Job *job = event.data.job;++  // Invoke the job callback+  job->read_cb(job->id,+               job->data,+               job->buffer,+               job->length,+               job->lock == kBufferLockStdout);+  shell_resized();+  // restart reading+  job->lock = kBufferLockNone;+  uv_read_start((uv_stream_t *)&job->proc_stdout, alloc_cb, read_cb);+  uv_read_start((uv_stream_t *)&job->proc_stderr, alloc_cb, read_cb);+}++static bool is_alive(Job *job)+{+  return uv_process_kill(&job->proc, 0) == 0;+}++static Job * find_job(int id)+{+  if (id <= 0 || id > MAX_RUNNING_JOBS) {+    return NULL;+  }+   +  return table[id - 1];+}++/// Iterates the table, sending SIGTERM to stopped jobs and SIGKILL to those+/// that didn't die from SIGTERM after a while(exit_timeout is 0).+static void job_prepare_cb(uv_prepare_t *handle, int status)+{+  Job *job;+  int i;++  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) == NULL || !job->stopped) {+      continue;+    }+  +    if ((job->exit_timeout--) == EXIT_TIMEOUT) {+      // Job was just stopped, close all stdio handles and send SIGTERM+      uv_process_kill(&job->proc, SIGTERM);+    } else if (job->exit_timeout == 0) {+      // We've waited long enough, send SIGKILL+      uv_process_kill(&job->proc, SIGKILL);+    }+  }+}++/// Puts the job into a 'reading state' which 'locks' the job buffer for+/// until the data is consumed+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  Job *job = (Job *)handle->data;++  if (job->lock != kBufferLockNone) {+    // Already reserved the buffer for reading from stdout or stderr.+    buf->len = 0;+    return;+  }++  buf->base = job->buffer;+  buf->len = JOB_BUFFER_SIZE;+  // Avoid `alloc_cb`, `alloc_cb` sequences on windows and also mark which+  // stream we are reading from+  job->lock =+    (handle == (uv_handle_t *)&job->proc_stdout) ?+    kBufferLockStdout :+    kBufferLockStderr;+}++/// Pushes a event object to the event queue, which will be handled later by+/// `job_handle`+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{+  Event event;+  Job *job = (Job *)stream->data;+  // pause reading on both streams+  uv_read_stop((uv_stream_t *)&job->proc_stdout);+  uv_read_stop((uv_stream_t *)&job->proc_stderr);++  if (cnt <= 0) {+    if (cnt != UV_ENOBUFS) {+      // Assume it's EOF and exit the job. Doesn't harm sending a SIGTERM+      // at this point+      uv_process_kill(&job->proc, SIGTERM);+    }+    return;+  }++  job->length = cnt;+  event.type = kEventJobActivity;+  event.data.job = job;+  event_push(event);+}++static void write_cb(uv_write_t *req, int status)",`status` intentionally unused?,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/475,11352296,2014-04-07T16:32:03Z,src/os/job.c,"@@ -0,0 +1,315 @@+#include <stdint.h>+#include <stdbool.h>++#include <uv.h>++#include ""os/job_defs.h""+#include ""os/job.h""+#include ""os/time.h""+#include ""os/shell.h""+#include ""vim.h""+#include ""memory.h""+#include ""term.h""++#define EXIT_TIMEOUT 25+#define MAX_RUNNING_JOBS 100+#define JOB_BUFFER_SIZE 1024++/// Possible lock states of the job buffer+typedef enum {+  kBufferLockNone = 0, ///< No data was read+  kBufferLockStdout,   ///< Data read from stdout+  kBufferLockStderr    ///< Data read from stderr+} BufferLock;++struct _Job {+  // Job id the index in the job table plus one. +  int id;+  // Number of times the job will can be sent SIGTERM before a SIGKILL+  int exit_timeout;+  // If the job was already stopped+  bool stopped;+  // Data associated with the job+  void *data;+  // Buffer for reading from stdout or stderr+  char buffer[JOB_BUFFER_SIZE];+  // Size of the data from the last read+  uint32_t length;+  // Buffer lock state+  BufferLock lock;+  // Callback for consuming data from the buffer+  job_read_cb read_cb;+  // Structures for process spawning/management used by libuv+  uv_process_t proc;+  uv_process_options_t proc_opts;+  uv_stdio_container_t stdio[3];+  uv_pipe_t proc_stdin, proc_stdout, proc_stderr;+};++static Job *table[MAX_RUNNING_JOBS] = {NULL};+static uv_prepare_t job_prepare;++// Some helpers shared in this module+static bool is_alive(Job *job);+static Job * find_job(int id);++// Callbacks for libuv+static void job_prepare_cb(uv_prepare_t *handle, int status);+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf);+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf);+static void write_cb(uv_write_t *req, int status);+static void exit_cb(uv_process_t *proc, int64_t status, int term_signal);++void job_init()+{+  uv_disable_stdio_inheritance();+  uv_prepare_init(uv_default_loop(), &job_prepare);+  uv_prepare_start(&job_prepare, job_prepare_cb);+}++void job_teardown()+{+  uint32_t remaining_tries = 6;+  int i;+  Job *job;++  // Politely ask each job to terminate+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) != NULL) {+      uv_process_kill(&job->proc, SIGTERM);+    }+  }++  // Prepare to start shooting+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) == NULL) continue;+    if (is_alive(job)) {+      // Still alive+      if (remaining_tries--) {+        // Since this is the first time we're checking, wait 300ms so+        // every job has a chance to exit normally+        os_delay(50, 0);+      }+      uv_process_kill(&job->proc, SIGKILL);+    }+  }+}++int job_start(char **argv, void *data, job_read_cb cb)+{+  int i;+  Job *job;+ +  // Search for a free flot in the table+  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if (table[i] == NULL) {+      break;+    }+  }++  if (i == MAX_RUNNING_JOBS) {+    // No free slots+    return 0;+  }++  job = xmalloc(sizeof(Job)); +  // Initialize+  job->id = i + 1;+  job->data = data;+  job->read_cb = cb;+  job->stopped = false;+  job->exit_timeout = EXIT_TIMEOUT;+  job->proc_opts.file = argv[0];+  job->proc_opts.args = argv;+  job->proc_opts.stdio = job->stdio;+  job->proc_opts.stdio_count = 3;+  job->proc_opts.flags = UV_PROCESS_WINDOWS_HIDE;+  job->proc_opts.exit_cb = exit_cb;+  job->proc_opts.cwd = NULL;+  job->proc_opts.env = NULL;++  // Initialize the job std{in,out,err}+  uv_pipe_init(uv_default_loop(), &job->proc_stdin, 0);+  job->proc_stdin.data = job;+  job->stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE;+  job->stdio[0].data.stream = (uv_stream_t *)&job->proc_stdin;++  uv_pipe_init(uv_default_loop(), &job->proc_stdout, 0);+  job->proc_stdout.data = job;+  job->stdio[1].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+  job->stdio[1].data.stream = (uv_stream_t *)&job->proc_stdout;++  uv_pipe_init(uv_default_loop(), &job->proc_stderr, 0);+  job->proc_stderr.data = job;+  job->stdio[2].flags = UV_CREATE_PIPE | UV_WRITABLE_PIPE;+  job->stdio[2].data.stream = (uv_stream_t *)&job->proc_stderr;++  // Spawn the job+  if (uv_spawn(uv_default_loop(), &job->proc, &job->proc_opts) != 0) {+    return -1;+  }+  // Start the readable streams+  uv_read_start((uv_stream_t *)&job->proc_stdout, alloc_cb, read_cb);+  uv_read_start((uv_stream_t *)&job->proc_stderr, alloc_cb, read_cb);+  // Give the callback a reference to the job+  job->proc.data = job;+  // Save the job to the table+  table[i] = job;++  return job->id;+}++bool job_stop(int id)+{+  Job *job = find_job(id);++  if (job == NULL || job->stopped) {+    return false;+  }++  uv_read_stop((uv_stream_t *)&job->proc_stdout);+  uv_read_stop((uv_stream_t *)&job->proc_stderr);+  job->stopped = true;++  return true;+}++bool job_write(int id, char *data, uint32_t len)+{+  uv_buf_t uvbuf;+  uv_write_t *req;+  Job *job = find_job(id);++  if (job == NULL || job->stopped) {+    return false;+  }++  req = xmalloc(sizeof(uv_write_t));+  req->data = data;+  uvbuf.base = data;+  uvbuf.len = len;+  uv_write(req, (uv_stream_t *)&job->proc_stdin, &uvbuf, 1, write_cb);++  return true;+}++void job_handle(Event event)+{+  Job *job = event.data.job;++  // Invoke the job callback+  job->read_cb(job->id,+               job->data,+               job->buffer,+               job->length,+               job->lock == kBufferLockStdout);+  shell_resized();+  // restart reading+  job->lock = kBufferLockNone;+  uv_read_start((uv_stream_t *)&job->proc_stdout, alloc_cb, read_cb);+  uv_read_start((uv_stream_t *)&job->proc_stderr, alloc_cb, read_cb);+}++static bool is_alive(Job *job)+{+  return uv_process_kill(&job->proc, 0) == 0;+}++static Job * find_job(int id)+{+  if (id <= 0 || id > MAX_RUNNING_JOBS) {+    return NULL;+  }+   +  return table[id - 1];+}++/// Iterates the table, sending SIGTERM to stopped jobs and SIGKILL to those+/// that didn't die from SIGTERM after a while(exit_timeout is 0).+static void job_prepare_cb(uv_prepare_t *handle, int status)+{+  Job *job;+  int i;++  for (i = 0; i < MAX_RUNNING_JOBS; i++) {+    if ((job = table[i]) == NULL || !job->stopped) {+      continue;+    }+  +    if ((job->exit_timeout--) == EXIT_TIMEOUT) {+      // Job was just stopped, close all stdio handles and send SIGTERM+      uv_process_kill(&job->proc, SIGTERM);+    } else if (job->exit_timeout == 0) {+      // We've waited long enough, send SIGKILL+      uv_process_kill(&job->proc, SIGKILL);+    }+  }+}++/// Puts the job into a 'reading state' which 'locks' the job buffer for+/// until the data is consumed+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  Job *job = (Job *)handle->data;++  if (job->lock != kBufferLockNone) {+    // Already reserved the buffer for reading from stdout or stderr.+    buf->len = 0;+    return;+  }++  buf->base = job->buffer;+  buf->len = JOB_BUFFER_SIZE;+  // Avoid `alloc_cb`, `alloc_cb` sequences on windows and also mark which+  // stream we are reading from+  job->lock =+    (handle == (uv_handle_t *)&job->proc_stdout) ?+    kBufferLockStdout :+    kBufferLockStderr;+}++/// Pushes a event object to the event queue, which will be handled later by+/// `job_handle`+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{+  Event event;+  Job *job = (Job *)stream->data;+  // pause reading on both streams+  uv_read_stop((uv_stream_t *)&job->proc_stdout);+  uv_read_stop((uv_stream_t *)&job->proc_stderr);++  if (cnt <= 0) {+    if (cnt != UV_ENOBUFS) {+      // Assume it's EOF and exit the job. Doesn't harm sending a SIGTERM+      // at this point+      uv_process_kill(&job->proc, SIGTERM);+    }+    return;+  }++  job->length = cnt;+  event.type = kEventJobActivity;+  event.data.job = job;+  event_push(event);+}++static void write_cb(uv_write_t *req, int status)","`status` might indicate a failure, we have two choices here:- Notify the user in some way- Kill the process(not necessary if the reason for failure is because it was killed already)I think the sane choice here is to kill the process, we don't want a job that we cant send data to, either way the user will be notified(I'm thinking of calling `JobActivity` with 0 or empty string is a reasonable way of notifying the job has exited)",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/485,11366385,2014-04-07T21:24:27Z,src/os/event.c,"@@ -146,7 +86,37 @@ static bool poll_uv_loop(int32_t ms)     uv_timer_stop(&timer);   } -  return input_ready() || !kl_empty(event_queue);+  return input_ready() || event_is_pending();+}++bool event_is_pending()+{+  return !kl_empty(event_queue);","Jobs continue to run but the events will be queued(the first time a job sends data it will 'lock' its read buffer, `alloc_cb` always return buf->len == 0.. If `os_call_shell` runs for long enough then it's possible that the OS buffer for the job will be full, which will cause the job process to :- block if it uses blocking writes- receive EAGAIN if it's writing with O_NONBLOCKIt would normalize once `os_call_shell` returns",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/479,11395262,2014-04-08T15:32:29Z,src/edit.c,"@@ -283,6 +283,7 @@ static void internal_format(int textwidth, int second_indent, int flags,  static colnr_T Insstart_textlen;        /* length of line when insert started */ static colnr_T Insstart_blank_vcol;     /* vcol for first inserted blank */+static int update_Insstart_orig = TRUE; /* set Insstart_orig to Insstart */","Indeed it seems to be a factual bool. The variable naming is a bit strange as well, don't know if we should change that, though.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/491,11408842,2014-04-08T20:07:16Z,src/os_unix_defs.h,"@@ -30,14 +30,9 @@ # include <sys/param.h>     /* defines BSD, if it's a BSD system */ #endif -/*- * Sun defines FILE on SunOS 4.x.x, Solaris has a typedef for FILE- */--/* always use unlink() to remove files */-#  define vim_mkdir(x, y) mkdir((char *)(x), y)-#  define mch_rmdir(x) rmdir((char *)(x))-#  define mch_remove(x) unlink((char *)(x))+#define vim_mkdir(x, y) os_mkdir((char *)(x), (y))+#define mch_rmdir(x)    os_rmdir((char *)(x))+#define mch_remove(x)   os_remove((char *)(x))","@justinmk I still see no reason why we couldn't rename, we're obviously not wanting to retain vim idiosyncrasies. I'm ambivalent about `os_remove` vs `os_rm`, but mirroring old vim api's should not be an argument against, I think. Unless I missed something?",
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/491,11410434,2014-04-08T20:40:57Z,src/ex_docmd.c,"@@ -7362,11 +7362,10 @@ static void ex_mkrc(exarg_T *eap)   vim_free(viewFile); } -#if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) && defined(vim_mkdir)) \-  || defined(PROTO)+#if ((defined(FEAT_SESSION) || defined(FEAT_EVAL)) || defined(PROTO))",Should I remove this preprocessor conditional completely?,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/509,11518005,2014-04-11T04:49:45Z,src/msgpack_rpc.c,"@@ -0,0 +1,139 @@+#include <msgpack.h>++#include ""msgpack_rpc.h""+#include ""vim.h""+#include ""memory.h""+++bool msgpack_rpc_call(msgpack_object *req, msgpack_packer *res)+{+  // Validate the basic structure of the msgpack-rpc payload+  if (req->type != MSGPACK_OBJECT_ARRAY+      // Must be an array of size 4+      || req->via.array.size != 4+      // First item is the message type, it must be 0 which represents+      // a request+      || req->via.array.ptr[0].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      || req->via.array.ptr[0].via.u64 != 0+      // Second item is the request id, it must be a positive integer+      || req->via.array.ptr[1].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      // Third item is the API function id, also a positive integer+      || req->via.array.ptr[2].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      // Last item is the function parameters, it must be an array+      || req->via.array.ptr[3].type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Invalid msgpack-rpc request"");+  }++  // dispatch the message+  return msgpack_rpc_dispatch(req, res);+}++void msgpack_rpc_response(msgpack_object *req, msgpack_packer *res)+{+  // Array of size 4+  msgpack_pack_array(res, 4);+  // Response type is 1+  msgpack_pack_int(res, 1);+  // Msgid is the same as the request+  msgpack_pack_int(res, req->via.array.ptr[1].via.u64);+}++void msgpack_rpc_success(msgpack_object *req, msgpack_packer *res)+{+  msgpack_rpc_response(req, res);+  // Nil error+  msgpack_pack_nil(res);+}++bool msgpack_rpc_error(msgpack_object *req, msgpack_packer *res, char *msg)+{+  size_t len = strlen(msg);++  msgpack_rpc_response(req, res);+  msgpack_pack_raw(res, len);+  msgpack_pack_raw_body(res, msg, len);+  // Nil result+  msgpack_pack_nil(res);++  return false;+}++char ** msgpack_rpc_array_argument(msgpack_object *obj)+{+  uint32_t i;+  char **rv = xmalloc(obj->via.array.size);++  for (i = 0; i < obj->via.array.size; i++) {+    rv[i] = msgpack_rpc_raw_argument(obj->via.array.ptr + i);+  }++  rv[i] = NULL;++  return rv;+}++char * msgpack_rpc_raw_argument(msgpack_object *obj)+{+  char *rv = xmalloc(obj->via.raw.size + 1);+  memcpy(rv, obj->via.raw.ptr, obj->via.raw.size);+  rv[obj->via.raw.size] = NUL;++  return rv;+}++uint32_t msgpack_rpc_integer_argument(msgpack_object *obj)+{+  return obj->via.u64;+}++bool msgpack_rpc_array_result(char **result,+                             msgpack_object *req,+                             msgpack_packer *res)",Indentation of these parameters is off.,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/509,11518034,2014-04-11T04:51:22Z,src/msgpack_rpc.c,"@@ -0,0 +1,139 @@+#include <msgpack.h>++#include ""msgpack_rpc.h""+#include ""vim.h""+#include ""memory.h""+++bool msgpack_rpc_call(msgpack_object *req, msgpack_packer *res)+{+  // Validate the basic structure of the msgpack-rpc payload+  if (req->type != MSGPACK_OBJECT_ARRAY+      // Must be an array of size 4+      || req->via.array.size != 4+      // First item is the message type, it must be 0 which represents+      // a request+      || req->via.array.ptr[0].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      || req->via.array.ptr[0].via.u64 != 0+      // Second item is the request id, it must be a positive integer+      || req->via.array.ptr[1].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      // Third item is the API function id, also a positive integer+      || req->via.array.ptr[2].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      // Last item is the function parameters, it must be an array+      || req->via.array.ptr[3].type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Invalid msgpack-rpc request"");+  }++  // dispatch the message+  return msgpack_rpc_dispatch(req, res);+}++void msgpack_rpc_response(msgpack_object *req, msgpack_packer *res)+{+  // Array of size 4+  msgpack_pack_array(res, 4);+  // Response type is 1+  msgpack_pack_int(res, 1);+  // Msgid is the same as the request+  msgpack_pack_int(res, req->via.array.ptr[1].via.u64);+}++void msgpack_rpc_success(msgpack_object *req, msgpack_packer *res)+{+  msgpack_rpc_response(req, res);+  // Nil error+  msgpack_pack_nil(res);+}++bool msgpack_rpc_error(msgpack_object *req, msgpack_packer *res, char *msg)+{+  size_t len = strlen(msg);++  msgpack_rpc_response(req, res);+  msgpack_pack_raw(res, len);+  msgpack_pack_raw_body(res, msg, len);+  // Nil result+  msgpack_pack_nil(res);++  return false;+}++char ** msgpack_rpc_array_argument(msgpack_object *obj)+{+  uint32_t i;+  char **rv = xmalloc(obj->via.array.size);++  for (i = 0; i < obj->via.array.size; i++) {+    rv[i] = msgpack_rpc_raw_argument(obj->via.array.ptr + i);+  }++  rv[i] = NULL;++  return rv;+}++char * msgpack_rpc_raw_argument(msgpack_object *obj)+{+  char *rv = xmalloc(obj->via.raw.size + 1);+  memcpy(rv, obj->via.raw.ptr, obj->via.raw.size);+  rv[obj->via.raw.size] = NUL;++  return rv;+}++uint32_t msgpack_rpc_integer_argument(msgpack_object *obj)+{+  return obj->via.u64;+}++bool msgpack_rpc_array_result(char **result,+                             msgpack_object *req,+                             msgpack_packer *res)+{+  uint32_t array_size = 0;+  char **ptr;++  // Count number of items in the array+  for (ptr = result; *ptr != NULL; ptr++) {+    array_size++;+  }++  msgpack_rpc_success(req, res);+  msgpack_pack_array(res, array_size);++  // push each string to the awway+  for (uint32_t i = 0; i < array_size; i++) {+    uint32_t raw_size = strlen(*ptr);+    msgpack_pack_raw(res, raw_size);+    msgpack_pack_raw_body(res, *ptr, raw_size);+  }++  return true;+}++bool msgpack_rpc_raw_result(char *result,+                             msgpack_object *req,+                             msgpack_packer *res)",Indentation of these parameters is off.,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/509,11518041,2014-04-11T04:51:29Z,src/msgpack_rpc.c,"@@ -0,0 +1,139 @@+#include <msgpack.h>++#include ""msgpack_rpc.h""+#include ""vim.h""+#include ""memory.h""+++bool msgpack_rpc_call(msgpack_object *req, msgpack_packer *res)+{+  // Validate the basic structure of the msgpack-rpc payload+  if (req->type != MSGPACK_OBJECT_ARRAY+      // Must be an array of size 4+      || req->via.array.size != 4+      // First item is the message type, it must be 0 which represents+      // a request+      || req->via.array.ptr[0].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      || req->via.array.ptr[0].via.u64 != 0+      // Second item is the request id, it must be a positive integer+      || req->via.array.ptr[1].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      // Third item is the API function id, also a positive integer+      || req->via.array.ptr[2].type != MSGPACK_OBJECT_POSITIVE_INTEGER+      // Last item is the function parameters, it must be an array+      || req->via.array.ptr[3].type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Invalid msgpack-rpc request"");+  }++  // dispatch the message+  return msgpack_rpc_dispatch(req, res);+}++void msgpack_rpc_response(msgpack_object *req, msgpack_packer *res)+{+  // Array of size 4+  msgpack_pack_array(res, 4);+  // Response type is 1+  msgpack_pack_int(res, 1);+  // Msgid is the same as the request+  msgpack_pack_int(res, req->via.array.ptr[1].via.u64);+}++void msgpack_rpc_success(msgpack_object *req, msgpack_packer *res)+{+  msgpack_rpc_response(req, res);+  // Nil error+  msgpack_pack_nil(res);+}++bool msgpack_rpc_error(msgpack_object *req, msgpack_packer *res, char *msg)+{+  size_t len = strlen(msg);++  msgpack_rpc_response(req, res);+  msgpack_pack_raw(res, len);+  msgpack_pack_raw_body(res, msg, len);+  // Nil result+  msgpack_pack_nil(res);++  return false;+}++char ** msgpack_rpc_array_argument(msgpack_object *obj)+{+  uint32_t i;+  char **rv = xmalloc(obj->via.array.size);++  for (i = 0; i < obj->via.array.size; i++) {+    rv[i] = msgpack_rpc_raw_argument(obj->via.array.ptr + i);+  }++  rv[i] = NULL;++  return rv;+}++char * msgpack_rpc_raw_argument(msgpack_object *obj)+{+  char *rv = xmalloc(obj->via.raw.size + 1);+  memcpy(rv, obj->via.raw.ptr, obj->via.raw.size);+  rv[obj->via.raw.size] = NUL;++  return rv;+}++uint32_t msgpack_rpc_integer_argument(msgpack_object *obj)+{+  return obj->via.u64;+}++bool msgpack_rpc_array_result(char **result,+                             msgpack_object *req,+                             msgpack_packer *res)+{+  uint32_t array_size = 0;+  char **ptr;++  // Count number of items in the array+  for (ptr = result; *ptr != NULL; ptr++) {+    array_size++;+  }++  msgpack_rpc_success(req, res);+  msgpack_pack_array(res, array_size);++  // push each string to the awway+  for (uint32_t i = 0; i < array_size; i++) {+    uint32_t raw_size = strlen(*ptr);+    msgpack_pack_raw(res, raw_size);+    msgpack_pack_raw_body(res, *ptr, raw_size);+  }++  return true;+}++bool msgpack_rpc_raw_result(char *result,+                             msgpack_object *req,+                             msgpack_packer *res)+{+  uint32_t raw_size = strlen(result);+  msgpack_rpc_success(req, res);+  msgpack_pack_raw(res, raw_size);+  msgpack_pack_raw_body(res, result, raw_size);+  return true;+}++bool msgpack_rpc_integer_result(uint32_t result,+                             msgpack_object *req,+                             msgpack_packer *res)",Indentation of these parameters is off.,
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/507,11520768,2014-04-11T06:45:30Z,src/buffer.h,"@@ -69,8 +69,6 @@ int buf_getsigntype(buf_T *buf, linenr_T lnum, int type); linenr_T buf_delsign(buf_T *buf, int id); int buf_findsign(buf_T *buf, int id); int buf_findsign_id(buf_T *buf, linenr_T lnum);-int buf_findsigntype_id(buf_T *buf, linenr_T lnum, int typenr);","@justinmk Can't we rely on git here? All the code this PR deletes is unused at the moment. We can restore this using git, when we need it.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/509,11549707,2014-04-11T20:11:11Z,src/msgpack_rpc.c,"@@ -0,0 +1,156 @@+#include <msgpack.h>++#include ""msgpack_rpc.h""+#include ""vim.h""+#include ""memory.h""+++bool msgpack_rpc_call(msgpack_object *req, msgpack_packer *res)+{+  // Validate the basic structure of the msgpack-rpc payload+  if (req->type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Request is not an array"");+  }++  if (req->via.array.size != 4) {+    char error_msg[256];+    snprintf(error_msg,+             sizeof(error_msg),+             ""Request array size is %u, it should be 4"",+             req->via.array.size);+    return msgpack_rpc_error(req, res, error_msg);+  }++  if (req->via.array.ptr[0].type != MSGPACK_OBJECT_POSITIVE_INTEGER) {+    return msgpack_rpc_error(req, res, ""Message type must be an integer"");+  }++  if (req->via.array.ptr[0].via.u64 != 0) {+    return msgpack_rpc_error(req, res, ""Message type must be 0"");+  }++  if (req->via.array.ptr[1].type != MSGPACK_OBJECT_POSITIVE_INTEGER) {+    return msgpack_rpc_error(req, res, ""Id must be a positive integer"");+  }++  if (req->via.array.ptr[2].type != MSGPACK_OBJECT_POSITIVE_INTEGER) {+    return msgpack_rpc_error(req, res, ""Method id must be a positive integer"");+  }++  if (req->via.array.ptr[3].type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Paremeters must be an array"");+  }++  // dispatch the message+  return msgpack_rpc_dispatch(req, res);+}++void msgpack_rpc_response(msgpack_object *req, msgpack_packer *res)+{+  // Array of size 4+  msgpack_pack_array(res, 4);+  // Response type is 1+  msgpack_pack_int(res, 1);+  // Msgid is the same as the request+  msgpack_pack_int(res, req->via.array.ptr[1].via.u64);+}++void msgpack_rpc_success(msgpack_object *req, msgpack_packer *res)+{+  msgpack_rpc_response(req, res);+  // Nil error+  msgpack_pack_nil(res);+}++bool msgpack_rpc_error(msgpack_object *req, msgpack_packer *res, char *msg)+{+  size_t len = strlen(msg);++  msgpack_rpc_response(req, res);+  msgpack_pack_raw(res, len);+  msgpack_pack_raw_body(res, msg, len);+  // Nil result+  msgpack_pack_nil(res);++  return false;+}++char **msgpack_rpc_array_argument(msgpack_object *obj)+{+  uint32_t i;+  char **rv = xmalloc(obj->via.array.size + 1);++  for (i = 0; i < obj->via.array.size; i++) {+    rv[i] = msgpack_rpc_raw_argument(obj->via.array.ptr + i);+  }++  rv[i] = NULL;++  return rv;+}++char *msgpack_rpc_raw_argument(msgpack_object *obj)+{+  char *rv = xmalloc(obj->via.raw.size + 1);+  memcpy(rv, obj->via.raw.ptr, obj->via.raw.size);+  rv[obj->via.raw.size] = NUL;++  return rv;+}++uint32_t msgpack_rpc_integer_argument(msgpack_object *obj)+{+  return obj->via.u64;+}++bool msgpack_rpc_array_result(char **result,+                              msgpack_object *req,+                              msgpack_packer *res)+{+  char **ptr;+  uint32_t array_size;++  // Count number of items in the array+  for (ptr = result; *ptr != NULL; ptr++) continue;++  msgpack_rpc_success(req, res);+  // Subtract 1 to exclude the NULL slot+  array_size = ptr - result - 1;",Has `result` always at least one element? If not `array_size` would get quite big.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/509,11551021,2014-04-11T20:43:47Z,src/msgpack_rpc.c,"@@ -0,0 +1,156 @@+#include <msgpack.h>++#include ""msgpack_rpc.h""+#include ""vim.h""+#include ""memory.h""+++bool msgpack_rpc_call(msgpack_object *req, msgpack_packer *res)+{+  // Validate the basic structure of the msgpack-rpc payload+  if (req->type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Request is not an array"");+  }++  if (req->via.array.size != 4) {+    char error_msg[256];+    snprintf(error_msg,+             sizeof(error_msg),+             ""Request array size is %u, it should be 4"",+             req->via.array.size);+    return msgpack_rpc_error(req, res, error_msg);+  }++  if (req->via.array.ptr[0].type != MSGPACK_OBJECT_POSITIVE_INTEGER) {+    return msgpack_rpc_error(req, res, ""Message type must be an integer"");+  }++  if (req->via.array.ptr[0].via.u64 != 0) {+    return msgpack_rpc_error(req, res, ""Message type must be 0"");+  }++  if (req->via.array.ptr[1].type != MSGPACK_OBJECT_POSITIVE_INTEGER) {+    return msgpack_rpc_error(req, res, ""Id must be a positive integer"");+  }++  if (req->via.array.ptr[2].type != MSGPACK_OBJECT_POSITIVE_INTEGER) {+    return msgpack_rpc_error(req, res, ""Method id must be a positive integer"");+  }++  if (req->via.array.ptr[3].type != MSGPACK_OBJECT_ARRAY) {+    return msgpack_rpc_error(req, res, ""Paremeters must be an array"");+  }++  // dispatch the message+  return msgpack_rpc_dispatch(req, res);+}++void msgpack_rpc_response(msgpack_object *req, msgpack_packer *res)+{+  // Array of size 4+  msgpack_pack_array(res, 4);+  // Response type is 1+  msgpack_pack_int(res, 1);+  // Msgid is the same as the request+  msgpack_pack_int(res, req->via.array.ptr[1].via.u64);+}++void msgpack_rpc_success(msgpack_object *req, msgpack_packer *res)+{+  msgpack_rpc_response(req, res);+  // Nil error+  msgpack_pack_nil(res);+}++bool msgpack_rpc_error(msgpack_object *req, msgpack_packer *res, char *msg)+{+  size_t len = strlen(msg);++  msgpack_rpc_response(req, res);+  msgpack_pack_raw(res, len);+  msgpack_pack_raw_body(res, msg, len);+  // Nil result+  msgpack_pack_nil(res);++  return false;+}++char **msgpack_rpc_array_argument(msgpack_object *obj)+{+  uint32_t i;+  char **rv = xmalloc(obj->via.array.size + 1);++  for (i = 0; i < obj->via.array.size; i++) {+    rv[i] = msgpack_rpc_raw_argument(obj->via.array.ptr + i);+  }++  rv[i] = NULL;++  return rv;+}++char *msgpack_rpc_raw_argument(msgpack_object *obj)+{+  char *rv = xmalloc(obj->via.raw.size + 1);+  memcpy(rv, obj->via.raw.ptr, obj->via.raw.size);+  rv[obj->via.raw.size] = NUL;++  return rv;+}++uint32_t msgpack_rpc_integer_argument(msgpack_object *obj)+{+  return obj->via.u64;+}++bool msgpack_rpc_array_result(char **result,+                              msgpack_object *req,+                              msgpack_packer *res)+{+  char **ptr;+  uint32_t array_size;++  // Count number of items in the array+  for (ptr = result; *ptr != NULL; ptr++) continue;++  msgpack_rpc_success(req, res);+  // Subtract 1 to exclude the NULL slot+  array_size = ptr - result - 1;",I'm currently changing the C types mapped to the msgpack types:``` ctypedef struct {  char *data;  size_t len;} String;struct string_sequence {  String *items;  size_t len;};typedef string_sequence Array;typedef string_sequence Dictionary;```For now these will be enough for our needs and will also fix this problem,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/539,11638789,2014-04-15T15:10:00Z,src/os/rstream.c,"@@ -0,0 +1,129 @@+#include <stdint.h>+#include <stdbool.h>+#include <stdlib.h>++#include <uv.h>++#include ""os/rstream_defs.h""+#include ""os/rstream.h""+#include ""vim.h""+#include ""memory.h""++struct rstream {+  void *data;+  char *buffer;+  uv_stream_t *stream;+  rstream_cb cb;+  uint32_t buffer_size, rpos, wpos;+  bool reading;+};++// Callbacks used by libuv+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);++RStream * rstream_new(uv_stream_t *stream,+                      rstream_cb cb,+                      uint32_t buffer_size,+                      void *data)+{+  RStream *rv = xmalloc(sizeof(RStream));+  rv->buffer = xmalloc(buffer_size);+  rv->buffer_size = buffer_size;+  rv->data = data;+  rv->cb = cb;+  rstream_switch(rv, stream);+  rstream_resume(rv);++  return rv;+}++void rstream_free(RStream *rstream)+{+  free(rstream->buffer);+  free(rstream);+}++void rstream_switch(RStream *rstream, uv_stream_t *stream)+{+  rstream->data = stream;+}++void rstream_resume(RStream *rstream)+{+  uv_read_start(rstream->stream, alloc_cb, read_cb);+}++void rstream_pause(RStream *rstream)+{+  uv_read_stop(rstream->stream);+}++uint32_t rstream_read(RStream *rstream, char *buf, uint32_t count)+{+  uint32_t read_count = rstream->wpos - rstream->rpos;++  if (count < read_count) {+    read_count = count;+  }++  if (read_count > 0) {+    memcpy(buf, rstream->buffer + rstream->rpos, read_count);+    rstream->rpos += read_count;+  }++  if (rstream->wpos == rstream->buffer_size) {+    // `wpos` is at the end of the buffer, so free some space by moving unread+    // data...+    memmove(+        rstream->buffer,  // ...To the beginning of the buffer(rpos 0)+        rstream->buffer + rstream->rpos, // ...From the first unread position+        rstream->wpos - rstream->rpos);  // ...By the number of unread bytes+    rstream->wpos -= rstream->rpos;+    rstream->rpos = 0;+  }++  return read_count;+}++// Called by libuv to allocate memory for reading.+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  RStream *rstream = handle->data;++  if (rstream->reading) {+    buf->len = 0;+    return;+  }++  buf->base = rstream->buffer + rstream->wpos;+  buf->len = rstream->buffer_size - rstream->wpos;+  // Avoid `alloc_cb`, `alloc_cb` sequences on windows+  rstream->reading = true;+}++// Callback invoked by libuv after it copies the data into the buffer provided+// by `alloc_cb`. This is also called on EOF or when `alloc_cb` returns a+// 0-length buffer.+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{+  RStream *rstream = stream->data;++  if (cnt <= 0) {+    if (cnt != UV_ENOBUFS) {+      // Read error or EOF, either way stop the stream and invoke the callback+      // with eof == true+      uv_read_stop(stream);+      rstream->cb(rstream, rstream->wpos - rstream->rpos, rstream->data, true);","the callback gets `rstream` as the first parameter, so why provide `rstream->data` as another parameter?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/539,11640626,2014-04-15T15:40:38Z,src/os/rstream.c,"@@ -0,0 +1,129 @@+#include <stdint.h>+#include <stdbool.h>+#include <stdlib.h>++#include <uv.h>++#include ""os/rstream_defs.h""+#include ""os/rstream.h""+#include ""vim.h""+#include ""memory.h""++struct rstream {+  void *data;+  char *buffer;+  uv_stream_t *stream;+  rstream_cb cb;+  uint32_t buffer_size, rpos, wpos;+  bool reading;+};++// Callbacks used by libuv+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);++RStream * rstream_new(uv_stream_t *stream,+                      rstream_cb cb,+                      uint32_t buffer_size,+                      void *data)+{+  RStream *rv = xmalloc(sizeof(RStream));+  rv->buffer = xmalloc(buffer_size);+  rv->buffer_size = buffer_size;+  rv->data = data;+  rv->cb = cb;+  rstream_switch(rv, stream);+  rstream_resume(rv);++  return rv;+}++void rstream_free(RStream *rstream)+{+  free(rstream->buffer);+  free(rstream);+}++void rstream_switch(RStream *rstream, uv_stream_t *stream)+{+  rstream->data = stream;+}++void rstream_resume(RStream *rstream)+{+  uv_read_start(rstream->stream, alloc_cb, read_cb);+}++void rstream_pause(RStream *rstream)+{+  uv_read_stop(rstream->stream);+}++uint32_t rstream_read(RStream *rstream, char *buf, uint32_t count)+{+  uint32_t read_count = rstream->wpos - rstream->rpos;++  if (count < read_count) {+    read_count = count;+  }++  if (read_count > 0) {+    memcpy(buf, rstream->buffer + rstream->rpos, read_count);+    rstream->rpos += read_count;+  }++  if (rstream->wpos == rstream->buffer_size) {+    // `wpos` is at the end of the buffer, so free some space by moving unread+    // data...+    memmove(+        rstream->buffer,  // ...To the beginning of the buffer(rpos 0)+        rstream->buffer + rstream->rpos, // ...From the first unread position+        rstream->wpos - rstream->rpos);  // ...By the number of unread bytes+    rstream->wpos -= rstream->rpos;+    rstream->rpos = 0;+  }++  return read_count;+}++// Called by libuv to allocate memory for reading.+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  RStream *rstream = handle->data;++  if (rstream->reading) {+    buf->len = 0;+    return;+  }++  buf->base = rstream->buffer + rstream->wpos;+  buf->len = rstream->buffer_size - rstream->wpos;+  // Avoid `alloc_cb`, `alloc_cb` sequences on windows+  rstream->reading = true;+}++// Callback invoked by libuv after it copies the data into the buffer provided+// by `alloc_cb`. This is also called on EOF or when `alloc_cb` returns a+// 0-length buffer.+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{+  RStream *rstream = stream->data;++  if (cnt <= 0) {+    if (cnt != UV_ENOBUFS) {","I'm not sure if it's possible to get this error. `EAGAIN` should only happen when a normal read would block due to no data being available in the OS buffer, but the fact that the callback was called means data is available for reading. @saghul what do you think?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/539,11640820,2014-04-15T15:44:30Z,src/os/rstream.c,"@@ -0,0 +1,129 @@+#include <stdint.h>+#include <stdbool.h>+#include <stdlib.h>++#include <uv.h>++#include ""os/rstream_defs.h""+#include ""os/rstream.h""+#include ""vim.h""+#include ""memory.h""++struct rstream {+  void *data;+  char *buffer;+  uv_stream_t *stream;+  rstream_cb cb;+  uint32_t buffer_size, rpos, wpos;+  bool reading;+};++// Callbacks used by libuv+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);++RStream * rstream_new(uv_stream_t *stream,+                      rstream_cb cb,+                      uint32_t buffer_size,+                      void *data)+{+  RStream *rv = xmalloc(sizeof(RStream));+  rv->buffer = xmalloc(buffer_size);+  rv->buffer_size = buffer_size;+  rv->data = data;+  rv->cb = cb;+  rstream_switch(rv, stream);+  rstream_resume(rv);++  return rv;+}++void rstream_free(RStream *rstream)+{+  free(rstream->buffer);+  free(rstream);+}++void rstream_switch(RStream *rstream, uv_stream_t *stream)+{+  rstream->data = stream;+}++void rstream_resume(RStream *rstream)+{+  uv_read_start(rstream->stream, alloc_cb, read_cb);+}++void rstream_pause(RStream *rstream)+{+  uv_read_stop(rstream->stream);+}++uint32_t rstream_read(RStream *rstream, char *buf, uint32_t count)+{+  uint32_t read_count = rstream->wpos - rstream->rpos;++  if (count < read_count) {+    read_count = count;+  }++  if (read_count > 0) {+    memcpy(buf, rstream->buffer + rstream->rpos, read_count);+    rstream->rpos += read_count;+  }++  if (rstream->wpos == rstream->buffer_size) {+    // `wpos` is at the end of the buffer, so free some space by moving unread+    // data...+    memmove(+        rstream->buffer,  // ...To the beginning of the buffer(rpos 0)+        rstream->buffer + rstream->rpos, // ...From the first unread position+        rstream->wpos - rstream->rpos);  // ...By the number of unread bytes+    rstream->wpos -= rstream->rpos;+    rstream->rpos = 0;+  }++  return read_count;+}++// Called by libuv to allocate memory for reading.+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  RStream *rstream = handle->data;++  if (rstream->reading) {+    buf->len = 0;+    return;+  }++  buf->base = rstream->buffer + rstream->wpos;+  buf->len = rstream->buffer_size - rstream->wpos;+  // Avoid `alloc_cb`, `alloc_cb` sequences on windows+  rstream->reading = true;+}++// Callback invoked by libuv after it copies the data into the buffer provided+// by `alloc_cb`. This is also called on EOF or when `alloc_cb` returns a+// 0-length buffer.+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{+  RStream *rstream = stream->data;++  if (cnt <= 0) {+    if (cnt != UV_ENOBUFS) {+      // Read error or EOF, either way stop the stream and invoke the callback+      // with eof == true+      uv_read_stop(stream);+      rstream->cb(rstream, rstream->wpos - rstream->rpos, rstream->data, true);","Because of [encapsulation](http://en.wikipedia.org/wiki/Encapsulation_%28object-oriented_programming%29), the rstream fields are hidden from consumers. I'm not sure we should use this OO pattern though, it's just something I'm used to do, a way to make it explicit we don't expect consumers to access the fields directly.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/539,11646267,2014-04-15T17:28:15Z,src/os/rstream.c,"@@ -0,0 +1,129 @@+#include <stdint.h>+#include <stdbool.h>+#include <stdlib.h>++#include <uv.h>++#include ""os/rstream_defs.h""+#include ""os/rstream.h""+#include ""vim.h""+#include ""memory.h""++struct rstream {+  void *data;+  char *buffer;+  uv_stream_t *stream;+  rstream_cb cb;+  uint32_t buffer_size, rpos, wpos;+  bool reading;+};++// Callbacks used by libuv+static void alloc_cb(uv_handle_t *, size_t, uv_buf_t *);+static void read_cb(uv_stream_t *, ssize_t, const uv_buf_t *);++RStream * rstream_new(uv_stream_t *stream,+                      rstream_cb cb,+                      uint32_t buffer_size,+                      void *data)+{+  RStream *rv = xmalloc(sizeof(RStream));+  rv->buffer = xmalloc(buffer_size);+  rv->buffer_size = buffer_size;+  rv->data = data;+  rv->cb = cb;+  rstream_switch(rv, stream);+  rstream_resume(rv);++  return rv;+}++void rstream_free(RStream *rstream)+{+  free(rstream->buffer);+  free(rstream);+}++void rstream_switch(RStream *rstream, uv_stream_t *stream)+{+  rstream->data = stream;+}++void rstream_resume(RStream *rstream)+{+  uv_read_start(rstream->stream, alloc_cb, read_cb);+}++void rstream_pause(RStream *rstream)+{+  uv_read_stop(rstream->stream);+}++uint32_t rstream_read(RStream *rstream, char *buf, uint32_t count)+{+  uint32_t read_count = rstream->wpos - rstream->rpos;++  if (count < read_count) {+    read_count = count;+  }++  if (read_count > 0) {+    memcpy(buf, rstream->buffer + rstream->rpos, read_count);+    rstream->rpos += read_count;+  }++  if (rstream->wpos == rstream->buffer_size) {+    // `wpos` is at the end of the buffer, so free some space by moving unread+    // data...+    memmove(+        rstream->buffer,  // ...To the beginning of the buffer(rpos 0)+        rstream->buffer + rstream->rpos, // ...From the first unread position+        rstream->wpos - rstream->rpos);  // ...By the number of unread bytes+    rstream->wpos -= rstream->rpos;+    rstream->rpos = 0;+  }++  return read_count;+}++// Called by libuv to allocate memory for reading.+static void alloc_cb(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  RStream *rstream = handle->data;++  if (rstream->reading) {+    buf->len = 0;+    return;+  }++  buf->base = rstream->buffer + rstream->wpos;+  buf->len = rstream->buffer_size - rstream->wpos;+  // Avoid `alloc_cb`, `alloc_cb` sequences on windows+  rstream->reading = true;+}++// Callback invoked by libuv after it copies the data into the buffer provided+// by `alloc_cb`. This is also called on EOF or when `alloc_cb` returns a+// 0-length buffer.+static void read_cb(uv_stream_t *stream, ssize_t cnt, const uv_buf_t *buf)+{+  RStream *rstream = stream->data;++  if (cnt <= 0) {+    if (cnt != UV_ENOBUFS) {+      // Read error or EOF, either way stop the stream and invoke the callback+      // with eof == true+      uv_read_stop(stream);+      rstream->cb(rstream, rstream->wpos - rstream->rpos, rstream->data, true);",@justinmk @tarruda I think it makes sense to have the extra parameter for callback code clarity. Client code author doesn't have to look at `rstream` definition and doesn't have to double check if it's OK to write from the beginning of `rstream->data`.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/556,11744844,2014-04-17T17:58:54Z,src/os/job.c,"@@ -266,38 +292,43 @@ static void job_prepare_cb(uv_prepare_t *handle)   } } -/// Pushes a event object to the event queue, which will be handled later by-/// `job_handle`+static void write_cb(uv_write_t *req, int status)+{+  free(req->data);+  free(req);+}++// Wraps the call to std{out,err}_cb and emits a JobExit event if necessary. static void read_cb(RStream *rstream, void *data, bool eof) {-  Event event;   Job *job = data; -  if (eof) {-    uv_process_kill(&job->proc, SIGTERM);-    return;+  if (rstream == job->out) {+    job->stdout_cb(rstream, data, eof);+  } else {+    job->stderr_cb(rstream, data, eof);   } -  event.type = kEventJobActivity;-  event.data.job.ptr = job;-  event.data.job.target = rstream;-  event.data.job.from_stdout = rstream == job->out;-  event_push(event);-}--static void write_cb(uv_write_t *req, int status)-{-  free(req->data);-  free(req);+  if (eof && --job->pending_refs == 0) {+    emit_exit_event(job);+  } } -/// Cleanup all the resources associated with the job+// Emits a JobExit event if both rstreams are closed static void exit_cb(uv_process_t *proc, int64_t status, int term_signal) {   Job *job = proc->data; -  table[job->id - 1] = NULL;-  shell_free_argv(job->proc_opts.args);-  free_job(job);+  if (--job->pending_refs == 0) {","Even if the process doesn't write anything, I think it's guaranteed that libuv will call our `read_cb` with the status/count parameter set to some error code, which will be considered `EOF` unless it is `UV_ENOBUFS`. I'm not 100% sure about this, but @saghul can probably confirm.",
3405586,schmee,https://api.github.com/repos/neovim/neovim/pulls/526,11757518,2014-04-17T22:31:53Z,test/unit/path.moon,"@@ -102,6 +103,31 @@ describe 'path function', ->     it 'returns empty string if given file contains no seperator', ->       eq '', path_next_component 'file.txt' +  describe 'shorten_fname', ->+    shorten_fname = (full_path, dir_name) ->+      res = path.shorten_fname (to_cstr full_path), (to_cstr dir_name)+      ffi.string res++    it 'returns NULL if `full_path` is NULL', ->+      dir = to_cstr 'some/directory/file.txt'+      eq NULL, path.shorten_fname NULL, dir++    it 'shortens the filename if `dir_name` is the start of `full_path`', ->+      dir = 'some/very/long'+      full = 'some/very/long/directory/file.txt'+      eq 'directory/file.txt', shorten_fname full, dir","This should be alright. Quoting the moonscript [documentation](http://moonscript.org/reference/#function_literals):> When chaining together function calls, the arguments are applied to the closest function to the left.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/558,11762494,2014-04-18T02:44:34Z,src/ops.c,"@@ -3465,9 +3464,9 @@ int do_join(long count, int insert_space, int save_undo, int use_formatoptions)   /* Allocate an array to store the number of spaces inserted before each    * line.  We will use it to pre-compute the length of the new line and the    * proper placement of each original line in the new one. */-  spaces = lalloc_clear((long_u)count, TRUE);+  spaces = xcalloc(1, (size_t)count);",Swap arguments here. You're allocating `count` 1 byte sized blocks of memory. That's the `calloc` pattern.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/556,11765796,2014-04-18T07:31:44Z,src/os/wstream.h,"@@ -0,0 +1,39 @@+#ifndef NEOVIM_OS_WSTREAM_H+#define NEOVIM_OS_WSTREAM_H++#include <stdint.h>+#include <stdbool.h>+#include <uv.h>++#include ""os/wstream_defs.h""++/// Creates a new WStream instance. A WStream encapsulates all the boilerplate+/// necessary for writing to a libuv stream.+///+/// @param maxmem Maximum amount memory used by this `WStream` instance. After+///        this limit is crossed, calls to `wstream_write` will fail.","We never cross this limit. As long as the `WStream`-instance is not freed, only calls to `wstream_write` will fail that _would_ cross this limit.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/558,11767481,2014-04-18T09:14:43Z,src/ops.c,"@@ -2415,8 +2415,7 @@ int op_yank(oparg_T *oap, int deleting, int mess)   y_current->y_size = yanklines;   y_current->y_type = yanktype;     /* set the yank register type */   y_current->y_width = 0;-  y_current->y_array = (char_u **)lalloc_clear((long_u)(sizeof(char_u *) *-                                                        yanklines), TRUE);+  y_current->y_array = xcalloc(1, sizeof(char_u *) * yanklines);","@schmee it is indeed a good thing to specify the variable if possible instead of the type. The C compiler will automatically fill in the size of the type that the variable has. This is very good for maintainability and prevents bugs: changing the type of the variable will adjust all allocations of it as well.There is, however, something you have to be really careful about: the difference between arrays and pointers. Even though one usually ""handles"" arrays and pointers in the same way, they react differently to `sizeof`:``` c/** * cc -Wall -pedantic sizeof.c -o sizeof */#include <stdio.h>#include <string.h>#include <inttypes.h>#define NELEMS(x)  (sizeof(x) / sizeof(x[0]))int main() {    int arr[64];    int *parr;    printf(""sizeof(int) = %zu\n"", sizeof(int));    printf(""sizeof(uint32_t) = %zu\n"", sizeof(uint32_t));    printf(""sizeof(size_t) = %zu\n"", sizeof(size_t));    printf(""sizeof(arr[64]) = %zu (NELEMS = %zu)\n"", sizeof(arr), NELEMS(arr));    printf(""sizeof(int *) = %zu\n"", sizeof(parr));    return 0;}```output:```sizeof(int) = 4sizeof(uint32_t) = 4sizeof(size_t) = 8sizeof(arr[64]) = 256 (NELEMS = 64)sizeof(int *) = 8```The `NELEMS` macro relies on this behaviour. This is possible because the compiler is guaranteed to know the size of the array at compile time. So pay attention to that.On a separate note, there is a slightly safer alternative to the `NELEMS` macro that we perhaps should consider: https://groups.google.com/forum/#!topic/comp.std.c/IsJaXEhtgIQ",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/558,11768940,2014-04-18T10:52:48Z,src/ops.c,"@@ -2415,8 +2415,7 @@ int op_yank(oparg_T *oap, int deleting, int mess)   y_current->y_size = yanklines;   y_current->y_type = yanktype;     /* set the yank register type */   y_current->y_width = 0;-  y_current->y_array = (char_u **)lalloc_clear((long_u)(sizeof(char_u *) *-                                                        yanklines), TRUE);+  y_current->y_array = xcalloc(1, sizeof(char_u *) * yanklines);","No problem. A pointer to any data element always has the same size. So a pointer to an `int` (i.e.: `int *`) has the same size as a pointer to a `char` (i.e.: `char *`) or even a pointer to a `pointer to a char` (i.e.: `char **`). On 99% of all architectures a pointer to **anything** will have the same size (it is technically possible for an architecture to make a difference between a pointer to data and a pointer to a function). While there's many reasons why a pointer to a pointer makes heads spin (try triple pointers, ugh), the size should be pretty straightforward :).But, it always helps to think about what we are allocating here. `ycurrent->yarray` is an array of strings. Strings in C are usually char arrays or pointers to char. So that makes it an array of (an array of chars). The amount of strings in the in the array is `yanklines`, and the size of each element is `sizeof(char_u *)`. To put it in another way:``` c/* pseudo-code and execution, haven't checked *//* to allocate a pointer to the array, we would do: */sizeof(y_current->y_array) == sizeof(char_u **) /* == 8 (on most 64-bits systems) *//* to allocate the array itself, we would do: */sizeof(y_current->y_array[0]) == sizeof(*(y_current->y_array[0])) == sizeof(char_u *) /* ==  8 (on most 64-bits systems) */```From this it's clear that semantically, we'd need to substitute the second line. As we are allocating `yanklines` elements in the array `char **y_array`, and each element has `sizeof(char_u *)`.You might wonder: how is something like `sizeof(y_current->y_array[0])` or equivalently `sizeof(*(y_current->y_array[0]))` even possible? We haven't even allocated yet, this should cause a NULL pointer error in the best case!But that's the peculiar behaviour of the `sizeof` operator, it doesn't evaluate its parameter. The compiler just calculates what the size of the resulting value would be, if it _were_ evaluated.Now, this kind of thing can be pretty confusing, even for old-timers reading the code. I myself find that in this case, it's clearer to just use `sizeof(char_u *)`. Moral of the story: be judicious, if the variable is simple, use `sizeof(variable)`, if the variable is complex, use `sizeof(the_actual_type)`. This is a case of the latter.So the actual line should become:``` c/* void *xcalloc(size_t num, size_t size); */y_current->y_array = xcalloc(yanklines, sizeof(char_u *));```Nice and simple :).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/556,11769939,2014-04-18T11:57:50Z,src/os/wstream.c,"@@ -0,0 +1,115 @@+#include <stdint.h>+#include <stdbool.h>++#include <uv.h>++#include ""os/wstream.h""+#include ""os/wstream_defs.h""+#include ""vim.h""+#include ""memory.h""++struct wstream {+  void *data;",`data` is not used.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/475,11774468,2014-04-18T15:06:38Z,src/eval.c,"@@ -11001,6 +11015,143 @@ static void f_items(typval_T *argvars, typval_T *rettv)   dict_list(argvars, rettv, 2); } +// ""jobstart()"" function+static void f_job_start(typval_T *argvars, typval_T *rettv)+{+  list_T *args = NULL;+  listitem_T *arg;+  int i, argvl, argsl;+  char **argv = NULL;++  rettv->v_type = VAR_NUMBER;+  rettv->vval.v_number = 0;++  if (check_restricted() || check_secure()) {+    goto cleanup;+  }++  if (argvars[0].v_type != VAR_STRING+      || argvars[1].v_type != VAR_STRING+      || (argvars[2].v_type != VAR_LIST+      && argvars[2].v_type != VAR_UNKNOWN)) {+    // Wrong argument types+    EMSG(_(e_invarg));+    goto cleanup;+  }++  argsl = 0;+  if (argvars[2].v_type == VAR_LIST) {+    args = argvars[2].vval.v_list;+    argsl = args->lv_len;+    // Assert that all list items are strings+    for (arg = args->lv_first; arg != NULL; arg = arg->li_next) {+      if (arg->li_tv.v_type != VAR_STRING) {+        EMSG(_(e_invarg));+        goto cleanup;+      }+    }+  }++  if (!os_can_exe(get_tv_string(&argvars[1]))) {+    // String is not executable+    EMSG2(e_jobexe, get_tv_string(&argvars[1]));+    goto cleanup;+  }++  // Allocate extra memory for the argument vector and the NULL pointer+  argvl = argsl + 2;+  argv = xmalloc(sizeof(char_u *) * argvl);++  // Copy program name+  argv[0] = xstrdup((char *)argvars[1].vval.v_string);++  i = 1;+  // Copy arguments to the vector+  if (argsl > 0) {+    for (arg = args->lv_first; arg != NULL; arg = arg->li_next) {+      argv[i++] = xstrdup((char *)arg->li_tv.vval.v_string);+    }+  }++  // The last item of argv must be NULL+  argv[i] = NULL;++  rettv->vval.v_number = job_start(argv,+                                   xstrdup((char *)argvars[0].vval.v_string),+                                   apply_job_autocmds);++  if (rettv->vval.v_number <= 0) {+    if (rettv->vval.v_number == 0) {+      EMSG(_(e_jobtblfull));+    } else {+      EMSG(_(e_jobexe));+    }+  }++cleanup:+  if (rettv->vval.v_number > 0) {+    // Success+    return;+  }+  // Cleanup argv memory in case the `job_start` call failed+  shell_free_argv(argv);","You are right, the label is useless. I will push the fix to #556",
3405586,schmee,https://api.github.com/repos/neovim/neovim/pulls/571,11799392,2014-04-20T20:59:44Z,src/eval.c,"@@ -7164,7 +7164,7 @@ find_internal_func (    * Find the function name in the table. Binary search.    */   while (first <= last) {-    x = first + ((unsigned)(last - first) >> 1);",General question: I did a quick search a while ago and found around 15 separate implementations of binary search. Would it be possible to use `bsearch` from the standard library instead of all these duplications?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/571,11827487,2014-04-21T21:35:57Z,src/eval.c,"@@ -7164,7 +7164,7 @@ find_internal_func (    * Find the function name in the table. Binary search.    */   while (first <= last) {-    x = first + ((unsigned)(last - first) >> 1);","@schmee Good question, open a ticket? Here's my notes:- bsearch appears to be standard even in C89, so Vim must have a reason to avoid it. - MSVC includes bsearch: `C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\crt\src\bsearch.c`- this article (worth reading) claims that the function pointer is expensive: http://www.longacre-scm.com/blog/index.php/2010/10/crossing-over- maybe the 15 implementations you found could be replaced by macros. Here's one by our very own @aktau : https://gist.github.com/aktau/8225628",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/592,11868664,2014-04-22T18:36:00Z,src/buffer.c,"@@ -403,9 +404,8 @@ close_buffer (     win->w_buffer = NULL;      /* make sure we don't use the buffer now */    /* Autocommands may have deleted the buffer. */-  if (!buf_valid(buf))-    return;-  if (aborting())           /* autocmds may abort script processing */+  /* autocmds may abort script processing */+  if (!buf_valid(buf) || aborting())","the comments before lived next to their conditions, now we saved one line and lost some clarity. Unnecessary churn.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/592,11869308,2014-04-22T18:47:27Z,src/buffer.c,"@@ -339,41 +334,47 @@ close_buffer (         win->w_cursor.col, TRUE);   } +#define __emsg_and_return_on(x) do {  \+      if ((x)) {                      \+        EMSG(_(e_auabort));           \+        return;                       \+      }                               \+    } while (0)+   /* When the buffer is no longer in a window, trigger BufWinLeave */   if (buf->b_nwindows == 1) {     buf->b_closing = TRUE;-    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,-        FALSE, buf);-    if (!buf_valid(buf)) {-      /* Autocommands deleted the buffer. */-aucmd_abort:-      EMSG(_(e_auabort));-      return;-    }+    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname, FALSE, buf);++    /* If autocommands deleted the buffer */+    __emsg_and_return_on(!buf_valid(buf));","I kind of like this, but if this sort of macro is worth including, it should be more generalized, rather than defined for a block of 50 lines and then undefined. But I am not sure this pattern is really worth using. It increases the cognitive burden to save one line, and makes the control flow less explicit: the `return` is now hidden in a macro. Will also prevent navigating the control flow with Vim's `%` motion.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/592,11884318,2014-04-23T01:51:29Z,src/buffer.c,"@@ -84,6 +84,9 @@ static int append_arg_number(win_T *wp, char_u *buf, int buflen, int add_file); static void free_buffer(buf_T *); static void free_buffer_stuff(buf_T *buf, int free_options); static void clear_wininfo(buf_T *buf);+static void decide_bufferaction(char, int*, int*, int*);","Given the number of parameter and how hard is to come with a good name for this function, I think we're better off inlining it back.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/592,11884394,2014-04-23T01:56:26Z,src/buffer.c,"@@ -339,41 +334,47 @@ close_buffer (         win->w_cursor.col, TRUE);   } +#define __emsg_and_return_on(x) do {  \+      if ((x)) {                      \+        EMSG(_(e_auabort));           \+        return;                       \+      }                               \+    } while (0)+   /* When the buffer is no longer in a window, trigger BufWinLeave */   if (buf->b_nwindows == 1) {     buf->b_closing = TRUE;-    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,-        FALSE, buf);-    if (!buf_valid(buf)) {-      /* Autocommands deleted the buffer. */-aucmd_abort:-      EMSG(_(e_auabort));-      return;-    }+    apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname, FALSE, buf);++    /* If autocommands deleted the buffer */+    __emsg_and_return_on(!buf_valid(buf));","The `goto` version was better. C doesn't have exceptions, using `goto` to handle errors is not only common but advised. It's a good way to guarantee that all allocated memory will be freed no matter what.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/592,11933721,2014-04-24T02:24:44Z,src/buffer.c,"@@ -601,6 +568,64 @@ static void clear_wininfo(buf_T *buf)   } } +static void+decide_bufferaction(char act, int *wipe, int *del, int *unload)+{+  switch (act)+  {+  case 'w': /* 'bufhidden' == ""wipe"" */+    *wipe = TRUE;+    /* fallthrough */++  case 'd': /* 'bufhidden' == ""delete"" */+    *del = TRUE;+    /* fallthrough */++  case 'u': /* 'bufhidden' == ""unload"" */+    *unload = TRUE;+    /* fallthrough */++  }++}++/*+ * Remove the buffer from the list.+ */+static void+wipe_or_delete_buffer(int wipe_buf, int del_buf, buf_T *buf, buf_T *firstbuf,",`firstbuf` and `lastbuf` are globals. You can delete these parameters.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/592,11933799,2014-04-24T02:31:11Z,src/buffer.c,"@@ -317,15 +320,7 @@ close_buffer (    * The caller must take care of NOT deleting/freeing when 'bufhidden' is    * ""hide"" (otherwise we could never free or delete a buffer).    */-  if (buf->b_p_bh[0] == 'd') {          /* 'bufhidden' == ""delete"" */-    del_buf = TRUE;-    unload_buf = TRUE;-  } else if (buf->b_p_bh[0] == 'w') { /* 'bufhidden' == ""wipe"" */-    del_buf = TRUE;-    unload_buf = TRUE;-    wipe_buf = TRUE;-  } else if (buf->b_p_bh[0] == 'u')     /* 'bufhidden' == ""unload"" */-    unload_buf = TRUE;+  decide_bufferaction(buf->b_p_bh[0], &wipe_buf, &del_bug, &unload_buf);",`decide_bufferaction` is not a descriptive name and it takes way too many parameters. Inline the code back. Using a `switch` was already an improvement.,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/592,11935994,2014-04-24T05:18:17Z,src/buffer.c,"@@ -601,6 +568,64 @@ static void clear_wininfo(buf_T *buf)   } } +static void+decide_bufferaction(char act, int *wipe, int *del, int *unload)+{+  switch (act)+  {+  case 'w': /* 'bufhidden' == ""wipe"" */+    *wipe = TRUE;+    /* fallthrough */++  case 'd': /* 'bufhidden' == ""delete"" */+    *del = TRUE;+    /* fallthrough */",@philix thanks. My bad.,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/604,11936301,2014-04-24T05:40:07Z,src/ascii.h,"@@ -85,9 +85,6 @@  /*  * Character that separates dir names in a path.- * For MS-DOS, WIN32 and OS/2 we use a backslash.  A slash mostly works",I removed it because I don't think it's a good comment. Clearly the dir separator varies; that's why the macro exists. So why duplicate the knowledge of which system uses a backslash in the comment here?,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/604,11936859,2014-04-24T06:18:13Z,src/ascii.h,"@@ -85,9 +85,6 @@  /*  * Character that separates dir names in a path.- * For MS-DOS, WIN32 and OS/2 we use a backslash.  A slash mostly works","You're right. :+1:On Apr 24, 2014 2:40 AM, ""Chris"" notifications@github.com wrote:> In src/ascii.h:> > > @@ -85,9 +85,6 @@> > > >  /*> > - Character that separates dir names in a path.> >   - \* For MS-DOS, WIN32 and OS/2 we use a backslash.  A slash mostly works> > I removed it because I don't think it's a good comment. Clearly the dir> separator varies; that's why the macro exists. So why duplicate the> knowledge of which system uses a backslash in the comment here?> > ���> Reply to this email directly or view it on GitHubhttps://github.com/neovim/neovim/pull/604/files#r11936301> .",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/592,11951460,2014-04-24T14:31:25Z,src/buffer.c,"@@ -601,6 +568,64 @@ static void clear_wininfo(buf_T *buf)   } } +static void+decide_bufferaction(char act, int *wipe, int *del, int *unload)+{+  switch (act)+  {+  case 'w': /* 'bufhidden' == ""wipe"" */+    *wipe = TRUE;+    /* fallthrough */++  case 'd': /* 'bufhidden' == ""delete"" */+    *del = TRUE;+    /* fallthrough */++  case 'u': /* 'bufhidden' == ""unload"" */+    *unload = TRUE;+    /* fallthrough */++  }++}++/*+ * Remove the buffer from the list.+ */+static void+wipe_or_delete_buffer(int wipe_buf, int del_buf, buf_T *buf, buf_T *firstbuf,+        buf_T *lastbuf)+{+  if (wipe_buf) {","You can do``` cif (wipe_buf) {  wipe_buf(buf);} else if (del_buf) {  delete_buffer(buf);  // <---- this should include a call tobuf_clear_file(buf)} else {  buf_clear_file(buf);}```On Thu, Apr 24, 2014 at 4:29 AM, Matthias Beyer notifications@github.comwrote:> In src/buffer.c:> > > -  case 'u': /\* 'bufhidden' == ""unload"" */> > -    *unload = TRUE;> > -    /\* fallthrough */> >   +> > -  }> >   +> >   +}> >   +> >   +/*> > - \* Remove the buffer from the list.> > - */> >   +static void> >   +wipe_or_delete_buffer(int wipe_buf, int del_buf, buf_T *buf, buf_T *firstbuf,> > -        buf_T *lastbuf)> >   +{> > -  if (wipe_buf) {> > But if I'd move the if-else back to the called, the caller would contain> partitial code from the if-else construct, as we do> > if (wipe_buf) {>   /// code> } else {>   if (del_buf) {>     /// code>   }>   /// something else>   if (del_buf) /// more> }> > Moving this to the caller would result in something like> > if (wipe_buf)>   wipe_buf(buf);> else {>   if (del_buf)>     del_buf(buf);>   // something>   if (del_buf)>     // something more> }> > which isn't really clean either!> > ���> Reply to this email directly or view it on GitHubhttps://github.com/neovim/neovim/pull/592/files#r11938178> .",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/574,11988040,2014-04-25T09:02:27Z,src/fold.c,"@@ -2957,8 +2957,9 @@ static int put_folds_recurse(FILE *fd, garray_T *gap, linenr_T off)     /* Do nested folds first, they will be created closed. */     if (put_folds_recurse(fd, &fp->fd_nested, off + fp->fd_top) == FAIL)       return FAIL;-    if (fprintf(fd, ""%ld,%ldfold"", fp->fd_top + off,-            fp->fd_top + off + fp->fd_len - 1) < 0+    if (fprintf(fd, ""%"" PRId64 "",%"" PRId64 ""fold"",+                (int64_t)fp->fd_top + off,+                (int64_t)fp->fd_top + off + fp->fd_len - 1) < 0","In general, you  would be right and those expressions wouldn't be equivalent.But, to my understanding, in the context they occur, they should always yield the same result.Note that:- All involved quantities are of type `linenr_T`, which in turn is `long`. Thus, problems that arise when mixing signed/unsigned types shouldn't occur. And, as `int64_t` is guaranteed to be not smaller than long, then those two expressions should be equivalent.- Even if you redefined `linenr_T` to an unsigned type (which you wouldn't do without careful examination of all its appearances), you would get at least an error on that line (cause expression result would be unsigned and wouldn't match expression format).Ok, but why bother this all? Why not just enclosing it in parentheses, and rest assured?- To be honest, the truth is that I did this in a semi-automated way, and the way it's done was simpler to automate.- In any case, all those horrible castings are there just temporarily, as they are meant to be dropped again when variable types are refactored.So, I hope I have convinced you that those changes are safe.In any case, I do agree that they can be confusing, and that type refactoring may take some time. So, I now regret having left it that way.I will fix it. For my peace of mind and others'Thanks for daring to review such boring-looking changes.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/587,12024215,2014-04-26T12:21:42Z,src/undo.c,"@@ -1509,8 +1509,7 @@ void u_read_undo(char_u *name, char_u *hash, char_u *orig_name)   }  #ifdef U_DEBUG-  uhp_table_used = (int *)alloc_clear(-      (unsigned)(sizeof(int) * num_head + 1));+  uhp_table_used = xcalloc(num_head + 1, sizeof(int));","Was the increase in size intentional to fit into the ""size pattern"" a*b  for the `xcalloc(a,b)` call?",
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/624,12027674,2014-04-27T05:18:38Z,src/garray.c,"@@ -98,30 +97,48 @@ void ga_remove_duplicate_strings(garray_T *gap) }  /// For a growing array that contains a list of strings: concatenate all the-/// strings with a separating comma.+/// strings with sep as separator. /// /// @param gap /// /// @returns the concatenated strings-char_u* ga_concat_strings(garray_T *gap)+char_u *ga_concat_strings_sep(const garray_T *gap, const char *sep) {-  size_t len = 0;+  const int nelem = gap->ga_len;+  const char **data = gap->ga_data;","What about ""strings"" instead of ""data""?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/640,12047394,2014-04-28T14:04:01Z,src/eval.c,"@@ -8640,10 +8620,10 @@ static void f_expand(typval_T *argvars, typval_T *rettv)     result = eval_vars(s, s, &len, NULL, &errormsg, NULL);     --emsg_off;     if (rettv->v_type == VAR_LIST) {-      if (rettv_list_alloc(rettv) != FAIL && result != NULL)+      rettv_list_alloc(rettv);+      if (result != NULL) {         list_append_string(rettv->vval.v_list, result, -1);-      else-        vim_free(result);","There should be no semantic change.If `result==NULL` then the allocated list is empty, otherwise a string is added. After that the function returns (and it must be assumed, a list was allocated). So the freeing of the list is always done somewhere else.",
3405586,schmee,https://api.github.com/repos/neovim/neovim/pulls/630,12066907,2014-04-28T20:50:01Z,src/regexp.c,"@@ -3295,53 +3295,28 @@ static lpos_T reg_endzpos[NSUBEXP];     /* idem, end pos */ /* TRUE if using multi-line regexp. */ #define REG_MULTI       (reg_match == NULL) -static int bt_regexec(regmatch_T *rmp, char_u *line, colnr_T col);+static int bt_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr);",I would use `bool line_lbr` instead of `int line_lbr`. `TRUE` and `FALSE` macros are deprecated.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/643,12075880,2014-04-29T01:00:29Z,README.md,"@@ -30,9 +30,13 @@ For lots more details, see - Formatted entire source with [uncrustify] - Replaced autotools build system with [CMake] - Implemented [continuous integration] and [test coverage]-- Wrote 60+ new unit tests+- Wrote 100+ new unit tests - Split large, monolithic files (`misc1.c`) into logical units   (`path.c`, `indent.c`, `garray.c`, `keymap.c`, ...)+- [Implemented](https://github.com/neovim/neovim/pull/475) job control (""async"")+- Reworked out-of-memory handling and removed thousands of redundant lines of ",I don't think the removed code reaches the thousands. The value of removal is the complexity reduction by reducing the number of branches in functions.,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/644,12078943,2014-04-29T04:00:29Z,src/log.c,"@@ -0,0 +1,119 @@+#include <assert.h>+#include <inttypes.h>+#include <stdarg.h>+#include <stdbool.h>+#include <stdint.h>+#include <stdio.h>+#include <sys/time.h>+#include <unistd.h>++#include ""log.h""+#include ""misc1.h""+#include ""types.h""++#define USR_LOG_FILE ""$HOME/.neovimlog""+++static FILE *open_log_file(void);+static bool do_log_to_file(FILE *log_file, int log_level, const char* fmt,+                           va_list args);++bool do_log(int log_level, const char* fmt, ...)+{+  FILE *log_file = open_log_file();++  va_list args;+  va_start(args, fmt);+  bool ret = do_log_to_file(log_file, log_level, fmt, args);+  va_end(args);++  return ret;+}++/// Open the log file for appending.+///+/// @return The FILE* specified by the USR_LOG_FILE path or stderr in case of+///         error+static FILE *open_log_file(void)+{+  static bool opening_log_file = false;++  // check if it's a recursive call+  if (opening_log_file) {+    va_list args;+    do_log_to_file(stderr, ERROR_LOG_LEVEL,+                   ""Trying to LOG() recursively! Please fix it."", args);+    return stderr;+  }++  // expand USR_LOG_FILE and open the file+  FILE *log_file;+  opening_log_file = true;+  {+    static char expanded_log_file_path[MAXPATHL + 1];++    expand_env((char_u *)USR_LOG_FILE, (char_u *)expanded_log_file_path,+               MAXPATHL);+    // if the log file path expansion failed then fallback to stderr+    if (strcmp(USR_LOG_FILE, expanded_log_file_path) == 0) {+      goto open_log_file_error;+    }++    log_file = fopen(expanded_log_file_path, ""a"");+    if (log_file == NULL) {+      goto open_log_file_error;+    }+  }+  opening_log_file = false;++  return log_file;++open_log_file_error:+  opening_log_file = false;++  va_list args;+  do_log_to_file(stderr, ERROR_LOG_LEVEL,+                ""Couldn't open USR_LOG_FILE, logging to stderr! This may be \","Indentation looks one character too far left.You can avoid the bad indentation on the next lines by letting the preprocessor concatenate the strings for you, e.g.,: ```printf(""this is a ""       ""long string"");```",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/632,12116833,2014-04-29T21:07:08Z,src/ex_cmds.c,"@@ -4178,23 +4163,23 @@ void do_sub(exarg_T *eap)           /*            * Get some space for a temporary buffer to do the            * substitution into (and some extra space to avoid-           * too many calls to alloc()/free()).+           * too many calls to xmalloc()/free()).            */           new_start_len = needed_len + 50;-          new_start = (char_u *)xmalloc((size_t)new_start_len);+          new_start = xmalloc(new_start_len);           *new_start = NUL;           new_end = new_start;         } else {           /*            * Check if the temporary buffer is long enough to do the            * substitution into.  If not, make it larger (with a bit-           * extra to avoid too many calls to alloc()/free()).+           * extra to avoid too many calls to xmalloc()/free()).            */           len = (unsigned)STRLEN(new_start);           needed_len += len;           if (needed_len > (int)new_start_len) {             new_start_len = needed_len + 50;-            p1 = (char_u *) xmalloc((size_t)new_start_len);+            p1 = xmalloc(new_start_len);",My default comment on the PRs that replace old allocation functions withxmalloc() is that you shouldn't miss the opportunity to perform additionalrefactorings. The reason I went slowly on converting all functions.In the first lines of this diff I saw `xmalloc(STRLEN(str))`. This can bereplaced by `xmalloc(strlen((char_u*)str)`.One should also consider changing the type of local variables to size_t andchar*.It's easier to preform and review these changes along with the `alloc`replacements.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/632,12129921,2014-04-30T06:20:26Z,src/ex_cmds.c,"@@ -4178,23 +4163,23 @@ void do_sub(exarg_T *eap)           /*            * Get some space for a temporary buffer to do the            * substitution into (and some extra space to avoid-           * too many calls to alloc()/free()).+           * too many calls to xmalloc()/free()).            */           new_start_len = needed_len + 50;-          new_start = (char_u *)xmalloc((size_t)new_start_len);+          new_start = xmalloc(new_start_len);           *new_start = NUL;           new_end = new_start;         } else {           /*            * Check if the temporary buffer is long enough to do the            * substitution into.  If not, make it larger (with a bit-           * extra to avoid too many calls to alloc()/free()).+           * extra to avoid too many calls to xmalloc()/free()).            */           len = (unsigned)STRLEN(new_start);           needed_len += len;           if (needed_len > (int)new_start_len) {             new_start_len = needed_len + 50;-            p1 = (char_u *) xmalloc((size_t)new_start_len);+            p1 = xmalloc(new_start_len);",Well if we're not going to simplify or use a `garray` here (more involved). At least put a todo there with a reference to this conversation so we can do it later. The (neo)vim codebase is sufficiently large that this likely won't be noticed again for quite a while.,
1769968,KarboniteKream,https://api.github.com/repos/neovim/neovim/pulls/654,12135340,2014-04-30T09:35:01Z,src/memory.c,"@@ -216,23 +214,21 @@ char *xstrndup(const char *str, size_t len) }  -char_u *lalloc(long_u size, int message)+char_u *lalloc(uint64_t size, bool message)","The variable 'message' is unused and should be removed (I'll do it after #645). The same goes for the function itself, since it's deprecated.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/644,12204419,2014-05-01T20:01:15Z,src/log.c,"@@ -0,0 +1,152 @@+#include <assert.h>+#include <inttypes.h>+#include <stdarg.h>+#include <stdbool.h>+#include <stdint.h>+#include <stdio.h>+#include <sys/time.h>+#include <unistd.h>++#include ""log.h""+#include ""misc1.h""+#include ""types.h""+#include ""os/os.h""++#define USR_LOG_FILE ""$HOME/.nvimlog""+++static FILE *open_log_file(void);+static bool do_log_to_file(FILE *log_file, int log_level,+                           const char *func_name, int line_num,+                           const char* fmt, ...);+static bool v_do_log_to_file(FILE *log_file, int log_level,+                             const char *func_name, int line_num,+                             const char* fmt, va_list args);++bool do_log(int log_level, const char *func_name, int line_num,+            const char* fmt, ...)+{+  FILE *log_file = open_log_file();++  if (log_file == NULL) {+    return false;+  }++  va_list args;+  va_start(args, fmt);+  bool ret = v_do_log_to_file(log_file, log_level, func_name, line_num, fmt,+                              args);+  va_end(args);++  return ret;+}++/// Open the log file for appending.+///+/// @return The FILE* specified by the USR_LOG_FILE path or stderr in case of+///         error+static FILE *open_log_file(void)+{+  static bool opening_log_file = false;++  // check if it's a recursive call+  if (opening_log_file) {+    do_log_to_file(stderr, ERROR_LOG_LEVEL, __func__, __LINE__,+                   ""Trying to LOG() recursively! Please fix it."");+    return stderr;+  }++  // expand USR_LOG_FILE and open the file+  FILE *log_file;+  opening_log_file = true;+  {+    static char expanded_log_file_path[MAXPATHL + 1];++    expand_env((char_u *)USR_LOG_FILE, (char_u *)expanded_log_file_path,+               MAXPATHL);+    // if the log file path expansion failed then fall back to stderr+    if (strcmp(USR_LOG_FILE, expanded_log_file_path) == 0) {+      goto open_log_file_error;+    }++    log_file = fopen(expanded_log_file_path, ""a"");+    if (log_file == NULL) {+      goto open_log_file_error;+    }+  }+  opening_log_file = false;++  return log_file;++open_log_file_error:+  opening_log_file = false;++  do_log_to_file(stderr, ERROR_LOG_LEVEL, __func__, __LINE__,+                 ""Couldn't open USR_LOG_FILE, logging to stderr! This may be ""+                 ""caused by attempting to LOG() before initialization ""+                 ""functions are called (e.g. init_homedir())."");+  return stderr;+}++static bool do_log_to_file(FILE *log_file, int log_level,+                           const char *func_name, int line_num,+                           const char* fmt, ...)+{+  va_list args;+  va_start(args, fmt);+  bool ret = v_do_log_to_file(log_file, log_level, func_name, line_num, fmt,+                              args);+  va_end(args);++  return ret;+}++static bool v_do_log_to_file(FILE *log_file, int log_level,+                             const char *func_name, int line_num,+                             const char* fmt, va_list args)+{+  static const char *log_levels[] = {+    [DEBUG_LOG_LEVEL] = ""debug"",+    [INFO_LOG_LEVEL] = ""info"",+    [WARNING_LOG_LEVEL] = ""warning"",+    [ERROR_LOG_LEVEL] = ""error""+  };+  assert(log_level >= DEBUG_LOG_LEVEL && log_level <= ERROR_LOG_LEVEL);++  // format current timestamp in local time+  struct timeval tv;+  if (gettimeofday(&tv, NULL) < 0) {+    return false;+  }+#ifdef UNIX+  // localtime() is not thread-safe. POSIX provides localtime_r() as a+  // thread-safe version.+  struct tm local_time_allocated;+  struct tm *local_time = localtime_r(&tv.tv_sec, &local_time_allocated);+#else+  // Windows version of localtime() is thread-safe.+  // See http://msdn.microsoft.com/en-us/library/bf12f0hc%28VS.80%29.aspx+  struct tm *local_time = localtime(&tv.tv_sec);  // NOLINT+#endif","wouldn't this pattern be generally useful as a function, eg `os_local_time()` ?",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/644,12209149,2014-05-01T21:37:10Z,src/log.c,"@@ -0,0 +1,152 @@+#include <assert.h>+#include <inttypes.h>+#include <stdarg.h>+#include <stdbool.h>+#include <stdint.h>+#include <stdio.h>+#include <sys/time.h>+#include <unistd.h>++#include ""log.h""+#include ""misc1.h""+#include ""types.h""+#include ""os/os.h""++#define USR_LOG_FILE ""$HOME/.nvimlog""+++static FILE *open_log_file(void);+static bool do_log_to_file(FILE *log_file, int log_level,+                           const char *func_name, int line_num,+                           const char* fmt, ...);+static bool v_do_log_to_file(FILE *log_file, int log_level,+                             const char *func_name, int line_num,+                             const char* fmt, va_list args);++bool do_log(int log_level, const char *func_name, int line_num,+            const char* fmt, ...)+{+  FILE *log_file = open_log_file();++  if (log_file == NULL) {+    return false;+  }++  va_list args;+  va_start(args, fmt);+  bool ret = v_do_log_to_file(log_file, log_level, func_name, line_num, fmt,+                              args);+  va_end(args);++  return ret;+}++/// Open the log file for appending.+///+/// @return The FILE* specified by the USR_LOG_FILE path or stderr in case of+///         error+static FILE *open_log_file(void)+{+  static bool opening_log_file = false;++  // check if it's a recursive call+  if (opening_log_file) {+    do_log_to_file(stderr, ERROR_LOG_LEVEL, __func__, __LINE__,+                   ""Trying to LOG() recursively! Please fix it."");+    return stderr;+  }++  // expand USR_LOG_FILE and open the file+  FILE *log_file;+  opening_log_file = true;+  {+    static char expanded_log_file_path[MAXPATHL + 1];++    expand_env((char_u *)USR_LOG_FILE, (char_u *)expanded_log_file_path,+               MAXPATHL);+    // if the log file path expansion failed then fall back to stderr+    if (strcmp(USR_LOG_FILE, expanded_log_file_path) == 0) {+      goto open_log_file_error;+    }++    log_file = fopen(expanded_log_file_path, ""a"");+    if (log_file == NULL) {+      goto open_log_file_error;+    }+  }+  opening_log_file = false;++  return log_file;++open_log_file_error:+  opening_log_file = false;++  do_log_to_file(stderr, ERROR_LOG_LEVEL, __func__, __LINE__,+                 ""Couldn't open USR_LOG_FILE, logging to stderr! This may be ""+                 ""caused by attempting to LOG() before initialization ""+                 ""functions are called (e.g. init_homedir())."");+  return stderr;+}++static bool do_log_to_file(FILE *log_file, int log_level,+                           const char *func_name, int line_num,+                           const char* fmt, ...)+{+  va_list args;+  va_start(args, fmt);+  bool ret = v_do_log_to_file(log_file, log_level, func_name, line_num, fmt,+                              args);+  va_end(args);++  return ret;+}++static bool v_do_log_to_file(FILE *log_file, int log_level,+                             const char *func_name, int line_num,+                             const char* fmt, va_list args)+{+  static const char *log_levels[] = {+    [DEBUG_LOG_LEVEL] = ""debug"",+    [INFO_LOG_LEVEL] = ""info"",+    [WARNING_LOG_LEVEL] = ""warning"",+    [ERROR_LOG_LEVEL] = ""error""+  };+  assert(log_level >= DEBUG_LOG_LEVEL && log_level <= ERROR_LOG_LEVEL);++  // format current timestamp in local time+  struct timeval tv;+  if (gettimeofday(&tv, NULL) < 0) {+    return false;+  }+#ifdef UNIX+  // localtime() is not thread-safe. POSIX provides localtime_r() as a+  // thread-safe version.+  struct tm local_time_allocated;+  struct tm *local_time = localtime_r(&tv.tv_sec, &local_time_allocated);+#else+  // Windows version of localtime() is thread-safe.+  // See http://msdn.microsoft.com/en-us/library/bf12f0hc%28VS.80%29.aspx+  struct tm *local_time = localtime(&tv.tv_sec);  // NOLINT+#endif",Yes! I would call it `os_localtime_r` along with `os_get_local_time`. The last one would call `gettimeofday` to obtain the parameter to `os_localtime_t`.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/665,12209736,2014-05-01T21:50:50Z,src/buffer.c,"@@ -4369,9 +4369,7 @@ static void insert_sign(     int typenr              /* typenr of sign we are adding */     ) {-    signlist_T	*newsign;--    newsign = (signlist_T *)lalloc((long_u)sizeof(signlist_T), FALSE);+    signlist_T *newsign = xmalloc(sizeof(signlist_T));",@watk  https://github.com/neovim/neovim/wiki/C-programming says to be judicious about it.`sizeof(*var)` is good to avoid a situation where `var` may change from `int` to `long` and the buffer size becomes too small.The allocate struct idiom is way too simple that I think my approach is good. I can argue about how more fragile `sizeof(*newsign)` actually is.,
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/665,12213715,2014-05-01T23:44:56Z,src/buffer.c,"@@ -4369,9 +4369,7 @@ static void insert_sign(     int typenr              /* typenr of sign we are adding */     ) {-    signlist_T	*newsign;--    newsign = (signlist_T *)lalloc((long_u)sizeof(signlist_T), FALSE);+    signlist_T *newsign = xmalloc(sizeof(signlist_T));","Ok, fair enough. My change is inconsistent with this, but no big deal.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/619,12257560,2014-05-03T18:52:47Z,src/file_search.c,"@@ -1126,38 +1124,27 @@ static int ff_wc_equal(char_u *s1, char_u *s2) static int ff_check_visited(ff_visited_T **visited_list, char_u *fname, char_u *wc_path) {   ff_visited_T        *vp;-#ifdef UNIX-  struct stat st;-  int url = FALSE;-#endif+  bool url = false; -  /* For an URL we only compare the name, otherwise we compare the-   * device/inode (unix) or the full path name (not Unix). */+  FileInfo file_info;+  // For an URL we only compare the name, otherwise we compare the+  // device/inode.   if (path_with_url(fname)) {     vim_strncpy(ff_expand_buffer, fname, MAXPATHL - 1);-#ifdef UNIX-    url = TRUE;-#endif+    url = true;   } else {     ff_expand_buffer[0] = NUL;-#ifdef UNIX-    if (mch_stat((char *)fname, &st) < 0)-#else-    if (vim_FullName(fname, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)-#endif+    if (!os_get_file_info((char *)fname, &file_info)) {       return FAIL;+    }   }    /* check against list of already visited files */   for (vp = *visited_list; vp != NULL; vp = vp->ffv_next) {-    if (-#ifdef UNIX-      !url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev-              && vp->ffv_ino == st.st_ino)-      :-#endif-      fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0-      ) {+    if ((url && fnamecmp(vp->ffv_fname, ff_expand_buffer) == 0)+        || (vp->ffv_dev_valid+            && vp->ffv_dev == file_info.stat.st_dev+            && vp->ffv_ino == file_info.stat.st_ino)) {","This condition does not have the same meaning as before. Now if `url == true` and `fnamecmp(vp->ffv_fname, ff_expand_buffer) != 0` then `(vp->ffv_dev_valid && vp->ffv_dev == file_info.stat.st_dev && vp->ffv_ino == file_info.stat.st_ino)` would also be checked. In the ternary operator version just one of these subconditions can be checked.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/619,12259906,2014-05-04T05:35:13Z,src/os/fs.c,"@@ -189,6 +189,16 @@ int os_file_is_writable(const char *name)   return 0; } +bool os_get_file_size(const char *name, off_t *size)",Is there any reason why you did not use `off_t &size`? (The same for other functions' `file_info` parameter),
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/619,12259916,2014-05-04T05:43:15Z,src/os/os.h,"@@ -58,6 +58,12 @@ bool os_file_is_readonly(const char *name); /// @return `2` for a directory which we have rights to write into. int os_file_is_writable(const char *name); +/// Get the size of a file in bytes.+///+/// @param size pointer to an off_t to put the size into.",Doxygen have additional flags to specify direction of the parameter: http://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdparamFor example in this case you can write `@param[out] size`I think it is good to clarify direction on pointer arguments.,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/619,12259933,2014-05-04T05:48:17Z,src/os/os.h,"@@ -105,4 +111,36 @@ char *os_get_user_directory(const char *name); /// @return OK on success, FAIL if an failure occured. int os_stat(const char_u *name, uv_stat_t *statbuf); +/// Struct which encapsulates stat information.+typedef struct {+  // TODO(stefan991): make stat private+  uv_stat_t stat;+} FileInfo;++/// Get the file information for a given path+///+/// @param path Path to the file.+/// @param file_info Pointer to a FileInfo struct to put the information in.+/// @return `true` on sucess, `false` for failure.+bool os_get_file_info(const char *path, FileInfo *file_info);++/// Get the file information for a given path without following links+///+/// @param file_descriptor File descriptor of the file.",Perhaps copy-paste error: `os_get_file_info_link` has `path`(not the `file_descriptor`) parameter.,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/681,12260067,2014-05-04T06:49:09Z,src/buffer.c,"@@ -1820,6 +1821,52 @@ buflist_findpat ( }  +// Find the matches & store the matches in (*file) array.+// Return the count of matches found.+static int store_buf_match(char_u ***file, regprog_T *prog, int options)+{+  buf_T *buf;+  int count = 0;++  // Count the matches+  for (buf = firstbuf; buf != NULL; buf = buf->b_next) {+    // skip unlisted buffers+    if (!buf->b_p_bl) {+      continue;+    }++    if (buflist_match(prog, buf) != NULL) {+      count++;+    }+  }++  if (count == 0) {+    return 0;+  }++  *file = xmalloc(count * sizeof(**file));  // Space for storing the matches++  char_u *p;",According to the style guide we must declare variables as close as possible to their respective definitions(I think the same is applicable to `buf_T *buf`). If you did it for optimisation purposes these threads explain why it is not needed: http://stackoverflow.com/questions/8735765/variables-declared-inside-a-loop http://stackoverflow.com/questions/7959573/declaring-variables-inside-loops-good-practice-or-bad-practice-2-parter,
11265,ony,https://api.github.com/repos/neovim/neovim/pulls/665,12263539,2014-05-04T19:12:00Z,src/edit.c,"@@ -6274,31 +6274,30 @@ static int echeck_abbr(int c)  */  static char_u   *replace_stack = NULL;-static long replace_stack_nr = 0;           /* next entry in replace stack */-static long replace_stack_len = 0;          /* max. number of entries */+static int64_t replace_stack_nr = 0;           /* next entry in replace stack */","Type `long` in gcc bound to machine word size and thus matches with `size_t` which is type of `xmalloc`/`malloc`. If there is a really need to support ""stack"" bigger than address space of process we should modify related code to process it with help of loadable (from file or whatever) pages etc.But looks this is a simple in-memory stack that is not intended for spanning outside of available addressing space.",
11265,ony,https://api.github.com/repos/neovim/neovim/pulls/665,12263553,2014-05-04T19:14:48Z,src/edit.c,"@@ -6274,31 +6274,30 @@ static int echeck_abbr(int c)  */  static char_u   *replace_stack = NULL;-static long replace_stack_nr = 0;           /* next entry in replace stack */-static long replace_stack_len = 0;          /* max. number of entries */+static int64_t replace_stack_nr = 0;           /* next entry in replace stack */+static int64_t  replace_stack_len = 0;          /* max. number of entries */  void  replace_push (     int c              /* character that is replaced (NUL is none) */ ) {-  char_u  *p;-   if (replace_stack_nr < replace_offset)        /* nothing to do */     return;++  char_u *p;   if (replace_stack_len <= replace_stack_nr) {     replace_stack_len += 50;-    p = lalloc(sizeof(char_u) * replace_stack_len, TRUE);+    p = xmalloc(sizeof(*p) * replace_stack_len);",Its actually doesn't matter which type to use for `p` since it is simply a temporary pointer to freshly allocated memory. You can use `void *p` instead (and I'd prefer to do that). Thus its makes not much of sense to use `sizeof(*p)`. But instead it may make a sense to put `sizeof(*replace_stack)` instead.,
11265,ony,https://api.github.com/repos/neovim/neovim/pulls/665,12263776,2014-05-04T19:53:23Z,src/ex_cmds.c,"@@ -1337,17 +1330,12 @@ make_filter_cmd (     char_u *otmp              /* NULL or name of output file */ ) {-  char_u      *buf;-  long_u len;--  len = (long_u)STRLEN(cmd) + 3;                        /* ""()"" + NUL */+  size_t len = STRLEN(cmd) + 3;                        /* ""()"" + NUL */   if (itmp != NULL)-    len += (long_u)STRLEN(itmp) + 9;                    /* "" { < "" + "" } "" */",Such kind of code is a subject for rising a ticket that will help to simplify this code by calculating requires size from formatting and parameters. I've created issue #685,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/688,12328123,2014-05-06T14:51:43Z,src/message.c,"@@ -61,6 +61,34 @@ static int do_more_prompt(int typed_char); static void msg_screen_putchar(int c, int attr); static int msg_check_screen(void); static void redir_write(char_u *s, int maxlen);++/// Allocates memory for dialog string & for storing hotkeys+///+/// Finds the size of memory required for the confirm_msg & for storing hotkeys+/// and then allocates the memory for them.+/// has_hotkey array is also filled-up.+///+/// @param message Message which will be part of the confirm_msg+/// @param buttons String containing button names+/// @param has_hotkey A element in this array is TRUE if corresponding button+///                   has a hotkey+///+/// @return Pointer to memory allocated for storing hotkeys+static char_u * console_dialog_alloc(const char_u *message,+                                     char_u *buttons,+                                     char_u has_hotkey[]);++/// Copies hotkeys & dialog message into the memory allocated for it+///+/// @param message Message which will be part of the confirm_msg+/// @param buttons String containing button names+/// @param dfltbutton Number of default button",In Neovim we're trying to move away from overly abbreviated variable names in favor of more descriptive (even if longer) names. I suggest you to rename it to `default_button_idx`.,
4763183,harsh1kumar,https://api.github.com/repos/neovim/neovim/pulls/688,12343366,2014-05-06T19:26:46Z,src/message.c,"@@ -2828,6 +2856,57 @@ copy_char (   } } +#define HAS_HOTKEY_LEN 30+#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)++static char_u * console_dialog_alloc(const char_u *message,+                                     char_u *buttons,+                                     char_u has_hotkey[])+{+  int lenhotkey = HOTK_LEN;  // count first button+  has_hotkey[0] = FALSE;++  // Compute the size of memory to allocate.+  int len = 0;+  int idx = 0;+  char_u *r = buttons;+  while (*r) {+    if (*r == DLG_BUTTON_SEP) {+      len += 3;                         // '\n' -> ', '; 'x' -> '(x)'+      lenhotkey += HOTK_LEN;            // each button needs a hotkey+      if (idx < HAS_HOTKEY_LEN - 1) {+        has_hotkey[++idx] = FALSE;+      }+    } else if (*r == DLG_HOTKEY_CHAR) {+      r++;+      len++;                    // '&a' -> '[a]'+      if (idx < HAS_HOTKEY_LEN - 1) {+        has_hotkey[idx] = TRUE;+      }+    }++    // Advance to the next character+    mb_ptr_adv(r);+  }++  len += (int)(STRLEN(message)+                + 2                          // for the NL's+                + STRLEN(buttons)+                + 3);                        // for the "": "" and NUL+  lenhotkey++;                               // for the NUL++  // If no hotkey is specified, first char is used.+  if (!has_hotkey[0]) {+    len += 2;                                // ""x"" -> ""[x]""+  }++  // Now allocate space for the strings+  vim_free(confirm_msg);",Do I replace `vim_free` with `free` in all my future patches? Why is `vim_free` bad?,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/688,12343562,2014-05-06T19:30:39Z,src/message.c,"@@ -2828,6 +2856,57 @@ copy_char (   } } +#define HAS_HOTKEY_LEN 30+#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)++static char_u * console_dialog_alloc(const char_u *message,+                                     char_u *buttons,+                                     char_u has_hotkey[])+{+  int lenhotkey = HOTK_LEN;  // count first button+  has_hotkey[0] = FALSE;++  // Compute the size of memory to allocate.+  int len = 0;+  int idx = 0;+  char_u *r = buttons;+  while (*r) {+    if (*r == DLG_BUTTON_SEP) {+      len += 3;                         // '\n' -> ', '; 'x' -> '(x)'+      lenhotkey += HOTK_LEN;            // each button needs a hotkey+      if (idx < HAS_HOTKEY_LEN - 1) {+        has_hotkey[++idx] = FALSE;+      }+    } else if (*r == DLG_HOTKEY_CHAR) {+      r++;+      len++;                    // '&a' -> '[a]'+      if (idx < HAS_HOTKEY_LEN - 1) {+        has_hotkey[idx] = TRUE;+      }+    }++    // Advance to the next character+    mb_ptr_adv(r);+  }++  len += (int)(STRLEN(message)+                + 2                          // for the NL's+                + STRLEN(buttons)+                + 3);                        // for the "": "" and NUL+  lenhotkey++;                               // for the NUL++  // If no hotkey is specified, first char is used.+  if (!has_hotkey[0]) {+    len += 2;                                // ""x"" -> ""[x]""+  }++  // Now allocate space for the strings+  vim_free(confirm_msg);","> Do I replace vim_free with free in all my future patches? Why is vim_free bad?Yes, `vim_free` has just been removed, see #627. So if you rebase, you shouldn't even be able to use `vim_free` anymore. Also, in this particular instance there should just be a single `xrealloc()` call :).",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/665,12360606,2014-05-07T03:47:08Z,src/edit.c,"@@ -6274,31 +6274,30 @@ static int echeck_abbr(int c)  */  static char_u   *replace_stack = NULL;-static long replace_stack_nr = 0;           /* next entry in replace stack */-static long replace_stack_len = 0;          /* max. number of entries */+static int64_t replace_stack_nr = 0;           /* next entry in replace stack */",@ony `long` is 32bits on Windows. I'm now moving to `ssize_t`.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/665,12360650,2014-05-07T03:51:13Z,src/edit.c,"@@ -6274,31 +6274,30 @@ static int echeck_abbr(int c)  */  static char_u   *replace_stack = NULL;-static long replace_stack_nr = 0;           /* next entry in replace stack */-static long replace_stack_len = 0;          /* max. number of entries */+static int64_t replace_stack_nr = 0;           /* next entry in replace stack */+static int64_t  replace_stack_len = 0;          /* max. number of entries */  void  replace_push (     int c              /* character that is replaced (NUL is none) */ ) {-  char_u  *p;-   if (replace_stack_nr < replace_offset)        /* nothing to do */     return;++  char_u *p;   if (replace_stack_len <= replace_stack_nr) {     replace_stack_len += 50;-    p = lalloc(sizeof(char_u) * replace_stack_len, TRUE);+    p = xmalloc(sizeof(*p) * replace_stack_len);","@ony for this block `void *` is OK, but later it's used as a `char_u *`. Thanks to your comment I'm now reducing the scope of this ""first"" `p` and renaming it to `void *aux`.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/644,12361278,2014-05-07T04:39:40Z,src/eval.c,"@@ -14174,9 +14174,11 @@ static void f_strftime(typval_T *argvars, typval_T *rettv)     seconds = time(NULL);   else     seconds = (time_t)get_tv_number(&argvars[1]);-  curtime = localtime(&seconds);++  struct tm curtime;+  struct tm *curtime_ptr = os_localtime_r(&seconds, &curtime);   /* MSVC returns NULL for an invalid value of seconds. */","@justinmk `man localtime` gives> The functions ctime(), gmtime(), and localtime() all take as an argument a time value representing the time in  seconds since the Epoch (00:00:00 UTC, January 1, 1970; see time(3)).  When encountering an error, these functions return NULL and set errno to an appropriate value.This comment work as a note that one of the possible error conditions is an invalid value of seconds.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/644,12361404,2014-05-07T04:50:11Z,src/eval.c,"@@ -14174,9 +14174,11 @@ static void f_strftime(typval_T *argvars, typval_T *rettv)     seconds = time(NULL);   else     seconds = (time_t)get_tv_number(&argvars[1]);-  curtime = localtime(&seconds);++  struct tm curtime;+  struct tm *curtime_ptr = os_localtime_r(&seconds, &curtime);   /* MSVC returns NULL for an invalid value of seconds. */","Ok, but the comment says msvc. It's eval.c though, so no big deal.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/619,12372607,2014-05-07T12:05:13Z,src/os/fs.c,"@@ -189,6 +189,16 @@ int os_file_is_writable(const char *name)   return 0; } +bool os_get_file_size(const char *name, off_t *size)+{+  uv_stat_t statbuf;+  if (os_stat((char_u *)name, &statbuf) == OK) {+    *size = statbuf.st_size;+    return true;+  }+  return false;","I'm all for getting more info to the user, especially if it doesn't complicate calling patterns. Since we seem to be exposing libuv anyway (through `os_stat` for example), perhaps it's not such a big problem to bring in libuv'isms into this.Then again, I've always had a weak spot for how to linux kernel does it: return a signed number where negative values indicate an error, and positive ones mean success (like `read()`).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/619,12377073,2014-05-07T13:50:17Z,src/os/fs.c,"@@ -189,6 +189,16 @@ int os_file_is_writable(const char *name)   return 0; } +bool os_get_file_size(const char *name, off_t *size)+{+  uv_stat_t statbuf;+  if (os_stat((char_u *)name, &statbuf) == OK) {+    *size = statbuf.st_size;+    return true;+  }+  return false;","> I think we should implement error handling, but I don't think we should use libuv error codes directly, because we should be able to handle errors in a consistent way, even if they are not from libuv.That should be preferable of course (if it's not too complex).",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/692,12433638,2014-05-08T15:10:56Z,src/syntax.c,"@@ -4682,6 +4703,81 @@ static int syn_compare_stub(const void *v1, const void *v2)   return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0; } +static int syn_combine_list_count(const short *g1, const short *g2, int list_op)+{+  int count = 0;++  // Loop through the lists until one of them is empty.+  while (*g1 && *g2) {++    // Always add from the first list.+    if (*g1 < *g2) {+      count++;+      g1++;+      continue;+    }++    // Only add from the second list if we're adding the lists.+    if (list_op == CLUSTER_ADD) {+      count++;+    }++    if (*g1 == *g2)+      g1++;+    g2++;+  }++  // Now add the leftovers from whichever list didn't get finished first.+  // As before, only add from the second list if we're adding the lists.+  for (; *g1; g1++) {+    count++;+  }++  if (list_op == CLUSTER_ADD)+    for (; *g2; g2++) {+      count++;+    }++  return count;+}++static void syn_combine_list_merge(const short *g1, const short *g2, int list_op, short *clstr)+{+  // Loop through the lists until one of them is empty.+  while (*g1 && *g2) {++    // Always add from the first list.+    if (*g1 < *g2) {+      *clstr = *g1;",In the case of `syn_combine_list_merge` you can renamer `count` to `i`.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/705,12445303,2014-05-08T18:34:53Z,src/strings.c,"@@ -41,32 +41,22 @@ #include ""os/os.h"" #include ""os/shell.h"" -/*- * Copy ""string"" into newly allocated memory.- */+// TODO(elmart): Refactor this function to return void *,+//               and its callers to remove checks for NULL. char_u *vim_strsave(char_u *string)","> P.S. If you develop your changes on top of my 'remove_long_u' branch, we won't have merge problems once this PR is merged.@elmart then I need you to reimplement these using `xstrdup`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/703,12446750,2014-05-08T19:03:23Z,CONTRIBUTING.md,"@@ -2,53 +2,84 @@  ## Thank you -Thanks for considering contributing to neovim. To make the process as smooth-as possible we would ask you to follow the guidelines below.+Thanks for considering contributing to Neovim. To make the process as smooth as+possible we would ask you to follow the guidelines below. If you need support+see [the wiki][wiki]. -## Help with contributing+## Issues -See [Communicating](https://github.com/neovim/neovim/wiki/Communicating).-Raise documentation issues.+- Search existing issues before raising a new one.+- Include as much detail as possible. In particular, we need to know which+  OS you're using.++## Pull requests -## Guidelines+### For all PRs -### Finding something to do+- Make it clear in the issue tracker what you are working on, so that someone+  else doesn't duplicate the work.+- Be descriptive in your PR message: what is it for, why is it needed, etc.+- Don't make cosmetic changes to unrelated files in the same PR. -Neovim uses [waffle.io](https://waffle.io/neovim/neovim), so check there-first.+#### Tagging in the issue tracker -You can also ask for an issues to be assigned to you.-Ideally wait until we assign it to you to minimize-work duplication.+When submitting pull requests, include one of the following 'tags' in the title: -### Reporting an issue+* `[WIP]` - Work In Progress. The pull request will change, and there is no need+  to review it yet.+* `[RFC]` - Request For Comment. The request needs reviewing and/or comments.+* `[RDY]` - The request is ready to be merged. The request must have been+  reviewed by at least one person and have no outstanding issues. -- Search existing issues before raising a new one.-- Include as much detail as possible. In particular, we need to know which-  OS you're using.+This lets people quickly see the status of the PR, and reduces the risk of+merging requests that are not yet ready or reviewed. By tagging, you'll also+save reviewers and mergers some work. -### Pull requests+If a pull request doesn't have a tag, it's considered `WIP` as long as there are+no comments indicating it's `RFC` or `RDY`.++#### Branching & history -- Make it clear in the issue tracker what you are working on, so that-someone else doesn't duplicate the work. - Use a feature branch, not master.-- Rebase your feature branch onto origin/master before raising the PR.-- Keep up to date with changes in master so your PR is easy to merge.-- Be descriptive in your PR message: what is it for, why is it needed, etc.-- Make sure the tests pass (TODO: we need to make this easier with travis etc.)-- Squash related commits as much as possible.+- Rebase your feature branch onto (upstream) master before raising the PR.+- Keep up to date with changes in (upstream) master so your PR is easy to merge.+- Try to actively tidy your history: combine related commits with interactive+  rebasing etc. If your PR is still `[WIP]` don't be afraid to force-push to+  your feature branch to tidy your history.++### For code PRs++#### Testing -### Coding style+- We are unlikely to merge your PR if the Travis build fails.+- The Travis build does not currently run the tests under valgrind, but we would+  strongly encourage you to do so locally. -All code changes should follow the [neovim style guide](http://neovim.org/development-wiki/style-guide/style-guide.xml).+#### Coding style -Please run `clint.py` to detect style errors. `clint.py` is Google's-[`cpplint.py`](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#cpplint)-script modified with the neovim style guidelines. It is not perfect and may-have false positives and negatives, but is still a valuable tool. To have-`clint.py` ignore certain special cases, put `// NOLINT` at the end of the-line.+All code changes should follow the [Neovim style guide][style].++Please run [`clint.py`][clint] to detect style errors. `clint.py` is Google's+[`cpplint.py`][cpplint].  script modified with the neovim style guidelines. It+is not perfect and may have false positives and negatives, but is still a+valuable tool. To have `clint.py` ignore certain special cases, put `// NOLINT`+at the end of the line.  ### Commit messages -TODO+Try to follow the [Tim Pope Convention][commit] (@tpope) for commit messages.+Most importantly, do the following:++- Keep the first line a summary of 50 characters or less.+- Write the summary in the [imperative mood][imperative].+- Write a more detailed explanation (after a blank line) that explains more in+  depth (only if necessary).++Tim Pope's site also contains an example if you need one.",@elmart's commit messages are very good. Here's an example: https://github.com/neovim/neovim/commit/cb7fb8c008e3da673014952b960bf4604af7b210The first line might be a bit long though.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/707,12464298,2014-05-09T04:56:10Z,src/ex_docmd.c,"@@ -303,7 +303,15 @@ struct loop_cookie {  static char_u   *get_loop_line(int c, void *cookie, int indent); static void store_loop_line(garray_T *gap, char_u *line);-static void free_cmdlines(garray_T *gap);++///+/// clear the content in wcmd_T","I was talking about the comments using ""free()"" as a verb. I think you should drop the comments altogether. `free_OBJECT` is a very common pattern in C programming. `git grep free_` on Neovim's codebase returns many results.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/705,12476329,2014-05-09T13:58:07Z,src/strings.c,"@@ -41,32 +41,22 @@ #include ""os/os.h"" #include ""os/shell.h"" -/*- * Copy ""string"" into newly allocated memory.- */+// TODO(elmart): Refactor this function to return void *,+//               and its callers to remove checks for NULL. char_u *vim_strsave(char_u *string)","Yes, I had seen #690 and found it very interesting. Thanks for sharing, anyway. I see you are now putting coccinelle to good use! I'll give a try too for my large-scale simple refactorings.",
7245795,watk,https://api.github.com/repos/neovim/neovim/pulls/708,12502935,2014-05-10T07:19:03Z,src/eval.c,"@@ -6171,15 +6153,12 @@ dictitem_T *dictitem_alloc(char_u *key)  */ static dictitem_T *dictitem_copy(dictitem_T *org)",The caller of this no longer needs a null check.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/714,12507306,2014-05-11T03:54:00Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","Ack, this is failing on the 32-bit build now. Why would it fail now, but not before? ping @elmart```/home/travis/build/neovim/neovim/src/os/rstream.c: In function ���fread_idle_cb���:/home/travis/build/neovim/neovim/src/os/rstream.c:238:3: error: comparison is always true due to limited range of data type [-Werror=type-limits]```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/710,12509320,2014-05-11T15:30:01Z,src/garray.h,"@@ -16,16 +16,7 @@ typedef struct growarray {  #define GA_EMPTY { 0, 0, 0, 0, NULL }","@philix ? You have to include generated files in `*.c` files. Just you have to include _different_ generated files: those that contain only static declarations.`*.h.generated.h` files containing non-static declarations are generated separately because it is possible that they will be distributed in a separate packages alongside with non-generated `*.h` files. So I generate them separately and I put them  in a separate directory from `*.c.generated.h` (well, will put if somebody can say how to tell cmake what I want: see my last comment).",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/708,12546941,2014-05-12T18:53:50Z,src/eval.c,"@@ -6171,15 +6153,12 @@ dictitem_T *dictitem_alloc(char_u *key)  */ static dictitem_T *dictitem_copy(dictitem_T *org)",Added to my list of functions to check.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/582,12627832,2014-05-14T09:34:07Z,src/api/buffer.c,"@@ -0,0 +1,413 @@+// Much of this code was adapted from 'if_py_both.h' from the original+// vim source+#include <stdint.h>+#include <stdlib.h>++#include ""api/buffer.h""+#include ""api/helpers.h""+#include ""api/defs.h""+#include ""../vim.h""+#include ""../buffer.h""+#include ""memline.h""+#include ""memory.h""+#include ""misc1.h""+#include ""misc2.h""+#include ""ex_cmds.h""+#include ""mark.h""+#include ""fileio.h""+#include ""move.h""+#include ""../window.h""+#include ""undo.h""++// Find a window that contains ""buf"" and switch to it.+// If there is no such window, use the current window and change ""curbuf"".+// Caller must initialize save_curbuf to NULL.+// restore_win_for_buf() MUST be called later!+static void switch_to_win_for_buf(buf_T *buf,+                                  win_T **save_curwinp,+                                  tabpage_T **save_curtabp,+                                  buf_T **save_curbufp);++static void restore_win_for_buf(win_T *save_curwin,+                                tabpage_T *save_curtab,+                                buf_T *save_curbuf);++// Check if deleting lines made the cursor position invalid.+// Changed the lines from ""lo"" to ""hi"" and added ""extra"" lines (negative if+// deleted).+static void fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra);++// Normalizes 0-based indexes to buffer line numbers+static int64_t normalize_index(buf_T *buf, int64_t index);++int64_t buffer_get_length(Buffer buffer, Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return 0;+  }++  return buf->b_ml.ml_line_count;+}++String buffer_get_line(Buffer buffer, int64_t index, Error *err)+{+  String rv = {.size = 0};+  StringArray slice = buffer_get_slice(buffer, index, index, true, true, err);++  if (slice.size) {+    rv = slice.items[0];+  }++  return rv;+}++void buffer_set_line(Buffer buffer, int64_t index, String line, Error *err)+{+  StringArray array = {.items = &line, .size = 1};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++void buffer_del_line(Buffer buffer, int64_t index, Error *err)+{+  StringArray array = {.size = 0};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++StringArray buffer_get_slice(Buffer buffer,+                             int64_t start,+                             int64_t end,+                             bool include_start,+                             bool include_end,+                             Error *err)+{+  StringArray rv = {.size = 0};+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return rv;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start >= end) {+    // Return 0-length array+    return rv;+  }++  rv.size = end - start;+  rv.items = xmalloc(sizeof(String) * rv.size);++  for (uint32_t i = 0; i < rv.size; i++) {+    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+    rv.items[i].size = strlen(rv.items[i].data);+  }++  return rv;+}++void buffer_set_slice(Buffer buffer,+                      int64_t start,+                      int64_t end,+                      bool include_start,+                      bool include_end,+                      StringArray replacement,+                      Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start > end) {+    set_api_error(""start > end"", err);+    return;+  }++  buf_T *save_curbuf = NULL;+  win_T *save_curwin = NULL;+  tabpage_T *save_curtab = NULL;+  uint32_t new_len = replacement.size;+  uint32_t old_len = end - start;+  uint32_t i;+  int32_t extra = 0;  // lines added to text, can be negative+  char **lines;++  if (new_len == 0) {+    // avoid allocating zero bytes+    lines = NULL;+  } else {+    lines = xcalloc(sizeof(char *), new_len);+  }++  for (i = 0; i < new_len; i++) {+    String l = replacement.items[i];+    lines[i] = xstrndup(l.data, l.size);+  }++  try_start();+  switch_to_win_for_buf(buf, &save_curwin, &save_curtab, &save_curbuf);++  if (u_save(start - 1, end) == FAIL) {+    set_api_error(""Cannot save undo information"", err);+    goto cleanup;+  }++  // If the size of the range is reducing (ie, new_len < old_len) we+  // need to delete some old_len. We do this at the start, by+  // repeatedly deleting line ""start"".+  for (i = 0; new_len < old_len && i < old_len - new_len; i++) {","`new_len`/`old_len` are unsigned, we should be very, very careful with subtractions. I think the reason @tarruda added it, is because if `new_len > old_len`, then `old_len - new_len` wraps around and becomes huge, therefore making the loop run for a very long time and possibly exploding the universe.This is one of the reasons I advocate using signed types of possible. Of course, size semantics are appropriate here, so the alternative solution is to be paranoid. That said, `new_len < old_len` can be hoisted out of the loop condition. I'm not saying this for performance reasons, as any compiler can see that `new_len` and `old_len` are constant in the loop.E.g.:``` c// If the size of the range is reducing (ie, new_len < old_len) we// need to delete some old_len. We do this at the start, by// repeatedly deleting line ""start"".size_t to_delete = (new_len < old_len) ? (size_t)(new_len - old_len) : 0;for (size_t i = 0; i < to_delete; i++) {  if (ml_delete(start, false) == FAIL) {    set_api_error(""Cannot delete line"", err);    goto cleanup;  }}extra -= to_delete;```This, in my opinion, just reads faster.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/582,12632306,2014-05-14T12:10:41Z,src/api/buffer.c,"@@ -0,0 +1,413 @@+// Much of this code was adapted from 'if_py_both.h' from the original+// vim source+#include <stdint.h>+#include <stdlib.h>++#include ""api/buffer.h""+#include ""api/helpers.h""+#include ""api/defs.h""+#include ""../vim.h""+#include ""../buffer.h""+#include ""memline.h""+#include ""memory.h""+#include ""misc1.h""+#include ""misc2.h""+#include ""ex_cmds.h""+#include ""mark.h""+#include ""fileio.h""+#include ""move.h""+#include ""../window.h""+#include ""undo.h""++// Find a window that contains ""buf"" and switch to it.+// If there is no such window, use the current window and change ""curbuf"".+// Caller must initialize save_curbuf to NULL.+// restore_win_for_buf() MUST be called later!+static void switch_to_win_for_buf(buf_T *buf,+                                  win_T **save_curwinp,+                                  tabpage_T **save_curtabp,+                                  buf_T **save_curbufp);++static void restore_win_for_buf(win_T *save_curwin,+                                tabpage_T *save_curtab,+                                buf_T *save_curbuf);++// Check if deleting lines made the cursor position invalid.+// Changed the lines from ""lo"" to ""hi"" and added ""extra"" lines (negative if+// deleted).+static void fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra);++// Normalizes 0-based indexes to buffer line numbers+static int64_t normalize_index(buf_T *buf, int64_t index);++int64_t buffer_get_length(Buffer buffer, Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return 0;+  }++  return buf->b_ml.ml_line_count;+}++String buffer_get_line(Buffer buffer, int64_t index, Error *err)+{+  String rv = {.size = 0};+  StringArray slice = buffer_get_slice(buffer, index, index, true, true, err);++  if (slice.size) {+    rv = slice.items[0];+  }++  return rv;+}++void buffer_set_line(Buffer buffer, int64_t index, String line, Error *err)+{+  StringArray array = {.items = &line, .size = 1};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++void buffer_del_line(Buffer buffer, int64_t index, Error *err)+{+  StringArray array = {.size = 0};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++StringArray buffer_get_slice(Buffer buffer,+                             int64_t start,+                             int64_t end,+                             bool include_start,+                             bool include_end,+                             Error *err)+{+  StringArray rv = {.size = 0};+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return rv;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start >= end) {+    // Return 0-length array+    return rv;+  }++  rv.size = end - start;+  rv.items = xmalloc(sizeof(String) * rv.size);++  for (uint32_t i = 0; i < rv.size; i++) {+    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+    rv.items[i].size = strlen(rv.items[i].data);+  }++  return rv;+}++void buffer_set_slice(Buffer buffer,+                      int64_t start,+                      int64_t end,+                      bool include_start,+                      bool include_end,+                      StringArray replacement,+                      Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start > end) {+    set_api_error(""start > end"", err);+    return;+  }++  buf_T *save_curbuf = NULL;+  win_T *save_curwin = NULL;+  tabpage_T *save_curtab = NULL;+  uint32_t new_len = replacement.size;+  uint32_t old_len = end - start;+  uint32_t i;+  int32_t extra = 0;  // lines added to text, can be negative+  char **lines;++  if (new_len == 0) {+    // avoid allocating zero bytes+    lines = NULL;+  } else {+    lines = xcalloc(sizeof(char *), new_len);","> Why zero the memory? The following loop sets every entry in the array.:+1: Remnants from the [old code](https://github.com/b4winckler/vim/blob/master/src/if_py_both.h#L4225-L4235)> Also the usage of xcalloc() seems wrong, the arguments should be reversed.:+1: ",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/582,12632804,2014-05-14T12:26:19Z,src/api/buffer.c,"@@ -0,0 +1,413 @@+// Much of this code was adapted from 'if_py_both.h' from the original+// vim source+#include <stdint.h>+#include <stdlib.h>++#include ""api/buffer.h""+#include ""api/helpers.h""+#include ""api/defs.h""+#include ""../vim.h""+#include ""../buffer.h""+#include ""memline.h""+#include ""memory.h""+#include ""misc1.h""+#include ""misc2.h""+#include ""ex_cmds.h""+#include ""mark.h""+#include ""fileio.h""+#include ""move.h""+#include ""../window.h""+#include ""undo.h""++// Find a window that contains ""buf"" and switch to it.+// If there is no such window, use the current window and change ""curbuf"".+// Caller must initialize save_curbuf to NULL.+// restore_win_for_buf() MUST be called later!+static void switch_to_win_for_buf(buf_T *buf,+                                  win_T **save_curwinp,+                                  tabpage_T **save_curtabp,+                                  buf_T **save_curbufp);++static void restore_win_for_buf(win_T *save_curwin,+                                tabpage_T *save_curtab,+                                buf_T *save_curbuf);++// Check if deleting lines made the cursor position invalid.+// Changed the lines from ""lo"" to ""hi"" and added ""extra"" lines (negative if+// deleted).+static void fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra);++// Normalizes 0-based indexes to buffer line numbers+static int64_t normalize_index(buf_T *buf, int64_t index);++int64_t buffer_get_length(Buffer buffer, Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return 0;+  }++  return buf->b_ml.ml_line_count;+}++String buffer_get_line(Buffer buffer, int64_t index, Error *err)+{+  String rv = {.size = 0};+  StringArray slice = buffer_get_slice(buffer, index, index, true, true, err);++  if (slice.size) {+    rv = slice.items[0];+  }++  return rv;+}++void buffer_set_line(Buffer buffer, int64_t index, String line, Error *err)+{+  StringArray array = {.items = &line, .size = 1};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++void buffer_del_line(Buffer buffer, int64_t index, Error *err)+{+  StringArray array = {.size = 0};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++StringArray buffer_get_slice(Buffer buffer,+                             int64_t start,+                             int64_t end,+                             bool include_start,+                             bool include_end,+                             Error *err)+{+  StringArray rv = {.size = 0};+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return rv;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start >= end) {+    // Return 0-length array+    return rv;+  }++  rv.size = end - start;+  rv.items = xmalloc(sizeof(String) * rv.size);++  for (uint32_t i = 0; i < rv.size; i++) {+    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+    rv.items[i].size = strlen(rv.items[i].data);+  }++  return rv;+}++void buffer_set_slice(Buffer buffer,+                      int64_t start,+                      int64_t end,+                      bool include_start,+                      bool include_end,+                      StringArray replacement,+                      Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start > end) {+    set_api_error(""start > end"", err);+    return;+  }++  buf_T *save_curbuf = NULL;+  win_T *save_curwin = NULL;+  tabpage_T *save_curtab = NULL;+  uint32_t new_len = replacement.size;+  uint32_t old_len = end - start;+  uint32_t i;+  int32_t extra = 0;  // lines added to text, can be negative+  char **lines;++  if (new_len == 0) {+    // avoid allocating zero bytes+    lines = NULL;+  } else {+    lines = xcalloc(sizeof(char *), new_len);+  }++  for (i = 0; i < new_len; i++) {+    String l = replacement.items[i];+    lines[i] = xstrndup(l.data, l.size);+  }++  try_start();+  switch_to_win_for_buf(buf, &save_curwin, &save_curtab, &save_curbuf);++  if (u_save(start - 1, end) == FAIL) {+    set_api_error(""Cannot save undo information"", err);+    goto cleanup;+  }++  // If the size of the range is reducing (ie, new_len < old_len) we+  // need to delete some old_len. We do this at the start, by+  // repeatedly deleting line ""start"".+  for (i = 0; new_len < old_len && i < old_len - new_len; i++) {","> I think the reason @tarruda added it, is because if new_len > old_len, then old_len - new_len wraps around and becomes huge, therefore making the loop run for a very long time and possibly exploding the universe.:+1: . Though the loop wouldn't run for a very long time because `ml_delete` would probably fail.> This is one of the reasons I advocate using signed types of possible. Of course, size semantics are appropriate here, so the alternative solution is to be paranoid:+1:> This, in my opinion, just reads faster.Will fix in the next PR",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/582,12632859,2014-05-14T12:27:56Z,src/api/buffer.c,"@@ -0,0 +1,413 @@+// Much of this code was adapted from 'if_py_both.h' from the original+// vim source+#include <stdint.h>+#include <stdlib.h>++#include ""api/buffer.h""+#include ""api/helpers.h""+#include ""api/defs.h""+#include ""../vim.h""+#include ""../buffer.h""+#include ""memline.h""+#include ""memory.h""+#include ""misc1.h""+#include ""misc2.h""+#include ""ex_cmds.h""+#include ""mark.h""+#include ""fileio.h""+#include ""move.h""+#include ""../window.h""+#include ""undo.h""++// Find a window that contains ""buf"" and switch to it.+// If there is no such window, use the current window and change ""curbuf"".+// Caller must initialize save_curbuf to NULL.+// restore_win_for_buf() MUST be called later!+static void switch_to_win_for_buf(buf_T *buf,+                                  win_T **save_curwinp,+                                  tabpage_T **save_curtabp,+                                  buf_T **save_curbufp);++static void restore_win_for_buf(win_T *save_curwin,+                                tabpage_T *save_curtab,+                                buf_T *save_curbuf);++// Check if deleting lines made the cursor position invalid.+// Changed the lines from ""lo"" to ""hi"" and added ""extra"" lines (negative if+// deleted).+static void fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra);++// Normalizes 0-based indexes to buffer line numbers+static int64_t normalize_index(buf_T *buf, int64_t index);++int64_t buffer_get_length(Buffer buffer, Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return 0;+  }++  return buf->b_ml.ml_line_count;+}++String buffer_get_line(Buffer buffer, int64_t index, Error *err)+{+  String rv = {.size = 0};+  StringArray slice = buffer_get_slice(buffer, index, index, true, true, err);++  if (slice.size) {+    rv = slice.items[0];+  }++  return rv;+}++void buffer_set_line(Buffer buffer, int64_t index, String line, Error *err)+{+  StringArray array = {.items = &line, .size = 1};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++void buffer_del_line(Buffer buffer, int64_t index, Error *err)+{+  StringArray array = {.size = 0};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++StringArray buffer_get_slice(Buffer buffer,+                             int64_t start,+                             int64_t end,+                             bool include_start,+                             bool include_end,+                             Error *err)+{+  StringArray rv = {.size = 0};+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return rv;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start >= end) {+    // Return 0-length array+    return rv;+  }++  rv.size = end - start;+  rv.items = xmalloc(sizeof(String) * rv.size);++  for (uint32_t i = 0; i < rv.size; i++) {+    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+    rv.items[i].size = strlen(rv.items[i].data);+  }++  return rv;+}++void buffer_set_slice(Buffer buffer,+                      int64_t start,+                      int64_t end,+                      bool include_start,+                      bool include_end,+                      StringArray replacement,+                      Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start > end) {+    set_api_error(""start > end"", err);+    return;+  }++  buf_T *save_curbuf = NULL;+  win_T *save_curwin = NULL;+  tabpage_T *save_curtab = NULL;+  uint32_t new_len = replacement.size;","Forgot about adding to the `-Wconversion` list, fixing it",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/582,12633316,2014-05-14T12:42:29Z,src/api/buffer.c,"@@ -0,0 +1,413 @@+// Much of this code was adapted from 'if_py_both.h' from the original+// vim source+#include <stdint.h>+#include <stdlib.h>++#include ""api/buffer.h""+#include ""api/helpers.h""+#include ""api/defs.h""+#include ""../vim.h""+#include ""../buffer.h""+#include ""memline.h""+#include ""memory.h""+#include ""misc1.h""+#include ""misc2.h""+#include ""ex_cmds.h""+#include ""mark.h""+#include ""fileio.h""+#include ""move.h""+#include ""../window.h""+#include ""undo.h""++// Find a window that contains ""buf"" and switch to it.+// If there is no such window, use the current window and change ""curbuf"".+// Caller must initialize save_curbuf to NULL.+// restore_win_for_buf() MUST be called later!+static void switch_to_win_for_buf(buf_T *buf,+                                  win_T **save_curwinp,+                                  tabpage_T **save_curtabp,+                                  buf_T **save_curbufp);++static void restore_win_for_buf(win_T *save_curwin,+                                tabpage_T *save_curtab,+                                buf_T *save_curbuf);++// Check if deleting lines made the cursor position invalid.+// Changed the lines from ""lo"" to ""hi"" and added ""extra"" lines (negative if+// deleted).+static void fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra);++// Normalizes 0-based indexes to buffer line numbers+static int64_t normalize_index(buf_T *buf, int64_t index);++int64_t buffer_get_length(Buffer buffer, Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return 0;+  }++  return buf->b_ml.ml_line_count;+}++String buffer_get_line(Buffer buffer, int64_t index, Error *err)+{+  String rv = {.size = 0};+  StringArray slice = buffer_get_slice(buffer, index, index, true, true, err);++  if (slice.size) {+    rv = slice.items[0];+  }++  return rv;+}++void buffer_set_line(Buffer buffer, int64_t index, String line, Error *err)+{+  StringArray array = {.items = &line, .size = 1};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++void buffer_del_line(Buffer buffer, int64_t index, Error *err)+{+  StringArray array = {.size = 0};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++StringArray buffer_get_slice(Buffer buffer,+                             int64_t start,+                             int64_t end,+                             bool include_start,+                             bool include_end,+                             Error *err)+{+  StringArray rv = {.size = 0};+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return rv;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start >= end) {+    // Return 0-length array+    return rv;+  }++  rv.size = end - start;+  rv.items = xmalloc(sizeof(String) * rv.size);++  for (uint32_t i = 0; i < rv.size; i++) {+    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+    rv.items[i].size = strlen(rv.items[i].data);+  }++  return rv;+}++void buffer_set_slice(Buffer buffer,+                      int64_t start,+                      int64_t end,+                      bool include_start,+                      bool include_end,+                      StringArray replacement,+                      Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start > end) {+    set_api_error(""start > end"", err);+    return;+  }++  buf_T *save_curbuf = NULL;+  win_T *save_curwin = NULL;+  tabpage_T *save_curtab = NULL;+  uint32_t new_len = replacement.size;+  uint32_t old_len = end - start;+  uint32_t i;+  int32_t extra = 0;  // lines added to text, can be negative+  char **lines;++  if (new_len == 0) {+    // avoid allocating zero bytes+    lines = NULL;+  } else {+    lines = xcalloc(sizeof(char *), new_len);+  }++  for (i = 0; i < new_len; i++) {+    String l = replacement.items[i];+    lines[i] = xstrndup(l.data, l.size);+  }++  try_start();+  switch_to_win_for_buf(buf, &save_curwin, &save_curtab, &save_curbuf);++  if (u_save(start - 1, end) == FAIL) {+    set_api_error(""Cannot save undo information"", err);+    goto cleanup;+  }++  // If the size of the range is reducing (ie, new_len < old_len) we+  // need to delete some old_len. We do this at the start, by+  // repeatedly deleting line ""start"".+  for (i = 0; new_len < old_len && i < old_len - new_len; i++) {","> Will fix in the next PRNote that I made an error in my mockup, it should be:``` cextra -= to_delete - 1;```To maintain the same semantics as `extra -= i` from before ;)",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/582,12651857,2014-05-14T18:16:22Z,src/api/buffer.c,"@@ -0,0 +1,413 @@+// Much of this code was adapted from 'if_py_both.h' from the original+// vim source+#include <stdint.h>+#include <stdlib.h>++#include ""api/buffer.h""+#include ""api/helpers.h""+#include ""api/defs.h""+#include ""../vim.h""+#include ""../buffer.h""+#include ""memline.h""+#include ""memory.h""+#include ""misc1.h""+#include ""misc2.h""+#include ""ex_cmds.h""+#include ""mark.h""+#include ""fileio.h""+#include ""move.h""+#include ""../window.h""+#include ""undo.h""++// Find a window that contains ""buf"" and switch to it.+// If there is no such window, use the current window and change ""curbuf"".+// Caller must initialize save_curbuf to NULL.+// restore_win_for_buf() MUST be called later!+static void switch_to_win_for_buf(buf_T *buf,+                                  win_T **save_curwinp,+                                  tabpage_T **save_curtabp,+                                  buf_T **save_curbufp);++static void restore_win_for_buf(win_T *save_curwin,+                                tabpage_T *save_curtab,+                                buf_T *save_curbuf);++// Check if deleting lines made the cursor position invalid.+// Changed the lines from ""lo"" to ""hi"" and added ""extra"" lines (negative if+// deleted).+static void fix_cursor(linenr_T lo, linenr_T hi, linenr_T extra);++// Normalizes 0-based indexes to buffer line numbers+static int64_t normalize_index(buf_T *buf, int64_t index);++int64_t buffer_get_length(Buffer buffer, Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return 0;+  }++  return buf->b_ml.ml_line_count;+}++String buffer_get_line(Buffer buffer, int64_t index, Error *err)+{+  String rv = {.size = 0};+  StringArray slice = buffer_get_slice(buffer, index, index, true, true, err);++  if (slice.size) {+    rv = slice.items[0];+  }++  return rv;+}++void buffer_set_line(Buffer buffer, int64_t index, String line, Error *err)+{+  StringArray array = {.items = &line, .size = 1};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++void buffer_del_line(Buffer buffer, int64_t index, Error *err)+{+  StringArray array = {.size = 0};+  buffer_set_slice(buffer, index, index, true, true, array, err);+}++StringArray buffer_get_slice(Buffer buffer,+                             int64_t start,+                             int64_t end,+                             bool include_start,+                             bool include_end,+                             Error *err)+{+  StringArray rv = {.size = 0};+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return rv;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start >= end) {+    // Return 0-length array+    return rv;+  }++  rv.size = end - start;+  rv.items = xmalloc(sizeof(String) * rv.size);++  for (uint32_t i = 0; i < rv.size; i++) {+    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+    rv.items[i].size = strlen(rv.items[i].data);+  }++  return rv;+}++void buffer_set_slice(Buffer buffer,+                      int64_t start,+                      int64_t end,+                      bool include_start,+                      bool include_end,+                      StringArray replacement,+                      Error *err)+{+  buf_T *buf = find_buffer(buffer, err);++  if (!buf) {+    return;+  }++  start = normalize_index(buf, start) + (include_start ? 0 : 1);+  end = normalize_index(buf, end) + (include_end ? 1 : 0);++  if (start > end) {+    set_api_error(""start > end"", err);+    return;+  }++  buf_T *save_curbuf = NULL;+  win_T *save_curwin = NULL;+  tabpage_T *save_curtab = NULL;+  uint32_t new_len = replacement.size;","Yes, there is the possibility to do that with some #prama statements I think. Too bad we can't simplify doing that because you can't use preprocessor directives inside of preprocessor directives.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/717,12683474,2014-05-15T11:07:39Z,.travis.yml,"@@ -1,8 +1,33 @@ language: c env:-  - TRAVIS_BUILD_TYPE=clang/asan-  - TRAVIS_BUILD_TYPE=gcc/ia32-  - TRAVIS_BUILD_TYPE=gcc/unittest-  - TRAVIS_BUILD_TYPE=clint+  global:+    # The next declaration is the encrypted COVERITY_SCAN_TOKEN, created+    # via the ""travis encrypt"" command using the project repo's public key+    - secure: ""QEz92NyItkzQu52kCFD928jEwUYnA2OIgSyeNrp+Y3gm5rOmSZerY8hGiXyNZxocap9+qIPCapRRYU3ZYKWZPeucWMLN3aIjxAFdhugKbnmNYE1jFugb6b8N3SxiX/3206NHXlYaz0OZhh6OBAFmPUXamJC8OrWVgPNPo7wv4UQ=""+  matrix:+    - TRAVIS_BUILD_TYPE=clang/asan+    - TRAVIS_BUILD_TYPE=gcc/ia32+    - TRAVIS_BUILD_TYPE=gcc/unittest+    - TRAVIS_BUILD_TYPE=clint+addons:+  coverity_scan:+    project:+      name: neovim/neovim+      version: 1.0+      description: The main Neovim project+    notification_email: coverity@aktau.be++    # Commands to prepare for build_command+    # ** likely specific to your build **+    build_command_prepend: make build/.ran-cmake",`make cmake` would be better indeed. The thing is that the coverity script just doesn't run at all. I'm thinking of perhaps trying the way [libgit2](https://github.com/libgit2/libgit2/blob/development/.travis.yml) does it this weekend. Or do you have another idea @jszakmeister?,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/714,12683624,2014-05-15T11:12:45Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","This is the original reason why we had to declare `fpos_intmax` as a separate variable instead of doing the cast like you just did @justinmk. If we just cast, gcc complains with `comparison always true`.This is a bit nasty, as `NDEBUG` erases the assert and makes `fpos_intmax` useless...",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/717,12683706,2014-05-15T11:16:06Z,.travis.yml,"@@ -1,8 +1,33 @@ language: c env:-  - TRAVIS_BUILD_TYPE=clang/asan-  - TRAVIS_BUILD_TYPE=gcc/ia32-  - TRAVIS_BUILD_TYPE=gcc/unittest-  - TRAVIS_BUILD_TYPE=clint+  global:+    # The next declaration is the encrypted COVERITY_SCAN_TOKEN, created+    # via the ""travis encrypt"" command using the project repo's public key+    - secure: ""QEz92NyItkzQu52kCFD928jEwUYnA2OIgSyeNrp+Y3gm5rOmSZerY8hGiXyNZxocap9+qIPCapRRYU3ZYKWZPeucWMLN3aIjxAFdhugKbnmNYE1jFugb6b8N3SxiX/3206NHXlYaz0OZhh6OBAFmPUXamJC8OrWVgPNPo7wv4UQ=""+  matrix:+    - TRAVIS_BUILD_TYPE=clang/asan+    - TRAVIS_BUILD_TYPE=gcc/ia32+    - TRAVIS_BUILD_TYPE=gcc/unittest+    - TRAVIS_BUILD_TYPE=clint+addons:+  coverity_scan:+    project:+      name: neovim/neovim+      version: 1.0+      description: The main Neovim project+    notification_email: coverity@aktau.be++    # Commands to prepare for build_command+    # ** likely specific to your build **+    build_command_prepend: make build/.ran-cmake","Unfortunately, I don't at the moment... I haven't done such a thing in Travis yet.  I'll try and take a look tonight after class and see what I can dig up as well, or at least look to see what you've managed to do. :-)",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/714,12684272,2014-05-15T11:36:10Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","> So the behavior for signed types is undefined--which fits in with the rest of standard.This was my intuition for why I tried the `uintmax_t`-way. Good to know it's cleared up.> Hmmm... consider it's an abstraction that interacts with the file system, I wonder if fpos and friends really should be something else (off_t or int64_t)?There was a big discussion about that. `off_t` is kind of finicky as it has 32/64-bits issues, and #defines are necessary and don't get me started on windows. For a sample, look at the [recent large file patch](https://github.com/neovim/neovim/issues/614), where they changed `off_t` to a self-defined `off_T`. If we're going to switch to a signed type, it should be something like `off64_t` and we should take care that it's defined everywhere. Or just whatever libuv uses (`int64_t`), they've obviously been interacting with the same problem and decided that `int64_t` was a good deal.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/708,12734433,2014-05-16T11:44:02Z,src/nvim/eval.c,"@@ -9643,17 +9605,14 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;-  cwd = alloc(MAXPATHL);-  if (cwd != NULL) {-    if (os_dirname(cwd, MAXPATHL) != FAIL) {-      rettv->vval.v_string = vim_strsave(cwd);+  cwd = xmalloc(MAXPATHL);+  if (os_dirname(cwd, MAXPATHL) != FAIL) {+    rettv->vval.v_string = vim_strsave(cwd);",What's the point of copying here? Can we just change it to `rettv->vval.v_string = cwd;` and remove `free(cwd);` at the end? Or even do all the work without temporal `cwd`.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/708,12734935,2014-05-16T12:06:17Z,src/nvim/eval.c,"@@ -9643,17 +9605,14 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;-  cwd = alloc(MAXPATHL);-  if (cwd != NULL) {-    if (os_dirname(cwd, MAXPATHL) != FAIL) {-      rettv->vval.v_string = vim_strsave(cwd);+  cwd = xmalloc(MAXPATHL);+  if (os_dirname(cwd, MAXPATHL) != FAIL) {+    rettv->vval.v_string = vim_strsave(cwd);","I've already suggested a similar change (remove temp cwd), to have the best trade-of between xmalloc and overallocation. Like this:``` cstatic void f_getcwd(typval_T *argvars, typval_T *rettv){  char_u cwd[MAXPATHL];  rettv->v_type = VAR_STRING;  rettv->vval.v_string = (os_dirname(cwd, MAXPATHL) != FAIL) ? xstrdup(cwd) : NULL;#ifdef BACKSLASH_IN_FILENAME  if (rettv->vval.v_string) {    slash_adjust(rettv->vval.v_string);  }#endif}```But it wasn't changed then. Not sure where my comment went. Even though `eval.c` is going the way of the dodo, I suspect we might be carrying it around for at least another year, so it doesn't do any harm to simplify and reduce the huge linecount of the file. Even if just be a little.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/708,12747515,2014-05-16T16:32:04Z,src/nvim/eval.c,"@@ -9643,17 +9605,14 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;-  cwd = alloc(MAXPATHL);-  if (cwd != NULL) {-    if (os_dirname(cwd, MAXPATHL) != FAIL) {-      rettv->vval.v_string = vim_strsave(cwd);+  cwd = xmalloc(MAXPATHL);+  if (os_dirname(cwd, MAXPATHL) != FAIL) {+    rettv->vval.v_string = vim_strsave(cwd);",@Hinidu @aktau is it OK to leave this for another PR? I'm creating a list of code patterns that can be refactored to be more memory-efficient.  That's a good thing for an `entry-level` issue.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/708,12755681,2014-05-16T19:31:16Z,src/nvim/eval.c,"@@ -9643,17 +9605,14 @@ static void f_getcwd(typval_T *argvars, typval_T *rettv)    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;-  cwd = alloc(MAXPATHL);-  if (cwd != NULL) {-    if (os_dirname(cwd, MAXPATHL) != FAIL) {-      rettv->vval.v_string = vim_strsave(cwd);+  cwd = xmalloc(MAXPATHL);+  if (os_dirname(cwd, MAXPATHL) != FAIL) {+    rettv->vval.v_string = vim_strsave(cwd);","> @Hinidu @aktau is it OK to leave this for another PR? @philix sure, as long as we don't leave any stones unturned. This PR is massive as it is and I would personally like to see it merged ASAP.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/727,12768280,2014-05-17T12:46:49Z,src/nvim/api/buffer.c,"@@ -97,22 +97,40 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = end - start;-  rv.items = xmalloc(sizeof(String) * rv.size);+  rv.size = (size_t)(end - start);+  rv.items = xcalloc(sizeof(String), rv.size); -  for (uint32_t i = 0; i < rv.size; i++) {-    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+  for (size_t i = 0; i < rv.size; i++) {+    int64_t lnum = start + (int64_t)i;++    if (lnum > LONG_MAX) {+      set_api_error(""Line index is too high"", err);+      goto end;+    }++    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, (linenr_T)lnum, false));",Do we need the terminating `\0` in the string duplicate? `xstrdup` could be replaced with `xmemdup` wheninitializing `String` objects.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/727,12768426,2014-05-17T13:25:03Z,src/nvim/api/buffer.c,"@@ -97,22 +97,40 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = end - start;-  rv.items = xmalloc(sizeof(String) * rv.size);+  rv.size = (size_t)(end - start);+  rv.items = xcalloc(sizeof(String), rv.size); -  for (uint32_t i = 0; i < rv.size; i++) {-    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+  for (size_t i = 0; i < rv.size; i++) {+    int64_t lnum = start + (int64_t)i;++    if (lnum > LONG_MAX) {","I think `LONG_MAX` is architecture dependent, and we probably shouldn't add arch-dependent stuff in the API. What do you want to limit is to? `INT64_MAX`, but this would always be true? Or `INT32_MAX`?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/727,12768454,2014-05-17T13:34:48Z,src/nvim/api/buffer.c,"@@ -97,22 +97,40 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = end - start;-  rv.items = xmalloc(sizeof(String) * rv.size);+  rv.size = (size_t)(end - start);+  rv.items = xcalloc(sizeof(String), rv.size); -  for (uint32_t i = 0; i < rv.size; i++) {-    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+  for (size_t i = 0; i < rv.size; i++) {+    int64_t lnum = start + (int64_t)i;++    if (lnum > LONG_MAX) {","This is here because `linenr_T` is a type alias for `long`(may be 32-bit on some platforms). I agree this is wrong, I should have added a `#define LINENR_MAX LONG_MAX` next to the alias and used that instead.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/727,12768748,2014-05-17T14:34:02Z,src/nvim/api/buffer.c,"@@ -97,22 +97,40 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = end - start;-  rv.items = xmalloc(sizeof(String) * rv.size);+  rv.size = (size_t)(end - start);+  rv.items = xcalloc(sizeof(String), rv.size); -  for (uint32_t i = 0; i < rv.size; i++) {-    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+  for (size_t i = 0; i < rv.size; i++) {+    int64_t lnum = start + (int64_t)i;++    if (lnum > LONG_MAX) {+      set_api_error(""Line index is too high"", err);+      goto end;+    }++    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, (linenr_T)lnum, false));","> I did that because it saves an extra line and the memory is freed right after the response is sentTrue enough (2 extra lines in fact), but I think I must concur with @oni-link, it's still a useless `strlen()`  call. I think one or two lines is not going to make the difference. To make it even more copy-pastable ;):``` c    char *str = (char *) ml_get_buf(buf, (linenr_T) lnum, false);    size_t len = strlen(str);    rv.items[i].data = xmemdup(str, len); // do these need to be NULL-terminated?    rv.items[i].size = len;```But this could be easily abstracted into a function I think, since we use pass-by-value (which I love).``` c// alternative name ideas: stringize(), ...String cstr_to_string(const char *str) {    size_t len = strlen(str);    return (String){        .data = xmemdup(str, len),        .size = len    };}rv.items[i] = cstr_to_string((char *) ml_get_buf(buf, (linenr_T) lnum, false));```Now you have efficiency and line savings in one go ;).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/727,12768795,2014-05-17T14:39:32Z,src/nvim/api/buffer.c,"@@ -97,22 +97,40 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = end - start;-  rv.items = xmalloc(sizeof(String) * rv.size);+  rv.size = (size_t)(end - start);+  rv.items = xcalloc(sizeof(String), rv.size); -  for (uint32_t i = 0; i < rv.size; i++) {-    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+  for (size_t i = 0; i < rv.size; i++) {+    int64_t lnum = start + (int64_t)i;++    if (lnum > LONG_MAX) {+      set_api_error(""Line index is too high"", err);+      goto end;+    }++    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, (linenr_T)lnum, false));","Btw, in gcc and clang `strlen` is marked as `pure`, so we technically shouldn't have to save it in a temporary variable, the compiler will do that for us. But I don't trust other compilers...",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/727,12789131,2014-05-19T11:07:23Z,src/nvim/api/buffer.c,"@@ -97,22 +97,40 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = end - start;-  rv.items = xmalloc(sizeof(String) * rv.size);+  rv.size = (size_t)(end - start);+  rv.items = xcalloc(sizeof(String), rv.size); -  for (uint32_t i = 0; i < rv.size; i++) {-    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, start + i, false));+  for (size_t i = 0; i < rv.size; i++) {+    int64_t lnum = start + (int64_t)i;++    if (lnum > LONG_MAX) {+      set_api_error(""Line index is too high"", err);+      goto end;+    }++    rv.items[i].data = xstrdup((char *)ml_get_buf(buf, (linenr_T)lnum, false));     rv.items[i].size = strlen(rv.items[i].data);   } +end:+  if (err->set) {+    for (size_t i = 0; i < rv.size; i++) {+      if (rv.items[i].data != NULL) {+        free(rv.items[i].data);+      }+    }++    free(rv.items);","It's also not really necessary to check that `rv.items[i].data != NULL`, `free()` handles it fine.``` c  if (err->set) {    for (size_t i = 0; i < rv.size; i++) {      free(rv.items[i].data);    }    free(rv.items);    rv.items = NULL;    rv.size = 0;  }```Perhaps an `empty_string_array()` function could reduce the last two lines to 1. Or even a `free_string_array()` that does all of the above.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/757,12992796,2014-05-23T10:00:23Z,src/nvim/hashtab.c,"@@ -340,6 +337,7 @@ static int hash_may_resize(hashtab_T *ht, int minitems)       // Moving from ht_smallarray to ht_smallarray!  Happens when there       // are many removed items.  Copy the items to be able to clean up       // removed items.+      hashitem_T temparray[HT_INIT_SIZE];       memmove(temparray, newarray, sizeof(temparray));       oldarray = temparray;","I've tried to work out a simplifcation with all possible branches. What do you guys think? @oni-link and @elmart ``` c  // small -> small (temparray -> smallarray)  // big   -> small (array -> smallarray)  // small -> big   (array -> mallocarray)  // big   -> big   (array -> mallocarray)  // Check if we're moving from ht_smallarray to ht_smallarray, this can happen  // when there are many removed items. Copy the items to be able to clean up  // removed items.  oldarray = (newsize == HT_INIT_SIZE && ht->ht_array == ht->ht_smallarray)    ? memcpy(temparray, ht->ht_smallarray, sizeof(temparray)) // small -> small, make temp copy    : ht->ht_array;  // if newsize fits in the small array, copy thence, otherwise allocate a new chunk  newarray = (newsize == HT_INIT_SIZE)    ? ht->ht_smallarray // new size is small enough to fit    : xmalloc(newsize * sizeof(hashitem_T));```",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/757,12994190,2014-05-23T10:55:34Z,src/nvim/hashtab.c,"@@ -340,6 +337,7 @@ static int hash_may_resize(hashtab_T *ht, int minitems)       // Moving from ht_smallarray to ht_smallarray!  Happens when there       // are many removed items.  Copy the items to be able to clean up       // removed items.+      hashitem_T temparray[HT_INIT_SIZE];       memmove(temparray, newarray, sizeof(temparray));       oldarray = temparray;","> Which can further be reduced to:This last suggestion is almost exactly the same as my last suggestion (with the exception of `memmove` -> `memcpy`). I'm concerned about readability as well, someone else should chime in.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/757,12995414,2014-05-23T11:51:07Z,src/nvim/hashtab.c,"@@ -340,6 +337,7 @@ static int hash_may_resize(hashtab_T *ht, int minitems)       // Moving from ht_smallarray to ht_smallarray!  Happens when there       // are many removed items.  Copy the items to be able to clean up       // removed items.+      hashitem_T temparray[HT_INIT_SIZE];       memmove(temparray, newarray, sizeof(temparray));       oldarray = temparray;","I think we're talking next to each other here. What I meant was:I (aktau) think that the copy is only necessary because otherwise we would be copying from an array (smallarray) into the same array (smallaray). This is obviously bad, it would destroy what you're iterating over. It's what I meant when I said:> if src == dst everything goes haywireThe vim comment seems to suggest that if you don't to the copy, you can't clean up the items. This is not true, because in all cases except for `small -> small`, there's no need for the copy, and the removed items get filtered out just fine.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/757,13007070,2014-05-23T16:28:01Z,src/nvim/hashtab.c,"@@ -176,12 +169,14 @@ void hash_debug_results(void) #endif  // ifdef HT_DEBUG } -/// Add item with key ""key"" to hashtable ""ht"".+/// Add item for key ""key"" to hashtable ""ht"". ///-/// @param ht-/// @param key+/// @param ht  The hash table.+/// @param key Pointer to the key for the new item, the key being part of a",What does `the key being part of a bigger value` means?,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/757,13008462,2014-05-23T17:00:35Z,src/nvim/hashtab.c,"@@ -340,6 +337,7 @@ static int hash_may_resize(hashtab_T *ht, int minitems)       // Moving from ht_smallarray to ht_smallarray!  Happens when there       // are many removed items.  Copy the items to be able to clean up       // removed items.+      hashitem_T temparray[HT_INIT_SIZE];       memmove(temparray, newarray, sizeof(temparray));       oldarray = temparray;","What about changing this:```  // small -> small (temparray -> smallarray)  // big   -> small (array -> smallarray)  // small -> big   (array -> mallocarray)  // big   -> big   (array -> mallocarray)  // Check if we're moving from ht_smallarray to ht_smallarray, this can happen  // when there are many removed items. Copy the items to be able to clean up  // removed items.```into this.```  // Check if we're moving from ht_smallarray to ht_smallarray. This can happen  // when there are many removed items. In that case, copy the items to a temp  // array (if not, src and dest of the cleanup step would be the same).```",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/757,13009160,2014-05-23T17:16:50Z,src/nvim/hashtab.c,"@@ -176,12 +169,14 @@ void hash_debug_results(void) #endif  // ifdef HT_DEBUG } -/// Add item with key ""key"" to hashtable ""ht"".+/// Add item for key ""key"" to hashtable ""ht"". ///-/// @param ht-/// @param key+/// @param ht  The hash table.+/// @param key Pointer to the key for the new item, the key being part of a","It just tries to emphasize the fact that here, we don't have an independent string as the key, and another independent object as the value stored for that key. Here, the key _must_ be part of the value object. Could you suggest another wording, if that's the problem?",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/757,13017878,2014-05-23T20:35:17Z,src/nvim/hashtab.c,"@@ -340,6 +337,7 @@ static int hash_may_resize(hashtab_T *ht, int minitems)       // Moving from ht_smallarray to ht_smallarray!  Happens when there       // are many removed items.  Copy the items to be able to clean up       // removed items.+      hashitem_T temparray[HT_INIT_SIZE];       memmove(temparray, newarray, sizeof(temparray));       oldarray = temparray;","Mmm, I like that, in fact, :+1: Others?Three small things, though:- Suggested formatting does not fit in 80 chars. I propose alternative formatting below.- I changed the order of conditions in keep_small_array. Proposed way is marginally more performant.- Line before this block was:`hashitem_T *oldarray, *newarray, temparray[HT_INIT_SIZE];`. We can now inline oldarray/newarray declarations, too.With those changes, whole block results in:```  bool new_array_is_small = newsize == HT_INIT_SIZE;  bool keep_small_array = new_array_is_small    && ht->ht_array == ht->ht_smallarray;  // Make sure that oldarray and newarray do not overlap,  // so that copying is possible.  hashitem_T temparray[HT_INIT_SIZE];  hashitem_T *oldarray = keep_small_array     ? memcpy(temparray, ht->smallarray, sizeof(temparray))    : ht->ht_array;  hashitem_T *newarray = new_array_is_small    ? ht->ht_smallarray    : xmalloc(sizeof(hashitem_T) * newsize);```What about that?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/762,13030161,2014-05-25T10:39:09Z,src/nvim/os/channel.c,"@@ -124,8 +121,40 @@ void channel_from_stream(uv_stream_t *stream, ChannelProtocol prot)   // write stream   channel->data.streams.write = wstream_new(1024 * 1024);   wstream_set_stream(channel->data.streams.write, stream);-  // push to channel list-  *kl_pushp(Channel, channels) = channel;+  channel->data.streams.uv = stream;+  map_put(uint64_t)(channels, channel->id, channel);+}++bool channel_send_event(uint64_t id, char *type, typval_T *data)+{+  Channel *channel = map_get(uint64_t)(channels, id);++  if (!channel) {+    return false;+  }++  String event_type = {.size = strnlen(type, 1024), .data = type};+  Object event_data = vim_to_object(data);++  switch (channel->protocol) {+    case kChannelProtocolMsgpack:+      send_msgpack(channel, event_type, event_data);+      break;+    default:+      abort();+  }++  msgpack_rpc_free_object(event_data);","If  the type of `event_data` is `kObjectTypeString` then this string will not be freed, because `msg_rpc_free_string(value)` is an empty macro. I saw your comment about the empty macro, but in this case are we not copying _to_ msgpack?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/768,13100336,2014-05-27T20:27:18Z,src/nvim/os/channel.c,"@@ -158,15 +186,84 @@ static void parse_msgpack(RStream *rstream, void *data, bool eof)     // Perform the call     msgpack_rpc_call(channel->id, &unpacked.data, &response);     wstream_write(channel->data.streams.write,-                  xmemdup(channel->sbuffer->data, channel->sbuffer->size),-                  channel->sbuffer->size,-                  true);+                  wstream_new_buffer(channel->sbuffer->data,+                                     channel->sbuffer->size,+                                     true));      // Clear the buffer for future calls     msgpack_sbuffer_clear(channel->sbuffer);   } } +static void send_event(Channel *channel, char *type, typval_T *data)+{+  String event_type = {.size = strnlen(type, EVENT_MAXLEN), .data = type};+  Object event_data = vim_to_object(data);+  msgpack_packer packer;+  msgpack_packer_init(&packer, &msgpack_event_buffer, msgpack_sbuffer_write);+  msgpack_rpc_notification(event_type, event_data, &packer);+  WBuffer *buffer = wstream_new_buffer(msgpack_event_buffer.data,+      msgpack_event_buffer.size,+      true);",The `*_event` functions as well as the `channel_from_*` functions duplicate some code.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/768,13128588,2014-05-28T12:41:52Z,src/nvim/api/vim.c,"@@ -327,6 +328,24 @@ void vim_set_current_tabpage(Tabpage tabpage, Error *err)   try_end(err); } +void vim_subscribe(uint64_t channel_id, String event)+{+  size_t length = (event.size < EVENT_MAXLEN ? event.size : EVENT_MAXLEN);+  char e[EVENT_MAXLEN + 1];+  memcpy(e, event.data, length);+  e[length] = NUL;","> Please use xstrlcpy.That's not necessary here, as far as I can see `event` is not a c string but a binary string (not necesarily NULL-terminated). But even if it was NULL-terminated, it wouldn't be efficient to use `xstrlcpy` as that would perform `strlen` which we already have (`event.size`). Ideally, we'd be able to write:``` cchar e[EVENT_MAXLEN + 1];(x)mempcpy(e, event.data, min(EVENT_MAXLEN, length)) = NUL;```",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/768,13128712,2014-05-28T12:44:46Z,src/nvim/os/wstream.c,"@@ -59,51 +59,60 @@ void wstream_set_stream(WStream *wstream, uv_stream_t *stream)   wstream->stream = stream; } -bool wstream_write(WStream *wstream, char *buffer, uint32_t length, bool free)+bool wstream_write(WStream *wstream, WBuffer *buffer) {   WriteData *data;   uv_buf_t uvbuf;   uv_write_t *req; -  if (wstream->freed) {-    // Don't accept write requests after the WStream instance was freed-    return false;-  }+  // This should not be called after a wstream was freed+  assert(!wstream->freed); -  if (wstream->curmem + length > wstream->maxmem) {+  if (wstream->curmem + buffer->size > wstream->maxmem) {     return false;   } -  if (free) {-    // We should only account for buffers that are ours to free-    wstream->curmem += length;-  }-+  buffer->refcount++;",The `refcount` field seems to be redundant as you already have `pending_reqs`which is incremented/decremented in a similar fashion. Consider using that.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/768,13129605,2014-05-28T13:05:46Z,src/nvim/api/vim.c,"@@ -327,6 +328,24 @@ void vim_set_current_tabpage(Tabpage tabpage, Error *err)   try_end(err); } +void vim_subscribe(uint64_t channel_id, String event)+{+  size_t length = (event.size < EVENT_MAXLEN ? event.size : EVENT_MAXLEN);+  char e[EVENT_MAXLEN + 1];+  memcpy(e, event.data, length);+  e[length] = NUL;","That `(x)mempcpy(e, event.data, min(EVENT_MAXLEN, length)) = NUL;` line, though compact, is pretty opaque and should probably be abstracted behind a function. I've been meaning to import `xmempcpy` in the codebase as well, but hadn't found a use yet.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/762,13129657,2014-05-28T13:07:08Z,src/nvim/os/channel.c,"@@ -30,22 +32,26 @@ typedef struct {     struct {       RStream *read;       WStream *write;+      uv_stream_t *uv;","It's necessary for removing the libuv handle. I didn't name it 'uv_stream' because it would be redundant, since it's already inside a struct field named 'streams'. Eg- `channel->data.streams.read`- `channel->data.streams.write`- `channel->data.streams.uv`",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/762,13130516,2014-05-28T13:29:02Z,src/nvim/os/channel.c,"@@ -173,3 +196,49 @@ static void parse_msgpack(RStream *rstream, void *data, bool eof)     msgpack_sbuffer_clear(channel->proto.msgpack.sbuffer);   } }++static void send_msgpack(Channel *channel, String type, Object data)+{+  msgpack_packer packer;+  msgpack_packer_init(&packer, &msgpack_event_buffer, msgpack_sbuffer_write);+  msgpack_rpc_notification(type, data, &packer);+  char *bytes = xmemdup(msgpack_event_buffer.data, msgpack_event_buffer.size);++  wstream_write(channel->data.streams.write,+      bytes,+      msgpack_event_buffer.size,+      true);++  msgpack_sbuffer_clear(&msgpack_event_buffer);+}++static void close_channel(Channel *channel)+{+  map_del(uint64_t)(channels, channel->id);++  switch (channel->protocol) {+    case kChannelProtocolMsgpack:+      msgpack_sbuffer_free(channel->proto.msgpack.sbuffer);+      msgpack_unpacker_free(channel->proto.msgpack.unpacker);+      break;+    default:+      abort();+  }++  if (channel->is_job) {+    job_stop(channel->data.job_id);+  } else {+    rstream_free(channel->data.streams.read);+    wstream_free(channel->data.streams.write);+    uv_close((uv_handle_t *)channel->data.streams.uv, close_cb);","Instead of keeping an extra reference to the underlying `uv_stream` you could simply `uv_close` `channel->data.streams.read->stream` and set it to `NULL` here. Both approaches break encapsulation, this one has the advantage we don't have to keep an extra reference in sync with the UV streams inside `{R,W}Stream`.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/768,13130944,2014-05-28T13:39:54Z,src/nvim/api/vim.c,"@@ -327,6 +328,24 @@ void vim_set_current_tabpage(Tabpage tabpage, Error *err)   try_end(err); } +void vim_subscribe(uint64_t channel_id, String event)+{+  size_t length = (event.size < EVENT_MAXLEN ? event.size : EVENT_MAXLEN);+  char e[EVENT_MAXLEN + 1];+  memcpy(e, event.data, length);+  e[length] = NUL;","Btw @tarruda this is probably a good candidate for abstracting into a `string_to_cstr()` function.``` c///  copy a String into a char buffer of size `len` and make ///  sure it's NULL-terminated.///  NOTE: if the String contains NUL characters, the will be copied verbatim, and///  the C string will be effectively ""truncated"". The caller has to deal with that.size_t string_to_cstr_len(String str, char *restrict buf, size_t len) {  size_t min_len = (str.size < len) ? str.size : len;  memcpy(buf, str.data, min_len);  buf[min_len] = NUL;  return min_len;}```",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/768,13131225,2014-05-28T13:46:16Z,src/nvim/api/vim.c,"@@ -327,6 +328,24 @@ void vim_set_current_tabpage(Tabpage tabpage, Error *err)   try_end(err); } +void vim_subscribe(uint64_t channel_id, String event)+{+  size_t length = (event.size < EVENT_MAXLEN ? event.size : EVENT_MAXLEN);+  char e[EVENT_MAXLEN + 1];+  memcpy(e, event.data, length);+  e[length] = NUL;","> I'm not sure if it has been used for that purpose, but it would be possible. Though in that case we should stay even more away from regular C string functions and start using more mem functions. At any rate, what do you mean with str *?@aktau We should still use the `[x]str*` functions. Unfortunately they can't be used for the `data` field in the `String` type (except when the ""raw"" bytes in it are assumed to be a C string).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/768,13140591,2014-05-28T16:28:27Z,src/nvim/api/vim.c,"@@ -327,6 +328,24 @@ void vim_set_current_tabpage(Tabpage tabpage, Error *err)   try_end(err); } +void vim_subscribe(uint64_t channel_id, String event)+{+  size_t length = (event.size < EVENT_MAXLEN ? event.size : EVENT_MAXLEN);+  char e[EVENT_MAXLEN + 1];+  memcpy(e, event.data, length);+  e[length] = NUL;","I'm a big proponent of using the best possible `[x]str` function for C string manipulations. However, `Strings`'s are not C strings. That's what the `string_to_cstr_(len)` could be for, to copy it and most importantly NULL-terminate it, so that `[x]str` functions can be used on them.However, if you do already have a Pascal string (what `String` basically is), it doesn't hurt to do the operations that are fastest with Pascal strings while still in Pascal string mode. Take for example copying: it's only a `memcpy` away with Pascal strings, but for C strings one needs `xstrlcpy` which implicitly does a `strlen`, which wouldn't work on most `String`'s anyway as they're not often NULL-terminated.What I'm saying is:- have a C string? Use `[x]str` to your hearts content- have a Pascal string (`String`)? Use `mem` functions or special `String` functions and convert to C strings only when necessary.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/768,13143178,2014-05-28T17:18:56Z,src/nvim/api/vim.c,"@@ -327,6 +328,24 @@ void vim_set_current_tabpage(Tabpage tabpage, Error *err)   try_end(err); } +void vim_subscribe(uint64_t channel_id, String event)+{+  size_t length = (event.size < EVENT_MAXLEN ? event.size : EVENT_MAXLEN);+  char e[EVENT_MAXLEN + 1];+  memcpy(e, event.data, length);+  e[length] = NUL;","Perhaps `Buffer`, to keep it short but more understandable than `Raw`? Anyway, I don't have a problem with `String` myself, even though I dislike the usage of capitalized class-like identifiers in my own code, when it's used consistently it's OK.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/781,13208871,2014-05-29T22:35:32Z,src/nvim/lib/kvec.h,"@@ -53,39 +53,39 @@ int main() {  #define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x)) -#define kvec_t(type) struct { size_t n, m; type *a; }-#define kv_init(v) ((v).n = (v).m = 0, (v).a = 0)-#define kv_destroy(v) free((v).a)-#define kv_A(v, i) ((v).a[(i)])-#define kv_pop(v) ((v).a[--(v).n])-#define kv_size(v) ((v).n)-#define kv_max(v) ((v).m)+#define kvec_t(type) struct { size_t size, capacity; type *items; }+#define kv_init(v) ((v).size = (v).capacity = 0, (v).items = 0)+#define kv_destroy(v) free((v).items)+#define kv_A(v, i) ((v).items[(i)])+#define kv_pop(v) ((v).items[--(v).size])+#define kv_size(v) ((v).size)+#define kv_max(v) ((v).capacity)","I think we should keep kvec changes at minimum. `a`, `n` and `m` aren'tthat bad. Would be good variable names in a mathematical proof dealing witharrays. An array `a` of size `n` and capacity `m`.On May 29, 2014 7:12 PM, ""Justin M. Keyes"" notifications@github.com wrote:> In src/nvim/lib/kvec.h:> > > @@ -53,39 +53,39 @@ int main() {> > > >  #define kv_roundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))> > > > -#define kvec_t(type) struct { size_t n, m; type *a; }> > -#define kv_init(v) ((v).n = (v).m = 0, (v).a = 0)> > -#define kv_destroy(v) free((v).a)> > -#define kv_A(v, i) ((v).a[(i)])> > -#define kv_pop(v) ((v).a[--(v).n])> > -#define kv_size(v) ((v).n)> > -#define kv_max(v) ((v).m)> > +#define kvec_t(type) struct { size_t size, capacity; type *items; }> > +#define kv_init(v) ((v).size = (v).capacity = 0, (v).items = 0)> > +#define kv_destroy(v) free((v).items)> > +#define kv_A(v, i) ((v).items[(i)])> > +#define kv_pop(v) ((v).items[--(v).size])> > +#define kv_size(v) ((v).size)> > +#define kv_max(v) ((v).capacity)> > We should fork the klib tests> https://github.com/attractivechaos/klib/tree/master/test if we are> going to fork klib. Could be another entry-level item.> > ���> Reply to this email directly or view it on GitHub> https://github.com/neovim/neovim/pull/781/files#r13208009.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/783,13261355,2014-05-31T14:36:43Z,src/nvim/api/private/helpers.c,"@@ -318,14 +302,15 @@ tabpage_T * find_tab(Tabpage tabpage, Error *err)   return rv; } -String cstr_to_string(const char *str) {+String cstr_to_string(const char *str)+{     if (str == NULL) {         return (String) STRING_INIT;","Is this String save to use, because it does not end with a `NUL` byte.``` c#define STRING_INIT {.data = NULL, .size = 0}```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/783,13261500,2014-05-31T15:07:35Z,src/nvim/api/private/helpers.h,"@@ -87,10 +87,12 @@ win_T * find_window(Window window, Error *err); /// @return the tabpage pointer tabpage_T * find_tab(Tabpage tabpage, Error *err); -/// Copies a C string into a String (binary safe string, characters + length)+/// Copies a C string into a String (binary safe string, characters + length).+/// The resulting string is also NUL-terminated, to facilitate interoperating+/// with code using C strings. /// /// @param str the C string to copy-/// @return the resulting String, if the input string was NULL, then an+/// @return the resulting String, if the input string was NULL, an ///         empty String is returned",We have now to versions of an empty String. Both have `size == 0` but `data` can also be `!= NULL`.,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/714,13261805,2014-05-31T16:07:58Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","We could wrap it up in a helper (`ASSERT_FILE_POS`) that takes what you'vedone @aktau, but only have it do something useful when `NDEBUG` is notdefined.  That would help keep the clutter down.  The reason I didn't makethe `NDEBUG` suggestion this morning is because I wanted to see if it wouldbe useful elsewhere.  At the moment, I don't think so, but it might stillbe nice to have.On Sat, May 31, 2014 at 11:47 AM, Nicolas Hillegeer <notifications@github.com> wrote:> In src/os/rstream.c:> > > @@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)> >    // the offset argument to uv_fs_read is int64_t, could someone really try> >    // to read more than 9 quintillion (9e18) bytes?> >    // upcast is meant to avoid tautological condition warning on 32 bits> > -  uintmax_t fpos_intmax = rstream->fpos;> > -  assert(fpos_intmax <= INT64_MAX);> > -  assert((uintmax_t)rstream->fpos <= INT64_MAX);> > The only reason not to use #ifdef's is because our stated goals are to> turn this project into something beautiful and hackable. #ifdef soup is a> bit of the opposite. Any reason why an if-statement wouldn't work?> > ���> Reply to this email directly or view it on GitHub> https://github.com/neovim/neovim/pull/714/files#r13261699.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/714,13261870,2014-05-31T16:17:31Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","The reason it's there is to make the program exit whenever some rediculous amount is requested that neither neovim nor libuv knows what to do with. Of course we know that we won't be doing this in debug builds. So I just realized that this is just useful as documentation at this point, since the assert is based on user data. It should actually just be an if-test, or at least it should do something when the value is too high.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/714,13262482,2014-05-31T18:12:23Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","@aktau You're touching on another topic I wanted to bring up, but haven't had the cycles to do.  I used to hack on Subversion some time ago, which had/has a fair number of asserts in the code base.  The TortoiseSVN maintainer at the time, Stefan K��ng (who does absolutely amazing work, BTW), made a fair point.  He basically said anywhere that the code was trying to be a library (which is most of the Subversion code base), you should really avoid asserting as much as possible.  The idea being that you don't always understand the environment you're running in, and assertions could be damaging.  In his case, whenever Subversion asserted, it was would cause Explorer to die a horrible death.Don't get me wrong, I think assertions have their place, but Stefan's view has stuck in my mind ever since, especially because integration with Explorer was such an interesting use-case.  It's probably worth keeping in mind.All that said, it's probably hard to wiggle out of this function in a meaningful way and report an error without dying.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/714,13262734,2014-05-31T18:55:33Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","We'll have to tapdance around it anyhow. I've thought about these things. For example, I think using xmalloc is a terrific simplifier but the fact that it dies on overallocation isn't very good from a library perspective. We could solve this by allowing an embedding application to supply its own callback before dying or something. About the asserts: yes, this was basically asserting on user-specified input, and still dying now.  But, if the user tries to do such a thing, (s)he's got bigger things to worry about. Such as which program could possibly open a 16384 petabyte file. Not us, not us.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/714,13264323,2014-05-31T23:40:02Z,src/os/rstream.c,"@@ -235,8 +235,7 @@ static void fread_idle_cb(uv_idle_t *handle)   // the offset argument to uv_fs_read is int64_t, could someone really try   // to read more than 9 quintillion (9e18) bytes?   // upcast is meant to avoid tautological condition warning on 32 bits-  uintmax_t fpos_intmax = rstream->fpos;-  assert(fpos_intmax <= INT64_MAX);+  assert((uintmax_t)rstream->fpos <= INT64_MAX);","@aktau This callback pattern is common in libraries and is something I haveplanned. Git's xmalloc dies on OOM, but provides setters for routines thatcan free application memory and other routines that are called when OOM isunrecoverable.There should be many such configurable callbacks once neovim becomes a lib.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/788,13267078,2014-06-01T15:28:27Z,src/nvim/ex_cmds_defs.h,"@@ -5,25 +8,23 @@  * Do "":help credits"" in Vim to see a list of people who contributed.  */ +#include <stdbool.h>+ #include ""nvim/normal.h""+#include ""nvim/types.h""+#include ""nvim/vim.h""  /*  * This file defines the Ex commands.- * When DO_DECLARE_EXCMD is defined, the table with ex command names and- * options results.- * When DO_DECLARE_EXCMD is NOT defined, the enum with all the Ex commands- * results.- * This clever trick was invented by Ron Aaron.- */--/*+ *  * When adding an Ex command:- * 1. Add an entry in the table below.  Keep it sorted on the shortest- *    version of the command name that works.  If it doesn't start with a+ * 1. Add an entry in enum CMD_index below. Keep it sorted on the shortest+ *    version of the command name that works. If it doesn't start with a  *    lower case letter, add it at the end.+ * 2. Add corresponding entry in cmdnames table in ex_docmd.c.  * 2. Add a ""case: CMD_xxx"" in the big switch in ex_docmd.c.",You're right. I forgot to update list numbering. Thx. :+1:,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/790,13268063,2014-06-01T19:23:42Z,src/nvim/ops.c,"@@ -4759,17 +4760,25 @@ void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, i   }    if (name == '=') {-    char_u      *p, *s;+    size_t offset = 0;+    size_t totlen = len; -    p = vim_strnsave(str, (int)len);--    if (must_append) {-      s = concat_str(get_expr_line_src(), p);-      free(p);-      p = s;+    if (must_append && expr_line) {+      // append has been specified and expr_line already exists, so we'll+      // append the new string to expr_line.+      size_t exprlen = STRLEN(expr_line); +      totlen = exprlen + len;+      offset = exprlen;     }-    set_expr_line(p);++    // modify the global expr_line, extend/shrink it if necessary (realloc).+    // Copy the input string into the adjusted memory at the specified+    // offset.+    expr_line = xrealloc(expr_line, totlen + 1);+    memcpy(expr_line + offset, str, len);+    expr_line[totlen] = NUL;","> Wouldn't this would exceed maxlen?Yes, if `must_append` is true, then this code has the ability to exceed `maxlen` (by `strlen(expr_line)` bytes). But, as far as I can see, this was already the case in the old version of the code. That's also the reason why I kept that (admittedly strange) behaviour. I wanted to put that in the commit message, but seemingly forgot.> Interestingly, I can't find any call to write_reg_contents_ex() nor write_reg_contents() where maxlen is not -1.message.c, line 2556 (otherwise I would've removed it, for the complexity it introduces).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/790,13268167,2014-06-01T19:46:42Z,src/nvim/ops.c,"@@ -4759,17 +4760,25 @@ void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, i   }    if (name == '=') {-    char_u      *p, *s;+    size_t offset = 0;+    size_t totlen = len; -    p = vim_strnsave(str, (int)len);--    if (must_append) {-      s = concat_str(get_expr_line_src(), p);-      free(p);-      p = s;+    if (must_append && expr_line) {+      // append has been specified and expr_line already exists, so we'll+      // append the new string to expr_line.+      size_t exprlen = STRLEN(expr_line); +      totlen = exprlen + len;+      offset = exprlen;     }-    set_expr_line(p);++    // modify the global expr_line, extend/shrink it if necessary (realloc).+    // Copy the input string into the adjusted memory at the specified+    // offset.+    expr_line = xrealloc(expr_line, totlen + 1);+    memcpy(expr_line + offset, str, len);+    expr_line[totlen] = NUL;","`maxlen` probably is only used to specifiy a prefix of `str`, so I would assume `maxlen <= STRLEN(str)`.If a bigger value would be used for `maxlen`, you could get problems further down in `str_to_reg`, which uses `len` (`== maxlen, maxlen > STRLEN(str)`) to access characters in `str`.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/790,13268191,2014-06-01T19:54:00Z,src/nvim/ops.c,"@@ -4759,17 +4760,25 @@ void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, i   }    if (name == '=') {-    char_u      *p, *s;+    size_t offset = 0;+    size_t totlen = len; -    p = vim_strnsave(str, (int)len);--    if (must_append) {-      s = concat_str(get_expr_line_src(), p);-      free(p);-      p = s;+    if (must_append && expr_line) {+      // append has been specified and expr_line already exists, so we'll+      // append the new string to expr_line.+      size_t exprlen = STRLEN(expr_line); +      totlen = exprlen + len;+      offset = exprlen;     }-    set_expr_line(p);++    // modify the global expr_line, extend/shrink it if necessary (realloc).+    // Copy the input string into the adjusted memory at the specified+    // offset.+    expr_line = xrealloc(expr_line, totlen + 1);+    memcpy(expr_line + offset, str, len);+    expr_line[totlen] = NUL;","The value of `len` as suggested earlier by @oni-link does differ from the old code:``` c// old long len;  if (maxlen >= 0)    len = maxlen;  else    len = (long)STRLEN(str);// new  size_t len = STRLEN(str);  // truncate the incoming string to maxlen if necessary  if (maxlen >= 0 && len > (size_t) maxlen) {    len = (size_t) maxlen;  }```And this might have an impact on functionality. Thoughts? As @oni-link has put it, the old way might have been fundamentally dangerous if `maxlen > STRLEN(str)`. So in that regard we have fixed a bug.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/790,13269223,2014-06-02T00:11:08Z,src/nvim/ops.c,"@@ -4759,17 +4760,25 @@ void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, i   }    if (name == '=') {-    char_u      *p, *s;+    size_t offset = 0;+    size_t totlen = len; -    p = vim_strnsave(str, (int)len);--    if (must_append) {-      s = concat_str(get_expr_line_src(), p);-      free(p);-      p = s;+    if (must_append && expr_line) {+      // append has been specified and expr_line already exists, so we'll+      // append the new string to expr_line.+      size_t exprlen = STRLEN(expr_line); +      totlen = exprlen + len;+      offset = exprlen;     }-    set_expr_line(p);++    // modify the global expr_line, extend/shrink it if necessary (realloc).+    // Copy the input string into the adjusted memory at the specified+    // offset.+    expr_line = xrealloc(expr_line, totlen + 1);+    memcpy(expr_line + offset, str, len);+    expr_line[totlen] = NUL;","@aktau I looked at the code again and think we should keep the old version for the `len` computation and replace `memcpy` with `xstpncpy`. We would now only get problems, if `maxlen` would be bigger than the allocated range for `str` and `str` would not be `NUL` terminated. These problems are also present in the vim code, but we cannot detect them (**cannot** use `STRLEN`).`maxlen` seems always not to be larger than the allocated range for `str` (see the start of the only possible call chain `msg_outtrans_len_attr` -> `msg_puts_attr_len` -> `redir_write` -> `write_reg_contents` for `maxlen != -1`).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/790,13277038,2014-06-02T09:49:51Z,src/nvim/ops.c,"@@ -4759,17 +4760,25 @@ void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, i   }    if (name == '=') {-    char_u      *p, *s;+    size_t offset = 0;+    size_t totlen = len; -    p = vim_strnsave(str, (int)len);--    if (must_append) {-      s = concat_str(get_expr_line_src(), p);-      free(p);-      p = s;+    if (must_append && expr_line) {+      // append has been specified and expr_line already exists, so we'll+      // append the new string to expr_line.+      size_t exprlen = STRLEN(expr_line); +      totlen = exprlen + len;+      offset = exprlen;     }-    set_expr_line(p);++    // modify the global expr_line, extend/shrink it if necessary (realloc).+    // Copy the input string into the adjusted memory at the specified+    // offset.+    expr_line = xrealloc(expr_line, totlen + 1);+    memcpy(expr_line + offset, str, len);+    expr_line[totlen] = NUL;","So @oni-link, what you're saying is that `maxlen` is just the length of `str` if `maxlen` is specified. Ergo if `maxlen >= 0`, `str` is a Pascal string? (not NUL-terminated). Which would indeed make it unsafe to call `STRLEN`. That means we should probably call `maxlen` something else. Am I misunderstanding?> We would now only get problems, if maxlen would be bigger than the allocated range for str and str would not be NUL terminated. These problems are also present in the vim code, but we cannot detect them (cannot use STRLEN).In the old code, if `maxlen` is bigger than the allocated range we would get problems anyhow, no? Whatever we do would read into unallocated memory. For correct functioning, `maxlen` would have to be `< buflen(src)`.In the new code, we have a different failure case: the code doesn't handle the case of a Pascal string, because it tries to take `STRLEN(str)` even if `maxlen` is specified.> replace memcpy with xstpncpy.Why would we do that? `xstpncpy` actually just calls `memcpy` anyway, if you already know the length you want. If the string is not NUL-terminated or `maxlen < strlen`, it acts exactly like `mempcpy(dst, src, maxlen)`. If the string IS NUL-terminated and `strlen < maxlen`, it acts like `memset(dst + strlen(src), 0, maxlen - strlen(src)); return mempcpy(dst, src, strlen(src));`, unnecesarily filling up the string with `'\0'`.Note also that `stpncpy` doesn't necesarily NUL-terminate. Which is a shame. `xstrlcpy` is better in that regard (**EDIT**: but `xstrlcpy won't work either). We could conceivably use it like this:``` cxstpncpy(expr_line + offset, str, len)[0] = NUL;```But I'm not sure whether that's clearer.> maxlen seems always not to be larger than the allocated range for str (see the start of the only possible call chain msg_outtrans_len_attr -> msg_puts_attr_len -> redir_write -> write_reg_contents for maxlen != -1).I'm interested in just fixing this oversight instead of trying to accomodate the vim interface. I wonder how we can make this cleaner.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/790,13279287,2014-06-02T11:04:27Z,src/nvim/ops.c,"@@ -4759,17 +4760,25 @@ void write_reg_contents_ex(int name, char_u *str, int maxlen, int must_append, i   }    if (name == '=') {-    char_u      *p, *s;+    size_t offset = 0;+    size_t totlen = len; -    p = vim_strnsave(str, (int)len);--    if (must_append) {-      s = concat_str(get_expr_line_src(), p);-      free(p);-      p = s;+    if (must_append && expr_line) {+      // append has been specified and expr_line already exists, so we'll+      // append the new string to expr_line.+      size_t exprlen = STRLEN(expr_line); +      totlen = exprlen + len;+      offset = exprlen;     }-    set_expr_line(p);++    // modify the global expr_line, extend/shrink it if necessary (realloc).+    // Copy the input string into the adjusted memory at the specified+    // offset.+    expr_line = xrealloc(expr_line, totlen + 1);+    memcpy(expr_line + offset, str, len);+    expr_line[totlen] = NUL;","**UPDATE**: the documentation at `write_reg_contents` says:> - ""maxlen"" is the maximum number of bytes to use, -1 for all bytes.Which seems intellectually dishonest. If `maxlen >= 0`, that's exactly the number of bytes that will be used, not the _maximum_ number of bytes. Anyone in favor of renaming the `maxlen` argument to `len`?",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/807,13372879,2014-06-04T06:49:28Z,src/nvim/os/shell.c,"@@ -475,3 +472,329 @@ static void exit_cb(uv_process_t *proc, int64_t status, int term_signal)   data->exit_status = status;   uv_close((uv_handle_t *)proc, NULL); }++#define NELEMS(x) \+  ((sizeof(x)/sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))+#define ROUNDUP32(x) \+  (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))++typedef struct {+  uv_process_t proc;+  int64_t status;+  int *exited;+} process_data_t;++typedef struct {+  uv_write_t req;+  uv_pipe_t pipe;+  int *exited;+} write_data_t;++typedef struct {+  char buf[BUFFER_LENGTH];+  bool in_use;+} scratch_buffer_t;++typedef struct {+  char *data;+  size_t cap;+  size_t len;+} dyn_buffer_t;++typedef struct {+  uv_pipe_t pipe;+  int *exited;+  dyn_buffer_t buf;            // buffer in which to assemble all the read data+  scratch_buffer_t scratch[4]; // scratch buffers for libu+} read_data_t;++#include ""nvim/log.h""++static void on_write(uv_write_t *req, int status)+{+  write_data_t *wr = (write_data_t *) req;+  (*wr->exited)++;++  if (status) {+    // TODO(aktau): report write error+  }++  uv_close((uv_handle_t *) &wr->pipe, NULL);+}++/// need_alloc - return memory for libuv to write into+///+/// @note We don't actually allocate memory here, but return a+///       stack allocated buffer that libuv can write into. That means+///       there's no need to free this buffer in `on_read` either.+///+/// @note returning a NULL buffer will prompt libuv to call the read+///       callback with UV_ENOBUFS. We do this if all scratch buffers are in+///       use.+///+/// @note On windows, it's possible for this function to be called+///       multiple times in a row without calling the read callback. Like+///       this: alloc_cb1, alloc_cb2, read_cb1, read_cb2. We accomodate some+///       of those out-of-bound requests by using multiple scratch buffers.+///       since we don't want to start (x)malloc'ing, we can't do that+///       indefinitely.+static void on_alloc(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  read_data_t *rd = (read_data_t *) handle;++  // assign the first free buffer+  for (size_t i = 0; i < NELEMS(rd->scratch); ++i) {+    if (!rd->scratch[i].in_use) {+      buf->base = rd->scratch[i].buf;+      buf->len = sizeof(rd->scratch[i].buf);+      rd->scratch[i].in_use = true;+      return;+    }+  }++  // no free buffer found, this will provoke on_read(..., UV_ENOBUFS, ...)+  buf->base = NULL;+  buf->len = 0;+}++static void on_read(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf)+{+  DLOG(""READ DONE, result: %zd, buflen: %zu"", nread, buf->len);+  read_data_t *rd = (read_data_t *) stream;++  // handle possible errors (including failure to allocate)+  if (nread < 0) {+    switch (nread) {+      case UV_ENOBUFS:+        // the alloc callback returned a NULL buffer, which means that the+        // read was skipped, that sucks. We should at least notify.+        break;++      default:+        // error or EOF, stop reading+        (*rd->exited)++;+        uv_read_stop(stream);+        uv_close((uv_handle_t *) stream, NULL);+    }++    return;+  }++  // check if libuv is done reading for now+  if (nread == 0) {+    return;+  }++  // grow the dynamic buffer if necessary+  // TODO(aktau): extract into an ensure() function+  if (rd->buf.cap < rd->buf.len + (size_t) nread) {","It's initialized by memset(&rd, 0, sizeof(rd)). Unfortunately, clang likes to warn when I assign `= { 0 }`, which is a real bummer as it's faster and cleaner.This `dyn_buffer_t` should be folded into `kvec` I think (we already forked kvec anyway). As you can see, it uses the same growing algorithm. The reason I didn't use `kvec` is because:1. There's no macro for getting the underlying array (so you'd have to know what its name is, which is not very clean)2. There's no macro for ""ensuring"" a bigger size (there's `kv_resize` but that one doesn't do array doubling afaik)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/807,13375421,2014-06-04T08:18:03Z,src/nvim/os/shell.c,"@@ -475,3 +472,329 @@ static void exit_cb(uv_process_t *proc, int64_t status, int term_signal)   data->exit_status = status;   uv_close((uv_handle_t *)proc, NULL); }++#define NELEMS(x) \+  ((sizeof(x)/sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))+#define ROUNDUP32(x) \+  (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))++typedef struct {+  uv_process_t proc;+  int64_t status;+  int *exited;+} process_data_t;++typedef struct {+  uv_write_t req;+  uv_pipe_t pipe;+  int *exited;+} write_data_t;++typedef struct {+  char buf[BUFFER_LENGTH];+  bool in_use;+} scratch_buffer_t;++typedef struct {+  char *data;+  size_t cap;+  size_t len;+} dyn_buffer_t;++typedef struct {+  uv_pipe_t pipe;+  int *exited;+  dyn_buffer_t buf;            // buffer in which to assemble all the read data+  scratch_buffer_t scratch[4]; // scratch buffers for libu+} read_data_t;++#include ""nvim/log.h""++static void on_write(uv_write_t *req, int status)+{+  write_data_t *wr = (write_data_t *) req;+  (*wr->exited)++;++  if (status) {+    // TODO(aktau): report write error+  }++  uv_close((uv_handle_t *) &wr->pipe, NULL);+}++/// need_alloc - return memory for libuv to write into+///+/// @note We don't actually allocate memory here, but return a+///       stack allocated buffer that libuv can write into. That means+///       there's no need to free this buffer in `on_read` either.+///+/// @note returning a NULL buffer will prompt libuv to call the read+///       callback with UV_ENOBUFS. We do this if all scratch buffers are in+///       use.+///+/// @note On windows, it's possible for this function to be called+///       multiple times in a row without calling the read callback. Like+///       this: alloc_cb1, alloc_cb2, read_cb1, read_cb2. We accomodate some+///       of those out-of-bound requests by using multiple scratch buffers.+///       since we don't want to start (x)malloc'ing, we can't do that+///       indefinitely.+static void on_alloc(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  read_data_t *rd = (read_data_t *) handle;++  // assign the first free buffer+  for (size_t i = 0; i < NELEMS(rd->scratch); ++i) {+    if (!rd->scratch[i].in_use) {+      buf->base = rd->scratch[i].buf;+      buf->len = sizeof(rd->scratch[i].buf);+      rd->scratch[i].in_use = true;+      return;+    }+  }++  // no free buffer found, this will provoke on_read(..., UV_ENOBUFS, ...)+  buf->base = NULL;+  buf->len = 0;+}++static void on_read(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf)+{+  DLOG(""READ DONE, result: %zd, buflen: %zu"", nread, buf->len);+  read_data_t *rd = (read_data_t *) stream;++  // handle possible errors (including failure to allocate)+  if (nread < 0) {+    switch (nread) {+      case UV_ENOBUFS:+        // the alloc callback returned a NULL buffer, which means that the+        // read was skipped, that sucks. We should at least notify.+        break;++      default:+        // error or EOF, stop reading+        (*rd->exited)++;+        uv_read_stop(stream);+        uv_close((uv_handle_t *) stream, NULL);+    }++    return;+  }++  // check if libuv is done reading for now+  if (nread == 0) {+    return;+  }++  // grow the dynamic buffer if necessary+  // TODO(aktau): extract into an ensure() function+  if (rd->buf.cap < rd->buf.len + (size_t) nread) {+    rd->buf.cap = rd->buf.len + (size_t) nread + 1; // 1 byte for NUL+    ROUNDUP32(rd->buf.cap);+    rd->buf.data = xrealloc(rd->buf.data, rd->buf.cap);+  }++  // some bytes arrived, append them to our read buffer+  memcpy(rd->buf.data + rd->buf.len, buf->base, nread);+  rd->buf.len += nread;++  // we're able to reuse one of the scratch buffers now+  for (size_t i = 0; i < NELEMS(rd->scratch); ++i) {+    // find which one we got passed+    if (rd->scratch[i].buf == buf->base) {+      rd->scratch[i].in_use = false;+      break;+    }+  }+}++static void on_exit(uv_process_t *proc, int64_t status, int term_signal)+{+  process_data_t *pd = (process_data_t *) proc;+  pd->status = status;+  (*pd->exited)++;+  uv_close((uv_handle_t *) &pd->proc, NULL);+}++/// os_run_sync - synchronously execute a command+///+/// @param argv The argument vector, the first element must be the program+///             to execute, the last element must be NULL. Thus, this vector+///             must contain at least two elements.+/// @param input The input to the shell (NULL for no input), passed to the+///              stdin of the resulting process.+/// @param len The length of the input buffer (not used if `input` == NULL)+/// @param[out] output A pointer to to a location where the output will be+///                    allocated and stored. Will be NULL if the shell command+///                    did not output anything. Pass NULL if no+///                    output is desired. It is the callers' responsibility+///                    to free this buffer if it is not NULL.+/// @param[out] nread the number of bytes in the returned buffer (if the+///             returned buffer is not NULL)+/// @return the exit status code, traditionally 0 for success on UNIX.+int os_run_sync(char *const argv[],+                const char *input,+                size_t len,+                char **output,+                size_t *nread)+{+  assert(argv);++  if (len == 0) {+    input = NULL;+  }++  uv_loop_t *loop = uv_default_loop();","The API looks natural. :+1: to hiding the libuv plumbing. Where was the suggestion for async? I don't see how it could be async without breaking legacy plugins. If scripts need async `system()` they should use `jobstart()`.Looking at the old `get_cmd_output` and `make_filter_cmd`, it was literally building a command string to send to the shell, and `input` was send via a `<` shell redirect. `:help shelltemp` says Vim uses pipes if `shelltemp=0`, but that doesn't appear to affect `system()`.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/807,13375585,2014-06-04T08:22:57Z,src/nvim/os/shell.c,"@@ -475,3 +472,329 @@ static void exit_cb(uv_process_t *proc, int64_t status, int term_signal)   data->exit_status = status;   uv_close((uv_handle_t *)proc, NULL); }++#define NELEMS(x) \+  ((sizeof(x)/sizeof(0[x])) / ((size_t)(!(sizeof(x) % sizeof(0[x])))))+#define ROUNDUP32(x) \+  (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))++typedef struct {+  uv_process_t proc;+  int64_t status;+  int *exited;+} process_data_t;++typedef struct {+  uv_write_t req;+  uv_pipe_t pipe;+  int *exited;+} write_data_t;++typedef struct {+  char buf[BUFFER_LENGTH];+  bool in_use;+} scratch_buffer_t;++typedef struct {+  char *data;+  size_t cap;+  size_t len;+} dyn_buffer_t;++typedef struct {+  uv_pipe_t pipe;+  int *exited;+  dyn_buffer_t buf;            // buffer in which to assemble all the read data+  scratch_buffer_t scratch[4]; // scratch buffers for libu+} read_data_t;++#include ""nvim/log.h""++static void on_write(uv_write_t *req, int status)+{+  write_data_t *wr = (write_data_t *) req;+  (*wr->exited)++;++  if (status) {+    // TODO(aktau): report write error+  }++  uv_close((uv_handle_t *) &wr->pipe, NULL);+}++/// need_alloc - return memory for libuv to write into+///+/// @note We don't actually allocate memory here, but return a+///       stack allocated buffer that libuv can write into. That means+///       there's no need to free this buffer in `on_read` either.+///+/// @note returning a NULL buffer will prompt libuv to call the read+///       callback with UV_ENOBUFS. We do this if all scratch buffers are in+///       use.+///+/// @note On windows, it's possible for this function to be called+///       multiple times in a row without calling the read callback. Like+///       this: alloc_cb1, alloc_cb2, read_cb1, read_cb2. We accomodate some+///       of those out-of-bound requests by using multiple scratch buffers.+///       since we don't want to start (x)malloc'ing, we can't do that+///       indefinitely.+static void on_alloc(uv_handle_t *handle, size_t suggested, uv_buf_t *buf)+{+  read_data_t *rd = (read_data_t *) handle;++  // assign the first free buffer+  for (size_t i = 0; i < NELEMS(rd->scratch); ++i) {+    if (!rd->scratch[i].in_use) {+      buf->base = rd->scratch[i].buf;+      buf->len = sizeof(rd->scratch[i].buf);+      rd->scratch[i].in_use = true;+      return;+    }+  }++  // no free buffer found, this will provoke on_read(..., UV_ENOBUFS, ...)+  buf->base = NULL;+  buf->len = 0;+}++static void on_read(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf)+{+  DLOG(""READ DONE, result: %zd, buflen: %zu"", nread, buf->len);+  read_data_t *rd = (read_data_t *) stream;++  // handle possible errors (including failure to allocate)+  if (nread < 0) {+    switch (nread) {+      case UV_ENOBUFS:+        // the alloc callback returned a NULL buffer, which means that the+        // read was skipped, that sucks. We should at least notify.+        break;++      default:+        // error or EOF, stop reading+        (*rd->exited)++;+        uv_read_stop(stream);+        uv_close((uv_handle_t *) stream, NULL);+    }++    return;+  }++  // check if libuv is done reading for now+  if (nread == 0) {+    return;+  }++  // grow the dynamic buffer if necessary+  // TODO(aktau): extract into an ensure() function+  if (rd->buf.cap < rd->buf.len + (size_t) nread) {+    rd->buf.cap = rd->buf.len + (size_t) nread + 1; // 1 byte for NUL+    ROUNDUP32(rd->buf.cap);+    rd->buf.data = xrealloc(rd->buf.data, rd->buf.cap);+  }++  // some bytes arrived, append them to our read buffer+  memcpy(rd->buf.data + rd->buf.len, buf->base, nread);+  rd->buf.len += nread;++  // we're able to reuse one of the scratch buffers now+  for (size_t i = 0; i < NELEMS(rd->scratch); ++i) {+    // find which one we got passed+    if (rd->scratch[i].buf == buf->base) {+      rd->scratch[i].in_use = false;+      break;+    }+  }+}++static void on_exit(uv_process_t *proc, int64_t status, int term_signal)+{+  process_data_t *pd = (process_data_t *) proc;+  pd->status = status;+  (*pd->exited)++;+  uv_close((uv_handle_t *) &pd->proc, NULL);+}++/// os_run_sync - synchronously execute a command+///+/// @param argv The argument vector, the first element must be the program+///             to execute, the last element must be NULL. Thus, this vector+///             must contain at least two elements.+/// @param input The input to the shell (NULL for no input), passed to the+///              stdin of the resulting process.+/// @param len The length of the input buffer (not used if `input` == NULL)+/// @param[out] output A pointer to to a location where the output will be+///                    allocated and stored. Will be NULL if the shell command+///                    did not output anything. Pass NULL if no+///                    output is desired. It is the callers' responsibility+///                    to free this buffer if it is not NULL.+/// @param[out] nread the number of bytes in the returned buffer (if the+///             returned buffer is not NULL)+/// @return the exit status code, traditionally 0 for success on UNIX.+int os_run_sync(char *const argv[],+                const char *input,+                size_t len,+                char **output,+                size_t *nread)+{+  assert(argv);++  if (len == 0) {+    input = NULL;+  }++  uv_loop_t *loop = uv_default_loop();","Yes, after grokking `get_cmd_output` and `make_filter_cmd` all I could think was: what a mess.I think `system()` can't benefit from async (at least not without explicit callback support in VimL, thus possibly adding a `system_async()` call as we can't change `system()`). For filtering `!range` it could be nice to provide continuous updates for very long running commands though. That should probably be another function: `os_run_async()`, which would conform more to @tarruda's suggested interface. The optimal case for filtering huge files is actually async both ways: with a write callback and a read callback. Perhaps I can layer that in somewhere.Note that in my opinion, when on requires async, one can't inherit the neovim FD's, so that will hopefully allows us to separate some concerns and hide the complexity of the implementation, providing more code reuse.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/787,13495430,2014-06-06T15:31:43Z,src/nvim/getchar.c,"@@ -3803,7 +3796,7 @@ char_u *vim_strsave_escape_csi(char_u *p)  * Remove escaping from CSI and K_SPECIAL characters.  Reverse of  * vim_strsave_escape_csi().  Works in-place.  */-void vim_unescape_csi(char_u *p)+void vim_unescape_csi(char_u *p) FUNC_ATTR_NONNULL_RET",My mistake. Wrongly assumed by looking at the name of the function in the commit list.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/823,13531173,2014-06-09T07:21:21Z,src/nvim/api/buffer.c,"@@ -214,14 +206,15 @@ void buffer_set_slice(Buffer buffer,   // new old_len. This is a more efficient operation, as it requires   // less memory allocation and freeing.   size_t to_replace = old_len < new_len ? old_len : new_len;++  if ((int64_t)to_replace > LONG_MAX - start) {",The old code still replaced lines until the first bad index was reached.,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/823,13531441,2014-06-09T07:37:46Z,src/nvim/api/buffer.c,"@@ -114,31 +114,23 @@ StringArray buffer_get_slice(Buffer buffer,     return rv;   } -  rv.size = (size_t)(end - start);+  size_t last_index = (size_t)(end - start);++  if ((int64_t)last_index > LONG_MAX - start) {",In the previous version maximum checked number was `last_index - 1` because `i < rv.size`.And this condition can be simplified because `last_index = end - start` so we can check `end - 1 > LONG_MAX`. `end - 1` is the biggest value of `lnum` in the loop.I'm not sure that such check can be true because `end` is `int64_t`. Maybe we don't need it at all?,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/743,13550324,2014-06-09T16:41:02Z,src/nvim/memory.c,"@@ -292,6 +292,8 @@ size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)         dst[len] = '\0';     } +    DLOG(""ratio: (%zu/%zu) %Lf"", ret, size, (long double) ret/size);",Let's log only when `ret != size - 1` which happens due to bigger buffer or truncation.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/743,13555705,2014-06-09T18:18:08Z,src/nvim/memory.c,"@@ -292,6 +292,8 @@ size_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size)         dst[len] = '\0';     } +    DLOG(""ratio: (%zu/%zu) %Lf"", ret, size, (long double) ret/size);","> Yeah, the first could be a DLOG suggesting memcpy/stracpy. The second case a WLOG and the third a DLOG as we (I?) are somehow worried that the codebase relies on strncpys zero-filling behavior.I agree with the sentiment. There are probably also cases we can't easily detect from inside `xstrlcpy`. Such as when the passed-in `size` argument is actually smaller than the buffer, which probably indicates that the truncation was deliberate and the user just wanted to copy a substring (which would indicate that stracpy is more appropriate). However, to be able to quickly track down these callsites, we'd have to macro'ize xstrlcpy or make some sort of macro hiding the xstrlcpy symbol (otherwise it'll be difficult to find where it came from). Not sure which is more doable (or even preferable).Another thing is that there are of course many perfectly legitimate uses of xstrlcpy (more than there are legitimate uses of strncpy), and by logging everything like that we'll fetch a lot of false positives.I worry about the zero-filling behaviour too, but what we don't even have full coverage let alone a broad spectrum of input strings in the tests. I hope I'll come up with some way to be (more) sure.**UPDATE**: I think I've swayed myself to the conclusion that we can use these logs to rectify vim's code and use the proper string or memory function. But to leave it out of a ""real"" build (master branch).> By separating the cases like this I can turn off debug level messages in the nvim that I use for everything (yep, I install nvim's Debug build on my system).I'll also be able to do this once Python support is up-and-performant. I've regrettably become addicted to vim-easytags, who's vim implementation is one billion times slower than its python implementation, making me unable to edit documents.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/827,13579930,2014-06-10T06:55:10Z,src/nvim/testdir/test10a.in,"@@ -37,7 +37,7 @@ at line number 16 in file SYS$DISK:XTESTFILE  some other error somewhere here. ...........................^-%CC-W-WARRING, Sorry, but no expalnation for such an warring.+%CC-W-WARRING, Sorry, but no explanation for such a warring.",Avoid changing test input files. They're deprecated anyway.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/774,13687581,2014-06-12T04:57:26Z,src/nvim/screen.c,"@@ -1610,10 +1610,10 @@ static void win_update(win_T *wp)       /*        * Last line isn't finished: Display ""@@@"" at the end.        */-      screen_fill(W_WINROW(wp) + wp->w_height - 1,-          W_WINROW(wp) + wp->w_height,-          (int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),-          '@', '@', hl_attr(HLF_AT));+      screen_fill(wp->w_winrow + wp->w_height - 1,+                  wp->w_winrow + wp->w_height,+                  wp->w_wincol + wp->w_width - 3, wp->w_wincol + wp->w_width,","Besides the verbosity of the now-expanded macro, we're losing some semantic information here. If it were only a couple cases, I wouldn't mind, but there are several. I think `W_ENDCOL` macro should not be removed. ",
1126580,epmatsw,https://api.github.com/repos/neovim/neovim/pulls/827,13697513,2014-06-12T11:55:19Z,src/nvim/message.c,"@@ -1201,7 +1201,7 @@ void msg_make(char_u *arg) }  /*- * Output the string 'str' upto a NUL character.+ * Output the string 'str' up to a NUL character.","I didn't think about that. I have removed most of the 'upto'->'up to' changes, but I left a couple that seemed to be used in a non-technical sense.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/839,13759837,2014-06-13T16:44:35Z,src/nvim/ex_cmds2.c,"@@ -792,15 +783,11 @@ char * profile_msg(proftime_T *tm)  */ void profile_setlimit(long msec, proftime_T *tm)","I think it is good idea to get rid of `long` here: it is guaranteed to have only 32 bits, while we need 64. If it is 32 bit than `msec * 1000000L` will overflow if you set timeout in `search()` to slightly more then 2 seconds.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/839,13760516,2014-06-13T16:58:21Z,src/nvim/ex_cmds2.c,"@@ -792,15 +783,11 @@ char * profile_msg(proftime_T *tm)  */ void profile_setlimit(long msec, proftime_T *tm)",It will be 32-bit on windows indeed. But I wouldn't change the prototype of the function just yet (a bit more invasive since it's called with `long` globals and whatnot). How about this:``` c    *tm = uv_hrtime() + ((proftime_T) msec * 1000000ULL);```That should (I think) make it not overflow unless for extremely high values.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/839,13761461,2014-06-13T17:20:49Z,src/nvim/ex_cmds2.c,"@@ -751,15 +751,7 @@ void profile_start(proftime_T *tm)  */ void profile_end(proftime_T *tm) {-  proftime_T now;--  gettimeofday(&now, NULL);-  tm->tv_usec = now.tv_usec - tm->tv_usec;-  tm->tv_sec = now.tv_sec - tm->tv_sec;-  if (tm->tv_usec < 0) {-    tm->tv_usec += 1000000;-    --tm->tv_sec;-  }+  *tm = uv_hrtime() - *tm;",I guess I was being lazy and assuming that any reasonable implementation would not return a time close to the overflow time...,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/839,13761909,2014-06-13T17:30:01Z,src/nvim/ex_cmds2.c,"@@ -751,15 +751,7 @@ void profile_start(proftime_T *tm)  */ void profile_end(proftime_T *tm) {-  proftime_T now;--  gettimeofday(&now, NULL);-  tm->tv_usec = now.tv_usec - tm->tv_usec;-  tm->tv_sec = now.tv_sec - tm->tv_sec;-  if (tm->tv_usec < 0) {-    tm->tv_usec += 1000000;-    --tm->tv_sec;-  }+  *tm = uv_hrtime() - *tm;","I remember some story about a counter in a linux kernel that was intentionally initialized to overflow soon to force everybody check for overflows (as that was already causing bugs in systems with very long uptime) (have not saved any references, but Google knows everything: http://stackoverflow.com/questions/24168642/why-are-jiffies-initialized-at-300000-5-minutes). `struct timespec` is not designed to overflow and there are no references that anybody should check for overflows, but we are using conversion to `uint64_t` and you cannot guarantee that `clock_gettime` will not return time a few hundred years off compared to uptime to force some other bugs to appear somewhere in the future: few centuries are completely not enough to overflow `tv_sec`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/743,13773839,2014-06-13T22:05:44Z,src/nvim/screen.c,"@@ -5083,11 +5083,11 @@ win_redr_custom (    /* Make all characters printable. */   p = transstr(buf);-  vim_strncpy(buf, p, sizeof(buf) - 1);+  len = STRLCPY(buf, p, sizeof(buf));+  len = (size_t)len < sizeof(buf) ? len : (int)sizeof(buf) - 1;","Does anyone else find this pattern too confusing, just to save a couple lines? I've seen it in other commits, maybe it's an idiom that I need to get used to.",
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/846,13782028,2014-06-14T17:50:50Z,src/nvim/os/fs.c,"@@ -146,6 +147,21 @@ static bool is_executable_in_path(const char_u *name)   return false; } +//If successful, open() returns a file descriptor (non-negative integer).+//Returns -1 on failure, and sets errno to indicate the error.+//TODO(jkeyes): refactor call sites?","`os_get_file_info` doesn't open the file, it only reads file system metadata => `os_open` is needed.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/839,13792114,2014-06-16T05:22:25Z,src/nvim/macros.h,"@@ -148,4 +148,74 @@  # define RESET_BINDING(wp)  (wp)->w_p_scb = FALSE; (wp)->w_p_crb = FALSE +// some compilers don't properly support short-circuiting apparently, giving+// ugly syntax errors when using things like defined(__clang__) &&+// defined(__has_feature) && __has_feature(...).+#ifndef __has_feature+  #define __has_feature(x) 0+#endif++#ifndef __has_extension+  #define __has_extension __has_feature+#endif++/// STATIC_ASSERT(condition, message) - assert at compile time if !cond+///+/// example:+///  STATIC_ASSERT(sizeof(void *) == 8, ""need 64-bits mode"");+///++// define STATIC_ASSERT as C11's _Static_assert whenever either C11 mode is+// detected or the compiler is known to support it. Note that Clang in C99+// mode defines __has_feature(c_static_assert) as false and+// __has_extension(c_static_assert) as true. Meaning it does support it, but+// warns. Since we prefer the clearer messages we get from _Static_assert,+// we suppress the warnings temporarily.++// the easiest case, when the mode is C11 (generic compiler) or Clang+// advertises support for c_static_assert+#if __STDC_VERSION__ >= 201112L || __has_feature(c_static_assert)+  #define STATIC_ASSERT(cond, msg) _Static_assert(cond, msg)+// if we're dealing with gcc >= 4.6 in C99 mode, we can still use+// _Static_assert but we need to suppress warnings, this is pretty ugly.+#elif (!defined(__clang__) && !defined(__INTEL_COMPILER)) && \+  __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)+  #define STATIC_ASSERT(cond, msg) \+    _Pragma(""GCC diagnostic push"") \+    _Pragma(""GCC diagnostic ignored \""-pedantic\"""") \+    _Static_assert(cond, msg); \+    _Pragma(""GCC diagnostic pop"") \++// the same goes for clang in C99 mode.+#elif defined(__clang__) && __has_extension(c_static_assert)+  #define STATIC_ASSERT(cond, msg) \+    _Pragma(""clang diagnostic push"") \+    _Pragma(""clang diagnostic ignored \""-Wc11-extensions\"""") \+    _Static_assert(cond, msg); \+    _Pragma(""clang diagnostic pop"") \++// TODO(aktau): verify that this works, don't have MSVC on hand.+#elif _MSC_VER >= 1600+  #define STATIC_ASSERT(cond, msg) static_assert(cond, msg)++// fallback for compilers that don't support _Static_assert or static_assert+// not as pretty but gets the job done. Credit goes to P��draig Brady and+// contributors.+#else+  #define ASSERT_CONCAT_(a, b) a##b+  #define ASSERT_CONCAT(a, b) ASSERT_CONCAT_(a, b)+  // These can't be used after statements in c89.+  #ifdef __COUNTER__+    #define STATIC_ASSERT(e,m) \+      { enum { ASSERT_CONCAT(static_assert_, __COUNTER__) = 1/(!!(e)) }; }+  #else+    // This can't be used twice on the same line so ensure if using in headers+    // that the headers are not included twice (by wrapping in #ifndef...#endif)+    // Note it doesn't cause an issue when used on same line of separate modules+    // compiled with gcc -combine -fwhole-program.+    #define STATIC_ASSERT(e,m) \+      { enum { ASSERT_CONCAT(assert_line_, __LINE__) = 1/(!!(e)) }; }+  #endif+#endif+","`macros.h`, `misc.h`, `structs.h`... are really bad file names as they become huge and confusing. Please create an `assert.h` (or something like it) to place the `ASSERT_*` macros in it from the beginning.",
667180,saimen,https://api.github.com/repos/neovim/neovim/pulls/823,13793183,2014-06-16T06:49:26Z,src/nvim/api/buffer.c,"@@ -214,14 +206,15 @@ void buffer_set_slice(Buffer buffer,   // new old_len. This is a more efficient operation, as it requires   // less memory allocation and freeing.   size_t to_replace = old_len < new_len ? old_len : new_len;++  if ((int64_t)to_replace > LONG_MAX - start) {","Looking further into this I think it won't be easy to keep the former behaviour with the range check outside the loop. I came up with the following wich seems to be equivalent to the former code:``` cbool out_of_range_error = false;if ((int64_t)to_replace > LONG_MAX - start) {  to_replace = LONG_MAX - start;  out_of_range_error = true;}size_t i;for(i = 0; i < to_replace, i++) {  int64_t lnum = start + (int64_t)i;  if (ml_replace((linenr_T)lnum, (char_u *)lines[i], false) == FAIL) {    set_api_error(""Cannot replace line"", err);    goto end;  }}if (out_of_range_error) {  set_api_error(""Index value is too high"", err);  goto end;}lines[i] = NULL;```I don't really like this solution becaue it scatters the detection of the error and the actions to take. In my opinion those things belong in one place.I think it's preferable to break up with the former behaviour instead of trying to stay compatible. As far as I see it we do not have to keep the API stable before a first stable release or at least a formal API freeze. If however general consesus is to stay compatible to the former solution I don't mind to change the code as proposed.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/823,13909956,2014-06-18T11:16:09Z,src/nvim/api/buffer.c,"@@ -214,14 +206,15 @@ void buffer_set_slice(Buffer buffer,   // new old_len. This is a more efficient operation, as it requires   // less memory allocation and freeing.   size_t to_replace = old_len < new_len ? old_len : new_len;++  if ((int64_t)to_replace > LONG_MAX - start) {","Yes, I also would like to see the parameters verified at the start and return in case of error:Here is what I would check for:- Check if `new_len` <= LONG_MAX (otherwise new slice is to big)- Check if `start,end` are in `{0,..,buf->b_ml.ml_line_count}` after ""normalization"" (otherwise invalid old slice)- Check if `start <= end`- Check if `buf->b_ml.ml_line_count + (new_len - old_len) <= LONG_MAX` (otherwise new slice is to big)After that no range checks should be needed anymore.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/824,13943457,2014-06-18T22:09:42Z,Doxyfile,"@@ -892,13 +892,13 @@ HTML_FILE_EXTENSION    = .html # have to redo this when upgrading to a newer version of doxygen or when # changing the value of configuration settings such as GENERATE_TREEVIEW! -HTML_HEADER            =+HTML_HEADER            = documentation/theme/header.html","All of these newly-added files should probably go in `contrib/`: https://github.com/neovim/neovim/tree/master/contribThere was a long discussion about where to support files for third party tools, and that's what we landed on. It would be confusing to have a `documentation/` directory which does not actually contain documentation in it. (Most devs won't build doxygen locally, only the build bot... :)",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/869,13987329,2014-06-19T19:10:29Z,src/nvim/memory.h,"@@ -2,7 +2,123 @@ #define NVIM_MEMORY_H  #include <stddef.h>+#include <string.h>+#include <stdbool.h>+ #include ""nvim/vim.h""+#include ""func_attr.h""++/// xmemcpyz - memcpy that always NUL-terminates the destination buffer+///+/// copies `len` bytes from `src` to `dst` and adds a NUL byte. `dst` must+/// large enough to hold `n` + 1 bytes.+///+/// @return the destination buffer+static inline char *xmemcpyz(char *restrict dst,+                             const char *restrict src,+                             size_t len)+    FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET+{+  memcpy(dst, src, len);+  dst[len] = '\0';+  return dst;+}++/// xstrucpy - copy min(`strsize`, `bufsize` - 1) bytes, NUL terminates+///+/// Returns the number of bytes written (not counting the NUL byte).  If the+/// string length is known, this function provides a few advantages over+/// `(x)strlcpy`:+///+/// 1. Usually we want to know if truncation happened, not by how much.+///    Truncation happens when the `src` string is larger than the `dst` buffer.+///    In this case, xstrucpy will return a number smaller than `strsize`.+/// 2. `(x)strlcpy` calculates `strlen`, which is sometimes already known.+/// 3. `xstrucpy` can be used with Pascal strings (non-NUL terminated strings).+/// 4. It saves one from having to manually type `if (strlen(str) > ...)`.+///+/// Example:+///+/// @code{.c}+///   if (xstrucpy(buf, str, bufsize, str_len) < str_len) {+///     // truncation happened, deal with it+///   }+/// @endcode+///+/// @return the number of bytes copied (without the NUL terminator)+///+/// @see xstrlcpy+static inline size_t xstrucpy(char *restrict dst,+                              const char *restrict src,+                              size_t bufsize,+                              size_t strsize)+    FUNC_ATTR_NONNULL_ALL+{+  size_t cpy = (strsize < bufsize) ? strsize : bufsize - 1;++  if (cpy) {","We need further requirements, like `bufsize > 0`, otherwise `cpy` could get big if `strsize >= bufsize`.Then we could always `NUL` terminate without the `if` check.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/869,13988737,2014-06-19T19:36:42Z,src/nvim/memory.h,"@@ -2,7 +2,123 @@ #define NVIM_MEMORY_H  #include <stddef.h>+#include <string.h>+#include <stdbool.h>+ #include ""nvim/vim.h""+#include ""func_attr.h""++/// xmemcpyz - memcpy that always NUL-terminates the destination buffer+///+/// copies `len` bytes from `src` to `dst` and adds a NUL byte. `dst` must+/// large enough to hold `n` + 1 bytes.+///+/// @return the destination buffer+static inline char *xmemcpyz(char *restrict dst,+                             const char *restrict src,+                             size_t len)+    FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET+{+  memcpy(dst, src, len);+  dst[len] = '\0';+  return dst;+}++/// xstrucpy - copy min(`strsize`, `bufsize` - 1) bytes, NUL terminates+///+/// Returns the number of bytes written (not counting the NUL byte).  If the+/// string length is known, this function provides a few advantages over+/// `(x)strlcpy`:+///+/// 1. Usually we want to know if truncation happened, not by how much.+///    Truncation happens when the `src` string is larger than the `dst` buffer.+///    In this case, xstrucpy will return a number smaller than `strsize`.+/// 2. `(x)strlcpy` calculates `strlen`, which is sometimes already known.+/// 3. `xstrucpy` can be used with Pascal strings (non-NUL terminated strings).+/// 4. It saves one from having to manually type `if (strlen(str) > ...)`.+///+/// Example:+///+/// @code{.c}+///   if (xstrucpy(buf, str, bufsize, str_len) < str_len) {+///     // truncation happened, deal with it+///   }+/// @endcode+///+/// @return the number of bytes copied (without the NUL terminator)+///+/// @see xstrlcpy+static inline size_t xstrucpy(char *restrict dst,+                              const char *restrict src,+                              size_t bufsize,+                              size_t strsize)+    FUNC_ATTR_NONNULL_ALL+{+  size_t cpy = (strsize < bufsize) ? strsize : bufsize - 1;++  if (cpy) {","I don't see this appearing on the web interface so I'll respond via mail:Yep, right again. How do you feel about an assert? Passing a 0-sized bufferis probably a programming error. It will be disabled for release buildsthen.On Thu, Jun 19, 2014 at 9:10 PM, oni-link notifications@github.com wrote:> In src/nvim/memory.h:> > > +///     // truncation happened, deal with it> > +///   }> > +/// @endcode> > +///> > +/// @return the number of bytes copied (without the NUL terminator)> > +///> > +/// @see xstrlcpy> > +static inline size_t xstrucpy(char *restrict dst,> > -                              const char *restrict src,> > -                              size_t bufsize,> > -                              size_t strsize)> > -    FUNC_ATTR_NONNULL_ALL> >   +{> > -  size_t cpy = (strsize < bufsize) ? strsize : bufsize - 1;> >   +> > -  if (cpy) {> > We need further requirements, like bufsize > 0, otherwise cpy could get> big if strsize >= bufsize.> Then we could always NUL terminate without the if check.> > ���> Reply to this email directly or view it on GitHub> https://github.com/neovim/neovim/pull/869/files#r13987329.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/872,14050280,2014-06-21T16:01:36Z,src/nvim/os/channel.c,"@@ -348,10 +526,67 @@ static WBuffer *serialize_event(char *type, Object data) static Channel *register_channel() {   Channel *rv = xmalloc(sizeof(Channel));+  rv->enabled = true;+  rv->rpc_call_level = 0;   rv->unpacker = msgpack_unpacker_new(MSGPACK_UNPACKER_INIT_BUFFER_SIZE);   rv->sbuffer = msgpack_sbuffer_new();   rv->id = next_id++;   rv->subscribed_events = pmap_new(cstr_t)();+  rv->next_request_id = 1;+  kv_init(rv->call_stack);   pmap_put(uint64_t)(channels, rv->id, rv);   return rv; }++static bool is_rpc_response(msgpack_object *obj)+{+  return obj->type == MSGPACK_OBJECT_ARRAY+      && obj->via.array.size == 4+      && obj->via.array.ptr[0].type == MSGPACK_OBJECT_POSITIVE_INTEGER+      && obj->via.array.ptr[0].via.u64 == 1+      && obj->via.array.ptr[1].type == MSGPACK_OBJECT_POSITIVE_INTEGER;+}++static bool is_valid_rpc_response(msgpack_object *obj, Channel *channel)+{+  uint64_t response_id = obj->via.array.ptr[1].via.u64;+  // Must be equal to the frame at the stack's bottom+  return response_id == kv_A(channel->call_stack,+                             kv_size(channel->call_stack) - 1)->request_id;+}++static void call_stack_pop(msgpack_object *obj, Channel *channel)+{+  ChannelCallFrame *frame = kv_A(channel->call_stack,+                                 kv_size(channel->call_stack) - 1);+  frame->errored = obj->via.array.ptr[2].type != MSGPACK_OBJECT_NIL;+  (void)kv_pop(channel->call_stack);++  if (frame->errored) {+    msgpack_rpc_to_object(&obj->via.array.ptr[2], &frame->result);+  } else {+    msgpack_rpc_to_object(&obj->via.array.ptr[3], &frame->result);+  }+}++static void call_stack_unwind(Channel *channel, char *msg)+{+  for (size_t i = 0; i < kv_size(channel->call_stack); i++) {+    ChannelCallFrame *frame = kv_A(channel->call_stack, i);+    frame->errored = true;+    (void)kv_pop(channel->call_stack);+    frame->result = STRING_OBJ(msg);+  }","Here we start modifying elements from the beginning of the vector, but at the same time removing elements from the end. The removed elements are not modified, because the vector size in the loop condition is not constant.Would be nice to have a `kv_clear` that sets the size of the vector to zero, so no `kv_pop` would be needed here.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/880,14102173,2014-06-23T21:47:50Z,src/nvim/line_consumption.c,"@@ -0,0 +1,230 @@+#include ""nvim/vim.h""+#include ""nvim/buffer_defs.h""+#include ""nvim/diff.h""+#include ""nvim/fold.h""+#include ""nvim/memline.h""+#include ""nvim/charset.h""+#include ""nvim/move.h""+#include ""nvim/line_consumption.h""+#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""line_consumption.c.generated.h""+#endif+/// Functions to determine physical line consumption of real lines+///+/// Throughout this file the terminology is:+/// - physical line: the amount of lines on the screen.+/// - real line: text in a file between two newline characters+///+///+/// There are several situations where a real line can take up several lines on+/// screen. This is especially true if the 'wrap' option is activated.+///+/// The contrary, several real lines consuming less physical lines on the screen+/// becomes true if 'folding' is used.+///+/// This file provides functions that determine the amount of physical lines+/// used by real lines, considering these factors.+++/// Gets the physical line count consumed by a real line in current window+///+/// @param lnum Linenumber of buffer+///+/// @return The physical line count+size_t plines(linenr_T lnum)+  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT","Don't we need all functions to be pure, that will be called from this function?Call chain: `plines_win -> diff_check_fill -> diff_check -> ex_diffupdate -> diff_clear -> free`",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/880,14118098,2014-06-24T08:32:04Z,src/nvim/line_consumption.c,"@@ -0,0 +1,230 @@+#include ""nvim/vim.h""+#include ""nvim/buffer_defs.h""+#include ""nvim/diff.h""+#include ""nvim/fold.h""+#include ""nvim/memline.h""+#include ""nvim/charset.h""+#include ""nvim/move.h""+#include ""nvim/line_consumption.h""+#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""line_consumption.c.generated.h""+#endif+/// Functions to determine physical line consumption of real lines+///+/// Throughout this file the terminology is:+/// - physical line: the amount of lines on the screen.+/// - real line: text in a file between two newline characters+///+///+/// There are several situations where a real line can take up several lines on+/// screen. This is especially true if the 'wrap' option is activated.+///+/// The contrary, several real lines consuming less physical lines on the screen+/// becomes true if 'folding' is used.+///+/// This file provides functions that determine the amount of physical lines+/// used by real lines, considering these factors.+++/// Gets the physical line count consumed by a real line in current window+///+/// @param lnum Linenumber of buffer+///+/// @return The physical line count+size_t plines(linenr_T lnum)+  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT","Completely correct, I'm afraid. Pure functions can change no global state, and I believe the allocated memory is global state, among others.Perhaps there is a way to rewrite the function without allocating.Also, as experimented by @Hinidu, when specifying pure, warn_unused_result is no longer necessary.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/884,14167548,2014-06-25T03:15:55Z,src/nvim/buffer.c,"@@ -1729,57 +1723,41 @@ buflist_findpat (     if (pat == NULL)       return -1;     patend = pat + STRLEN(pat) - 1;-    toggledollar = (patend > pat && *patend == '$');      /* First try finding a listed buffer.  If not found and ""unlisted""      * is TRUE, try finding an unlisted buffer. */     find_listed = TRUE;     for (;; ) {",I think this outer loop is actually the one that is the anti-pattern.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/884,14167894,2014-06-25T03:35:47Z,src/nvim/buffer.c,"@@ -1792,6 +1770,76 @@ buflist_findpat (   return match; } +/* Returns the buffer number matching the given pattern, depending on the attempt:+ * attempt 0: without '^' or '$' (at any position)+ * attempt 1: with '^' at start (only at position 0)+ * attempt 2: with '$' at end (only match at end)+ * attempt 3: with '^' at start and '$' at end (only full match)+ */+static int attempt_match(char_u *pat, char_u *patend, int attempt, int find_listed, int diffmode, int curtab_only)",Extracting the loop body and turning it into a function that takes the loop variable (`attempt`) as parameter is equivalent to the old code. A refactoring of this anti-pattern means that there will be a big reduction in conditional code. Conditional code still exists inside the `attempt_match` function.,
116260,mikaelj,https://api.github.com/repos/neovim/neovim/pulls/872,14174090,2014-06-25T08:35:59Z,src/nvim/os/channel.c,"@@ -113,26 +125,98 @@ void channel_from_stream(uv_stream_t *stream) /// /// @param id The channel id. If 0, the event will be sent to all ///        channels that have subscribed to the event type-/// @param type The event type, an arbitrary string-/// @param obj The event data+/// @param name The event name, an arbitrary string+/// @param arg The event arg /// @return True if the data was sent successfully, false otherwise.-bool channel_send_event(uint64_t id, char *type, Object data)+bool channel_send_event(uint64_t id, char *name, Object arg) {   Channel *channel = NULL;    if (id > 0) {     if (!(channel = pmap_get(uint64_t)(channels, id))) {-      msgpack_rpc_free_object(data);+      msgpack_rpc_free_object(arg);       return false;     }-    send_event(channel, type, data);+    send_event(channel, name, arg);   } else {-    broadcast_event(type, data);+    broadcast_event(name, arg);   }    return true; } +bool channel_send_call(uint64_t id,+                       char *name,+                       Object arg,+                       Object *result,+                       bool *errored)+{+  Channel *channel = NULL;++  if (!(channel = pmap_get(uint64_t)(channels, id))) {+    msgpack_rpc_free_object(arg);+    return false;+  }++  if (kv_size(channel->call_stack) > 20) {","Maybe introduce a constant describing what the number ""20"" means so it's easier to change it later? Magic numbers are bad.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/884,14278678,2014-06-27T03:44:49Z,src/nvim/buffer.c,"@@ -1792,6 +1770,76 @@ buflist_findpat (   return match; } +/* Returns the buffer number matching the given pattern, depending on the attempt:+ * attempt 0: without '^' or '$' (at any position)+ * attempt 1: with '^' at start (only at position 0)+ * attempt 2: with '$' at end (only match at end)+ * attempt 3: with '^' at start and '$' at end (only full match)+ */+static int attempt_match(char_u *pat, char_u *patend, int attempt, int find_listed, int diffmode, int curtab_only)+{+  char_u *p;+  int match = -1;++  if ((attempt == 0 || attempt == 1) && (patend > pat && *patend == '$')) {+    // attempt 0 or 1 and last char is '$'+    *patend = NUL;+  }++  p = pat;+  if ((attempt == 1 || attempt == 3) && *p == '^') {+    // attempt is 1 or 3 and first char is '^'+    p++;+  }++  regprog_T *prog = vim_regcomp(p, p_magic ? RE_MAGIC : 0);+  if (prog == NULL) {+    free(pat);+    return -1;+  }++  match = find_buf_match(prog, find_listed, diffmode, curtab_only);++  // undo *patend = NUL, since it's a pointer+  *patend = '$';++  return match;+}++/*+ * Find a match and return buffer number+ */+static int find_buf_match(regprog_T *prog, int find_listed, int diffmode, int curtab_only)+{+  buf_T       *buf;+  int match = -1;+  for (buf = firstbuf; buf != NULL; buf = buf->b_next) {+    if (buf->b_p_bl == find_listed+        && (!diffmode || diff_mode_buf(buf))+        && buflist_match(prog, buf) != NULL) {+      if (curtab_only) {+        /* Ignore the match if the buffer is not open in+         * the current tab. */+        win_T       *wp;++        for (wp = firstwin; wp != NULL; wp = wp->w_next)+          if (wp->w_buffer == buf)+            break;+        if (wp == NULL)+          continue;+      }+      if (match >= 0) {                   /* already found a match */+        match = -2;",This statement is here because the code is written to fail unless the pattern uniquely matches a single buffer.,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/850,14293209,2014-06-27T13:52:06Z,src/nvim/os/os.h,"@@ -1,9 +1,16 @@ #ifndef NVIM_OS_OS_H #define NVIM_OS_OS_H+ #include <uv.h>  #include ""nvim/vim.h"" +#ifdef WIN32+# include ""nvim/os/win_defs.h""+#else+# include ""nvim/os/unix_defs.h""+#endif+",I would do this on a separate file os/os_defs.h - similar to what currently happens with os_unix_defs.h and os_unix.h. - to keep platform specific defines away from internal os_\* stuff.,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/846,14437031,2014-07-02T01:17:03Z,test/unit/os/fs.moon,"@@ -8,6 +8,13 @@ fs = cimport './src/nvim/os/os.h' FAIL = 0 OK = 1 +O_RDONLY = 0x0000 -- same on linux and OS X. <fcntl.h>+O_WRONLY = 0x0001 -- same on linux and OS X.+O_RDWR   = 0x0002 -- same on linux and OS X.+O_CREAT  = 0x0040 -- this is 0x40 on linux, 0x0200 on OS X.","@justinmk > @aktau @Hinidu did we ever find a way to import header constants?We have something setup in `test/includes` that was used to extract constants from `sys/stat.h`.  Perhaps something similar could be done here?  Another choice would be to build some sort of lua helper (perhaps in C) to help pull out the required values.  I'm not sure what it takes to do that, but I imagine its not too difficult.  I've thought a few times of doing it myself and making some package available on luarocks--it's disappointing that it's not there already. :-(",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/907,14459871,2014-07-02T14:34:41Z,src/nvim/misc2.c,"@@ -485,27 +485,26 @@ time_t get8ctime(FILE *fd)   return n; } -/*- * Read a string of length ""cnt"" from ""fd"" into allocated memory.- * Returns NULL when unable to read that many bytes.- */-char_u *read_string(FILE *fd, int cnt)+/// Reads a string from a file.+///+/// Reads cnt characters from the stream fd and returns a string.+/// The caller is responsible for freeing the string.+///+/// @param fd Stream to read from.+/// @param cnt Number of characters to read.+///+/// @return Null terminated string with cnt characters, or NULL on EOF.+char *read_string(FILE *fd, size_t cnt) {-  int i;-  int c;--  char_u *str = xmallocz(cnt);-  /* Read the string.  Quit when running into the EOF. */-  for (i = 0; i < cnt; ++i) {-    c = getc(fd);+  char *str = xmallocz(cnt);","> I know that using `char` here works the same as `uint8_t`, however it would be nicer to use an unsigned type as that's what `getc` returns inside the `int`.I'm still trying to deduce what you mean by ""nicer""--sorry!  Is your underlying argument here is that it could prevent a subtle bug because a platform could (theoretically) use a different mechanism for representing numbers, which could cause the character read to be wrong?  Or is the argument really just that it is more consistent with what's happening under-the-hood?I only ask because avoiding casts is nice, since they can hide bugs.  I would've swung the other way here said it should be `char *`.  So I'm trying to understand your philosophy about this so that I can either amend my vision or yours. :-)",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/907,14460584,2014-07-02T14:46:08Z,src/nvim/misc2.c,"@@ -485,27 +485,26 @@ time_t get8ctime(FILE *fd)   return n; } -/*- * Read a string of length ""cnt"" from ""fd"" into allocated memory.- * Returns NULL when unable to read that many bytes.- */-char_u *read_string(FILE *fd, int cnt)+/// Reads a string from a file.+///+/// Reads cnt characters from the stream fd and returns a string.+/// The caller is responsible for freeing the string.+///+/// @param fd Stream to read from.+/// @param cnt Number of characters to read.+///+/// @return Null terminated string with cnt characters, or NULL on EOF.+char *read_string(FILE *fd, size_t cnt) {-  int i;-  int c;--  char_u *str = xmallocz(cnt);-  /* Read the string.  Quit when running into the EOF. */-  for (i = 0; i < cnt; ++i) {-    c = getc(fd);+  char *str = xmallocz(cnt);","Because it is more consistent with what's happening under-the-hood. `getc`returns an `int`, so there's a cast to `char` or `uint8_t` anyway.I suggested casting on return when he changed everything to `uint8_t`. Thenhe changed everything to `char *`, force pushed, and my suggestion becameless justifiable. :)On Wed, Jul 2, 2014 at 11:34 AM, John Szakmeister notifications@github.comwrote:> In src/nvim/misc2.c:> > >  {> > -  int i;> > > > ## \-  int c;> > -  char_u *str = xmallocz(cnt);> > -  /\* Read the string.  Quit when running into the EOF. */> > -  for (i = 0; i < cnt; ++i) {> > -    c = getc(fd);> > -  char *str = xmallocz(cnt);> >  I know that using char here works the same as uint8_t, however it would> be nicer to use an unsigned type as that's what getc returns inside the> int.> > I'm still trying to deduce what you mean by ""nicer""--sorry! Is your> underlying argument here is that it could prevent a subtle bug because a> platform could (theoretically) use a different mechanism for representing> numbers, which could cause the character read to be wrong? Or is the> argument really just that it is more consistent with what's happening> under-the-hood?> > I only ask because avoiding casts is nice, since they can hide bugs. I> would've swung the other way here said it should be char *. So I'm trying> to understand your philosophy about this so that I can either amend my> vision or yours. :-)> > ���> Reply to this email directly or view it on GitHub> https://github.com/neovim/neovim/pull/907/files#r14459871.",
1622279,siler,https://api.github.com/repos/neovim/neovim/pulls/907,14467160,2014-07-02T16:24:46Z,src/nvim/misc2.c,"@@ -485,27 +485,26 @@ time_t get8ctime(FILE *fd)   return n; } -/*- * Read a string of length ""cnt"" from ""fd"" into allocated memory.- * Returns NULL when unable to read that many bytes.- */-char_u *read_string(FILE *fd, int cnt)+/// Reads a string from a file.+///+/// Reads cnt characters from the stream fd and returns a string.+/// The caller is responsible for freeing the string.+///+/// @param fd Stream to read from.+/// @param cnt Number of characters to read.+///+/// @return Null terminated string with cnt characters, or NULL on EOF.+char *read_string(FILE *fd, size_t cnt) {-  int i;-  int c;--  char_u *str = xmallocz(cnt);-  /* Read the string.  Quit when running into the EOF. */-  for (i = 0; i < cnt; ++i) {-    c = getc(fd);+  char *str = xmallocz(cnt);","My original reasoning for using uint8_t was that we are returning bytes from a file, and in most systems bytes are probably going to be 8 unsigned bits.But the method is actually an interface to get a string, so it is more accurate to return characters from it. I agree that is correct. :) The caller is going to assume they are going to get a string back. Since the data type used to read the characters is unsigned char, as per the man page for getc, I realized that it is possible, though very unlikely, that the value returned by getc may not fit in uint8_t at some point in the future. That is why I changed everything to char. It is guaranteed to fit the data, and the representation will be the same when the data is used by the caller.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/846,14536075,2014-07-03T20:24:16Z,test/unit/os/fs.moon,"@@ -8,6 +8,13 @@ fs = cimport './src/nvim/os/os.h' FAIL = 0 OK = 1 +O_RDONLY = 0x0000 -- same on linux and OS X. <fcntl.h>+O_WRONLY = 0x0001 -- same on linux and OS X.+O_RDWR   = 0x0002 -- same on linux and OS X.+O_CREAT  = 0x0040 -- this is 0x40 on linux, 0x0200 on OS X.","Using `cppimport` as was done for `sys/stat.h` worked nicely. > ffiex. If someone has time to experiment,That looks great, but we should decide #903 first. In the meantime `cppimport` seems fine. It also seems to have a dependency on gcc/tcc, and reading about its extended support for `/usr/include/` makes me think it won't work at all for MSVC. Is there any major reason your ""weak"" version would not be workable for MSVC?",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/645,14576731,2014-07-06T18:50:24Z,src/nvim/spell.c,"@@ -6075,17 +6075,15 @@ static int spell_read_wordfile(spellinfo_T *spin, char_u *fname)   return retval; } -// Get part of an sblock_T, ""len"" bytes long.-// This avoids calling free() for every little struct we use (and keeping-// track of them).-// The memory is cleared to all zeros.-// Returns NULL when out of memory.-static void *-getroom (-    spellinfo_T *spin,-    size_t len,                     // length needed-    int align                      // align for pointer-)+/// Get part of an sblock_T, ""len"" bytes long.+/// This avoids calling free() for every little struct we use (and keeping+/// track of them).+/// The memory is cleared to all zeros.+/// Returns NULL when out of memory.",Can use `@return` after the `@param` list.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/920,14658433,2014-07-08T15:14:45Z,src/nvim/api/vim.c,"@@ -52,55 +52,31 @@ void vim_command(String str, Error *err) /// Pass input keys to Neovim /// /// @param keys to be typed-/// @param replace_tcodes If true replace special keys such as <CR> or <Leader>-///           for compatibility with Vim --remote-send expressions-/// @param remap If True remap keys-/// @param typed Handle keys as if typed; otherwise they are handled as-///           if coming from a mapping.  This matters for undo,-///           opening folds, etc.-void vim_feedkeys(String keys, Boolean replace_tcodes, Boolean remap,-                Boolean typed, Error *err)+/// @param mode specifies the mapping options+/// @see feedkeys()+void vim_feedkeys(String keys, String mode)+{+  feedkeys(keys.data, mode.data);+}++/// Replace any terminal codes with the internal representation+///+/// @see replace_termcodes+/// @see cpoptions+String vim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,+                              Boolean special, Error *err) {   char *ptr = NULL;-  char *cpo_save = (char *)p_cpo;--  if (replace_tcodes) {-    // Set 'cpoptions' the way we want it.-    //    B set - backslashes are *not* treated specially-    //    k set - keycodes are *not* reverse-engineered-    //    < unset - <Key> sequences *are* interpreted-    //  The last but one parameter of replace_termcodes() is TRUE so that the-    //  <lt> sequence is recognised - needed for a real backslash.-    p_cpo = (char_u *)""Bk"";-    replace_termcodes((char_u *)keys.data, (char_u **)&ptr, false, true, true);-    p_cpo = (char_u *)cpo_save;-  } else {-    ptr = keys.data;-  }+  char *result = (char *)replace_termcodes((char_u *)str.data, (char_u **)&ptr,+                                            from_part, do_lt, special); -  if (ptr == NULL) {+  if (!ptr) {     set_api_error(""Failed to eval expression"", err);-  } else {-    // Add the string to the input stream.-    // Can't use add_to_input_buf() here, we now have K_SPECIAL bytes.-    //-    // First clear typed characters from the typeahead buffer, there could-    // be half a mapping there.  Then append to the existing string, so-    // that multiple commands from a client are concatenated.-    if (typebuf.tb_maplen < typebuf.tb_len) {-        del_typebuf(typebuf.tb_len - typebuf.tb_maplen, typebuf.tb_maplen);-    }-    (void)ins_typebuf((char_u *)ptr, (remap ? REMAP_YES : REMAP_NONE),-                    typebuf.tb_len, !typed, false);--    // Let input_available() know we inserted text in the typeahead-    // buffer. */-    typebuf_was_filled = true;--    if (replace_tcodes) {-      free(ptr);-    }   }++  String ret = cstr_to_string(result);","The following lines could be replaced with `return (String) {.data = result, .size = strlen(result)};`.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/920,14659741,2014-07-08T15:33:08Z,src/nvim/api/vim.c,"@@ -52,55 +52,31 @@ void vim_command(String str, Error *err) /// Pass input keys to Neovim /// /// @param keys to be typed-/// @param replace_tcodes If true replace special keys such as <CR> or <Leader>-///           for compatibility with Vim --remote-send expressions-/// @param remap If True remap keys-/// @param typed Handle keys as if typed; otherwise they are handled as-///           if coming from a mapping.  This matters for undo,-///           opening folds, etc.-void vim_feedkeys(String keys, Boolean replace_tcodes, Boolean remap,-                Boolean typed, Error *err)+/// @param mode specifies the mapping options+/// @see feedkeys()+void vim_feedkeys(String keys, String mode)+{+  feedkeys(keys.data, mode.data);+}++/// Replace any terminal codes with the internal representation+///+/// @see replace_termcodes+/// @see cpoptions+String vim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,+                              Boolean special, Error *err) {   char *ptr = NULL;-  char *cpo_save = (char *)p_cpo;--  if (replace_tcodes) {-    // Set 'cpoptions' the way we want it.-    //    B set - backslashes are *not* treated specially-    //    k set - keycodes are *not* reverse-engineered-    //    < unset - <Key> sequences *are* interpreted-    //  The last but one parameter of replace_termcodes() is TRUE so that the-    //  <lt> sequence is recognised - needed for a real backslash.-    p_cpo = (char_u *)""Bk"";-    replace_termcodes((char_u *)keys.data, (char_u **)&ptr, false, true, true);-    p_cpo = (char_u *)cpo_save;-  } else {-    ptr = keys.data;-  }+  char *result = (char *)replace_termcodes((char_u *)str.data, (char_u **)&ptr,+                                            from_part, do_lt, special); -  if (ptr == NULL) {+  if (!ptr) {     set_api_error(""Failed to eval expression"", err);-  } else {-    // Add the string to the input stream.-    // Can't use add_to_input_buf() here, we now have K_SPECIAL bytes.-    //-    // First clear typed characters from the typeahead buffer, there could-    // be half a mapping there.  Then append to the existing string, so-    // that multiple commands from a client are concatenated.-    if (typebuf.tb_maplen < typebuf.tb_len) {-        del_typebuf(typebuf.tb_len - typebuf.tb_maplen, typebuf.tb_maplen);-    }-    (void)ins_typebuf((char_u *)ptr, (remap ? REMAP_YES : REMAP_NONE),-                    typebuf.tb_len, !typed, false);--    // Let input_available() know we inserted text in the typeahead-    // buffer. */-    typebuf_was_filled = true;--    if (replace_tcodes) {-      free(ptr);-    }   }++  String ret = cstr_to_string(result);","Not the best semanthics but I could add``` CString cstr_as_string(char *str){  return (String) {.data = str, .size = strlen(str)};}```",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/920,14660570,2014-07-08T15:45:12Z,src/nvim/api/vim.c,"@@ -52,55 +51,31 @@ void vim_command(String str, Error *err) /// Pass input keys to Neovim /// /// @param keys to be typed-/// @param replace_tcodes If true replace special keys such as <CR> or <Leader>-///           for compatibility with Vim --remote-send expressions-/// @param remap If True remap keys-/// @param typed Handle keys as if typed; otherwise they are handled as-///           if coming from a mapping.  This matters for undo,-///           opening folds, etc.-void vim_feedkeys(String keys, Boolean replace_tcodes, Boolean remap,-                Boolean typed, Error *err)+/// @param mode specifies the mapping options+/// @see feedkeys()+void vim_feedkeys(String keys, String mode)+{+  feedkeys(keys.data, mode.data);+}++/// Replace any terminal codes with the internal representation+///+/// @see replace_termcodes+/// @see cpoptions+String vim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,+                              Boolean special, Error *err) {   char *ptr = NULL;-  char *cpo_save = (char *)p_cpo;--  if (replace_tcodes) {-    // Set 'cpoptions' the way we want it.-    //    B set - backslashes are *not* treated specially-    //    k set - keycodes are *not* reverse-engineered-    //    < unset - <Key> sequences *are* interpreted-    //  The last but one parameter of replace_termcodes() is TRUE so that the-    //  <lt> sequence is recognised - needed for a real backslash.-    p_cpo = (char_u *)""Bk"";-    replace_termcodes((char_u *)keys.data, (char_u **)&ptr, false, true, true);-    p_cpo = (char_u *)cpo_save;-  } else {-    ptr = keys.data;-  }+  char *result = (char *)replace_termcodes((char_u *)str.data, (char_u **)&ptr,+                                            from_part, do_lt, special); -  if (ptr == NULL) {+  if (*ptr == NULL) {",@philix is this something that escaped the huge OOM list?,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/920,14660650,2014-07-08T15:46:15Z,src/nvim/api/vim.c,"@@ -52,55 +52,31 @@ void vim_command(String str, Error *err) /// Pass input keys to Neovim /// /// @param keys to be typed-/// @param replace_tcodes If true replace special keys such as <CR> or <Leader>-///           for compatibility with Vim --remote-send expressions-/// @param remap If True remap keys-/// @param typed Handle keys as if typed; otherwise they are handled as-///           if coming from a mapping.  This matters for undo,-///           opening folds, etc.-void vim_feedkeys(String keys, Boolean replace_tcodes, Boolean remap,-                Boolean typed, Error *err)+/// @param mode specifies the mapping options+/// @see feedkeys()+void vim_feedkeys(String keys, String mode)+{+  feedkeys(keys.data, mode.data);+}++/// Replace any terminal codes with the internal representation+///+/// @see replace_termcodes+/// @see cpoptions+String vim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,+                              Boolean special, Error *err) {   char *ptr = NULL;-  char *cpo_save = (char *)p_cpo;--  if (replace_tcodes) {-    // Set 'cpoptions' the way we want it.-    //    B set - backslashes are *not* treated specially-    //    k set - keycodes are *not* reverse-engineered-    //    < unset - <Key> sequences *are* interpreted-    //  The last but one parameter of replace_termcodes() is TRUE so that the-    //  <lt> sequence is recognised - needed for a real backslash.-    p_cpo = (char_u *)""Bk"";-    replace_termcodes((char_u *)keys.data, (char_u **)&ptr, false, true, true);-    p_cpo = (char_u *)cpo_save;-  } else {-    ptr = keys.data;-  }+  char *result = (char *)replace_termcodes((char_u *)str.data, (char_u **)&ptr,+                                            from_part, do_lt, special); -  if (ptr == NULL) {+  if (!ptr) {     set_api_error(""Failed to eval expression"", err);-  } else {-    // Add the string to the input stream.-    // Can't use add_to_input_buf() here, we now have K_SPECIAL bytes.-    //-    // First clear typed characters from the typeahead buffer, there could-    // be half a mapping there.  Then append to the existing string, so-    // that multiple commands from a client are concatenated.-    if (typebuf.tb_maplen < typebuf.tb_len) {-        del_typebuf(typebuf.tb_len - typebuf.tb_maplen, typebuf.tb_maplen);-    }-    (void)ins_typebuf((char_u *)ptr, (remap ? REMAP_YES : REMAP_NONE),-                    typebuf.tb_len, !typed, false);--    // Let input_available() know we inserted text in the typeahead-    // buffer. */-    typebuf_was_filled = true;--    if (replace_tcodes) {-      free(ptr);-    }   }++  String ret = cstr_to_string(result);","> Maybe do cstr_to_string_nodup() instead to make really obvious.Perhaps, it's really obvious but a bit long in the tooth. I kinda like your `cstr_as_string` though. What does the rest think?",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/920,14661064,2014-07-08T15:52:30Z,src/nvim/api/vim.c,"@@ -52,55 +52,31 @@ void vim_command(String str, Error *err) /// Pass input keys to Neovim /// /// @param keys to be typed-/// @param replace_tcodes If true replace special keys such as <CR> or <Leader>-///           for compatibility with Vim --remote-send expressions-/// @param remap If True remap keys-/// @param typed Handle keys as if typed; otherwise they are handled as-///           if coming from a mapping.  This matters for undo,-///           opening folds, etc.-void vim_feedkeys(String keys, Boolean replace_tcodes, Boolean remap,-                Boolean typed, Error *err)+/// @param mode specifies the mapping options+/// @see feedkeys()+void vim_feedkeys(String keys, String mode)+{+  feedkeys(keys.data, mode.data);+}++/// Replace any terminal codes with the internal representation+///+/// @see replace_termcodes+/// @see cpoptions+String vim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,+                              Boolean special, Error *err) {   char *ptr = NULL;-  char *cpo_save = (char *)p_cpo;--  if (replace_tcodes) {-    // Set 'cpoptions' the way we want it.-    //    B set - backslashes are *not* treated specially-    //    k set - keycodes are *not* reverse-engineered-    //    < unset - <Key> sequences *are* interpreted-    //  The last but one parameter of replace_termcodes() is TRUE so that the-    //  <lt> sequence is recognised - needed for a real backslash.-    p_cpo = (char_u *)""Bk"";-    replace_termcodes((char_u *)keys.data, (char_u **)&ptr, false, true, true);-    p_cpo = (char_u *)cpo_save;-  } else {-    ptr = keys.data;-  }+  char *result = (char *)replace_termcodes((char_u *)str.data, (char_u **)&ptr,+                                            from_part, do_lt, special); -  if (ptr == NULL) {+  if (!ptr) {     set_api_error(""Failed to eval expression"", err);-  } else {-    // Add the string to the input stream.-    // Can't use add_to_input_buf() here, we now have K_SPECIAL bytes.-    //-    // First clear typed characters from the typeahead buffer, there could-    // be half a mapping there.  Then append to the existing string, so-    // that multiple commands from a client are concatenated.-    if (typebuf.tb_maplen < typebuf.tb_len) {-        del_typebuf(typebuf.tb_len - typebuf.tb_maplen, typebuf.tb_maplen);-    }-    (void)ins_typebuf((char_u *)ptr, (remap ? REMAP_YES : REMAP_NONE),-                    typebuf.tb_len, !typed, false);--    // Let input_available() know we inserted text in the typeahead-    // buffer. */-    typebuf_was_filled = true;--    if (replace_tcodes) {-      free(ptr);-    }   }++  String ret = cstr_to_string(result);",More semantics `cstr_cast_string`,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/920,14661827,2014-07-08T16:03:57Z,src/nvim/api/vim.c,"@@ -52,55 +52,31 @@ void vim_command(String str, Error *err) /// Pass input keys to Neovim /// /// @param keys to be typed-/// @param replace_tcodes If true replace special keys such as <CR> or <Leader>-///           for compatibility with Vim --remote-send expressions-/// @param remap If True remap keys-/// @param typed Handle keys as if typed; otherwise they are handled as-///           if coming from a mapping.  This matters for undo,-///           opening folds, etc.-void vim_feedkeys(String keys, Boolean replace_tcodes, Boolean remap,-                Boolean typed, Error *err)+/// @param mode specifies the mapping options+/// @see feedkeys()+void vim_feedkeys(String keys, String mode)+{+  feedkeys(keys.data, mode.data);+}++/// Replace any terminal codes with the internal representation+///+/// @see replace_termcodes+/// @see cpoptions+String vim_replace_termcodes(String str, Boolean from_part, Boolean do_lt,+                              Boolean special, Error *err) {   char *ptr = NULL;-  char *cpo_save = (char *)p_cpo;--  if (replace_tcodes) {-    // Set 'cpoptions' the way we want it.-    //    B set - backslashes are *not* treated specially-    //    k set - keycodes are *not* reverse-engineered-    //    < unset - <Key> sequences *are* interpreted-    //  The last but one parameter of replace_termcodes() is TRUE so that the-    //  <lt> sequence is recognised - needed for a real backslash.-    p_cpo = (char_u *)""Bk"";-    replace_termcodes((char_u *)keys.data, (char_u **)&ptr, false, true, true);-    p_cpo = (char_u *)cpo_save;-  } else {-    ptr = keys.data;-  }+  char *result = (char *)replace_termcodes((char_u *)str.data, (char_u **)&ptr,+                                            from_part, do_lt, special); -  if (ptr == NULL) {+  if (!ptr) {     set_api_error(""Failed to eval expression"", err);-  } else {-    // Add the string to the input stream.-    // Can't use add_to_input_buf() here, we now have K_SPECIAL bytes.-    //-    // First clear typed characters from the typeahead buffer, there could-    // be half a mapping there.  Then append to the existing string, so-    // that multiple commands from a client are concatenated.-    if (typebuf.tb_maplen < typebuf.tb_len) {-        del_typebuf(typebuf.tb_len - typebuf.tb_maplen, typebuf.tb_maplen);-    }-    (void)ins_typebuf((char_u *)ptr, (remap ? REMAP_YES : REMAP_NONE),-                    typebuf.tb_len, !typed, false);--    // Let input_available() know we inserted text in the typeahead-    // buffer. */-    typebuf_was_filled = true;--    if (replace_tcodes) {-      free(ptr);-    }   }++  String ret = cstr_to_string(result);","> More semantics cstr_cast_stringAlso good, though `cstr_as_string` has grown on me in the short time of its existence.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/874,14702786,2014-07-09T10:28:10Z,src/nvim/os/server.c,"@@ -116,21 +116,19 @@ void server_start(char *endpoint)    if (addr_len > sizeof(ip) - 1) {     // Maximum length of an IP address buffer is 15(eg: 255.255.255.255)-    addr_len = sizeof(ip);+    addr_len = sizeof(ip) - 1;   }    // Extract the address part-  xstrlcpy(ip, addr, addr_len);+  xstrlcpy(ip, addr, addr_len + 1);    int port = NEOVIM_DEFAULT_TCP_PORT;    if (*ip_end == ':') {-    char *port_end;     // Extract the port-    port = strtol(ip_end + 1, &port_end, 10);-    errno = 0;+    port = strtol(ip_end + 1, NULL, 10);","There are a number of `long ints` that would map into the range of `0..0xffff` after a cast to `int`. We could have different representations for the same address,```127.0.0.1:1024127.0.0.1:4294968320```and trying to listen on the same port twice will probably fail. ",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/874,14703095,2014-07-09T10:36:48Z,src/nvim/os/server.c,"@@ -116,21 +116,19 @@ void server_start(char *endpoint)    if (addr_len > sizeof(ip) - 1) {     // Maximum length of an IP address buffer is 15(eg: 255.255.255.255)-    addr_len = sizeof(ip);+    addr_len = sizeof(ip) - 1;   }    // Extract the address part-  xstrlcpy(ip, addr, addr_len);+  xstrlcpy(ip, addr, addr_len + 1);    int port = NEOVIM_DEFAULT_TCP_PORT;    if (*ip_end == ':') {-    char *port_end;     // Extract the port-    port = strtol(ip_end + 1, &port_end, 10);-    errno = 0;+    port = strtol(ip_end + 1, NULL, 10);","It depends on the platform (sometimes `sizeof(int) == sizeof(long)`), but you are of course completely right.A decent fix would be to assign to a temporary `long` variable and only assign to `port` after checking the range. Like this:``` c   long lport = strtol(ip_end + 1, NULL, 10);   if (lport <= 0 || lport > 0xffff) {      // Invalid port, treat as named pipe or unix socket      server_type = kServerTypePipe;    } else {      port = (int) lport;    }```Added a check for `<= 0` since technically a user could specify `*:-9874`.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/813,14728435,2014-07-09T18:52:43Z,cmake/FindLibIntl.cmake,"@@ -49,6 +49,16 @@ int main(int argc, char** argv) {   textdomain(\""foo\""); }"" HAVE_WORKING_LIBINTL) +if (HAVE_WORKING_LIBINTL)+check_c_source_compiles(""+#include <libintl.h>++int main(int argc, char** argv) {+  extern int _nl_msg_cat_cntr;+  ++_nl_msg_cat_cntr;+}"" HAVE_NL_MSG_CAT_CNTR)",@equalsraf I learned CMake a bit :-) In CMake source tree I found the module [`CheckVariableExists`](http://cmake.org/gitweb?p=cmake.git;a=blob_plain;f=Modules/CheckVariableExists.cmake;hb=HEAD). This `check_c_source_compiles(...)` can be replaced with `check_variable_exists(_nl_msg_cat_cntr HAVE_NL_MSG_CAT_CNTR)`. At least on my machine it works as intended.,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/813,14759148,2014-07-10T10:45:58Z,config/CMakeLists.txt,"@@ -9,11 +11,75 @@ check_type_size(""void *"" SIZEOF_VOID_PTR)  check_symbol_exists(_NSGetEnviron crt_externs.h HAVE__NSGETENVIRON) +# Headers+check_include_files(dirent.h HAVE_DIRENT_H)+check_include_files(fcntl.h HAVE_FCNTL_H)+check_include_files(iconv.h HAVE_ICONV_H)+check_include_files(langinfo.h HAVE_LANGINFO_H)+check_include_files(libgen.h HAVE_LIBGEN_H)+check_include_files(locale.h HAVE_LOCALE_H)+check_include_files(pwd.h HAVE_PWD_H)+check_include_files(strings.h HAVE_STRINGS_H)+check_include_files(stropts.h HAVE_STROPTS_H)+check_include_files(sys/ioctl.h HAVE_SYS_IOCTL_H)+check_include_files(sys/param.h HAVE_SYS_PARAM_H)+check_include_files(sys/time.h HAVE_SYS_TIME_H)+check_include_files(sys/wait.h HAVE_SYS_WAIT_H)+if (NOT HAVE_SYS_WAIT_H AND UNIX)+	# See if_cscope.c+	message(SEND_ERROR ""header sys/wait.h is required for UNIX"")+endif()+check_include_files(sys/utsname.h HAVE_SYS_UTSNAME_H)+check_include_files(utime.h HAVE_UTIME_H)+check_include_files(termcap.h HAVE_TERMCAP_H)+check_include_files(termios.h HAVE_TERMIOS_H)+check_include_files(termio.h HAVE_TERMIO_H)+check_include_files(unistd.h HAVE_UNISTD_H)+check_include_files(utime.h HAVE_UTIME_H)++# Functions+check_function_exists(fchown HAVE_FCHOWN)","I guess we were hoping some of these checks would go away due to using libuv.  But it doesn't hurt to have them now, as long as we remember to remove them when we're no longer directly calling them.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/874,14773771,2014-07-10T15:41:00Z,src/nvim/os/server.c,"@@ -117,23 +118,22 @@ void server_start(char *endpoint)    if (addr_len > sizeof(ip) - 1) {     // Maximum length of an IP address buffer is 15(eg: 255.255.255.255)-    addr_len = sizeof(ip);+    addr_len = sizeof(ip) - 1;   }    // Extract the address part-  xstrlcpy(ip, addr, addr_len);+  xstrlcpy(ip, addr, addr_len + 1);    int port = NEOVIM_DEFAULT_TCP_PORT;    if (*ip_end == ':') {-    char *port_end;     // Extract the port-    port = strtol(ip_end + 1, &port_end, 10);-    errno = 0;--    if (errno != 0 || port == 0 || port > 0xffff) {+    int32_t lport = strtol(ip_end + 1, NULL, 10);","Not sure if this file is in `-Wconversion`, but if so, then if a system has 128-bit longs, it will warn and we'll notice.Otherwise, if we use `intmax_t`, we'll never have to change the code.It's a bit stupid we can't just use `long` though...",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/874,14774894,2014-07-10T15:58:22Z,src/nvim/os/server.c,"@@ -117,23 +118,22 @@ void server_start(char *endpoint)    if (addr_len > sizeof(ip) - 1) {     // Maximum length of an IP address buffer is 15(eg: 255.255.255.255)-    addr_len = sizeof(ip);+    addr_len = sizeof(ip) - 1;   }    // Extract the address part-  xstrlcpy(ip, addr, addr_len);+  xstrlcpy(ip, addr, addr_len + 1);    int port = NEOVIM_DEFAULT_TCP_PORT;    if (*ip_end == ':') {-    char *port_end;     // Extract the port-    port = strtol(ip_end + 1, &port_end, 10);-    errno = 0;--    if (errno != 0 || port == 0 || port > 0xffff) {+    int32_t lport = strtol(ip_end + 1, NULL, 10);",If the problem with `long` is only because of `clint` we can avoid it with comment `//NOLINT`.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/874,14775447,2014-07-10T16:08:13Z,src/nvim/os/server.c,"@@ -117,23 +118,22 @@ void server_start(char *endpoint)    if (addr_len > sizeof(ip) - 1) {     // Maximum length of an IP address buffer is 15(eg: 255.255.255.255)-    addr_len = sizeof(ip);+    addr_len = sizeof(ip) - 1;   }    // Extract the address part-  xstrlcpy(ip, addr, addr_len);+  xstrlcpy(ip, addr, addr_len + 1);    int port = NEOVIM_DEFAULT_TCP_PORT;    if (*ip_end == ':') {-    char *port_end;     // Extract the port-    port = strtol(ip_end + 1, &port_end, 10);-    errno = 0;--    if (errno != 0 || port == 0 || port > 0xffff) {+    int32_t lport = strtol(ip_end + 1, NULL, 10);",> If the problem with long is only because of clint we can avoid it with comment //NOLINT.That might be the best option indeed.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/895,14811001,2014-07-11T08:28:03Z,src/nvim/api/vim.c,"@@ -503,6 +504,22 @@ void vim_unsubscribe(uint64_t channel_id, String event)   channel_unsubscribe(channel_id, e); } +/// Registers the channel as the provider for `method`. This fails if+/// a provider for `method` is already registered.+///+/// @param channel_id The channel id+/// @param method The method name+/// @param[out] err Details of an error that may have occurred+void vim_register_provider(uint64_t channel_id, String method, Error *err)+{+  char buf[METHOD_MAXLEN];+  xstrlcpy(buf, method.data, sizeof(buf));",Is this necessary? `provider_register` duplicates the method name with a `xstrdup` call.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/895,14816632,2014-07-11T11:36:47Z,src/nvim/api/vim.c,"@@ -503,6 +504,22 @@ void vim_unsubscribe(uint64_t channel_id, String event)   channel_unsubscribe(channel_id, e); } +/// Registers the channel as the provider for `method`. This fails if+/// a provider for `method` is already registered.+///+/// @param channel_id The channel id+/// @param method The method name+/// @param[out] err Details of an error that may have occurred+void vim_register_provider(uint64_t channel_id, String method, Error *err)+{+  char buf[METHOD_MAXLEN];+  xstrlcpy(buf, method.data, sizeof(buf));",We could use `xstrndup` instead of `xstrdup` to make sure the string is not too long.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/914,14857718,2014-07-13T10:41:17Z,src/nvim/ui.c,"@@ -303,53 +303,48 @@ void set_input_buf(char_u *p)   } } -#if defined(FEAT_GUI) \-  || defined(FEAT_MOUSE_GPM) || defined(FEAT_SYSMOUSE) \-  || defined(FEAT_XCLIPBOARD) || defined(PROTO) /*  * Add the given bytes to the input buffer  * Special keys start with CSI.  A real CSI must have been translated to  * CSI KS_EXTRA KE_CSI.  K_SPECIAL doesn't require translation.+ *+ * Returns the amount of bytes writen  */-void add_to_input_buf(char_u *s, int len)+int64_t add_to_input_buf(char_u *s, int len) {   if (inbufcount + len > INBUFLEN + MAX_KEY_CODE_LEN)-    return;         /* Shouldn't ever happen! */--  if ((State & (INSERT|CMDLINE)) && hangul_input_state_get())-    if ((len = hangul_input_process(s, len)) == 0)-      return;+    return 0;         /* Shouldn't ever happen! */    while (len--)     inbuf[inbufcount++] = *s++;+  return len;","Seems a bit wrong indeed. Also if `-1` is the only possible error condition number `ssize_t` ""might"" be adequate. If we don't need to add more than `2^31` bytes to an input buffer (and there should probably be an assert for that, then).",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/949,14860064,2014-07-13T19:51:13Z,src/nvim/memory.c,"@@ -136,16 +135,21 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET {+  // Make sure we allocate at least one byte. calloc on a size of zero is+  // undefined and can return either NULL or a non-NULL pointer.","@philix said:> After studying all this, I realized how genius git's xmalloc() impl was [2]. We better stick to it. :-)> > [2] https://github.com/git/git/blob/master/wrapper.c#L45It remains unclear to me why git's implementation relies on such behaviour. Git's source assumes gcc (https://github.com/git/git/search?q=gcc&type=Code) so it may only work because of how gcc handles `calloc(0,0)`. nvim compiles with the `-std=gnu99` flag, but cannot compile with `-std=c99`. Does nvim intend to be C99-compatible? If not then I should definitely drop this PR.> The main idea for xmalloc is: do not return NULL as this is understood as OOM and xmalloc should handle OOM.That makes sense. So `xmalloc` shouldn't return `NULL` just because the user asked to allocate zero space. > For the case where size == 0 I think it's OK (and better) to stick to default malloc behavior.`calloc` (and presumably `malloc`) seems to allocate a minimum amount of space to ensure that the caller will have at least _some_  space, even if the standard discourages actually using it. I agree we should stick with the ""default"" behaviour, but by making it explicit. Perhaps by keeping the `malloc(1)` line, or even using a higher number.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/880,14870490,2014-07-14T09:44:37Z,src/nvim/screenline.h,"@@ -0,0 +1,7 @@+#ifndef NVIM_SCREENLINE_H+#define NVIM_SCREENLINE_H+","I forgot that we should include here all headers which contain types of parameters of functions in `screenline.h.generated.h`. `""nvim/buffer_defs.h""` for `win_T`, `<stdbool.h>` for `bool` and `""nvim/vim.h""` for `linenr_T` (though `linenr_T` will be moved to `""nvim/pos.h""` in #941)",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/839,14965563,2014-07-15T21:42:33Z,src/nvim/os/time.c,"@@ -22,6 +22,15 @@ void time_init(void)   uv_cond_init(&delay_cond); } +/// Obtain a high-resolution timer value","""timer"" standalone sounds the same to me, but ""timer value"" sounds like something that comes out of a timer, and implies ""relativity"" to me. That's why I chose it. But it makes no big difference to me, to be honest.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/953,14976356,2014-07-16T00:29:30Z,src/nvim/os/fs.c,"@@ -131,8 +157,13 @@ static bool is_executable_in_path(const char_u *name)     append_path((char *) buf, (const char *) name, (int)buf_len);      if (is_executable(buf)) {-      // Found our executable. Free buf and return.-      free(buf);+      if (ex != NULL) {+        // The user asked for ownership of the path.+        *ex = _save_executable_path(buf);+      } else {+        free(buf);","Looks like I got confused. I chose to stick close to the patch, but at first I thought `buf` needn't be duplicated if `buf[0] != '.'`, so `*ex = buf` in that case--except that duplicating the string shrinks the allocation space. I'll need to change that comment as well. ""asked for ownership"" -> ""requested a copy""",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/839,15023435,2014-07-16T19:59:27Z,src/nvim/eval.c,"@@ -11646,66 +11653,101 @@ static void f_readfile(typval_T *argvars, typval_T *rettv) }  -/*- * Convert a List to proftime_T.- * Return FAIL when there is something wrong.- */-static int list2proftime(typval_T *arg, proftime_T *tm)+/// list2proftime - convert a List to proftime_T+///+/// @param arg The input list, must be of type VAR_LIST and have+///            exactly 2 items+/// @param[out] tm The proftime_T representation of `arg`+/// @return OK In case of success, FAIL in case of error+static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL {-  long n1, n2;-  int error = FALSE;+  if (arg->v_type != VAR_LIST+      || arg->vval.v_list == NULL+      || arg->vval.v_list->lv_len != 2) {+    return FAIL;+  } -  if (arg->v_type != VAR_LIST || arg->vval.v_list == NULL-      || arg->vval.v_list->lv_len != 2)+  int error = false;+  varnumber_T n1 = list_find_nr(arg->vval.v_list, 0L, &error);+  varnumber_T n2 = list_find_nr(arg->vval.v_list, 1L, &error);+  if (error) {     return FAIL;-  n1 = list_find_nr(arg->vval.v_list, 0L, &error);-  n2 = list_find_nr(arg->vval.v_list, 1L, &error);-  tm->tv_sec = n1;-  tm->tv_usec = n2;-  return error ? FAIL : OK;+  }++  // in f_reltime() we split up the 64-bit proftime_T into two 32-bit+  // values, now we combine them again.","I'm sorry, I don't understand what you mean... `f_reltime` splits the `uint64_t` in two parts and returns it to the vimscript, this is then passed to `list2proftime` by the vimscripter.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/941,15026743,2014-07-16T20:52:48Z,src/nvim/types.h,"@@ -10,6 +10,14 @@  #include <stdint.h> +// dummy to pass an ACL to a function+typedef void *vim_acl_T;++// Make sure long_u is big enough to hold a pointer.","Also, as mentioned in the comments below, this would inhibit compiling on windows: [windows is LLP64](http://stackoverflow.com/questions/384502/what-is-the-bit-size-of-long-on-64-bit-windows). So I'm not really sure why the ""Make sure long_u is big enough to hold a pointer."" is there.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/941,15031289,2014-07-16T22:10:15Z,src/nvim/types.h,"@@ -10,6 +10,14 @@  #include <stdint.h> +// dummy to pass an ACL to a function+typedef void *vim_acl_T;++// Make sure long_u is big enough to hold a pointer.","Looks like Vim uses `__int64` on win64: https://github.com/b4winckler/vim/blob/master/src/vim.h#L397-L420So this comment makes no sense for Neovim currently, but we'll need to address it eventually (https://github.com/neovim/neovim/issues/459), of course.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/941,15032922,2014-07-16T22:50:25Z,src/nvim/types.h,"@@ -10,6 +10,14 @@  #include <stdint.h> +// dummy to pass an ACL to a function+typedef void *vim_acl_T;++// Make sure long_u is big enough to hold a pointer.","In that case, why don't we just do:``` ctypedef uintptr_t long_u;```And save @equalsraf a bunch of trouble?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/941,15034123,2014-07-16T23:21:31Z,src/nvim/types.h,"@@ -10,6 +10,14 @@  #include <stdint.h> +// dummy to pass an ACL to a function+typedef void *vim_acl_T;++// Make sure long_u is big enough to hold a pointer.",Yes! This must have been for C89 and/or older MSVC versions. [msinttypes.h](http://msinttypes.googlecode.com/svn/trunk/stdint.h) defines `uintptr_t` exactly Vim does (except for win32 it uses `int` instead of `long`),
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/962,15064504,2014-07-17T15:33:35Z,src/nvim/profile.c,"@@ -182,3 +186,96 @@ int profile_cmp(proftime_T tm1, proftime_T tm2) FUNC_ATTR_CONST {   return sgn64((int64_t)(tm2 - tm1)); }++#ifdef STARTUPTIME++static proftime_T g_start_time;+static proftime_T prev_timeval;","I agree with you, I had already made a note about renaming it. Time pressure ;).",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/904,15142093,2014-07-19T05:36:18Z,src/nvim/regexp.c,"@@ -1122,8 +1122,10 @@ static int reg_cpo_bsl; /* 'cpoptions' contains '\' flag */  static void get_cpo_flags(void) {-  reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;-  reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;+  if(p_cpo != NULL) {+     reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;+     reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;+  }","I ran into an issue because `p_cpo` wasn't set during my tests. I saw somewhere else checked `p_cpo != NULL` so I added that here. If that is inappropriate, I need to figure out how to initialize `p_cpo` properly.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/904,15146433,2014-07-19T22:49:23Z,src/nvim/main.c,"@@ -1483,7 +1483,7 @@ static void init_startuptime(mparm_T *paramp)  * Allocate space for the generic buffers (needed for set_init_1() and  * EMSG2()).  */-static void allocate_generic_buffers(void)+void allocate_generic_buffers(void)","...suprisingly, in vanilla vim `IObuff` is also dynamically allocated (but not `msg_buf`). Who changed it? The plot thickens...**EDIT**: Git blame to the rescue:``` gittree c084cde4dbad56ce29ab07a3ffd247aea86cfbf9parent 08059114349d689d2a45bbeb983fe78217ba5f1cauthor Thiago de Arruda <tpadilha84@gmail.com> Tue Apr 8 07:01:44 2014 -0300committer Thiago de Arruda <tpadilha84@gmail.com> Tue Apr 8 13:49:45 2014 -0300Fix/add more files with to clint-files.txt```Not that I'm blaming you @tarruda, I support this change, and I think that we should try it for `NameBuff` too. But something in my mind wonders why it wasn't done like this in the first place.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/904,15147406,2014-07-20T03:24:16Z,src/nvim/main.c,"@@ -1483,7 +1483,7 @@ static void init_startuptime(mparm_T *paramp)  * Allocate space for the generic buffers (needed for set_init_1() and  * EMSG2()).  */-static void allocate_generic_buffers(void)+void allocate_generic_buffers(void)",I'm guessing `NameBuff` was not converted along with the others because it caused tests to fail. I have updated the code so that it passes the tests. If there is a better way to fix things please let me know.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/904,15147652,2014-07-20T05:37:58Z,src/nvim/buffer.h,"@@ -5,32 +5,32 @@ #include ""nvim/ex_cmds_defs.h""  // for exarg_T  /* Values for buflist_getfile() */-#define GETF_SETMARK    0x01    /* set pcmark before jumping */-#define GETF_ALT        0x02    /* jumping to alternate file (not buf num) */-#define GETF_SWITCH     0x04    /* respect 'switchbuf' settings when jumping */+static const int GETF_SETMARK  = 0x01;   /* set pcmark before jumping */","There's a good discussion here, with some conflicting opinions: http://stackoverflow.com/a/1674459/152142 . But see also [c faq](http://c-faq.com/ansi/constasconst.html). The way we are currently accessing `#define` values is to provide them to the lua preprocessor like this: https://github.com/neovim/neovim/blob/master/test/includes/pre/sys/fcntl.h",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/904,15148030,2014-07-20T07:56:41Z,src/nvim/buffer.c,"@@ -846,11 +846,14 @@ do_buffer (   int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL                 || action == DOBUF_WIPE); -  switch (start) {-  case DOBUF_FIRST:   buf = firstbuf; break;-  case DOBUF_LAST:    buf = lastbuf;  break;-  default:            buf = curbuf;   break;+  if (start == DOBUF_FIRST) {+     buf = firstbuf;+  } else if (start == DOBUF_LAST) {+     buf = lastbuf;+  } else {+     buf = curbuf;   }+","The Stack Overflow link referenced by @justinmk says most of it really (refreshing to read). As long as they're (supposed to be) ints, enums seems better because they're true constants. Then we can also keep the switch, which looks cleaner. Otherwise, the extra lua header is better until I can update the Lua-C parser to handle simple `#define`'s properly.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/904,15148744,2014-07-20T10:16:06Z,src/nvim/ex_cmds.c,"@@ -5156,7 +5156,8 @@ void fix_help_buffer(void)           /* Find all ""doc/ *.txt"" files in this directory. */           add_pathsep(NameBuff);           STRCAT(NameBuff, ""doc/*.??[tx]"");-          if (gen_expand_wildcards(1, &NameBuff, &fcount,+          char_u *buff_list[1] = {(char_u*) NameBuff};+          if (gen_expand_wildcards(1, buff_list, &fcount,","It seems that taking the address of a statically sized array has different semantics:``` c(lldb) expr (void)printf(""%p %p\n"", NameBuff, &NameBuff);0x100291710 0x100291710```So `*&` would not be idempotent, which is why it crashes. This is also why your approach works.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/904,15150990,2014-07-20T17:59:21Z,src/nvim/main.c,"@@ -166,12 +166,6 @@ int main(int argc, char **argv)   /* Init the table of Normal mode commands. */   init_normal_cmds(); -  /*-   * Allocate space for the generic buffers (needed for set_init_1() and-   * EMSG2()).-   */-  allocate_generic_buffers();","Now the comment on line 147 above `mch_early_init()` is also no longer relevant. Can you trim it? Vim avoided allocating these buffers until now, in order to avoid OOM on startup--at least that's what I can gather. But I don't think that matters on modern systems, because statically-allocated arrays are not assigned real memory until they are accessed. For example:``` c#include <stdio.h>                        static int foo[1024*1024*100];            int main(int argc, char *argv[]) {    for(int i = 0; i < 1024*1024*100; i++) {    foo[i] = i; //touch the array to page it in  }      getchar();    return 0; }   ```In the above program, `htop` shows 400MB of real memory consumed:```VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND  404M  400M   324 S  0.0 10.1  0:00.40 ./a.out```But if `foo[i] = i;` is commented out, then resident memory is just 368 bytes:```VIRT  RES  SHR S  %CPU %MEM    TIME+  COMMAND  404M  368  288 S  0.0  0.0  0:00.30 ./a.out```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/904,15151098,2014-07-20T18:17:03Z,test/unit/fileio_spec.lua,"@@ -0,0 +1,84 @@+local helpers = require(""test.unit.helpers"")+--{:cimport, :internalize, :eq, :neq, :ffi, :lib, :cstr, :to_cstr} = require 'test.unit.helpers'++local eq      = helpers.eq+local ffi     = helpers.ffi+local to_cstr = helpers.to_cstr++local fileio = helpers.cimport(""./src/nvim/fileio.h"")++describe('file_pat functions', function()+   describe('file_pat_to_reg_pat', function()++      local file_pat_to_reg_pat = function(pat)+         local pat = to_cstr(pat)+         local res = fileio.file_pat_to_reg_pat(pat, NULL, NULL, 0)+         return ffi.string(res)+      end++      it('converts a plaintext path to a regex with ^ and $', function()+         eq( '^path$', file_pat_to_reg_pat('path'))+      end)++      it('does not include ^ when there is a starting glob (*)', function()+         eq('path$', file_pat_to_reg_pat('*path'))+      end)++      it('does not include $ when there is an ending glob (*)', function()+         eq('^path', file_pat_to_reg_pat('path*'))+      end)++      it('does not include ^ or $ when surrounded by globs (*)', function()+        eq('path', file_pat_to_reg_pat('*path*'))+      end)++      it('replaces the bash any character (?) with the regex any character (.)', function()+        eq('^foo.bar$', file_pat_to_reg_pat('foo?bar'))+      end)++      it('replaces a glob (*) in the middle of a path with regex multiple any character (.*)',+         function()+        eq('^foo.*bar$', file_pat_to_reg_pat('foo*bar'))+      end)++      it([[unescapes \? to ?]], function()+        eq('^foo?bar$', file_pat_to_reg_pat([[foo\?bar]]))+      end)++      it([[unescapes \% to %]], function()+        eq('^foo%bar$', file_pat_to_reg_pat([[foo\%bar]]))+      end)++      it([[unescapes \, to ,]], function()+        eq('^foo,bar$', file_pat_to_reg_pat([[foo\,bar]]))+      end)++      it([[unescapes '\ ' to ' ']], function()+        eq('^foo bar$', file_pat_to_reg_pat([[foo\ bar]]))+      end)++      it([[escapes . to \.]], function()+        eq([[^foo\.bar$]], file_pat_to_reg_pat('foo.bar'))+      end)++      it('Converts bash brace expansion {a,b} to regex options (a|b)', function()+        eq([[^foo\(bar\|baz\)$]], file_pat_to_reg_pat('foo{bar,baz}'))+      end)++      it('Collapses multiple consecutive * into a single character', function()+        eq([[^foo.*bar$]], file_pat_to_reg_pat('foo*******bar'))+        eq([[foobar$]], file_pat_to_reg_pat('********foobar'))+        eq([[^foobar]], file_pat_to_reg_pat('foobar********'))+      end)++      it('Does not escape ^', function()+        eq([[^^blah$]], file_pat_to_reg_pat('^blah'))+        eq([[^foo^bar$]], file_pat_to_reg_pat('foo^bar'))+      end)++      it('Does not escape $', function()",can you create a ticket for this? Need to check if this is a regression or ask vim_dev mailing list.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/904,15151857,2014-07-20T20:27:09Z,src/nvim/ex_cmds.c,"@@ -5156,7 +5156,8 @@ void fix_help_buffer(void)           /* Find all ""doc/ *.txt"" files in this directory. */           add_pathsep(NameBuff);           STRCAT(NameBuff, ""doc/*.??[tx]"");-          if (gen_expand_wildcards(1, &NameBuff, &fcount,+          char_u *buff_list[1] = {(char_u*) NameBuff};+          if (gen_expand_wildcards(1, buff_list, &fcount,","> Is there actually a good reason why NameBuff isn't statically allocated like IOBuff and msg_buf? After looking into this I'm fairly confident that the primary reason Vim wasn't statically allocating NameBuff is to avoid having to change the signature of `gen_expand_wildcards()`. I'm not even sure it was OOM-related as I first thought.c faq: ""An array reference is not a pointer"": http://c-faq.com/aryptr/aryptr2.html , http://c-faq.com/aryptr/aryvsadr.html> (lldb) expr (void)printf(""%p %p\n"", NameBuff, &NameBuff);> 0x100291710 0x100291710Doesn't this just illustrate the fact that [""array references decay into pointers""](http://c-faq.com/aryptr/aryvsadr.html)?I think at this point our options are: (1) change the signature of `gen_expand_wildcards`, (2) leave NameBuff as a dynamic allocation to avoid insane array semantics, or (3) use @war1025 approach (nicely done). All the options feel a bit dirty to me because they leave some WTFs scattered in the codebase for future readers :)",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/904,15151913,2014-07-20T20:40:38Z,src/nvim/main.c,"@@ -166,12 +166,6 @@ int main(int argc, char **argv)   /* Init the table of Normal mode commands. */   init_normal_cmds(); -  /*-   * Allocate space for the generic buffers (needed for set_init_1() and-   * EMSG2()).-   */-  allocate_generic_buffers();",> statically-allocated arrays are not assigned real memory until they are accessed@aktau Are you sure that's what is happening and it's not simply being optimized away because it's unused?  I suspect it is... at least if you're compiling with `-O2`.,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/904,15152108,2014-07-20T21:30:27Z,src/nvim/main.c,"@@ -166,12 +166,6 @@ int main(int argc, char **argv)   /* Init the table of Normal mode commands. */   init_normal_cmds(); -  /*-   * Allocate space for the generic buffers (needed for set_init_1() and-   * EMSG2()).-   */-  allocate_generic_buffers();","Yes, that works too.  I just wanted to make sure that what @aktau was looking at was actually real and not some side-effect of the compiler.  Like I said, I missed the fact that the virtual size was 404MB, so it's still there in his example, but the data hasn't been touched so the data has been paged in.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/904,15153377,2014-07-21T01:30:01Z,src/nvim/ex_cmds.c,"@@ -5156,7 +5156,8 @@ void fix_help_buffer(void)           /* Find all ""doc/ *.txt"" files in this directory. */           add_pathsep(NameBuff);           STRCAT(NameBuff, ""doc/*.??[tx]"");-          if (gen_expand_wildcards(1, &NameBuff, &fcount,+          char_u *buff_list[1] = {(char_u*) NameBuff};+          if (gen_expand_wildcards(1, buff_list, &fcount,",@aktau I like the way I have it since the function asks for a list of `char_u*` which is what I'm making. I will switch it to your way if you want. I'm not hard up on it. Either way it would probably be good to add in a comment about why it is needed.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/840,15159104,2014-07-21T08:47:20Z,scripts/genex_cmds.lua,"@@ -0,0 +1,87 @@+local nvimsrcdir = arg[1]",Might not be such a bad idea... bit careful though: http://lua-users.org/lists/lua-l/2012-03/msg00874.htmlMany packages seem to include it manually in their source tree.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/840,15161604,2014-07-21T10:06:43Z,scripts/genex_cmds.lua,"@@ -0,0 +1,87 @@+local nvimsrcdir = arg[1]+local includedir = arg[2]+local autodir = arg[3]++if nvimsrcdir == '--help' then+  print ([[+Usage:+  lua genex_cmds.lua src/nvim build/include build/src/nvim/auto++Will generate files build/src/nvim/auto/ex_cmds_enum.generated.h with cmdidx_T +enum and build/src/nvim/auto/ex_cmds_defs.generated.h with main Ex commands +definitions.+]])+  os.exit(0)+end++package.path = nvimsrcdir .. '/?.lua;' .. package.path++local enumfname = includedir .. '/ex_cmds_enum.generated.h'+local defsfname = autodir .. '/ex_cmds_defs.generated.h'++local enumfile = io.open(enumfname, 'w')+local defsfile = io.open(defsfname, 'w')++local defs = require('ex_cmds')+local lastchar = nil++local i+local cmd+local first = true+local prevfirstchar = nil++local byte_a = string.byte('a')+local byte_z = string.byte('z')++local cmdidxs = string.format([[+static const cmdidx_T cmdidxs[%u] = {+]], byte_z - byte_a + 2)++enumfile:write([[+typedef enum CMD_index {+]])+defsfile:write(string.format([[+static CommandDefinition cmdnames[%u] = {+]], #defs))",> AFAIR I do not have non-integer keys or nil values. It will only be risky if we have enough commands to experience precision loss. If you see a place where this is not true please point it.When we have more than 2^53 commands I suppose we'll have bigger problems. Perhaps a comment above the table itself to not leave gaps or have nil values.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/840,15162019,2014-07-21T10:22:39Z,scripts/genex_cmds.lua,"@@ -0,0 +1,87 @@+local nvimsrcdir = arg[1]+local includedir = arg[2]+local autodir = arg[3]++if nvimsrcdir == '--help' then+  print ([[+Usage:+  lua genex_cmds.lua src/nvim build/include build/src/nvim/auto++Will generate files build/src/nvim/auto/ex_cmds_enum.generated.h with cmdidx_T +enum and build/src/nvim/auto/ex_cmds_defs.generated.h with main Ex commands +definitions.+]])+  os.exit(0)+end++package.path = nvimsrcdir .. '/?.lua;' .. package.path++local enumfname = includedir .. '/ex_cmds_enum.generated.h'+local defsfname = autodir .. '/ex_cmds_defs.generated.h'++local enumfile = io.open(enumfname, 'w')+local defsfile = io.open(defsfname, 'w')++local defs = require('ex_cmds')+local lastchar = nil++local i+local cmd+local first = true+local prevfirstchar = nil++local byte_a = string.byte('a')+local byte_z = string.byte('z')++local cmdidxs = string.format([[+static const cmdidx_T cmdidxs[%u] = {+]], byte_z - byte_a + 2)++enumfile:write([[+typedef enum CMD_index {+]])+defsfile:write(string.format([[+static CommandDefinition cmdnames[%u] = {+]], #defs))","On July 21, 2014 2:06:49 PM GMT+03:00, Nicolas Hillegeer notifications@github.com wrote:> > +local first = true> > +local prevfirstchar = nil> > +> > +local byte_a = string.byte('a')> > +local byte_z = string.byte('z')> > +> > +local cmdidxs = string.format([[> > +static const cmdidx_T cmdidxs[%u] = {> > +]], byte_z - byte_a + 2)> > +> > +enumfile:write([[> > +typedef enum CMD_index {> > +]])> > +defsfile:write(string.format([[> > +static CommandDefinition cmdnames[%u] = {> > +]], #defs))> > > > AFAIR I do not have non-integer keys or nil values. It will only be> > risky if we have enough commands to experience precision loss. If you> > see a place where this is not true please point it.> > When we have more than 2^53 commands I suppose we'll have bigger> problems. Perhaps a comment above the table itself to not leave gaps or> have nil values.> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/840/files#r15161604There is an infinite number of incorrect things that must not be added to the table thus I do not see a reason to specially say about nil.Though documentation about what exactly should be there in the table is the way to go: current state is not much different from former ex_cmds_defs.h which assumed programmer is smart enough to deduce what is there in that huge array (which honestly was not too hard).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/975,15172846,2014-07-21T14:55:29Z,src/nvim/term.c,"@@ -3955,17 +3947,17 @@ int check_termcode(int max_offset, char_u *buf, int bufsize, int *buflen)       } else if (wheel_code == 0)   { # ifdef CHECK_DOUBLE_CLICK","That's also a really good catch. See this:``` c#if defined(UNIX) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)# define CHECK_DOUBLE_CLICK 1  /* Checking for double clicks ourselves. */#endif```As far as I can see, that would mean that the `DOUBLE_CLICK` code would no longer be activated after the commit in which I removed the cmake detection.I also don't know why it asks for `defined(UNIX)` because in the `:help` it says that this also works for Windows. Did it get lost in the vim/neovim split?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/904,15209175,2014-07-22T03:25:22Z,test/unit/buffer_spec.lua,"@@ -0,0 +1,195 @@+local helpers = require(""test.unit.helpers"")++local to_cstr = helpers.to_cstr+local eq      = helpers.eq++helpers.vim_init()++local buffer = helpers.cimport(""./src/nvim/buffer.h"")+local window = helpers.cimport(""./src/nvim/window.h"")+local option = helpers.cimport(""./src/nvim/option.h"")++--{ Initialize the options needed for interacting with buffers+window.win_alloc_first()+option.set_init_1()+--}++describe('buffer functions', function()++  local buflist_new = function(file, flags)+    local file = to_cstr(file)+    return buffer.buflist_new(file, file, 1, flags)+  end++  local close_buffer = function(win, buf, action, abort_if_last)+    return buffer.close_buffer(win, buf, action, abort_if_last)+  end++  local path1 = 'test_file_path'+  local path2 = 'file_path_test'+  local path3 = 'path_test_file'++  before_each(function()+    -- create the files+    io.open(path1, 'w').close()+    io.open(path2, 'w').close()+    io.open(path3, 'w').close()+  end)++  after_each(function()+    os.remove(path1)+    os.remove(path2)+    os.remove(path3)+  end)++  describe('buf_valid', function()++    it('should view NULL as an invalid buffer', function()+      eq(0, buffer.buf_valid(NULL))+    end)++    it('should view an open buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and hidden buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, 0, 0)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and unloaded buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, buffer.DOBUF_UNLOAD, 0)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and wiped buffer as invalid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, buffer.DOBUF_WIPE, 0)++      eq(0, buffer.buf_valid(buf))+    end)+  end)+++  describe('buflist_findpat', function()++    local buflist_findpat = function(pat, allow_unlisted)+      local pat = to_cstr(pat)+      local allow_unlisted = allow_unlisted or 0+      return buffer.buflist_findpat(pat, NULL, allow_unlisted, 0, 0)+    end++    it('should find exact matches', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      eq(buf.b_fnum, buflist_findpat(path1))++      close_buffer(NULL, buf, buffer.DOBUF_WIPE, 0)+    end)++    it('should prefer to match the start of a file path', function()+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf1.b_fnum, buflist_findpat(""test""))",But this could also be dependent on the order of the buffers (buf1 happens to be the first buffer). Probably need another test for that or re-order the buffers in this test and repeat the assert.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/904,15209448,2014-07-22T03:38:59Z,test/unit/buffer_spec.lua,"@@ -0,0 +1,195 @@+local helpers = require(""test.unit.helpers"")++local to_cstr = helpers.to_cstr+local eq      = helpers.eq++helpers.vim_init()++local buffer = helpers.cimport(""./src/nvim/buffer.h"")+local window = helpers.cimport(""./src/nvim/window.h"")+local option = helpers.cimport(""./src/nvim/option.h"")++--{ Initialize the options needed for interacting with buffers+window.win_alloc_first()+option.set_init_1()+--}++describe('buffer functions', function()++  local buflist_new = function(file, flags)+    local file = to_cstr(file)+    return buffer.buflist_new(file, file, 1, flags)+  end++  local close_buffer = function(win, buf, action, abort_if_last)+    return buffer.close_buffer(win, buf, action, abort_if_last)+  end++  local path1 = 'test_file_path'+  local path2 = 'file_path_test'+  local path3 = 'path_test_file'++  before_each(function()+    -- create the files+    io.open(path1, 'w').close()+    io.open(path2, 'w').close()+    io.open(path3, 'w').close()+  end)++  after_each(function()+    os.remove(path1)+    os.remove(path2)+    os.remove(path3)+  end)++  describe('buf_valid', function()++    it('should view NULL as an invalid buffer', function()+      eq(0, buffer.buf_valid(NULL))+    end)++    it('should view an open buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and hidden buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, 0, 0)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and unloaded buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, buffer.DOBUF_UNLOAD, 0)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and wiped buffer as invalid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, buffer.DOBUF_WIPE, 0)++      eq(0, buffer.buf_valid(buf))+    end)+  end)+++  describe('buflist_findpat', function()++    local buflist_findpat = function(pat, allow_unlisted)+      local pat = to_cstr(pat)+      local allow_unlisted = allow_unlisted or 0+      return buffer.buflist_findpat(pat, NULL, allow_unlisted, 0, 0)+    end++    it('should find exact matches', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      eq(buf.b_fnum, buflist_findpat(path1))++      close_buffer(NULL, buf, buffer.DOBUF_WIPE, 0)+    end)++    it('should prefer to match the start of a file path', function()+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf1.b_fnum, buflist_findpat(""test""))++      close_buffer(NULL, buf1, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf2, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)+    end)++    it('should prefer to match the end of a file over the middle', function()+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf2.b_fnum, buflist_findpat(""test""))++      close_buffer(NULL, buf2, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)+    end)++    it('should match a unique fragment of a file path', function()+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf3.b_fnum, buflist_findpat(""_test_""))++      close_buffer(NULL, buf1, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf2, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)+    end)++    it('should include / ignore unlisted buffers based on the flag.', function()+      --{ Given: A buffer+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      -- Then: We should find the buffer when it is given a unique pattern+      eq(buf3.b_fnum, buflist_findpat(""_test_""))+      --}++      --{ When: We unlist the buffer+      close_buffer(NULL, buf3, buffer.DOBUF_DEL, 0)++      -- Then: It should not find the buffer when searching only listed buffers+      eq(-1, buflist_findpat(""_test_""))++      -- And: It should find the buffer when including unlisted buffers+      eq(buf3.b_fnum, buflist_findpat(""_test_"", 1))+      --}++      --{ When: We wipe the buffer+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)++      -- Then: It should not find the buffer at all+      eq(-1, buflist_findpat(""_test_""))+      eq(-1, buflist_findpat(""_test_"", 1))+      --}+    end)++    it('should prefer listed buffers to unlisted buffers.', function()+      --{ Given: Two buffers that match a pattern+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)++      -- Then: The first buffer is preferred when both are listed+      eq(buf1.b_fnum, buflist_findpat(""test""))","> The first buffer is preferred when both are listedBut in a test above, this buffer is preferred because `test_` is at the start of the buffer name. So this comment would make more sense if both buffer names started with `test_` in this test, showing that order was the tie-breaker here.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/904,15209477,2014-07-22T03:41:12Z,test/unit/buffer_spec.lua,"@@ -0,0 +1,195 @@+local helpers = require(""test.unit.helpers"")++local to_cstr = helpers.to_cstr+local eq      = helpers.eq++helpers.vim_init()++local buffer = helpers.cimport(""./src/nvim/buffer.h"")+local window = helpers.cimport(""./src/nvim/window.h"")+local option = helpers.cimport(""./src/nvim/option.h"")++--{ Initialize the options needed for interacting with buffers+window.win_alloc_first()+option.set_init_1()+--}++describe('buffer functions', function()++  local buflist_new = function(file, flags)+    local file = to_cstr(file)+    return buffer.buflist_new(file, file, 1, flags)+  end++  local close_buffer = function(win, buf, action, abort_if_last)+    return buffer.close_buffer(win, buf, action, abort_if_last)+  end++  local path1 = 'test_file_path'+  local path2 = 'file_path_test'+  local path3 = 'path_test_file'++  before_each(function()+    -- create the files+    io.open(path1, 'w').close()+    io.open(path2, 'w').close()+    io.open(path3, 'w').close()+  end)++  after_each(function()+    os.remove(path1)+    os.remove(path2)+    os.remove(path3)+  end)++  describe('buf_valid', function()++    it('should view NULL as an invalid buffer', function()+      eq(0, buffer.buf_valid(NULL))+    end)++    it('should view an open buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and hidden buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, 0, 0)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and unloaded buffer as valid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, buffer.DOBUF_UNLOAD, 0)++      eq(1, buffer.buf_valid(buf))+    end)++    it('should view a closed and wiped buffer as invalid', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      close_buffer(NULL, buf, buffer.DOBUF_WIPE, 0)++      eq(0, buffer.buf_valid(buf))+    end)+  end)+++  describe('buflist_findpat', function()++    local buflist_findpat = function(pat, allow_unlisted)+      local pat = to_cstr(pat)+      local allow_unlisted = allow_unlisted or 0+      return buffer.buflist_findpat(pat, NULL, allow_unlisted, 0, 0)+    end++    it('should find exact matches', function()+      local buf = buflist_new(path1, buffer.BLN_LISTED)++      eq(buf.b_fnum, buflist_findpat(path1))++      close_buffer(NULL, buf, buffer.DOBUF_WIPE, 0)+    end)++    it('should prefer to match the start of a file path', function()+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf1.b_fnum, buflist_findpat(""test""))++      close_buffer(NULL, buf1, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf2, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)+    end)++    it('should prefer to match the end of a file over the middle', function()+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf2.b_fnum, buflist_findpat(""test""))++      close_buffer(NULL, buf2, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)+    end)++    it('should match a unique fragment of a file path', function()+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      eq(buf3.b_fnum, buflist_findpat(""_test_""))++      close_buffer(NULL, buf1, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf2, buffer.DOBUF_WIPE, 0)+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)+    end)++    it('should include / ignore unlisted buffers based on the flag.', function()+      --{ Given: A buffer+      local buf3 = buflist_new(path3, buffer.BLN_LISTED)++      -- Then: We should find the buffer when it is given a unique pattern+      eq(buf3.b_fnum, buflist_findpat(""_test_""))+      --}++      --{ When: We unlist the buffer+      close_buffer(NULL, buf3, buffer.DOBUF_DEL, 0)++      -- Then: It should not find the buffer when searching only listed buffers+      eq(-1, buflist_findpat(""_test_""))++      -- And: It should find the buffer when including unlisted buffers+      eq(buf3.b_fnum, buflist_findpat(""_test_"", 1))+      --}++      --{ When: We wipe the buffer+      close_buffer(NULL, buf3, buffer.DOBUF_WIPE, 0)++      -- Then: It should not find the buffer at all+      eq(-1, buflist_findpat(""_test_""))+      eq(-1, buflist_findpat(""_test_"", 1))+      --}+    end)++    it('should prefer listed buffers to unlisted buffers.', function()+      --{ Given: Two buffers that match a pattern+      local buf1 = buflist_new(path1, buffer.BLN_LISTED)+      local buf2 = buflist_new(path2, buffer.BLN_LISTED)++      -- Then: The first buffer is preferred when both are listed+      eq(buf1.b_fnum, buflist_findpat(""test""))","I think the current flow works.What I am trying to demonstrate in the test is that while `buf1` is preferred when both are listed (as you stated), once `buf1` becomes unlisted, `buf2` is preferred.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/978,15218140,2014-07-22T09:28:47Z,src/nvim/os/shell.c,"@@ -237,6 +241,123 @@ int os_call_shell(char_u *cmd, ShellOpts opts, char_u *extra_shell_arg)   return proc_cleanup_exit(&pdata, &proc_opts, opts); } +#include ""nvim/log.h""++/// os_system - synchronously execute a command in the shell+///+/// example:+///   char *output = NULL;+///   size_t nread = 0;+///   int status = os_sytem(""ls -la"", NULL, 0, &output, &nread);+///+/// @param cmd The full commandline to be passed to the shell+/// @param input The input to the shell (NULL for no input), passed to the+///              stdin of the resulting process.+/// @param len The length of the input buffer (not used if `input` == NULL)+/// @param[out] output A pointer to to a location where the output will be+///                    allocated and stored. Will be NULL if the shell command+///                    did not output anything. Pass NULL if no+///                    output is desired.+/// @param[out] nread the number of bytes in the returned buffer (if the+///             returned buffer is not NULL)+/// @return the return code of the process, -1 if the process couldn't be+///         started properly+int os_system(const char *cmd,+              const char *input,+              size_t len,+              char **output,+              size_t *nread)+{+  // the output buffer+  dyn_buffer_t buf;+  memset(&buf, 0, sizeof(buf));++  char **argv = shell_build_argv((char_u *) cmd, NULL);++  ELOG(""starting: %s %s %s"", argv[0], argv[1], argv[2]);+  int i;+  Job *job = job_start(argv,+                       output ? &buf : NULL,+                       output ? system_data_cb : NULL,",If the job outputs data then `read_cb` in `job.c` tries to call this callback (no NULL check). Likewise for the next argument.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/978,15219362,2014-07-22T10:02:16Z,src/nvim/os/shell.c,"@@ -237,6 +241,123 @@ int os_call_shell(char_u *cmd, ShellOpts opts, char_u *extra_shell_arg)   return proc_cleanup_exit(&pdata, &proc_opts, opts); } +#include ""nvim/log.h""++/// os_system - synchronously execute a command in the shell+///+/// example:+///   char *output = NULL;+///   size_t nread = 0;+///   int status = os_sytem(""ls -la"", NULL, 0, &output, &nread);+///+/// @param cmd The full commandline to be passed to the shell+/// @param input The input to the shell (NULL for no input), passed to the+///              stdin of the resulting process.+/// @param len The length of the input buffer (not used if `input` == NULL)+/// @param[out] output A pointer to to a location where the output will be+///                    allocated and stored. Will be NULL if the shell command+///                    did not output anything. Pass NULL if no+///                    output is desired.+/// @param[out] nread the number of bytes in the returned buffer (if the+///             returned buffer is not NULL)+/// @return the return code of the process, -1 if the process couldn't be+///         started properly+int os_system(const char *cmd,+              const char *input,+              size_t len,+              char **output,+              size_t *nread)+{+  // the output buffer+  dyn_buffer_t buf;+  memset(&buf, 0, sizeof(buf));++  char **argv = shell_build_argv((char_u *) cmd, NULL);++  ELOG(""starting: %s %s %s"", argv[0], argv[1], argv[2]);+  int i;+  Job *job = job_start(argv,+                       output ? &buf : NULL,+                       output ? system_data_cb : NULL,","We can't inherit the parent's std{out,err} because it won't work for UIs over msgpack-rpc. For now simply forward to nvim stdout explicitly(if the ""pipe"" option is not used), later we will use a specialized log bufer for displaying output from child processes(ref #901)You might need to create a struct that encapsulates the dynamic buffer and the os_system options, and pass it as the job data to handle the job callbacks correctly.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/978,15219691,2014-07-22T10:10:54Z,src/nvim/os/shell.c,"@@ -237,6 +241,123 @@ int os_call_shell(char_u *cmd, ShellOpts opts, char_u *extra_shell_arg)   return proc_cleanup_exit(&pdata, &proc_opts, opts); } +#include ""nvim/log.h""++/// os_system - synchronously execute a command in the shell+///+/// example:+///   char *output = NULL;+///   size_t nread = 0;+///   int status = os_sytem(""ls -la"", NULL, 0, &output, &nread);+///+/// @param cmd The full commandline to be passed to the shell+/// @param input The input to the shell (NULL for no input), passed to the+///              stdin of the resulting process.+/// @param len The length of the input buffer (not used if `input` == NULL)+/// @param[out] output A pointer to to a location where the output will be+///                    allocated and stored. Will be NULL if the shell command+///                    did not output anything. Pass NULL if no+///                    output is desired.+/// @param[out] nread the number of bytes in the returned buffer (if the+///             returned buffer is not NULL)+/// @return the return code of the process, -1 if the process couldn't be+///         started properly+int os_system(const char *cmd,+              const char *input,+              size_t len,+              char **output,+              size_t *nread)+{+  // the output buffer+  dyn_buffer_t buf;+  memset(&buf, 0, sizeof(buf));++  char **argv = shell_build_argv((char_u *) cmd, NULL);++  ELOG(""starting: %s %s %s"", argv[0], argv[1], argv[2]);+  int i;+  Job *job = job_start(argv,+                       output ? &buf : NULL,+                       output ? system_data_cb : NULL,","> We can't inherit the parent's std{out,err} because it won't work for UIs over msgpack-rpc.I didn't mean inheriting the parent's (nvim)'s stdout/stderr, I meant not opening the pipes at all. That way there could never be any data to read (and the process could also known that it's not expected to output anything). Not sure what the OS does if the process tries to write to such an FD. Perhaps send it to /dev/null efficiently.> You might need to create a struct that encapsulates the dynamic buffer and the os_system options, and pass it as the job data to handle the job callbacks correctly.I'm really not sure why that would be necessary, it works fine as is. Can you give an example?",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/978,15224656,2014-07-22T12:36:46Z,src/nvim/os/shell.c,"@@ -237,6 +241,123 @@ int os_call_shell(char_u *cmd, ShellOpts opts, char_u *extra_shell_arg)   return proc_cleanup_exit(&pdata, &proc_opts, opts); } +#include ""nvim/log.h""++/// os_system - synchronously execute a command in the shell+///+/// example:+///   char *output = NULL;+///   size_t nread = 0;+///   int status = os_sytem(""ls -la"", NULL, 0, &output, &nread);+///+/// @param cmd The full commandline to be passed to the shell+/// @param input The input to the shell (NULL for no input), passed to the+///              stdin of the resulting process.+/// @param len The length of the input buffer (not used if `input` == NULL)+/// @param[out] output A pointer to to a location where the output will be+///                    allocated and stored. Will be NULL if the shell command+///                    did not output anything. Pass NULL if no+///                    output is desired.+/// @param[out] nread the number of bytes in the returned buffer (if the+///             returned buffer is not NULL)+/// @return the return code of the process, -1 if the process couldn't be+///         started properly+int os_system(const char *cmd,+              const char *input,+              size_t len,+              char **output,+              size_t *nread)+{+  // the output buffer+  dyn_buffer_t buf;+  memset(&buf, 0, sizeof(buf));++  char **argv = shell_build_argv((char_u *) cmd, NULL);++  ELOG(""starting: %s %s %s"", argv[0], argv[1], argv[2]);+  int i;+  Job *job = job_start(argv,+                       output ? &buf : NULL,+                       output ? system_data_cb : NULL,","> I'm not sure what's the windows behavior regarding full OS buffers.If anything bad happens, I'd consider it a libuv bug. Ignore is ignore.>  The os_system callback must read output from the child process(it always will open a PIPE even if NULL is passed as the output argument) and forward to nvim stdout from the read callbackTechnically we could catch all the output and throw it to the screen after being done, like `os_system` does now, but that's not efficient. To support something like this (as in the current incarnation of vim/nvim), we'd indeed have to alter `job_start` to be able to override the FD's or something.Ok I'll leave out the optionality of the output for now.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/985,15284046,2014-07-23T12:14:57Z,src/nvim/arabic.c,"@@ -1374,9 +1374,6 @@ int arabic_shape(int c, int *ccp, int *c1p, int prev_c, int prev_c1,   /* half-shape current and previous character */   shape_c = half_shape(prev_c); -  /* Save away current character */-  curr_c = c;",It's only a dead store because all of the following if branches will set `curr_c`. What if the code below is changed? We may end up with an uninitialized `curr_c`. What if declare and initialize `curr_c` here (`int curr_c = c;`)? It's a good practice to initialize variables. Specially before a set of branches that write to it.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/985,15284086,2014-07-23T12:16:46Z,src/nvim/message.c,"@@ -3585,7 +3584,6 @@ int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs)                * zero value is formatted with an                * explicit precision of zero */               precision = num_of_digits + 1;-              precision_specified = 1;",This is another dead store that I don't think should be removed.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/985,15284360,2014-07-23T12:26:41Z,src/nvim/screen.c,"@@ -3758,7 +3758,6 @@ win_line (       /* Get rid of the boguscols now, we want to draw until the right        * edge for 'cursorcolumn'. */       col -= boguscols;-      boguscols = 0;",The `win_line` function starts in line 2177 and ends in line 4139. We should definitely refactor it. Removing the dead store makes it even more fragile.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/985,15284744,2014-07-23T12:37:17Z,src/nvim/search.c,"@@ -3784,7 +3784,6 @@ current_search (     orig_pos = curwin->w_cursor;      pos = curwin->w_cursor;-    start_pos = VIsual;","The else branch of this `if` has `orig_pos = pos = start_pos = curwin->w_cursor;`. You can actually remove `start_pos` from that line too [1]. Then, on line `3848` you can replace `start_pos = pos;` with `pos_T start_pos = pos;`.[1] It wasn't considered a dead store because the `orig_pos = pos = start_pos = curwin->w_cursor` line sets and reads it, however we can see that `start_pos` is unnecessary there.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/985,15284959,2014-07-23T12:43:52Z,src/nvim/spell.c,"@@ -1606,7 +1605,6 @@ static void find_word(matchinf_T *mip, int mode)             mip->mi_compoff = (int)(p - mip->mi_fword);           }         }-        c = mip->mi_compoff;",Another place where removing the dead store may be bad.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/978,15440963,2014-07-27T19:10:01Z,src/nvim/eval.c,"@@ -14077,76 +14077,58 @@ static void f_synstack(typval_T *argvars, typval_T *rettv)   } } -/*- * ""system()"" function- */+/// f_system - the VimL system() function static void f_system(typval_T *argvars, typval_T *rettv) {-  char_u      *res = NULL;-  char_u      *p;-  char_u      *infile = NULL;+  rettv->v_type = VAR_STRING;+  rettv->vval.v_string = NULL;++  if (check_restricted() || check_secure()) {+    return;+  }++  // get input to the shell command (if any), and its length   char_u buf[NUMBUFLEN];-  int err = FALSE;-  FILE        *fd;+  const char *input = (argvars[1].v_type != VAR_UNKNOWN)+      ? (char *) get_tv_string_buf_chk(&argvars[1], buf): NULL;+  size_t input_len = input ? strlen(input) : 0; -  if (check_restricted() || check_secure())-    goto done;+  // get shell command to execute+  const char *cmd = (char *) get_tv_string(&argvars[0]); -  if (argvars[1].v_type != VAR_UNKNOWN) {-    /*-     * Write the string to a temp file, to be used for input of the shell-     * command.-     */-    if ((infile = vim_tempname()) == NULL) {-      EMSG(_(e_notmp));-      goto done;-    }+  // execute the command+  size_t nread = 0;+  char *res = NULL;+  int status = os_system(cmd, input, input_len, &res, &nread); -    fd = mch_fopen((char *)infile, WRITEBIN);-    if (fd == NULL) {-      EMSG2(_(e_notopen), infile);-      goto done;-    }-    p = get_tv_string_buf_chk(&argvars[1], buf);-    if (p == NULL) {-      fclose(fd);-      goto done;                /* type error; errmsg already given */-    }-    if (fwrite(p, STRLEN(p), 1, fd) != 1)-      err = TRUE;-    if (fclose(fd) != 0)-      err = TRUE;-    if (err) {-      EMSG(_(""E677: Error writing temp file""));-      goto done;+  set_vim_var_nr(VV_SHELL_ERROR, (long) status);++#if defined(USE_CR)",@aktau This is for Mac OS classic (9) so it can be removed. USE_CR was removed by 01ca4600bae9cd1aa5f0cfe4fc4294e7da0b4ee3,
144418,atwupack,https://api.github.com/repos/neovim/neovim/pulls/971,15574000,2014-07-30T09:34:30Z,src/nvim/edit.c,"@@ -4597,13 +4601,17 @@ static int ins_complete(int c)    /* Show a message about what (completion) mode we're in. */   showmode();-  if (edit_submode_extra != NULL) {-    if (!p_smd)-      msg_attr(edit_submode_extra,+  if (!shortmess(SHM_COMPLETIONMENU)) {+    if (edit_submode_extra != NULL) {+      if (!p_smd) {+        msg_attr(edit_submode_extra,           edit_submode_highl < HLF_COUNT",The function parameters should be aligned with the first parameter.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/823,15646607,2014-07-31T14:52:16Z,src/nvim/api/buffer.c,"@@ -177,8 +166,19 @@ void buffer_set_slice(Buffer buffer,   buf_T *save_curbuf = NULL;   win_T *save_curwin = NULL;   tabpage_T *save_curtab = NULL;+   size_t new_len = replacement.size;+  if (!(new_len <= SIZE_MAX)) {",A buffer can only have `LONG_MAX` lines (`ml_line_count` is of type `long`). So trying to add more than `LONG_MAX` lines is already an error.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1019,15734519,2014-08-03T13:51:02Z,src/nvim/eval.c,"@@ -9605,27 +9605,50 @@ static void f_glob(typval_T *argvars, typval_T *rettv)     rettv->vval.v_string = NULL; } -/*- * ""globpath()"" function- */+/// ""globpath()"" function static void f_globpath(typval_T *argvars, typval_T *rettv) {-  int flags = 0;-  char_u buf1[NUMBUFLEN];-  char_u      *file = get_tv_string_buf_chk(&argvars[1], buf1);+  int flags = 0;  // Flags for globpath.   int error = FALSE; -  /* When the optional second argument is non-zero, don't remove matches-  * for 'wildignore' and don't put matches for 'suffixes' at the end. */-  if (argvars[2].v_type != VAR_UNKNOWN-      && get_tv_number_chk(&argvars[2], &error))-    flags |= WILD_KEEP_ALL;+  // Return a string, or a list of the optional third argument is non-zero.",Typo of -> ifWhy not use a similar comment above the the test for the third argument and remove this one?,
65244,dbarnett,https://api.github.com/repos/neovim/neovim/pulls/1050,16021640,2014-08-08T23:25:03Z,test/functional/legacy/test2-filename-recognition.vroom,"@@ -0,0 +1,34 @@+Test if URLs are recognized as filenames by commands such as ""gf"". Here+we'll use `expand(""<cfile>"")` since ""gf"" would need to open the file.++Insert some URLs:++  > ifirst test for URL://machine.name/tmp/vimtest2a and other text<esc>+  > osecond test for URL://machine.name/tmp/vimtest2b. And other text<esc>+  > othird test for URL:\\machine.name\vimtest2c and other text<esc>+  > ofourth test for URL:\\machine.name\tmp\vimtest2d, and other text<esc>++Go to the first URL:+  :/^first<cr>/tmp++Append the url to the beginning of the buffer:+  :call append(0, expand(""<cfile>""))","A common pattern we use for something like this is:```  :echomsg expand(""<cfile>"")  ~ URL://machine.name/tmp/vimtest2a```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1049,16031085,2014-08-10T12:59:32Z,src/nvim/ex_getln.c,"@@ -1832,15 +1840,19 @@ getexmodeline (         /* redraw the line */         msg_col = startcol;         vcol = 0;-        for (p = (char_u *)line_ga.ga_data;-             p < (char_u *)line_ga.ga_data + line_ga.ga_len; ++p) {+        p = (char_u *)line_ga.ga_data;+        p[line_ga.ga_len] = NUL;","At this point I am not sure that we always have at least one free byte at the end of `line_ga.ga_data`:If the code after `add_indent:` was executed, we could end up with `line_ga.maxlen == line_ga.ga_len` (if we added `line_ga.maxlen - line_ga.ga_len` spaces). So `p[line_ga.ga_len] = NUL` would be a buffer overrun.",
144418,atwupack,https://api.github.com/repos/neovim/neovim/pulls/1049,16075680,2014-08-11T19:48:46Z,src/nvim/ex_getln.c,"@@ -1832,15 +1840,19 @@ getexmodeline (         /* redraw the line */         msg_col = startcol;         vcol = 0;-        for (p = (char_u *)line_ga.ga_data;-             p < (char_u *)line_ga.ga_data + line_ga.ga_len; ++p) {+        p = (char_u *)line_ga.ga_data;+        p[line_ga.ga_len] = NUL;","@oni-link Good point. I think it is quite safe because of the `ga_grow(&line_ga, 40);` in each iteration. But still there should be a better way to handle setting values after the end of the array. Wouldn't it be an idea to replace all places with```p = (char_u *)line_ga.ga_data;p[line_ga.ga_len] = NUL;```or similar constructs with```GA_APPEND(char_u, line_ga, NUL)p = (char_u *)line_ga.ga_data;```What do you think?Edit. Bad idea. Of course this will increase `ga_len` each time. So maybe just put `ga_grow(&line_ga,1);` before line 1843?",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/950,16323293,2014-08-16T05:58:56Z,src/nvim/undo.c,"@@ -1119,10 +1119,7 @@ void u_write_undo(char_u *name, int forceit, buf_T *buf, char_u *hash)   if (os_get_file_info((char *)buf->b_ffname, &file_info_old)       && os_get_file_info((char *)file_name, &file_info_new)       && file_info_old.stat.st_gid != file_info_new.stat.st_gid-# ifdef HAVE_FCHOWN  /* sequent-ptx lacks fchown() */-      && fchown(fd, (uid_t)-1, file_info_old.stat.st_gid) != 0-# endif-      ) {+      && os_fchown(fd, (uid_t)-1, file_info_old.stat.st_gid) != 0) {",Good catch! It seems at least strange that argument is of type `uv_uid_t` but we cast parameter to `uid_t`. I removed this cast and another one.,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1075,16332020,2014-08-17T20:50:31Z,src/nvim/ops.c,"@@ -3518,14 +3517,14 @@ int do_join(long count,    * column.  This is not Vi compatible, but Vi deletes the marks, thus that    * should not really be a problem.    */-  for (t = count - 1;; --t) {+  for (size_t t = count - 1; t > 0; --t) {",I think you changed the semantics here. Original code had no predicate and manually `break`'s after a few state-changing operations.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1062,16336009,2014-08-18T03:28:04Z,src/nvim/testdir/Makefile,"@@ -5,6 +5,7 @@ export SHELL := sh  VIMPROG := ../../../build/bin/nvim+SCRIPTSOURCE = ../../../runtime","Although it doesn't technically matter, for consistency this should probably use `:=` like the other assignments above. I think `:=` is also less surprising so it's good practice to use it unless `=` behavior is explicitly needed.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1075,16338406,2014-08-18T06:09:14Z,src/nvim/ops.c,"@@ -3518,14 +3517,14 @@ int do_join(long count,    * column.  This is not Vi compatible, but Vi deletes the marks, thus that    * should not really be a problem.    */-  for (t = count - 1;; --t) {+  for (size_t t = count - 1; t > 0; --t) {","On August 18, 2014 1:50:06 AM GMT+03:00, Nicolas Hillegeer notifications@github.com wrote:> > @@ -3518,14 +3517,14 @@ int do_join(long count,> >     \* column.  This is not Vi compatible, but Vi deletes the marks,> > thus that> >     \* should not really be a problem.> >     */> > -  for (t = count - 1;; --t) {> > -  for (size_t t = count - 1; t > 0; --t) {> > No idea why my comments aren't appearing the global conversation, but> to rephrase them:> - `t > 0` is always true, the type is unsigned (the compiler should>   have warned about this)? Unsigned types may have zero value. This is the same as (t != 0) or just 't'. I would suggest using the first variant, not just 't' or greater than comparison.> - `count - 1` with an unsigned type is inviting an underflow, even if>   it can be guaranteed that `count > 1`, we should still rewrite the loop>   to do without subtractions if possible (or with a signed type).> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1075/files#r16332367",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/691,16470313,2014-08-20T11:29:40Z,src/nvim/version.c,"@@ -224,13 +224,8 @@ static int included_patches[] = {   //374,   //373,   //372,-  //371,-  //370,-  //369,-  //368,-  //367,-  //366,-  //365,",I think you accidentally removed these patches.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1099,16551413,2014-08-21T16:50:17Z,src/nvim/path.c,"@@ -334,21 +334,17 @@ int vim_fnamencmp(char_u *x, char_u *y, size_t len) #endif } +#define STPCPY(d, s) (char_u *) xstpcpy((char *) d, (char *) s)+ /*  * Concatenate file names fname1 and fname2 into allocated memory.  * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.  */-char_u *concat_fnames(char_u *fname1, char_u *fname2, int sep)-  FUNC_ATTR_NONNULL_RET+char_u *concat_fnames(const char_u *fname1, const char_u *fname2, int sep)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_MALLOC {   char_u *dest = xmalloc(STRLEN(fname1) + STRLEN(fname2) + 3);--  STRCPY(dest, fname1);-  if (sep) {-    add_pathsep(dest);-  }-  STRCAT(dest, fname2);-+  STRCPY(add_pathsep(STPCPY(dest, fname1)), fname2);","Nothing like using the right function (strpcpy in this case). This should only be merged after the PR that removes the `int sep` parameter is merged, right?",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1099,16551450,2014-08-21T16:50:56Z,src/nvim/path.c,"@@ -334,21 +334,17 @@ int vim_fnamencmp(char_u *x, char_u *y, size_t len) #endif } +#define STPCPY(d, s) (char_u *) xstpcpy((char *) d, (char *) s)","Wouldn't be a better idea to move this macro to where the other similar macros (`STRLEN`, `STRCPY`...) are defined?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1099,16557667,2014-08-21T18:32:05Z,src/nvim/path.c,"@@ -334,32 +334,36 @@ int vim_fnamencmp(char_u *x, char_u *y, size_t len) #endif } +#define STPCPY(d, s) (char_u *) xstpcpy((char *) d, (char *) s)+ /*  * Concatenate file names fname1 and fname2 into allocated memory.  * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.  */-char_u *concat_fnames(char_u *fname1, char_u *fname2, int sep)-  FUNC_ATTR_NONNULL_RET+char_u *concat_fnames(const char_u *fname1, const char_u *fname2, int sep)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL {-  char_u *dest = xmalloc(STRLEN(fname1) + STRLEN(fname2) + 3);--  STRCPY(dest, fname1);-  if (sep) {-    add_pathsep(dest);-  }-  STRCAT(dest, fname2);--  return dest;+  char_u *dst = vim_strnsave(fname1, STRLEN(fname1) + STRLEN(fname2) + 3);",`vim_strnsave` has special semantics. It allocates an additional byte and fills the remaining buffer with `NUL`.Would it not be more efficient to keep the calls to `xmalloc` and `STRCPY`?,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1099,16558434,2014-08-21T18:43:06Z,src/nvim/path.c,"@@ -334,21 +334,17 @@ int vim_fnamencmp(char_u *x, char_u *y, size_t len) #endif } +#define STPCPY(d, s) (char_u *) xstpcpy((char *) d, (char *) s)",I just put it there as a quick (read: lazy) fix.,
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1048,16565065,2014-08-21T20:05:05Z,runtime/filetype.vim,"@@ -2686,6 +2686,9 @@ au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh') "" the ""conf"" type being used if there is a line starting with '#'. au BufNewFile,BufRead *.txt,*.text,README	setf text +"" Go+au BufNewFile,BufRead *.go setf go+",Can you move this block to in between [Gkrellmrc (line 793)](https://github.com/wingyplus/neovim/blob/go_syntax/runtime/filetype.vim#L793) and [GP scripts (line 795)](https://github.com/wingyplus/neovim/blob/go_syntax/runtime/filetype.vim#L795)? That way it'd be in alphabetical order.,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/1075,16584296,2014-08-22T06:28:35Z,src/nvim/misc1.c,"@@ -213,7 +213,7 @@ open_line (       old_cursor = curwin->w_cursor;       ptr = saved_line;       if (flags & OPENLINE_DO_COM)-        lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);+        lead_len = (int)get_leader_len(ptr, NULL, FALSE, TRUE);","`open_line` is too big and sophisticated, so I decided to not change `lead_len` type to `size_t` because it is involved in many subtractions. Perhaps it can be achived in the future by splitting `open_line` to many functions.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1106,16607690,2014-08-22T16:41:32Z,CMakeLists.txt,"@@ -171,7 +171,8 @@ if(BUSTED_PRG)     DEPENDS nvim-test unittest-headers) endif() -install(DIRECTORY runtime DESTINATION share/nvim/)+install(DIRECTORY runtime DESTINATION share/nvim)",Changed this because otherwise the slash would be duplicated:```-- Up-to-date: /usr/local/share/nvim//runtime/tools/shtags.1```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1107,16628605,2014-08-23T04:07:20Z,src/nvim/screen.c,"@@ -2942,15 +2944,21 @@ win_line (             shl_flag = TRUE;           } else             shl = &cur->hl;-          while (shl->rm.regprog != NULL) {+          if (cur != NULL)+            cur->pos.cur = 0;+          pos_inprogress = true;+          while (shl->rm.regprog != NULL+                                 || (cur != NULL && pos_inprogress)) {             if (shl->startcol != MAXCOL                 && v >= (long)shl->startcol                 && v < (long)shl->endcol) {               shl->attr_cur = shl->attr;-            } else if (v == (long)shl->endcol) {+            } else if (v >= (long)shl->endcol) {               shl->attr_cur = 0; -              next_search_hl(wp, shl, lnum, (colnr_T)v);+              next_search_hl(wp, shl, lnum, (colnr_T)v, cur);+              pos_inprogress = cur == NULL || cur->pos.cur == 0+                                               ? false : true; ",can just negate the condition,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1107,16628665,2014-08-23T04:21:29Z,src/nvim/screen.c,"@@ -2658,38 +2660,38 @@ win_line (     shl->startcol = MAXCOL;     shl->endcol = MAXCOL;     shl->attr_cur = 0;-    if (shl->rm.regprog != NULL) {",Adding this `if` condition around the new code makes the problem go away. ~~No idea if it breaks `matchaddpos`.~~ Yep it does.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1097,16684748,2014-08-25T22:22:18Z,src/nvim/path.c,"@@ -334,32 +334,36 @@ int vim_fnamencmp(char_u *x, char_u *y, size_t len) #endif } -/*- * Concatenate file names fname1 and fname2 into allocated memory.- * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.- */-char_u *concat_fnames(char_u *fname1, char_u *fname2, int sep)-  FUNC_ATTR_NONNULL_RET+/// Concatenate file names fname1 and fname2 into allocated memory.+/// @returns ""{fname1}/{fname2}""+char_u *concat_fnames(const char_u *fname1, const char_u *fname2)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC+  FUNC_ATTR_WARN_UNUSED_RESULT {   char_u *dest = xmalloc(STRLEN(fname1) + STRLEN(fname2) + 3);--  STRCPY(dest, fname1);-  if (sep) {-    add_pathsep(dest);+  char_u *end = (char_u *) STPCPY(dest, fname1);+  if (end - dest > 0) {+    end = add_pathsep(end-1);","In `add_pathsep` the function `after_pathsep` also checks whether the last character is part of an multi-byte character. So not calling `add_pathsep` with `dest` (or the beginning of the last multi-byte character) could render this test useless (can there be an multi-byte character that has a path separator as his last byte?). For example, for the last multi-byte character `xx xx xx '/'` `add_pathsep` would need to append an extra '/'.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1054,16800371,2014-08-27T19:57:59Z,src/nvim/os/fs.c,"@@ -403,17 +389,44 @@ void os_file_info_get_id(const FileInfo *file_info, FileID *file_id) /// @deprecated Use `FileID` instead, this function is only needed in memline.c /// @param file_info Pointer to the `FileInfo` /// @return the inode number-uint64_t os_file_info_get_inode(const FileInfo *file_info)+uint64_t os_fileinfo_inode(const FileInfo *file_info) {   return file_info->stat.st_ino; } +/// Get the size of a file from a `FileInfo`.+///+/// @return filesize in bytes.+off_t os_fileinfo_size(const FileInfo *file_info)","> st_size is uint64_t so that's another reason to favor size_t.Not really, it's a reason to favour `uint64_t`. `size_t` is 32-bits on 32-bits systems, yet files can and do grow larger than 4GB there.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1087,16851388,2014-08-28T16:34:06Z,runtime/filetype.vim,"@@ -1843,11 +1843,19 @@ au BufNewFile,BufRead catalog			setf catalog au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')  "" Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.-"" Gentoo ebuilds are actually bash scripts-au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH(""bash"")+"" Gentoo ebuilds and Arch Linux PKGBUILDs are actually bash scripts+au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild,PKGBUILD* call SetFileTypeSH(""bash"") au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH(""ksh"") au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1)) +"" Shell script (Arch Linux) or PHP file (Drupal)+au BufNewFile,BufRead *.install+	\ if getline(1) =~ '<?php' |+	\   setf php |+	\ else |+	\   call SetFileTypeSH(""bash"") |+	\ endif","Or better yet, an example: https://github.com/drupal/drupal/blob/7.x/modules/comment/comment.install""Justin M. Keyes"" notifications@github.com wrote:> In runtime/filetype.vim:> > > au BufNewFile,BufRead .kshrc_,_.ksh call SetFileTypeSH(""ksh"") > au BufNewFile,BufRead _/etc/profile,.profile_,_.sh,_.env call SetFileTypeSH(getline(1)) > > +"" Shell script (Arch Linux) or PHP file (Drupal) > +au BufNewFile,BufRead *.install > + \ if getline(1) =~ '<?php' | > +    \ setf php | > +    \ else | > +    \ call SetFileTypeSH(""bash"") | > +  \ endif > > Is *.install really a php/drupal file type or was that just copied from the other example? I couldn't find any information on this.> > ���> Reply to this email directly or view it on GitHub.���",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1107,17079257,2014-09-03T20:55:23Z,src/nvim/window.c,"@@ -5236,15 +5238,109 @@ int match_add(win_T *wp, char_u *grp, char_u *pat, int prio, int id)   }    /* Build new match. */-  m = xmalloc(sizeof(matchitem_T));+  m = xmallocz(sizeof(matchitem_T));","I was wrong about `xmallocz`--it doesn't initialize the memory to zero, just the last byte, and we don't seem to have an equivalent. As long as all the members get initialized, it shouldn't be an issue.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1107,17097052,2014-09-04T06:11:37Z,src/nvim/window.c,"@@ -5236,15 +5238,109 @@ int match_add(win_T *wp, char_u *grp, char_u *pat, int prio, int id)   }    /* Build new match. */-  m = xmalloc(sizeof(matchitem_T));+  m = xmallocz(sizeof(matchitem_T));","On September 4, 2014 12:55:28 AM GMT+03:00, Scott Prager notifications@github.com wrote:> > @@ -5236,15 +5238,109 @@ int match_add(win_T *wp, char_u *grp, char_u> > *pat, int prio, int id)> >    }> > > >    /\* Build new match. */> > -  m = xmalloc(sizeof(matchitem_T));> > -  m = xmallocz(sizeof(matchitem_T));> > I was wrong about `xmallocz`--it doesn't initialize the memory to zero> and we don't seem to have an equivalent. As long as all the members get> initialized, it shouldn't be an issue.> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1107/files#r17079257? If you want a zero-initialized memory there is xcalloc wrapper. I use it almost always in my VimL parser.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1144,17213998,2014-09-07T10:15:36Z,test/unit/garray_spec.lua,"@@ -156,23 +159,23 @@ end  -- enhanced constructors local garray_ctype = ffi.typeof('garray_T[1]')-function new_garray()+local new_garray = function()   local garr = garray_ctype()   return ffi.gc(garr, ga_clear) end -function new_string_garray()+local new_string_garray = function()   local garr = garray_ctype()-  ga_init(garr, ffi.sizeof(""char_u *""), 1)+  ga_init(garr, ffi.sizeof(""unsigned char *""), 1)","Looks like it should be similar, no? Afaik `char_u` is a typedef for `unsigned char`, moreover this is just taking the size of a pointer (4 or 8 bytes depending on platform).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1144,17214002,2014-09-07T10:16:59Z,test/unit/helpers.lua,"@@ -64,10 +64,15 @@ function cimport(...)     return libnvim   end -  -- preprocess the header-  local stream = Preprocess.preprocess_stream(unpack(paths))-  local body = stream:read(""*a"")-  stream:close()","I actually have the same hack in a personal branch, but never bothered to submit it because it ""vanished"" after some Lua-C preprocessor fixes long ago. Also I was ashamed that I couldn't find the actual issue behind this. Sometimes the body is nil indeed...",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1144,17214493,2014-09-07T12:39:11Z,test/unit/formatc.lua,"@@ -214,25 +214,25 @@ end  -- uncomment the following lines (and comment the return) for standalone -- operation (very handy for debugging)-local function standalone(...)-  Preprocess = require(""preprocess"")-  Preprocess.add_to_include_path('./../../src')-  Preprocess.add_to_include_path('./../../build/include')-  Preprocess.add_to_include_path('./../../.deps/usr/include')--  input = Preprocess.preprocess_stream(arg[1])-  local raw = input:read('*all')-  input:close()--  local formatted-  if #arg == 2 and arg[2] == 'no' then-      formatted = raw-  else-      formatted = formatc(raw)-  end--  print(formatted)-end+-- local function standalone(...)+--   Preprocess = require(""preprocess"")+--   Preprocess.add_to_include_path('./../../src')+--   Preprocess.add_to_include_path('./../../build/include')+--   Preprocess.add_to_include_path('./../../.deps/usr/include')++--   input = Preprocess.preprocess_stream(arg[1])+--   local raw = input:read('*all')+--   input:close()++--   local formatted+--   if #arg == 2 and arg[2] == 'no' then+--       formatted = raw+--   else+--       formatted = formatc(raw)+--   end++--   print(formatted)+-- end -- standalone(...)","> Prefer to leave it uncommented ?Yes, actually. Perhaps the comments weren't clear (I'm not a native English speaker)? If so you can rewrite them for sure.Reason is I don't like to leave large commented chunks of code in the master branch, it looks messy imho.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1144,17214716,2014-09-07T13:22:55Z,test/unit/formatc.lua,"@@ -214,25 +214,25 @@ end  -- uncomment the following lines (and comment the return) for standalone -- operation (very handy for debugging)-local function standalone(...)-  Preprocess = require(""preprocess"")-  Preprocess.add_to_include_path('./../../src')-  Preprocess.add_to_include_path('./../../build/include')-  Preprocess.add_to_include_path('./../../.deps/usr/include')--  input = Preprocess.preprocess_stream(arg[1])-  local raw = input:read('*all')-  input:close()--  local formatted-  if #arg == 2 and arg[2] == 'no' then-      formatted = raw-  else-      formatted = formatc(raw)-  end--  print(formatted)-end+-- local function standalone(...)+--   Preprocess = require(""preprocess"")+--   Preprocess.add_to_include_path('./../../src')+--   Preprocess.add_to_include_path('./../../build/include')+--   Preprocess.add_to_include_path('./../../.deps/usr/include')++--   input = Preprocess.preprocess_stream(arg[1])+--   local raw = input:read('*all')+--   input:close()++--   local formatted+--   if #arg == 2 and arg[2] == 'no' then+--       formatted = raw+--   else+--       formatted = formatc(raw)+--   end++--   print(formatted)+-- end -- standalone(...)",No problem with your English (I thought for sure you were a US expat based on your speech patterns),
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/1108,17402901,2014-09-11T03:41:32Z,src/nvim/api/tabpage.c,"@@ -90,18 +82,15 @@ Window tabpage_get_window(Tabpage tabpage, Error *err)   Window rv = 0;   tabpage_T *tab = find_tab_by_handle(tabpage, err); -  if (!tab) {+  if (!tab || !valid_tabpage(tab)) {",Not sure. I put this check in because previously we were doing `FOR_ALL_TAB_WINDOWS` and looking to find the tab and the window both. `valid_tabpage` does the first check and ensures that the tab is in the tabs list. Then we can use `FOR_ALL_WINDOWS_IN_TAB` with the same behavior as the old code.I am not entirely sure why we couldn't just return `tab->tp_curwin->handle` but I assume there is a reason for that...,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1108,17403074,2014-09-11T03:50:27Z,src/nvim/globals.h,"@@ -548,6 +551,9 @@ EXTERN tabpage_T    *first_tabpage; EXTERN tabpage_T    *curtab; EXTERN int redraw_tabline INIT(= FALSE);           /* need to redraw tabline */ +// Iterates over all tabs in the tab list",I mean something like``` c/// Iterates over all tabs in the tab list./// @param tp The identifier to use as the iterator.```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1144,17406543,2014-09-11T06:58:58Z,test/unit/buffer_spec.lua,"@@ -9,11 +9,6 @@ local buffer = helpers.cimport(""./src/nvim/buffer.h"") local window = helpers.cimport(""./src/nvim/window.h"") local option = helpers.cimport(""./src/nvim/option.h"") ---{ Initialize the options needed for interacting with buffers-window.win_alloc_first()",@aktau This was the call that was accidentally allowing the tempfile_spec tests to proceed. I moved all init calls to `helper.vim_init`.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1144,17408151,2014-09-11T07:52:54Z,test/unit/buffer_spec.lua,"@@ -9,11 +9,6 @@ local buffer = helpers.cimport(""./src/nvim/buffer.h"") local window = helpers.cimport(""./src/nvim/window.h"") local option = helpers.cimport(""./src/nvim/option.h"") ---{ Initialize the options needed for interacting with buffers-window.win_alloc_first()","> Yep!Awesome, hopefully we can soon have a nicely running `make unittest` then, that would make me quite happy. Thanks for taking the time for looking at my byzantine C preprocessing/formatting code, I know it's a bit messy ;).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1130,17415318,2014-09-11T11:12:59Z,src/nvim/api/window.c,"@@ -51,31 +51,40 @@ Position window_get_cursor(Window window, Error *err) /// @param window The window handle /// @param pos the (row, col) tuple representing the new position /// @param[out] err Details of an error that may have occurred-void window_set_cursor(Window window, Position pos, Error *err)+void window_set_cursor(Window window, Array pos, Error *err) {   win_T *win = find_window_by_handle(window, err); +  if (pos.size != 2 || pos.items[0].type != kObjectTypeInteger ||+      pos.items[1].type != kObjectTypeInteger) {+    set_api_error(""\""pos\"" argument must be a [row, col] array"", err);+    return;+  }+   if (!win) {     return;   } -  if (pos.row <= 0 || pos.row > win->w_buffer->b_ml.ml_line_count) {+  int64_t row = pos.items[0].data.integer;+  int64_t col = pos.items[1].data.integer;++  if (row <= 0 || row > win->w_buffer->b_ml.ml_line_count) {     set_api_error(""cursor position outside buffer"", err);     return;   } -  if (pos.row > LONG_MAX || pos.row < LONG_MIN) {+  if (row > LONG_MAX || row < LONG_MIN) {",This two conditions can never be true at this point.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1130,17418112,2014-09-11T12:40:21Z,scripts/msgpack-gen.lua,"@@ -38,9 +38,28 @@ assert(#arg >= 1) -- api metadata api = {   functions = {},-  -- Helpers for object-oriented languages-  classes = {'Buffer', 'Window', 'Tabpage'}+  types = {} }++-- Extract type codes from api/private/defs.h. The codes are values between+-- comment markers in the ObjectType enum+local typedefs_header = arg[1]+local input = io.open(typedefs_header, 'rb')+local reading_types = false+while true do+  local line = input:read('*l'):gsub(""^%s*(.-)%s*$"", ""%1"")+  if reading_types then+    if line == '// end custom types' then+      break+    end+    local type_name = line:gsub(""^kObjectType(.-),$"", ""%1"")+    api.types[#api.types + 1] = type_name",I'm actually considering removing this part from the metadata generator and simply hardcode the metadata in C(like the `vim_discover_features function`). Types are not something that change so much that require automatic updates,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1163,17518133,2014-09-14T08:58:16Z,runtime/doc/msgpack_rpc.txt,"@@ -0,0 +1,245 @@+*msgpack_rpc.txt*    For Nvim.						 {Nvim}+++		 NVIM REFERENCE MANUAL    by Thiago de Arruda+++The Msgpack-RPC Interface to Nvim		  *msgpack-rpc*++1. Introduction			|msgpack-rpc-intro|+2. API			  	|msgpack-rpc-api|+3. Connecting			|msgpack-rpc-connecting|+4. Clients			|msgpack-rpc-clients|+5. Types			|msgpack-rpc-types|+6. Wrapping methods		|msgpack-rpc-wrap-methods|+7. Vimscript functions		|msgpack-rpc-vim-functions|++==============================================================================+1. Introduction						    *msgpack-rpc-intro*++The primary means of controlling a running nvim instance is through+MessagePack-RPC, a messaging protocol that uses the MessagePack serialization+format: https://github.com/msgpack/msgpack/blob/7498cf3/spec.md.+From now on, we'll be referring to the protocol as msgpack-rpc.++At this point, only plugins use msgpack-rpc, but eventually even user+interaction will be achieved through the protocol, since user interfaces will+be separate programs that control a headless nvim instance.++This is what can be achieved by connecting to the msgpack-rpc interface:++- Call any nvim API function+- Listen for nvim events+- Receive remote calls from nvim++Nvim's msgpack-rpc interface can be seen as a more powerful version of Vim's+`clientserver` feature.++==============================================================================+2. API							      *msgpack-rpc-api*++Nvim C API is automatically exposed to the msgpack-rpc interface by the+build system, which parses headers at src/nvim/api from the project root. A+dispatch function is generated, and it will match msgpack-rpc method names+with non-static API functions, converting/validating arguments and return+values back to msgpack.++Client libraries will normally provide wrappers that hide msgpack-rpc details+from programmers, which can be automatically generated by reading bundled api+metadata from a compiled nvim instance.++There are two ways to obtain API metadata:++- By connecting to a running nvim instance and calling `vim_get_api_metadata`",There is no help yet for `vim_get_api_metadata`.,
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/1011,17519222,2014-09-14T12:36:10Z,runtime/doc/Makefile,"@@ -280,32 +274,45 @@ HTMLS = \ 	windows.html \ 	workshop.html -CONVERTED = \-	vim-fr.UTF-8.1 \-	evim-fr.UTF-8.1 \-	vimdiff-fr.UTF-8.1 \-	vimtutor-fr.UTF-8.1 \-	xxd-fr.UTF-8.1 \-	vim-it.UTF-8.1 \-	evim-it.UTF-8.1 \-	vimdiff-it.UTF-8.1 \-	vimtutor-it.UTF-8.1 \-	xxd-it.UTF-8.1 \-	vim-pl.UTF-8.1 \-	evim-pl.UTF-8.1 \-	vimdiff-pl.UTF-8.1 \-	vimtutor-pl.UTF-8.1 \-	xxd-pl.UTF-8.1 \-	vim-ru.UTF-8.1 \-	evim-ru.UTF-8.1 \-	vimdiff-ru.UTF-8.1 \-	vimtutor-ru.UTF-8.1 \-	xxd-ru.UTF-8.1+MANPAGES = \+	manpages/vim.man \+	manpages/evim.man \+	manpages/vimdiff.man \+	manpages/vimtutor.man \+	manpages/xxd.man \++# TODO (stefan991): fix output encoding of nroff","Seems that OS X man doesn't support the -l and -T option:```stefan at air in ~/Dev/neovim/runtime/doc on git:cleanup-docs+% make manpagesman -l -Tutf8 manpages/vim.1 | sed -e s/.//g > manpages/vim.manman: invalid option -- lman, version 1.6cusage: man [-adfhktwW] [section] [-M path] [-P pager] [-S list]    [-m system] [-p string] name ...  a : find all matching entries  c : do not use cat file  d : print gobs of debugging information  D : as for -d, but also display the pages  f : same as whatis(1)  h : print this help message  k : same as apropos(1)  K : search for a string in all pages  t : use troff to format pages for printing  w : print location of man page(s) that would be displayed      (if no name given: print directories that would be searched)  W : as for -w, but display filenames only  C file   : use `file' as configuration file  M path   : set search path for manual pages to `path'  P pager  : use program `pager' to display pages  S list   : colon separated section list  m system : search for alternate system's man pages  p string : string tells which preprocessors to run               e - [n]eqn(1)   p - pic(1)    t - tbl(1)               g - grap(1)     r - refer(1)  v - vgrind(1)man -l -Tutf8 manpages/evim.1 | sed -e s/.//g > manpages/evim.manman: invalid option -- lman, version 1.6c...```If I start man without options, the encoding is still wrong.Using this I get files with empty lines:```.1.man:  man $< | sed -e s/.//g > $@```",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1163,17520091,2014-09-14T15:10:23Z,runtime/doc/msgpack_rpc.txt,"@@ -0,0 +1,245 @@+*msgpack_rpc.txt*    For Nvim.						 {Nvim}+++		 NVIM REFERENCE MANUAL    by Thiago de Arruda+++The Msgpack-RPC Interface to Nvim		  *msgpack-rpc*++1. Introduction			|msgpack-rpc-intro|+2. API			  	|msgpack-rpc-api|+3. Connecting			|msgpack-rpc-connecting|+4. Clients			|msgpack-rpc-clients|+5. Types			|msgpack-rpc-types|+6. Wrapping methods		|msgpack-rpc-wrap-methods|+7. Vimscript functions		|msgpack-rpc-vim-functions|++==============================================================================+1. Introduction						    *msgpack-rpc-intro*++The primary means of controlling a running nvim instance is through+MessagePack-RPC, a messaging protocol that uses the MessagePack serialization+format: https://github.com/msgpack/msgpack/blob/7498cf3/spec.md.+From now on, we'll be referring to the protocol as msgpack-rpc.++At this point, only plugins use msgpack-rpc, but eventually even user+interaction will be achieved through the protocol, since user interfaces will+be separate programs that control a headless nvim instance.","Hm.. actually, why Nvim and not Neovim? To distinguish between Neovim (the project) and Nvim (the editor, as opposed to other components of the project, such as the Neovim Python client)? Should this repo be called `neovim/nvim`, then?",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1011,17520123,2014-09-14T15:14:41Z,runtime/doc/Makefile,"@@ -280,32 +274,45 @@ HTMLS = \ 	windows.html \ 	workshop.html -CONVERTED = \-	vim-fr.UTF-8.1 \-	evim-fr.UTF-8.1 \-	vimdiff-fr.UTF-8.1 \-	vimtutor-fr.UTF-8.1 \-	xxd-fr.UTF-8.1 \-	vim-it.UTF-8.1 \-	evim-it.UTF-8.1 \-	vimdiff-it.UTF-8.1 \-	vimtutor-it.UTF-8.1 \-	xxd-it.UTF-8.1 \-	vim-pl.UTF-8.1 \-	evim-pl.UTF-8.1 \-	vimdiff-pl.UTF-8.1 \-	vimtutor-pl.UTF-8.1 \-	xxd-pl.UTF-8.1 \-	vim-ru.UTF-8.1 \-	evim-ru.UTF-8.1 \-	vimdiff-ru.UTF-8.1 \-	vimtutor-ru.UTF-8.1 \-	xxd-ru.UTF-8.1+MANPAGES = \+	manpages/vim.man \+	manpages/evim.man \+	manpages/vimdiff.man \+	manpages/vimtutor.man \+	manpages/xxd.man \++# TODO (stefan991): fix output encoding of nroff","Is there a way to install a newer version, e.g. via Homebrew?Do you know how OS X handles manpages? As I wrote below, from what I saw only the .1 files are installed by packages on Arch Linux, so this step should not even be necessary (Manpages are formatted for viewing on demand, I think). I guess other Linux distros are similar, so maybe OS X is the only system where compiling manpages is actually necessary?",
393493,stefan991,https://api.github.com/repos/neovim/neovim/pulls/1011,17520239,2014-09-14T15:32:14Z,runtime/doc/Makefile,"@@ -280,32 +274,45 @@ HTMLS = \ 	windows.html \ 	workshop.html -CONVERTED = \-	vim-fr.UTF-8.1 \-	evim-fr.UTF-8.1 \-	vimdiff-fr.UTF-8.1 \-	vimtutor-fr.UTF-8.1 \-	xxd-fr.UTF-8.1 \-	vim-it.UTF-8.1 \-	evim-it.UTF-8.1 \-	vimdiff-it.UTF-8.1 \-	vimtutor-it.UTF-8.1 \-	xxd-it.UTF-8.1 \-	vim-pl.UTF-8.1 \-	evim-pl.UTF-8.1 \-	vimdiff-pl.UTF-8.1 \-	vimtutor-pl.UTF-8.1 \-	xxd-pl.UTF-8.1 \-	vim-ru.UTF-8.1 \-	evim-ru.UTF-8.1 \-	vimdiff-ru.UTF-8.1 \-	vimtutor-ru.UTF-8.1 \-	xxd-ru.UTF-8.1+MANPAGES = \+	manpages/vim.man \+	manpages/evim.man \+	manpages/vimdiff.man \+	manpages/vimtutor.man \+	manpages/xxd.man \++# TODO (stefan991): fix output encoding of nroff","Only `.1`files are installed. Most of the system default are ascii and some latin-1, and the few which are utf-8 get rendered incorrectly:https://developer.apple.com/library/prerelease/mac/documentation/Darwin/Reference/ManPages/man1/mmroff.1.html (see Author section)It seems that utf-8 manages are not supported in OS X.**EDIT**: There is https://github.com/Homebrew/homebrew-dupes/blob/master/groff.rb in homebrew.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1163,17536281,2014-09-15T11:20:23Z,runtime/doc/eval.txt,"@@ -5043,6 +5069,32 @@ round({expr})							*round()* <			-5.0 		{only available when compiled with the |+float| feature} +rpcnotify({channel}, {event}[, {args}...])		  {Nvim} *rpcnotify()*+		Sends {event} to {channel} via |msgpack-rpc| and returns+		immediately. If {channel} is 0, the event is broadcast to all+		channels. Example: >+			:au VimLeave call rpcnotify(0, ""leaving"")++rpcrequest({channel}, {method}[, {args}...])		 {Nvim} *rpcrequest()*","`jobsend` is non-blocking, so it is somewhat equivalent to `rpcnotify`, except that `rpcnotify` can be sent to all connected channels.Though I'd rather leave the similarities contained in the `start`/`stop` functions because `notification` and `request` are part of msgpack-rpc, so it will be more intuitive to those that read the specification.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1186,17709952,2014-09-18T05:45:54Z,src/nvim/term.c,"@@ -1006,6 +1006,26 @@ static struct builtin_term builtin_termcaps[] = # define DEFAULT_TERM   (char_u *)""dumb"" #endif +/// Sets up the terminal window for use.+///+/// Thus must be done after resetting full_screen, otherwise it may move the+/// cursor.+///+/// @remark We may call mch_exit() before calling this.+void term_init(void)+{+  Columns = 80;+  Rows = 24;++  setbuf(stdout, NULL);  // Prevent buffering output.","The issue here is that when I didn't add the `fflush()` line (not needed with `setbuf(stdout, NULL)`), I didn't see anything on screen, which means we can't let the data from `term_write()` sit in the buffer. So we either need to immediately flush after every write, or disable buffering.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1192,17766462,2014-09-19T02:15:37Z,src/nvim/getchar.c,"@@ -2209,6 +2209,12 @@ static int vgetorpeek(int advance)         }         if (c < 0)           continue;             /* end of input script reached */++        /* Allow mapping for just typed characters. When we get here c",Current policy: refactor as we go. Sometimes I'll even do a follow-up commit to refactor a whole function if something offends me badly enough.,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/1190,17820829,2014-09-20T18:07:56Z,runtime/plugin/python_setup.vim,"@@ -4,43 +4,43 @@ if exists(""did_python_setup"") || &cp endif let did_python_setup = 1 --let s:get_version =-      \ ' -c ""import sys; sys.stdout.write(str(sys.version_info[0]) + '.-      \ '\"".\"" + str(sys.version_info[1]))""'--let s:supported = ['2.6', '2.7']- "" To load the python host a python 2 executable must be available if exists('python_interpreter')       \ && executable(g:python_interpreter)-      \ && index(s:supported, system(g:python_interpreter.s:get_version)) >= 0-  let s:python_interpreter = g:python_interpreter-elseif executable('python')-      \ && index(s:supported, system('python'.s:get_version)) >= 0-  let s:python_interpreter = 'python'+    let s:test_interpreter = g:python_interpreter   elseif executable('python2')-      \ && index(s:supported, system('python2'.s:get_version)) >= 0-  "" In some distros, python3 is the default python-  let s:python_interpreter = 'python2'+    "" In some distros, python points to python3, so we prefer python2 if available+    let s:test_interpreter = 'python2'+elseif executable('python')+    "" If python2 is not available, python could be either python2 or python3.+    "" We check if the interpreter version is supported later+    let s:test_interpreter = 'python' else+  echoerr expand('<sfile>')."": no python interpreter available.""   finish endif -"" Execute python, import neovim and print a string. If import_result matches-"" the printed string, we can probably start the host-let s:import_result = system(s:python_interpreter .-      \ ' -c ""import neovim, sys; sys.stdout.write(\""ok\"")""')-if s:import_result != 'ok'-  finish+"" Check if the interpreter version is supported+let s:python_version = matchstr(system(s:test_interpreter."" --version""), '2\.[67]')","My test was skewed because I wasn't piping the output, though. It is not that slow, but `python --version` is still faster.``` > ~ time python2 -c ""import sys; sys.stdout.write(str(sys.version_info[0]) + '.' +     str(sys.version_info[1]))"" >> speed-test 0.01user 0.00system 0:00.02elapsed 88%CPU (0avgtext+0avgdata 6100maxresident)k0inputs+8outputs (0major+763minor)pagefaults 0swaps > ~ time python2 -c ""import sys; sys.stdout.write(str(sys.version_info[0]) + '.' + str(sys.version_info[1]))""2.70.02user 0.00system 0:00.02elapsed 89%CPU (0avgtext+0avgdata     6144maxresident)k0inputs+0outputs (0major+766minor)pagefaults 0swaps```",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1212,17823251,2014-09-21T04:08:33Z,src/nvim/path.c,"@@ -531,84 +594,86 @@ unix_expandpath (     return 0;   } -  /* If ""**"" is by itself, this is the first time we encounter it and more-   * is following then find matches without any directory. */+  // If ""**"" is by itself, this is the first time we encounter it and more+  // is following then find matches without any directory.   if (!didstar && stardepth < 100 && starstar && e - s == 2       && *path_end == '/') {     STRCPY(s, path_end + 1);     ++stardepth;-    (void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);+    (void)do_path_expand(gap, buf, (int)(s - buf), flags, TRUE);     --stardepth;   } -  /* open the directory for scanning */   *s = NUL;-  dirp = opendir(*buf == NUL ? ""."" : (char *)buf); -  /* Find all matching entries */-  if (dirp != NULL) {-    for (;; ) {-      dp = readdir(dirp);-      if (dp == NULL)-        break;-      if ((dp->d_name[0] != '.' || starts_with_dot)-          && ((regmatch.regprog != NULL && vim_regexec(&regmatch,-                   (char_u *)dp->d_name, (colnr_T)0))-              || ((flags & EW_NOTWILD)-                  && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0))) {-        STRCPY(s, dp->d_name);-        len = STRLEN(buf);--        if (starstar && stardepth < 100) {-          /* For ""**"" in the pattern first go deeper in the tree to-           * find matches. */-          STRCPY(buf + len, ""/**"");-          STRCPY(buf + len + 3, path_end);-          ++stardepth;-          (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);-          --stardepth;-        }+  // open the directory for scanning+  Directory dir;+  if (!os_opendir(&dir, *buf == NUL ? ""."" : (char *)buf)) {","In vanilla vim's `dos_expandpath()`, it uses `""*.*""` as the search pattern, but libuv just uses `""*""`, so if we need to restore that behaviour, it'll have to go in the loop below. (https://github.com/joyent/libuv/blob/v0.11.28/src/win/fs.c#L807-L813)",
144418,atwupack,https://api.github.com/repos/neovim/neovim/pulls/1207,17824119,2014-09-21T08:56:26Z,src/nvim/edit.c,"@@ -5610,12 +5610,18 @@ static void spell_back_to_badword(void) int stop_arrow(void) {   if (arrow_used) {+    Insstart = curwin->w_cursor;  //new insertion starts here+    if (Insstart.col > Insstart_orig.col && !ins_need_undo) {+      // Don't update the original insert position when moved to the+      // right, except when nothing was inserted yet.+      update_Insstart_orig = FALSE;+    }+    Insstart_textlen = (colnr_T)linetabsize(get_cursor_line_ptr());","@splinterofchaos `linetabsize` returns an `int` which is cast to the type of `Insstart_textlen`. Although `colnr_T` is defined as `int`, I like the explicit cast here.Otherwise line https://github.com/neovim/neovim/blob/fe446c86cf752961fab84f92aa4956aaa4dc3f6f/src/nvim/edit.c#L339 should be changed too.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1212,17825098,2014-09-21T13:00:03Z,src/nvim/path.c,"@@ -414,116 +440,153 @@ static int pstrcmp(const void *a, const void *b) {   return pathcmp(*(char **)a, *(char **)b, -1); }+#endif -/*- * Recursively expand one path component into all matching files and/or- * directories.  Adds matches to ""gap"".  Handles ""*"", ""?"", ""[a-z]"", ""**"", etc.- * ""path"" has backslashes before chars that are not to be expanded, starting- * at ""path + wildoff"".- * Return the number of matches found.- * NOTE: much of this is identical to dos_expandpath(), keep in sync!- */-int -unix_expandpath (-    garray_T *gap,-    char_u *path,-    int wildoff,-    int flags,                      /* EW_* flags */-    int didstar                    /* expanded ""**"" once already */-)+#if !defined(NO_EXPANDPATH) || defined(PROTO)","PROTO is meaningless to us, but we still have a bunch of `defined(PROTO)` conditions floating around (we should remove them).",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1212,17825129,2014-09-21T13:07:33Z,src/nvim/path.c,"@@ -414,116 +440,153 @@ static int pstrcmp(const void *a, const void *b) {   return pathcmp(*(char **)a, *(char **)b, -1); }+#endif -/*- * Recursively expand one path component into all matching files and/or- * directories.  Adds matches to ""gap"".  Handles ""*"", ""?"", ""[a-z]"", ""**"", etc.- * ""path"" has backslashes before chars that are not to be expanded, starting- * at ""path + wildoff"".- * Return the number of matches found.- * NOTE: much of this is identical to dos_expandpath(), keep in sync!- */-int -unix_expandpath (-    garray_T *gap,-    char_u *path,-    int wildoff,-    int flags,                      /* EW_* flags */-    int didstar                    /* expanded ""**"" once already */-)+#if !defined(NO_EXPANDPATH) || defined(PROTO)","> PROTO is meaningless to us, but we still have a bunch of defined(PROTO) conditions floating around (we should remove them).:+1: ",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1141,17901072,2014-09-23T10:35:45Z,src/nvim/eval.c,"@@ -15031,6 +15073,81 @@ static void f_winsaveview(typval_T *argvars, typval_T *rettv)   dict_add_nr_str(dict, ""skipcol"", (long)curwin->w_skipcol, NULL); } +/// Writes list of strings to file+static bool write_list(FILE *fd, list_T *list, bool binary)+{+  int ret = true;++  for (listitem_T *li = list->lv_first; li != NULL; li = li->li_next) {+    for (char_u *s = get_tv_string(&li->li_tv); *s != NUL; ++s) {+      if (putc(*s == '\n' ? NUL : *s, fd) == EOF) {+        ret = false;+        break;+      }+    }+    if (!binary || li->li_next != NULL) {+      if (putc('\n', fd) == EOF) {+        ret = false;+        break;+      }+    }+    if (ret == false) {+      EMSG(_(e_write));+      break;+    }+  }+  return ret;+}++/// Saves a typval_T as a string.+///+/// For lists, replaces NLs with NUL and separates items with NLs.+///+/// @param[in]  tv   A value to store as a string.+/// @param[out] len  The length of the resulting string or -1 on error.+/// @returns an allocated string if `tv` represents a VimL string, list, or+///          number; NULL otherwise.+static char_u *save_tv_as_string(typval_T *tv, size_t *len)+  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL+{+  if (tv->v_type == VAR_UNKNOWN) {+    *len = 0;+    return NULL;+  }++  // For types other than list, let get_tv_string_buf_chk() get the value or+  // print an error.+  if (tv->v_type != VAR_LIST) {+    char_u *ret = get_tv_string_chk(tv);+    if (ret) {+      ret = vim_strsave(ret);+    }+    *len = ret ? STRLEN(ret) : (size_t)-1;+    return ret;+  }++  // Pre-calculate the resulting length.+  *len = 0;+  list_T *list = tv->vval.v_list;+  for (listitem_T *li = list->lv_first; li != NULL; li = li->li_next) {+    *len += STRLEN(get_tv_string(&li->li_tv)) + 1;+  }++  char_u *ret = xmallocz(*len);",Is the extra allocated byte only there in case the list is empty (otherwise unused)? Why not return `NULL` in this case?,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/1227,17937792,2014-09-23T20:42:43Z,src/nvim/buffer.c,"@@ -1755,7 +1755,7 @@ buflist_findpat (         FOR_ALL_BUFFERS(buf) {           if (buf->b_p_bl == find_listed               && (!diffmode || diff_mode_buf(buf))-              && buflist_match(prog, buf) != NULL) {+              && buflist_match(prog, buf, FALSE) != NULL) {","I used `FALSE`, because `buflist_match()` is also called with `EXTERN long p_wic` in other places. Of course, I could change that one to `bool`, too.I wasn't sure if such ""refactorings"" should be done in the patch backports. I'll just add a second commit for it.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1241,18044190,2014-09-25T16:53:10Z,src/nvim/quickfix.c,"@@ -2476,23 +2505,8 @@ void ex_make(exarg_T *eap)     wp = curwin;    autowrite_all();-  fname = get_mef_name();-  if (fname == NULL)-    return;-  os_remove((char *)fname);  // in case it's not unique    /*-   * If 'shellpipe' empty: don't redirect to 'errorfile'.-   */-  len = (unsigned)STRLEN(p_shq) * 2 + (unsigned)STRLEN(eap->arg) + 1;-  if (*p_sp != NUL)-    len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;-  cmd = xmalloc(len);-  sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,-      (char *)p_shq);-  if (*p_sp != NUL)-    append_redir(cmd, len, p_sp, fname);","The fastest output I ever got was by, instead of removing these, using `NULL` for the callbacks and running `mkfifo()` here, but that certainly isn't OS-independent.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/1256,18130297,2014-09-28T15:32:25Z,src/nvim/option.c,"@@ -4737,64 +4733,110 @@ static char_u *set_chars_option(char_u **varp)   };   struct charstab *tab; +  int entries;   if (varp == &p_lcs) {     tab = lcstab;-    entries = sizeof(lcstab) / sizeof(struct charstab);+    entries = sizeof(lcstab) / sizeof(*tab);   } else {     tab = filltab;-    entries = sizeof(filltab) / sizeof(struct charstab);-  }--  /* first round: check for valid value, second round: assign values */-  for (round = 0; round <= 1; ++round) {-    if (round > 0) {-      /* After checking that the value is valid: set defaults: space for-       * 'fillchars', NUL for 'listchars' */-      for (i = 0; i < entries; ++i)-        if (tab[i].cp != NULL)-          *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');-      if (varp == &p_lcs)-        lcs_tab1 = NUL;-      else-        fill_diff = '-';-    }-    p = *varp;-    while (*p) {-      for (i = 0; i < entries; ++i) {-        len = (int)STRLEN(tab[i].name);-        if (STRNCMP(p, tab[i].name, len) == 0-            && p[len] == ':'-            && p[len + 1] != NUL) {-          s = p + len + 1;-          c1 = mb_ptr2char_adv(&s);-          if (mb_char2cells(c1) > 1)+    entries = sizeof(filltab) / sizeof(*tab);+  }++  // Check for valid value.+  char_u *p = *varp;+  while (*p) {+    int i = 0;+    for (; i < entries; ++i) {+      int len = (int)STRLEN(tab[i].name);+      char_u *s;+      if (STRNCMP(p, tab[i].name, len) == 0+          && p[len] == ':'+          && p[len + 1] != NUL) {+        s = p + len + 1;+        int c1 = mb_ptr2char_adv(&s);+        if (mb_char2cells(c1) > 1) {+          continue;+        }+        if (tab[i].cp == &lcs_tab2) {+          if (*s == NUL) {+            continue;+          }+          int c2 = mb_ptr2char_adv(&s);+          if (mb_char2cells(c2) > 1) {             continue;-          if (tab[i].cp == &lcs_tab2) {-            if (*s == NUL)-              continue;-            c2 = mb_ptr2char_adv(&s);-            if (mb_char2cells(c2) > 1)-              continue;           }-          if (*s == ',' || *s == NUL) {-            if (round) {-              if (tab[i].cp == &lcs_tab2) {-                lcs_tab1 = c1;-                lcs_tab2 = c2;-              } else if (tab[i].cp != NULL)-                *(tab[i].cp) = c1;+        }+        if (*s == ',' || *s == NUL) {+          p = s;+          break;+        }+      }+    } -            }-            p = s;-            break;+    if (i == entries) {+      return e_invarg;+    }+    if (*p == ',') {+      ++p;+    }+  }++  // Assign values.++  // After checking that the value is valid: set defaults: space for+  // 'fillchars', NUL for 'listchars'.+  for (int i = 0; i < entries; ++i) {+    if (tab[i].cp != NULL) {+      *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');+    }+  }+  if (varp == &p_lcs) {+    lcs_tab1 = NUL;+  } else {+    fill_diff = '-';+  }+  p = *varp;+  while (*p) {+    int i = 0;+    for (; i < entries; ++i) {+      int len = (int)STRLEN(tab[i].name);+      char_u *s;+      if (STRNCMP(p, tab[i].name, len) == 0+          && p[len] == ':'+          && p[len + 1] != NUL) {+        s = p + len + 1;+        int c1 = mb_ptr2char_adv(&s);+        if (mb_char2cells(c1) > 1) {+          continue;+        }+        int c2 = 0;+        if (tab[i].cp == &lcs_tab2) {+          if (*s == NUL) {+            continue;+          }+          c2 = mb_ptr2char_adv(&s);+          if (mb_char2cells(c2) > 1) {+            continue;           }         }+        if (*s == ',' || *s == NUL) {+          if (tab[i].cp == &lcs_tab2) {+            lcs_tab1 = c1;+            lcs_tab2 = c2;+          } else if (tab[i].cp != NULL) {+            *(tab[i].cp) = c1;+          }+          p = s;+          break;+        }       }+    } -      if (i == entries)-        return e_invarg;-      if (*p == ',')-        ++p;+    if (i == entries) {+      return e_invarg;","Is it possible for this to happen? I may be missing something, but seems like if this condition were to hit, the one from the previous section would also have happened and we would have returned already.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1256,18131213,2014-09-28T18:14:49Z,src/nvim/option.c,"@@ -4737,64 +4733,110 @@ static char_u *set_chars_option(char_u **varp)   };   struct charstab *tab; +  int entries;   if (varp == &p_lcs) {     tab = lcstab;-    entries = sizeof(lcstab) / sizeof(struct charstab);+    entries = sizeof(lcstab) / sizeof(*tab);   } else {     tab = filltab;-    entries = sizeof(filltab) / sizeof(struct charstab);-  }--  /* first round: check for valid value, second round: assign values */-  for (round = 0; round <= 1; ++round) {-    if (round > 0) {-      /* After checking that the value is valid: set defaults: space for-       * 'fillchars', NUL for 'listchars' */-      for (i = 0; i < entries; ++i)-        if (tab[i].cp != NULL)-          *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');-      if (varp == &p_lcs)-        lcs_tab1 = NUL;-      else-        fill_diff = '-';-    }-    p = *varp;-    while (*p) {-      for (i = 0; i < entries; ++i) {-        len = (int)STRLEN(tab[i].name);-        if (STRNCMP(p, tab[i].name, len) == 0-            && p[len] == ':'-            && p[len + 1] != NUL) {-          s = p + len + 1;-          c1 = mb_ptr2char_adv(&s);-          if (mb_char2cells(c1) > 1)+    entries = sizeof(filltab) / sizeof(*tab);+  }++  // Check for valid value.+  char_u *p = *varp;+  while (*p) {+    int i = 0;+    for (; i < entries; ++i) {+      int len = (int)STRLEN(tab[i].name);+      char_u *s;+      if (STRNCMP(p, tab[i].name, len) == 0+          && p[len] == ':'+          && p[len + 1] != NUL) {+        s = p + len + 1;+        int c1 = mb_ptr2char_adv(&s);+        if (mb_char2cells(c1) > 1) {+          continue;+        }+        if (tab[i].cp == &lcs_tab2) {+          if (*s == NUL) {+            continue;+          }+          int c2 = mb_ptr2char_adv(&s);+          if (mb_char2cells(c2) > 1) {             continue;-          if (tab[i].cp == &lcs_tab2) {-            if (*s == NUL)-              continue;-            c2 = mb_ptr2char_adv(&s);-            if (mb_char2cells(c2) > 1)-              continue;           }-          if (*s == ',' || *s == NUL) {-            if (round) {-              if (tab[i].cp == &lcs_tab2) {-                lcs_tab1 = c1;-                lcs_tab2 = c2;-              } else if (tab[i].cp != NULL)-                *(tab[i].cp) = c1;+        }+        if (*s == ',' || *s == NUL) {+          p = s;+          break;+        }+      }+    } -            }-            p = s;-            break;+    if (i == entries) {+      return e_invarg;+    }+    if (*p == ',') {+      ++p;+    }+  }++  // Assign values.++  // After checking that the value is valid: set defaults: space for+  // 'fillchars', NUL for 'listchars'.+  for (int i = 0; i < entries; ++i) {+    if (tab[i].cp != NULL) {+      *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');+    }+  }+  if (varp == &p_lcs) {+    lcs_tab1 = NUL;+  } else {+    fill_diff = '-';+  }+  p = *varp;+  while (*p) {+    int i = 0;+    for (; i < entries; ++i) {+      int len = (int)STRLEN(tab[i].name);+      char_u *s;+      if (STRNCMP(p, tab[i].name, len) == 0+          && p[len] == ':'+          && p[len + 1] != NUL) {+        s = p + len + 1;+        int c1 = mb_ptr2char_adv(&s);+        if (mb_char2cells(c1) > 1) {+          continue;+        }+        int c2 = 0;+        if (tab[i].cp == &lcs_tab2) {+          if (*s == NUL) {+            continue;+          }+          c2 = mb_ptr2char_adv(&s);+          if (mb_char2cells(c2) > 1) {+            continue;           }         }+        if (*s == ',' || *s == NUL) {+          if (tab[i].cp == &lcs_tab2) {+            lcs_tab1 = c1;+            lcs_tab2 = c2;+          } else if (tab[i].cp != NULL) {+            *(tab[i].cp) = c1;+          }+          p = s;+          break;+        }       }+    }","Copying and pasting code is also an anti pattern. If a line needs to change in the above loop, it likely has to change here, too. If you can, please try to find a way to factor this into a reusable function.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1258,18152981,2014-09-29T13:27:26Z,test/legacy/002_filename_recognition_spec.lua,"@@ -0,0 +1,60 @@+-- Test if URLs are recognized as filenames by commands such as ""gf"". Here+-- we'll use `expand(""<cfile>"")` since ""gf"" would need to open the file.++local helpers = require('test.functional.helpers')+local clear, feed, insert = helpers.clear, helpers.feed, helpers.insert+local execute, expect = helpers.execute, helpers.expect++describe('filename recognition', function()+  setup(clear)++  it('insert some URLs', function()+    insert([[+      first test for URL://machine.name/tmp/vimtest2a and other text+      second test for URL://machine.name/tmp/vimtest2b. And other text+      third test for URL:\\machine.name\vimtest2c and other text+      fourth test for URL:\\machine.name\tmp\vimtest2d, and other text]])+    expect([[+      first test for URL://machine.name/tmp/vimtest2a and other text+      second test for URL://machine.name/tmp/vimtest2b. And other text+      third test for URL:\\machine.name\vimtest2c and other text+      fourth test for URL:\\machine.name\tmp\vimtest2d, and other text]])+  end)++  it('go to the first URL and append it to the beginning', function()+    execute('/^first', '/tmp', 'call append(0, expand(""<cfile>""))')+    expect([[+      URL://machine.name/tmp/vimtest2a+      first test for URL://machine.name/tmp/vimtest2a and other text]], 0, 2)+  end)++  it('repeat for the second URL', function()+    -- this time, navigate to the word ""URL"" instead of ""tmp""+    execute('/^second', '/URL', 'call append(1, expand(""<cfile>""))')+    expect([[+      URL://machine.name/tmp/vimtest2b+      first test for URL://machine.name/tmp/vimtest2a and other text]], 1, 3)+  end)++  it('repeat for the remaining URLs', function()+    -- This time, the 'isfname' option must be set to allow '\' in filenames+    execute('set isf=@,48-57,/,.,-,_,+,,,$,:,~,\\')+    execute('/^third', '/name', 'call append(2, expand(""<cfile>""))')+    execute('/^fourth', '/URL', 'call append(3, expand(""<cfile>""))')+    expect([[+      URL:\\machine.name\vimtest2c+      URL:\\machine.name\tmp\vimtest2d+      first test for URL://machine.name/tmp/vimtest2a and other text]], 2, 5)+  end)++  it('delete the initial text', function()","I think all of these `it()` blocks need to be combined into one `it()` block. I believe busted v2 randomizes test order. Even if it doesn't, it may do so in the future (it's considered bad practice for tests to depend on each other, they should all be self-contained).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1141,18253184,2014-09-30T23:00:05Z,src/nvim/eval.c,"@@ -9410,13 +9412,13 @@ static void getpos_both(typval_T *argvars, typval_T *rettv, bool getcurpos)   list_T *l;   int fnum = -1; -  rettv_list_alloc(rettv);-  l = rettv->vval.v_list;   if (getcurpos) {     fp = &curwin->w_cursor;   } else {     fp = var2fpos(&argvars[0], true, &fnum);   }++  l = rettv_list_alloc(rettv);",Could move the declaration here.```list_T *l = rettv_list_alloc(rettv);```,
2503012,mtayler,https://api.github.com/repos/neovim/neovim/pulls/1259,18254103,2014-09-30T23:27:37Z,neovim.rb,"@@ -11,8 +11,8 @@ class Neovim < Formula    def install     ENV.deparallelize-    system ""make"", ""deps""-    system ""cmake"", ""-DCMAKE_BUILD_TYPE=Debug"", ""-DCMAKE_PREFIX_PATH=.deps/usr"", ""-DLibUV_USE_STATIC=YES"", ""-DCMAKE_INSTALL_PREFIX:PATH=#{prefix}""+    system ""make""","Homebrew clones a fresh copy of the repo every time it installs, so caches should be no issue. I'll push another commit with the changes you suggested.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1141,18258755,2014-10-01T02:28:50Z,src/nvim/eval.c,"@@ -14426,10 +14426,11 @@ static void f_system(typval_T *argvars, typval_T *rettv)   }    // get input to the shell command (if any), and its length-  char_u buf[NUMBUFLEN];-  const char *input = (argvars[1].v_type != VAR_UNKNOWN)-      ? (char *) get_tv_string_buf_chk(&argvars[1], buf): NULL;-  size_t input_len = input ? strlen(input) : 0;+  size_t input_len;+  char *input = (char *) save_tv_as_string(&argvars[1], &input_len);+  if (input_len == (size_t) -1) {","It's not C99, only POSIX, so we decided on typedefing `ssize` (see #682 for discussion). In the meantime `ptrdiff_t` would be better so we can find it later.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1259,18345872,2014-10-02T15:17:32Z,neovim.rb,"@@ -11,8 +11,8 @@ class Neovim < Formula    def install     ENV.deparallelize-    system ""make"", ""deps""-    system ""cmake"", ""-DCMAKE_BUILD_TYPE=Debug"", ""-DCMAKE_PREFIX_PATH=.deps/usr"", ""-DLibUV_USE_STATIC=YES"", ""-DCMAKE_INSTALL_PREFIX:PATH=#{prefix}""+    system ""make""","> Very true. I'm fine with whatever, just keep in mind the ""Install"" page is directed towards ""end users"".Took a shot at it, hope it's an improvement. I also moved the section about required build tools to the building page; I think this belongs on a ""dev"" page rather than on a ""user"" page.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1267,18432579,2014-10-05T00:14:10Z,src/nvim/version.c,"@@ -752,48 +744,17 @@ static void list_features(void)  void list_version(void) {-  int i;-  int first;-  char *s = """";-   // When adding features here, don't forget to update the list of   // internal variables in eval.c!   MSG(longVersion); -  // Print the list of patch numbers if there is at least one.-  // Print a range when patches are consecutive: ""1-10, 12, 15-40, 42-45""-  if (included_patches[0] != 0) {-    MSG_PUTS(_(""\nIncluded patches: ""));","Removed ""Included patches"" list from user-visible `:version` output, it is meaningless for our purposes. Vim compatibility can be verified programmatically with `has(""patchXXX"")` and `v:version`.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1267,18434165,2014-10-05T09:53:21Z,src/nvim/version_defs.h,"@@ -1,47 +1,48 @@ #ifndef NVIM_VERSION_DEFS_H #define NVIM_VERSION_DEFS_H -/*- * VIM - Vi IMproved		by Bram Moolenaar- *- * Do "":help uganda""  in Vim to read copying and usage conditions.- * Do "":help credits"" in Vim to see a list of people who contributed.- */+// VIM - Vi IMproved    by Bram Moolenaar+//+// Do "":help uganda""  in Vim to read copying and usage conditions.+// Do "":help credits"" in Vim to see a list of people who contributed. -/*- * Define the version number, name, etc.- * The patchlevel is in included_patches[], in version.c.- *- * This doesn't use string concatenation, some compilers don't support it.- */+#define STR_(x) #x+#define STR(x) STR_(x) +//+// Nvim version identifiers+//+#ifndef NVIM_VERSION_MAJOR+#define NVIM_VERSION_MAJOR 0+#endif+#ifndef NVIM_VERSION_MINOR+#define NVIM_VERSION_MINOR 0+#endif+#ifndef NVIM_VERSION_PATCH+#define NVIM_VERSION_PATCH 0+#endif+#ifndef NVIM_VERSION_PRERELEASE+#define NVIM_VERSION_PRERELEASE+#endif+#ifndef NVIM_VERSION_BUILD+#define NVIM_VERSION_BUILD+#endif+// for the startup-screen+#define NVIM_VERSION_MEDIUM STR(NVIM_VERSION_MAJOR) ""."" STR(NVIM_VERSION_MINOR)+// for the "":version"" command and ""nvim -h""+#define NVIM_VERSION_LONG ""NVIM "" NVIM_VERSION_MEDIUM ""."" STR(NVIM_VERSION_PATCH) NVIM_VERSION_PRERELEASE NVIM_VERSION_BUILD",What about including the number of commits (`git rev-list --count HEAD`) to get a strictly increasing (~~comparable~~ sortable) version number?,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1267,18434513,2014-10-05T11:08:24Z,CMakeLists.txt,"@@ -12,9 +12,14 @@ set(DEPS_BIN_DIR ""${DEPS_INSTALL_DIR}/bin"")  list(APPEND CMAKE_PREFIX_PATH ${DEPS_INSTALL_DIR}) -set(NEOVIM_VERSION_MAJOR 0)-set(NEOVIM_VERSION_MINOR 0)-set(NEOVIM_VERSION_PATCH 0)+include(GetGitRevisionDescription)+get_git_head_revision(GIT_REFSPEC GIT_SHA1)+set(NVIM_VERSION_MAJOR 0)+set(NVIM_VERSION_MINOR 0)+set(NVIM_VERSION_PATCH 0)+set(NVIM_VERSION_PRERELEASE ""-alpha"")+# TODO(justinmk): do not set this for ""release"" builds #1071+set(NVIM_VERSION_BUILD ""+${GIT_SHA1}"")","Good question.  I would not key off of the build type.  My initial thought on the matter was to have some kind of file generated (given some sort of flag to say I'm making a release archive) and include in the source release.  The file would serve as an indicator to use just the version number defined in CMake or it would contain the version information to use.  The only thing I don't like about that is that `git archive` would not produce a proper release archive (you'd need the version file in it) without running through this step, but I consider that as much an advantage (no accidental releases) as much as a hinderance.#1071 was just about having Travis build with optimizations--it wasn't going to decide how to determine whether we're building for a release or not.  I really need to finish that line up, but there are several warnings in the optimized builds we need to get rid of.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1267,18434732,2014-10-05T12:03:55Z,src/nvim/version_defs.h,"@@ -1,47 +1,48 @@ #ifndef NVIM_VERSION_DEFS_H #define NVIM_VERSION_DEFS_H -/*- * VIM - Vi IMproved		by Bram Moolenaar- *- * Do "":help uganda""  in Vim to read copying and usage conditions.- * Do "":help credits"" in Vim to see a list of people who contributed.- */+// VIM - Vi IMproved    by Bram Moolenaar+//+// Do "":help uganda""  in Vim to read copying and usage conditions.+// Do "":help credits"" in Vim to see a list of people who contributed. -/*- * Define the version number, name, etc.- * The patchlevel is in included_patches[], in version.c.- *- * This doesn't use string concatenation, some compilers don't support it.- */+#define STR_(x) #x+#define STR(x) STR_(x) +//+// Nvim version identifiers+//+#ifndef NVIM_VERSION_MAJOR+#define NVIM_VERSION_MAJOR 0+#endif+#ifndef NVIM_VERSION_MINOR+#define NVIM_VERSION_MINOR 0+#endif+#ifndef NVIM_VERSION_PATCH+#define NVIM_VERSION_PATCH 0+#endif+#ifndef NVIM_VERSION_PRERELEASE+#define NVIM_VERSION_PRERELEASE+#endif+#ifndef NVIM_VERSION_BUILD+#define NVIM_VERSION_BUILD+#endif+// for the startup-screen+#define NVIM_VERSION_MEDIUM STR(NVIM_VERSION_MAJOR) ""."" STR(NVIM_VERSION_MINOR)+// for the "":version"" command and ""nvim -h""+#define NVIM_VERSION_LONG ""NVIM "" NVIM_VERSION_MEDIUM ""."" STR(NVIM_VERSION_PATCH) NVIM_VERSION_PRERELEASE NVIM_VERSION_BUILD","That can take a long to to compute, depending on how far ahead you get.",
3105373,xu-cheng,https://api.github.com/repos/neovim/neovim/pulls/1267,18440762,2014-10-06T03:36:59Z,src/nvim/version_defs.h,"@@ -1,47 +1,48 @@ #ifndef NVIM_VERSION_DEFS_H #define NVIM_VERSION_DEFS_H -/*- * VIM - Vi IMproved		by Bram Moolenaar- *- * Do "":help uganda""  in Vim to read copying and usage conditions.- * Do "":help credits"" in Vim to see a list of people who contributed.- */+// VIM - Vi IMproved    by Bram Moolenaar+//+// Do "":help uganda""  in Vim to read copying and usage conditions.+// Do "":help credits"" in Vim to see a list of people who contributed. -/*- * Define the version number, name, etc.- * The patchlevel is in included_patches[], in version.c.- *- * This doesn't use string concatenation, some compilers don't support it.- */+#define STR_(x) #x+#define STR(x) STR_(x) +//+// Nvim version identifiers+//+#ifndef NVIM_VERSION_MAJOR+#define NVIM_VERSION_MAJOR 0+#endif+#ifndef NVIM_VERSION_MINOR+#define NVIM_VERSION_MINOR 0+#endif+#ifndef NVIM_VERSION_PATCH+#define NVIM_VERSION_PATCH 0+#endif+#ifndef NVIM_VERSION_PRERELEASE+#define NVIM_VERSION_PRERELEASE+#endif+#ifndef NVIM_VERSION_BUILD+#define NVIM_VERSION_BUILD+#endif+// for the startup-screen+#define NVIM_VERSION_MEDIUM STR(NVIM_VERSION_MAJOR) ""."" STR(NVIM_VERSION_MINOR)+// for the "":version"" command and ""nvim -h""+#define NVIM_VERSION_LONG ""NVIM "" NVIM_VERSION_MEDIUM ""."" STR(NVIM_VERSION_PATCH) NVIM_VERSION_PRERELEASE NVIM_VERSION_BUILD","We should make the version strictly increasing, so the version control can get a idea which build is newer one. How about reporting the version as `0.0.0-alpha-<commit count>-<commit sha>`, while `<commit count>` is calculated by `git rev-list --count HEAD`?",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1267,18444554,2014-10-06T08:00:35Z,src/nvim/version_defs.h,"@@ -1,47 +1,48 @@ #ifndef NVIM_VERSION_DEFS_H #define NVIM_VERSION_DEFS_H -/*- * VIM - Vi IMproved		by Bram Moolenaar- *- * Do "":help uganda""  in Vim to read copying and usage conditions.- * Do "":help credits"" in Vim to see a list of people who contributed.- */+// VIM - Vi IMproved    by Bram Moolenaar+//+// Do "":help uganda""  in Vim to read copying and usage conditions.+// Do "":help credits"" in Vim to see a list of people who contributed. -/*- * Define the version number, name, etc.- * The patchlevel is in included_patches[], in version.c.- *- * This doesn't use string concatenation, some compilers don't support it.- */+#define STR_(x) #x+#define STR(x) STR_(x) +//+// Nvim version identifiers+//+#ifndef NVIM_VERSION_MAJOR+#define NVIM_VERSION_MAJOR 0+#endif+#ifndef NVIM_VERSION_MINOR+#define NVIM_VERSION_MINOR 0+#endif+#ifndef NVIM_VERSION_PATCH+#define NVIM_VERSION_PATCH 0+#endif+#ifndef NVIM_VERSION_PRERELEASE+#define NVIM_VERSION_PRERELEASE+#endif+#ifndef NVIM_VERSION_BUILD+#define NVIM_VERSION_BUILD+#endif+// for the startup-screen+#define NVIM_VERSION_MEDIUM STR(NVIM_VERSION_MAJOR) ""."" STR(NVIM_VERSION_MINOR)+// for the "":version"" command and ""nvim -h""+#define NVIM_VERSION_LONG ""NVIM "" NVIM_VERSION_MEDIUM ""."" STR(NVIM_VERSION_PATCH) NVIM_VERSION_PRERELEASE NVIM_VERSION_BUILD","> How about reporting the version as 0.0.0-alpha-<commit count>-<commit sha>, while <commit count> is calculated by git rev-list --count HEAD?No, that will take an increasingly longer time to compute as more commits land.  If you need something that increases regularly, use the date:```git log -1 --format='%ci' | cut -f 1 -d ' ' | sed -e 's/-//g'```That can be part of the Homebrew's formula.  We don't need to do this in Neovim right now.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1267,18502949,2014-10-07T06:44:20Z,config/pathdef.c.in,"@@ -1,7 +1,7 @@ #include ""${PROJECT_SOURCE_DIR}/src/nvim/vim.h"" char_u *default_vim_dir = (char_u *)""${CMAKE_INSTALL_PREFIX}/share/nvim""; char_u *default_vimruntime_dir = (char_u *)"""";-char_u *all_cflags = (char_u *)""${COMPILER_FLAGS}"";-char_u *all_lflags = (char_u *)""${LINKER_FLAGS}"";+char_u *all_cflags = (char_u *)""${CFLAGS}"";","@jszakmeister This doesn't really work. Do you know of any way to achieve this with cmake? According to everything I've read it's not possible. We may want to just remove these cflags/lflags messages, they're close to useless.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1182,18537535,2014-10-07T18:07:02Z,src/nvim/ops.c,"@@ -5209,33 +5191,74 @@ static void free_register(struct yankreg *reg)   y_current = curr; } -static void copy_register(struct yankreg *dest, struct yankreg *src)-{-  free_register(dest);-  *dest = *src;-  dest->y_array = xcalloc(src->y_size, sizeof(uint8_t *));-  for (int j = 0; j < src->y_size; ++j) {-    dest->y_array[j] = (uint8_t *)xstrdup((char *)src->y_array[j]);+// return target register+static int check_clipboard_name(int *name) {+  if (*name == '*' || *name == '+') {+    return CLIP_REGISTER;+  } else if (!(*name) && provider_has_feature(""clipboard"")) {+    if (cb_flags & CB_UNNAMEDPLUS) {+      *name = '+';+      return 0; //unnamed+    } else if (cb_flags & CB_UNNAMED) {+      *name = '*';+      return 0; //unnamed+    }   }+  // don't do anything for other register names+  return -1; }  static void get_clipboard(int name) {-  if (!(name == '*' || name == '+'-        || (p_unc && !name && provider_has_feature(""clipboard"")))) {+  int ireg = check_clipboard_name(&name);+  if (ireg < 0) {     return;   } -  struct yankreg *reg = &y_regs[CLIP_REGISTER];+  struct yankreg *reg = &y_regs[ireg];   free_register(reg);+   Array args = ARRAY_DICT_INIT;-  Object result = provider_call(""clipboard_get"", args);+  char regname[] = { (char)name, NUL };+  ADD(args, STRING_OBJ(cstr_to_string(regname)));++  Object res = provider_call(""clipboard_get"", args); -  if (result.type != kObjectTypeArray) {+  if (res.type != kObjectTypeArray) {     goto err;   } -  Array lines = result.data.array;+  Array result = res.data.array, lines;+  if (result.size == 2 && result.items[0].type == kObjectTypeArray) {+    lines = result.items[0].data.array;+    if (result.items[1].type != kObjectTypeString) {+      goto err;+    }+    String regtype = result.items[1].data.string;+    if (regtype.size != 1) {+      goto err;+    }+    switch (regtype.data[0]) {+    case 'v': case 'c':+      reg->y_type = MCHAR;+      break;+    case 'V': case 'l':+      reg->y_type = MLINE;+      break;+    case 'b': case Ctrl_V:+      reg->y_type = MBLOCK;+      break;+    default:+      goto err;+    }+    api_free_string(regtype);+    result.items[1] = NIL;+  } else {+    lines = result;+    // provider did not specify regtype, use sane defaults+    reg->y_type = lines.size > 1 ? MLINE : MCHAR;","One thing #1134 adds that might be helpful: It adds `write_reg_contents_lst()` which accepts a `char_u **` instead of a normal string. Similarly, it allows one to get the register contents as a list by invoking `get_reg_contents(name, kGRegList)`. Though, I tried to do this after rebasing your branch on top of that and somehow introduced an infinite loop...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1267,18540897,2014-10-07T18:58:03Z,src/nvim/version_defs.h,"@@ -1,47 +1,48 @@ #ifndef NVIM_VERSION_DEFS_H #define NVIM_VERSION_DEFS_H -/*- * VIM - Vi IMproved		by Bram Moolenaar- *- * Do "":help uganda""  in Vim to read copying and usage conditions.- * Do "":help credits"" in Vim to see a list of people who contributed.- */+// VIM - Vi IMproved    by Bram Moolenaar+//+// Do "":help uganda""  in Vim to read copying and usage conditions.+// Do "":help credits"" in Vim to see a list of people who contributed. -/*- * Define the version number, name, etc.- * The patchlevel is in included_patches[], in version.c.- *- * This doesn't use string concatenation, some compilers don't support it.- */+#define STR_(x) #x+#define STR(x) STR_(x) +//+// Nvim version identifiers+//+#ifndef NVIM_VERSION_MAJOR+#define NVIM_VERSION_MAJOR 0+#endif+#ifndef NVIM_VERSION_MINOR+#define NVIM_VERSION_MINOR 0+#endif+#ifndef NVIM_VERSION_PATCH+#define NVIM_VERSION_PATCH 0+#endif+#ifndef NVIM_VERSION_PRERELEASE+#define NVIM_VERSION_PRERELEASE+#endif+#ifndef NVIM_VERSION_BUILD+#define NVIM_VERSION_BUILD+#endif+// for the startup-screen+#define NVIM_VERSION_MEDIUM STR(NVIM_VERSION_MAJOR) ""."" STR(NVIM_VERSION_MINOR)+// for the "":version"" command and ""nvim -h""+#define NVIM_VERSION_LONG ""NVIM "" NVIM_VERSION_MEDIUM ""."" STR(NVIM_VERSION_PATCH) NVIM_VERSION_PRERELEASE NVIM_VERSION_BUILD","> it's possible for one person get build 201412312200 while the other person get 201501010100 for the same commitThe same build number may also represent _different_ commits made in the same minute (or second...). But I think these concerns are premature at the moment. - The build number is for humans. - In the unlikely event there's any ambiguity, then the commit sha is listed on the very next line :)- The purpose of the build number is to identify unreleased builds created by the _build bot_. It's not intended to uniquely identify builds made by anyone anywhere.> There're some way you can try.Thanks but those won't work. `-date=local` does not seem to affect `--format='%ci'`, and the other suggestions are unix-only.So, if someone wants to send a PR that avoids the timezone issue while not causing more pain for the Windows port, please do, but let's move forward with this one in the meantime.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1274,18719558,2014-10-10T17:42:06Z,cmake/GetGitRevisionDescription.cmake,"@@ -41,16 +41,18 @@ set(__get_git_revision_description YES) # to find the path to this module rather than the path to a calling list file get_filename_component(_gitdescmoddir ${CMAKE_CURRENT_LIST_FILE} PATH) -function(get_git_head_revision _refspecvar _hashvar)-  set(GIT_PARENT_DIR ""${CMAKE_CURRENT_SOURCE_DIR}"")-  set(GIT_DIR ""${GIT_PARENT_DIR}/.git"")-  while(NOT EXISTS ""${GIT_DIR}"")	# .git dir not found, search parent directories+function(get_git_dir _gitdir)+  # .git dir not found, search parent directories",This comment is confusing given that it is duplicated on line 51.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1342,19514274,2014-10-29T00:37:24Z,src/nvim/eval.c,"@@ -424,7 +424,8 @@ static struct vimvar {   {VV_NAME(""oldfiles"",         VAR_LIST), 0},   {VV_NAME(""windowid"",         VAR_NUMBER), VV_RO},   {VV_NAME(""progpath"",         VAR_STRING), VV_RO},-  {VV_NAME(""job_data"",         VAR_LIST), 0}+  {VV_NAME(""job_data"",         VAR_LIST), 0},+  {VV_NAME(""command_output"",   VAR_STRING), 0}",@tarruda  Shouldn't this be readonly (`VV_RO`)? Same question for `job_data`.,
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1358,19573625,2014-10-29T21:27:38Z,runtime/plugin/python_setup.vim,"@@ -24,23 +32,29 @@ elseif executable('python2')   "" In some distros, python3 is the default python   let s:python_interpreter = 'python2' else+  call s:ShowError('No python interpreter found')",Found this old mailing list post: http://vim.1045645.n5.nabble.com/gettext-support-for-vim-script-td1196097.html,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1345,19589605,2014-10-30T06:43:18Z,src/nvim/option.c,"@@ -6173,8 +6173,8 @@ showoneopt (   varp = get_varp_scope(p, opt_flags);    /* for 'modified' we also need to check if 'ff' or 'fenc' changed. */-  if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed-                              ? !curbufIsChanged() : !*(int *)varp))+  if ((p->flags & P_BOOL) && ((bool *)varp == &curbuf->b_changed+                              ? !curbufIsChanged() : !*(bool *)varp))",Sorry. Debuging incomplete diff was really bad idea.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/951,19708131,2014-11-01T22:10:27Z,src/nvim/api/window.c,"@@ -125,11 +130,8 @@ void window_set_height(Window window, Integer height, Error *err)     return;   } -  win_T *savewin = curwin;-  curwin = win;",@bfredl  I think @tarruda may have done this intentionally because there may be code paths that only operate on `curwin` because they aren't (yet) parameterized on `win`. I assume this is why things like `:windo` must actually change the current window in order to do useful things. Obviously we want to move away from this limitation eventually.Could you break off this commit into a separate PR so I can merge the other two commits in this PR?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1377,19717866,2014-11-03T02:58:12Z,runtime/doc/msgpack_rpc.txt,"@@ -74,31 +74,31 @@ There are four ways to open msgpack-rpc streams to nvim:  2. Through stdin/stdout of a program spawned by the |rpcstart()| function. -3. Through the socket automatically created with every instance. To find out-   the socket location(which is random by default) from a running nvim+3. Through the socket automatically created with each instance. To find out+   the socket's location(which is random by default) from a running nvim","Also don't think possessive case is necessary here, the old verbiage isn't ambiguous or awkward. However I would like to see a space before the `(`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1377,19717901,2014-11-03T03:01:55Z,runtime/doc/msgpack_rpc.txt,"@@ -210,15 +210,15 @@ that makes this task easier: - Each function metadata object has type information about the return value   and parameters. These can be used for generating strongly-typed APIs in   static languages.-- Container types may be decorated with type/size constraints, eg:+- Container types may be decorated with type/size constraints, e.g.",Technically this should be `viz.` but that would be too pedantic for software documentation purposes. I think the colon should be preserved though.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1377,19718881,2014-11-03T04:41:00Z,runtime/doc/msgpack_rpc.txt,"@@ -210,15 +210,15 @@ that makes this task easier: - Each function metadata object has type information about the return value   and parameters. These can be used for generating strongly-typed APIs in   static languages.-- Container types may be decorated with type/size constraints, eg:+- Container types may be decorated with type/size constraints, e.g.","I disagree, as the lack of a colon keeps the sentence flowing IMO. I don't think the example's are large enough to warrant an interruption (obviously a comma is an interruption, but less so than a colon).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1348,19723980,2014-11-03T09:36:21Z,CONTRIBUTING.md,"@@ -50,9 +50,17 @@ When submitting pull requests, include one of the following tokens in the title:  #### Testing -- We are unlikely to merge your PR if the Travis build fails.+- Please run all tests before submitting a pull request:","We want to encourage incomplete PRs to be posted as WIP to avoid duplicate work, so I think we should soften the language here. Maybe just change it to:```To run all tests locally:...```",
3105373,xu-cheng,https://api.github.com/repos/neovim/neovim/pulls/1381,19729149,2014-11-03T12:02:32Z,cmake/GenerateHelptags.cmake,"@@ -1,4 +1,4 @@-if(ENV{DESTDIR})+if(DEFINED ENV{DESTDIR})","If this were the case, you would need to change https://github.com/neovim/neovim/blob/master/cmake/InstallHelpers.cmake#L25 accordingly.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1411,19937798,2014-11-06T11:02:27Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -48,7 +57,7 @@ message(STATUS ""downloading...  file(DOWNLOAD ${URL} ${file}   ${timeout_args}-  EXPECTED_MD5 ${EXPECTED_MD5}+  EXPECTED_HASH SHA1=${EXPECTED_SHA1}","It's not documented, but I think homebrew does support `md5` instead of `sha1`: https://github.com/Homebrew/homebrew/blob/master/Library/Homebrew/compat/md5.rbMaybe by the time they drop support for it, we can drop support for Ubuntu 12.04.",
3105373,xu-cheng,https://api.github.com/repos/neovim/neovim/pulls/1411,19937993,2014-11-06T11:06:12Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -48,7 +57,7 @@ message(STATUS ""downloading...  file(DOWNLOAD ${URL} ${file}   ${timeout_args}-  EXPECTED_MD5 ${EXPECTED_MD5}+  EXPECTED_HASH SHA1=${EXPECTED_SHA1}","Homebrew deprecated MD5 for security purpose long time ago. You can see it on the file you pointed.Also if neovim has more favor to security, I recommend we do the same.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1411,19938539,2014-11-06T11:18:07Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -48,7 +57,7 @@ message(STATUS ""downloading...  file(DOWNLOAD ${URL} ${file}   ${timeout_args}-  EXPECTED_MD5 ${EXPECTED_MD5}+  EXPECTED_HASH SHA1=${EXPECTED_SHA1}","> @fwalch It's meanless for maintaince or security.If you have both hashes in there, you can use SHA1 (for CMake and for automatically updating the Homebrew formula in `bot-ci`), except when the CMake version doesn't support SHA1 (conditional on `CMAKE_MAJOR_VERSION` etc), then you can fall back to MD5.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1411,19939009,2014-11-06T11:29:54Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -48,7 +57,7 @@ message(STATUS ""downloading...  file(DOWNLOAD ${URL} ${file}   ${timeout_args}-  EXPECTED_MD5 ${EXPECTED_MD5}+  EXPECTED_HASH SHA1=${EXPECTED_SHA1}","> It's meaningless for maintenance as you still requires calculating both sha1 and md5 for every updates.That shouldn't happen too often, and it would be required only in one place (CMake file). But, if we use SHA1 in Homebrew only, we can't automatically update the formula from the CMake file.> And it's meaningless for security as an attack can still attack the MD5 users if he/she found a MD5 collision. I'm not proposing this for security reasons, but for automatic formula updates; still, users of newer CMake versions would be automatically safe(r), while now, everybody is vulnerable to an MD5 collision.Or we could just use MD5 in homebrew for now; while it's deprecated, it's still supported.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1340,19950693,2014-11-06T15:28:56Z,src/nvim/memfile.c,"@@ -1,39 +1,54 @@ /*- * VIM - Vi IMproved	by Bram Moolenaar+ * VIM - Vi IMproved    by Bram Moolenaar  *  * Do "":help uganda""  in Vim to read copying and usage conditions.  * Do "":help credits"" in Vim to see a list of people who contributed.  * See README.txt for an overview of the Vim source code.  */ -/*- * memfile.c: Contains the functions for handling blocks of memory which can- * be stored in a file. This is the implementation of a sort of virtual memory.- *- * A memfile consists of a sequence of blocks. The blocks numbered from 0- * upwards have been assigned a place in the actual file. The block number- * is equal to the page number in the file. The- * blocks with negative numbers are currently in memory only. They can be- * assigned a place in the file when too much memory is being used. At that- * moment they get a new, positive, number. A list is used for translation of- * negative to positive numbers.- *- * The size of a block is a multiple of a page size, normally the page size of- * the device the file is on. Most blocks are 1 page long. A Block of multiple- * pages is used for a line that does not fit in a single page.- *- * Each block can be in memory and/or in a file. The block stays in memory- * as long as it is locked. If it is no longer locked it can be swapped out to- * the file. It is only written to the file if it has been changed.- *- * Under normal operation the file is created when opening the memory file and- * deleted when closing the memory file. Only with recovery an existing memory- * file is opened.- */-+/// An abstraction to handle blocks of memory which can be stored in a file.+/// This is the implementation of a sort of virtual memory.+///+/// A memfile consists of a sequence of blocks:+/// - Blocks numbered from 0 upwards have been assigned a place in the actual+/// file. The block number is equal to the page number in the file.+/// - Blocks with negative numbers are currently in memory only. They can be+/// assigned a place in the file when too much memory is being used. At that+/// moment, they get a new, positive, number. A list is used for translation of+/// negative to positive numbers.","Can you indent the bullets:```+/// - Blocks numbered from 0 upwards have been assigned a place in the actual+///   file. The block number is equal to the page number in the file.+/// - Blocks with negative numbers are currently in memory only. They can be+///   assigned a place in the file when too much memory is being used. At that+///   moment, they get a new, positive, number. A list is used for translation of+///   negative to positive numbers.```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1340,19965103,2014-11-06T18:49:47Z,src/nvim/memfile.c,"@@ -505,22 +470,23 @@ int mf_sync(memfile_T *mfp, int flags)     if (STRCMP(p_sws, ""fsync"") == 0) {       if (fsync(mfp->mf_fd))         status = FAIL;-    } else+    } else { # endif-    /* OpenNT is strictly POSIX (Benzinger) */-    /* Tandem/Himalaya NSK-OSS doesn't have sync() */+    // OpenNT is strictly POSIX (Benzinger).+    // Tandem/Himalaya NSK-OSS doesn't have sync() # if defined(__OPENNT) || defined(__TANDEM)     fflush(NULL); # else     sync(); # endif+# ifdef HAVE_FSYNC+    }+# endif #endif # ifdef SYNC_DUP_CLOSE-    /*-     * Win32 is a bit more work: Duplicate the file handle and close it.-     * This should flush the file to disk.-     */-    if ((fd = dup(mfp->mf_fd)) >= 0)+    // Win32 is a bit more work: Duplicate the file handle and close it.+    // This should flush the file to disk.+    if ((int fd = dup(mfp->mf_fd)) >= 0)",`int fd;` needs to be declared before the `if`. The `#ifdef` hides this error.,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1340,19967449,2014-11-06T19:22:05Z,src/nvim/memfile.c,"@@ -249,53 +248,42 @@ mf_close_file (   } } -/*- * Set new size for a memfile.  Used when block 0 of a swapfile has been read- * and the size it indicates differs from what was guessed.- */+/// Set new size for a memfile. Used when block 0 of a swapfile has been read+/// and the size it indicates differs from what was guessed. void mf_new_page_size(memfile_T *mfp, unsigned new_size) {-  /* Correct the memory used for block 0 to the new size, because it will be-   * freed with that size later on. */+  // Correct the memory used for block 0 to the new size, because it will be+  // freed with that size later on.+  assert(new_size > mfp->mf_page_size);","I was right in that, in principle, this should only be called to augment size.This is only used when recovering from old swap file, and size is initially set to the minimum one (line 865).But I was wrong in the sense that calling it otherwise (to diminish size) is an error controlled by invocating code, and so, this function shouldn't fail (which assert does) on such conditions.So, this was an actual bug. Thanks!I will change this to:```  if (new_size >= mfp->mf_page_size) {    total_mem_used += new_size - mfp->mf_page_size;  } else {    total_mem_used -= mfp->mf_page_size - new_size;  }```Ok?",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1340,19974673,2014-11-06T21:00:34Z,src/nvim/memfile.c,"@@ -721,70 +665,60 @@ int mf_release_all(void)   return retval; } -/*- * Allocate a block header and a block of memory for it- */-static bhdr_T *mf_alloc_bhdr(memfile_T *mfp, int page_count)+/// Allocate a block header and a block of memory for it.+static bhdr_T *mf_alloc_bhdr(memfile_T *mfp, unsigned page_count) {   bhdr_T *hp = xmalloc(sizeof(bhdr_T));   hp->bh_data = xmalloc(mfp->mf_page_size * page_count);   hp->bh_page_count = page_count;-   return hp; } -/*- * Free a block header and the block of memory for it- */+/// Free a block header and its block memory. static void mf_free_bhdr(bhdr_T *hp) {   free(hp->bh_data);   free(hp); } -/*- * insert entry *hp in the free list- */+/// Insert a block in the free list. static void mf_ins_free(memfile_T *mfp, bhdr_T *hp) {   hp->bh_next = mfp->mf_free_first;   mfp->mf_free_first = hp; } -/*- * remove the first entry from the free list and return a pointer to it- * Note: caller must check that mfp->mf_free_first is not NULL!- */+/// Remove the first block in the free list and return it.+///+/// Caller must check that mfp->mf_free_first is not NULL. static bhdr_T *mf_rem_free(memfile_T *mfp) {-  bhdr_T      *hp;--  hp = mfp->mf_free_first;+  bhdr_T *hp = mfp->mf_free_first;   mfp->mf_free_first = hp->bh_next;   return hp; } -/*- * read a block from disk- *- * Return FAIL for failure, OK otherwise- */+/// Read a block from disk.+///+/// @return  OK    On success.+///          FAIL  On failure. Could be:+///                - No file.+///                - Error reading file. static int mf_read(memfile_T *mfp, bhdr_T *hp) {-  off_t offset;-  unsigned page_size;-  unsigned size;--  if (mfp->mf_fd < 0)       /* there is no file, can't read */+  if (mfp->mf_fd < 0)       // there is no file, can't read     return FAIL; -  page_size = mfp->mf_page_size;-  offset = (off_t)page_size * hp->bh_bnum;-  size = page_size * hp->bh_page_count;+  unsigned page_size = mfp->mf_page_size;+  // TODO(elmart): Check (page_size * hp->bh_bnum) within off_t bounds.","My current understanding of this is:In principle, `ptrdiff_t` is sized depending on machine's memory size, while `off_t` is sized depending on machine's disk size. So, they're not exactly equivalent, and `off_t` could in fact be bigger (for machines with really huge disks).Now, the problem with `off_t` is that is very poorly defined, and it has no min/max associated constants. So, I've found no way to chekc a value is in bounds.The article you link says that if we compile with _FILE_OFFSET_BITS=64, then we can, at least, we sure that `off_t` be 64 bits long, and then, we could use INT64_MAX/MIN to check bounds.If you agree, I will come back to this after a while (I've left todos in the code), as I still find it pretty confusing. Each article I read says a slightly different thing. It wasn't checked before, so we are not introducing a new bug by leaving it as it is by now. Ok?",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1414,19987449,2014-11-07T00:32:46Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -46,11 +46,19 @@ message(STATUS ""downloading...      dst='${file}'      timeout='${timeout_msg}'"") -file(DOWNLOAD ${URL} ${file}-  ${timeout_args}-  EXPECTED_MD5 ${EXPECTED_MD5}-  STATUS status-  LOG log)+if((DEFINED EXPECTED_SHA1) AND (${CMAKE_VERSION} VERSION_GREATER 2.8.10))+  file(DOWNLOAD ${URL} ${file}+    ${timeout_args}+    EXPECTED_HASH SHA1=${EXPECTED_SHA1}+    STATUS status+    LOG log)+else()+  file(DOWNLOAD ${URL} ${file}+    ${timeout_args}+    EXPECTED_MD5 ${EXPECTED_MD5}+    STATUS status+    LOG log)","It's not a big deal, but you could probably cut down on the repetitiveness here by doing something like this instead:``` cmakeif((DEFINED EXPECTED_SHA1) AND (${CMAKE_VERSION} VERSION_GREATER 2.8.10))  set(hash_args EXPECTED_HASH SHA1=${EXPECTED_SHA1})else()  set(hash_args EXPECTED_MD5 ${EXPECTED_MD5})endif()file(DOWNLOAD ${URL} ${file}  ${timeout_args}  ${hash_args}  STATUS status  LOG log)```Note that I haven't tried to run the above code, so there maybe typos or other issues.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1429,20050714,2014-11-08T08:56:52Z,src/nvim/msgpack_rpc/channel.c,"@@ -119,7 +119,7 @@ void channel_teardown(void) /// Creates an API channel by starting a job and connecting to its /// stdin/stdout. stderr is forwarded to the editor error stream. ///-/// @param argv The argument vector for the process+/// @param[consumed] argv The argument vector for the process","Not sure if this notation will be accepted by doxygen.From what I know, doxygen allows a direction attribute with possible values in/out/in-out using just that style.This is, `@param[in] ...`, etc.So, I don't know if a value other than those allowed will be rejected.It this in fact causes a problem, I'd just put `[consumed]` at the end of the line (for short descs), or on a new line (for longer descs).",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1383,20051378,2014-11-08T11:49:46Z,CMakeLists.txt,"@@ -53,16 +53,21 @@ if(TRAVIS_CI_BUILD)   add_definitions(-Werror) endif() -add_definitions(-DINCLUDE_GENERATED_DECLARATIONS)+if(CMAKE_COMPILER_IS_GNUCC)+  set(CMAKE_C_FLAGS_RELWITHDEBINFO ""-Og"")+else()+  set(CMAKE_C_FLAGS_RELWITHDEBINFO ""-O2 -g"")+endif() -add_definitions(-DHAVE_CONFIG_H)-if(CMAKE_BUILD_TYPE MATCHES Debug)-  # cmake automatically appends -g to the compiler flags+if(CMAKE_BUILD_TYPE MATCHES Debug OR CMAKE_BUILD_TYPE MATCHES RelWithDebInfo)   set(DEBUG 1) else()   set(DEBUG 0) endif()","`grep -r ""ifdef DEBUG$"" src` shows only a few places where DEBUG is used.. one of them would be removed in #1403. Updated the PR and removed this change. Assertions should work regardless, right? (as long as NDEBUG is not set)",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1403,20051924,2014-11-08T14:36:10Z,CMakeLists.txt,"@@ -12,6 +12,11 @@ set(DEPS_BIN_DIR ""${DEPS_INSTALL_DIR}/bin"")  list(APPEND CMAKE_PREFIX_PATH ${DEPS_INSTALL_DIR}) +# Set default build type.+if(NOT CMAKE_BUILD_TYPE)+  set(CMAKE_BUILD_TYPE ""RelWithDebInfo"")+endif()",@fwalch What about doing something like here: http://vtk.org/gitweb?p=VTK.git;a=blob;f=CMakeLists.txt;h=a57fd66ef333fc26bf74fe658c88c3c634f54c3a;hb=HEAD#l11,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1403,20051927,2014-11-08T14:36:36Z,CMakeLists.txt,"@@ -12,6 +12,11 @@ set(DEPS_BIN_DIR ""${DEPS_INSTALL_DIR}/bin"")  list(APPEND CMAKE_PREFIX_PATH ${DEPS_INSTALL_DIR}) +# Set default build type.+if(NOT CMAKE_BUILD_TYPE)+  set(CMAKE_BUILD_TYPE ""RelWithDebInfo"")+endif()",Email chain for reference: https://www.mail-archive.com/cmake@cmake.org/msg42005.html,
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1403,20052066,2014-11-08T15:11:47Z,CMakeLists.txt,"@@ -12,6 +12,11 @@ set(DEPS_BIN_DIR ""${DEPS_INSTALL_DIR}/bin"")  list(APPEND CMAKE_PREFIX_PATH ${DEPS_INSTALL_DIR}) +# Set default build type.+if(NOT CMAKE_BUILD_TYPE)+  set(CMAKE_BUILD_TYPE ""RelWithDebInfo"")+endif()","Adapted the PR to do something similar. I changed it so that the available build types are set unconditionally, but this only affects programs such as `ccmake`; passing a different build type (.e.g `-DCMAKE_BUILD_TYPE=Gentoo`) from the command line still works despite it not being in the list of ""available"" build types.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1403,20052937,2014-11-08T17:38:34Z,src/nvim/version_defs.h,"@@ -30,6 +30,12 @@ #ifndef NVIM_VERSION_COMMIT #define NVIM_VERSION_COMMIT #endif+#ifndef NVIM_VERSION_CFLAGS+#define NVIM_VERSION_CFLAGS","I think we should either show a ""?"" to positively indicate that the information wasn't passed, or don't show the message at all (wrap the `MSG(version_cflags);` in a `#ifdef NVIM_VERSION_CFLAGS`).Otherwise we get useless blank ""Build type: "" and ""Compilation: "" messages in the version output.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1446,20110747,2014-11-10T20:38:06Z,src/nvim/log.h,"@@ -26,7 +26,7 @@ // MIN_LOG_LEVEL can be defined during compilation to adjust the desired level // of logging. INFO_LOG_LEVEL is used by default. #ifndef MIN_LOG_LEVEL-#  define MIN_LOG_LEVEL INFO_LOG_LEVEL+#  define MIN_LOG_LEVEL DEBUG_LOG_LEVEL",I assume this is temporary. Did defining it at command line not work?,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1446,20112352,2014-11-10T21:02:14Z,src/nvim/msgpack_rpc/channel.c,"@@ -425,8 +425,9 @@ static void handle_request(Channel *channel, msgpack_object *request)   FUNC_ATTR_NONNULL_ALL {   uint64_t request_id;+  bool is_notification;   Error error = ERROR_INIT;-  msgpack_rpc_validate(&request_id, request, &error);+  msgpack_rpc_validate(&request_id, request, &is_notification, &error);","No. According to the [msgpackrpc specs](https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md), a request must be in the form `[type, msgid, method, params]` and a notification in the form `[type, method, params]`.I intend to add a few helper functions to make the logic more obvious.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1454,20165048,2014-11-11T17:28:04Z,runtime/provider/clipboard/init.vim,"@@ -0,0 +1,30 @@+"" The clipboard provider uses shell commands to communicate with the clipboard.+"" The provider function will only be registered if one of the supported+"" commands are available.+let s:copy = ''+let s:paste = ''++if executable('pbcopy')+  let s:copy = 'pbcopy'+  let s:paste = 'pbpaste'+elseif executable('xsel')+  let s:copy = 'xsel -i -b'+  let s:paste = 'xsel -o -b'+elseif executable('xclip')+  let s:copy = 'xclip -i -selection clipboard'+  let s:paste = 'xclip -o -selection clipboard'+endif++if s:copy == ''+  finish+endif++function! s:Clipboard(method, args)+  if a:method == 'get'+    return systemlist(s:paste)+  else+    call systemlist(s:copy, a:args)+  endif+endfunction++call provide('clipboard', function('s:Clipboard'))","Can `provide()` be eliminated by using a more Vim-typical ""passive"", convention-based approach? What I mean is this:To provide `foo` and its methods, a provider is defined like so:```runtime/provider/foo.vim```When `has(""foo"")` is called, nvim sees that `provider/foo.vim` exists and then sources it. The methods are provided as `foo#bar` functions defined in `foo.vim`. For example, `provider/clipboard.vim`:``` vim"" provides clipboard 'paste'function! clipboard#get(...)  return systemlist(s:paste)endfunction""provides clipboard 'copy'function! clipboard#set(...)  call systemlist(s:copy, a:000)endfunction```Is there a reason the ""active"" approach of `provide()` is necessary instead of the ""passive"" approach? ",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1446,20193774,2014-11-12T00:44:24Z,src/nvim/msgpack_rpc/helpers.c,"@@ -369,6 +369,7 @@ void msgpack_rpc_serialize_response(uint64_t response_id,  void msgpack_rpc_validate(uint64_t *response_id,                           msgpack_object *req,+                          bool *notification,","Question is do we know it's a notification because the message type equals 2, or because the array size is 3? I've refactored it (again) to try and make the ambiguity more clear and use those helper functions instead of pointer math.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1454,20403643,2014-11-15T17:28:33Z,runtime/autoload/provider/clipboard.vim,"@@ -0,0 +1,39 @@+"" The clipboard provider uses shell commands to communicate with the clipboard.+"" The provider function will only be registered if one of the supported+"" commands are available.+let s:copy = ''+let s:paste = ''++if executable('pbcopy')+  let s:copy = 'pbcopy'+  let s:paste = 'pbpaste'+elseif executable('xsel')+  let s:copy = 'xsel -i -b'+  let s:paste = 'xsel -o -b'+elseif executable('xclip')+  let s:copy = 'xclip -i -selection clipboard'+  let s:paste = 'xclip -o -selection clipboard'+endif++if s:copy == ''+  finish",We should establish a habit of leaving hints for diagnostic purposes. Either `echom` a warning or add it to a list that can be printed. Probably just adding it to `:mes` is predictable and accessible.```echom 'provider: clipboard: no clipboard service found'```,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1454,20409559,2014-11-16T13:44:38Z,runtime/autoload/provider/clipboard.vim,"@@ -0,0 +1,39 @@+"" The clipboard provider uses shell commands to communicate with the clipboard.+"" The provider function will only be registered if one of the supported+"" commands are available.+let s:copy = ''+let s:paste = ''++if executable('pbcopy')+  let s:copy = 'pbcopy'+  let s:paste = 'pbpaste'+elseif executable('xsel')+  let s:copy = 'xsel -i -b'+  let s:paste = 'xsel -o -b'+elseif executable('xclip')+  let s:copy = 'xclip -i -selection clipboard'+  let s:paste = 'xclip -o -selection clipboard'+endif++if s:copy == ''+  finish","> echom 'provider: clipboard: no clipboard service found'Fully agreed, that will seriously lessen the amount of duplicate issues. One more thing: I would mention in that message that the user can get more information on how to setup providers with by doing `:h providers` or `:h provider-clipboard` or something like that.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1478,20476025,2014-11-17T23:59:00Z,src/nvim/eval.c,"@@ -16068,10 +16092,15 @@ void free_tv(typval_T *varp) void clear_tv(typval_T *varp) {   if (varp != NULL) {+    char_u *null_string = (char_u *)"""";     switch (varp->v_type) {     case VAR_FUNC:       func_unref(varp->vval.v_string);-    /*FALLTHROUGH*/+      if (varp->vval.v_string != null_string) {","I verified locally that this works, but I am baffled. Isn't it just comparing pointers? And is it platform independent? ",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1478,20489303,2014-11-18T07:36:04Z,src/nvim/eval.c,"@@ -16068,10 +16092,15 @@ void free_tv(typval_T *varp) void clear_tv(typval_T *varp) {   if (varp != NULL) {+    char_u *null_string = (char_u *)"""";     switch (varp->v_type) {     case VAR_FUNC:       func_unref(varp->vval.v_string);-    /*FALLTHROUGH*/+      if (varp->vval.v_string != null_string) {","String literals are by definition immutable. Then, there would be little gain in creating a different copy for each individual appearance of the same literal. So, all instances of the same literal end up pointing to the same location in the read-only data section of your object file. This is called interning strings. And it's why pointer comparison works here.Now, I thought this worked for every c compiler (and it does for most common ones), but as @ZyX-I has pointed out, there are some for which it doesn't.I said this was ugly. But what I wanted was a way to distinguish the non-allocated empty string assigned at 4127 from a possible allocated empty string, for which I wouldn't want to spare the call to free().I looked at eval.c code for a while, but I wasn't sure an allocated empty name wasn't possible for a function value. @ZyX-I Could you answer that, given your knowledge of eval.c?If we have the guarantee an allocated empty name is not possible, then we can replace that with something less surprising:`if (varp->vval.v_string && *varp->vval.v_string != NUL)`BTW, Would the first non-null check be needed? can vval.v_string be null there?",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1391,20497697,2014-11-18T10:45:14Z,src/nvim/diff.c,"@@ -767,15 +748,27 @@ void ex_diffupdate(exarg_T *eap)       continue;     } -    if (diff_write(buf, tmp_new) == FAIL) {","This will call down to `buf_write()`, which looks like it triggers autocmds.  Does it matter that we'll no longer be triggering those?  In particular, it looks like `FilterWritePre` and `FilterWritePost` will no longer be triggered.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1391,20527973,2014-11-18T18:52:58Z,src/nvim/diff.c,"@@ -786,24 +779,67 @@ void ex_diffupdate(exarg_T *eap)  theend:   free(tmp_orig);-  free(tmp_new);   free(tmp_diff); }  /// Make a diff between files ""tmp_orig"" and ""tmp_new"", results in ""tmp_diff"". /// /// @param tmp_orig-/// @param tmp_new+/// @param cmp      The text of the file to compare with `tmp_orig`.+/// @param cmp_len  The length of `cmp`. /// @param tmp_diff-static void diff_file(char_u *tmp_orig, char_u *tmp_new, char_u *tmp_diff)+static char_u * diff_file(char_u *tmp_orig, const char *cmp, size_t cmp_len,+                          size_t *diff_len) {   if (*p_dex != NUL) {+    // Resort to old implementation for 'diffexpr'.+    // To store the output from v:fname_out.+    DynamicBuffer db = DYNAMIC_BUFFER_INIT;+     // Use 'diffexpr' to generate the diff file.","See `:help 'diffexpr'`. Not wanting to be redundant, I suppose I lost out on clarity here.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1494,20565122,2014-11-19T09:39:59Z,cmake/RunTests.cmake,"@@ -17,8 +17,13 @@ execute_process(   COMMAND ${BUSTED_PRG} -v -o ${BUSTED_OUTPUT_TYPE}     --lpath=${BUILD_DIR}/?.lua ${TEST_PATH}   WORKING_DIRECTORY ${WORKING_DIR}+  ERROR_VARIABLE err   RESULT_VARIABLE res) +if(err)","Do you actually want to key off of `res` here and not show the output at all unless there was an error?  I can honestly go either way on it.  We might accidentally hide a useful warning if we do.  OTOH, we're still displaying useless information most of the time.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/1494,20565826,2014-11-19T09:57:45Z,cmake/RunTests.cmake,"@@ -17,8 +17,13 @@ execute_process(   COMMAND ${BUSTED_PRG} -v -o ${BUSTED_OUTPUT_TYPE}     --lpath=${BUILD_DIR}/?.lua ${TEST_PATH}   WORKING_DIRECTORY ${WORKING_DIR}+  ERROR_VARIABLE err   RESULT_VARIABLE res) +if(err)","I'd say hide it unless we fail, it is pretty hard to figure which or how the test caused those messages anyway.",
340100,lslah,https://api.github.com/repos/neovim/neovim/pulls/1494,20571438,2014-11-19T12:17:43Z,cmake/RunTests.cmake,"@@ -17,8 +17,13 @@ execute_process(   COMMAND ${BUSTED_PRG} -v -o ${BUSTED_OUTPUT_TYPE}     --lpath=${BUILD_DIR}/?.lua ${TEST_PATH}   WORKING_DIRECTORY ${WORKING_DIR}+  ERROR_VARIABLE err   RESULT_VARIABLE res) +if(err)","It happens [here](https://github.com/neovim/neovim/blob/master/src/nvim/buffer.c#L1799) and is caused be [these unit tests](https://github.com/neovim/neovim/blob/master/test/unit/buffer_spec.lua#L157-L204) with `eq(-1, ...)`.",
137576,peterhajas,https://api.github.com/repos/neovim/neovim/pulls/1491,20633109,2014-11-20T08:45:42Z,runtime/doc/autocmd.txt,"@@ -1003,8 +1003,8 @@ The pattern is interpreted like mostly used in file names: 	[^ch]   match any character but 'c' and 'h'  Note that for all systems the '/' character is used for path separator (even-MS-DOS and OS/2).  This was done because the backslash is difficult to use-in a pattern and to make the autocommands portable across different systems.+MS-DOS2). This was done because the backslash is difficult to use in a pattern","Good catch, fixed. I remember reading that and thinking it was yet another obscure platform heh.On November 20, 2014 2:05:47 AM EST, Peter Hajas notifications@github.com wrote:> > @@ -1003,8 +1003,8 @@ The pattern is interpreted like mostly used in> > file names:> >      [^ch]   match any character but 'c' and 'h'> > > >  Note that for all systems the '/' character is used for path> > separator (even> > -MS-DOS and OS/2).  This was done because the backslash is difficult> > to use> > -in a pattern and to make the autocommands portable across different> > systems.> > +MS-DOS2). This was done because the backslash is difficult to use in> > a pattern> > Potential typo here - MS-DOS2?> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1491/files#r20630334",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1526,20760040,2014-11-22T21:36:10Z,src/nvim/memory.c,"@@ -102,10 +102,14 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET {-  void *ret = count && size ? calloc(count, size) : calloc(1, 1);+  bool nonzero = count && size;+  count = nonzero ? count : 1;","I think reassigning argument values is something we want to avoid. In fact, can't we make the parameters `const`? Or does that conflict with the contract of the standard `calloc`?",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1526,20760286,2014-11-22T22:18:15Z,src/nvim/memory.c,"@@ -102,10 +102,14 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET {-  void *ret = count && size ? calloc(count, size) : calloc(1, 1);+  bool nonzero = count && size;+  count = nonzero ? count : 1;","> I think reassigning argument values is something we want to avoid.It's just that usually the names of the function arguments are just right, and thinking of other names or even using others can be confusing. The only hard things in computer science being caching and naming things... But I understand your arguments and I sympathise. It's ok for me.> In fact, can't we make the parameters const? Or does that conflict with the contract of the standard calloc?While we could do that, it would increase the size of function prototypes by a lot for not real gain for the caller. I personally don't like seeing it. Also for consistency then this should happen over the entire codebase, the policy being that arguments are never mutated.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1526,20761778,2014-11-23T03:27:39Z,src/nvim/memory.c,"@@ -102,10 +102,14 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET {-  void *ret = count && size ? calloc(count, size) : calloc(1, 1);+  bool nonzero = count && size;+  count = nonzero ? count : 1;","Ok, let's forget it. I missed the last similar discussion.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1526,20763464,2014-11-23T10:27:11Z,src/nvim/memory.c,"@@ -102,10 +102,14 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET","Is it safe to change the allocation parameters if we use `FUNC_ATTR_ALLOC_SIZE_PROD(1, 2)`?",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1526,20763540,2014-11-23T10:40:00Z,src/nvim/memory.c,"@@ -102,10 +102,14 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET","I wondered the same some time ago. Note, though, that this has been working a long time without problems (I mean, this PR doesn't change that, it was already so).But going back to your question, I think the following:- Regarding executing code at runtime, function attribute doesn't affect. Allocation remembers its size, and free will act consequently.- Function attribute should affect only in static analysis, if it detects we try to access more memory than declared as allocated. Then, the only case where we change params is if one of them is 0. And in that case, we shouldn't dereference the returned pointer in any case. So, if we do dereference it, and analysis warns us because accessing more than theoretically allocated size (0), it would in fact be signaling something we shouldn't be doing.So, I see no harm in that.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1526,20777338,2014-11-24T08:35:10Z,src/nvim/memory.c,"@@ -102,10 +102,12 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET {-  void *ret = count && size ? calloc(count, size) : calloc(1, 1);+  size_t real_count = count && size ? count : 1;+  size_t real_size = count && size ? size : 1;","My first option here was `effective_size` / `effective_count`, but it was a bit long, so I opted for `real_size` / `real_count`. `allocated_size` / `allocated_count` was another option.To me, any of those are better because they introduce a clear concept. There is a ""requested"" size and a ""real / effective / allocated"" size. The fact that difference is being 1 or something else is secondary to that concept. Under this considerations:`calloc(real_size, real_count)`reads better to me than`calloc(size_or_1, count_or_1)`But this kind of things are very subjective.I don't have problems to changing names to whatever agreed.Note that these are very short functions, perfectly understandable anyway.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1526,20784781,2014-11-24T11:38:25Z,src/nvim/memory.c,"@@ -102,10 +102,12 @@ void *xmalloc(size_t size) void *xcalloc(size_t count, size_t size)   FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2) FUNC_ATTR_NONNULL_RET {-  void *ret = count && size ? calloc(count, size) : calloc(1, 1);+  size_t real_count = count && size ? count : 1;+  size_t real_size = count && size ? size : 1;","On November 24, 2014 11:35:15 AM EAT, ""Eliseo Mart��nez"" notifications@github.com wrote:> > @@ -102,10 +102,12 @@ void *xmalloc(size_t size)> >  void *xcalloc(size_t count, size_t size)> >    FUNC_ATTR_MALLOC FUNC_ATTR_ALLOC_SIZE_PROD(1, 2)> > FUNC_ATTR_NONNULL_RET> >  {> > -  void *ret = count && size ? calloc(count, size) : calloc(1, 1);> > -  size_t real_count = count && size ? count : 1;> > -  size_t real_size = count && size ? size : 1;> > My first option here was `effective_size` / `effective_count`, but it> was a bit long, so I opted for `real_size` / `real_count`.> `allocated_size` / `allocated_count` was another option.""Allocated"" variant was the first thing I thought about when saw previous message. _or_1 looks rather ugly.> To me, any of those are better because they introduce a clear concept.> There is a ""requested"" size and a ""real / effective / allocated"" size.> The fact that difference is being 1 or something else is secondary to> that concept. Under this considerations:> `calloc(real_size, real_count)`> reads better to me than> `calloc(size_or_1, count_or_1)`> > But this kind of things are very subjective.> I don't have problems to changing names to whatever agreed.> Note that these are very short functions, perfectly understandable> anyway.> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1526/files#r20777338",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/1182,20829502,2014-11-24T22:52:38Z,runtime/autoload/provider/clipboard.vim,"@@ -1,42 +1,53 @@ "" The clipboard provider uses shell commands to communicate with the clipboard. "" The provider function will only be registered if one of the supported "" commands are available.-let s:copy = ''-let s:paste = ''+let s:copy = {}+let s:paste = {}  function! s:try_cmd(cmd, ...)-  let out = a:0 ? systemlist(a:cmd, a:1) : systemlist(a:cmd)+  let out = a:0 ? system(a:cmd, a:1) : system(a:cmd)","In my quick test: neither does `xsel` (nor most other X apps), but `xclip` actually does, so we should also reorder these. Unfortunately `systemlist` throws away the final newline (needed to distinguish linewise/charwise selection), but I suppose it could learn the `keepempty` option of `split()`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1541,20835196,2014-11-25T00:41:10Z,runtime/autoload/remote/host.vim,"@@ -246,3 +246,17 @@ endfunction  call remote#host#Register('python', function('s:RequirePythonHost')) "" }}}+++function! s:GoHost(name)+  try+    let channel_id = rpcstart($HOME.""/.nvim/plugins/go/plugin_host"")",Should be `rplugin/` I think. See:- https://github.com/neovim/neovim/pull/1515- https://github.com/neovim/neovim/blob/2c29b20af767bd7ebebeb41da14df4d66a19d5a0/runtime/doc/remote_plugin.txt#L97- https://github.com/neovim/neovim/blob/bcab2905d83c4b6c0def50462752b1beb5548f10/runtime/autoload/remote/host.vim#L123,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1541,20835497,2014-11-25T00:46:41Z,runtime/autoload/remote/host.vim,"@@ -246,3 +246,17 @@ endfunction  call remote#host#Register('python', function('s:RequirePythonHost')) "" }}}+++function! s:GoHost(name)+  try+    let channel_id = rpcstart($HOME.""/.nvim/plugins/go/plugin_host"")",But https://github.com/myitcv/neovim-editor/blob/go-plugin-support/runtime/autoload/remote/host.vim#L122-L123 already should take care of this I think. So the actual path would look like `rplugin/go/foo.go`. Or you can add `plugin_host` to [`s:plugin_patterns`](https://github.com/myitcv/neovim-editor/blob/go-plugin-support/runtime/autoload/remote/host.vim#L2-L3).,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1541,20854818,2014-11-25T10:43:29Z,runtime/autoload/remote/host.vim,"@@ -246,3 +247,17 @@ endfunction  call remote#host#Register('python', function('s:RequirePythonHost')) "" }}}+++function! s:GoHost(name)","FWIW, this is the function you can use to compile the host passing a list of plugins, similarly to RequirePythonHOst",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1541,20854867,2014-11-25T10:44:54Z,runtime/autoload/remote/host.vim,"@@ -246,3 +247,17 @@ endfunction  call remote#host#Register('python', function('s:RequirePythonHost')) "" }}}+++function! s:GoHost(name)+  try+    let channel_id = rpcstart($HOME.""/.nvim/rplugin/go/plugin_host_go"")+    call rpcrequest(channel_id, 'plugin_load')","This no longer is how the python host does it, I've refactored to take a list of plugins as program arguments. This new approach is better because you can use the plugin list to compile a binary and then spawn it separately",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1541,20855270,2014-11-25T10:54:56Z,runtime/autoload/remote/host.vim,"@@ -246,3 +247,17 @@ endfunction  call remote#host#Register('python', function('s:RequirePythonHost')) "" }}}+++function! s:GoHost(name)+  try+    let channel_id = rpcstart($HOME.""/.nvim/rplugin/go/plugin_host_go"")+    call rpcrequest(channel_id, 'plugin_load')","> Thanks @tarruda - to be honest I'd spent more time on the Go side... will look more into your most recent Python integration for the best practice.Some of these changes were performed to make it simpler having hosts for languages that don't support dynamic code loading such as go. The idea is that nvim collects a list of plugin paths, and when the host is required it will call the Require_Host function, which can get the list of plugins and pass to the host's program as arguments. Eventually it will be possible to dynamically change this list of plugins, but that will make Nvim restart the host. by calling it's ""shutdown"" method and invoking ""Require_Host"" againIn a few words: You no longer need to worry about dynamic plugin loading: Just take the list of plugins as program arguments, and handle a 'shutdown' msgpack-rpc method exit the host",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1544,20859574,2014-11-25T12:35:36Z,cmake/RunTests.cmake,"@@ -20,5 +20,5 @@ execute_process(   RESULT_VARIABLE res)  if(NOT res EQUAL 0)-  message(FATAL_ERROR ""Running ${TEST_TYPE} tests failed."")+  message(FATAL_ERROR ""Running ${TEST_TYPE} tests failed with error: ${res}."")","> RESULT_VARIABLE>     The variable will be set to contain the result of running the processes. This will be an integer return code from the last child or a string describing an error condition.ret is not only the return code? Never would have guessed.. We should try that for GenerateHelptags as well, when that fails there is usually no error message at all.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1436,20882535,2014-11-25T18:16:01Z,contrib/localvimrc/vimrc.local,"@@ -0,0 +1,10 @@++let s:srcroot = fnamemodify(expand(""<afile>"", 1), "":p:h:h:h"")++"" Add to 'path' so that :find always searches from the source root.+exe 'set path+='.s:srcroot.'/**'++augroup LOCAL_SETUP+  autocmd!+  autocmd FileType c setlocal comments=:///,://","Quick test:```mkdir testcd testgit clone https://github.com/embear/vim-localvimrcecho $'throw &filetype' > .lvimrcecho $'set nocompatible rtp=$VIMRUNTIME,vim-localvimrc\nfiletype plugin indent on' > vimrcvim -u vimrc -i NONE a.py```that this is also the case for the referenced plugin: after confirming that I do want to load local vimrc I get ���E605: Exception not caught: python���. If I edit a new file (e.g. type `:e b.py<CR>y`) the message is the same. Thus you must not use FileType event and suggest that plugin at once.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1436,20907242,2014-11-26T00:00:23Z,contrib/localvimrc/vimrc.local,"@@ -0,0 +1,10 @@++let s:srcroot = fnamemodify(expand(""<afile>"", 1), "":p:h:h:h"")++"" Add to 'path' so that :find always searches from the source root.+exe 'set path+='.s:srcroot.'/**'++augroup LOCAL_SETUP+  autocmd!+  autocmd FileType c setlocal comments=:///,://","Thanks, I definitely left this PR in a bad state. I have some local changes that I've been fixing up and will update soon.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1580,21060518,2014-11-30T14:18:39Z,src/nvim/file_search.c,"@@ -375,8 +375,9 @@ vim_findfile_init (       search_ctx->ffsc_stopdirs_v = ptr;       walker = vim_strchr(walker, ';');       if (walker) {+        assert(walker - helper >= 0);",I think it's a good pattern to have an assertion before such a cast; you can see that it's safe at a glance. Maybe similar to having `//FALLTHROUGH` comments in a `switch`/`case` without a `break`.,
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1580,21060563,2014-11-30T14:25:41Z,src/nvim/ex_eval.c,"@@ -386,21 +386,19 @@ int do_intthrow(struct condstack *cstack) char_u *get_exception_string(void *value, int type, char_u *cmdname, int *should_free) {   char_u      *ret, *mesg;-  int cmdlen;   char_u      *p, *val;    if (type == ET_ERROR) {     *should_free = FALSE;     mesg = ((struct msglist *)value)->throw_msg;     if (cmdname != NULL && *cmdname != NUL) {-      cmdlen = (int)STRLEN(cmdname);-      ret = vim_strnsave((char_u *)""Vim("",-          4 + cmdlen + 2 + (int)STRLEN(mesg));+      size_t cmdlen = STRLEN(cmdname);+      ret = vim_strnsave((char_u *)""Vim("", 4 + cmdlen + 2 + STRLEN(mesg));       STRCPY(&ret[4], cmdname);       STRCPY(&ret[4 + cmdlen], ""):"");       val = ret + 4 + cmdlen + 2;","In fact, this entire thing might be written differently. It appears to be some concatenation:``` cchar *s = xmalloc(4 + strlen(cmdname) + 2 + strlen(mesg));val = stpcpy(""):"", stpcpy(cmdname, stpcpy(s, ""Vim("")));```Untested, just some scribbling. The only thing that bothers me is that it looks inverted. Can be solved by:``` cchar *s = xmalloc(4 + strlen(cmdname) + 2 + strlen(mesg));val = stpcpy(s, ""Vim(""));val = stpcpy(val, cmdname);val = stpcpy(val, ""):"");```Which is a bit longer but better illustrates what's going on.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1344,21063921,2014-11-30T22:03:41Z,src/nvim/os/fs.c,"@@ -476,3 +476,16 @@ bool os_fileid_equal_fileinfo(const FileID *file_id,          && file_id->device_id == file_info->stat.st_dev; } ++/// Set access time and modification time of a file+///+/// @return `0` on success, a libuv error code on failure.+int os_utime(const char *path, uv_timespec_t ts_atim, uv_timespec_t ts_mtim)","> Since this function is only use by file info structs, I think it would make more sense to write os_fileinfo_utime()It's not just for use by `fileinfo`, just that it can only be exposed by `fileinfo`. But I can see your reasoning. I like the parallelism with `utime()/utimes()` on the UNIX side though, and `os_utime()` looks more concise (it's a platform independent `utime()`).I agree about the `uv_timespec_ts` though. They look out of place. But I wouldn't want the function to take `double`'s either, in my opinion. Floating point is just the wrong representation for time (https://randomascii.wordpress.com/2012/02/13/dont-store-that-in-a-float/). The should take 64-bit integers representing nanoseconds.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/1586,21077764,2014-12-01T09:27:36Z,src/nvim/CMakeLists.txt,"@@ -197,6 +197,15 @@ list(APPEND NVIM_LINK_LIBRARIES     m     ${CMAKE_THREAD_LIBS_INIT}) +if(DEFINED ENV{MAKE_LIB})+  set(CMAKE_POSITION_INDEPENDENT_CODE ON)+  set(ENV{SKIP_EXEC} ON)+  add_definitions(-DMAKE_LIB)+  add_library(nvim STATIC ${NEOVIM_GENERATED_SOURCES} ${NEOVIM_SOURCES}","I wouldn't name this nvim, I might want to build both the library and the executable.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1587,21081950,2014-12-01T10:58:44Z,.ci/clang-asan.sh,"@@ -25,18 +25,16 @@ symbolizer=/usr/local/clang-$clang_version/bin/llvm-symbolizer  setup_prebuilt_deps x64 -export SANITIZE=1 export ASAN_SYMBOLIZER_PATH=$symbolizer export ASAN_OPTIONS=""detect_leaks=1:log_path=$tmpdir/asan"" export TSAN_OPTIONS=""external_symbolizer_path=$symbolizer:log_path=$tmpdir/tsan"" -export SKIP_UNITTEST=1","Historically, there were issues running unittests when compiled with clang's Address Sanitizer.  Is this no longer the case?",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1587,21112555,2014-12-01T19:24:05Z,.ci/clang-asan.sh,"@@ -25,18 +25,16 @@ symbolizer=/usr/local/clang-$clang_version/bin/llvm-symbolizer  setup_prebuilt_deps x64 -export SANITIZE=1 export ASAN_SYMBOLIZER_PATH=$symbolizer export ASAN_OPTIONS=""detect_leaks=1:log_path=$tmpdir/asan"" export TSAN_OPTIONS=""external_symbolizer_path=$symbolizer:log_path=$tmpdir/tsan"" -export SKIP_UNITTEST=1","> Historically, there were issues running unittests when compiled with clang's Address Sanitizer. Is this no longer the case?Supposedly still the case, as they still run with the LuaJIT ffi :).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1589,21112741,2014-12-01T19:26:24Z,src/nvim/strings.c,"@@ -237,13 +237,9 @@ char_u *vim_strnsave_up(const char_u *string, size_t len) void vim_strup(char_u *p)   FUNC_ATTR_NONNULL_ALL {-  char_u  *p2;   char_u c;--  if (p != NULL) {-    p2 = p;-    while ((c = *p2) != NUL)-      *p2++ = (char_u)((c < 'a' || c > 'z') ? c : c - 0x20);+  while ((c = *p) != NUL) {+    *p++ = (char_u)(c < 'a' || c > 'z' ? c : c - 0x20);","It kind of depends. If the branch is about 50/50 change, then the ternary will likely be faster as it will likely be converted into a conditional move (CMOV) on x86. If the distribution is more skewed though, a branch is faster. That said, even an if-check can (and often does) compile down to a CMOV if gcc/clang feel up to it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1567,21161412,2014-12-02T14:32:24Z,test/functional/shell/viml_system_spec.lua,"@@ -188,6 +188,18 @@ describe('systemlist()', function()     end)   end) +  describe('when keepempty option is', function()+    it('0, ignores trailing newline', function()+      eq({'aa','bb'}, eval('systemlist(""cat"",[""aa"",""bb""],0)'))+      eq({'aa','bb'}, eval('systemlist(""cat"",[""aa"",""bb"",""""],0)'))",Is there a test for empty lines in the middle?,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1617,21403249,2014-12-05T21:56:57Z,test/unit/tempfile_spec.lua,"@@ -1,60 +1,151 @@ local lfs = require 'lfs'+ local helpers = require 'test.unit.helpers'+local cimport, vim_init, ffi, to_cstr =+  helpers.cimport, helpers.vim_init, helpers.ffi, helpers.to_cstr  local os = helpers.cimport './src/nvim/os/os.h'-local tempfile = helpers.cimport './src/nvim/tempfile.h'+local os_isdir, os_file_is_writable, os_file_exists =+  os.os_isdir, os.os_file_is_writable, os.os_file_exists -helpers.vim_init()+local is_dir = function(x) return os_isdir(x) end -describe('tempfile related functions', function()-  after_each(function()-    tempfile.vim_deltempdir()-  end)+-- os_file_is_writable returns 2 for a directory which we have rights+-- to write into.+local is_writable = function(x) return os_file_is_writable(to_cstr(x)) == 2 end -  local vim_gettempdir = function()-    return helpers.ffi.string(tempfile.vim_gettempdir())+local is_empty = function(x)+  local r = true+  for f in lfs.dir(x) do+    r = r and (f == '.' or f == '..')   end+  return r+end++local file_exists = function(x) return os_file_exists(x) end++local path_contains_dir = function(path, dir)+  return (path ~= nil) and (path:find(""^"" .. tostring(dir) .. ""[^/]*$"") ~= nil)+end++local dir_of_path = function(path)+  return path:match('(.-)[^/]+$') or ''+end++local ok = function(x) return assert.True(x) end+local notok = function(x) return assert.False(x) end","See `helpers.eq` and `neq`. I don't think we have an equivalent for `assert.True/False`, and that could be generally useful, though I don't think `ok`/`notok` are good names for it. (If a return value of `false` means the test passed, `notok()` would imply that's a bad thing.)",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1617,21403701,2014-12-05T22:04:42Z,test/unit/tempfile_spec.lua,"@@ -1,60 +1,151 @@ local lfs = require 'lfs'+ local helpers = require 'test.unit.helpers'+local cimport, vim_init, ffi, to_cstr =+  helpers.cimport, helpers.vim_init, helpers.ffi, helpers.to_cstr  local os = helpers.cimport './src/nvim/os/os.h'-local tempfile = helpers.cimport './src/nvim/tempfile.h'+local os_isdir, os_file_is_writable, os_file_exists =+  os.os_isdir, os.os_file_is_writable, os.os_file_exists -helpers.vim_init()+local is_dir = function(x) return os_isdir(x) end -describe('tempfile related functions', function()-  after_each(function()-    tempfile.vim_deltempdir()-  end)+-- os_file_is_writable returns 2 for a directory which we have rights+-- to write into.+local is_writable = function(x) return os_file_is_writable(to_cstr(x)) == 2 end -  local vim_gettempdir = function()-    return helpers.ffi.string(tempfile.vim_gettempdir())+local is_empty = function(x)+  local r = true+  for f in lfs.dir(x) do+    r = r and (f == '.' or f == '..')   end+  return r+end++local file_exists = function(x) return os_file_exists(x) end++local path_contains_dir = function(path, dir)+  return (path ~= nil) and (path:find(""^"" .. tostring(dir) .. ""[^/]*$"") ~= nil)+end++local dir_of_path = function(path)+  return path:match('(.-)[^/]+$') or ''+end++local ok = function(x) return assert.True(x) end+local notok = function(x) return assert.False(x) end++local tempfile = helpers.cimport './src/nvim/tempfile.h'+local vim_gettempdir = function() return ffi.string(tempfile.vim_gettempdir()) end+local vim_tempname = function() return ffi.string(tempfile.vim_tempname()) end+local vim_deltempdir = function() return tempfile.vim_deltempdir() end++vim_init()++describe('tempfile module:', function()++  after_each(function() vim_deltempdir() end)    describe('vim_gettempdir', function()-    it('returns path to Neovim own temp directory', function()++    it('generates directory name to a writable, empty directory on first call', function()       local dir = vim_gettempdir()-      assert.True(dir ~= nil and dir:len() > 0)-      -- os_file_is_writable returns 2 for a directory which we have rights-      -- to write into.-      assert.equals(os.os_file_is_writable(helpers.to_cstr(dir)), 2)-      for entry in lfs.dir(dir) do-        assert.True(entry == '.' or entry == '..')-      end+      ok(dir ~= nil and dir:len() > 0)+      ok((is_dir(dir)) and (is_writable(dir)) and (is_empty(dir)))     end) -    it('returns the same directory on each call', function()-      local dir1 = vim_gettempdir()-      local dir2 = vim_gettempdir()-      assert.equals(dir1, dir2)+    it('generates a directory which can be later deleted', function()+      local dir = vim_gettempdir()+      ok(is_dir(dir))+      vim_deltempdir()+      notok(is_dir(dir))+    end)++    context('called successively', function()++      it('generates the same directory name', function()+        local dir1, dir2+        dir1 = vim_gettempdir()+        dir2 = vim_gettempdir()","Stylistically, the declarations should not be separate from initialization. http://neovim.org/develop/style-guide.xml#Local_Variables",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1622,21434865,2014-12-08T05:03:39Z,src/nvim/option.c,"@@ -4925,16 +4922,8 @@ set_bool_option (   if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)     *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value; -  /*-   * Handle side effects of changing a bool option.-   */--  /* 'compatible' */-  if ((int *)varp == &p_cp) {-    compatible_set();-  }","So, after looking around, the old order of operations appears to be:1. set_init12. compatible_set   - This only gets called for `-N` flag.3. vimrc_found   - This does something similar to compatible_set as mentioned in my other comment.4. set_bool_option",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1182,21436089,2014-12-08T06:00:50Z,src/nvim/ops.c,"@@ -5225,33 +5208,82 @@ static void free_register(struct yankreg *reg)   y_current = curr; } -static void copy_register(struct yankreg *dest, struct yankreg *src)-{-  free_register(dest);-  *dest = *src;-  dest->y_array = xcalloc(src->y_size, sizeof(uint8_t *));-  for (int j = 0; j < src->y_size; ++j) {-    dest->y_array[j] = (uint8_t *)xstrdup((char *)src->y_array[j]);+// return target register+static int adjust_clipboard_name(int *name) {+  if (*name == '*' || *name == '+') {+    if(!eval_has_provider(""clipboard"")) {+      EMSG(""Clipboard provider is not available"");","```EMSG(""clipboard: provider is not available"");```This is consistent with existing messages, and the ""context"" pattern that is typical of shell programs is valuable (where the context is provided with one or more prefixes followed by a colon).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1182,21437179,2014-12-08T06:52:51Z,test/functional/clipboard/clipboard_provider_spec.lua,"@@ -0,0 +1,126 @@+-- Test clipboard provider support","These are good tests. Should we also test `setreg()` and `getreg()`?- `getreg('+', 1, 0)` should return NUL _and_ newlines as newlines- `getreg('+', 1, 1)` should return NUL as newlines, and newlines as separate list items- `setreg('+', ""foo"", 'c')`, then `""+p` should paste ""foo"" characterwise (into the current line without adding a new line)- `setreg('+', ""foo"", 'l')`, then `""+p` should paste ""foo"" linewise (creates a new line containing only ""foo"")- `setreg('+', ""foo\nbar"", 'b')`, then `""+p` should paste ""foo\nbar"" blockwise - I think `setreg()` also accepts a list, but currently the builds I have don't seem to like it.Note: it may be convenient to know that you can change the register type without changing its contents, by appending an empty string. E.g., to change the type to ""linewise"", use ""al"" (the ""a"" flag means ""append""):```:call setreg('+', '', 'al')```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/1182,21470726,2014-12-08T17:54:57Z,src/nvim/ops.c,"@@ -5225,33 +5208,82 @@ static void free_register(struct yankreg *reg)   y_current = curr; } -static void copy_register(struct yankreg *dest, struct yankreg *src)-{-  free_register(dest);-  *dest = *src;-  dest->y_array = xcalloc(src->y_size, sizeof(uint8_t *));-  for (int j = 0; j < src->y_size; ++j) {-    dest->y_array[j] = (uint8_t *)xstrdup((char *)src->y_array[j]);+// return target register+static int adjust_clipboard_name(int *name) {+  if (*name == '*' || *name == '+') {+    if(!eval_has_provider(""clipboard"")) {+      EMSG(""Clipboard provider is not available"");"," :+1: will also update ""invalid data""  below to the same style.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1605,21502832,2014-12-09T01:55:01Z,src/nvim/ui.c,"@@ -98,7 +156,373 @@ int ui_get_shellsize(void)  */ void ui_cursor_shape(void) {-  term_cursor_shape();+  if (abstract_ui) {+    ui_change_mode();+  } else {+    term_cursor_shape();+    conceal_check_cursur_line();+  }+}++void ui_resize(int width, int height)+{+  sr.top = 0;+  sr.bot = height - 1;+  sr.left = 0;+  sr.right = width - 1;+  UI_CALL(resize, width, height);+}++void ui_cursor_on(void)+{+  if (!cursor_enabled) {+    UI_CALL(cursor_on);+    cursor_enabled = true;+  }+}++void ui_cursor_off(void)+{+  if (full_screen) {+    if (cursor_enabled) {+      UI_CALL(cursor_off);+    }+    cursor_enabled = false;+  }+}++void ui_mouse_on(void)+{+  if (abstract_ui) {+    UI_CALL(mouse_on);+  } else {+    mch_setmouse(true);+  }+}++void ui_mouse_off(void)+{+  if (abstract_ui) {+    UI_CALL(mouse_off);+  } else {+    mch_setmouse(false);+  }+}++// Notify that the current mode has changed. Can be used to change cursor+// shape, for example.+void ui_change_mode(void)+{+  static int showing_insert_mode = MAYBE;++  if (!full_screen)+    return;++  if (State & INSERT) {+    if (showing_insert_mode != TRUE) {+      UI_CALL(insert_mode);+    }+    showing_insert_mode = TRUE;+  } else {+    if (showing_insert_mode != FALSE) {+      UI_CALL(normal_mode);+    }+    showing_insert_mode = FALSE;+  }   conceal_check_cursur_line(); } +void ui_attach(UI *ui)+{+  if (ui_count == MAX_UI_COUNT) {+    abort();+  }++  uis[ui_count++] = ui;+  resized(ui);+}++void ui_detach(UI *ui)+{+  size_t shift_index = MAX_UI_COUNT;++  // Find the index that will be removed+  for (size_t i = 0; i < ui_count; i++) {+    if (uis[i] == ui) {+      shift_index = i;+      break;+    }+  }++  if (shift_index == MAX_UI_COUNT) {+    abort();+  }++  // Shift UIs at ""shift_index""+  while (shift_index < ui_count - 1) {+    uis[shift_index] = uis[shift_index + 1];+    shift_index++;+  }++  ui_count--;++  if (ui->width == width || ui->height == height) {+    // It is possible that the UI being detached had the smallest screen,+    // so check for the new minimum dimensions+    width = height = INT_MAX;+    for (size_t i = 0; i < ui_count; i++) {+      check_dimensions(uis[i]);+    }+  }++  if (ui_count) {+    screen_resize(width, height, true);+  }+}++static void highlight_start(int mask)+{+  if (mask > HL_ALL) {+    // attribute code+    current_highlight_mask = mask;+  } else {+    // attribute mask+    current_highlight_mask |= mask;+  }++  if (!ui_count) {+    return;+  }++  set_highlight_args(current_highlight_mask, &current_attrs);+  UI_CALL(highlight_set, current_attrs);+}++static void highlight_stop(int mask)+{+  if (mask > HL_ALL) {+    // attribute code+    current_highlight_mask = HL_NORMAL;+  } else {+    // attribute mask+    current_highlight_mask &= ~mask;+  }++  set_highlight_args(current_highlight_mask, &current_attrs);+  UI_CALL(highlight_set, current_attrs);+}++static void set_highlight_args(int mask, HlAttrs *attrs)+{+  attrentry_T *aep = NULL;+  attrs->foreground = -1;+  attrs->background = -1;++  if (mask > HL_ALL) {+    aep = syn_cterm_attr2entry(mask);+    mask = aep ? aep->ae_attr : 0;+  }++  attrs->bold = mask & HL_BOLD;+  attrs->standout = mask & HL_STANDOUT;+  attrs->underline = mask & HL_UNDERLINE;+  attrs->undercurl = mask & HL_UNDERCURL;+  attrs->italic = mask & HL_ITALIC;+  attrs->reverse = mask & HL_INVERSE;++  if (aep && aep->ae_u.cterm.fg_color+      && (cterm_normal_fg_color != aep->ae_u.cterm.fg_color)) {+    attrs->foreground = aep->ae_u.cterm.fg_color - 1;+  }++  if (aep && aep->ae_u.cterm.bg_color+      && (cterm_normal_bg_color != aep->ae_u.cterm.bg_color)) {+    attrs->background = aep->ae_u.cterm.bg_color - 1;+  }+}++static void parse_abstract_ui_codes(uint8_t *ptr, int len)+{+  int arg1 = 0, arg2 = 0;+  uint8_t *end = ptr + len, *p, c;+  bool update_cursor = false;++  while (ptr < end) {+    if (ptr < end - 1 && ptr[0] == ESC && ptr[1] == '|') {+      p = ptr + 2;++      if (VIM_ISDIGIT(*p)) {","I think this won't ever happen because I basically copied this loop from gui.c in vim upstream. In any case, ui_write will be removed eventually so this is all temporary(I will add direct calls to ui functions instead of writing termcap codes with out_str)",
4466737,DuncanvR,https://api.github.com/repos/neovim/neovim/pulls/1522,21566428,2014-12-09T22:01:05Z,src/nvim/normal.c,"@@ -443,10 +443,12 @@ normal_cmd (    * will terminate it. Finish_op tells us to finish the operation before    * returning this time (unless the operation was cancelled).    */-  c = finish_op;-  finish_op = (oap->op_type != OP_NOP);-  if (finish_op != c) {-    ui_cursor_shape();                  /* may show different cursor shape */+  {","I meant the `{` and `}` on lines 446 and 452; those are preceded by a comment (that was already there), not by a condition or loop. So as far as I can see, those braces can be removed and the block can be indented one level less.But I see how my statement was confusing, as the `if` statement hasn't been removed. The braces have been duplicated though, and that was what I meant.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1628,21572445,2014-12-09T23:27:36Z,runtime/doc/gui.txt,"@@ -779,9 +779,9 @@ from the main menu bar.  You must then use the |:popup| or |:tearoff| command to display it.  							*popup-menu*-In the Win32, GTK+, Motif, Athena and Photon GUI, you can define the-special menu ""PopUp"".  This is the menu that is displayed when the right mouse-button is pressed, if 'mousemodel' is set to popup or popup_setpos.+In the Win32, GTK+, Motif, and Athena GUI, you can define the special menu","In general we have a strict goal of platform parity. So this kind of platform listing generally should be removed. Sentence should be:> You can define the special menu ""PopUp"".",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1628,21575698,2014-12-10T00:29:57Z,runtime/doc/gui.txt,"@@ -25,8 +25,8 @@ Other GUI documentation:  First you must make sure you actually have a version of Vim with the GUI code included.  You can check this with the "":version"" command, it says ""with xxx-GUI"", where ""xxx"" is X11-Motif, X11-Athena, Photon, GTK, GTK2, etc., or-""MS-Windows 32 bit GUI version"".+GUI"", where ""xxx"" is X11-Motif, X11-Athena, GTK, GTK2, etc., or ""MS-Windows 32+bit GUI version"".","If you are worried about the temporary inaccuracy, well, the existence of `gui.txt` itself is inaccurate at the moment :) For now, we processed this chunk, I don't want to have to revisit it later.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1584,21575784,2014-12-10T00:31:33Z,test/functional/job/job_spec.lua,"@@ -81,6 +81,15 @@ describe('jobs', function()     eq({'notification', 'exit', {0}}, next_message())   end) +  it('will NOT hold data if third argument is nonzero', function()","""hold"" could be misunderstood (by me at least), should this be:> will NOT buffer data if third argument is nonzero",
259933,stevenyvr987,https://api.github.com/repos/neovim/neovim/pulls/1617,21637680,2014-12-10T21:13:30Z,test/unit/tempfile_spec.lua,"@@ -1,60 +1,151 @@ local lfs = require 'lfs'+ local helpers = require 'test.unit.helpers'+local cimport, vim_init, ffi, to_cstr =+  helpers.cimport, helpers.vim_init, helpers.ffi, helpers.to_cstr  local os = helpers.cimport './src/nvim/os/os.h'-local tempfile = helpers.cimport './src/nvim/tempfile.h'+local os_isdir, os_file_is_writable, os_file_exists =+  os.os_isdir, os.os_file_is_writable, os.os_file_exists -helpers.vim_init()+local is_dir = function(x) return os_isdir(x) end -describe('tempfile related functions', function()-  after_each(function()-    tempfile.vim_deltempdir()-  end)+-- os_file_is_writable returns 2 for a directory which we have rights+-- to write into.+local is_writable = function(x) return os_file_is_writable(to_cstr(x)) == 2 end -  local vim_gettempdir = function()-    return helpers.ffi.string(tempfile.vim_gettempdir())+local is_empty = function(x)+  local r = true+  for f in lfs.dir(x) do+    r = r and (f == '.' or f == '..')   end+  return r+end++local file_exists = function(x) return os_file_exists(x) end++local path_contains_dir = function(path, dir)+  return (path ~= nil) and (path:find(""^"" .. tostring(dir) .. ""[^/]*$"") ~= nil)+end++local dir_of_path = function(path)+  return path:match('(.-)[^/]+$') or ''+end++local ok = function(x) return assert.True(x) end+local notok = function(x) return assert.False(x) end++local tempfile = helpers.cimport './src/nvim/tempfile.h'+local vim_gettempdir = function() return ffi.string(tempfile.vim_gettempdir()) end+local vim_tempname = function() return ffi.string(tempfile.vim_tempname()) end+local vim_deltempdir = function() return tempfile.vim_deltempdir() end++vim_init()++describe('tempfile module:', function()++  after_each(function() vim_deltempdir() end)    describe('vim_gettempdir', function()-    it('returns path to Neovim own temp directory', function()++    it('generates directory name to a writable, empty directory on first call', function()       local dir = vim_gettempdir()-      assert.True(dir ~= nil and dir:len() > 0)-      -- os_file_is_writable returns 2 for a directory which we have rights-      -- to write into.-      assert.equals(os.os_file_is_writable(helpers.to_cstr(dir)), 2)-      for entry in lfs.dir(dir) do-        assert.True(entry == '.' or entry == '..')-      end+      ok(dir ~= nil and dir:len() > 0)+      ok((is_dir(dir)) and (is_writable(dir)) and (is_empty(dir)))     end) -    it('returns the same directory on each call', function()-      local dir1 = vim_gettempdir()-      local dir2 = vim_gettempdir()-      assert.equals(dir1, dir2)+    it('generates a directory which can be later deleted', function()+      local dir = vim_gettempdir()+      ok(is_dir(dir))+      vim_deltempdir()+      notok(is_dir(dir))+    end)++    context('called successively', function()++      it('generates the same directory name', function()+        local dir1, dir2+        dir1 = vim_gettempdir()+        dir2 = vim_gettempdir()","The style guide is for C code, but there is no similar guide for Lua code for the project. In Lua, local declarations are initialized to nil by default, but in C I believe there is no default initialization.Nevertheless, I've initialized all local vars for the unit test, which is possible.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1617,21702898,2014-12-11T19:38:03Z,test/unit/tempfile_spec.lua,"@@ -1,60 +1,147 @@+local cimport, vim_init, ffi, to_cstr, eq, neq = (function()+  local _ = require 'test.unit.helpers'+  return _.cimport, _.vim_init, _.ffi, _.to_cstr, _.eq, _.neq+end)()+ local lfs = require 'lfs'-local helpers = require 'test.unit.helpers' -local os = helpers.cimport './src/nvim/os/os.h'-local tempfile = helpers.cimport './src/nvim/tempfile.h'+local os = cimport './src/nvim/os/os.h' -helpers.vim_init()+-- is_dir('/a/b/') will return true if '/a/b/' is a directory name+local is_dir = function(x) return 'directory' == lfs.attributes(x, 'mode') end -describe('tempfile related functions', function()-  after_each(function()-    tempfile.vim_deltempdir()-  end)+-- os_file_is_writable returns 2 for a directory which we have rights+-- to write into.+local is_writable = function(x) return os.os_file_is_writable(to_cstr(x)) == 2 end -  local vim_gettempdir = function()-    return helpers.ffi.string(tempfile.vim_gettempdir())+-- is_empty('/a/b/') will return true if 'a/b/' is a directory linking only to itself and the parent dir+local is_empty = function(x)+  for f in lfs.dir(x) do+    if f ~= '.' and f ~= '..' then return false end   end+  return true+end++-- file_exists('/a/b/c') will return true if '/a/b/c' is an existing file+local file_exists = os.os_file_exists++-- path_contains_dir('/a/b/c', '/a/b/') will return true+local path_contains_dir = function(path, dir)+  return (path ~= nil) and (path:find(""^"" .. tostring(dir) .. ""[^/]*$"") ~= nil)+end++-- dir_of_path('/a/b/c') will return '/a/b/'+local dir_of_path = function(path)+  return path:match('(.-)[^/]+$') or ''+end++local ok = function(x) return assert.True(x) end++local tempfile = cimport './src/nvim/tempfile.h'+local vim_gettempdir = function() return ffi.string(tempfile.vim_gettempdir()) end+local vim_tempname = function() return ffi.string(tempfile.vim_tempname()) end+local vim_deltempdir = function() return tempfile.vim_deltempdir() end++vim_init()++describe('tempfile module:', function()++  after_each(function() vim_deltempdir() end)    describe('vim_gettempdir', function()-    it('returns path to Neovim own temp directory', function()++    it('generates directory name to a writable, empty directory on first call', function()+      local dir = vim_gettempdir()+      ok(dir ~= nil and dir:len() > 0)+      ok(is_dir(dir))+      ok(is_writable(dir))+      ok(is_empty(dir))+    end)++    it('generates a directory which can be later deleted', function()       local dir = vim_gettempdir()-      assert.True(dir ~= nil and dir:len() > 0)-      -- os_file_is_writable returns 2 for a directory which we have rights-      -- to write into.-      assert.equals(os.os_file_is_writable(helpers.to_cstr(dir)), 2)-      for entry in lfs.dir(dir) do-        assert.True(entry == '.' or entry == '..')-      end+      ok(is_dir(dir))+      vim_deltempdir()+      ok(not is_dir(dir))     end) -    it('returns the same directory on each call', function()-      local dir1 = vim_gettempdir()-      local dir2 = vim_gettempdir()-      assert.equals(dir1, dir2)+    context('called successively', function()++      it('generates the same directory name', function()+        local dir1 = vim_gettempdir()+        local dir2 = vim_gettempdir()+        ok(dir1 == dir2)+      end)++      it('interrupted by generating a file name, generates the same directory name', function()+        local dir1 = vim_gettempdir()+        vim_tempname()+        local dir2 = vim_gettempdir()+        eq(dir1, dir2)+      end)++      it('interrupted by deleting the temp directory, generates different directory names with corresponding directories', function()+        local dir1 = vim_gettempdir()+        ok(is_dir(dir1))+        vim_deltempdir()+        local dir2 = vim_gettempdir()+        ok(is_dir(dir2))+        neq(dir1, dir2)+      end)++      it('interrupted by externally deleting the temp directory, generates the same directory name and with no corresponding director ', function()+        local dir1 = vim_gettempdir()+        ok(is_dir(dir1))+        ok(lfs.rmdir(dir1))+        local dir2 = vim_gettempdir()+        ok(not is_dir(dir2))+        eq(dir1, dir2)+      end)     end)   end)    describe('vim_tempname', function()-    local vim_tempname = function()-      return helpers.ffi.string(tempfile.vim_tempname())-    end--    it('generate name of non-existing file', function()-      local file = vim_tempname()-      assert.truthy(file)-      assert.False(os.os_file_exists(file))-    end) -    it('generate different names on each call', function()-      local fst = vim_tempname()-      local snd = vim_tempname()-      assert.not_equals(fst, snd)+    it('generates path name of a non-existing file in temp directory', function()+      local path, dir = vim_tempname(), vim_gettempdir()+      ok(path_contains_dir(path, dir))+      ok(not file_exists(path))     end) -    it('generate file name in Neovim own temp directory', function()-      local dir = vim_gettempdir()-      local file = vim_tempname()-      assert.truthy(file:find('^' .. dir .. '[^/]*$'))+    context('called successively', function()++      it('generates different paths with a common temp directory', function()+        local path1, path2 = vim_tempname(), vim_tempname()+        neq(path1, path2)+        eq(dir_of_path(path1), dir_of_path(path2))+      end)++      it('interrupted by generating a directory name, generates different paths with a common temp directory', function()+        local path1 = vim_tempname()+        vim_gettempdir()+        local path2 = vim_tempname()+        neq(path1, path2)+        eq(dir_of_path(path1), dir_of_path(path2))+      end)++      it('interrupted by deleting the temp directory, generates paths with different temp directories', function()+        local path1 = vim_tempname()+        vim_deltempdir()+        local path2 = vim_tempname()+        neq(path1, path2)+        neq(dir_of_path(path1), dir_of_path(path2))+      end)++      it('interrupted by externally deleting the temp directory, generates a path that is no longer useful', function()","I find it irksome to have a unit test ensuring the behaviour of a known bug, but it does offer insight into `tempdir()` so it's not a bad thing to have.",
259933,stevenyvr987,https://api.github.com/repos/neovim/neovim/pulls/1617,21712443,2014-12-11T21:49:35Z,test/unit/tempfile_spec.lua,"@@ -1,60 +1,147 @@+local cimport, vim_init, ffi, to_cstr, eq, neq = (function()+  local _ = require 'test.unit.helpers'+  return _.cimport, _.vim_init, _.ffi, _.to_cstr, _.eq, _.neq+end)()+ local lfs = require 'lfs'-local helpers = require 'test.unit.helpers' -local os = helpers.cimport './src/nvim/os/os.h'-local tempfile = helpers.cimport './src/nvim/tempfile.h'+local os = cimport './src/nvim/os/os.h' -helpers.vim_init()+-- is_dir('/a/b/') will return true if '/a/b/' is a directory name+local is_dir = function(x) return 'directory' == lfs.attributes(x, 'mode') end -describe('tempfile related functions', function()-  after_each(function()-    tempfile.vim_deltempdir()-  end)+-- os_file_is_writable returns 2 for a directory which we have rights+-- to write into.+local is_writable = function(x) return os.os_file_is_writable(to_cstr(x)) == 2 end -  local vim_gettempdir = function()-    return helpers.ffi.string(tempfile.vim_gettempdir())+-- is_empty('/a/b/') will return true if 'a/b/' is a directory linking only to itself and the parent dir+local is_empty = function(x)+  for f in lfs.dir(x) do+    if f ~= '.' and f ~= '..' then return false end   end+  return true+end++-- file_exists('/a/b/c') will return true if '/a/b/c' is an existing file+local file_exists = os.os_file_exists++-- path_contains_dir('/a/b/c', '/a/b/') will return true+local path_contains_dir = function(path, dir)+  return (path ~= nil) and (path:find(""^"" .. tostring(dir) .. ""[^/]*$"") ~= nil)+end","Yes. the temp dir path will always have a terminating /.I tried to find a pathname parser in Lua's standard library, but there doesn't seem to be one.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1645,21727502,2014-12-12T03:47:17Z,src/nvim/syntax.c,"@@ -4562,19 +4562,101 @@ static int syn_compare_stub(const void *v1, const void *v2)   return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0; } +/// Count how many elements will be necessary for the list resulting from the+/// list_op operation on the two lists.+///+/// @param g1 The first sorted NUL terminated list+/// @param g2 The second sorted NUL terminated list+/// @param list_op The operation that will be performed on the two lists+/// @return The count of elemnts of the list resulting from the list_op+/// operation on the two lists+static size_t syn_combine_list_count(const short *g1, const short *g2, int list_op)","Since `list_op` is only checked for `CLUSTER_ADD`, `bool cluster cluster_add` would be more direct.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/1588,21734718,2014-12-12T09:35:50Z,CMakeLists.txt,"@@ -5,12 +5,8 @@ project(NEOVIM) list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"")  # Prefer our bundled versions of dependencies.-set(DEPS_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/.deps"")-set(DEPS_BUILD_DIR ""${DEPS_DIR}/build"")-set(DEPS_INSTALL_DIR ""${DEPS_DIR}/usr"")-set(DEPS_BIN_DIR ""${DEPS_INSTALL_DIR}/bin"")--list(APPEND CMAKE_PREFIX_PATH ${DEPS_INSTALL_DIR})+set(DEPS_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/.deps"" CACHE PATH ""Path for loading bundled dependencies"")+list(APPEND CMAKE_PREFIX_PATH ""${DEPS_DIR}/usr"")","I had a branch where I was heading down a similar path, but I didn't like having the same `DEPS_DIR` here, because it referred to `${CMAKE_CURRENT_SOURCE_DIR}/.deps` elsewhere.  Can we keep this as `DEPS_INSTALL_DIR`?Also, can we do this instead:``` cmakelist(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_INSTALL_DIR})```It's a separate fix, but it'll make sure our built dependencies get picked up ahead of others.",
13779,NOLFXceptMe,https://api.github.com/repos/neovim/neovim/pulls/1650,21750217,2014-12-12T15:24:11Z,src/nvim/os_unix_defs.h,"@@ -250,7 +250,7 @@  #define HAVE_DUP                /* have dup() */ -/* We have three kinds of ACL support. */-#define HAVE_ACL (HAVE_POSIX_ACL || HAVE_SOLARIS_ACL || HAVE_AIX_ACL)+// We have only POSIX ACL support+#define HAVE_ACL HAVE_POSIX_ACL","For Vim, `HAVE_POSIX_ACL` comes from `AC_DEFINE(HAVE_POSIX_ACL)` in configure.in.The only function of `HAVE_ACL` is to #guard the `mch_*_acl()` implementations. Since these are now OS-independent, I think we can drop `HAVE_ACL` altogether.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1650,21753914,2014-12-12T16:14:30Z,src/nvim/os_unix_defs.h,"@@ -250,7 +250,7 @@  #define HAVE_DUP                /* have dup() */ -/* We have three kinds of ACL support. */-#define HAVE_ACL (HAVE_POSIX_ACL || HAVE_SOLARIS_ACL || HAVE_AIX_ACL)+// We have only POSIX ACL support+#define HAVE_ACL HAVE_POSIX_ACL","In vim code, `mch_` means ""machine dependent"". If this is OS-independent, it should be moved out of `os_unix` and the `mch_` prefix should be removed.However, I don't think that `os_getperm()` actually returns a file's access control list, which is supposed to be a list of users and permissions. I don't know much about ACL, but it's hard for me to imagine that fitting in a single integer, or being statically sized.Finally, vim preserves permissions without ACL, which is a special kind of permission. If you look at `readfile` and `buf_write`, you'll see that the information from `os_getperm()` is already taken care of.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1134,21770682,2014-12-12T20:23:21Z,src/nvim/memory.c,"@@ -283,6 +283,42 @@ void memchrsub(void *data, char c, char x, size_t len)   } } +/// Counts the number of occurrences of `c` in `str`.+///+/// @warning Unsafe if `c == NUL`.","> Actually, it would just return 1Haha, yea of course! Wrote that just after waking up is what I tell myself :).> but I think asserting that c > 0 makes more sense.Alright. It doesn't seem hugely important but then we need to make sure that a user can't somehow pass in a `NUL` to search for somehow. I.e.: `strcnt` is never called with user-defined parameters.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1645,21787700,2014-12-13T11:30:25Z,src/nvim/syntax.c,"@@ -4562,19 +4562,101 @@ static int syn_compare_stub(const void *v1, const void *v2)   return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0; } +/// Count how many elements will be necessary for the list resulting from the+/// list_op operation on the two lists.+///+/// @param g1 The first sorted NUL terminated list+/// @param g2 The second sorted NUL terminated list+/// @param list_op The operation that will be performed on the two lists+/// @return The count of elemnts of the list resulting from the list_op+/// operation on the two lists+static size_t syn_combine_list_count(const short *g1, const short *g2, int list_op)+{+  size_t count = 0;++  // Loop through the lists until one of them is empty.+  while (*g1 && *g2) {+    // Always add from the first list.+    if (*g1 < *g2) {+      count++;+      g1++;+    } else {+      // Only add from the second list if we're adding the lists.+      if (list_op == CLUSTER_ADD) {+        count++;+      }++      if (*g1 == *g2) {",Perhaps add a comment like this to clarify:``` c      // Count only unique elements and elements that are not removed      // (list_op == CLUSTER_SUBTRACT) from the result list.```,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1645,21787754,2014-12-13T11:42:39Z,src/nvim/syntax.c,"@@ -4562,19 +4562,101 @@ static int syn_compare_stub(const void *v1, const void *v2)   return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0; } +/// Count how many elements will be necessary for the list resulting from the+/// list_op operation on the two lists.+///+/// @param g1 The first sorted NUL terminated list+/// @param g2 The second sorted NUL terminated list+/// @param list_op The operation that will be performed on the two lists+/// @return The count of elemnts of the list resulting from the list_op+/// operation on the two lists+static size_t syn_combine_list_count(const short *g1, const short *g2, int list_op)+{+  size_t count = 0;++  // Loop through the lists until one of them is empty.+  while (*g1 && *g2) {+    // Always add from the first list.+    if (*g1 < *g2) {+      count++;+      g1++;+    } else {+      // Only add from the second list if we're adding the lists.+      if (list_op == CLUSTER_ADD) {+        count++;+      }++      if (*g1 == *g2) {+        g1++;+      }+      g2++;+    }+  }++  // Now add the leftovers from whichever list didn't get finished first.+  for (; *g1; g1++) {+    count++;+  }+  // As before, only add from the second list if we're adding the lists.+  if (list_op == CLUSTER_ADD) {+    for (; *g2; g2++) {+      count++;+    }+  }++  return count;+}++/// Combines two lists according to list_op using the mergesort algorithm.+///+/// @param g1 The first sorted NUL terminated list+/// @param g2 The second sorted NUL terminated list+/// @param list_op The type of combination (operation) that should be performed+/// on the two lists+/// @param[out] clstr Pointer to the resulting list+static void syn_combine_list_merge(const short *g1, const short *g2, int list_op, short *clstr)+{+  size_t i = 0;++  // Loop through the lists until one of them is empty.+  while (*g1 && *g2) {+    // Always add from the first list.+    if (*g1 < *g2) {+      clstr[i++] = *g1;+      g1++;+    } else {+      // Only add from the second list if we're adding the lists.+      if (list_op == CLUSTER_ADD) {+        clstr[i++] = *g2;+      }++      if (*g1 == *g2) {",Comment to clarify this:``` c      // Add only unique elements and elements that are not removed      // (list_op == CLUSTER_SUBTRACT) from the result list.```,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1645,21787815,2014-12-13T11:54:48Z,src/nvim/syntax.c,"@@ -4562,19 +4562,101 @@ static int syn_compare_stub(const void *v1, const void *v2)   return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0; } +/// Count how many elements will be necessary for the list resulting from the+/// list_op operation on the two lists.+///+/// @param g1 The first sorted NUL terminated list+/// @param g2 The second sorted NUL terminated list+/// @param list_op The operation that will be performed on the two lists+/// @return The count of elemnts of the list resulting from the list_op+/// operation on the two lists+static size_t syn_combine_list_count(const short *g1, const short *g2, int list_op)+{+  size_t count = 0;++  // Loop through the lists until one of them is empty.+  while (*g1 && *g2) {+    // Always add from the first list.+    if (*g1 < *g2) {+      count++;+      g1++;+    } else {+      // Only add from the second list if we're adding the lists.+      if (list_op == CLUSTER_ADD) {+        count++;+      }++      if (*g1 == *g2) {+        g1++;+      }+      g2++;+    }+  }++  // Now add the leftovers from whichever list didn't get finished first.+  for (; *g1; g1++) {+    count++;+  }+  // As before, only add from the second list if we're adding the lists.+  if (list_op == CLUSTER_ADD) {+    for (; *g2; g2++) {+      count++;+    }+  }++  return count;+}++/// Combines two lists according to list_op using the mergesort algorithm.",More specifically we are using a/the merge algorithm on two sorted lists.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1645,21788180,2014-12-13T13:39:41Z,src/nvim/syntax.c,"@@ -4562,19 +4562,101 @@ static int syn_compare_stub(const void *v1, const void *v2)   return *s1 > *s2 ? 1 : *s1 < *s2 ? -1 : 0; } +/// Count how many elements will be necessary for the list resulting from the+/// list_op operation on the two lists.+///+/// @param g1 The first sorted NUL terminated list+/// @param g2 The second sorted NUL terminated list+/// @param list_op The operation that will be performed on the two lists+/// @return The count of elemnts of the list resulting from the list_op+/// operation on the two lists+static size_t syn_combine_list_count(const short *g1, const short *g2, int list_op)","That's true, but I will keep as it is so that I can mention `(list_op == CLUSTER_SUBTRACT)` in comments as proposed by @oni-link.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1622,21788487,2014-12-13T14:24:32Z,src/nvim/globals.h,"@@ -1229,6 +1229,7 @@ EXTERN char_u e_invalpat[] INIT(= N_( EXTERN char_u e_bufloaded[] INIT(= N_(""E139: File is loaded in another buffer"")); EXTERN char_u e_notset[] INIT(= N_(""E764: Option '%s' is not set"")); EXTERN char_u e_invalidreg[] INIT(= N_(""E850: Invalid register name""));+EXTERN char_u e_compatible[] INIT(= N_(""E???: Compatible not supported""));","The comment above this list says ""Excluded are errors that are only used once"". Since we are only using this once we don't need an `e_compatible` global. ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1667,21797900,2014-12-14T18:00:19Z,runtime/early.vim,"@@ -0,0 +1,73 @@+"" early.vim+""+"" configurations to set earliest+""+"" based on tpope's sensible.vim[1], with some suggestions gathered +"" at neovim's issue #276[2]+""+"" [1]: https://github.com/tpope/vim-sensible+"" [2]: https://github.com/neovim/neovim/issues/276++filetype plugin indent on+syntax enable++set autoindent+set backspace=indent,eol,start+set complete-=i+set smarttab++set nrformats-=octal++set ttimeout+set ttimeoutlen=100++set incsearch+set hlsearch+"" use <C-L> to clear the highlighting of :set hlsearch.+if maparg('<C-L>', 'n') ==# ''+    nnoremap <silent> <C-L> :nohlsearch<CR><C-L>+endif++set mouse=a++set laststatus=2+set ruler+set showcmd+set wildmenu+set wildmode=list:longest++set scrolloff=1+set sidescrolloff=5+set display+=lastline++set encoding=utf-8++set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+++set formatoptions+=j++"" search upwards for tags file+setglobal tags-=./tags  tags^=./tags;++set autoread+set fileformats+=mac++set history=1000+set tabpagemax=50+set viminfo^=!+set sessionoptions-=options++if &t_Co == 8 && $TERM !~# '^linux'+    set t_Co=16+endif++if &shell =~# 'fish$'+    set shell=sh+endif++"" allow undoing <C-u> (delete text typed in the current line)+inoremap <C-U> <C-G>u<C-U>++"" <home> goes to the beginning of the text on first press +"" and the beginning of the line on second. it alternates afterwards+map <expr> <home> search('^\s\+\%#', 'n') ? '0' : '_'","`virtcol()` + `indent()` is two orders of magnitude faster in a file with 1800 lines, 3 orders of magnitude for 20000 lines, etc. You need to supply `, line('.')` as an additional argument to `search()` to make them take the same time to finish that is not dependent on the amount of lines in the current file.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1584,21800378,2014-12-14T22:45:08Z,src/nvim/eval.c,"@@ -19706,35 +19743,45 @@ char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, char_u *flags)     }, true);                                                        \   } while(0) -static void on_job_stdout(RStream *rstream, void *data, bool eof)+static void on_job_stdout(RStream *rstream, void *job, bool eof) {+  JobData *data = job_data(job);   if (rstream_pending(rstream)) {-    push_job_event(data, rstream, ""stdout"", eof);+    push_job_event(job_id(job), data->name, rstream, ""stdout"",+                   data->unbuffered, data->as_string, eof);   } } -static void on_job_stderr(RStream *rstream, void *data, bool eof)+static void on_job_stderr(RStream *rstream, void *job, bool eof) {+  JobData *data = job_data(job);   if (rstream_pending(rstream)) {-    push_job_event(data, rstream, ""stderr"", eof);+    push_job_event(job_id(job), data->name, rstream, ""stderr"",+                   data->unbuffered, data->as_string, eof);   } } -static void on_job_exit(Job *job, void *data)+static void on_job_exit(Job *job, void *vdata) {-  push_job_event(job, NULL, ""exit"", true);+  JobData *data = vdata;+  push_job_event(job_id(job), data->name, NULL, ""exit"",+                 data->unbuffered, data->as_string, true);+  free(data);",Macro `push_job_event` has a return statement. So it could be possible that the statement `free(data);` would not be reached.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1684,21881432,2014-12-16T07:22:09Z,src/nvim/os/shell.c,"@@ -396,6 +396,7 @@ static void read_input(DynamicBuffer *buf)               curbuf->b_ml.ml_line_count               || curbuf->b_p_eol))) {         dynamic_buffer_ensure(buf, buf->len + 1);+        assert(buf->data != NULL);         buf->data[buf->len++] = NL;","coverity claims this is `dereferences null`, but as far as I can tell `dynamic_buffer_ensure()` allocates `buf->data` in the case of `l == 0 && l == len`, because `dynamic_buffer_ensure(buf, buf->len + 1)` executes `buf->data = xrealloc(buf->data, (buf->len + 1))`.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/1684,21881624,2014-12-16T07:31:05Z,src/nvim/os/shell.c,"@@ -396,6 +396,7 @@ static void read_input(DynamicBuffer *buf)               curbuf->b_ml.ml_line_count               || curbuf->b_p_eol))) {         dynamic_buffer_ensure(buf, buf->len + 1);+        assert(buf->data != NULL);         buf->data[buf->len++] = NL;",Yeah. Just too bad we can't communicate postconditions like that as easily as returns non-null.,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1683,21884724,2014-12-16T09:06:59Z,src/nvim/os/shell.c,"@@ -396,6 +396,7 @@ static void read_input(DynamicBuffer *buf)               curbuf->b_ml.ml_line_count               || curbuf->b_p_eol))) {         dynamic_buffer_ensure(buf, buf->len + 1);+        assert(buf->data != NULL);         buf->data[buf->len++] = NL;",Why not just `assert(buf->data)`? We've been doing that everywhere else.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1638,21911022,2014-12-16T16:32:20Z,src/nvim/ex_cmds2.c,"@@ -3293,3 +3293,79 @@ static void script_host_do_range(char *name, exarg_T *eap)   (void)eval_call_provider(name, ""do_range"", args); } +/*+ * "":drop""+ * Opens the first argument in a window.  When there are two or more arguments+ * the argument list is redefined.+ */+void ex_drop(exarg_T   *eap)+{+    int                split = FALSE;+    buf_T      *buf;++    /*+     * Check if the first argument is already being edited in a window.  If+     * so, jump to that window.+     * We would actually need to check all arguments, but that's complicated+     * and mostly only one file is dropped.+     * This also ignores wildcards, since it is very unlikely the user is+     * editing a file name with a wildcard character.+     */+    do_arglist(eap->arg, AL_SET, 0);","For my own edification, why does Vim have `set_arglist(eap->arg)` here (which doesn't exist in Neovim)?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1648,21913565,2014-12-16T17:04:09Z,runtime/doc/autocmd.txt,"@@ -528,8 +528,9 @@ CursorHold			When the user doesn't press a key for the time 				Hint: to force an update of the status lines 				use: > 					:let &ro = &ro-<				{only on Amiga, Unix, Win32, MSDOS and all GUI+<				{only on Unix, Win32, MSDOS, and all GUI 				versions}","Can just remove the entire sentence. Any case platform support is listed for all platforms we support, we can (and should) just remove the statement entirely, because it's redundant.",
7451790,jmehne,https://api.github.com/repos/neovim/neovim/pulls/1678,21931094,2014-12-16T20:53:56Z,test/functional/options/viminfo_spec.lua,"@@ -0,0 +1,29 @@+local helpers = require('test.functional.helpers')+local clear, execute, ok = helpers.clear, helpers.execute, helpers.ok++describe('viminfo', function()+  setup(clear)++  it('`n`: uses a different viminfo name', function()+    local viminfo_name = 'nviminfo_foobar'+    execute(""set viminfo='100,n""..viminfo_name)++    os.remove(viminfo_name)+    execute('wviminfo!')+    ok(os.remove(viminfo_name))+  end)++  --pending('`!`: saves/restores uppercase variables - migrate test74')+  --pending('`""`: tests max number of lines saved for each register')+  --pending('`<`: tests max number of lines saved for each register')+  --pending('`%`: saves/restores the buffer list')+  --pending(""`'`: remembers marks for a maximum number of files"")+  --pending('`/`: tests max number of items in the search pattern history')+  --pending('`:`: tests max number of items in the command-line history')+  --pending('`@`: tests max number of items in the input-line history')+  --pending('`c`: converts viminfo file to different encoding')+  --pending('`f`: stores file marks')+  --pending(""`h`: disables the effect of 'hlsearch'"")+  --pending(""`r`: doesn't store marks for removable media"")+  --pending('`s`: tests maximum size of an item')","In the end it doesn't make a big difference. IMO, the busted output for pending tests is even harder to read than the output of `grep -Rn -- --pending test` (at least if `alias grep='grep --color=auto` is used). So we'd just have to be consistent with `--pending` in all tests to get similar behavior as with busted itself.",
3199732,Grimy,https://api.github.com/repos/neovim/neovim/pulls/1638,22096996,2014-12-19T09:54:35Z,src/nvim/ex_cmds2.c,"@@ -3293,3 +3293,79 @@ static void script_host_do_range(char *name, exarg_T *eap)   (void)eval_call_provider(name, ""do_range"", args); } +/*+ * "":drop""+ * Opens the first argument in a window.  When there are two or more arguments+ * the argument list is redefined.+ */+void ex_drop(exarg_T   *eap)+{+    int                split = FALSE;+    buf_T      *buf;++    /*+     * Check if the first argument is already being edited in a window.  If+     * so, jump to that window.+     * We would actually need to check all arguments, but that's complicated+     * and mostly only one file is dropped.+     * This also ignores wildcards, since it is very unlikely the user is+     * editing a file name with a wildcard character.+     */+    do_arglist(eap->arg, AL_SET, 0);","vim had the following:```/* * Redefine the argument list. */void set_arglist(char_u *str){    do_arglist(str, AL_SET, 0);}```This one-line function was called exactly once in the codebase, which is a pretty bad code smell IMO (especially considering the similar function names and less than clear comment). I inlined it while applying the patch.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1638,22123596,2014-12-19T19:28:55Z,src/nvim/ex_cmds2.c,"@@ -3293,3 +3293,79 @@ static void script_host_do_range(char *name, exarg_T *eap)   (void)eval_call_provider(name, ""do_range"", args); } +/*+ * "":drop""+ * Opens the first argument in a window.  When there are two or more arguments+ * the argument list is redefined.+ */+void ex_drop(exarg_T   *eap)+{+    int                split = FALSE;+    buf_T      *buf;++    /*+     * Check if the first argument is already being edited in a window.  If+     * so, jump to that window.+     * We would actually need to check all arguments, but that's complicated+     * and mostly only one file is dropped.+     * This also ignores wildcards, since it is very unlikely the user is+     * editing a file name with a wildcard character.+     */+    do_arglist(eap->arg, AL_SET, 0);",":+1:  I see now, Vim hides `set_arglist` for terminal version.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1685,22128413,2014-12-19T20:58:37Z,src/nvim/os/shell.c,"@@ -56,15 +53,16 @@ char **shell_build_argv(const char_u *cmd, const char_u *extra_shell_opt)   // Split 'shell'   size_t i = tokenize(p_sh, rv); -  if (extra_shell_opt != NULL) {-    // Push a copy of `extra_shell_opt`-    rv[i++] = xstrdup((char *)extra_shell_opt);+  if (extra_args != NULL) {+    // Push a copy of `extra_args`+    rv[i++] = xstrdup(extra_args);   } -  if (cmd != NULL) {-    // Split 'shellcmdflag'-    i += tokenize(p_shcf, rv + i);-    rv[i++] = xstrdup((char *)cmd);+  if (cmd == NULL) {+    rv[i++] = xstrdup((char *)p_sh);  // Push a copy of the default 'shell'.","> positions previous to i (those containing the shell name and options) must be handled somewhere elseWell, not somewhere else, in fact. They are handled previously in this same function. The line:```  size_t i = tokenize(p_sh, rv);```already fills positions previous to i (containing shell name and options). I hadn't previously noticed that `rv` was an output parameter.So, we can leave just the `if (cmd != NULL)` branch (improved to `if (cmd)`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1710,22140841,2014-12-20T09:56:59Z,runtime/doc/job_control.txt,"@@ -53,27 +53,27 @@ event. The best way to understand is with a complete example:       else         let str = 'shell '.v:job_data[0].' exited'       endif-    +       call append(line('$'), str)     endfunction-    +     au JobActivity shell* call JobHandler() <-To test the above, copy it to the ~/jobcontrol.vim file and start with a clean+To test the above, copy it to the file ~/jobcontrol.vim and start with a clean nvim instance:-  >-      nvim -u NONE -S ~/jobcontrol.vim+>+    nvim -u NONE -S ~/jobcontrol.vim < Here's what is happening: -- Two bash instances are spawned by |jobstart()| and their stdin/stdout/stderr-  are connected to nvim.-- The first shell is idle, waiting to read commands from it's stdin-- The second shell is passed the -c option to execute a command and exit. In-  our case, the command is a for loop that will print numbers and exit after-  a while.-- The JobHandler function is called by the JobActivity autocommand(notice how-  the shell* pattern matches the `shell1` and `shell2` names passed to+- Two bash instances are spawned by |jobstart()| with their stdin/stdout/stderr+  connected to nvim.+- The first shell is idle, waiting to read commands from its stdin.+- The second shell is started with the -c argument, causing it to execute a+  command then exit. In this case, the command is a for loop that will print 0+  through 9 then exit.+- The `JobHandler()` function is called by the `JobActivity` autocommand (notice+  how the shell* pattern matches the names `shell1` and `shell2` passed to","Cannot comment on line 89-91, so I use this line.Instead of using single quotes around the data for `jobsend`, double quotes should be used. Otherwise `\n` is not interpreted right.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1584,22205169,2014-12-23T07:01:52Z,src/nvim/eval.c,"@@ -19797,15 +19839,23 @@ static void apply_job_autocmds(int id, char *name, char *type,   list_append_string(list, (uint8_t *)type, -1);    if (received) {-    listitem_T *str_slot = listitem_alloc();-    str_slot->li_tv.v_type = VAR_LIST;-    str_slot->li_tv.v_lock = 0;-    str_slot->li_tv.vval.v_list =-      string_to_list((char_u *) received, received_len, false);-    str_slot->li_tv.vval.v_list->lv_refcount++;-    list_append(list, str_slot);--    free(received);+    listitem_T *li = listitem_alloc();  // To inert the job data.",typo: inert => insert. But `To hold the job data` may be better.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1584,22205472,2014-12-23T07:20:02Z,runtime/doc/eval.txt,"@@ -4033,6 +4033,13 @@ jobstart({name}, {prog}[, {argv}])			{Nvim} *jobstart()* 		    |jobstop()| 		  - 0 when the job table is full or on invalid arguments 		  - -1 when {prog} is not executable+		+		Output will be buffered until a newline character is read and+		returned as a list unless supplied {flags}. If {flags} is a+		string, it may contain 'u' or 'b', meaning (u)nbuffered and+		(b)uffered, respectively, or 's' or 'l', meaning to set+		v:job_data[2] as a string or list. If {flags} is a number,+		being larger than zero implies ""unbuffered string"".","Before I forget, can we add some verbiage here regarding the empty item. E.g.:```Buffered ('b') job output always ends with an empty string item [''] to indicate the end of the output; absence of a final empty string item indicates that the buffer overflowed. In contrast, unbuffered ('u') data may emit any part of the output, so the lack of a final empty item indicates an unterminated line.```",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1729,22218979,2014-12-23T15:30:05Z,src/nvim/diff.c,"@@ -2017,17 +2017,24 @@ int diff_infold(win_T *wp, linenr_T lnum) }  /// ""dp"" and ""do"" commands.-///-/// @param put","If there is no `@param` at all, we get a Doxygen warning that docu is missing for this parameter, which is IMO more useful than an empty parameter description.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1730,22219266,2014-12-23T15:36:03Z,src/nvim/ex_docmd.c,"@@ -1707,17 +1709,15 @@ static char_u * do_one_cmd(char_u **cmdlinep,   if (       (ea.argt & REGSTR)              && *ea.arg != NUL              /* Do not allow register = for user commands */-             && (!USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')+             && (!IS_USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')              && !((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg))) {     /* check these explicitly for a more specific error message */     if (*ea.arg == '*' || *ea.arg == '+') {       errormsg = (char_u *)_(e_invalidreg);       goto doend;     }-    if (-      valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put-                               && USER_CMDIDX(ea.cmdidx)))-      ) {+    if (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put+                                 && !IS_USER_CMDIDX(ea.cmdidx)))) {","Here, from what I can see, is the only real change in this patch: the condition is negated (`USER_CMDIDX` to `!IS_USER_CMDIDX`).Original patch:``` diff-   if (-#ifdef FEAT_USR_CMDS-       valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put-                          && USER_CMDIDX(ea.cmdidx)))-#else-       valid_yank_reg(*ea.arg, ea.cmdidx != CMD_put)-#endif-      )+   if (valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put+                         && !IS_USER_CMDIDX(ea.cmdidx))))```",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1715,22262094,2014-12-24T19:06:30Z,src/nvim/undo.c,"@@ -1121,7 +1111,7 @@ void u_write_undo(char_u *name, int forceit, buf_T *buf, char_u *hash)       && os_fileinfo((char *)buf->b_ffname, &file_info_old)       && os_fileinfo((char *)file_name, &file_info_new)       && file_info_old.stat.st_gid != file_info_new.stat.st_gid-      && os_fchown(fd, -1, file_info_old.stat.st_gid) != 0) {+      && os_fchown(fd, (uv_uid_t)-1, (uv_gid_t)file_info_old.stat.st_gid)) {","> I wonder why libuv's own uv_stat_t.st_gid is defined as uint64_t. Me too. Could be a small inconsistency. But haven't really looked into it.> Should we just change the signature of os_fchown to accept uint64_t?Could be an option.> Also, uv_uid_t resolves to unsigned int. Shouldn't we change -1 to UINT_MAX or is (unsigned int)-1 an acceptable C idiom?The fact that uv_uid_t resolves to unsigned int should remain hidden, so that it can be changed. So I don't like relying on UINT_MAX. The ideal thing should be having a constant UV_UID_MAX. Lacking that, I don't think the (uv_uid_t)-1 idiom is bad, as that would automatically adapt to changes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1740,22275619,2014-12-25T21:43:04Z,scripts/vim-patch.sh,"@@ -18,10 +21,11 @@ fi  vim_version=""${1}"" if [[ ! ${vim_version} =~ [0-9]\.[0-9]\.[0-9][0-9][0-9] ]]; then-  >&2 echo ""vim-version must be in format '7.4.xxx'.""+  >&2 echo ""��� vim-version must be in format '7.4.xxx'.""   exit 2 fi +echo ""Retrieving Vim sources."" if [[ ! -d ${VIM_SOURCE_DIR} ]]; then   echo ""Cloning Vim sources into '${VIM_SOURCE_DIR}'.""   hg clone https://code.google.com/p/vim ${VIM_SOURCE_DIR}","If `-r` does what I think it does, I suggest adding `-re29f11399cce` here so that only history back to 7.4.002 is pulled. The initial clone takes quite awhile, so anything we can do to reduce pain of merging patches is worth doing :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1740,22275625,2014-12-25T21:45:38Z,scripts/vim-patch.sh,"@@ -18,10 +21,11 @@ fi  vim_version=""${1}"" if [[ ! ${vim_version} =~ [0-9]\.[0-9]\.[0-9][0-9][0-9] ]]; then-  >&2 echo ""vim-version must be in format '7.4.xxx'.""+  >&2 echo ""��� vim-version must be in format '7.4.xxx'.""   exit 2 fi +echo ""Retrieving Vim sources."" if [[ ! -d ${VIM_SOURCE_DIR} ]]; then   echo ""Cloning Vim sources into '${VIM_SOURCE_DIR}'.""   hg clone https://code.google.com/p/vim ${VIM_SOURCE_DIR}","Actually `-r` doesn't seem to work. And I can't seem to find how to limit `hg clone` to ""only get history since X"".",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1740,22275635,2014-12-25T21:50:05Z,scripts/vim-patch.sh,"@@ -18,10 +21,11 @@ fi  vim_version=""${1}"" if [[ ! ${vim_version} =~ [0-9]\.[0-9]\.[0-9][0-9][0-9] ]]; then-  >&2 echo ""vim-version must be in format '7.4.xxx'.""+  >&2 echo ""��� vim-version must be in format '7.4.xxx'.""   exit 2 fi +echo ""Retrieving Vim sources."" if [[ ! -d ${VIM_SOURCE_DIR} ]]; then   echo ""Cloning Vim sources into '${VIM_SOURCE_DIR}'.""   hg clone https://code.google.com/p/vim ${VIM_SOURCE_DIR}",It should be okay to just clone everything; this is only necessary once (if the `.vim-src` directory is not deleted).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1740,22275644,2014-12-25T21:56:52Z,scripts/vim-patch.sh,"@@ -18,10 +21,11 @@ fi  vim_version=""${1}"" if [[ ! ${vim_version} =~ [0-9]\.[0-9]\.[0-9][0-9][0-9] ]]; then-  >&2 echo ""vim-version must be in format '7.4.xxx'.""+  >&2 echo ""��� vim-version must be in format '7.4.xxx'.""   exit 2 fi +echo ""Retrieving Vim sources."" if [[ ! -d ${VIM_SOURCE_DIR} ]]; then   echo ""Cloning Vim sources into '${VIM_SOURCE_DIR}'.""   hg clone https://code.google.com/p/vim ${VIM_SOURCE_DIR}","Yeah, I don't know if others are like me, but I'm constantly moving around from 5 different machines, and having ""disposable"" environments is always desirable. A 2-minute checkout is somewhat less disposable. Not a big deal though.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1729,22286823,2014-12-26T18:50:13Z,src/nvim/diff.c,"@@ -2017,17 +2017,24 @@ int diff_infold(win_T *wp, linenr_T lnum) }  /// ""dp"" and ""do"" commands.-///-/// @param put",":+1: Empty param descriptions, or descriptions that meaninglessly restate the parameter name (e.g. `@param put The thing to put`) are useless noise and should be avoided.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1729,22286864,2014-12-26T18:54:03Z,src/nvim/diff.c,"@@ -2017,17 +2017,24 @@ int diff_infold(win_T *wp, linenr_T lnum) }  /// ""dp"" and ""do"" commands.-///-/// @param put-void nv_diffgetput(int put)+void nv_diffgetput(bool put, size_t count) {   exarg_T ea;-  ea.arg = (char_u *)"""";+  char buf[30];++  if (count == 0) {+    ea.arg = (char_u *)"""";+  } else {+    vim_snprintf(buf, 30, ""%ld"", count);",I believe this should use portable format specifier `PRId64` instead of `%ld`. See 28bac30c196fbe74a635b0c285bad0cd34bfaffa for example. cc @elmart Is `PRId64` correct for `size_t`?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1182,22370989,2014-12-31T00:09:46Z,src/nvim/eval.c,"@@ -5119,6 +5119,20 @@ void list_append_tv(list_T *l, typval_T *tv) }  /*+ * Add a list to a list.+ */+void list_append_list(list_T *list, list_T *itemlist)+{+  listitem_T  *li = listitem_alloc();++  li->li_tv.v_type = VAR_LIST;+  li->li_tv.v_lock = 0;+  li->li_tv.vval.v_list = itemlist;+  list_append(list, li);+  ++list->lv_refcount;","`itemlist` is referenced in `list`, so we should use `++itemlist->lv_refcount` here.The refcount of `list` should probably be increased somewhere else.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/1182,22371332,2014-12-31T00:28:36Z,src/nvim/eval.c,"@@ -5119,6 +5119,20 @@ void list_append_tv(list_T *l, typval_T *tv) }  /*+ * Add a list to a list.+ */+void list_append_list(list_T *list, list_T *itemlist)+{+  listitem_T  *li = listitem_alloc();++  li->li_tv.v_type = VAR_LIST;+  li->li_tv.v_lock = 0;+  li->li_tv.vval.v_list = itemlist;+  list_append(list, li);+  ++list->lv_refcount;",":+1: i've must have copypasted dict_add_list too quickly...Den 31 dec 2014 01:09 skrev ""oni-link"" notifications@github.com:> In src/nvim/eval.c> https://github.com/neovim/neovim/pull/1182#discussion-diff-22370989:> > > @@ -5119,6 +5119,20 @@ void list_append_tv(list_T *l, typval_T *tv)> >  }> > > >  /*> > - \* Add a list to a list.> > - */> >   +void list_append_list(list_T *list, list_T *itemlist)> >   +{> > -  listitem_T  *li = listitem_alloc();> >   +> > -  li->li_tv.v_type = VAR_LIST;> > -  li->li_tv.v_lock = 0;> > -  li->li_tv.vval.v_list = itemlist;> > -  list_append(list, li);> > -  ++list->lv_refcount;> > itemlist is referenced in list, so we should use ++itemlist->lv_refcount> here.> The refcount of list should probably be increased somewhere else.> > ���> Reply to this email directly or view it on GitHub> https://github.com/neovim/neovim/pull/1182/files#r22370989.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1729,22435947,2015-01-04T01:38:35Z,src/nvim/diff.c,"@@ -2017,17 +2017,24 @@ int diff_infold(win_T *wp, linenr_T lnum) }  /// ""dp"" and ""do"" commands.-///-/// @param put-void nv_diffgetput(int put)+void nv_diffgetput(bool put, size_t count) {   exarg_T ea;-  ea.arg = (char_u *)"""";+  char buf[30];++  if (count == 0) {+    ea.arg = (char_u *)"""";+  } else {+    vim_snprintf(buf, 30, ""%ld"", count);","I extracted inttypes.h from VS2015 latest preview and here it is: https://gist.github.com/jasonwilliams200OK/45d0b5f4fd2b087e0b3aAnd here is the one that shipped with VS2013 Update 4: https://gist.github.com/jasonwilliams200OK/2a0ce733923fbcf86c64 (don't know why they say complex.h in comment in 2013 version?)Besides the following, all C99 and C11 standard headers are included in CRT (VS2015):``` CC11 - <stdalign.h>C11 - <stdatomic.h>C11 - <stdnoreturn.h>C99 - <tgmath.h>C11 - <threads.h>```The only C11 header that is included is [`<uchar.h>`](https://gist.github.com/jasonwilliams200OK/e8c8d4f71284d52ffa91), which means STL (person) was not kidding [in this blog's comment](http://blogs.msdn.com/b/vcblog/archive/2014/06/11/c-11-14-feature-tables-for-visual-studio-14-ctp1.aspx?PageIndex=1#comments):> My coworker Pat Brenner is actually adding <uchar.h> to the CRT right now, and I've given him <cuchar> to add to the STL. Unless a meteor strikes, this will get into VS14 RTM.(it was later, they changed the name to VS2015 ... and yes meteor did not strike!)So now we even know what date uchar.h got included in their CRT! :)BTW, that list in blog I linked above is now superseded by [this one](http://blogs.msdn.com/b/vcblog/archive/2014/11/17/c-11-14-17-features-in-vs-2015-preview.aspx).PS Matter of time before we would be `@`'ing VC guys directly on GH..",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1729,22436056,2015-01-04T02:12:39Z,src/nvim/diff.c,"@@ -2017,17 +2017,24 @@ int diff_infold(win_T *wp, linenr_T lnum) }  /// ""dp"" and ""do"" commands.-///-/// @param put-void nv_diffgetput(int put)+void nv_diffgetput(bool put, size_t count) {   exarg_T ea;-  ea.arg = (char_u *)"""";+  char buf[30];++  if (count == 0) {+    ea.arg = (char_u *)"""";+  } else {+    vim_snprintf(buf, 30, ""%ld"", count);","To answer your earlier question @justinmk, I tested with this code (taken from SO link by @fwalch):``` c// test.c#include <stdio.h>#include <BaseTsd.h>int main(){    size_t x = 1;    SSIZE_T y = 2;    printf(""%zu\n"", x);  // prints as unsigned decimal    printf(""%zx\n"", x);  // prints as hex    printf(""%zd\n"", y);  // prints as signed decimal    return 0;}```on both VS2013 and VS2015.VS2015 generated binary outputs:```112```while the one generated by VS2013 says:```zuzxzd```Note: `ssize_t` is a POSIX extension and `SSIZE_T` is similar thing in [Windows Data Types](http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751.aspx), hence I added `<BaseTsd.h>` referenceLet me know if there is anything else you want me to confirm.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1657,22446514,2015-01-05T03:11:03Z,runtime/plugin/matchparen.vim,"@@ -45,7 +45,7 @@ function! s:Highlight_Matching_Pair()    "" Avoid that we remove the popup menu.   "" Return when there are no colors (looks like the cursor jumps).-  if pumvisible() || (&t_Co < 8 && !has(""gui_running""))+  if pumvisible() || (&term != 'abstract_ui' && &t_Co < 8 && !has(""gui_running""))",Is this a temporary workaround? Shouldn't `t_Co` return the correct number for the currently active TUI?,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1657,22452638,2015-01-05T09:36:13Z,runtime/plugin/matchparen.vim,"@@ -45,7 +45,7 @@ function! s:Highlight_Matching_Pair()    "" Avoid that we remove the popup menu.   "" Return when there are no colors (looks like the cursor jumps).-  if pumvisible() || (&t_Co < 8 && !has(""gui_running""))+  if pumvisible() || (&term != 'abstract_ui' && &t_Co < 8 && !has(""gui_running""))","Yes and no. While abstract_ui is temporary(it will be removed once the new TUI migration is complete), I'm still not sure how to deal with the `&t_Co` option in vimscript.Most of the times, this is checked to decide what to display based on the number of terminal colors, but since nvim can have multiple terminals attached, this simply doesn't make sense. In the C code where t_Co is checked, I will simply remove the conditions and hardcode the path where most colors are available, but for vimscript I see two choices:- Add a stub value of 256 to `&t_Co`- Require that existing vimscript testing for `&t_Co` to be modified to take nvim into consideration.Both approaches will probably require color schemes designed for multiple UIs to be adapted for nvim to work correctly. For example, in a color scheme that supports terminals with 16, 88 and 256 colors the current solution is something like this:``` vimif &t_Co == 256  highlight GROUP ctermfg=xelse if &t_Co == 88  highlight GROUP ctermfg=yelse  highlight GROUP ctermfg=zendif```while for nvim the ideal approach would be:``` vimhighlight GROUP term256fg=x term88fg=y term16fg=z```Which would display correctly if multiple TUIs with different color count are connected at the same time(each TUI would receive the complete highlight information and use what is appropriate)Clearly this would require [this change](https://github.com/neovim/neovim/issues/1767#issuecomment-68656372) to work.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1365,22559122,2015-01-06T22:55:33Z,src/nvim/os/shell.c,"@@ -300,34 +244,37 @@ int os_system(const char *cmd,       job_stop(job);       return -1;     }+    // close the input stream, let the process know that no more input is+    // coming+    job_close_in(job);   } -  // close the input stream, let the process know that no more input is coming-  job_close_in(job);-  int status = job_wait(job, -1);+  status = job_wait(job, -1);","We can return early from `job_wait()` (hitting CTRL-C) and there can still be waiting callbacks to `system_data_cb()`.If  `shell()` returns, the stack allocated buffer `buf` becomes invalid, but the job callbacks can still try to use `buf`.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1788,22757958,2015-01-10T10:03:11Z,src/nvim/hardcopy.c,"@@ -455,8 +454,10 @@ static void prt_line_number(prt_settings_T *psettings, int page_line, linenr_T l  */ int prt_header_height(void) {-  if (printer_opts[OPT_PRINT_HEADERHEIGHT].present)-    return printer_opts[OPT_PRINT_HEADERHEIGHT].number;+  if (printer_opts[OPT_PRINT_HEADERHEIGHT].present) {+    assert(printer_opts[OPT_PRINT_HEADERHEIGHT].number <= INT_MAX);","Ok, I reviewed every place where INT_MAX was introduced to check conversion to int, and added the corresponding check for INT_MIN when converting from a signed type. Probably, there are cases where, while the variable is signed, it is meant to hold a positive value (mouse_col, mouse_row, etc). In those cases, asserting >= 0 && <= INT_MAX would be more sensible. But, without deeper understanding of the code, and not knowing if value can ever be negative for some reason, I prefer the safe path of asserting >= INT_MIN && <= INT_MAX.Note also that a lot more of type refactoring cleanup can (and should) still be done in these files, which would eventually eliminate most asserts/casts. But that's not this PR's scope. Here I'm just doing the minimum to be able to enable -Wconversion and remove long_u.Pushed new version with these changes.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1788,22758001,2015-01-10T10:11:34Z,src/nvim/hardcopy.c,"@@ -728,13 +730,10 @@ void ex_hardcopy(exarg_T *eap)           if (got_int || settings.user_abort)             goto print_fail; -          sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),-              page_count + 1 + side,-              prtpos.bytes_printed > 1000000-              ? (int)(prtpos.bytes_printed /-                      (bytes_to_print / 100))-              : (int)((prtpos.bytes_printed * 100)-                      / bytes_to_print));+          assert(prtpos.bytes_printed * 100 > prtpos.bytes_printed);","Original code tried to do calculation in two different ways in order to expand the range of values for which calculation could be done without overflow.Now that prtpos.bytes_printed is size_t, I think range is big enough. So, I simplified calculation to be done just one way, after checking for improbable overflow. I think that's clearer.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1788,22758569,2015-01-10T12:17:47Z,src/nvim/hardcopy.c,"@@ -455,8 +454,10 @@ static void prt_line_number(prt_settings_T *psettings, int page_line, linenr_T l  */ int prt_header_height(void) {-  if (printer_opts[OPT_PRINT_HEADERHEIGHT].present)-    return printer_opts[OPT_PRINT_HEADERHEIGHT].number;+  if (printer_opts[OPT_PRINT_HEADERHEIGHT].present) {+    assert(printer_opts[OPT_PRINT_HEADERHEIGHT].number <= INT_MAX);",>  Here I'm just doing the minimum to be able to enable -Wconversion and remove long_u.:+1:,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1788,22762265,2015-01-10T22:02:19Z,src/nvim/hardcopy.c,"@@ -3080,16 +3079,18 @@ void mch_print_set_font(int iBold, int iItalic, int iUnderline)   } } -void mch_print_set_bg(long_u bgcol)+void mch_print_set_bg(uint32_t bgcol) {+  assert(bgcol <= INT_MAX);","Note that I didn't do all possible type refactoring in these files. There are still a lot of things than can be improved, as I just did the strictly necessary to make -Wconversion pass and remove long_u.This one is a sensible one, though.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1794,22768873,2015-01-11T18:52:25Z,src/nvim/charset.c,"@@ -1676,26 +1676,37 @@ char_u* skiptowhite_esc(char_u *p) {   return p; } -/// Getdigits: Get a number from a string and skip over it.+/// Get a number from a string and skip over it. ///-/// Note: the argument is a pointer to a char_u pointer!+/// @param[out]  pp  A pointer to a pointer to char_u.+///                  It will be advanced past the read number. ///-/// @param pp+/// @return Number read from the string.+intmax_t get_digits(char_u **pp)+{+  intmax_t number = strtoimax((char *)*pp, (char **)pp, 10);+  assert(errno != ERANGE);+  return number;+}++/// Get an int number from a string. ///-/// @return Number from the string.-long getdigits(char_u **pp)+/// A get_digits wrapper restricted to int values.+int get_int_digits(char_u **pp) {-  char_u *p = *pp;-  long retval = atol((char *)p);+  intmax_t number = get_digits(pp);+  assert(number >= INT_MIN && number <= INT_MAX);+  return (int)number;+} -  if (*p == '-') {-    // skip negative sign-    ++p;-  }-  // skip to next non-digit-  p = skipdigits(p);-  *pp = p;-  return retval;+/// Get a long number from a string.+///+/// A get_digits wrapper restricted to long values.+long get_long_digits(char_u **pp)","For this kind of function ""family"" I think `getdigits`, `getdigits_int` and `getdigits_long` follows ""parallel form"" and is more discoverable. What do you think @elmart?",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1794,22769269,2015-01-11T19:35:13Z,src/nvim/charset.c,"@@ -1676,26 +1676,37 @@ char_u* skiptowhite_esc(char_u *p) {   return p; } -/// Getdigits: Get a number from a string and skip over it.+/// Get a number from a string and skip over it. ///-/// Note: the argument is a pointer to a char_u pointer!+/// @param[out]  pp  A pointer to a pointer to char_u.+///                  It will be advanced past the read number. ///-/// @param pp+/// @return Number read from the string.+intmax_t get_digits(char_u **pp)+{+  intmax_t number = strtoimax((char *)*pp, (char **)pp, 10);+  assert(errno != ERANGE);+  return number;+}++/// Get an int number from a string. ///-/// @return Number from the string.-long getdigits(char_u **pp)+/// A get_digits wrapper restricted to int values.+int get_int_digits(char_u **pp) {-  char_u *p = *pp;-  long retval = atol((char *)p);+  intmax_t number = get_digits(pp);+  assert(number >= INT_MIN && number <= INT_MAX);+  return (int)number;+} -  if (*p == '-') {-    // skip negative sign-    ++p;-  }-  // skip to next non-digit-  p = skipdigits(p);-  *pp = p;-  return retval;+/// Get a long number from a string.+///+/// A get_digits wrapper restricted to long values.+long get_long_digits(char_u **pp)","I did in fact doubt about that when initially doing it.In the end, I opted for the more ""natural speech"" option, but it was probably the wrong option.You're right the other approach is more discoverable, and establishes a clearer pattern for function families.I'll rename them.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/1802,22900415,2015-01-13T22:20:42Z,src/nvim/memory.c,"@@ -596,9 +596,7 @@ void free_all_mem(void) # endif    /* message history */-  for (;; )-    if (delete_first_msg() == FAIL)-      break;+  while(msg_delete_first()) {;}","As far as I've seen this is the first instance of the `{;}` pattern, I though we were using just `{}`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1812,23028228,2015-01-15T17:49:51Z,src/nvim/ex_docmd.c,"@@ -2204,7 +2205,7 @@ find_ucmd (             eap->cmdidx = CMD_USER;           else             eap->cmdidx = CMD_USER_BUF;-          eap->argt = (long)uc->uc_argt;+          eap->argt = uc->uc_argt;",Member `argt` of  `struct exarg` has type `long`. Are we using additional infos why the value cannot be bigger than `INT_MAX`?,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1812,23034852,2015-01-15T19:13:39Z,src/nvim/ex_docmd.c,"@@ -2204,7 +2205,7 @@ find_ucmd (             eap->cmdidx = CMD_USER;           else             eap->cmdidx = CMD_USER_BUF;-          eap->argt = (long)uc->uc_argt;+          eap->argt = uc->uc_argt;","Note that here we are assigning an `uint32_t` to a `long`, not the other way. So, there's no problem.The variable being assigned to (eap->argt) is of type long.The value being assigned (uc->uc_argt) is a member of struct ucmd, of type uint32_t. IBefore refactoring (struct ucmd).uc_argt, I checked all values assigned to it never needed more than 4 bytes, and were always positive. Thus I refactored it into an uint32_t. Probably, the same will be true for (struct exarg).argt, but I haven't checked that yet.This was one of many places were long (and long_u) are used when only 4 bytes are required (which had sense for 16bit platforms, but not for 32bit and above).What it's true, it's that there's a missing cast here, to avoid warning for mixing signed/unsigned types, which is not being signaled because -Wconversion is not active on ex_docmd.c. The line should be:```eap->argt = (long)uc->uc_argt```",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1812,23037411,2015-01-15T19:44:52Z,src/nvim/ex_docmd.c,"@@ -2204,7 +2205,7 @@ find_ucmd (             eap->cmdidx = CMD_USER;           else             eap->cmdidx = CMD_USER_BUF;-          eap->argt = (long)uc->uc_argt;+          eap->argt = uc->uc_argt;","That last statement is not exactly correct. Let me rephrase:For 64bit, uint32_t is always safely convertible to long, so everything's correct, even without cast.For 32bit, warning would be generated, for assigning unsigned to signed of the same size.Now, we know unsigned value never uses the last bit, so a simple cast to long would suffice.But that would be fragile, as it would break if new values using the last bit were introduced.So, proper solution would be to assert assigned value is not bigger than LONG_MAX.But that could generate and ""always true"" warning in 64 bits.So, definitive thing should look like:```assert((uintmax_t)uc->uc_argt <= LONG_MAX);eap->argt = (long)uc->uc_argt```I will correct to that if you agree.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1812,23046373,2015-01-15T21:45:47Z,src/nvim/ex_docmd.c,"@@ -2204,7 +2205,7 @@ find_ucmd (             eap->cmdidx = CMD_USER;           else             eap->cmdidx = CMD_USER_BUF;-          eap->argt = (long)uc->uc_argt;+          eap->argt = uc->uc_argt;","I used `grep 'argt\>' src/nvim/* -r` to look for `(struct exarg).argt`. There are only a few places where an assignment is used (`=`,`|=`). Only `uint32_t` values are assigned, so I think it would be easier to just change the type from `long` to `uint32_t` for `(struct exarg).argt`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1814,23082649,2015-01-16T14:29:34Z,test/functional/clipboard/clipboard_provider_spec.lua,"@@ -38,6 +38,26 @@ local function basic_register_test()   expect([[     some text, stuff and some more     random text]])++  -- deleting line or word uses ""1/""- and doesn't clobber ""0+  -- and deleting word to unnamed doesn't clobber ""1+  feed('ggyyjdddw""0p""1p""-P')+  expect([[+    text, stuff and some more+    some text, stuff and some more+    some random text]])++  -- delete line doesn't clobber ""-+  feed('dd""-P')+  expect([[+    text, stuff and some more+    some some text, stuff and some more]])++  -- deleting a word to named (""a) updates ""1 (and not ""-)+  feed('gg""adwj""1P^""-P')+  expect([[+    , stuff and some more+    some textsome some text, stuff and some more]])","I don't see `set clipboard=unnamed` in these tests, should we add duplicate tests for that case?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1812,23099745,2015-01-16T18:39:01Z,src/nvim/misc1.c,"@@ -1292,11 +1293,12 @@ int plines_win_nofold(win_T *wp, linenr_T lnum)   width = wp->w_width - win_col_off(wp);   if (width <= 0)     return 32000;-  if (col <= width)+  if (col <= (unsigned int)width)     return 1;   col -= width;   width += win_col_off2(wp);-  return (col + (width - 1)) / width + 1;+  assert(col <= INT_MAX);","A line should not be longer than `INT32_MAX` (`:h limits`, `win_linetabsize()`) and after a possible `col += 1` and `col -= width`, we should use `assert((int)col < INT32_MAX - (width - 1));`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1812,23104119,2015-01-16T19:42:41Z,src/nvim/option.c,"@@ -6497,8 +6499,10 @@ void comp_col(void)     if (!p_ru || last_has_status)           /* no need for separating space */       ++sc_col;   }-  sc_col = Columns - sc_col;-  ru_col = Columns - ru_col;+  assert((long)INT_MIN + sc_col <= Columns && Columns <= (long)INT_MAX + sc_col);",For `LONG_MAX` equal `INT_MAX` this won't work: `(long) INT_MAX + sc_col`,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1812,23104172,2015-01-16T19:43:42Z,src/nvim/option.c,"@@ -6497,8 +6499,10 @@ void comp_col(void)     if (!p_ru || last_has_status)           /* no need for separating space */       ++sc_col;   }-  sc_col = Columns - sc_col;-  ru_col = Columns - ru_col;+  assert((long)INT_MIN + sc_col <= Columns && Columns <= (long)INT_MAX + sc_col);+  sc_col = (int)(Columns - sc_col);+  assert((long)INT_MIN + ru_col <= Columns && Columns <= (long)INT_MAX + ru_col);",For `LONG_MAX` equal `INT_MAX` this won't work: `(long) INT_MAX + ru_col`,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1812,23124277,2015-01-17T10:16:25Z,src/nvim/option.c,"@@ -4667,7 +4664,9 @@ char_u *check_colorcolumn(win_T *wp)       col = col * getdigits_int(&s);       if (wp->w_buffer->b_p_tw == 0)         goto skip;          /* 'textwidth' not set, skip this item */-      col += wp->w_buffer->b_p_tw;+      assert(wp->w_buffer->b_p_tw >= (long)INT_MIN - col+             && wp->w_buffer->b_p_tw <= (long)INT_MAX - col);","This won't work when sizeof(long) == sizeof(int).Following the same spirit as before, I could change it to:```       assert((col >= 0                                                                          && wp->w_buffer->b_p_tw <= INT_MAX - col                                          && wp->w_buffer->b_p_tw + col >= INT_MIN)                                        || (col < 0                                                                           && wp->w_buffer->b_p_tw >= INT_MIN - col                                          && wp->w_buffer->b_p_tw + col <= INT_MAX));```But I've found it's easier if we test the opposite (not overflow condition instead of in-bounds condition):```      assert(!(col > 0 && wp->w_buffer->b_p_tw > INT_MAX - col                                   || col < 0 && wp->w_buffer->b_p_tw < INT_MIN - col));             ```I will review other asserts, to follow this shorter (and IMO, clearer) style.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1820,23125529,2015-01-17T14:28:03Z,src/nvim/tui/tui.c,"@@ -0,0 +1,630 @@+#include <assert.h>+#include <stdbool.h>+#include <stdio.h>++#include <unistd.h>++#include <uv.h>+#include <tickit.h>++#include ""nvim/lib/kvec.h""++#include ""nvim/vim.h""+#include ""nvim/ui.h""+#include ""nvim/memory.h""+#include ""nvim/api/vim.h""+#include ""nvim/os/event.h""+#include ""nvim/os/input.h""+#include ""nvim/tui/tui.h""++typedef struct {+  int top, bot, left, right;+} Rect;++typedef struct {+  char data[8];+  HlAttrs attrs;+} Cell;++typedef struct {+  TickitTerm *tt;+  TickitPen *pen;+  uv_poll_t input_handle;+  uv_signal_t winch_handle;+  uv_timer_t timer_handle;+  Rect scroll_region;+  kvec_t(Rect) invalid_regions;+  int row, col;+  int bg, fg;+  int in_fd, out_fd;+  int old_height;+  bool cursor_enabled;+  HlAttrs attrs, print_attrs;+  Cell **screen;+} TUIData;+++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""tui/tui.c.generated.h""+#endif++#define EMPTY_ATTRS ((HlAttrs){false, false, false, false, false, -1, -1})++#define FOREACH_CELL(ui, top, bot, left, right, go, code)               \+  do {                                                                  \+    TUIData *data = ui->data;                                           \+    for (int row = top; row <= bot; ++row) {                            \+      Cell *cells = data->screen[row];                                  \+      if (go) {                                                         \+        tickit_term_goto(data->tt, row, left);                          \+      }                                                                 \+      for (int col = left; col <= right; ++col) {                       \+        Cell *cell = cells + col;                                       \+        (void)(cell);                                                   \+        code;                                                           \+      }                                                                 \+    }                                                                   \+  } while(0)+++void tui_start(void)+{+  TUIData *data = xcalloc(1, sizeof(TUIData));+  data->fg = data->bg = -1;+  data->cursor_enabled = true;++  // read input from stderr if stdin is not a tty+  data->in_fd = isatty(0) ? 0 : (isatty(2) ? 2 : -1);+  // write output to stderr if stdout is not a tty+  data->out_fd = isatty(1) ? 1 : (isatty(2) ? 2 : -1);++  if (data->in_fd == -1) {+    fprintf(stderr, ""Vim: Warning: Input is not from a terminal\n"");+    data->in_fd = 0;+  }++  if (data->out_fd == -1) {+    fprintf(stderr, ""Vim: Warning: Output is not to a terminal\n"");+    data->out_fd = 1;+  }++  kv_init(data->invalid_regions);+  UI *ui = xcalloc(1, sizeof(UI));+  // setup libtickit+  data->tt = tickit_term_new();+  tickit_term_set_input_fd(data->tt, data->in_fd);+  tickit_term_set_output_fd(data->tt, data->in_fd);",`data->out_fd` instead of `data->in_fd`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1847,23223477,2015-01-20T14:05:49Z,src/nvim/msgpack_rpc/channel.c,"@@ -442,17 +442,22 @@ static void handle_request(Channel *channel, msgpack_object *request)    if (error.set) {     // Validation failed, send response with error-    channel_write(channel,-                  serialize_response(channel->id,-                                     request_id,-                                     &error,-                                     NIL,-                                     &out_buffer));-    char buf[256];-    snprintf(buf, sizeof(buf),-             ""Channel %"" PRIu64 "" sent an invalid message, closing."",-             channel->id);-    call_set_error(channel, buf);+    bool success = channel_write(channel,+                                 serialize_response(channel->id,+                                                    request_id,+                                                    &error,+                                                    NIL,+                                                    &out_buffer));++    // Checking the result of the above write because the channel may+    // be closed and freed.","This is a somewhat redundant comment given that `if (success)` is pretty self-documenting. In most of the source, the pattern is usually `if(channel_write(...))`, so the presence of `success` here is a luxury already. I think the comment can be removed, or at least trimmed to 1 line.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1849,23244802,2015-01-20T18:49:04Z,src/nvim/version.c,"@@ -57,7 +57,6 @@ static char *(features[]) = {   ""+cursorbind"",   ""+cursorshape"",   ""+dialog_con"",-  ""+diff"",",This is solely for `--version` and `:version` output.`has('feature')` is handled here https://github.com/neovim/neovim/blob/master/src/nvim/eval.c#L9892,
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/1849,23252398,2015-01-20T20:23:04Z,src/nvim/version.c,"@@ -57,7 +57,6 @@ static char *(features[]) = {   ""+cursorbind"",   ""+cursorshape"",   ""+dialog_con"",-  ""+diff"",","Actually there are plenty vim features which are non-optional in nvim, so perhaps we should do something with all such features in that list. I'm not sure that removing just that one is a good idea.",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/1849,23254589,2015-01-20T20:50:54Z,src/nvim/version.c,"@@ -57,7 +57,6 @@ static char *(features[]) = {   ""+cursorbind"",   ""+cursorshape"",   ""+dialog_con"",-  ""+diff"",","@Hinidu I just wanted to keep this PR well contained, since I already removed all references in the docs to `+diff`. I do agree with you though, and I already have a feature branch for that here:https://github.com/Pyrohh/neovim/commits/cleanup-version-outputThe output might need some work though, as it looks a bit odd/incomplete:```NVIM 0.0.0-alpha+201501201544 (compiled Jan 20 2015 15:44:59)Commit: 144c3fc0587ead7f51b9c02438f2a10e5747776cBuild type: DebugCompilation: /usr/bin/cc -Wconversion -g -Wall -Wextra -pedantic -Wno-unused-parameter -Wstrict-prototypes -std=gnu99 -DINCLUDE_GENERATED_DECLARATIONS -DHAVE_CONFIG_H -I/home/michael/src/neovim/build/config -I/home/michael/src/neovim/src -I/home/michael/src/neovim/.deps/usr/include -I/home/michael/src/neovim/.deps/usr/include -I/home/michael/src/neovim/.deps/usr/include/luajit-2.0 -I/usr/include -I/home/michael/src/neovim/build/src/nvim/auto -I/home/michael/src/neovim/build/includeCompiled by michael@orchid  Features included (+) or not (-):+acl      +iconv    +terminfo    system vimrc file: ""$VIM/nvimrc""     user vimrc file: ""$HOME/.nvimrc"" 2nd user vimrc file: ""~/.nvim/nvimrc""      user exrc file: ""$HOME/.exrc""  fall-back for $VIM: ""/usr/local/share/nvim""```",
911252,Hinidu,https://api.github.com/repos/neovim/neovim/pulls/1849,23254942,2015-01-20T20:55:22Z,src/nvim/version.c,"@@ -57,7 +57,6 @@ static char *(features[]) = {   ""+cursorbind"",   ""+cursorshape"",   ""+dialog_con"",-  ""+diff"",","Also worth mentioning is that I might have removed too many features from that branch, but my understanding is that platform parity is a big goal (hence the removal of the `+mouse_*` and X11 related items.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/1849,23255138,2015-01-20T20:58:15Z,src/nvim/version.c,"@@ -57,7 +57,6 @@ static char *(features[]) = {   ""+cursorbind"",   ""+cursorshape"",   ""+dialog_con"",-  ""+diff"",","Perhaps `Features included (+) or not (-):` could be changed for `Includes support for:`.Also, a list of removed features would be good to have, to make clean how nvim differs from vim: `-clipboard`, `-clientserver` `-cryptv`, etc. Just as an high level overview, there is no point in being too detailed.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1849,23264480,2015-01-20T22:57:55Z,src/nvim/version.c,"@@ -57,7 +57,6 @@ static char *(features[]) = {   ""+cursorbind"",   ""+cursorshape"",   ""+dialog_con"",-  ""+diff"",",(I accidentally replied in the main thread),
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1865,23369405,2015-01-22T11:27:59Z,src/nvim/globals.h,"@@ -140,7 +140,7 @@ EXTERN int mod_mask INIT(= 0x0);                /* current key modifiers */  * temporarily moved.  The old position is restored with the next call to  * update_screen().  */-EXTERN int cmdline_row;+EXTERN long cmdline_row;","Please note that you can't just change the type. You have to review every place where that variable is used to check the new type doesn't introduce problems.For `cmdline_row`, there are 81 such usages.Note that the fact that it compiles without errors doesn't mean anything, as many of those usages are in files where -Wconversion is not yet enabled. And, even if -Wconversion was enabled for all files, you still should manually review every usage, because of possible previous explicit casts becoming incorrect (those would not be caught by -Wconversion).As an example of something that would be broken, see, ex_getln.c:2462: `windgoto(cmdline_row, 0);`, where `windgoto()` is defined as having an `int` first parameter.So, going through that messy process would be the only way to do it correctly, if we really wanted to.But we don't need that. Because, in fact, an int is enough for that variable (you won't have a screen with more than 2Glines). That is also true for `Rows` and `p_ch` (an `int` would be enough for them). But those _must_ be `long` (because those are user options, and the way options are implemented by now, all numeric options have to be the same type, which turns out to be `long`). I'm in fact studying possible refactorings of this, to eliminate `long` from the codebase.Then, how to remove the warning to let us enable -Wconversion?In short, a safe cast.This is, check that the substraction is within `int`bounds, and cast to int:```  assert(Rows - p_ch >= INT_MIN && Rows - p_ch <= INT_MAX);  cmdline_row = (int)(Rows - p_ch);```In the general case, that wouldn't be completely correct yet, as the substraction could overflow/underflow. So, we'd have to check that substraction doesn't overflow as long, and result is within int bounds.But we don't need that in this case, as we have extra knowledge (both Rows and p_ch must be positive, and Rows >= p_ch). So, introducing all that extra knowledge in the assert (which also helps us validate our assumptions about the code), it would remain:```  assert(p_ch >= 0 && Rows >= p_ch &&  Rows - p_ch <= INT_MAX);  cmdline_row = (int)(Rows - p_ch);```It could still be improved, because it seems that Rows must be between 2 and 1000, and p_ch between 1 and Rows (exclusive). But that could be overkill, as limitation about Rows could be removed. Once both substraction and cast are safe, it's enough for me.As you see, type refactoring is a tricky thing. Please be extra-picky when dealing with it. ;-)Hope that helps.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1865,23401824,2015-01-22T19:22:47Z,src/nvim/main.c,"@@ -834,20 +808,25 @@ void getout(int exitval)   mch_exit(exitval); } -/*- * Get a (optional) count for a Vim argument.- */-static int-get_number_arg (-    char_u *p,             /* pointer to argument */-    int *idx,           /* index in argument, is incremented */-    int def                    /* default value */-)+/// Gets the integer value of a numeric command line argument if given,+/// such as '-o10'.+///+/// @param p pointer to argument+/// @param idx pointer to index in argument","I'm a little confused after reading this: http://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmdparamGiven that `*idx` is a parameter that is modifed, would the following be satisfactory?```/// @param[in] p pointer to argument/// @param[in,out] idx pointer to index in argument/// @param[in] def default value```",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1865,23417291,2015-01-22T22:43:04Z,src/nvim/main.c,"@@ -293,7 +276,8 @@ int main(int argc, char **argv)   if (params.diff_mode)     diff_win_options(firstwin, FALSE); -  cmdline_row = Rows - p_ch;+  assert(p_ch >= 0 && Rows >= p_ch && Rows - p_ch <= INT_MAX);+  cmdline_row = (int)Rows - p_ch;","The assert is wrong. I wrote `(int)(Rows - p_ch)`, not `(int)Rows - p_ch`.What you have written behaves this way:- Rows is converted to int.- Before doing substraction, as you have an int and a long (p_ch), the int gets promoted to long again.- The substraction is done.- Result of the substraction (long) is going to be assigned to an int var (cmdline_row), loosing precision. Thus the warning.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1850,23425504,2015-01-23T01:13:11Z,runtime/doc/various.txt,"@@ -19,9 +19,9 @@ CTRL-L			Clear and redraw the screen.  The redraw may happen 							*:redr* *:redraw* :redr[aw][!]		Redraw the screen right now.  When ! is included it is 			cleared first.-			Useful to update the screen halfway executing a script-			or function.  Also when halfway a mapping and-			'lazyredraw' is set.+			Useful to update the screen halfway through executing+			a script or function.  Also when halfway through a+			mapping and 'lazyredraw' is set.","> Useful to update the screen halfway through executing a script or function (or a mapping, if 'lazyredraw' is set).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1850,23425622,2015-01-23T01:15:25Z,runtime/doc/visual.txt,"@@ -492,7 +492,8 @@ Otherwise, typed characters are handled as in Visual mode.  When using an operator in Select mode, and the selection is linewise, the selected lines are operated upon, but like in characterwise selection.  For-example, when a whole line is deleted, it can later be pasted halfway a line.+example, when a whole line is deleted, it can later be pasted halfway through+a line.","""in the middle of a line"" ?",
2071,JackDanger,https://api.github.com/repos/neovim/neovim/pulls/1850,23431329,2015-01-23T04:29:22Z,runtime/doc/usr_04.txt,"@@ -201,7 +201,8 @@ change.  Then you can use Visual mode. You start Visual mode by pressing ""v"".  You move the cursor over the text you want to work on.  While you do this, the text is highlighted.  Finally type the operator command.-   For example, to delete from halfway one word to halfway another word:+   For example, to delete from halfway through one word to halfway through+   another word:",Changing:`to delete from halfway through one word to halfway through another word:`->`to delete from the middle of a word to the middle of another:` (fits on one line),
2071,JackDanger,https://api.github.com/repos/neovim/neovim/pulls/1850,23432235,2015-01-23T05:09:08Z,src/nvim/move.c,"@@ -1630,8 +1630,8 @@ void scroll_cursor_bot(int min_scroll, int set_topbot) }  /*- * Recompute topline to put the cursor halfway the window- * If ""atend"" is TRUE, also put it halfway at the end of the file.+ * Recompute topline to put the cursor halfway across the window+ * If ""atend"" is TRUE, also put it halfway to the end of the file.  */",I've updated the comment style but I'm having a really hard time understanding what the `atend` parameter does exactly so I didn't try rephrasing its description.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1850,23432543,2015-01-23T05:22:40Z,runtime/doc/various.txt,"@@ -19,9 +19,9 @@ CTRL-L			Clear and redraw the screen.  The redraw may happen 							*:redr* *:redraw* :redr[aw][!]		Redraw the screen right now.  When ! is included it is 			cleared first.-			Useful to update the screen halfway executing a script-			or function.  Also when halfway a mapping and-			'lazyredraw' is set.+                        Useful to update the screen halfway through executing+                        a script or function (or a mapping if 'lazyredraw'+                        set).","https://github.com/tpope/vim-sleuth might help with this, as we as `set list`.",
2071,JackDanger,https://api.github.com/repos/neovim/neovim/pulls/1846,23433429,2015-01-23T06:04:26Z,src/nvim/msgpack_rpc/channel.c,"@@ -721,7 +720,12 @@ static void complete_call(msgpack_object *obj, Channel *channel)   } } -static void call_set_error(Channel *channel, char *msg)+/// Set the channel's call stack to indicate error state.+/// Closes and frees the channel.+///+/// @param channel The Channel to close.",Great idea. I've removed the comment on the obvious parameter.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1883,23500660,2015-01-25T00:20:00Z,test/functional/ui/screen.lua,"@@ -54,12 +54,17 @@ -- having the exact same set of attributes will be substituted by ""{K:S}"", -- where K is a key associated the attribute set via the second argument of -- ""expect"".+-- If a transformation table is present, unexpected attribute sets in the final+-- state is considered an error. To make testing simpler, a list of attribute sets that+-- should be ignored can be passed as a third argument. Alternatively, this third+-- argument can be ""true"" to indicate that all unexpected attribute sets should be ignored.",Do we also use a maximum of 80 columns for lua files? `:set colorcolumn=80` shows somelines longer than that.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1844,23501431,2015-01-25T02:44:33Z,test/functional/job/job_spec.lua,"@@ -104,6 +104,17 @@ describe('jobs', function()     nvim('eval', 'jobsend(j, ""abcdef"")')     nvim('eval', 'jobstop(j)')     eq({'notification', 'j', {{jobid, 'stdout', {'abcdef'}}}}, next_message())-    eq({'notification', 'j', {{jobid, 'exit'}}}, next_message())+    eq({'notification', 'j', {{jobid, 'exit', 0}}}, next_message())+  end)++  it('will return the proper exit status for the job', function()+    nvim('command', notify_job())+    nvim('command', ""let j = jobstart('xxx', 'cat', ['/dev/null/fake'])"")+    local jobid = nvim('eval', 'j')+    next_message()+    eq({'notification', 'j', {{jobid, 'exit', 1}}}, next_message())+    nvim('command', ""let j = jobstart('xxx', 'bash', ['-c', 'exit 100'])"")+    local jobid = nvim('eval', 'j')+    eq({'notification', 'j', {{jobid, 'exit', 100}}}, next_message())","How about a negative number too, and a really large number",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1800,23577459,2015-01-27T00:23:11Z,src/nvim/api/vim.c,"@@ -133,7 +133,7 @@ String vim_command_output(String str, Error *err)   return cstr_to_string((char *)get_vim_var_str(VV_COMMAND_OUTPUT)); } -/// Evaluates the expression str using the vim internal expression+/// Evaluates the expression str using vim's internal expression","`the vim internal expression` remember that neovim is vim, and for purposes of technical documentation, vim concepts are still vim concepts. We don't need to take ownership of vim concepts. nvim is vim.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1910,23867543,2015-01-30T19:52:38Z,runtime/doc/options.txt,"@@ -5560,7 +5560,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	old Vi scripts.  						*'renderoptions'* *'rop'*-'renderoptions' 'rop'	Removed. {Nvim} will choose the best renderer available.+'renderoptions' 'rop'	Removed. {Nvim}","I think adding reasoning for removal is a good idea, but not here. This is the only removed option with a description, and it's incomplete. Perhaps we can just replace `vi_diff.txt` with `nvim_diff.txt`, then tack on `(See |nvim-diff-options|)` to the end of each removed option in `options.txt`.I can convert this PR, or just open a new one for a cleaner comment history.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/1926,23903462,2015-02-02T00:37:30Z,runtime/doc/syntax.txt,"@@ -4789,10 +4791,10 @@ ModeMsg		'showmode' message (e.g., ""-- INSERT --"") 							*hl-MoreMsg* MoreMsg		|more-prompt| 							*hl-NonText*-NonText		'~' and '@' at the end of the window, characters from-		'showbreak' and other characters that do not really exist in-		the text (e.g., "">"" displayed when a double-wide character-		doesn't fit at the end of the line).+NonText		'@' at the end of the window, characters from 'showbreak' +		and other characters that do not really exist in the text +		(e.g., "">"" displayed when a double-wide character doesn't +		fit at the end of the line).","Sure, but why? There is ""nothing to see"" there. `EndOfBuffer` is described as an independent thing to `NonText`, and viceversa. Perhaps it would be best to add a note mentioning that `EndOfBuffer` is highlighted the same as `NonText` by default.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1894,23909221,2015-02-02T06:52:40Z,src/nvim/main.c,"@@ -2057,93 +2057,66 @@ static void mainerr(int n, const char *str) }  -/*- * print a message with three spaces prepended and '\n' appended.- */-static void main_msg(char *s)-{-  mch_msg(""   "");-  mch_msg(s);-  mch_msg(""\n"");-}--/*- * Print messages for ""vim -h"" or ""vim --help"" and exit.- */+/// Prints help message and exits; used for 'nvim -h' & 'nvim --help' static void usage(void) {-  int i;-  static char *(use[]) =-  {-    N_(""[file ..]       edit specified file(s)""),-    N_(""-               read text from stdin""),-    N_(""-t tag          edit file where tag is defined""),-    N_(""-q [errorfile]  edit file with first error"")-  };--  signal_stop();              /* kill us with CTRL-C here, if you like */--  mch_msg(longVersion);",Why not print `longVersion`? It's a pretty common tradition with unix tools.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1894,23911511,2015-02-02T08:24:30Z,src/nvim/main.c,"@@ -2057,93 +2057,66 @@ static void mainerr(int n, const char *str) }  -/*- * print a message with three spaces prepended and '\n' appended.- */-static void main_msg(char *s)-{-  mch_msg(""   "");-  mch_msg(s);-  mch_msg(""\n"");-}--/*- * Print messages for ""vim -h"" or ""vim --help"" and exit.- */+/// Prints help message and exits; used for 'nvim -h' & 'nvim --help' static void usage(void) {-  int i;-  static char *(use[]) =-  {-    N_(""[file ..]       edit specified file(s)""),-    N_(""-               read text from stdin""),-    N_(""-t tag          edit file where tag is defined""),-    N_(""-q [errorfile]  edit file with first error"")-  };--  signal_stop();              /* kill us with CTRL-C here, if you like */--  mch_msg(longVersion);","I haven't seen it done anywhere else, but regardless I think it's just noise. I don't see how it's in any way helpful given that --version and the intro screen already include it.On February 2, 2015 1:53:02 AM EST, ""Justin M. Keyes"" notifications@github.com wrote:> >  static void usage(void)> >  {> > -  int i;> > -  static char *(use[]) => > -  {> > -    N_(""[file ..]       edit specified file(s)""),> > -    N_(""-               read text from stdin""),> > -    N_(""-t tag          edit file where tag is defined""),> > -    N_(""-q [errorfile]  edit file with first error"")> > > > ## \-  };> > -  signal_stop();              /\* kill us with CTRL-C here, if you> >   like */> >   -> > -  mch_msg(longVersion);> > Why not print `longVersion`? It's a pretty common tradition with unix> tools.> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1894/files#r23909221",
10798839,lucashn,https://api.github.com/repos/neovim/neovim/pulls/1923,23920357,2015-02-02T12:02:10Z,src/nvim/version.c,"@@ -1027,7 +1029,10 @@ void intro_message(int colon)   };    // blanklines = screen height - # message lines-  blanklines = (int)Rows - (ARRAY_SIZE(lines) - 1);+  size_t lines_size = ARRAY_SIZE(lines);","lines_size should always fit in a long, as the intro message is short.",
10798839,lucashn,https://api.github.com/repos/neovim/neovim/pulls/1923,23920500,2015-02-02T12:06:15Z,src/nvim/version.c,"@@ -1106,7 +1112,8 @@ static void do_intro_line(int row, char_u *mesg, int attr)         clen += byte2cells(p[l]);       }     }-    screen_puts_len(p, l, row, col, *p == '<' ? hl_attr(HLF_8) : attr);+    assert(row < INT_MAX && col < INT_MAX);","screen_puts_len is called in many places in the code base. I think in the future it should be refactored to the _row_ and _col_ parameters to be _long_, and not _int_.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1923,23957853,2015-02-02T20:58:21Z,src/nvim/version.c,"@@ -1027,7 +1029,10 @@ void intro_message(int colon)   };    // blanklines = screen height - # message lines-  blanklines = (int)Rows - (ARRAY_SIZE(lines) - 1);+  size_t lines_size = ARRAY_SIZE(lines);+  assert(lines_size <= LONG_MAX && Rows > 0l);++  blanklines = Rows - ((int)lines_size - 1l);","I think you wanted to cast to `long`, not to `int` (assertion checked long limit).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1820,24130163,2015-02-04T23:23:02Z,src/nvim/tui/tui.c,"@@ -0,0 +1,718 @@+#include <assert.h>+#include <stdbool.h>+#include <stdio.h>++#include <unistd.h>+#include <sys/ioctl.h>++#include <uv.h>+#include <termkey.h>+#include <unibilium.h>++#include ""nvim/lib/kvec.h""++#include ""nvim/vim.h""+#include ""nvim/ui.h""+#include ""nvim/memory.h""+#include ""nvim/api/vim.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/os/event.h""+#include ""nvim/os/input.h""+#include ""nvim/tui/tui.h""++typedef struct {+  int top, bot, left, right;+} Rect;++typedef struct {+  char data[8];",Why is this array `8` chars big? Longest UTF-8 + NUL would be at most `7` chars.,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1947,24260063,2015-02-06T18:24:47Z,src/nvim/msgpack_rpc/channel.c,"@@ -312,6 +315,9 @@ bool channel_close(uint64_t id)   }    close_channel(channel);+  if (!kv_size(channel->call_stack)) {","Well, yes. In fact I had done it that way the first time. I did that optimization later, as at that point, we know channel is not closed, so we can save checking one condition (and the function call).But I have no problem in changing it back to previous situation, if its considered better from a readability point of view.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/1947,24262251,2015-02-06T18:54:34Z,src/nvim/msgpack_rpc/channel.c,"@@ -312,6 +315,9 @@ bool channel_close(uint64_t id)   }    close_channel(channel);+  if (!kv_size(channel->call_stack)) {","Honestly, me too. I'd prefer just one single place where real freeing is done.I just thought others would not like checking redundant conditions.But if nobody opposes, I'll change it so that only one place encapsulates conditions to be able to free, and only one place calls channel_free.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1900,24292345,2015-02-07T20:03:26Z,.travis.yml,"@@ -5,7 +5,7 @@ env:   global:     - CI_SCRIPTS=$TRAVIS_BUILD_DIR/.ci     # To build third-party dependencies, set this to 'true'.-    - BUILD_NVIM_DEPS=false+    - BUILD_NVIM_DEPS=true","this is temporary, right?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1910,24303717,2015-02-08T23:09:35Z,runtime/doc/options.txt,"@@ -4379,7 +4380,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	NOTE: This option is set when 'compatible' is set.  					*'key'*-'key'			Removed. {Nvim}+'key'			Removed; see |vim-differences|.","it's customary in vim help to just plop a tag right after a word, without using extra verbiage such as ""see"". (There are some exceptions). So how about this:```'key'           Removed. |vim-differences| {Nvim}```Because we're going to need this pattern in many places, I would like to settle on a very terse convention.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1910,24304507,2015-02-09T00:13:45Z,runtime/doc/vim_diff.txt,"@@ -0,0 +1,96 @@+*vim_diff.txt*    For Nvim.						{Nvim}+++			    NVIM REFERENCE MANUAL+++Differences between Nvim and Vim			       *vim-differences*++Throughout the help files, differences between Nvim and Vim are indicated via+the ""{Nvim}"" tag.  This document is a complete and centralized list of all+these differences.++1. Configuration		|nvim-configuration|+2. Option defaults		|nvim-option-defaults|+3. Changed features		|nvim-features-changed|+4. New features			|nvim-features-new|+5. Missing legacy features	|nvim-features-missing|+6. Removed features		|nvim-features-removed|+++==============================================================================+1. Configuration					    *nvim-configuration*++- Use "".nvimrc"" instead of "".vimrc"" for storing configuration.+- Use "".nvim"" instead of "".vim"" to store configuration files.+- Use "".nviminfo"" instead of "".viminfo"" for persistent session information.++==============================================================================+2. Option defaults					  *nvim-option-defaults*++- 'nocompatible' is always set ("":set nocp"" is ignored; "":set cp"" is an error)+- 'encoding' defaults to ""utf-8""++==============================================================================+3. Changed features					 *nvim-features-changed*++Nvim always ships with all features, in contrast to Vim which may have+certain features removed depending at compile-time.  This is like if Vim's+""HUGE"" build was the only Vim release type (except Nvim is smaller than+Vim's ""HUGE"" build).++Assuming a python interpreter is installed, |:python| and |:python3| are+always available and may be used simultaneously in separate plugins.  The+`neovim` pip package must be installed for Nvim python plugins to work.  You+don't need to worry about link-time details or ABI incompatibilities.++==============================================================================+4. New Features						     *nvim-features-new*++See |nvim-intro| for a list of Nvim's largest new features.++- |hl-EndOfBuffer|++==============================================================================+5. Missing legacy features				 *nvim-features-missing*++These legacy Vim features are not present currently, but may be implemented in+the future:++- vim.bindeval() (new feature in Vim 7.4 python interface)+- if_lua+- if_mzscheme+- if_perl+- if_ruby+- if_tcl++==============================================================================+6. Removed features					 *nvim-features-removed*++These options are in Vim, but have been removed from Nvim:++- EBCDIC support++- 8.3 filesystem support+  - 'shortname'++- Encryption support+  - 'cryptmethod'+  - 'key'++- MS-DOS support+  - 'bioskey'+  - 'conskey'","I reduced the indentation level by two spaces, so top-most items like `8.3 filesystem support` and `Encryption support` now lack bullets. I'm not sure if this is what you wanted, but IMO bullets make sense when listing off individual points under larger fields.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1925,24306147,2015-02-09T02:09:59Z,runtime/doc/options.txt,"@@ -4872,8 +4741,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	languages, no matter what you set 'mkspellmem' to.  				   *'modeline'* *'ml'* *'nomodeline'* *'noml'*-'modeline' 'ml'		boolean	(Vim default: on (off for root),-				 Vi default: off)+'modeline' 'ml'		boolean	(default: on (off for root))","These types of ""Vi default ..."" notes are still relevant because we support the `set foo&vi` invocation. E.g.:```set modeline&vi```Will set `modeline` to ""off"". And I see no reason to _remove_ support for `&vi` because it doesn't add complexity, it's basically just a set of defaults listed in the `option.c:vimoption_T` table.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1925,24307647,2015-02-09T03:28:49Z,runtime/doc/options.txt,"@@ -6200,8 +6060,8 @@ A jump table for the options with a short description can be found at |Q_op|. 	""n"" flag to 'cpoptions'.  				     *'showcmd'* *'sc'* *'noshowcmd'* *'nosc'*-'showcmd' 'sc'		boolean	(Vim default: on, off for Unix, Vi default:-				 off)+'showcmd' 'sc'		boolean	(Vim default: on (off for Unix),","Something similar is done above (line 4749: `Vim default: on (off for root),`).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1925,24308291,2015-02-09T04:08:18Z,runtime/doc/options.txt,"@@ -7594,9 +7438,10 @@ A jump table for the options with a short description can be found at |Q_op|. 	but the Windows version of Vim can source unix format scripts.  				*'viminfo'* *'vi'* *E526* *E527* *E528*-'viminfo' 'vi'		string	(Vi default: """", Vim default for MS-DOS,-				   Windows: '100,<50,s10,h,rA:,rB:,-				   for others: '100,<50,s10,h)+'viminfo' 'vi'		string	(Vim default for+				   Win32: ""'100,<50,s10,h,rA:,rB:"",+				   others: ""'100,<50,s10,h"",","I think the quotation marks should be removed. I only mention this because there's other cases of flags lists like this, and I don't want to change them. (It's not a clear win, and most are used to the existing convention)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1925,24308429,2015-02-09T04:16:10Z,runtime/doc/options.txt,"@@ -7594,9 +7438,10 @@ A jump table for the options with a short description can be found at |Q_op|. 	but the Windows version of Vim can source unix format scripts.  				*'viminfo'* *'vi'* *E526* *E527* *E528*-'viminfo' 'vi'		string	(Vi default: """", Vim default for MS-DOS,-				   Windows: '100,<50,s10,h,rA:,rB:,-				   for others: '100,<50,s10,h)+'viminfo' 'vi'		string	(Vim default for+				   Win32: ""'100,<50,s10,h,rA:,rB:"",+				   others: ""'100,<50,s10,h"",","> I only mention this because there's other cases of flags lists like this, and I don't want to change themYou sure? I just stepped through all results for `Vi default` and pretty much every result is either an integer, boolean, or quoted string.edit: did the same for `default:`, case insensitive.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1820,24593559,2015-02-12T16:21:12Z,src/nvim/tui/term_input.inl,"@@ -0,0 +1,209 @@+#include <termkey.h>++#include ""nvim/os/os.h""+#include ""nvim/os/input.h""+#include ""nvim/os/rstream.h""+++struct term_input {+  int in_fd;+  TermKey *tk;+  uv_tty_t input_handle;+  uv_timer_t timer_handle;+  RBuffer *read_buffer;+  RStream *read_stream;+};++static void forward_simple_utf8(TermKeyKey *key)+{+  size_t len = 0;+  char buf[64];+  char *ptr = key->utf8;++  while (*ptr) {+    if (*ptr == '<') {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""<lt>"");+    } else {+      buf[len++] = *ptr;+    }+    ptr++;+  }++  buf[len] = 0;+  input_enqueue((String){.data = buf, .size = len});+}++static void forward_modified_utf8(TermKey *tk, TermKeyKey *key)+{+  size_t len;+  char buf[64];++  if (key->type == TERMKEY_TYPE_KEYSYM+      && key->code.sym == TERMKEY_SYM_ESCAPE) {+    len = (size_t)snprintf(buf, sizeof(buf), ""<Esc>"");+  } else {+    len = termkey_strfkey(tk, buf, sizeof(buf), key, TERMKEY_FORMAT_VIM);+  }++  input_enqueue((String){.data = buf, .size = len});+}++static void forward_mouse_event(TermKey *tk, TermKeyKey *key)+{+  char buf[64];+  size_t len = 0;+  int button, row, col;+  TermKeyMouseEvent ev;+  termkey_interpret_mouse(tk, key, &ev, &button, &row, &col);++  if (ev != TERMKEY_MOUSE_PRESS && ev != TERMKEY_MOUSE_DRAG) {+    return;+  }++  row--; col--;  // Termkey uses 1-based coordinates+  buf[len++] = '<';++  if (key->modifiers & TERMKEY_KEYMOD_SHIFT) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""S-"");+  }++  if (key->modifiers & TERMKEY_KEYMOD_CTRL) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""C-"");+  }++  if (key->modifiers & TERMKEY_KEYMOD_ALT) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""A-"");+  }++  if (button == 1) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""Left"");+  } else if (button == 2) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""Middle"");+  } else if (button == 3) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""Right"");+  }++  if (ev == TERMKEY_MOUSE_PRESS) {+    if (button == 4) {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""ScrollWheelUp"");+    } else if (button == 5) {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""ScrollWheelDown"");+    } else {+      len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""Mouse"");+    }+  } else if (ev == TERMKEY_MOUSE_DRAG) {+    len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""Drag"");+  }++  len += (size_t)snprintf(buf + len, sizeof(buf) - len, ""><%d,%d>"", col, row);+  input_enqueue((String){.data = buf, .size = len});+}++static TermKeyResult tk_getkey(TermKey *tk, TermKeyKey *key, bool force)+{+  return force ? termkey_getkey_force(tk, key) : termkey_getkey(tk, key);+}++static void timer_cb(uv_timer_t *handle);++static void tk_getkeys(TermInput *input, bool force)+{+  TermKeyKey key;+  TermKeyResult result;++  while ((result = tk_getkey(input->tk, &key, force)) == TERMKEY_RES_KEY) {+    if (key.type == TERMKEY_TYPE_UNICODE && !key.modifiers) {+      forward_simple_utf8(&key);+    } else if (key.type == TERMKEY_TYPE_UNICODE ||+               key.type == TERMKEY_TYPE_FUNCTION ||+               key.type == TERMKEY_TYPE_KEYSYM) {+      forward_modified_utf8(input->tk, &key);+    } else if (key.type == TERMKEY_TYPE_MOUSE) {+      forward_mouse_event(input->tk, &key);+    }+  }++  if (result != TERMKEY_RES_AGAIN) {+    return;+  }++  Integer ms = 0;+  bool timeout = false;+  // Check 'timeout' and 'ttimeout' to determine if we should send ESC+  // after 'ttimeoutlen'. See :help 'ttimeout' for more information+  Error err;+  timeout = vim_get_option(cstr_as_string(""timeout""), &err).data.boolean;+  if (!timeout) {+    timeout = vim_get_option(cstr_as_string(""ttimeout""), &err).data.boolean;+  }++  if (timeout) {+    ms = vim_get_option(cstr_as_string(""ttimeoutlen""), &err).data.integer;+  }++  if (ms > 0) {+    // Stop the current timer if already running+    uv_timer_stop(&input->timer_handle);+    uv_timer_start(&input->timer_handle, timer_cb, (uint32_t)ms, 0);+  } else {+    tk_getkeys(input, true);+  }+}++static void timer_cb(uv_timer_t *handle)+{+  tk_getkeys(handle->data, true);+}++static void read_cb(RStream *rstream, void *rstream_data, bool eof)+{+  if (eof) {+    input_done();+    return;+  }++  TermInput *input = rstream_data;++  do {+    size_t consumed = termkey_push_bytes(input->tk,+        rbuffer_read_ptr(input->read_buffer),+        rbuffer_pending(input->read_buffer));+    rbuffer_consumed(input->read_buffer, consumed);+    tk_getkeys(input, false);+  } while (rbuffer_pending(input->read_buffer));+}++static TermInput *term_input_new(void)+{+  TermInput *rv = xmalloc(sizeof(TermInput));+  // read input from stderr if stdin is not a tty+  rv->in_fd = isatty(0) ? 0 : (isatty(2) ? 2 : 0);+  rv->tk = termkey_new_abstract(os_getenv(""TERM""), 0);+  int curflags = termkey_get_canonflags(rv->tk);+  termkey_set_canonflags(rv->tk, curflags | TERMKEY_CANON_DELBS);+  // setup input handle+  uv_tty_init(uv_default_loop(), &rv->input_handle, rv->in_fd, 1);+  uv_tty_set_mode(&rv->input_handle, UV_TTY_MODE_RAW);+  rv->input_handle.data = NULL;+  rv->read_buffer = rbuffer_new(0xfff);+  rv->read_stream = rstream_new(read_cb, rv->read_buffer, rv);+  rstream_set_stream(rv->read_stream, (uv_stream_t *)&rv->input_handle);+  rstream_start(rv->read_stream);+  // initialize a timer handle for handling ESC with libtermkey+  uv_timer_init(uv_default_loop(), &rv->timer_handle);+  rv->timer_handle.data = rv;+  return rv;+}++static void term_input_destroy(TermInput *input)+{+  uv_tty_reset_mode();+  uv_timer_stop(&input->timer_handle);+  rstream_stop(input->read_stream);+  rstream_free(input->read_stream);+  uv_close((uv_handle_t *)&input->input_handle, NULL);",Missing `free(input->input_handle.data);`,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1979,24610732,2015-02-12T19:18:37Z,src/nvim/mark.c,"@@ -1499,12 +1501,13 @@ void copy_viminfo_marks(vir_T *virp, FILE *fp_out, int count, int eof, int flags       if (load_marks) {         if (line[1] != NUL) {           int64_t lnum_64;-          unsigned u;+          unsigned int u;","This is only stylistic, but why do you say `unsigned int` as opposed to `unsigned`? I don't do it myself for brevity, but then again it makes sense for consistency with types like `unsigned long` and `unsigned char`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1820,24622626,2015-02-12T21:35:37Z,src/nvim/tui/tui.c,"@@ -0,0 +1,718 @@+#include <assert.h>+#include <stdbool.h>+#include <stdio.h>++#include <uv.h>+#include <unibilium.h>++#include ""nvim/lib/kvec.h""++#include ""nvim/vim.h""+#include ""nvim/ui.h""+#include ""nvim/map.h""+#include ""nvim/memory.h""+#include ""nvim/api/vim.h""+#include ""nvim/api/private/helpers.h""+#include ""nvim/os/event.h""+#include ""nvim/tui/tui.h""++typedef struct term_input TermInput;++#include ""term_input.inl""++typedef struct {+  int top, bot, left, right;+} Rect;++typedef struct {+  char data[7];+  HlAttrs attrs;+} Cell;++typedef struct {+  PMap(cstr_t) *option_cache;+  unibi_var_t params[9];+  char buf[0xffff];+  size_t bufpos;+  TermInput *input;+  uv_loop_t *write_loop;+  unibi_term *ut;+  uv_tty_t output_handle;+  uv_signal_t winch_handle;+  Rect scroll_region;+  kvec_t(Rect) invalid_regions;+  int row, col;+  int bg, fg;+  int out_fd;+  int old_height;+  bool can_use_terminal_scroll;+  HlAttrs attrs, print_attrs;+  Cell **screen;+  struct {+    size_t enable_mouse, disable_mouse;+  } unibi_ext;+} TUIData;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""tui/tui.c.generated.h""+#endif++#define EMPTY_ATTRS ((HlAttrs){false, false, false, false, false, -1, -1})++#define FOREACH_CELL(ui, top, bot, left, right, go, code)               \+  do {                                                                  \+    TUIData *data = ui->data;                                           \+    for (int row = top; row <= bot; ++row) {                            \+      Cell *cells = data->screen[row];                                  \+      if (go) {                                                         \+        unibi_goto(ui, row, left);                                      \+      }                                                                 \+      for (int col = left; col <= right; ++col) {                       \+        Cell *cell = cells + col;                                       \+        (void)(cell);                                                   \+        code;                                                           \+      }                                                                 \+    }                                                                   \+  } while (0)+++void tui_start(void)+{+  TUIData *data = xcalloc(1, sizeof(TUIData));+  UI *ui = xcalloc(1, sizeof(UI));+  ui->data = data;+  data->attrs = data->print_attrs = EMPTY_ATTRS;+  data->fg = data->bg = -1;+  data->can_use_terminal_scroll = true;+  data->bufpos = 0;+  data->option_cache = pmap_new(cstr_t)();++  // write output to stderr if stdout is not a tty+  data->out_fd = isatty(1) ? 1 : (isatty(2) ? 2 : 1);+  kv_init(data->invalid_regions);+  // setup term input+  data->input = term_input_new();+  // setup unibilium+  data->ut = unibi_from_env();+  if (!data->ut) {+    // For some reason could not read terminfo file, use a dummy entry that+    // will be populated with common values by fix_terminfo below+    data->ut = unibi_dummy();+  }+  fix_terminfo(data);+  // Enter alternate screen and clear+  unibi_out(ui, unibi_enter_ca_mode, NULL);+  unibi_out(ui, unibi_clear_screen, NULL);++  // setup output handle in a separate event loop(we wanna do synchronous+  // write to the tty)+  data->write_loop = xmalloc(sizeof(uv_loop_t));+  uv_loop_init(data->write_loop);+  uv_tty_init(data->write_loop, &data->output_handle, data->out_fd, 0);++  // Obtain screen dimensions+  update_size(ui);++  // listen for SIGWINCH+  uv_signal_init(uv_default_loop(), &data->winch_handle);+  uv_signal_start(&data->winch_handle, sigwinch_cb, SIGWINCH);+  data->winch_handle.data = ui;++  ui->stop = tui_stop;+  ui->rgb = false;+  ui->data = data;+  ui->resize = tui_resize;+  ui->clear = tui_clear;+  ui->eol_clear = tui_eol_clear;+  ui->cursor_goto = tui_cursor_goto;+  ui->cursor_on = tui_cursor_on;+  ui->cursor_off = tui_cursor_off;+  ui->mouse_on = tui_mouse_on;+  ui->mouse_off = tui_mouse_off;+  ui->insert_mode = tui_insert_mode;+  ui->normal_mode = tui_normal_mode;+  ui->set_scroll_region = tui_set_scroll_region;+  ui->scroll = tui_scroll;+  ui->highlight_set = tui_highlight_set;+  ui->put = tui_put;+  ui->bell = tui_bell;+  ui->visual_bell = tui_visual_bell;+  ui->update_fg = tui_update_fg;+  ui->update_bg = tui_update_bg;+  ui->flush = tui_flush;+  ui->suspend = tui_suspend;+  ui->set_title = tui_set_title;+  ui->set_icon = tui_set_icon;+  // Attach+  ui_attach(ui);+}++static void tui_stop(UI *ui)+{+  TUIData *data = ui->data;+  // Destroy common stuff+  kv_destroy(data->invalid_regions);+  uv_signal_stop(&data->winch_handle);+  uv_close((uv_handle_t *)&data->winch_handle, NULL);+  // Destroy input stuff+  term_input_destroy(data->input);+  // Destroy output stuff+  tui_normal_mode(ui);+  tui_mouse_off(ui);+  unibi_out(ui, unibi_exit_attribute_mode, NULL);+  unibi_out(ui, unibi_cursor_normal, NULL);+  unibi_out(ui, unibi_exit_ca_mode, NULL);+  flush_buf(ui);+  uv_close((uv_handle_t *)&data->output_handle, NULL);+  uv_run(data->write_loop, UV_RUN_DEFAULT);+  if (uv_loop_close(data->write_loop)) {+    abort();+  }+  free(data->write_loop);+  unibi_destroy(data->ut);+  char *opt_value;+  map_foreach_value(data->option_cache, opt_value, {+    free(opt_value);+  });+  pmap_free(cstr_t)(data->option_cache);+  ui_detach(ui);+}","`tui_stop()` needs to free some more pointers. Memory leaks can add up when `tui_suspend()` is called a few times.``` diffdiff --git a/src/nvim/tui/tui.c b/src/nvim/tui/tui.cindex 92e35e5..527954e 100644--- a/src/nvim/tui/tui.c+++ b/src/nvim/tui/tui.c@@ -175,6 +175,16 @@ static void tui_stop(UI *ui)     free(opt_value);   });   pmap_free(cstr_t)(data->option_cache);++  if (data->screen) {+    for (int i = 0; i < data->old_height; i++) {+      free(data->screen[i]);+    }+    free(data->screen);+  }+  free(data);+  free(ui);+   ui_detach(ui); }```",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1820,24729672,2015-02-16T02:34:46Z,config/config.h.in,"@@ -70,7 +69,6 @@ #cmakedefine HAVE_WORKING_LIBINTL #define RETSIGTYPE void #define SIGRETURN return-#define TERMINFO 1 #define TGETENT_ZERO_ERR 0",`TGETENT_ZERO_ERR` and `FEAT_TERMRESPONSE` look unused.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/1981,24737457,2015-02-16T08:47:03Z,src/nvim/api/private/helpers.c,"@@ -644,10 +644,8 @@ static Object vim_to_object_rec(typval_T *obj, PMap(ptr_t) *lookup)    switch (obj->v_type) {     case VAR_STRING:-      if (obj->vval.v_string != NULL) {-        rv.type = kObjectTypeString;-        rv.data.string = cstr_to_string((char *) obj->vval.v_string);-      }+      rv.type = kObjectTypeString;+      rv.data.string = cstr_to_string((char *) obj->vval.v_string);","Well, in this case, NULLs are already checked (and interpreted correctly) in `cstr_to_string`, but to make it more explicit, I could instead add an `else { rv.data.string = (String) STRING_INIT }` here. What do you think?",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2012,24898185,2015-02-18T12:45:19Z,src/nvim/option_defs.h,"@@ -329,7 +329,7 @@ EXTERN long p_ch;               /* 'cmdheight' */ EXTERN int p_confirm;           /* 'confirm' */ EXTERN int p_cp;                /* 'compatible' */ EXTERN char_u   *p_cot;         /* 'completeopt' */-EXTERN long p_ph;               /* 'pumheight' */+EXTERN int p_ph;               /* 'pumheight' */","You can't change this to `int`.This is a global var for an option. The way options are implemented, all numeric options have to be the same type (currently `long`). We will eventually refactor that, because in fact, we want to get rid of type `long` (which is different size on Win64 than on other platforms), but it has to be done at the same time for all options. You can't just change one of them.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2012,24899107,2015-02-18T13:05:19Z,src/nvim/globals.h,"@@ -72,7 +72,7 @@ EXTERN long Rows                        /* nr of rows in the screen */   = 24L #endif ;-EXTERN long Columns INIT(= 80);         /* nr of columns in the screen */+EXTERN int Columns INIT(= 80);         /* nr of columns in the screen */","Forget the above. Everything I said is true if you could change `Columns`, but the fact is that you can't, because it's an option too, so it must be `long`, like the other ones below (if you haven't read comment on options below, please do). The fact that `Columns` doesn't follow the `p_xxxx` naming convention, as the other ones, confused me.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/1997,25121039,2015-02-21T09:29:01Z,src/nvim/memory.c,"@@ -149,7 +149,7 @@ void *xmallocz(size_t size) {   size_t total_size = size + 1;   if (total_size < size) {-    OUT_STR(_(""Vim: Data too large to fit into virtual memory space\n""));+    mch_errmsg(_(""Vim: Data too large to fit into virtual memory space\n""));",":+1:On February 21, 2015 2:58:56 AM EST, Thiago de Arruda notifications@github.com wrote:> > @@ -149,7 +149,7 @@ void *xmallocz(size_t size)> >  {> >    size_t total_size = size + 1;> >    if (total_size < size) {> > -    OUT_STR(_(""Vim: Data too large to fit into virtual memory> >   space\n""));> > -    mch_errmsg(_(""Vim: Data too large to fit into virtual memory> >   space\n""));> > Since most of these messages are still prefixed with ""Vim:"", I'd rather> leave it like this for now and change in another PR> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1997/files#r25120696",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2002,25134890,2015-02-22T18:25:54Z,runtime/doc/options.txt,"@@ -7170,6 +7173,9 @@ A jump table for the options with a short description can be found at |Q_op|. 				     *'ttyfast'* *'tf'* *'nottyfast'* *'notf'* 'ttyfast' 'tf'		Removed. {Nvim} +	Support for slow terminal connections has been removed.  ""set tf"" is","There should not be an empty line above this, to be consistent with the other entries.Also, the first sentence is a bit over-reaching. Slow terminals should be fine as long as they support scrolling regions. Second sentence is worth keeping though.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2046,25171059,2015-02-23T15:18:11Z,test/functional/legacy/077_mf_hash_grow_spec.lua,"@@ -0,0 +1,45 @@+-- Inserts 2 million lines with consecutive integers starting from 1+-- (essentially, the output of GNU's seq 1 2000000), writes them to Xtest+-- and calculates its cksum.+-- We need 2 million lines to trigger a call to mf_hash_grow().  If it would mess+-- up the lines the checksum would differ.+-- cksum is part of POSIX and so should be available on most Unixes.+-- If it isn't available then the test will be skipped.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('mf_hash_grow()', function()+  setup(clear)++  if os.execute('which cksum &> /dev/null') == 0 then+      it('is working', function()+        -- Check to see if cksum exists, otherwise skip the test+            execute('set fileformat=unix undolevels=-1')++            -- Fill the buffer with numbers 1 - 2000000+            execute('let i = 1')+            execute('while i <= 2000000 | call append(i, range(i, i + 99)) | let i += 100 | endwhile')++            -- Delete empty first line, save to Xtest, and clear buffer+            feed('ggdd<cr>')+            execute('w! Xtest')+            feed('ggdG<cr>')++            -- Calculate the cksum of Xtest and delete first line+            execute('r !cksum Xtest')+            feed('ggdd<cr>')++            -- Assert correct output of cksum.+            expect([[+              3678979763 14888896 Xtest]])+      end)+  else+      pending(""was not tested because cksum was not found"")","""legacy test 77 skipped because ..."" would be better. Otherwise there's no context in the ""pending"" listing. Also, the `which ...` call is going to be broken on Windows. Will that cause an error or just return non-zero? (Try it by doing `os.execute('foo')`)",
1015224,glindstedt,https://api.github.com/repos/neovim/neovim/pulls/2046,25173286,2015-02-23T15:41:45Z,test/functional/legacy/077_mf_hash_grow_spec.lua,"@@ -0,0 +1,45 @@+-- Inserts 2 million lines with consecutive integers starting from 1+-- (essentially, the output of GNU's seq 1 2000000), writes them to Xtest+-- and calculates its cksum.+-- We need 2 million lines to trigger a call to mf_hash_grow().  If it would mess+-- up the lines the checksum would differ.+-- cksum is part of POSIX and so should be available on most Unixes.+-- If it isn't available then the test will be skipped.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('mf_hash_grow()', function()+  setup(clear)++  if os.execute('which cksum &> /dev/null') == 0 then+      it('is working', function()+        -- Check to see if cksum exists, otherwise skip the test+            execute('set fileformat=unix undolevels=-1')++            -- Fill the buffer with numbers 1 - 2000000+            execute('let i = 1')+            execute('while i <= 2000000 | call append(i, range(i, i + 99)) | let i += 100 | endwhile')++            -- Delete empty first line, save to Xtest, and clear buffer+            feed('ggdd<cr>')+            execute('w! Xtest')+            feed('ggdG<cr>')++            -- Calculate the cksum of Xtest and delete first line+            execute('r !cksum Xtest')+            feed('ggdd<cr>')++            -- Assert correct output of cksum.+            expect([[+              3678979763 14888896 Xtest]])+      end)+  else+      pending(""was not tested because cksum was not found"")","Thanks for the input!The describe text is prepended to the pending text, which is why the pending text seems incomplete. The complete output when pending is triggered is:```Pending ��� .../neovim/test/functional/legacy/077_mf_hash_grow_spec.lua @ 39mf_hash_grow() was not tested because cksum was not found```Is that output descriptive enough? If not I could add ""legacy test 77"" as well.I tried running os.execute('foo') instead and it triggers pending without causing errors, I'm not sure if Windows would behave differently though.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2046,25179697,2015-02-23T16:52:19Z,test/functional/legacy/077_mf_hash_grow_spec.lua,"@@ -0,0 +1,45 @@+-- Inserts 2 million lines with consecutive integers starting from 1+-- (essentially, the output of GNU's seq 1 2000000), writes them to Xtest+-- and calculates its cksum.+-- We need 2 million lines to trigger a call to mf_hash_grow().  If it would mess+-- up the lines the checksum would differ.+-- cksum is part of POSIX and so should be available on most Unixes.+-- If it isn't available then the test will be skipped.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('mf_hash_grow()', function()+  setup(clear)++  if os.execute('which cksum &> /dev/null') == 0 then+      it('is working', function()+        -- Check to see if cksum exists, otherwise skip the test+            execute('set fileformat=unix undolevels=-1')++            -- Fill the buffer with numbers 1 - 2000000+            execute('let i = 1')+            execute('while i <= 2000000 | call append(i, range(i, i + 99)) | let i += 100 | endwhile')++            -- Delete empty first line, save to Xtest, and clear buffer+            feed('ggdd<cr>')+            execute('w! Xtest')+            feed('ggdG<cr>')++            -- Calculate the cksum of Xtest and delete first line+            execute('r !cksum Xtest')+            feed('ggdd<cr>')++            -- Assert correct output of cksum.+            expect([[+              3678979763 14888896 Xtest]])+      end)+  else+      pending(""was not tested because cksum was not found"")","Since another change is needed, I'll add another nitpick: how about changing the condition like this:``` luaif os.execute('which cksum &> /dev/null') ~= 0 then    pending(..)else   ...end```In general put the ""guards"" at the top of a block since they are short and convey the dependencies quickly.",
312503,DarkDefender,https://api.github.com/repos/neovim/neovim/pulls/2066,25474029,2015-02-26T22:59:56Z,src/nvim/ui.c,"@@ -470,21 +470,29 @@ static void flush_cursor_update(void) static void ui_change_mode(void) {   static int showing_insert_mode = MAYBE;+  static int showing_replace_mode = MAYBE;    if (!full_screen) {     return;   }    if (State & INSERT) {-    if (showing_insert_mode != TRUE) {-      UI_CALL(insert_mode);+	if (showing_replace_mode != TRUE && State & REPLACE_FLAG) {+	  UI_CALL(replace_mode);+	  showing_replace_mode = TRUE;+	  showing_insert_mode = FALSE;","My bad, will fix.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2081,25672430,2015-03-03T09:20:35Z,src/nvim/version.c,"@@ -22,6 +22,8 @@  char *Version = VIM_VERSION_SHORT; char *longVersion = NVIM_VERSION_LONG "" (compiled "" __DATE__ "" "" __TIME__ "")"";+char *longVersionWithDate = NVIM_VERSION_LONG "" (compiled "" __DATE__ "" "" __TIME__ "")"";",What's the difference between `longVersion` and `longVersionWithDate`?,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2081,25674054,2015-03-03T09:48:21Z,src/nvim/version.c,"@@ -22,6 +22,8 @@  char *Version = VIM_VERSION_SHORT; char *longVersion = NVIM_VERSION_LONG "" (compiled "" __DATE__ "" "" __TIME__ "")"";+char *longVersionWithDate = NVIM_VERSION_LONG "" (compiled "" __DATE__ "" "" __TIME__ "")"";","Oops, `longVersion` should just be `NVIM_VERSION_LONG`",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2081,25674341,2015-03-03T09:53:05Z,src/nvim/version_defs.h,"@@ -41,16 +43,5 @@ // for the "":version"" command and ""nvim -h"" #define NVIM_VERSION_LONG ""NVIM "" NVIM_VERSION_MEDIUM ""."" STR(NVIM_VERSION_PATCH) NVIM_VERSION_PRERELEASE NVIM_VERSION_BUILD -//-// Vim version number, name, etc. Patchlevel is defined in version.c.-//-#define VIM_VERSION_MAJOR                7-#define VIM_VERSION_MINOR                4-#define VIM_VERSION_100     (VIM_VERSION_MAJOR * 100 + VIM_VERSION_MINOR)--// used for the runtime directory name-#define VIM_VERSION_NODOT       ""vim74""-// swap file compatibility (max. length is 6 chars)-#define VIM_VERSION_SHORT       ""7.4""  #endif  // NVIM_VERSION_DEFS_H","You're right, the naming is a bit ad-hoc right now. Perhaps `version_gen.h` or something. The emphasis should be that it is re-generated while `version.h` is not.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2081,25751099,2015-03-04T04:12:55Z,src/nvim/version.c,"@@ -18,10 +18,23 @@ #include ""nvim/misc2.h"" #include ""nvim/screen.h"" #include ""nvim/strings.h""-#include ""nvim/version_defs.h""++// version info generated by the build system+#include ""auto/versiondef.h""++#define STR_(x) #x+#define STR(x) STR_(x)++// for the startup-screen+#define NVIM_VERSION_MEDIUM STR(NVIM_VERSION_MAJOR) ""."" STR(NVIM_VERSION_MINOR)+// for the "":version"" command and ""nvim -h""","The second part is no longer true, should be `... and ""nvim --version""`, unless `nvim--version` prints another `NVIM_VERSION_*` variant...",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2045,25751769,2015-03-04T04:41:39Z,src/nvim/msgpack_rpc/remote_ui.c,"@@ -66,8 +66,10 @@ static Object remote_ui_attach(uint64_t channel_id, uint64_t request_id,       || args.items[2].type != kObjectTypeBoolean       || args.items[0].data.integer <= 0 || args.items[1].data.integer <= 0) {     api_set_error(error, Validation,-                  _(""Arguments must be a pair of positive integers ""-                    ""representing the remote screen width/height""));+                  _(""Arguments must be:\n""+                    ""- remote screen width (integer > 0)\n""+                    ""- remote screen height (integer > 0)\n""+                    ""- whether to enable RGB capabilities (boolean)""));     return NIL;","How about: `""Invalid arguments. Expected: (uint width, uint height, bool enable_rgb)""`.Also, any change in wording should be reflected in the similar message here: https://github.com/carlosdcastillo/neovim/blob/stringfix/src/nvim/msgpack_rpc/remote_ui.c#L131-L133",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2037,25856138,2015-03-05T11:15:16Z,src/nvim/os/pty_process.c,"@@ -0,0 +1,225 @@+// Some of the code came from pangoterm and libuv+#include <stdbool.h>+#include <stdlib.h>+#include <string.h>++#include <unistd.h>+#include <termios.h>+#include <sys/types.h>+#include <sys/wait.h>+#include <sys/ioctl.h>++// forkpty is not in POSIX, so headers are platform-specific+#if defined(__FreeBSD__)+# include <libutil.h>+#elif defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)+# include <util.h>+#else+# include <pty.h>+#endif++#include <uv.h>++#include ""nvim/os/job.h""+#include ""nvim/os/job_defs.h""+#include ""nvim/os/job_private.h""+#include ""nvim/os/pty_process.h""+#include ""nvim/memory.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/pty_process.c.generated.h""+#endif++typedef struct {+  struct winsize winsize;+  uv_pipe_t proc_stdin, proc_stdout, proc_stderr;+  uv_signal_t schld;+  int tty_fd;+} PtyProcess;++void pty_process_init(Job *job)+{+  PtyProcess *ptyproc = xmalloc(sizeof(PtyProcess));++  if (job->opts.writable) {+    uv_pipe_init(uv_default_loop(), &ptyproc->proc_stdin, 0);+    ptyproc->proc_stdin.data = NULL;+  }++  if (job->opts.stdout_cb) {+    uv_pipe_init(uv_default_loop(), &ptyproc->proc_stdout, 0);+    ptyproc->proc_stdout.data = NULL;+  }++  if (job->opts.stderr_cb) {+    uv_pipe_init(uv_default_loop(), &ptyproc->proc_stderr, 0);+    ptyproc->proc_stderr.data = NULL;+  }++  job->proc_stdin = (uv_stream_t *)&ptyproc->proc_stdin;+  job->proc_stdout = (uv_stream_t *)&ptyproc->proc_stdout;+  job->proc_stderr = (uv_stream_t *)&ptyproc->proc_stderr;+  job->process = ptyproc;+}++void pty_process_destroy(Job *job)+{+  free(job->opts.term_name);+  free(job->process);+  job->process = NULL;+}++bool pty_process_spawn(Job *job)+{+  int master;+  PtyProcess *ptyproc = job->process;+  ptyproc->winsize = (struct winsize){job->opts.height, job->opts.width, 0, 0};+  struct termios termios;+  init_termios(&termios);+  uv_disable_stdio_inheritance();++  int pid = forkpty(&master, NULL, &termios, &ptyproc->winsize);++  if (pid < 0) {+    return false;+  } else if (pid == 0) {+    init_child(job);+    abort();+  }++  // make sure the master file descriptor is non blocking+  fcntl(master, F_SETFL, fcntl(master, F_GETFL) | O_NONBLOCK);++  if (job->opts.writable) {+    uv_pipe_open(&ptyproc->proc_stdin, dup(master));+  }++  if (job->opts.stdout_cb) {+    uv_pipe_open(&ptyproc->proc_stdout, dup(master));+  }++  if (job->opts.stderr_cb) {+    uv_pipe_open(&ptyproc->proc_stderr, dup(master));",I forgot to close the original fd. It has been fixed in #2076: https://github.com/tarruda/neovim/blob/builtin-terminal-emulation/src/nvim/os/pty_process.c#L108-L122,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2037,25861688,2015-03-05T13:08:09Z,src/nvim/os/pty_process.c,"@@ -0,0 +1,225 @@+// Some of the code came from pangoterm and libuv+#include <stdbool.h>+#include <stdlib.h>+#include <string.h>++#include <unistd.h>+#include <termios.h>+#include <sys/types.h>+#include <sys/wait.h>+#include <sys/ioctl.h>++// forkpty is not in POSIX, so headers are platform-specific+#if defined(__FreeBSD__)+# include <libutil.h>+#elif defined(__OpenBSD__) || defined(__NetBSD__) || defined(__APPLE__)+# include <util.h>+#else+# include <pty.h>+#endif++#include <uv.h>++#include ""nvim/os/job.h""+#include ""nvim/os/job_defs.h""+#include ""nvim/os/job_private.h""+#include ""nvim/os/pty_process.h""+#include ""nvim/memory.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/pty_process.c.generated.h""+#endif++typedef struct {+  struct winsize winsize;+  uv_pipe_t proc_stdin, proc_stdout, proc_stderr;+  uv_signal_t schld;+  int tty_fd;+} PtyProcess;++void pty_process_init(Job *job)+{+  PtyProcess *ptyproc = xmalloc(sizeof(PtyProcess));++  if (job->opts.writable) {+    uv_pipe_init(uv_default_loop(), &ptyproc->proc_stdin, 0);+    ptyproc->proc_stdin.data = NULL;+  }++  if (job->opts.stdout_cb) {+    uv_pipe_init(uv_default_loop(), &ptyproc->proc_stdout, 0);+    ptyproc->proc_stdout.data = NULL;+  }++  if (job->opts.stderr_cb) {+    uv_pipe_init(uv_default_loop(), &ptyproc->proc_stderr, 0);+    ptyproc->proc_stderr.data = NULL;+  }++  job->proc_stdin = (uv_stream_t *)&ptyproc->proc_stdin;+  job->proc_stdout = (uv_stream_t *)&ptyproc->proc_stdout;+  job->proc_stderr = (uv_stream_t *)&ptyproc->proc_stderr;+  job->process = ptyproc;+}++void pty_process_destroy(Job *job)+{+  free(job->opts.term_name);+  free(job->process);+  job->process = NULL;+}++bool pty_process_spawn(Job *job)+{+  int master;+  PtyProcess *ptyproc = job->process;+  ptyproc->winsize = (struct winsize){job->opts.height, job->opts.width, 0, 0};+  struct termios termios;+  init_termios(&termios);+  uv_disable_stdio_inheritance();++  int pid = forkpty(&master, NULL, &termios, &ptyproc->winsize);++  if (pid < 0) {+    return false;+  } else if (pid == 0) {+    init_child(job);+    abort();+  }++  // make sure the master file descriptor is non blocking+  fcntl(master, F_SETFL, fcntl(master, F_GETFL) | O_NONBLOCK);++  if (job->opts.writable) {+    uv_pipe_open(&ptyproc->proc_stdin, dup(master));+  }++  if (job->opts.stdout_cb) {+    uv_pipe_open(&ptyproc->proc_stdout, dup(master));+  }++  if (job->opts.stderr_cb) {+    uv_pipe_open(&ptyproc->proc_stderr, dup(master));",They are closed by libuv when the stream is closed: https://github.com/libuv/libuv/blob/v1.x/src/unix/stream.c#L1563-L1568,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2076,25888302,2015-03-05T18:31:04Z,src/nvim/terminal.c,"@@ -0,0 +1,965 @@+// VT220/xterm-like terminal emulator implementation for Neovim. Powered by+// libvterm(http://www.leonerd.org.uk/code/libvterm/).+//+// libvterm is a pure C99 terminal emulation library with abstract input and+// display.  This means that the library needs to read data from the master fd+// and feed VTerm instances, which will will invoke user callbacks with screen",duplicate word 'will',
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2106,25990453,2015-03-07T00:57:46Z,src/nvim/option.c,"@@ -2030,7 +2030,13 @@ void set_init_1(void)     } else {       free(p_enc);       p_enc = save_enc;+      /* mb_init() failed. Call it again for the saved encoding */+      mb_init();     }+  } else {+    /* enc_locale() didn't find a useful locale. Call mb_init() with+     * the default utf-8 encoding */",```// enc_locale() didn't find a useful locale; try again on the default (utf8).```Note that `//` comment style is preferred. See. https://github.com/neovim/neovim/blob/master/CONTRIBUTING.md#coding-style,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2076,26003617,2015-03-08T09:11:28Z,src/nvim/eval.c,"@@ -19755,6 +19807,39 @@ char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, char_u *flags)   return ret; } +static inline JobOptions common_job_options(char **argv, char *autocmd_file)+{+  TerminalJobData *data = xcalloc(1, sizeof(TerminalJobData));+  data->autocmd_file = xstrdup(autocmd_file);+  JobOptions opts = JOB_OPTIONS_INIT;+  opts.argv = argv;+  opts.data = data;+  opts.stdout_cb = on_job_stdout;+  opts.stderr_cb = on_job_stderr;+  opts.exit_cb = on_job_exit;+  return opts;+}++static inline Job *common_job_start(JobOptions opts, typval_T *rettv)+{+  Job *job = job_start(opts, &rettv->vval.v_number);+  TerminalJobData *data = opts.data;++  if (rettv->vval.v_number <= 0) {+    if (rettv->vval.v_number == 0) {+      EMSG(_(e_jobtblfull));+      free(data->autocmd_file);+    } else {+      EMSG(_(e_jobexe));","I think in this case the callback `on_job_exit()` will be called, but the refcount was not increased. So `term_job_data_decref()` will not free `data`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2076,26003743,2015-03-08T09:34:01Z,src/nvim/main.c,"@@ -270,6 +270,16 @@ int main(int argc, char **argv)   /* Set the break level after the terminal is initialized. */   debug_break_level = params.use_debug_break_level; +  // open terminals when opening files that start with term://+  do_cmdline_cmd((uint8_t *)+      ""autocmd BufReadCmd term://* ""+      "":call termopen( ""+      // Capture the command the command string ","duplicate words: ""the command""",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2076,26004814,2015-03-08T12:50:51Z,src/nvim/eval.c,"@@ -19755,6 +19808,39 @@ char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, char_u *flags)   return ret; } +static inline JobOptions common_job_options(char **argv, char *autocmd_file)+{+  TerminalJobData *data = xcalloc(1, sizeof(TerminalJobData));+  data->autocmd_file = xstrdup(autocmd_file);+  JobOptions opts = JOB_OPTIONS_INIT;+  opts.argv = argv;+  opts.data = data;+  opts.stdout_cb = on_job_stdout;+  opts.stderr_cb = on_job_stderr;+  opts.exit_cb = on_job_exit;+  return opts;+}++static inline Job *common_job_start(JobOptions opts, typval_T *rettv)+{+  Job *job = job_start(opts, &rettv->vval.v_number);+  TerminalJobData *data = opts.data;+  data->refcount++;++  if (rettv->vval.v_number <= 0) {+    if (rettv->vval.v_number == 0) {+      EMSG(_(e_jobtblfull));+      free(data->autocmd_file);+    } else {+      EMSG(_(e_jobexe));+      free(opts.data);",The job exit callback would free `opts.data`. But the other error branch needs `free(opts.data);` and `free(opts.term_name);`.,
491850,doppioandante,https://api.github.com/repos/neovim/neovim/pulls/1791,26084366,2015-03-09T22:44:41Z,src/nvim/os/fsnotification.c,"@@ -0,0 +1,248 @@+#include <stdbool.h>+#include <stdlib.h>+#include <assert.h>++#include <uv.h>++#include ""nvim/vim.h""+#include ""nvim/buffer.h""+#include ""nvim/lib/khash.h""+#include ""nvim/lib/klist.h""+#include ""nvim/fileio.h""+#include ""nvim/os/fs_defs.h""+#include ""nvim/os/fsnotification.h""+#include ""nvim/os/event.h""+++// Apparentely, the destruction mechanism is not very well implemented in klist.+// Proper resource handling will be done manually+#define _destroy(x)+KLIST_INIT(Watcher, Watcher, _destroy)+#undef _destroy++static klist_t(Watcher)* watchers_list = NULL;++KHASH_MAP_INIT_STR(EventTable, int)+khash_t(EventTable)* event_lookup = NULL;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/fsnotification.c.generated.h""+#endif++typedef struct {+    buf_T* buffer;+    khiter_t lookup_iter;+    uv_fs_event_t* handle;+} EvtData;++static void check_callback(Event evt)+{+  EvtData* data = (EvtData*) evt.data;+  (void) buf_check_timestamp(data->buffer, false);++  if ((kh_value(event_lookup, data->lookup_iter) & UV_RENAME) &&+      os_file_exists(data->buffer->b_ffname)) {+    fsnotification_delete_buffer(data->buffer);+    fsnotification_add_buffer(data->buffer);+  }++  kh_value(event_lookup, data->lookup_iter) = 0;+  free(data);+}++static void fs_event_callback(uv_fs_event_t* handle,+                                    const char* filename,+                                    int events,+                                    int status)+{+  // we need to retrieve the full path for buflist_findname+  char path[1024];+  size_t size = 1023;+  uv_fs_event_getpath(handle, path, &size);+  path[++size] = '\0';","Are you assuming libuv version >= 1.3 ? We currently use 1.2.0, and I'm wondering if you're aware of the changes to `uv_fs_event_getpath`'s semantics[0]. I should probably send a PR to update that...[0] http://docs.libuv.org/en/latest/fs_event.html (bottom of page)",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2124,26107972,2015-03-10T09:35:24Z,CONTRIBUTING.md,"@@ -7,100 +7,198 @@     - [**documentation**](https://github.com/neovim/neovim/labels/documentation)       improvements are also very helpful. - Look at [Waffle][waffle] to see who is working on what issues.-- Refer to the [the wiki][wiki] for detailed guidance.+- If needed, refer to the [the wiki][wiki] for additional guidance.  ## Issues -- Search existing issues before raising a new one.-- Include as much detail as possible. In particular, we need to know which-  OS you're using.--## Pull requests+- If you aren't running the latest version of Neovim, update to the newest+  version to see if your problem persists.+- Search existing issues before opening a new one.+- If you are experiencing compile or runtime warnings/failures, try+  searching for the error message you received on [Neovim's GitHub+  page][neovim].+    - If you are still unsure of what is causing your build failure, please+      run `make distclean && make` as to rule out a stale build+      environment causing the failure.+- Include as much detail as possible. We need to know:+    - Which operating system you're using.+    - What version of Neovim you're using. To get this, open a terminal and+      run `nvim --version`.+    - This isn't required, but when the issue showed up for you. You can run+      [`git bisect`][git-bisect] to find the exact commit which introduced+      your issue.++## Submitting pull requests  - Make it clear in the issue tracker what you are working on.-- Be descriptive in your PR message: what is it for, why is it needed, etc.-- Don't make cosmetic changes to unrelated files in the same PR.+- Be descriptive in your pull request description: what is it for, why is it+  needed, etc.+- Do ***not*** make cosmetic changes to unrelated files in the same pull+  request. This creates noise, making reviews harder to do. If your text+  editor that strips all trailing whitespace in a file when you open/save it,+  please disable it. - If you're a first-time contributor, please sign the-  [Neovim Contributor License Agreement (CLA)][cla] before submitting your PR.+  [Neovim Contributor License Agreement (CLA)][cla] before submitting your+  pull request.  #### Tagging in the issue tracker -When submitting pull requests, include one of the following tokens in the title:+When submitting pull requests (commonly referred to as ""PRs""), include one of+the following tags prepended to the title:++- `[WIP]` - Work In Progress. The PR will change, so while there is no+  immediate need for review, although the submitter still might appreciate it.+- `[RFC]` - Request For Comment. The PR needs reviewing and/or comments.+- `[RDY]` - The PR is ready to be merged. The PR has been reviewed by at least+  one other person and has no outstanding issues. -* `[WIP]` - Work In Progress. The pull request will change, and there is no need-  to review it yet.-* `[RFC]` - Request For Comment. The request needs reviewing and/or comments.-* `[RDY]` - The request is ready to be merged. The request must have been-  reviewed by at least one person and have no outstanding issues.-* Default label is assumed to be `[WIP]` if there's no indication otherwise.+Assuming the above criteria has been met, feel free to change your PR's tag+yourself, as opposed to waiting for a contributor to do it for you.  #### Branching & history -- Use a feature branch, not master.-- Rebase your feature branch onto (upstream) master before raising the PR.-- Keep up to date with changes in (upstream) master so your PR is easy to merge.-- Try to actively tidy your history: combine related commits with interactive-  rebasing etc. If your PR is still `[WIP]` don't be afraid to force-push to-  your feature branch to tidy your history.+- Do ***not*** work on your PR on the master branch, [use a feature branch+  instead][feature-branch]. ***TODO:*** this feature branch article is really+  long, a shorter one would be nicer.+- [Rebase your feature branch onto][git-rebasing] (upstream) master before+  opening the PR.+- Keep up to date with changes in (upstream) master so your PR is easy to+  merge.+- [Try to actively tidy your history][git-rewriting-history]: combine related+  commits with interactive rebasing, split monolithic commits into multiple+  ones, etc. If your PR is still `[WIP]` don't be afraid to force-push to your+  feature branch to tidy your history.  ### For code PRs  #### Testing -- We are unlikely to merge your PR if the Travis build fails.-- The Travis build does not currently run the tests under valgrind, but you-  are encouraged to do so locally.+We are unlikely to merge your PR if the Travis build fails:++- Travis builds are compiled with the [`-Werror`][gcc-warnings] flag, so+  if your PR introduces any compiler warnings then the Travis build will fail.+- If any unit tests fail, the Travis build will fail. They can be run+  locally with `make test`, which is generally much faster than waiting on+  Travis, so should be done prior to submitting your PR. Unit tests+  passing locally doesn't guarantee they'll pass in your Travis build, as+  multiple different builds using different platforms and compilers are+  used to test your code.+- The Travis build does not currently run the tests under+  [valgrind][valgrind], but you are encouraged to do so locally.  #### Coding style -We have a [style guide][style] that all new code should follow. However, vast-swathes of the existing vim codebase violate it to some degree, and fixing+We have a [style guide][style] that all new code should follow. However, large+portions of the existing Vim codebase violate it to some degree, and fixing them would increase merge conflicts and add noise to `git blame`. Please weigh-those costs when making cosmetic changes. As a rule of thumb, avoid pull-requests dominated by style changes. Feel free to fix up lines that you happen-to be modifying anyway, as long as they look consistent with their-surroundings. Fix anything that looks outright+those costs when making cosmetic changes. In general, avoid pull requests+dominated by style changes, but feel free to fix up lines that you happen to+be modifying anyway.++Fix anything that looks outright [barbarous](http://www.orwell.ru/library/essays/politics/english/e_polit) ---especially if you can't find any editor settings that make it look ok -- but+especially if you can't find any editor settings that make it look okay -- but otherwise err on the side of leaving things as they are. -For new code, please run [`clint.py`][clint] to detect style errors. It is not-perfect and may have false positives and negatives. To have `clint.py` ignore-certain special cases, put `// NOLINT` at the end of the line.+For new code, run `make lint` (which runs [clint.py][clint]) to detect style+errors. Make sure that the file(s) you intend to be linted are not in+`clint-ignored-files.txt`. It isn't perfect, so may have false+positives/negatives. To have `clint.py` ignore certain special cases, put+`// NOLINT` at the end of the line. -We also provide a configuration file for [`clang-format` and +We also provide a configuration file for [`clang-format` and `git-clang-format`][clang-format], which can be used to format code according to the style guidelines. Be aware this formatting method might need user-supervision.+supervision. To have `clang-format` ignore certain special cases, use the+following special comments:++```c+int formatted_code;+// clang-format off+    void    unformatted_code  ;+// clang-format on+    void formatted_code_again;+```  #### Commit guidelines -The purpose of these guidelines is to *make reviews easier* and make the VCS logs more valuable.+The purpose of these guidelines is to *make reviews easier* and make the+[VCS][vcs] logs more valuable.  - Try to keep the first line under 70 characters.-- Include further description, if necessary, after a blank line.-    - Don't make it too verbose by including obvious things.-    - But don't spare clarifications for anything that could be not so obvious.-      Some commit messages are pages long, and that's fine if there's no better-      place for those comments to live.+- If necessary, Include further description after a blank line.+    - Don't make the description too verbose by including obvious things, but+      don't spare clarifications for anything that could be not so obvious.+      Some commit messages are pages long, and that's fine if there's no+      better place for those comments to live.     - **Recommended:** Prefix logically-related commits with a consistent-      identifier at the beginning of each commit message.+      identifier in each commit message.       [For example](https://github.com/neovim/neovim/commits?author=elmart),       the following commits are related by task (*Introduce vim namespace*) and       scope (*Contrib YCM*).-      <br/> `Introduce vim namespace: Contrib YCM: Fix style issues.`-      <br/> `Introduce vim namespace: Contrib YCM: Fix build dir calculation`+      <br/> `Introduce nvim namespace: Contrib YCM: Fix style issues`+      <br/> `Introduce nvim namespace: Contrib YCM: Fix build dir calculation`         - Subtasks can be *activity-oriented* (doing different things on the same area)           or *scope-oriented* (doing the same thing on different areas).     - Granularity helps, but it's conceptual size that matters, not extent size.-- Use the imperative voice: ""Fix bug"" rather than ""Fixed bug"" or ""Fixes bug.""+- Use the [imperative][imperative] voice: ""Fix bug"" rather than ""Fixed bug"" or ""Fixes bug.""++## Reviewing pull requests++### Reviewer checklist++Many items were [taken from here][code-review-checklist].++#### Code++- Is the Travis build passing?+- Does the code conform to the [style guide][style]?+- Does the code work? Does it perform its intended function, the logic is+  correct etc.+- Is the code easily understood?+- Is there any redundant or duplicate code?+- Are there any unused variables?+- Is the code as modular as possible?+- Can any global/static variables be replaced?+- Can any function attributes be used?+- Are variables named intuitively? functions?+- Can any of the code be replaced with library functions?+- Can any logging or debugging code be removed?+- Do loops have a set length and correct termination conditions?+- Are return values being checked?+- Are invalid parameter values handled where needed?+- Are there any use after frees?+- Are there any memory leaks? unclosed sockets?+- Are there any null pointer dereferences?+- Are any uninitialized variables used?+- Are there any cases of possible arithmetic overflow?+- Are there any unneeded assert statements?++#### Documentation/comments++- Are there any superfluous comments?+- Where needed, do comments exist and describe the intent of the code?+- Are all non-trivial functions commented?+- Is any unusual behavior or edge-case handling described?+- Is the use and function of API functions documented?+- Are data structures/typedefs explained?+- Is there any incomplete code, e.g., code marked `TODO`, `FIXME`, or `XXX`?   [cla]: https://docs.google.com/forms/d/1u54bpbwzneDIRltFx1TGi2evKxY3w0cOV3vlpj8DPbg/viewform-[clint]: clint.py [clang-format]: http://clang.llvm.org/docs/ClangFormat.html+[clint]: clint.py+[code-review-checklist]: http://blog.fogcreek.com/increase-defect-detection-with-our-code-review-checklist-example/","I find the example checklist in SmeatBear's [Best Kept Secrets of Peer Code Review](http://smartbear.com/SmartBear/media/pdfs/best-kept-secrets-of-peer-code-review.pdf) (on pg. 112) useful too:1. Documentation: All subroutines are commented in clear language.2. Documentation: Describe what happens with corner-case input.3. Documentation: Complex algorithms are explained and justified.4. Documentation: Code that depends on non-obvious behavior in external libraries is documented with reference to external documentation.5. Documentation: Units of measurement are documented for numeric values.6. Documentation: Incomplete code is indicated with appropriate distinctive markers (e.g. `TODO` or `FIXME`).7. Documentation: User-facing documentation is updated (online help, contextual help, tool-tips, version history).8. Testing: Unit tests are added for new code paths or behaviors.9. Testing: Unit tests cover errors and invalid parameter cases.10. Testing: Unit tests demonstrate the algorithm is performing as documented.11. Testing: Possible null pointers always checked before use.12. Testing: Array indexes checked to avoid out-of-bound errors.13. Testing: Don't write new code that is already implemented in an existing, tested API.14. Testing: New code fixes/implements the issue in question.15. Error Handling: Invalid parameter values are handled properly early in the subroutine.16. Error Handling: Error values of null pointers from subroutine invocations are checked.17. Error Handling: Error handlers clean up state and resources no matter where an error occurs.18. Error Handling: Memory is released, resources are closed, and reference counters are managed under both error and nonerror conditions.19. Thread Safety: Global variables are protected by locks or locking subroutines.20. Thread Safety: Objects accessed by multiple threads are accessed only through a lock.21. Thread Safety: Locks must be acquired and released in the right order to prevent deadlocks, even in error-handling code.22. Performance: Objects are duplicated only when necessary.23. Performance: No busy-wait loops instead of proper thread-synchronization methods.24. Performance: Memory usage is acceptable even with large inputs.25. Performance: Optimization that makes code harder to read should only be implemented if a profiler or other tool has indicated that the routine stands to gain from optimization.  These kinds of optimizations should be well-documented and code that performs the same task simply should be preserved somewhere.",
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/1791,26130729,2015-03-10T15:18:10Z,runtime/autoload/notification.vim,"@@ -0,0 +1,31 @@+let s:fs_notify_on = 0++function! notification#turn_on()+    if s:fs_notify_on == 1+    	return+    endif++    for i in range(tabpagenr('$'))+    	for buf in tabpagebuflist(i+1)+            call notify_register(buf)+        endfor+    endfor++    let s:fs_notify_on = 1+endfunction notification#turn_on++"" TODO: write turn_off++augroup fs_notification+    autocmd BufRead        * call notify_register(expand('<afile>'))+    autocmd BufDelete      * call notify_unregister(expand('<afile>'))+    autocmd BufWritePre    * call notify_set(expand('<afile>'), 0)+    autocmd FileWritePre   * call notify_set(expand('<afile>'), 0)+    autocmd FileAppendPre  * call notify_set(expand('<afile>'), 0)+    autocmd BufWritePost   * call notify_register(expand('<afile>'))+    autocmd FileWritePost  * call notify_register(expand('<afile>'))+    autocmd FileAppendPost * call notify_register(expand('<afile>'))++    autocmd BufFilePre     * call notify_unregister(expand('<afile>'))+    autocmd BufFilePost    * call notify_register(expand('<afile>'))+augroup END","Autocommand groups should be self-clearing to prevent duplication of autocommands when the file is sourced multiple times. Also, you can combine multiple events into one command, i.e.:``` vimaugroup fs_notification  autocmd!  autocmd BufRead,BufWritePost,BufFilePost,FileWritePost,FileAppendPost * call notify_register(expand('<afile>'))  autocmd BufWritePre,FileWritePre,FileAppendPre * call notify_set(expand('<afile>'), 0)  autocmd BufDelete,BufFilePre * call notify_unregister(expand('<afile>'))augroup END```",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2108,26155875,2015-03-10T19:18:13Z,scripts/vim-patch.sh,"@@ -177,19 +178,28 @@ list_vim_patches() {   echo ""  To port one of the above patches to Neovim, execute""   echo ""  this script with the patch revision as argument.""   echo-  echo ""  Examples: './scripts/vim-patch.sh 7.4.487'""-  echo ""            './scripts/vim-patch.sh 1e8ebf870720e7b671f98f22d653009826304c4f'""+  echo ""  Examples: '${BASENAME} 7.4.487'""+  echo ""            '${BASENAME} 1e8ebf870720e7b671f98f22d653009826304c4f'"" } -if [[ ${#} != 1 || ""${1}"" == ""--help"" || ""${1}"" == ""-h"" ]]; then-  usage+if [[ ${1} == ""--help"" || ${1} == ""-h"" ]]; then+  usage 1+  exit 0+elif [[ ${#} != 1 ]]; then+  usage 2+  exit 1+fi++# Check if mercurial is in the user's PATH, and is executable+if [[ ! -x $(command -v hg) ]]; then","I read in `man bash` something along the lines of ""variables, substring expansion ... disabled inside `[[...]]` blocks"", is that not true? Shellcheck didn't warn about it.On March 10, 2015 3:15:23 PM EDT, Florian Walch notifications@github.com wrote:> >  }> > > > -if [[ ${#} != 1 || ""${1}"" == ""--help"" || ""${1}"" == ""-h"" ]]; then> > -  usage> >   +if [[ ${1} == ""--help"" || ${1} == ""-h"" ]]; then> > -  usage 1> > -  exit 0> >   +elif [[ ${#} != 1 ]]; then> > -  usage 2> > -  exit 1> >   +fi> >   +> >   +# Check if mercurial is in the user's PATH, and is executable> >   +if [[ ! -x $(command -v hg) ]]; then> > Add quotes around ""$(..)""?> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/2108/files#r26155597",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2074,26190621,2015-03-11T06:01:55Z,test/functional/legacy/089_number_relativenumber_spec.lua,"@@ -0,0 +1,86 @@+-- - Some tests for setting 'number' and 'relativenumber'+--   This is not all that useful now that the options are no longer reset when+--   setting the other.++local helpers = require('test.functional.helpers')+local feed = helpers.feed+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('setting \'number\' and \'relativenumber\'', function()+  setup(clear)++  it('is working', function()+    execute('set hidden nu rnu')",I think these `execute()` blocks can be one big `source([[...]])` call. Example: https://github.com/neovim/neovim/pull/2029/files#diff-f91bb1d2e99bfd9a4eac66290bdf501fR18,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2074,26191006,2015-03-11T06:16:46Z,test/functional/legacy/019_smarttab_expandtab_spec.lua,"@@ -0,0 +1,56 @@+-- Tests for ""r<Tab>"" with 'smarttab' and 'expandtab' set/not set.+-- Also test that dv_ works correctly++local helpers = require('test.functional.helpers')+local feed, insert = helpers.feed, helpers.insert+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('performing ""r<Tab>"" with \'smarttab\' and \'expandtab\' set/not set, and ""dv_""', function()+  setup(clear)++  it('is working', function()+    insert([[+      start text+      		some test text+      test text+      		other test text+          a cde+          f ghi+      test text+        Second line beginning with whitespace]])++    execute('set smarttab expandtab ts=8 sw=4')+    -- Make sure that backspace works, no matter what termcap is used.+    execute('set t_kD=x7f t_kb=x08')","When migrating legacy tests, be sure to look at the _raw_ original file in [neo]vim, with `set list` so that control characters appear.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2076,26270791,2015-03-12T00:54:15Z,src/nvim/eval.c,"@@ -19754,16 +19815,51 @@ char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, char_u *flags)   return ret; } +static inline JobOptions common_job_options(char **argv, char *autocmd_file)+{+  TerminalJobData *data = xcalloc(1, sizeof(TerminalJobData));+  if (autocmd_file) {+    data->autocmd_file = xstrdup(autocmd_file);+  }+  JobOptions opts = JOB_OPTIONS_INIT;+  opts.argv = argv;+  opts.data = data;+  opts.stdout_cb = on_job_stdout;+  opts.stderr_cb = on_job_stderr;+  opts.exit_cb = on_job_exit;+  return opts;+}++static inline Job *common_job_start(JobOptions opts, typval_T *rettv)+{+  Job *job = job_start(opts, &rettv->vval.v_number);+  TerminalJobData *data = opts.data;+  data->refcount++;","- We need to increase `data->refcount` before `job_start()`, because the clean up code for a failed `process_spawn()` will also call `term_job_data_decref()`. - We use the wrong pointers for the handles in the `uv_close()` calls when `process_spawn()` fails. ``` diffdiff --git a/src/nvim/eval.c b/src/nvim/eval.cindex 74a1915..0246cb7 100644--- a/src/nvim/eval.c+++ b/src/nvim/eval.c@@ -19832,18 +19832,19 @@ static inline JobOptions common_job_options(char **argv, char *autocmd_file) static inline Job *common_job_start(JobOptions opts, typval_T *rettv) {-  Job *job = job_start(opts, &rettv->vval.v_number);   TerminalJobData *data = opts.data;   data->refcount++;+  Job *job = job_start(opts, &rettv->vval.v_number);   if (rettv->vval.v_number <= 0) {     if (rettv->vval.v_number == 0) {       EMSG(_(e_jobtblfull));       free(data->autocmd_file);+      free(data);     } else {       EMSG(_(e_jobexe));-      free(opts.data);     }+    free(opts.term_name);     return NULL;   }   data->job = job;diff --git a/src/nvim/os/job.c b/src/nvim/os/job.cindex 40459d7..12006b7 100644--- a/src/nvim/os/job.c+++ b/src/nvim/os/job.c@@ -142,13 +142,13 @@ Job *job_start(JobOptions opts, int *status)   // Spawn the job   if (!process_spawn(job)) {     if (opts.writable) {-      uv_close((uv_handle_t *)&job->proc_stdin, close_cb);+      uv_close((uv_handle_t *)job->proc_stdin, close_cb);     }     if (opts.stdout_cb) {-      uv_close((uv_handle_t *)&job->proc_stdout, close_cb);+      uv_close((uv_handle_t *)job->proc_stdout, close_cb);     }     if (opts.stderr_cb) {-      uv_close((uv_handle_t *)&job->proc_stderr, close_cb);+      uv_close((uv_handle_t *)job->proc_stderr, close_cb);     }     process_close(job);     event_poll(0);```",
244927,chrisbra,https://api.github.com/repos/neovim/neovim/pulls/2141,26424263,2015-03-13T21:25:09Z,runtime/doc/vim_diff.txt,"@@ -0,0 +1,128 @@+*vim_diff.txt*    For Nvim.						{Nvim}+++			    NVIM REFERENCE MANUAL+++Differences between Nvim and Vim			       *vim-differences*++Throughout the help files, differences between Nvim and Vim are indicated via+the ""{Nvim}"" tag.  This document is a complete and centralized list of all+these differences.++1. Configuration		|nvim-configuration|+2. Option defaults		|nvim-option-defaults|+3. Changed features		|nvim-features-changed|+4. New features			|nvim-features-new|+5. Missing legacy features	|nvim-features-missing|+6. Removed features		|nvim-features-removed|+++==============================================================================+1. Configuration					    *nvim-configuration*++- Use "".nvimrc"" instead of "".vimrc"" for storing configuration.+- Use "".nvim"" instead of "".vim"" to store configuration files.+- Use "".nviminfo"" instead of "".viminfo"" for persistent session information.++==============================================================================+2. Option defaults					  *nvim-option-defaults*++- 'nocompatible' is always set+- 'encoding' defaults to ""utf-8""++==============================================================================+3. Changed features					 *nvim-features-changed*++Nvim always ships with all features, in contrast to Vim which may have+certain features removed depending at compile-time.  This is like if Vim's+""HUGE"" build was the only Vim release type (except Nvim is smaller than+Vim's ""HUGE"" build).++Assuming a python interpreter is installed, |:python| and |:python3| are+always available and may be used simultaneously in separate plugins.  The+`neovim` pip package must be installed for Nvim python plugins to work.  You+don't need to worry about link-time details or ABI incompatibilities.++==============================================================================+4. New Features						     *nvim-features-new*++See |nvim-intro| for a list of Nvim's largest new features.++Events:+- |TabNew|+- |TabNewEntered|+- |TabClosed|++Highlight groups:+- |hl-EndOfBuffer|++==============================================================================+5. Missing legacy features				 *nvim-features-missing*++These legacy Vim features are not present currently, but may be implemented in+the future:++vim.bindeval() (new feature in Vim 7.4 python interface)+if_lua+if_mzscheme+if_perl+if_ruby+if_tcl++==============================================================================+6. Removed features					 *nvim-features-removed*++These options are in Vim, but have been removed from Nvim:++Vi-compatible mode+- "":set nocompatible"" is ignored+- "":set compatible"" is an error++Ed-compatible mode+- "":set noedcompatible"" is ignored+- "":set edcompatible"" is an error++'ttyfast':+- "":set ttyfast"" is an error+- "":set nottyfast"" is ignored++EBCDIC support++8.3 filesystem support+- 'shortname'",":8 is currently only used on Windows Vim builgs and please do not remove this for future windows builts. As long as windows supports :8 this shouldn't be removed, as this is useful to handle paths with spaces",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2146,26428451,2015-03-13T22:41:43Z,test/functional/ui/screen.lua,"@@ -496,8 +501,8 @@ function pprint_attrs(attrs)     for f, v in pairs(attrs) do       local desc = tostring(v)       if f == ""foreground"" or f == ""background"" then-        if colornames[v] ~= nil then-          desc = ""Screen.colors.""..colornames[v]+        if Screen._colornames[v] ~= nil then+          desc = ""Screen.colors.""..Screen._colornames[v]","`Screen.colors().` for consistency here, but tell me, why should `Screen.colors` be a function? It is static data that doesn't depend on the state of nvim.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2148,26440199,2015-03-14T18:21:12Z,src/nvim/os/env.c,"@@ -87,3 +97,598 @@ void os_get_hostname(char *hostname, size_t len) #endif } +/// To get the ""real"" home directory:+///   - get value of $HOME+/// For Unix:+///   - go to that directory+///   - do os_dirname() to get the real name of that directory.+/// This also works with mounts and links.+/// Don't do this for MS-DOS, it will change the ""current dir"" for a drive.+static char_u   *homedir = NULL;++void init_homedir(void)+{+  char_u  *var;++  /* In case we are called a second time (when 'encoding' changes). */+  free(homedir);+  homedir = NULL;++  var = (char_u *)os_getenv(""HOME"");++  if (var != NULL && *var == NUL)       /* empty is same as not set */+    var = NULL;+++  if (var != NULL) {+#ifdef UNIX+    /*+     * Change to the directory and get the actual path.  This resolves+     * links.  Don't do it when we can't return.+     */+    if (os_dirname(NameBuff, MAXPATHL) == OK+        && os_chdir((char *)NameBuff) == 0) {+      if (!os_chdir((char *)var) && os_dirname(IObuff, IOSIZE) == OK)+        var = IObuff;+      if (os_chdir((char *)NameBuff) != 0)+        EMSG(_(e_prev_dir));+    }+#endif+    homedir = vim_strsave(var);+  }+}++#if defined(EXITFREE)++void free_homedir(void)+{+  free(homedir);+}++#endif++/// Call expand_env() and store the result in an allocated string.+/// This is not very memory efficient, this expects the result to be freed+/// again soon.+/// @param src String containing environment variables to expand+/// @see {expand_env}+char_u *expand_env_save(char_u *src)+{+  return expand_env_save_opt(src, false);+}++/// Similar to expand_env_save() but when ""one"" is `true` handle the string as+/// one file name, i.e. only expand ""~"" at the start.+/// @param src String containing environment variables to expand+/// @param one Should treat as only one file name+/// @see {expand_env}+char_u *expand_env_save_opt(char_u *src, bool one)+{+  char_u *p = xmalloc(MAXPATHL);+  expand_env_esc(src, p, MAXPATHL, false, one, NULL);+  return p;+}++/// Expand environment variable with path name.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// @param src Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+void expand_env(char_u *src, char_u *dst, int dstlen)+{+  expand_env_esc(src, dst, dstlen, false, false, NULL);+}++/// Expand environment variable with path name and escaping.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// startstr recognize the start of a new name, for '~' expansion.+/// @param srcp Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param esc Should we escape spaces in expanded variables?+/// @param one Should we expand more than one '~'?+/// @param startstr Common prefix for paths, can be NULL+void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,+                    char_u *startstr)+{+  char_u      *src;+  char_u      *tail;+  int c;+  char_u      *var;+  bool copy_char;+  bool mustfree;                 /* var was allocated, need to free it later */+  bool at_start = true;           /* at start of a name */+  int startstr_len = 0;++  if (startstr != NULL)+    startstr_len = (int)STRLEN(startstr);++  src = skipwhite(srcp);+  --dstlen;                 /* leave one char space for ""\,"" */+  while (*src && dstlen > 0) {+    copy_char = true;+    if ((*src == '$') || (*src == '~' && at_start)) {+      mustfree = false;++      /*+       * The variable name is copied into dst temporarily, because it may+       * be a string in read-only memory and a NUL needs to be appended.+       */+      if (*src != '~') {                                /* environment var */+        tail = src + 1;+        var = dst;+        c = dstlen - 1;++#ifdef UNIX+        /* Unix has ${var-name} type environment vars */+        if (*tail == '{' && !vim_isIDc('{')) {+          tail++;               /* ignore '{' */+          while (c-- > 0 && *tail && *tail != '}')+            *var++ = *tail++;+        } else // NOLINT+        // We're going to ask clint.py to ignore this else very nicely+        // because there isn't really a better way to format it without+        // adding more preprocessor logic for just curly braces or breaking+        // curlybrace balance+#endif+        {+          while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail)))) {","I think @jszakmeister is right. Just call `helpers.vim_init()` at the top of env_spec.lua. See `unit/buffer_spec.lua` for an example. We don't do this by default because ideally we want the unit tests to avoid dependency on global state; but when we're testing old/existing functions, it's necessary. New functions which are ""pure"" wouldn't need `vim_init()`.",
849039,Oberon00,https://api.github.com/repos/neovim/neovim/pulls/2146,26446312,2015-03-15T10:14:10Z,test/functional/helpers.lua,"@@ -271,7 +271,12 @@ local function expect(contents)   return eq(dedent(contents), curbuf_contents()) end -clear()+function once(fn)",Wouldn't an `assert(fn)` make sense here? Cause when you accidentally pass `nil` (which happens quite easy in Lua) the `if` below will lead to silently doing nothing.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2159,26450129,2015-03-15T17:57:23Z,scripts/genunicodetables.lua,"@@ -0,0 +1,227 @@+#!/usr/bin/lua","What for? Other generator scripts are not there, VimL is no longer used. And former `runtime/tools/unicode.vim` was creating a number of buffers in whatever directory it was run (it was needed to copy buffer contents to `mbyte.c` manually then; buffers even were left unsaved) and new script is not going to do anything like this (it does not run Vim in first place).",
849039,Oberon00,https://api.github.com/repos/neovim/neovim/pulls/2159,26450971,2015-03-15T19:16:35Z,scripts/download-unicode-files.sh,"@@ -0,0 +1,35 @@+#!/bin/sh++set -e++files=""UnicodeData.txt CaseFolding.txt EastAsianWidth.txt""++UNIDIR_DEFAULT=unicode+DOWNLOAD_URL_BASE_DEFAULT='http://unicode.org/Public/UNIDATA'++if test x$1 = 'x--help' ; then+  echo 'Usage:'+  echo ""  $0[ TARGET_DIRECTORY[ URL_BASE]]""+  echo+  echo ""Downloads files $files to TARGET_DIRECTORY.""+  echo ""Each file is downloaded from URL_BASE/\$filename.""+  echo+  echo ""Default target directory is $PWD/${UNIDIR_DEFAULT}.""+  echo ""Default URL base is ${DOWNLOAD_URL_BASE_DEFAULT}.""+fi++UNIDIR=${1:-$UNIDIR_DEFAULT}+DOWNLOAD_URL_BASE=${2:-$DOWNLOAD_URL_BASE_DEFAULT}++for filename in $files ; do+  curl -o ""$UNIDIR/$filename"" ""$DOWNLOAD_URL_BASE/$filename""+  (+    cd ""$UNIDIR""+    git add $filename+  )+done++(+  cd ""$UNIDIR""+  git commit -m ""Update unicode files"" -- *.txt","This is somewhat dangerous, since other files could have been `git add`ded by the user before.EDIT: Probably it would be better to just build a list of filepaths in the loop above and then use the `git commit <file>...` syntax",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2158,26452257,2015-03-15T21:00:22Z,src/nvim/tui/tui.c,"@@ -527,7 +529,13 @@ static void tui_flush(UI *ui)   }    unibi_goto(ui, data->row, data->col);++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+  }+   flush_buf(ui);+  unibi_out(ui, unibi_cursor_invisible);",Would it not be enough to call this for `!data->busy==true`?,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2158,26482640,2015-03-16T13:16:51Z,src/nvim/tui/tui.c,"@@ -527,7 +529,13 @@ static void tui_flush(UI *ui)   }    unibi_goto(ui, data->row, data->col);++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+  }+   flush_buf(ui);+  unibi_out(ui, unibi_cursor_invisible);","Can you try this patch?``` diffdiff --git a/src/nvim/tui/tui.c b/src/nvim/tui/tui.cindex 610419d..c25ec28 100644--- a/src/nvim/tui/tui.c+++ b/src/nvim/tui/tui.c@@ -46,6 +46,9 @@ typedef struct {   int old_height;   bool can_use_terminal_scroll;   bool busy;+  // true if there was an update that requires temporaril switching the cursor+  // off+  bool require_invisible_cursor;   HlAttrs attrs, print_attrs;   Cell **screen;   struct {@@ -342,16 +345,21 @@ static void tui_cursor_goto(UI *ui, int row, int col)   data->row = row;   data->col = col;   unibi_goto(ui, row, col);+  data->require_invisible_cursor = true; } static void tui_busy_start(UI *ui) {-  ((TUIData *)ui->data)->busy = true;+  TUIData *data = ui->data;+  data->busy = true;+  data->require_invisible_cursor = true; } static void tui_busy_stop(UI *ui) {-  ((TUIData *)ui->data)->busy = false;+  TUIData *data = ui->data;+  data->busy = false;+  data->require_invisible_cursor = true; } static void tui_mouse_on(UI *ui)@@ -475,6 +483,7 @@ static void tui_scroll(UI *ui, int count)     invalidate(ui, data->scroll_region.top, data->scroll_region.bot,         data->scroll_region.left, data->scroll_region.right);   }+  data->require_invisible_cursor = true; } static void tui_highlight_set(UI *ui, HlAttrs attrs)@@ -529,13 +538,7 @@ static void tui_flush(UI *ui)   }   unibi_goto(ui, data->row, data->col);--  if (!data->busy) {-    unibi_out(ui, unibi_cursor_normal);-  }-   flush_buf(ui);-  unibi_out(ui, unibi_cursor_invisible); } static void tui_suspend(UI *ui)@@ -789,12 +792,27 @@ end: static void flush_buf(UI *ui) {-  static uv_write_t req;-  static uv_buf_t buf;+  uv_write_t req;+  uv_buf_t buf[2];+  int buf_index = 0;+  char invis_buf[64];   TUIData *data = ui->data;-  buf.base = data->buf;-  buf.len = data->bufpos;-  uv_write(&req, (uv_stream_t *)&data->output_handle, &buf, 1, NULL);++  if (data->require_invisible_cursor) {+    if (!data->busy) {+      unibi_out(ui, unibi_cursor_normal);+    }++    const char *str = unibi_get_str(data->ut, unibi_cursor_invisible);+    buf[0].base = invis_buf;+    buf[0].len = unibi_run(str, data->params, invis_buf, sizeof(invis_buf));+    buf_index++;+    data->require_invisible_cursor = false;+  }++  buf[buf_index].base = data->buf;+  buf[buf_index].len = data->bufpos;+  uv_write(&req, (uv_stream_t *)&data->output_handle, buf + buf_index, 1, NULL);   uv_run(data->write_loop, UV_RUN_DEFAULT);   data->bufpos = 0; }```I didn't notice any difference in performance and it seems to complicate the code too much. Whats your opinion?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2158,26489250,2015-03-16T14:38:00Z,src/nvim/tui/tui.c,"@@ -527,7 +529,13 @@ static void tui_flush(UI *ui)   }    unibi_goto(ui, data->row, data->col);++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+  }+   flush_buf(ui);+  unibi_out(ui, unibi_cursor_invisible);","Perhaps I have misunderstood how this works, but can you explain, why the following code would not be enough/work?My explanation that it would work would be:Looks like `tui_flush()` is the only place where the cursor is ""switched"" on (besides tui_stop()).If we need to show the cursor, we do so and flush. After that the cursorwill be hidden at once, but this change will only be visible with the next call to `flush_buf()`. ``` cif (!data->busy) {      unibi_out(ui, unibi_cursor_normal); // Shows cursor}flush_buf(ui);if (!data->busy) {      unibi_out(ui, unibi_cursor_invisible); // Hides cursor}```So it seems we only need to hide the cursor when the cursor was shown here.The only problem that I see would be that the buffer is filled (and flushed with `flush_buf()`) before the next call to `tui_flush()` and so the cursor would be hidden until the next `tui_flush()`. But this is also how the old code works.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2158,26490989,2015-03-16T14:52:35Z,src/nvim/tui/tui.c,"@@ -527,7 +529,13 @@ static void tui_flush(UI *ui)   }    unibi_goto(ui, data->row, data->col);++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+  }+   flush_buf(ui);+  unibi_out(ui, unibi_cursor_invisible);","> So it seems we only need to hide the cursor when the cursor was shown here.We need to hide the cursor most times when redrawing to avoid seeing the cursor flash around the screen. That's why the cursor is put in invisible mode after flushing: it will always be the first command send to the terminal.We don't need to always put the cursor in invisible mode, this is the case when printing a single character at the cursor position for example. The only way I see to optimize this is to detect when we make a redraw request that would require making the cursor invisible, and if such request was made we write the cursor invisible command before flushing the output buffer. This is what the patch above did(but IMO it complicates the code for little gain)",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2158,26522324,2015-03-16T20:07:42Z,src/nvim/tui/tui.c,"@@ -527,7 +529,13 @@ static void tui_flush(UI *ui)   }    unibi_goto(ui, data->row, data->col);++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+  }+   flush_buf(ui);+  unibi_out(ui, unibi_cursor_invisible);","In the patch `invis_buf` is not flushed:``` diff-uv_write(&req, (uv_stream_t *)&data->output_handle, buf + buf_index, 1, NULL);+uv_write(&req, (uv_stream_t *)&data->output_handle, buf, buf_index + 1, NULL);```Is it correct that the following patch would not introduce cursor flashing (not sure if your answer said the snippet would not work)?Either the cursor was already hidden and no ""show cursor"" since then or the first command in the flushed buffer is ""hide cursor"". So a flushed buffer would not be drawn with a shown cursor. I did some simple test and compared this version with your patch (compared debug output), but could not find that your patch used fewer ""hide cursor"" commands.``` diffdiff --git a/src/nvim/tui/tui.c b/src/nvim/tui/tui.cindex 610419d..3f43c56 100644--- a/src/nvim/tui/tui.c+++ b/src/nvim/tui/tui.c@@ -108,6 +108,7 @@ void tui_start(void)     data->ut = unibi_dummy();   }   fix_terminfo(data);+  unibi_out(ui, unibi_cursor_invisible);   // Enter alternate screen and clear   unibi_out(ui, unibi_enter_ca_mode);   unibi_out(ui, unibi_clear_screen);@@ -530,12 +531,7 @@ static void tui_flush(UI *ui)   unibi_goto(ui, data->row, data->col);-  if (!data->busy) {-    unibi_out(ui, unibi_cursor_normal);-  }-   flush_buf(ui);-  unibi_out(ui, unibi_cursor_invisible); } static void tui_suspend(UI *ui)@@ -792,11 +788,27 @@ static void flush_buf(UI *ui)   static uv_write_t req;   static uv_buf_t buf;   TUIData *data = ui->data;++  static int i = 0;++  i++;+  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+    fprintf(stderr, ""flush %d: drawing -> cursor on -> pending cursor off\n"",+            i);+  } else {+    fprintf(stderr, ""flush %d: drawing\n"", i);+  }+   buf.base = data->buf;   buf.len = data->bufpos;   uv_write(&req, (uv_stream_t *)&data->output_handle, &buf, 1, NULL);   uv_run(data->write_loop, UV_RUN_DEFAULT);   data->bufpos = 0;++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_invisible);+  } } static void destroy_screen(TUIData *data)```",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2158,26540574,2015-03-17T00:25:29Z,src/nvim/tui/tui.c,"@@ -527,7 +529,13 @@ static void tui_flush(UI *ui)   }    unibi_goto(ui, data->row, data->col);++  if (!data->busy) {+    unibi_out(ui, unibi_cursor_normal);+  }+   flush_buf(ui);+  unibi_out(ui, unibi_cursor_invisible);","> In the patch invis_buf is not flushed: Here's a correction to apply on top of the previous patch:``` diffdiff --git a/src/nvim/tui/tui.c b/src/nvim/tui/tui.cindex c25ec28..e320ef7 100644--- a/src/nvim/tui/tui.c+++ b/src/nvim/tui/tui.c@@ -345,21 +345,18 @@ static void tui_cursor_goto(UI *ui, int row, int col)   data->row = row;   data->col = col;   unibi_goto(ui, row, col);-  data->require_invisible_cursor = true; } static void tui_busy_start(UI *ui) {   TUIData *data = ui->data;   data->busy = true;-  data->require_invisible_cursor = true; } static void tui_busy_stop(UI *ui) {   TUIData *data = ui->data;   data->busy = false;-  data->require_invisible_cursor = true; } static void tui_mouse_on(UI *ui)@@ -483,7 +480,6 @@ static void tui_scroll(UI *ui, int count)     invalidate(ui, data->scroll_region.top, data->scroll_region.bot,         data->scroll_region.left, data->scroll_region.right);   }-  data->require_invisible_cursor = true; } static void tui_highlight_set(UI *ui, HlAttrs attrs)@@ -642,6 +638,7 @@ static void unibi_goto(UI *ui, int row, int col)   data->params[0].i = row;   data->params[1].i = col;   unibi_out(ui, unibi_cursor_address);+  data->require_invisible_cursor = true; } static void unibi_out(UI *ui, int unibi_index)@@ -794,25 +791,25 @@ static void flush_buf(UI *ui) {   uv_write_t req;   uv_buf_t buf[2];-  int buf_index = 0;+  unsigned int buf_count = 1;   char invis_buf[64];   TUIData *data = ui->data;-  if (data->require_invisible_cursor) {-    if (!data->busy) {-      unibi_out(ui, unibi_cursor_normal);-    }-+  if (data->require_invisible_cursor || data->busy) {     const char *str = unibi_get_str(data->ut, unibi_cursor_invisible);     buf[0].base = invis_buf;     buf[0].len = unibi_run(str, data->params, invis_buf, sizeof(invis_buf));-    buf_index++;+    buf_count++;     data->require_invisible_cursor = false;++    if (!data->busy) {+      unibi_out(ui, unibi_cursor_normal);+    }   }-  buf[buf_index].base = data->buf;-  buf[buf_index].len = data->bufpos;-  uv_write(&req, (uv_stream_t *)&data->output_handle, buf + buf_index, 1, NULL);+  buf[buf_count - 1].base = data->buf;+  buf[buf_count - 1].len = data->bufpos;+  uv_write(&req, (uv_stream_t *)&data->output_handle, buf, buf_count, NULL);   uv_run(data->write_loop, UV_RUN_DEFAULT);   data->bufpos = 0; }```Note that this variant only sets `require_invisible_cursor` when the cursor is moved with `unibi_goto`.Your'e right though, your patch is simple and does not seem introduce unwanted cursor flashes. Can you make a PR with this patch?",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2159,26555509,2015-03-17T08:23:15Z,scripts/download-unicode-files.sh,"@@ -0,0 +1,35 @@+#!/bin/sh++set -e++files=""UnicodeData.txt CaseFolding.txt EastAsianWidth.txt""++UNIDIR_DEFAULT=unicode+DOWNLOAD_URL_BASE_DEFAULT='http://unicode.org/Public/UNIDATA'++if test x$1 = 'x--help' ; then+  echo 'Usage:'+  echo ""  $0[ TARGET_DIRECTORY[ URL_BASE]]""+  echo+  echo ""Downloads files $files to TARGET_DIRECTORY.""+  echo ""Each file is downloaded from URL_BASE/\$filename.""+  echo+  echo ""Default target directory is $PWD/${UNIDIR_DEFAULT}.""+  echo ""Default URL base is ${DOWNLOAD_URL_BASE_DEFAULT}.""+fi++UNIDIR=${1:-$UNIDIR_DEFAULT}+DOWNLOAD_URL_BASE=${2:-$DOWNLOAD_URL_BASE_DEFAULT}++for filename in $files ; do+  curl -o ""$UNIDIR/$filename"" ""$DOWNLOAD_URL_BASE/$filename""+  (+    cd ""$UNIDIR""+    git add $filename+  )+done++(+  cd ""$UNIDIR""+  git commit -m ""Update unicode files"" -- $files","Because this essentially does it (as long as it's under version control already).  If you intended it all to work if you add a new file, then you can disregard this. :-)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2148,26637956,2015-03-18T04:43:32Z,src/nvim/os/env.c,"@@ -87,3 +97,598 @@ void os_get_hostname(char *hostname, size_t len) #endif } +/// To get the ""real"" home directory:+///   - get value of $HOME+/// For Unix:+///   - go to that directory+///   - do os_dirname() to get the real name of that directory.+/// This also works with mounts and links.+/// Don't do this for MS-DOS, it will change the ""current dir"" for a drive.+static char_u   *homedir = NULL;++void init_homedir(void)+{+  char_u  *var;++  /* In case we are called a second time (when 'encoding' changes). */+  free(homedir);+  homedir = NULL;++  var = (char_u *)os_getenv(""HOME"");++  if (var != NULL && *var == NUL)       /* empty is same as not set */+    var = NULL;+++  if (var != NULL) {+#ifdef UNIX+    /*+     * Change to the directory and get the actual path.  This resolves+     * links.  Don't do it when we can't return.+     */+    if (os_dirname(NameBuff, MAXPATHL) == OK+        && os_chdir((char *)NameBuff) == 0) {+      if (!os_chdir((char *)var) && os_dirname(IObuff, IOSIZE) == OK)+        var = IObuff;+      if (os_chdir((char *)NameBuff) != 0)+        EMSG(_(e_prev_dir));+    }+#endif+    homedir = vim_strsave(var);+  }+}++#if defined(EXITFREE)++void free_homedir(void)+{+  free(homedir);+}++#endif++/// Call expand_env() and store the result in an allocated string.+/// This is not very memory efficient, this expects the result to be freed+/// again soon.+/// @param src String containing environment variables to expand+/// @see {expand_env}+char_u *expand_env_save(char_u *src)+{+  return expand_env_save_opt(src, false);+}++/// Similar to expand_env_save() but when ""one"" is `true` handle the string as+/// one file name, i.e. only expand ""~"" at the start.+/// @param src String containing environment variables to expand+/// @param one Should treat as only one file name+/// @see {expand_env}+char_u *expand_env_save_opt(char_u *src, bool one)+{+  char_u *p = xmalloc(MAXPATHL);+  expand_env_esc(src, p, MAXPATHL, false, one, NULL);+  return p;+}++/// Expand environment variable with path name.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// @param src Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+void expand_env(char_u *src, char_u *dst, int dstlen)+{+  expand_env_esc(src, dst, dstlen, false, false, NULL);+}++/// Expand environment variable with path name and escaping.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// startstr recognize the start of a new name, for '~' expansion.+/// @param srcp Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param esc Should we escape spaces in expanded variables?+/// @param one Should we expand more than one '~'?+/// @param startstr Common prefix for paths, can be NULL+void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,+                    char_u *startstr)+{+  char_u      *src;+  char_u      *tail;+  int c;+  char_u      *var;+  bool copy_char;+  bool mustfree;                 /* var was allocated, need to free it later */+  bool at_start = true;           /* at start of a name */+  int startstr_len = 0;++  if (startstr != NULL)+    startstr_len = (int)STRLEN(startstr);++  src = skipwhite(srcp);+  --dstlen;                 /* leave one char space for ""\,"" */+  while (*src && dstlen > 0) {+    copy_char = true;+    if ((*src == '$') || (*src == '~' && at_start)) {+      mustfree = false;++      /*+       * The variable name is copied into dst temporarily, because it may+       * be a string in read-only memory and a NUL needs to be appended.+       */+      if (*src != '~') {                                /* environment var */+        tail = src + 1;+        var = dst;+        c = dstlen - 1;++#ifdef UNIX+        /* Unix has ${var-name} type environment vars */+        if (*tail == '{' && !vim_isIDc('{')) {+          tail++;               /* ignore '{' */+          while (c-- > 0 && *tail && *tail != '}')+            *var++ = *tail++;+        } else // NOLINT+        // We're going to ask clint.py to ignore this else very nicely+        // because there isn't really a better way to format it without+        // adding more preprocessor logic for just curly braces or breaking+        // curlybrace balance+#endif+        {+          while (c-- > 0 && *tail != NUL && vim_isIDc(*tail)) {+            *var++ = *tail++;+          }+        }++#if defined(UNIX)+        // Verify that we have found the end of a UNIX ${VAR} style variable+        if (src[1] == '{' && *tail != '}') {+          var = NULL;+        } else if (src[1] == '{') {+          ++tail;+        }+#elif defined(MSWIN)+        // Verify that we have foudn the end of a windows %VAR% style variable+        if (src[0] == '%' && *tail != '%') {+          var = NULL;+        } else if (src[0] == '%') {+          ++tail;+        }+#endif+        *var = NUL;+        var = vim_getenv(dst, &mustfree);+      } else if (  src[1] == NUL /* home directory */+                 || vim_ispathsep(src[1])+                 || vim_strchr((char_u *)"" ,\t\n"", src[1]) != NULL) {+        var = homedir;+        tail = src + 1;+      } else {                                        /* user directory */+#if defined(UNIX)+        /*+         * Copy ~user to dst[], so we can put a NUL after it.+         */+        tail = src;+        var = dst;+        c = dstlen - 1;+        while (    c-- > 0+                   && *tail+                   && vim_isfilec(*tail)+                   && !vim_ispathsep(*tail))+          *var++ = *tail++;+        *var = NUL;+        /*+         * Use os_get_user_directory() to get the user directory.+         * If this function fails, the shell is used to+         * expand ~user. This is slower and may fail if the shell+         * does not support ~user (old versions of /bin/sh).+         */+        var = (char_u *)os_get_user_directory((char *)dst + 1);+        mustfree = true;+        if (var == NULL)+        {+          expand_T xpc;++          ExpandInit(&xpc);+          xpc.xp_context = EXPAND_FILES;+          var = ExpandOne(&xpc, dst, NULL,+              WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);+          mustfree = true;+        }+#else+        /* cannot expand user's home directory, so don't try */+        var = NULL;+        tail = (char_u *)"""";            /* for gcc */+#endif /* UNIX */+      }++#ifdef BACKSLASH_IN_FILENAME+      /* If 'shellslash' is set change backslashes to forward slashes.+       * Can't use slash_adjust(), p_ssl may be set temporarily. */+      if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL) {+        char_u  *p = vim_strsave(var);++        if (mustfree) {+          free(var);+        }+        var = p;+        mustfree = true;+        forward_slash(var);+      }+#endif++      /* If ""var"" contains white space, escape it with a backslash.+       * Required for "":e ~/tt"" when $HOME includes a space. */+      if (esc && var != NULL && vim_strpbrk(var, (char_u *)"" \t"") != NULL) {+        char_u  *p = vim_strsave_escaped(var, (char_u *)"" \t"");++        if (mustfree)+          free(var);+        var = p;+        mustfree = true;+      }++      if (var != NULL && *var != NUL+          && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen)) {+        STRCPY(dst, var);+        dstlen -= (int)STRLEN(var);+        c = (int)STRLEN(var);+        /* if var[] ends in a path separator and tail[] starts+         * with it, skip a character */+        if (*var != NUL && after_pathsep(dst, dst + c)+#if defined(BACKSLASH_IN_FILENAME)+            && dst[-1] != ':'+#endif+            && vim_ispathsep(*tail))+          ++tail;+        dst += c;+        src = tail;+        copy_char = false;+      }+      if (mustfree)+        free(var);+    }++    if (copy_char) {        /* copy at least one char */+      /*+       * Recognize the start of a new name, for '~'.+       * Don't do this when ""one"" is true, to avoid expanding ""~"" in+       * "":edit foo ~ foo"".+       */+      at_start = false;+      if (src[0] == '\\' && src[1] != NUL) {+        *dst++ = *src++;+        --dstlen;+      } else if ((src[0] == ' ' || src[0] == ',') && !one) {+        at_start = true;+      }+      *dst++ = *src++;+      --dstlen;++      if (startstr != NULL && src - startstr_len >= srcp+          && STRNCMP(src - startstr_len, startstr, startstr_len) == 0)+        at_start = true;+    }+  }+  *dst = NUL;+}++/// Check if the directory ""vimdir/<version>"" or ""vimdir/runtime"" exists.+/// Return NULL if not, return its name in allocated memory otherwise.+/// @param vimdir directory to test+static char_u *vim_version_dir(char_u *vimdir)+{+  char_u      *p;++  if (vimdir == NULL || *vimdir == NUL)+    return NULL;+  p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, true);+  if (os_isdir(p))+    return p;+  free(p);+  p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, true);+  if (os_isdir(p))+    return p;+  free(p);+  return NULL;+}++/// If the string between ""p"" and ""pend"" ends in ""name/"", return ""pend"" minus+/// the length of ""name/"".  Otherwise return ""pend"".+static char_u *remove_tail(char_u *p, char_u *pend, char_u *name)+{+  int len = (int)STRLEN(name) + 1;+  char_u      *newend = pend - len;++  if (newend >= p+      && fnamencmp(newend, name, len - 1) == 0+      && (newend == p || after_pathsep(p, newend)))+    return newend;+  return pend;+}++/// Vim's version of getenv().+/// Special handling of $HOME, $VIM and $VIMRUNTIME, allowing the user to+/// override the vim runtime directory at runtime.  Also does ACP to 'enc'+/// conversion for Win32.+/// @param name Name of environment variable to expand+/// @param mustfree Ouput parameter for the caller to determine if they are","I think `@param[out]` indicates an output param. So:```@param[out] mustfree true if the caller must free the returned object.             Caller must initialize to false.```""Must"" always strongly implies that a condition is required. So ""to work properly"" is redundant.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2148,26638263,2015-03-18T04:55:40Z,src/nvim/os/env.c,"@@ -87,3 +97,598 @@ void os_get_hostname(char *hostname, size_t len) #endif } +/// To get the ""real"" home directory:+///   - get value of $HOME+/// For Unix:+///   - go to that directory+///   - do os_dirname() to get the real name of that directory.+/// This also works with mounts and links.+/// Don't do this for MS-DOS, it will change the ""current dir"" for a drive.+static char_u   *homedir = NULL;++void init_homedir(void)+{+  char_u  *var;++  /* In case we are called a second time (when 'encoding' changes). */+  free(homedir);+  homedir = NULL;++  var = (char_u *)os_getenv(""HOME"");++  if (var != NULL && *var == NUL)       /* empty is same as not set */+    var = NULL;+++  if (var != NULL) {+#ifdef UNIX+    /*+     * Change to the directory and get the actual path.  This resolves+     * links.  Don't do it when we can't return.+     */+    if (os_dirname(NameBuff, MAXPATHL) == OK+        && os_chdir((char *)NameBuff) == 0) {+      if (!os_chdir((char *)var) && os_dirname(IObuff, IOSIZE) == OK)+        var = IObuff;+      if (os_chdir((char *)NameBuff) != 0)+        EMSG(_(e_prev_dir));+    }+#endif+    homedir = vim_strsave(var);+  }+}++#if defined(EXITFREE)++void free_homedir(void)+{+  free(homedir);+}++#endif++/// Call expand_env() and store the result in an allocated string.+/// This is not very memory efficient, this expects the result to be freed+/// again soon.+/// @param src String containing environment variables to expand+/// @see {expand_env}+char_u *expand_env_save(char_u *src)+{+  return expand_env_save_opt(src, false);+}++/// Similar to expand_env_save() but when ""one"" is `true` handle the string as+/// one file name, i.e. only expand ""~"" at the start.+/// @param src String containing environment variables to expand+/// @param one Should treat as only one file name+/// @see {expand_env}+char_u *expand_env_save_opt(char_u *src, bool one)+{+  char_u *p = xmalloc(MAXPATHL);+  expand_env_esc(src, p, MAXPATHL, false, one, NULL);+  return p;+}++/// Expand environment variable with path name.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// @param src Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+void expand_env(char_u *src, char_u *dst, int dstlen)+{+  expand_env_esc(src, dst, dstlen, false, false, NULL);+}++/// Expand environment variable with path name and escaping.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// startstr recognize the start of a new name, for '~' expansion.+/// @param srcp Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param esc Should we escape spaces in expanded variables?+/// @param one Should we expand more than one '~'?+/// @param startstr Common prefix for paths, can be NULL+void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,+                    char_u *startstr)+{+  char_u      *src;+  char_u      *tail;+  int c;+  char_u      *var;+  bool copy_char;+  bool mustfree;                 /* var was allocated, need to free it later */+  bool at_start = true;           /* at start of a name */+  int startstr_len = 0;++  if (startstr != NULL)+    startstr_len = (int)STRLEN(startstr);++  src = skipwhite(srcp);+  --dstlen;                 /* leave one char space for ""\,"" */+  while (*src && dstlen > 0) {+    copy_char = true;+    if ((*src == '$') || (*src == '~' && at_start)) {+      mustfree = false;++      /*+       * The variable name is copied into dst temporarily, because it may+       * be a string in read-only memory and a NUL needs to be appended.+       */+      if (*src != '~') {                                /* environment var */+        tail = src + 1;+        var = dst;+        c = dstlen - 1;++#ifdef UNIX+        /* Unix has ${var-name} type environment vars */+        if (*tail == '{' && !vim_isIDc('{')) {+          tail++;               /* ignore '{' */+          while (c-- > 0 && *tail && *tail != '}')+            *var++ = *tail++;+        } else // NOLINT+        // We're going to ask clint.py to ignore this else very nicely+        // because there isn't really a better way to format it without+        // adding more preprocessor logic for just curly braces or breaking+        // curlybrace balance+#endif+        {+          while (c-- > 0 && *tail != NUL && vim_isIDc(*tail)) {+            *var++ = *tail++;+          }+        }++#if defined(UNIX)+        // Verify that we have found the end of a UNIX ${VAR} style variable+        if (src[1] == '{' && *tail != '}') {+          var = NULL;+        } else if (src[1] == '{') {+          ++tail;+        }+#elif defined(MSWIN)+        // Verify that we have foudn the end of a windows %VAR% style variable+        if (src[0] == '%' && *tail != '%') {+          var = NULL;+        } else if (src[0] == '%') {+          ++tail;+        }+#endif+        *var = NUL;+        var = vim_getenv(dst, &mustfree);+      } else if (  src[1] == NUL /* home directory */+                 || vim_ispathsep(src[1])+                 || vim_strchr((char_u *)"" ,\t\n"", src[1]) != NULL) {+        var = homedir;+        tail = src + 1;+      } else {                                        /* user directory */+#if defined(UNIX)+        /*+         * Copy ~user to dst[], so we can put a NUL after it.+         */+        tail = src;+        var = dst;+        c = dstlen - 1;+        while (    c-- > 0+                   && *tail+                   && vim_isfilec(*tail)+                   && !vim_ispathsep(*tail))+          *var++ = *tail++;+        *var = NUL;+        /*+         * Use os_get_user_directory() to get the user directory.+         * If this function fails, the shell is used to+         * expand ~user. This is slower and may fail if the shell+         * does not support ~user (old versions of /bin/sh).+         */+        var = (char_u *)os_get_user_directory((char *)dst + 1);+        mustfree = true;+        if (var == NULL)+        {+          expand_T xpc;++          ExpandInit(&xpc);+          xpc.xp_context = EXPAND_FILES;+          var = ExpandOne(&xpc, dst, NULL,+              WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);+          mustfree = true;+        }+#else+        /* cannot expand user's home directory, so don't try */+        var = NULL;+        tail = (char_u *)"""";            /* for gcc */+#endif /* UNIX */+      }++#ifdef BACKSLASH_IN_FILENAME+      /* If 'shellslash' is set change backslashes to forward slashes.+       * Can't use slash_adjust(), p_ssl may be set temporarily. */+      if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL) {+        char_u  *p = vim_strsave(var);++        if (mustfree) {+          free(var);+        }+        var = p;+        mustfree = true;+        forward_slash(var);+      }+#endif++      /* If ""var"" contains white space, escape it with a backslash.+       * Required for "":e ~/tt"" when $HOME includes a space. */+      if (esc && var != NULL && vim_strpbrk(var, (char_u *)"" \t"") != NULL) {+        char_u  *p = vim_strsave_escaped(var, (char_u *)"" \t"");++        if (mustfree)+          free(var);+        var = p;+        mustfree = true;+      }++      if (var != NULL && *var != NUL+          && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen)) {+        STRCPY(dst, var);+        dstlen -= (int)STRLEN(var);+        c = (int)STRLEN(var);+        /* if var[] ends in a path separator and tail[] starts+         * with it, skip a character */+        if (*var != NUL && after_pathsep(dst, dst + c)+#if defined(BACKSLASH_IN_FILENAME)+            && dst[-1] != ':'+#endif+            && vim_ispathsep(*tail))+          ++tail;+        dst += c;+        src = tail;+        copy_char = false;+      }+      if (mustfree)+        free(var);+    }++    if (copy_char) {        /* copy at least one char */+      /*+       * Recognize the start of a new name, for '~'.+       * Don't do this when ""one"" is true, to avoid expanding ""~"" in+       * "":edit foo ~ foo"".+       */+      at_start = false;+      if (src[0] == '\\' && src[1] != NUL) {+        *dst++ = *src++;+        --dstlen;+      } else if ((src[0] == ' ' || src[0] == ',') && !one) {+        at_start = true;+      }+      *dst++ = *src++;+      --dstlen;++      if (startstr != NULL && src - startstr_len >= srcp+          && STRNCMP(src - startstr_len, startstr, startstr_len) == 0)+        at_start = true;+    }+  }+  *dst = NUL;+}++/// Check if the directory ""vimdir/<version>"" or ""vimdir/runtime"" exists.+/// Return NULL if not, return its name in allocated memory otherwise.+/// @param vimdir directory to test+static char_u *vim_version_dir(char_u *vimdir)+{+  char_u      *p;++  if (vimdir == NULL || *vimdir == NUL)+    return NULL;+  p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, true);+  if (os_isdir(p))+    return p;+  free(p);+  p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, true);+  if (os_isdir(p))+    return p;+  free(p);+  return NULL;+}++/// If the string between ""p"" and ""pend"" ends in ""name/"", return ""pend"" minus+/// the length of ""name/"".  Otherwise return ""pend"".+static char_u *remove_tail(char_u *p, char_u *pend, char_u *name)+{+  int len = (int)STRLEN(name) + 1;+  char_u      *newend = pend - len;++  if (newend >= p+      && fnamencmp(newend, name, len - 1) == 0+      && (newend == p || after_pathsep(p, newend)))+    return newend;+  return pend;+}++/// Vim's version of getenv().+/// Special handling of $HOME, $VIM and $VIMRUNTIME, allowing the user to+/// override the vim runtime directory at runtime.  Also does ACP to 'enc'+/// conversion for Win32.+/// @param name Name of environment variable to expand+/// @param mustfree Ouput parameter for the caller to determine if they are+///           responsible for releasing memory. Must be initialized to false+///           by the caller in order to work properly.+char_u *vim_getenv(char_u *name, bool *mustfree)+{+  char_u      *p;+  char_u      *pend;+  int vimruntime;+++  p = (char_u *)os_getenv((char *)name);+  if (p != NULL && *p == NUL)       /* empty is the same as not set */+    p = NULL;++  if (p != NULL) {+    return p;+  }++  vimruntime = (STRCMP(name, ""VIMRUNTIME"") == 0);+  if (!vimruntime && STRCMP(name, ""VIM"") != 0)+    return NULL;++  /*+   * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.+   * Don't do this when default_vimruntime_dir is non-empty.+   */+  if (vimruntime+#ifdef HAVE_PATHDEF+      && *default_vimruntime_dir == NUL+#endif+      ) {+    p = (char_u *)os_getenv(""VIM"");+    if (p != NULL && *p == NUL)             /* empty is the same as not set */+      p = NULL;+    if (p != NULL) {+      p = vim_version_dir(p);+      if (p != NULL)+        *mustfree = true;+      else+        p = (char_u *)os_getenv(""VIM"");+    }+  }++  /*+   * When expanding $VIM or $VIMRUNTIME fails, try using:+   * - the directory name from 'helpfile' (unless it contains '$')+   * - the executable name from argv[0]+   */+  if (p == NULL) {+    if (p_hf != NULL && vim_strchr(p_hf, '$') == NULL)+      p = p_hf;+    if (p != NULL) {+      /* remove the file name */+      pend = path_tail(p);++      /* remove ""doc/"" from 'helpfile', if present */+      if (p == p_hf)+        pend = remove_tail(p, pend, (char_u *)""doc"");++      /* for $VIM, remove ""runtime/"" or ""vim54/"", if present */+      if (!vimruntime) {+        pend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);+        pend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);+      }++      /* remove trailing path separator */+      /* With MacOS path (with  colons) the final colon is required */+      /* to avoid confusion between absolute and relative path */+      if (pend > p && after_pathsep(p, pend))+        --pend;++      // check that the result is a directory name+      // pend should always be greater than p, so casting to an unsigned type+      // should be safe here+      p = vim_strnsave(p, (size_t)(pend - p));++      if (!os_isdir(p)) {+        free(p);+        p = NULL;+      } else {+        *mustfree = true;+      }+    }+  }++#ifdef HAVE_PATHDEF+  /* When there is a pathdef.c file we can use default_vim_dir and+   * default_vimruntime_dir */+  if (p == NULL) {+    /* Only use default_vimruntime_dir when it is not empty */+    if (vimruntime && *default_vimruntime_dir != NUL) {+      p = default_vimruntime_dir;+      *mustfree = false;+    } else if (*default_vim_dir != NUL) {+      if (vimruntime && (p = vim_version_dir(default_vim_dir)) != NULL) {+        *mustfree = true;+      } else {+        p = default_vim_dir;+        *mustfree = false;+      }+    }+  }+#endif++  /*+   * Set the environment variable, so that the new value can be found fast+   * next time, and others can also use it (e.g. Perl).+   */+  if (p != NULL) {+    if (vimruntime) {+      vim_setenv((char_u *)""VIMRUNTIME"", p);+      didset_vimruntime = true;+    } else {+      vim_setenv((char_u *)""VIM"", p);+      didset_vim = true;+    }+  }+  return p;+}++/// Replace home directory by ""~"" in each space or comma separated file name in+/// 'src'.+/// If anything fails (except when out of space) dst equals src.+/// @param buf When not NULL, check for help files+/// @param src Input file name+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param one If true, only replace one file name, include spaces and commas+///           in the file name i.e. treat the argument as if it was one+///           filename, not a list of filenames to be expanded.+void home_replace(buf_T *buf, char_u *src, char_u *dst, int dstlen, bool one)+{+  size_t dirlen = 0, envlen = 0;+  size_t len;+  char_u      *homedir_env, *homedir_env_orig;+  char_u      *p;++  if (src == NULL) {+    *dst = NUL;+    return;+  }++  /*+   * If the file is a help file, remove the path completely.+   */+  if (buf != NULL && buf->b_help) {+    STRCPY(dst, path_tail(src));+    return;+  }++  /*+   * We check both the value of the $HOME environment variable and the+   * ""real"" home directory.+   */+  if (homedir != NULL)+    dirlen = STRLEN(homedir);++  homedir_env_orig = homedir_env = (char_u *)os_getenv(""HOME"");+  /* Empty is the same as not set. */+  if (homedir_env != NULL && *homedir_env == NUL)+    homedir_env = NULL;++  if (homedir_env != NULL && vim_strchr(homedir_env, '~') != NULL) {+    int usedlen = 0;+    int flen;+    char_u  *fbuf = NULL;++    flen = (int)STRLEN(homedir_env);+    (void)modify_fname((char_u *)"":p"", &usedlen,+        &homedir_env, &fbuf, &flen);+    flen = (int)STRLEN(homedir_env);+    if (flen > 0 && vim_ispathsep(homedir_env[flen - 1]))+      /* Remove the trailing / that is added to a directory. */+      homedir_env[flen - 1] = NUL;+  }++  if (homedir_env != NULL)+    envlen = STRLEN(homedir_env);++  if (!one)+    src = skipwhite(src);+  while (*src && dstlen > 0) {+    /*+     * Here we are at the beginning of a file name.+     * First, check to see if the beginning of the file name matches+     * $HOME or the ""real"" home directory. Check that there is a '/'+     * after the match (so that if e.g. the file is ""/home/pieter/bla"",+     * and the home directory is ""/home/piet"", the file does not end up+     * as ""~er/bla"" (which would seem to indicate the file ""bla"" in user+     * er's home directory)).+     */+    p = homedir;+    len = dirlen;+    for (;; ) {+      if (   len+             && fnamencmp(src, p, len) == 0+             && (vim_ispathsep(src[len])+                 || (!one && (src[len] == ',' || src[len] == ' '))+                 || src[len] == NUL)) {+        src += len;+        if (--dstlen > 0)+          *dst++ = '~';++        /*+         * If it's just the home directory, add  ""/"".+         */+        if (!vim_ispathsep(src[0]) && --dstlen > 0)+          *dst++ = '/';+        break;+      }+      if (p == homedir_env)+        break;+      p = homedir_env;+      len = envlen;+    }++    /* if (!one) skip to separator: space or comma */+    while (*src && (one || (*src != ',' && *src != ' ')) && --dstlen > 0)+      *dst++ = *src++;+    /* skip separator */+    while ((*src == ' ' || *src == ',') && --dstlen > 0)+      *dst++ = *src++;+  }+  /* if (dstlen == 0) out of space, what to do??? */++  *dst = NUL;++  if (homedir_env != homedir_env_orig)+    free(homedir_env);+}++/// Like home_replace, store the replaced string in allocated memory.+/// @param buf When not NULL, check for help files+/// @param src Input file name+char_u * home_replace_save(buf_T *buf, char_u *src) FUNC_ATTR_NONNULL_RET+{+  size_t len = 3;                      /* space for ""~/"" and trailing NUL */+  if (src != NULL)              /* just in case */+    len += STRLEN(src);+  char_u *dst = xmalloc(len);+  home_replace(buf, src, dst, (int)len, true);+  return dst;+}++/// Our portable version of setenv.+/// Has special handling for $VIMRUNTIME to keep the localization machinery+/// sane.+void vim_setenv(char_u *name, char_u *val)+{+  os_setenv((char *)name, (char *)val, 1);+  /*+   * When setting $VIMRUNTIME adjust the directory to find message+   * translations to $VIMRUNTIME/lang.+   */+  if (*val != NUL && STRICMP(name, ""VIMRUNTIME"") == 0) {+    char_u  *buf = concat_str(val, (char_u *)""/lang"");+    bindtextdomain(VIMPACKAGE, (char *)buf);+    free(buf);+  }+}+++/// Function given to ExpandGeneric() to obtain an environment variable name.+char_u *get_env_name(expand_T *xp, int idx)+{+# define ENVNAMELEN 100+  // this static buffer is needed to avoid a memory leak in ExpandGeneric+  static char_u name[ENVNAMELEN];+  // since it's nonsensical for idx to be negative, we will+  // assume that it is positive and that a cast to size_t is safe","here too... either `assert()` or don't bother, and in either case leave out the speculative comment.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2192,26783764,2015-03-19T18:28:14Z,src/nvim/menu.c,"@@ -1156,13 +1154,17 @@ static char_u *popup_mode_name(char_u *name, int idx) }  -/*- * Duplicate the menu item text and then process to see if a mnemonic key- * and/or accelerator text has been identified.- * Returns a pointer to allocated memory, or NULL for failure.- * If mnemonic != NULL, *mnemonic is set to the character after the first '&'.- * If actext != NULL, *actext is set to the text after the first TAB.- */+/// Duplicate the menu item text and then process to see if a mnemonic key+/// and/or accelerator text has been identified.+///+/// If mnemonic != NULL, *mnemonic is set to the character after the first '&'.",Description can be moved to its parameter.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2192,26805551,2015-03-19T22:46:37Z,src/nvim/menu.c,"@@ -1156,14 +1154,18 @@ static char_u *popup_mode_name(char_u *name, int idx) }  -/*- * Duplicate the menu item text and then process to see if a mnemonic key- * and/or accelerator text has been identified.- * Returns a pointer to allocated memory, or NULL for failure.- * If mnemonic != NULL, *mnemonic is set to the character after the first '&'.- * If actext != NULL, *actext is set to the text after the first TAB.- */+/// Duplicate the menu item text and then process to see if a mnemonic key+/// and/or accelerator text has been identified.+///+/// @param str","Honest question, what's the point of this being here if it doesn't have a description? I understand that the purpose is mostly obvious, but it would be more helpful if there was just a short snippet describing it, like for the other parameters. For example, [this Doxygen page] provides descriptions for some parameters, but many are left out for no obvious reason.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2148,26817045,2015-03-20T03:41:43Z,src/nvim/hardcopy.c,"@@ -32,7 +32,7 @@ #include ""nvim/memline.h"" #include ""nvim/memory.h"" #include ""nvim/message.h""-#include ""nvim/misc1.h""+#include ""nvim/os/os.h""",this is a duplicate include (look below),
1514748,bobtwinkles,https://api.github.com/repos/neovim/neovim/pulls/2148,26820420,2015-03-20T06:07:15Z,src/nvim/os/env.c,"@@ -87,3 +98,591 @@ void os_get_hostname(char *hostname, size_t len) #endif } +/// To get the ""real"" home directory:+///   - get value of $HOME+/// For Unix:+///   - go to that directory+///   - do os_dirname() to get the real name of that directory.+/// This also works with mounts and links.+/// Don't do this for MS-DOS, it will change the ""current dir"" for a drive.+static char_u   *homedir = NULL;++void init_homedir(void)+{+  char_u  *var;++  /* In case we are called a second time (when 'encoding' changes). */+  free(homedir);+  homedir = NULL;++  var = (char_u *)os_getenv(""HOME"");++  if (var != NULL && *var == NUL)       /* empty is same as not set */+    var = NULL;+++  if (var != NULL) {+#ifdef UNIX+    /*+     * Change to the directory and get the actual path.  This resolves+     * links.  Don't do it when we can't return.+     */+    if (os_dirname(NameBuff, MAXPATHL) == OK+        && os_chdir((char *)NameBuff) == 0) {+      if (!os_chdir((char *)var) && os_dirname(IObuff, IOSIZE) == OK)+        var = IObuff;+      if (os_chdir((char *)NameBuff) != 0)+        EMSG(_(e_prev_dir));+    }+#endif+    homedir = vim_strsave(var);+  }+}++#if defined(EXITFREE)++void free_homedir(void)+{+  free(homedir);+}++#endif++/// Call expand_env() and store the result in an allocated string.+/// This is not very memory efficient, this expects the result to be freed+/// again soon.+/// @param src String containing environment variables to expand+/// @see {expand_env}+char_u *expand_env_save(char_u *src)+{+  return expand_env_save_opt(src, false);+}++/// Similar to expand_env_save() but when ""one"" is `true` handle the string as+/// one file name, i.e. only expand ""~"" at the start.+/// @param src String containing environment variables to expand+/// @param one Should treat as only one file name+/// @see {expand_env}+char_u *expand_env_save_opt(char_u *src, bool one)+{+  char_u *p = xmalloc(MAXPATHL);+  expand_env_esc(src, p, MAXPATHL, false, one, NULL);+  return p;+}++/// Expand environment variable with path name.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// @param src Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+void expand_env(char_u *src, char_u *dst, int dstlen)+{+  expand_env_esc(src, dst, dstlen, false, false, NULL);+}++/// Expand environment variable with path name and escaping.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// startstr recognize the start of a new name, for '~' expansion.+/// @param srcp Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param esc Should we escape spaces in expanded variables?+/// @param one Should we expand more than one '~'?+/// @param startstr Common prefix for paths, can be NULL+void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,+                    char_u *startstr)+{+  char_u      *src;+  char_u      *tail;+  int c;+  char_u      *var;+  bool copy_char;+  bool mustfree;                 /* var was allocated, need to free it later */+  bool at_start = true;           /* at start of a name */+  int startstr_len = 0;++  if (startstr != NULL)+    startstr_len = (int)STRLEN(startstr);++  src = skipwhite(srcp);+  --dstlen;                 /* leave one char space for ""\,"" */+  while (*src && dstlen > 0) {+    copy_char = true;+    if ((*src == '$') || (*src == '~' && at_start)) {+      mustfree = false;++      /*+       * The variable name is copied into dst temporarily, because it may+       * be a string in read-only memory and a NUL needs to be appended.+       */+      if (*src != '~') {                                /* environment var */+        tail = src + 1;+        var = dst;+        c = dstlen - 1;++#ifdef UNIX+        /* Unix has ${var-name} type environment vars */+        if (*tail == '{' && !vim_isIDc('{')) {+          tail++;               /* ignore '{' */+          while (c-- > 0 && *tail && *tail != '}')+            *var++ = *tail++;+        } else // NOLINT+#endif+        {+          while (c-- > 0 && *tail != NUL && vim_isIDc(*tail)) {+            *var++ = *tail++;+          }+        }++#if defined(UNIX)+        // Verify that we have found the end of a UNIX ${VAR} style variable+        if (src[1] == '{' && *tail != '}') {+          var = NULL;+        } else if (src[1] == '{') {+          ++tail;+        }+#elif defined(MSWIN)+        // Verify that we have found the end of a Windows %VAR% style variable+        if (src[0] == '%' && *tail != '%') {","I wanted the `src[1]` above and this `src[0]` to be symmetric, and using the array syntax is much cleaner and semantically correct than `*(src + 1)` and `*src` IMHO. However, it doesn't (conceptually, at least to me) make sense to use the array syntax with `tail` because it's a pointer to some arbitrary point in the source array and not an array itself.",
1514748,bobtwinkles,https://api.github.com/repos/neovim/neovim/pulls/2148,26820710,2015-03-20T06:18:21Z,src/nvim/os/env.c,"@@ -87,3 +98,591 @@ void os_get_hostname(char *hostname, size_t len) #endif } +/// To get the ""real"" home directory:+///   - get value of $HOME+/// For Unix:+///   - go to that directory+///   - do os_dirname() to get the real name of that directory.+/// This also works with mounts and links.+/// Don't do this for MS-DOS, it will change the ""current dir"" for a drive.+static char_u   *homedir = NULL;++void init_homedir(void)+{+  char_u  *var;++  /* In case we are called a second time (when 'encoding' changes). */+  free(homedir);+  homedir = NULL;++  var = (char_u *)os_getenv(""HOME"");++  if (var != NULL && *var == NUL)       /* empty is same as not set */+    var = NULL;+++  if (var != NULL) {+#ifdef UNIX+    /*+     * Change to the directory and get the actual path.  This resolves+     * links.  Don't do it when we can't return.+     */+    if (os_dirname(NameBuff, MAXPATHL) == OK+        && os_chdir((char *)NameBuff) == 0) {+      if (!os_chdir((char *)var) && os_dirname(IObuff, IOSIZE) == OK)+        var = IObuff;+      if (os_chdir((char *)NameBuff) != 0)+        EMSG(_(e_prev_dir));+    }+#endif+    homedir = vim_strsave(var);+  }+}++#if defined(EXITFREE)++void free_homedir(void)+{+  free(homedir);+}++#endif++/// Call expand_env() and store the result in an allocated string.+/// This is not very memory efficient, this expects the result to be freed+/// again soon.+/// @param src String containing environment variables to expand+/// @see {expand_env}+char_u *expand_env_save(char_u *src)+{+  return expand_env_save_opt(src, false);+}++/// Similar to expand_env_save() but when ""one"" is `true` handle the string as+/// one file name, i.e. only expand ""~"" at the start.+/// @param src String containing environment variables to expand+/// @param one Should treat as only one file name+/// @see {expand_env}+char_u *expand_env_save_opt(char_u *src, bool one)+{+  char_u *p = xmalloc(MAXPATHL);+  expand_env_esc(src, p, MAXPATHL, false, one, NULL);+  return p;+}++/// Expand environment variable with path name.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// @param src Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+void expand_env(char_u *src, char_u *dst, int dstlen)+{+  expand_env_esc(src, dst, dstlen, false, false, NULL);+}++/// Expand environment variable with path name and escaping.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// startstr recognize the start of a new name, for '~' expansion.+/// @param srcp Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param esc Should we escape spaces in expanded variables?+/// @param one Should we expand more than one '~'?+/// @param startstr Common prefix for paths, can be NULL+void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,+                    char_u *startstr)+{+  char_u      *src;+  char_u      *tail;+  int c;+  char_u      *var;+  bool copy_char;+  bool mustfree;                 /* var was allocated, need to free it later */+  bool at_start = true;           /* at start of a name */+  int startstr_len = 0;++  if (startstr != NULL)+    startstr_len = (int)STRLEN(startstr);++  src = skipwhite(srcp);+  --dstlen;                 /* leave one char space for ""\,"" */+  while (*src && dstlen > 0) {+    copy_char = true;+    if ((*src == '$') || (*src == '~' && at_start)) {+      mustfree = false;++      /*+       * The variable name is copied into dst temporarily, because it may+       * be a string in read-only memory and a NUL needs to be appended.+       */+      if (*src != '~') {                                /* environment var */+        tail = src + 1;+        var = dst;+        c = dstlen - 1;++#ifdef UNIX+        /* Unix has ${var-name} type environment vars */+        if (*tail == '{' && !vim_isIDc('{')) {+          tail++;               /* ignore '{' */+          while (c-- > 0 && *tail && *tail != '}')+            *var++ = *tail++;+        } else // NOLINT+#endif+        {+          while (c-- > 0 && *tail != NUL && vim_isIDc(*tail)) {+            *var++ = *tail++;+          }+        }++#if defined(UNIX)+        // Verify that we have found the end of a UNIX ${VAR} style variable+        if (src[1] == '{' && *tail != '}') {+          var = NULL;+        } else if (src[1] == '{') {+          ++tail;+        }+#elif defined(MSWIN)+        // Verify that we have found the end of a Windows %VAR% style variable+        if (src[0] == '%' && *tail != '%') {+          var = NULL;+        } else if (src[0] == '%') {+          ++tail;+        }+#endif+        *var = NUL;+        var = vim_getenv(dst, &mustfree);+      } else if (  src[1] == NUL /* home directory */+                 || vim_ispathsep(src[1])+                 || vim_strchr((char_u *)"" ,\t\n"", src[1]) != NULL) {+        var = homedir;+        tail = src + 1;+      } else {                                        /* user directory */+#if defined(UNIX)+        /*+         * Copy ~user to dst[], so we can put a NUL after it.+         */+        tail = src;+        var = dst;+        c = dstlen - 1;+        while (    c-- > 0+                   && *tail+                   && vim_isfilec(*tail)+                   && !vim_ispathsep(*tail))+          *var++ = *tail++;+        *var = NUL;+        /*+         * Use os_get_user_directory() to get the user directory.+         * If this function fails, the shell is used to+         * expand ~user. This is slower and may fail if the shell+         * does not support ~user (old versions of /bin/sh).+         */+        var = (char_u *)os_get_user_directory((char *)dst + 1);+        mustfree = true;+        if (var == NULL)+        {+          expand_T xpc;++          ExpandInit(&xpc);+          xpc.xp_context = EXPAND_FILES;+          var = ExpandOne(&xpc, dst, NULL,+              WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);+          mustfree = true;+        }+#else+        /* cannot expand user's home directory, so don't try */+        var = NULL;+        tail = (char_u *)"""";            /* for gcc */+#endif /* UNIX */+      }++#ifdef BACKSLASH_IN_FILENAME+      /* If 'shellslash' is set change backslashes to forward slashes.+       * Can't use slash_adjust(), p_ssl may be set temporarily. */+      if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL) {+        char_u  *p = vim_strsave(var);++        if (mustfree) {+          free(var);+        }+        var = p;+        mustfree = true;+        forward_slash(var);+      }+#endif++      /* If ""var"" contains white space, escape it with a backslash.+       * Required for "":e ~/tt"" when $HOME includes a space. */+      if (esc && var != NULL && vim_strpbrk(var, (char_u *)"" \t"") != NULL) {+        char_u  *p = vim_strsave_escaped(var, (char_u *)"" \t"");++        if (mustfree)+          free(var);+        var = p;+        mustfree = true;+      }++      if (var != NULL && *var != NUL+          && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen)) {+        STRCPY(dst, var);+        dstlen -= (int)STRLEN(var);+        c = (int)STRLEN(var);+        /* if var[] ends in a path separator and tail[] starts+         * with it, skip a character */+        if (*var != NUL && after_pathsep(dst, dst + c)+#if defined(BACKSLASH_IN_FILENAME)+            && dst[-1] != ':'+#endif+            && vim_ispathsep(*tail))+          ++tail;+        dst += c;+        src = tail;+        copy_char = false;+      }+      if (mustfree)+        free(var);+    }++    if (copy_char) {        /* copy at least one char */+      /*+       * Recognize the start of a new name, for '~'.+       * Don't do this when ""one"" is true, to avoid expanding ""~"" in+       * "":edit foo ~ foo"".+       */+      at_start = false;+      if (src[0] == '\\' && src[1] != NUL) {+        *dst++ = *src++;+        --dstlen;+      } else if ((src[0] == ' ' || src[0] == ',') && !one) {+        at_start = true;+      }+      *dst++ = *src++;+      --dstlen;++      if (startstr != NULL && src - startstr_len >= srcp+          && STRNCMP(src - startstr_len, startstr, startstr_len) == 0)+        at_start = true;+    }+  }+  *dst = NUL;+}++/// Check if the directory ""vimdir/<version>"" or ""vimdir/runtime"" exists.+/// Return NULL if not, return its name in allocated memory otherwise.+/// @param vimdir directory to test+static char_u *vim_version_dir(char_u *vimdir)+{+  char_u      *p;++  if (vimdir == NULL || *vimdir == NUL)+    return NULL;+  p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, true);+  if (os_isdir(p))+    return p;+  free(p);+  p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, true);+  if (os_isdir(p))+    return p;+  free(p);+  return NULL;+}++/// If the string between ""p"" and ""pend"" ends in ""name/"", return ""pend"" minus+/// the length of ""name/"".  Otherwise return ""pend"".+static char_u *remove_tail(char_u *p, char_u *pend, char_u *name)+{+  int len = (int)STRLEN(name) + 1;+  char_u      *newend = pend - len;++  if (newend >= p+      && fnamencmp(newend, name, len - 1) == 0+      && (newend == p || after_pathsep(p, newend)))+    return newend;+  return pend;+}++/// Vim's version of getenv().+/// Special handling of $HOME, $VIM and $VIMRUNTIME, allowing the user to+/// override the vim runtime directory at runtime.  Also does ACP to 'enc'","ACP is apparently the Ascii Code Page, and it appears to be Windows translation management magic (https://msdn.microsoft.com/en-us/library/windows/desktop/dd318070%28v=vs.85%29.aspx). Rewording this to ""`Should do ACP  to 'enc'...`"" may not be a terrible idea, since while it is not currently representative of the function's behavior, as with the current directory changing issue in `init_homedir` ACP to `'enc'` conversion seems like a likely pitfall for the Windows porting effort in the future",
1514748,bobtwinkles,https://api.github.com/repos/neovim/neovim/pulls/2148,26872342,2015-03-20T20:14:18Z,src/nvim/os/env.c,"@@ -87,3 +98,591 @@ void os_get_hostname(char *hostname, size_t len) #endif } +/// To get the ""real"" home directory:+///   - get value of $HOME+/// For Unix:+///   - go to that directory+///   - do os_dirname() to get the real name of that directory.+/// This also works with mounts and links.+/// Don't do this for MS-DOS, it will change the ""current dir"" for a drive.+static char_u   *homedir = NULL;++void init_homedir(void)+{+  char_u  *var;++  /* In case we are called a second time (when 'encoding' changes). */+  free(homedir);+  homedir = NULL;++  var = (char_u *)os_getenv(""HOME"");++  if (var != NULL && *var == NUL)       /* empty is same as not set */+    var = NULL;+++  if (var != NULL) {+#ifdef UNIX+    /*+     * Change to the directory and get the actual path.  This resolves+     * links.  Don't do it when we can't return.+     */+    if (os_dirname(NameBuff, MAXPATHL) == OK+        && os_chdir((char *)NameBuff) == 0) {+      if (!os_chdir((char *)var) && os_dirname(IObuff, IOSIZE) == OK)+        var = IObuff;+      if (os_chdir((char *)NameBuff) != 0)+        EMSG(_(e_prev_dir));+    }+#endif+    homedir = vim_strsave(var);+  }+}++#if defined(EXITFREE)++void free_homedir(void)+{+  free(homedir);+}++#endif++/// Call expand_env() and store the result in an allocated string.+/// This is not very memory efficient, this expects the result to be freed+/// again soon.+/// @param src String containing environment variables to expand+/// @see {expand_env}+char_u *expand_env_save(char_u *src)+{+  return expand_env_save_opt(src, false);+}++/// Similar to expand_env_save() but when ""one"" is `true` handle the string as+/// one file name, i.e. only expand ""~"" at the start.+/// @param src String containing environment variables to expand+/// @param one Should treat as only one file name+/// @see {expand_env}+char_u *expand_env_save_opt(char_u *src, bool one)+{+  char_u *p = xmalloc(MAXPATHL);+  expand_env_esc(src, p, MAXPATHL, false, one, NULL);+  return p;+}++/// Expand environment variable with path name.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// @param src Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+void expand_env(char_u *src, char_u *dst, int dstlen)+{+  expand_env_esc(src, dst, dstlen, false, false, NULL);+}++/// Expand environment variable with path name and escaping.+/// ""~/"" is also expanded, using $HOME. For Unix ""~user/"" is expanded.+/// Skips over ""\ "", ""\~"" and ""\$"" (not for Win32 though).+/// If anything fails no expansion is done and dst equals src.+/// startstr recognize the start of a new name, for '~' expansion.+/// @param srcp Input string e.g. ""$HOME/vim.hlp""+/// @param dst Where to put the result+/// @param dstlen Maximum length of the result+/// @param esc Should we escape spaces in expanded variables?+/// @param one Should we expand more than one '~'?+/// @param startstr Common prefix for paths, can be NULL+void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,+                    char_u *startstr)+{+  char_u      *src;+  char_u      *tail;+  int c;+  char_u      *var;+  bool copy_char;+  bool mustfree;                 /* var was allocated, need to free it later */+  bool at_start = true;           /* at start of a name */+  int startstr_len = 0;++  if (startstr != NULL)+    startstr_len = (int)STRLEN(startstr);++  src = skipwhite(srcp);+  --dstlen;                 /* leave one char space for ""\,"" */+  while (*src && dstlen > 0) {+    copy_char = true;+    if ((*src == '$') || (*src == '~' && at_start)) {+      mustfree = false;++      /*+       * The variable name is copied into dst temporarily, because it may+       * be a string in read-only memory and a NUL needs to be appended.+       */+      if (*src != '~') {                                /* environment var */+        tail = src + 1;+        var = dst;+        c = dstlen - 1;++#ifdef UNIX+        /* Unix has ${var-name} type environment vars */+        if (*tail == '{' && !vim_isIDc('{')) {+          tail++;               /* ignore '{' */+          while (c-- > 0 && *tail && *tail != '}')+            *var++ = *tail++;+        } else // NOLINT+#endif+        {+          while (c-- > 0 && *tail != NUL && vim_isIDc(*tail)) {+            *var++ = *tail++;+          }+        }++#if defined(UNIX)+        // Verify that we have found the end of a UNIX ${VAR} style variable+        if (src[1] == '{' && *tail != '}') {+          var = NULL;+        } else if (src[1] == '{') {+          ++tail;+        }+#elif defined(MSWIN)+        // Verify that we have found the end of a Windows %VAR% style variable+        if (src[0] == '%' && *tail != '%') {+          var = NULL;+        } else if (src[0] == '%') {+          ++tail;+        }+#endif+        *var = NUL;+        var = vim_getenv(dst, &mustfree);+      } else if (  src[1] == NUL /* home directory */+                 || vim_ispathsep(src[1])+                 || vim_strchr((char_u *)"" ,\t\n"", src[1]) != NULL) {+        var = homedir;+        tail = src + 1;+      } else {                                        /* user directory */+#if defined(UNIX)+        /*+         * Copy ~user to dst[], so we can put a NUL after it.+         */+        tail = src;+        var = dst;+        c = dstlen - 1;+        while (    c-- > 0+                   && *tail+                   && vim_isfilec(*tail)+                   && !vim_ispathsep(*tail))+          *var++ = *tail++;+        *var = NUL;+        /*+         * Use os_get_user_directory() to get the user directory.+         * If this function fails, the shell is used to+         * expand ~user. This is slower and may fail if the shell+         * does not support ~user (old versions of /bin/sh).+         */+        var = (char_u *)os_get_user_directory((char *)dst + 1);+        mustfree = true;+        if (var == NULL)+        {+          expand_T xpc;++          ExpandInit(&xpc);+          xpc.xp_context = EXPAND_FILES;+          var = ExpandOne(&xpc, dst, NULL,+              WILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);+          mustfree = true;+        }+#else+        /* cannot expand user's home directory, so don't try */+        var = NULL;+        tail = (char_u *)"""";            /* for gcc */+#endif /* UNIX */+      }++#ifdef BACKSLASH_IN_FILENAME+      /* If 'shellslash' is set change backslashes to forward slashes.+       * Can't use slash_adjust(), p_ssl may be set temporarily. */+      if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL) {+        char_u  *p = vim_strsave(var);++        if (mustfree) {+          free(var);+        }+        var = p;+        mustfree = true;+        forward_slash(var);+      }+#endif++      /* If ""var"" contains white space, escape it with a backslash.+       * Required for "":e ~/tt"" when $HOME includes a space. */+      if (esc && var != NULL && vim_strpbrk(var, (char_u *)"" \t"") != NULL) {+        char_u  *p = vim_strsave_escaped(var, (char_u *)"" \t"");++        if (mustfree)+          free(var);+        var = p;+        mustfree = true;+      }++      if (var != NULL && *var != NUL+          && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen)) {+        STRCPY(dst, var);+        dstlen -= (int)STRLEN(var);+        c = (int)STRLEN(var);+        /* if var[] ends in a path separator and tail[] starts+         * with it, skip a character */+        if (*var != NUL && after_pathsep(dst, dst + c)+#if defined(BACKSLASH_IN_FILENAME)+            && dst[-1] != ':'+#endif+            && vim_ispathsep(*tail))+          ++tail;+        dst += c;+        src = tail;+        copy_char = false;+      }+      if (mustfree)+        free(var);+    }++    if (copy_char) {        /* copy at least one char */+      /*+       * Recognize the start of a new name, for '~'.+       * Don't do this when ""one"" is true, to avoid expanding ""~"" in+       * "":edit foo ~ foo"".+       */+      at_start = false;+      if (src[0] == '\\' && src[1] != NUL) {+        *dst++ = *src++;+        --dstlen;+      } else if ((src[0] == ' ' || src[0] == ',') && !one) {+        at_start = true;+      }+      *dst++ = *src++;+      --dstlen;++      if (startstr != NULL && src - startstr_len >= srcp+          && STRNCMP(src - startstr_len, startstr, startstr_len) == 0)+        at_start = true;+    }+  }+  *dst = NUL;+}++/// Check if the directory ""vimdir/<version>"" or ""vimdir/runtime"" exists.+/// Return NULL if not, return its name in allocated memory otherwise.+/// @param vimdir directory to test+static char_u *vim_version_dir(char_u *vimdir)+{+  char_u      *p;++  if (vimdir == NULL || *vimdir == NUL)+    return NULL;+  p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, true);+  if (os_isdir(p))+    return p;+  free(p);+  p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, true);+  if (os_isdir(p))+    return p;+  free(p);+  return NULL;+}++/// If the string between ""p"" and ""pend"" ends in ""name/"", return ""pend"" minus+/// the length of ""name/"".  Otherwise return ""pend"".+static char_u *remove_tail(char_u *p, char_u *pend, char_u *name)+{+  int len = (int)STRLEN(name) + 1;+  char_u      *newend = pend - len;++  if (newend >= p+      && fnamencmp(newend, name, len - 1) == 0+      && (newend == p || after_pathsep(p, newend)))+    return newend;+  return pend;+}++/// Vim's version of getenv().+/// Special handling of $HOME, $VIM and $VIMRUNTIME, allowing the user to+/// override the vim runtime directory at runtime.  Also does ACP to 'enc'","I appreciate your explanation, but I'm not familiar with the directory changing issue you mention.On March 20, 2015 2:18:44 AM EDT, Reed Koser notifications@github.com wrote:> > +/// the length of ""name/"".  Otherwise return ""pend"".> > +static char_u *remove_tail(char_u *p, char_u *pend, char_u *name)> > +{> > -  int len = (int)STRLEN(name) + 1;> > -  char_u      *newend = pend - len;> >   +> > -  if (newend >= p> > -      && fnamencmp(newend, name, len - 1) == 0> > -      && (newend == p || after_pathsep(p, newend)))> > -    return newend;> > -  return pend;> >   +}> >   +> >   +/// Vim's version of getenv().> >   +/// Special handling of $HOME, $VIM and $VIMRUNTIME, allowing the> >   user to> >   +/// override the vim runtime directory at runtime.  Also does ACP to> >   'enc'> > ACP is apparently the Ascii Code Page, and it appears to be Windows> translation management magic> (https://msdn.microsoft.com/en-us/library/windows/desktop/dd318070%28v=vs.85%29.aspx).> Rewording this to ""`Should do ACP  to 'enc'...`"" may not be a terrible> idea, since while it is not currently representative of the function's> behavior, as with the current directory changing issue in> `init_homedir` ACP to `'enc'` conversion seems like a likely pitfall> for the Windows porting effort in the future> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/2148/files#r26820710",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2076,26897255,2015-03-21T22:02:44Z,src/nvim/terminal.c,"@@ -0,0 +1,997 @@+// VT220/xterm-like terminal emulator implementation for Neovim. Powered by+// libvterm(http://www.leonerd.org.uk/code/libvterm/).+//+// libvterm is a pure C99 terminal emulation library with abstract input and+// display. This means that the library needs to read data from the master fd+// and feed VTerm instances, which will invoke user callbacks with screen+// update instructions that must be mirrored to the real display.+//+// Keys are pressed in VTerm instances by calling+// vterm_keyboard_key/vterm_keyboard_unichar, which generates byte streams that+// must be fed back to the master fd.+//+// This implementation uses Neovim buffers as the display mechanism for both the+// visible screen and the scrollback buffer. When focused, the window ""pins"" to+// the bottom of the buffer and mirrors libvterm screen state.+//+// When a line becomes invisible due to a decrease in screen height or because a+// line was pushed up during normal terminal output, we store the line+// information in the scrollback buffer which is mirrored in the Neovim buffer","Perhaps, but I suggested the parens instead because the sentence is already long and hard to follow. Both should work.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2218,26901826,2015-03-22T11:09:40Z,test/functional/legacy/094_visual_mode_operators_spec.lua,"@@ -0,0 +1,165 @@+-- Test for Visual mode and operators.+--+-- Tests for the two kinds of operations: Those executed with Visual mode+-- followed by an operator and those executed via Operator-pending mode. Also+-- part of the test are mappings, counts, and repetition with the . command.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++-- Vim script user functions needed for some of the test cases.+local function source_user_functions()+  source([[+    function MoveToCap()+      call search('\u', 'W')+    endfunction+    function SelectInCaps()+      let [line1, col1] = searchpos('\u', 'bcnW')+      let [line2, col2] = searchpos('.\u', 'nW')+      call setpos(""'<"", [0, line1, col1, 0])+      call setpos(""'>"", [0, line2, col2, 0])+      normal! gv+    endfunction+  ]])+end++describe('Visual mode operation', function()+  setup(clear)++  it('is working', function()+    insert([[+      apple banana cherry+      +      line 1 line 1+      line 2 line 2+      line 3 line 3+      line 4 line 4+      line 5 line 5+      line 6 line 6+      +      xxxxxxxxxxxxx+      xxxxxxxxxxxxx+      xxxxxxxxxxxxx+      xxxxxxxxxxxxx]])++    -- Exercise characterwise Visual mode plus operator, with count and repeat.+    execute('/^apple')+    feed('lvld.l3vd.')++    -- Same in linewise Visual mode.+    execute('/^line 1')+    feed('Vcnewline<esc>j.j2Vd.')++    -- Same in blockwise Visual mode.+    execute('/^xxxx')+    feed('jlc  <esc>l.l2c----<esc>l.')++    -- Assert buffer contents.+    expect([[+      a y+      +      newline+      newline+      +          --------x+          --------x+      xxxx--------x+      xxxx--------x]])+  end)+end)++describe('Visual mode mapping', function()+  setup(function()+    clear()+    source_user_functions()+  end)++  it('is working', function()+    insert([[+      KiwiRaspberryDateWatermelonPeach+      JambuRambutanBananaTangerineMango]])++    -- Set up Visual mode mappings.+    execute('vnoremap W /\\u/s-1<CR>')+    execute('vnoremap iW :<C-U>call SelectInCaps()<CR>')++    -- Do a simple change using the simple vmap, also with count and repeat.+    execute('/^Kiwi')+    feed('vWcNo<esc>l.fD2vd.')++    -- Same, using the vmap that maps to an Ex command.+    execute('/^Jambu')+    feed('llviWc-<esc>l.l2vdl.')++    -- Assert buffer contents.+    expect([[+      NoNoberryach+      --ago]])+  end)+end)++describe('Operator-pending mode mapping', function()+  setup(function()+    clear()+    source_user_functions()+  end)++  it('is working', function()+    insert([[+      PineappleQuinceLoganberryOrangeGrapefruitKiwiZ+      JuniperDurianZ+      LemonNectarineZ]])++    -- Set up Operator-pending mode mappings.+    execute('onoremap W /\\u/<CR>')+    execute('onoremap <Leader>W :<C-U>call MoveToCap()<CR>')+    execute('onoremap iW :<C-U>call SelectInCaps()<CR>')++    -- Do a simple change using the simple omap, also with count and repeat.+    execute('/^Pineapple')+    feed('cW-<esc>l.l2.l.')++    -- Same, using the omap that maps to an Ex command to move the cursor.+    execute('/^Juniper')+    feed('g?\\WfD.')++    -- Same, using the omap that uses Ex and Visual mode (custom text object).+    execute('/^Lemon')+    feed('yiWPlciWNew<esc>fr.')++    -- Assert buffer contents.+    expect([[+      ----Z+      WhavcreQhevnaZ+      LemonNewNewZ]])+  end)+end)++describe('patch 7.3.879', function()+  setup(clear)++  it('is working', function()+    insert([[+      zzzz+      zzzz]])++    -- Start a change operation consisting of operator plus Ex command, like+    -- ""dV:..."" etc., then either+    -- - complete the operation by pressing Enter: as a result the buffer is+    --   changed, taking into account the v/V/CTRL-V modifier given; or+    -- - abort the operation by pressing Escape: no change to the buffer is+    --   carried out.+    execute('/^zzzz')+    feed([[dV:dv::set noma | let v:errmsg = ''<cr>]])+    feed([[d::set ma | put = v:errmsg =~# '^E21' ? 'ok' : 'failed'<cr>]])","You should be able to indent the `feed` blocks, same as `insert` or `expect`. Common prefixed whitespace will be [removed](https://github.com/neovim/neovim/blob/master/test/functional/helpers.lua#L155).But then you'd have to move the first `dV:` to a new line.. not sure right now if that extra newline would be a problem.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2218,26901939,2015-03-22T11:24:08Z,test/functional/legacy/094_visual_mode_operators_spec.lua,"@@ -0,0 +1,165 @@+-- Test for Visual mode and operators.+--+-- Tests for the two kinds of operations: Those executed with Visual mode+-- followed by an operator and those executed via Operator-pending mode. Also+-- part of the test are mappings, counts, and repetition with the . command.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++-- Vim script user functions needed for some of the test cases.+local function source_user_functions()+  source([[+    function MoveToCap()+      call search('\u', 'W')+    endfunction+    function SelectInCaps()+      let [line1, col1] = searchpos('\u', 'bcnW')+      let [line2, col2] = searchpos('.\u', 'nW')+      call setpos(""'<"", [0, line1, col1, 0])+      call setpos(""'>"", [0, line2, col2, 0])+      normal! gv+    endfunction+  ]])+end++describe('Visual mode operation', function()+  setup(clear)++  it('is working', function()+    insert([[+      apple banana cherry+      +      line 1 line 1+      line 2 line 2+      line 3 line 3+      line 4 line 4+      line 5 line 5+      line 6 line 6+      +      xxxxxxxxxxxxx+      xxxxxxxxxxxxx+      xxxxxxxxxxxxx+      xxxxxxxxxxxxx]])++    -- Exercise characterwise Visual mode plus operator, with count and repeat.+    execute('/^apple')+    feed('lvld.l3vd.')++    -- Same in linewise Visual mode.+    execute('/^line 1')+    feed('Vcnewline<esc>j.j2Vd.')++    -- Same in blockwise Visual mode.+    execute('/^xxxx')+    feed('jlc  <esc>l.l2c----<esc>l.')++    -- Assert buffer contents.+    expect([[+      a y+      +      newline+      newline+      +          --------x+          --------x+      xxxx--------x+      xxxx--------x]])+  end)+end)++describe('Visual mode mapping', function()+  setup(function()+    clear()+    source_user_functions()+  end)++  it('is working', function()+    insert([[+      KiwiRaspberryDateWatermelonPeach+      JambuRambutanBananaTangerineMango]])++    -- Set up Visual mode mappings.+    execute('vnoremap W /\\u/s-1<CR>')+    execute('vnoremap iW :<C-U>call SelectInCaps()<CR>')++    -- Do a simple change using the simple vmap, also with count and repeat.+    execute('/^Kiwi')+    feed('vWcNo<esc>l.fD2vd.')++    -- Same, using the vmap that maps to an Ex command.+    execute('/^Jambu')+    feed('llviWc-<esc>l.l2vdl.')++    -- Assert buffer contents.+    expect([[+      NoNoberryach+      --ago]])+  end)+end)++describe('Operator-pending mode mapping', function()+  setup(function()+    clear()+    source_user_functions()+  end)++  it('is working', function()+    insert([[+      PineappleQuinceLoganberryOrangeGrapefruitKiwiZ+      JuniperDurianZ+      LemonNectarineZ]])++    -- Set up Operator-pending mode mappings.+    execute('onoremap W /\\u/<CR>')+    execute('onoremap <Leader>W :<C-U>call MoveToCap()<CR>')+    execute('onoremap iW :<C-U>call SelectInCaps()<CR>')++    -- Do a simple change using the simple omap, also with count and repeat.+    execute('/^Pineapple')+    feed('cW-<esc>l.l2.l.')++    -- Same, using the omap that maps to an Ex command to move the cursor.+    execute('/^Juniper')+    feed('g?\\WfD.')++    -- Same, using the omap that uses Ex and Visual mode (custom text object).+    execute('/^Lemon')+    feed('yiWPlciWNew<esc>fr.')++    -- Assert buffer contents.+    expect([[+      ----Z+      WhavcreQhevnaZ+      LemonNewNewZ]])+  end)+end)++describe('patch 7.3.879', function()+  setup(clear)++  it('is working', function()+    insert([[+      zzzz+      zzzz]])++    -- Start a change operation consisting of operator plus Ex command, like+    -- ""dV:..."" etc., then either+    -- - complete the operation by pressing Enter: as a result the buffer is+    --   changed, taking into account the v/V/CTRL-V modifier given; or+    -- - abort the operation by pressing Escape: no change to the buffer is+    --   carried out.+    execute('/^zzzz')+    feed([[dV:dv::set noma | let v:errmsg = ''<cr>]])+    feed([[d::set ma | put = v:errmsg =~# '^E21' ? 'ok' : 'failed'<cr>]])","Yes, if that's possible, please replace all of them (I also changed the checklist to request this).",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2228,26974677,2015-03-23T20:13:27Z,src/nvim/popupmnu.c,"@@ -219,7 +220,9 @@ void pum_display(pumitem_T *array, int size, int selected)     if (curwin->w_p_rl) {       pum_width = pum_col - pum_scrollbar + 1;     } else {-      pum_width = Columns - pum_col - pum_scrollbar;+      assert(Columns - pum_col - pum_scrollbar >= INT_MIN","There are a lot of asserts to verify parameters are in range. Perhaps we could using something like this?``` c#include <assert.h>#define RANGE(n, min, max) ((n) >= (min) && (n) <= (max))int main(int argc, char **argv){    assert(RANGE(5u - 10, -100, 0));    return 0;}```",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2228,26979835,2015-03-23T21:04:31Z,src/nvim/popupmnu.c,"@@ -219,7 +220,9 @@ void pum_display(pumitem_T *array, int size, int selected)     if (curwin->w_p_rl) {       pum_width = pum_col - pum_scrollbar + 1;     } else {-      pum_width = Columns - pum_col - pum_scrollbar;+      assert(Columns - pum_col - pum_scrollbar >= INT_MIN","By ""shape"" I just mean the concrete way of writing a macro, among the many possible ones.I want the most comfortable one.For example, the one you propose is ok, but you have to type `INT_MIN` and `INT_MAX` every time.It think it's more comfortable something where you just type `INT`, and it deduces `INT_MIN` and `INT_MAX` from them. This is:```#define IN_BOUNDS(type, value) ((value) >= type##_MIN && (value) <= type##_MAX)```It could be named IN_BOUNDS, or IN_RANGE, or whatever else. I don't like RANGE alone, cause it doesn't suggest a condition to me, but something that gets generated. We could also have an IN_RANGE with generic limits min & max, and IN_BOUNDS making use of that for the particular case of checking for value in bounds of a given type.Possibilities are many. That's why I said it takes a little thinking finding the right ""shape"" for this.In any case, we should discuss this in a dedicated issue, better than here.Let's restrict here to this PR's problems, please.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2228,26980196,2015-03-23T21:08:36Z,src/nvim/popupmnu.c,"@@ -219,7 +220,9 @@ void pum_display(pumitem_T *array, int size, int selected)     if (curwin->w_p_rl) {       pum_width = pum_col - pum_scrollbar + 1;     } else {-      pum_width = Columns - pum_col - pum_scrollbar;+      assert(Columns - pum_col - pum_scrollbar >= INT_MIN","Okay, thanks for explaining. I won't distract from this issue anymore.On March 23, 2015 5:04:55 PM EDT, ""Eliseo Mart��nez"" notifications@github.com wrote:> > @@ -219,7 +220,9 @@ void pum_display(pumitem_T *array, int size, int> > selected)> >      if (curwin->w_p_rl) {> >        pum_width = pum_col - pum_scrollbar + 1;> >      } else {> > -      pum_width = Columns - pum_col - pum_scrollbar;> > -      assert(Columns - pum_col - pum_scrollbar >= INT_MIN> > By ""shape"" I just mean the concrete way of writing a macro, among the> many possible ones.> I want the most comfortable one.> For example, the one you propose is ok, but you have to type `INT_MIN`> and `INT_MAX` every time.> It think it's more comfortable something where you just type `INT`, and> it deduces `INT_MIN` and `INT_MAX` from them. This is:> > ```> #define IN_BOUNDS(type, value) ((value) >= type##_MIN && (value) <=> type##_MAX)> ```> > It could be named IN_BOUNDS, or IN_RANGE, or whatever else. I don't> like RANGE alone, cause it doesn't suggest a condition to me, but> something that gets generated. > We could also have an IN_RANGE with generic limits min & max, and> IN_BOUNDS making use of that for the particular case of checking for> value in bounds of a given type.> Possibilities are many. That's why I said it takes a little thinking> finding the right ""shape"" for this.> In any case, we should discuss this in a dedicated issue, better than> here.> Let's restrict here to this PR's problems, please.> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/2228/files#r26979835",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2208,27083038,2015-03-24T23:16:37Z,runtime/doc/nvim_python.txt,"@@ -27,7 +31,15 @@ simple tutorial:   >       $ pip install neovim <-Most Python plugins created for Vim 7.3 should work after these steps.+						       *nvim-python3-quickstart* +If you just want to start using Vim Python3 plugins with Nvim quickly, here's+a simple tutorial:++- Make sure Python 3.3 or above is available in your `$PATH`+- Install the `neovim` Python3 package:+  >+      $ pip3 install neovim+<","Given how similar these instructions are, I think this could just be merged into the above section, so we only need `nvim-python-quickstart`. The whole section could look like something this:```2. Quickstart                        *nvim-python-quickstart*To use Vim Python 2/3 plugins with Nvim, do the following:- For Python 2 plugins, make sure an interpreter for Python 2.6 or 2.7 is available in your `$PATH`, theninstall the `neovim` Python package:  >      $ pip install neovim<- For Python 3 plugins, make sure an interpreter for Python 3.3 or above is available in your `$PATH`, theninstall the `neovim` Python package:  >      $ pip3 install neovim<```",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2227,27125710,2015-03-25T14:34:48Z,src/nvim/if_cscope.c,"@@ -1772,11 +1777,14 @@ static int cs_read_prompt(int i)       if (bufpos < maxlen - 1 && vim_isprintc(ch)) {         // lazy buffer allocation         if (buf == NULL) {-          buf = xmalloc(maxlen);+          assert(maxlen >= 0);+          buf = xmalloc((size_t)maxlen);         }         {           /* append character to the message */-          buf[bufpos++] = ch;+          assert(ch >= 0);+          assert(ch <= CHAR_MAX);","It is planned to replace those range-checking conditions by dedicated macros at some point.Then, it would read like this: `assert(IN_RANGE(INT, ch));`, which wouldn't need further explanation.For asserts requiring explanation, comments are preferred.",
6922115,mseeber,https://api.github.com/repos/neovim/neovim/pulls/2246,27251285,2015-03-26T20:14:23Z,src/nvim/mark.c,"@@ -378,8 +378,8 @@ pos_T *getmark_buf_fnum(buf_T *buf, int c, int changefile, int *fnum)     }   } else if (ASCII_ISLOWER(c)) {      /* normal named mark */     posp = &(buf->b_namedm[c - 'a']);-  } else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c)) {    /* named file mark */-    if (VIM_ISDIGIT(c))+  } else if (ASCII_ISUPPER(c) || isdigit(c)) {    /* named file mark */","The conditionals here looks kind of strange, this is out of the scope of this PR, but maybe note this for later:isdigit(c) is checked twice if ""c"" is a digit, also a manual subtraction is used instead of something like ""tolower()"". (did not evaluate this in detail, but is just jumped into my face when looking over this)",
6922115,mseeber,https://api.github.com/repos/neovim/neovim/pulls/2246,27253724,2015-03-26T20:40:55Z,src/nvim/mark.c,"@@ -378,8 +378,8 @@ pos_T *getmark_buf_fnum(buf_T *buf, int c, int changefile, int *fnum)     }   } else if (ASCII_ISLOWER(c)) {      /* normal named mark */     posp = &(buf->b_namedm[c - 'a']);-  } else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c)) {    /* named file mark */-    if (VIM_ISDIGIT(c))+  } else if (ASCII_ISUPPER(c) || isdigit(c)) {    /* named file mark */","> isdigit(c) is checked twice if ""c"" is a digitIt looks like there would be a lot of duplication if they were separated out like this:```...} else if (ASCII_ISUPPER(c)) {...} else if (isdigit(c)) {...```A `goto` could be used, but the current redundancy is so small I don't really care.> also a manual subtraction is used instead of something like ""tolower()""I've noticed that in a few places in Nvim. Vim works on some platforms that (at least according to function comments) have some odd standard libraries, so It'd probably be worthwhile to deal with that given the platforms we support are relatively sane.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2247,27259981,2015-03-26T21:52:57Z,runtime/doc/job_control.txt,"@@ -37,37 +37,29 @@ for details ============================================================================== 2. Usage						*job-control-usage* -Here's a quick one-liner that creates a job which invokes the ""ls"" shell-command and prints the result:->-    call jobstart('', 'ls', ['-a'])|au JobActivity * echo v:job_data|au!-    JobActivity--In the one-liner above, creating the JobActivity event handler immediately-after the call to jobstart() is not a race because the Nvim job system will-not publish the job result (even though it may receive it) until evaluation of-the chained user commands (`expr1|expr2|...|exprN`) has completed.- Job control is achieved by calling a combination of the |jobstart()|,-|jobsend()| and |jobstop()| functions, and by listening to the |JobActivity|-event. The best way to understand is with a complete example:+|jobsend()| and |jobstop()| functions. The best way to understand is with a+complete example:","maybe just `Here's an example:`. I prefer technical writing to be dry, as it's usually more concise that way.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2227,27267047,2015-03-26T23:47:31Z,src/nvim/if_cscope.c,"@@ -1509,7 +1532,8 @@ static char *cs_parse_results(int cnumber, char *buf, int bufsize, char **contex  */ static void cs_file_results(FILE *f, int *nummatches_a) {-  int i, j;+  size_t i;+  int j;","These could probably be moved down to their respective initializations.Edit: maybe not, there are a lot of these cases in this PR, so doing just this pair would incomplete.",
6922115,mseeber,https://api.github.com/repos/neovim/neovim/pulls/2246,27277860,2015-03-27T06:21:02Z,src/nvim/mark.c,"@@ -378,8 +378,8 @@ pos_T *getmark_buf_fnum(buf_T *buf, int c, int changefile, int *fnum)     }   } else if (ASCII_ISLOWER(c)) {      /* normal named mark */     posp = &(buf->b_namedm[c - 'a']);-  } else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c)) {    /* named file mark */-    if (VIM_ISDIGIT(c))+  } else if (ASCII_ISUPPER(c) || isdigit(c)) {    /* named file mark */","> It looks like there would be a lot of duplication if they were separated out like this:I checked the surrounding code again, makes sense, ack.> so It'd probably be worthwhile to deal with that given the platforms we support are relatively sane.As part of another PR, I guess?",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2267,27283474,2015-03-27T09:31:14Z,src/nvim/normal.c,"@@ -4361,7 +4361,7 @@ static void nv_ident(cmdarg_T *cap)     /* put pattern in search history */     init_history();     add_to_history(HIST_SEARCH, buf, true, NUL);-    normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);+    (void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0);","Reviewers: is this still done nowadays, casting an unused return value to `void`? I haven't been writing any C lately.",
1380357,pbhandari,https://api.github.com/repos/neovim/neovim/pulls/2246,27308333,2015-03-27T16:23:03Z,src/nvim/mark.c,"@@ -378,8 +378,8 @@ pos_T *getmark_buf_fnum(buf_T *buf, int c, int changefile, int *fnum)     }   } else if (ASCII_ISLOWER(c)) {      /* normal named mark */     posp = &(buf->b_namedm[c - 'a']);-  } else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c)) {    /* named file mark */-    if (VIM_ISDIGIT(c))+  } else if (ASCII_ISUPPER(c) || isdigit(c)) {    /* named file mark */","Yes indeed, another PR. I have no plans of doing it if you want to.On March 27, 2015 2:21:25 AM EDT, Markus Seeber notifications@github.com wrote:> > @@ -378,8 +378,8 @@ pos_T _getmark_buf_fnum(buf_T *buf, int c, int> > changefile, int *fnum)> >      }> >    } else if (ASCII_ISLOWER(c)) {      /_ normal named mark */> >      posp = &(buf->b_namedm[c - 'a']);> > -  } else if (ASCII_ISUPPER(c) || VIM_ISDIGIT(c)) {    /\* named file> >   mark */> > -    if (VIM_ISDIGIT(c))> > -  } else if (ASCII_ISUPPER(c) || isdigit(c)) {    /\* named file mark> >   */> > > > It looks like there would be a lot of duplication if they were> > separated out like this:> > I checked the surrounding code again, makes sense, ack.> > > so It'd probably be worthwhile to deal with that given the platforms> > we support are relatively sane.> > As part of another PR, I guess?> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/2246/files#r27277860",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2250,27332673,2015-03-27T21:30:54Z,src/nvim/os/env.c,"@@ -243,19 +243,24 @@ void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,         // Verify that we have found the end of a UNIX ${VAR} style variable         if (src[1] == '{' && *tail != '}') {           var = NULL;-        } else if (src[1] == '{') {-          ++tail;-        }+        } else {+          if (src[1] == '{') {+            ++tail;+          } #elif defined(MSWIN)","This `#elif ... #endif` could be removed completely, because `src[0]` is never '%'. In vim this code was useful, because of this: https://github.com/vim/vim/blob/master/src/misc1.c#L3974-L3976",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2291,27358284,2015-03-29T20:11:06Z,contrib/review-trailers-tooling/README.md,"@@ -0,0 +1,41 @@+## What's this?++A basic set of tools to ease adding review trailers, in order to acknowledge reviewers' work.++## Which trailers are to be added?++- `Helped-by: Full Name <email@address>`+   Added by regular users to particular commits within a PR. Applies to the commit it appears on. Means ""this commit was somehow improved based on suggestions by @reviewer"".+- `Reviewed-by: Full Name <email@address>`+   Added by maintainer to PR merge commit. Applies to whole PR. Means ""these changes were carefully reviewed by @reviewer an he has stated conformity with them.""","> I just think it's a bit of a pity some people make an argument out of that. To me, offense is in the intention, not in the words you use.In general I agree with this. I was just assuming, if we agree trailers are the way to go, this paragraph would be moved to `CONTRIBUTING.md` or similar (as is not really dependent on this particular tool), at which point it would be a ""policy"" document and not ""personal communication"" anymore, and a bit more care might be warranted. But not ""big issue"" or anything, just my opinion :) ",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2250,27360040,2015-03-29T22:31:36Z,src/nvim/os/env.c,"@@ -243,19 +243,24 @@ void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,         // Verify that we have found the end of a UNIX ${VAR} style variable         if (src[1] == '{' && *tail != '}') {           var = NULL;-        } else if (src[1] == '{') {-          ++tail;-        }+        } else {+          if (src[1] == '{') {+            ++tail;+          } #elif defined(MSWIN)","Maybe instead of removing the dead code, we should restore the original code. We'll need it eventually, no?",
1380357,pbhandari,https://api.github.com/repos/neovim/neovim/pulls/2250,27361087,2015-03-30T00:03:31Z,src/nvim/os/env.c,"@@ -243,19 +243,24 @@ void expand_env_esc(char_u *srcp, char_u *dst, int dstlen, bool esc, bool one,         // Verify that we have found the end of a UNIX ${VAR} style variable         if (src[1] == '{' && *tail != '}') {           var = NULL;-        } else if (src[1] == '{') {-          ++tail;-        }+        } else {+          if (src[1] == '{') {+            ++tail;+          } #elif defined(MSWIN)","Far as I can tell, the windows specific control was never introduced into the neovim codebase.Even in the first commit, [this function](https://github.com/neovim/neovim/blob/72cf89bce8e4230dbc161dc5606f48ef9884ba70/src/misc1.c#L3201) has no additional windows specific code.",
1380357,pbhandari,https://api.github.com/repos/neovim/neovim/pulls/2291,27361812,2015-03-30T00:54:47Z,contrib/review-trailers-tooling/README.md,"@@ -0,0 +1,41 @@+## What's this?++A basic set of tools to ease adding review trailers, in order to acknowledge reviewers' work.","Well Git's man pages are pretty dense, but the one you mentioned doesn't seem that bad.On March 29, 2015 5:35:04 PM EDT, ""Eliseo Mart��nez"" notifications@github.com wrote:> > @@ -0,0 +1,41 @@> > +## What's this?> > +> > +A basic set of tools to ease adding review trailers, in order to> > acknowledge reviewers' work.> > Ok. Maybe http://git-scm.com/docs/git-interpret-trailers better?> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/2291/files#r27359403",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2284,27426045,2015-03-30T20:01:02Z,src/nvim/ex_cmds.c,"@@ -2790,51 +2790,13 @@ do_ecmd (     oldbuf = (flags & ECMD_OLDBUF);   } +  buf = curbuf;   if ((flags & ECMD_SET_HELP) || keep_help_flag) {-    char_u  *p;--    curbuf->b_help = true;-    set_string_option_direct((char_u *)""buftype"", -1,-        (char_u *)""help"", OPT_FREE|OPT_LOCAL, 0);--    /*-     * Always set these options after jumping to a help tag, because the-     * user may have an autocommand that gets in the way.-     * Accept all ASCII chars for keywords, except ' ', '*', '""', '|', and-     * latin1 word characters (for translated help files).-     * Only set it when needed, buf_init_chartab() is some work.-     */-    p =-      (char_u *)""!-~,^*,^|,^\"",192-255"";-    if (STRCMP(curbuf->b_p_isk, p) != 0) {-      set_string_option_direct((char_u *)""isk"", -1, p,-          OPT_FREE|OPT_LOCAL, 0);-      check_buf_options(curbuf);-      (void)buf_init_chartab(curbuf, FALSE);-    }--    curbuf->b_p_ts = 8;                 /* 'tabstop' is 8 */-    curwin->w_p_list = FALSE;           /* no list mode */--    curbuf->b_p_ma = FALSE;             /* not modifiable */-    curbuf->b_p_bin = FALSE;            /* reset 'bin' before reading file */-    curwin->w_p_nu = 0;                 /* no line numbers */-    curwin->w_p_rnu = 0;                /* no relative line numbers */-    RESET_BINDING(curwin);              /* no scroll or cursor binding */-    curwin->w_p_arab = FALSE;           /* no arabic mode */-    curwin->w_p_rl  = FALSE;            /* help window is left-to-right */-    curwin->w_p_fen = FALSE;            /* No folding in the help window */-    curwin->w_p_diff = FALSE;           /* No 'diff' */-    curwin->w_p_spell = FALSE;          /* No spell checking */--    buf = curbuf;-    set_buflisted(FALSE);-  } else {-    buf = curbuf;-    /* Don't make a buffer listed if it's a help buffer.  Useful when-     * using CTRL-O to go back to a help file. */-    if (!curbuf->b_help)-      set_buflisted(TRUE);","The patch removes `buf = curbuf`, but keeps this conditional.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2085,27513785,2015-03-31T19:25:58Z,src/nvim/menu.c,"@@ -127,7 +128,7 @@ ex_menu (     }     arg = skipwhite(arg);   } else if (eap->addr_count && eap->line2 != 0) {-    pri_tab[0] = eap->line2;+    pri_tab[0] = (int) eap->line2;","It certainly looks like it, given that line2 is a `long`.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2228,27523772,2015-03-31T21:12:34Z,src/nvim/popupmnu.c,"@@ -219,7 +220,9 @@ void pum_display(pumitem_T *array, int size, int selected)     if (curwin->w_p_rl) {       pum_width = pum_col - pum_scrollbar + 1;     } else {-      pum_width = Columns - pum_col - pum_scrollbar;+      assert(Columns - pum_col - pum_scrollbar >= INT_MIN","One of the overflow checks could be removed, but this is not immediatley to see.The condition `Columns - pum_col - pum_scrollbar >= INT_MIN` should be always true at this point. The `if` on line 215 tests for something similar and we know that `pum_scrollbar` is `0` or `1` which is never bigger than `PUM_DEF_WIDTH` or `max_width`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2314,27545242,2015-04-01T05:07:04Z,runtime/autoload/vimexpect.vim,"@@ -0,0 +1,158 @@+"" vimexpect.vim is a small object-oriented library that simplifies the task of+"" scripting communication with jobs or any interactive program. The name+"" `expect` comes from the famous tcl extension that has the same purpose.+""+"" This library is built upon two simple concepts: Parsers and States.+""+"" A State represents a program state and associates a set of regular+"" expressions(to parse program output) with method names(to deal with parsed+"" output). States are created with the vimexpect#State(patterns) function.+""+"" A Parser manages data received from the program. It also manages State+"" objects by storing them into a stack, where the top of the stack is the+"" current State. Parsers are created with the vimexpect#Parser(initial_state,+"" target) function+""+"" The State methods are defined by the user, and are always called with `self`+"" set as the Parser target. Advanced control flow is achieved by changing the+"" current state with the `push`/`pop`/`switch` parser methods.+""+"" An example of this library in action can be found in Neovim source+"" code(contrib/neovim_gdb subdirectory)++"" Private API {{{+let s:State = {}+++"" Create a new State instance with a list where each item is a [regexp, name]+"" pair. A method named `name` must be defined in the created instance.+function s:State.create(patterns)+  let this = copy(self)+  let this._patterns = a:patterns+  return this+endfunction+++let s:Parser = {}+let s:Parser.LINE_BUFFER_MAX_LEN = 100+++"" Create a new Parser instance with the initial state and a target. The target+"" is a dictionary that will be the `self` of every State method call associated+"" with the parser, and may contain options normally passed to+"" `jobstart`(on_stdout/on_stderr will be overriden). Returns the target so it+"" can be called directly as the second argument of `jobstart`:+""+"" call jobstart(prog_argv, vimexpect#Parser(initial_state, {'pty': 1}))+function s:Parser.create(initial_state, target)+  let parser = copy(self)+  let parser._line_buffer = []+  let parser._stack = [a:initial_state]+  let parser._target = a:target+  let parser._target.on_stdout = function('s:JobOutput')+  let parser._target.on_stderr = function('s:JobOutput')+  let parser._target._parser = parser+  return parser._target+endfunction+++"" Push a state to the state stack+function s:Parser.push(state)+  call add(self._stack, a:state)+endfunction+++"" Pop a state from the state stack. Fails if there's only one state remaining.+function s:Parser.pop()+  if len(self._stack) == 1+    throw 'State stack cannot be empty'","I would highly suggest make all thrown messages use ���{plugin prefix}:{error code}:{Message}��� convention. Reason: thrown errors are normally part of the API and `{Message}` part does not look like good candidate for matching in `catch` (too long, looks much like a subject to translation and is definitely a subject to typos correction or convention switches like `State stack cannot be empty` vs `State stack cannot be empty.`). I.e.```throw 'vimexpect:emptystack:State stack cannot be empty'```or```throw 'emptystack:State stack cannot be empty'```matched with `catch /^vimexpect:emptystack:/`.This is only the case if you want thrown errors be the part of the API. I think this is good for libraries.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2192,27570157,2015-04-01T13:49:53Z,src/nvim/menu.c,"@@ -1156,14 +1154,18 @@ static char_u *popup_mode_name(char_u *name, int idx) }  -/*- * Duplicate the menu item text and then process to see if a mnemonic key- * and/or accelerator text has been identified.- * Returns a pointer to allocated memory, or NULL for failure.- * If mnemonic != NULL, *mnemonic is set to the character after the first '&'.- * If actext != NULL, *actext is set to the text after the first TAB.- */+/// Duplicate the menu item text and then process to see if a mnemonic key+/// and/or accelerator text has been identified.+///+/// @param str The menu item text.+/// @param[out] mnemonic If non-NULL, *mnemonic is set to the character after+///             the first '&'.+/// @param[out] actext If non-NULL, *actext is set to the text after the first+///             TAB.+///+/// @return a pointer to allocated memory. static char_u *menu_text(char_u *str, int *mnemonic, char_u **actext)+  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT","That'd be fine, but I think this PR is large enough that the `FUNC_ATTR`s won't outshine the rest.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2327,27581105,2015-04-01T15:38:34Z,src/nvim/api/vim.c,"@@ -232,8 +232,7 @@ void vim_change_directory(String dir, Error *err)   }    char string[MAXPATHL];-  strncpy(string, dir.data, dir.size);-  string[dir.size] = NUL;+  xstrlcpy(string, dir.data, dir.size+1);","Scratch that, if you look at the definition of `xstrlcpy()`,``` csize_t xstrlcpy(char *restrict dst, const char *restrict src, size_t size) {    size_t ret = strlen(src);    // ...}```If the concern is that `dir.data` may not be `NUL` terminated, then `xstrlcpy()` may not be used.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/1805,27609554,2015-04-01T20:44:27Z,src/nvim/undo.c,"@@ -1303,43 +1315,42 @@ void u_read_undo(char_u *name, char_u *hash, char_u *orig_name)   }    /* Read undo data for ""U"" command. */-  str_len = get4c(fp);+  str_len = undo_read_4c(&bi);   if (str_len < 0)     goto error;   if (str_len > 0)-    line_ptr = READ_STRING(fp, str_len);-  line_lnum = (linenr_T)get4c(fp);-  line_colnr = (colnr_T)get4c(fp);+    line_ptr = undo_read_string(&bi, (size_t)str_len);",I think this statement just longs for a pair of curlies.,
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2295,27671367,2015-04-02T16:06:00Z,src/nvim/testdir/bench_re_freeze.in,"@@ -0,0 +1,13 @@+Test for Benchmarking RE engine","> We really want to get rid of the testdir/ directoryAbsolutely, @justinmk. But then I need some assistance here. This test is not part of the old test suite, in fact the patch introduced a new make target `benchmark` to run it. It's a benchmark that doesn't verify functionality, it just does an expensive search and prints how long the search took. It takes about 15s to run and must be inspected by a human.So what to do with it? I did a quick search for Lua benchmarking frameworks and didn't find anything. I don't think we want to make it part of the legacy test suite, it would slow things down a lot without adding any value.That's why I just added it in this pull request. I don't know how to handle this atm.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/1805,27688920,2015-04-02T19:28:31Z,src/nvim/undo.c,"@@ -1263,103 +1250,122 @@ void u_read_undo(char_u *name, char_u *hash, char_u *orig_name)     verbose_leave();   } -  fp = mch_fopen((char *)file_name, ""r"");+  FILE *fp = mch_fopen((char *)file_name, ""r"");   if (fp == NULL) {-    if (name != NULL || p_verbose > 0)+    if (name != NULL || p_verbose > 0) {       EMSG2(_(""E822: Cannot open undo file for reading: %s""), file_name);+    }     goto error;   } -  /*-   * Read the undo file header.-   */+  bufinfo_T bi;+  bi.bi_buf = curbuf;+  bi.bi_fp = fp;++  // Read the undo file header.+  char_u magic_buf[UF_START_MAGIC_LEN];   if (fread(magic_buf, UF_START_MAGIC_LEN, 1, fp) != 1       || memcmp(magic_buf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0) {     EMSG2(_(""E823: Not an undo file: %s""), file_name);     goto error;   }-  version = get2c(fp);+  int version = get2c(fp);   if (version != UF_VERSION) {     EMSG2(_(""E824: Incompatible undo file: %s""), file_name);     goto error;   } -  if (fread(read_hash, UNDO_HASH_SIZE, 1, fp) != 1) {+  char_u read_hash[UNDO_HASH_SIZE];+  if (!undo_read(&bi, read_hash, UNDO_HASH_SIZE)) {     corruption_error(""hash"", file_name);     goto error;   }-  line_count = (linenr_T)get4c(fp);+  linenr_T line_count = (linenr_T)undo_read_4c(&bi);   if (memcmp(hash, read_hash, UNDO_HASH_SIZE) != 0       || line_count != curbuf->b_ml.ml_line_count) {     if (p_verbose > 0 || name != NULL) {-      if (name == NULL)+      if (name == NULL) {         verbose_enter();+      }       give_warning((char_u *)           _(""File contents changed, cannot use undo info""), true);-      if (name == NULL)+      if (name == NULL) {         verbose_leave();+      }     }     goto error;   } -  /* Read undo data for ""U"" command. */-  str_len = get4c(fp);-  if (str_len < 0)+  // Read undo data for ""U"" command.+  int str_len = undo_read_4c(&bi);+  if (str_len < 0) {     goto error;-  if (str_len > 0)-    line_ptr = READ_STRING(fp, str_len);-  line_lnum = (linenr_T)get4c(fp);-  line_colnr = (colnr_T)get4c(fp);+  }++  char_u *line_ptr = NULL;+  if (str_len > 0) {+    line_ptr = undo_read_string(&bi, (size_t)str_len);+  }+  linenr_T line_lnum = (linenr_T)undo_read_4c(&bi);+  colnr_T line_colnr = (colnr_T)undo_read_4c(&bi);   if (line_lnum < 0 || line_colnr < 0) {     corruption_error(""line lnum/col"", file_name);     goto error;   } -  /* Begin general undo data */-  old_header_seq = get4c(fp);-  new_header_seq = get4c(fp);-  cur_header_seq = get4c(fp);-  num_head = get4c(fp);-  seq_last = get4c(fp);-  seq_cur = get4c(fp);-  seq_time = get8ctime(fp);+  // Begin general undo data+  int old_header_seq = undo_read_4c(&bi);+  int new_header_seq = undo_read_4c(&bi);+  int cur_header_seq = undo_read_4c(&bi);+  int num_head = undo_read_4c(&bi);+  int seq_last = undo_read_4c(&bi);+  int seq_cur = undo_read_4c(&bi);","These were originally `long`, but as `undo_read_4c` returns `int`s, I changed their type.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2244,27765348,2015-04-04T01:33:57Z,src/nvim/ops.c,"@@ -1125,7 +1146,6 @@ insert_reg (   if (regname != NUL && !valid_yank_reg(regname, FALSE))     return FAIL; -  get_clipboard(regname); ","Should probably collapse the whitespace around this, given the surrounding if statements are somewhat similar.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2295,27775917,2015-04-05T09:06:12Z,src/nvim/regexp_nfa.c,"@@ -6068,8 +6082,12 @@ static long nfa_regtry(nfa_regprog_T *prog, colnr_T col)   clear_sub(&subs.synt);   clear_sub(&m.synt); -  if (nfa_regmatch(prog, start, &subs, &m) == FALSE)+  result = nfa_regmatch(prog, start, &subs, &m);+  if (result == FALSE) {     return 0;+  } else if (result == NFA_TOO_EXPENSIVE) {+    return result;+  }","@splinterofchaos Thanks very much for looking this over!I'm not comfortable touching too many `TRUE`/`FALSE`s at the moment, I have a feeling there are semantic subtleties that I might miss (here it's explicitly returning `0` instead of the `FALSE` result, which would of course be the same since it's `#def`ed to be `0`).But I will change it if you insist.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2295,27776507,2015-04-05T11:28:24Z,src/nvim/regexp.c,"@@ -7036,29 +7033,63 @@ void vim_regfree(regprog_T *prog)     prog->engine->regfree(prog); } -/*- * Match a regexp against a string.- * ""rmp->regprog"" is a compiled regexp as returned by vim_regcomp().- * Uses curbuf for line count and 'iskeyword'.- *- * Return TRUE if there is a match, FALSE if not.- */-int -vim_regexec (-    regmatch_T *rmp,-    char_u *line,      /* string to match against */-    colnr_T col            /* column to start looking for match */-)+static void report_re_switch(char_u *pat) {-  return rmp->regprog->engine->regexec_nl(rmp, line, col, false);+  if (p_verbose > 0) {+    verbose_enter();+    MSG_PUTS(_(""Switching to backtracking RE engine for pattern: ""));+    MSG_PUTS(pat);+    verbose_leave();+  } } -/*- * Like vim_regexec(), but consider a ""\n"" in ""line"" to be a line break.- */+/// Match a regexp against a string.+/// ""rmp->regprog"" is a compiled regexp as returned by vim_regcomp().+/// Uses curbuf for line count and 'iskeyword'.+/// When ""nl"" is TRUE consider a ""\n"" in ""line"" to be a line break.+///+/// Return TRUE if there is a match, FALSE if not.+///+/// @param rmp+/// @param line string to match against+/// @param col column to start looking for match+/// @param nl+static int vim_regexec_both(regmatch_T *rmp, char_u *line, colnr_T col, int nl)+{+  int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);++  // NFA engine aborted because it's very slow.+  if (rmp->regprog->re_engine == AUTOMATIC_ENGINE+      && result == NFA_TOO_EXPENSIVE) {+    int save_p_re = p_re;+    int re_flags = rmp->regprog->re_flags;+    char_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);++    p_re = BACKTRACKING_ENGINE;+    vim_regfree(rmp->regprog);+    if (pat != NULL) {",Here is one of Vims allocation functions:https://github.com/vim/vim/blob/master/src/misc2.c#L877-L972,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2346,27777389,2015-04-05T13:43:13Z,test/functional/terminal/buffer_spec.lua,"@@ -155,5 +157,42 @@ describe('terminal buffer', function()       :bnext                                            |     ]])   end)++  it('handles loss of focus gracefully', function()+    -- Temporarily change the statusline to avoid printing the file name, which+    -- varies be where the test is run.+    execute('set statusline=+++')+    execute('set laststatus=0')++    -- Save the buffer number of the terminal for later testing.+    local tbuf = eval('bufnr(""%"")')++    source([[+    function! SplitWindow()+      new+      set statusline=++++    endfunction++    startinsert+    call jobstart(['sh', '-c', 'exit'], {'on_exit': function(""SplitWindow"")})+    ]])++    -- We should be in a new buffer now.+    screen:expect([[+      ^                                                  |+      ~                                                 |+      +++                                               |+      rows: 2, cols: 50++                               |+      {2: }                                                 |+      {1:+++                                               }|+                                                        |+    ]])","One outstanding issue: event when I put `execute('set noruler')`, that `rows: 2, cols: 50` shows up, and if the `statusline` is longer than one character, all but the first get appended after the `cols: 50`.Otherwise, this is basically the output I expect.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2353,27777753,2015-04-05T14:37:36Z,src/nvim/tag.c,"@@ -2782,8 +2782,7 @@ int get_tags(list_T *list, char_u *pat)       TAG_REGEXP | TAG_NOIC, (int)MAXCOL, NULL);   if (ret == OK && num_matches > 0) {     for (i = 0; i < num_matches; ++i) {-      int parse_result = parse_match(matches[i], &tp);-      assert(parse_result == OK);+      assert(parse_match(matches[i], &tp) == OK);",Doesn't this make the behaviour dependent on whether asserts are compiled in or not? Are our `assert`s always present?,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2353,27777881,2015-04-05T14:53:34Z,src/nvim/tag.c,"@@ -2782,8 +2782,7 @@ int get_tags(list_T *list, char_u *pat)       TAG_REGEXP | TAG_NOIC, (int)MAXCOL, NULL);   if (ret == OK && num_matches > 0) {     for (i = 0; i < num_matches; ++i) {-      int parse_result = parse_match(matches[i], &tp);-      assert(parse_result == OK);+      assert(parse_match(matches[i], &tp) == OK);","We could use this sort of solution here instead:``` c      int parse_result = parse_match(matches[i], &tp);      (void) parse_result;      assert(parse_result == OK);```That avoids the warning, but works correctly.  Perhaps some of these can be wrapped with macros that do something similar?  Any thoughts?",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2349,27793988,2015-04-06T11:58:33Z,src/nvim/buffer.c,"@@ -77,8 +77,6 @@ #include ""nvim/os/time.h"" #include ""nvim/os/input.h"" -#define HAVE_BUFLIST_MATCH","I removed the `HAVE_BUFLIST_MATCH` define since it was apparently useless, please double check.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/2346,27823566,2015-04-06T19:44:28Z,src/nvim/terminal.c,"@@ -353,8 +353,14 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)   invalidate_terminal(term, -1, -1); } -void terminal_enter(Terminal *term, bool process_deferred)+void terminal_enter(bool process_deferred) {+  Terminal *term = curbuf->terminal;+  assert(term && ""should only be called when curbuf has a terminal"");",What if you pass the buffer to `terminal_enter` instead of relying on the `curbuf` global? You can move the `assert` up on the call chain and handle the error (or totally avoid it) in a better way.I see that the terminal also has a reference to the buffer. Maybe this is a sign that most the function should actually take the buffer as argument. @tarruda may have his reasons.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1805,27845384,2015-04-07T01:15:03Z,src/nvim/misc2.c,"@@ -459,22 +461,33 @@ char *read_string(FILE *fd, size_t cnt)   return (char *)str; } -/// Write a number to file ""fd"", MSB first, in ""len"" bytes.-/// @return OK/FAIL.-int put_bytes(FILE *fd, uintmax_t number, unsigned int len)+/// Writes a number to file ""fd"", most significant bit first, in ""len"" bytes.+/// @returns false in case of an error.+bool put_bytes(FILE *fd, uintmax_t number, size_t len) {-  for (unsigned int i = len - 1; i < len; --i)-    if (putc((int)(number >> (i * 8)), fd) == EOF)-      return FAIL;-  return OK;+  assert(len > 0);+  for (size_t i = len - 1; i < len; i--) {+    if (putc((int)(number >> (i * 8)), fd) == EOF) {+      return false;+    }+  }+  return true; } -/// Write time_t to file ""fd"" in 8 bytes.+/// Writes time_t to file ""fd"" in 8 bytes. void put_time(FILE *fd, time_t time_) {+  uint8_t buf[8];+  time_to_bytes(time_, buf);+  fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd);+}++/// Writes time_t to ""buf[8]"".+void time_to_bytes(time_t time_, uint8_t buf[8])+{   // time_t can be up to 8 bytes in size, more than uintmax_t in 32 bits   // systems, thus we can't use put_bytes() here.-  for (unsigned int i = 7; i < 8; --i) {-    putc((int)((uint64_t)time_ >> (i * 8)), fd);+  for (size_t i = 7, bufi = 0; i < 8; i--, bufi++) {",It would be clearer to have `bufi < 8` as the loop condition. `i < 8` relies on overflow behavior of unsigned types.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1805,27849133,2015-04-07T03:17:45Z,src/nvim/undo.c,"@@ -1459,35 +1473,117 @@ void u_read_undo(char_u *name, char_u *hash, char_u *orig_name)   free(uhp_table);  #ifdef U_DEBUG-  for (i = 0; i < num_head; ++i)-    if (uhp_table_used[i] == 0)+  for (int i = 0; i < num_head; i++) {+    if (uhp_table_used[i] == 0) {       EMSGN(""uhp_table entry %"" PRId64 "" not used, leaking memory"", i);+    }+  }   free(uhp_table_used);   u_check(TRUE); #endif -  if (name != NULL)+  if (name != NULL) {     smsg((char_u *)_(""Finished reading undo file %s""), file_name);+  }   goto theend;  error:   free(line_ptr);   if (uhp_table != NULL) {-    for (i = 0; i < num_read_uhps; i++)-      if (uhp_table[i] != NULL)+    for (long i = 0; i < num_read_uhps; i++)+      if (uhp_table[i] != NULL) {         u_free_uhp(uhp_table[i]);+      }     free(uhp_table);   }  theend:-  if (fp != NULL)+  if (fp != NULL) {     fclose(fp);-  if (file_name != name)+  }+  if (file_name != name) {     free(file_name);-  return;+  }+}++/// Writes a sequence of bytes to the undo file.+///+/// @returns false in case of an error.+static bool undo_write(bufinfo_T *bi, uint8_t *ptr, size_t len)+  FUNC_ATTR_NONNULL_ARG(1)+{+  return fwrite(ptr, len, 1, bi->bi_fp) == 1;+}++/// Writes a number, most significant bit first, in ""len"" bytes.+///+/// Must match with undo_read_?c() functions.+///+/// @returns false in case of an error.+static bool undo_write_bytes(bufinfo_T *bi, uintmax_t nr, size_t len)+{+  assert(len > 0);+  uint8_t buf[8];+  for (size_t i = len - 1, bufi = 0; i < len; i--, bufi++) {",Please replace loop condition by `bufi < len` for clearer code.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1805,27849832,2015-04-07T03:43:45Z,src/nvim/undo.c,"@@ -1487,7 +1498,83 @@ void u_read_undo(char_u *name, char_u *hash, char_u *orig_name)   return; } +/// Writes a sequence of bytes to the undo file.+///+/// @returns false in case of an error.+static bool undo_write(bufinfo_T *bi, uint8_t *ptr, size_t len)+{+  return fwrite(ptr, len, 1, bi->bi_fp) == 1;+}++/// Writes a number, MSB first, in ""len"" bytes.+///+/// Must match with undo_read_?c() functions.+///+/// @returns false in case of an error.+static bool undo_write_bytes(bufinfo_T *bi, uintmax_t nr, size_t len)+{+  assert(len > 0);+  uint8_t buf[8];+  for (size_t i = len - 1, bufi = 0; i < len; i--, bufi++) {+    buf[bufi] = (uint8_t)(nr >> (i * 8));+  }+  return undo_write(bi, buf, len);+} +/*+ * Write the pointer to an undo header.  Instead of writing the pointer itself+ * we use the sequence number of the header.  This is converted back to+ * pointers when reading. */+static void put_header_ptr(bufinfo_T *bi, u_header_T *uhp)+{+  assert(uhp == NULL || uhp->uh_seq >= 0);+  undo_write_bytes(bi, (uint64_t)(uhp != NULL ? uhp->uh_seq : 0), 4);+}++static int undo_read_4c(bufinfo_T *bi)+{+  return get4c(bi->bi_fp);+}++static int undo_read_2c(bufinfo_T *bi)+{+  return get2c(bi->bi_fp);+}++static int undo_read_byte(bufinfo_T *bi)+{+  return getc(bi->bi_fp);+}++static time_t undo_read_time(bufinfo_T *bi)+{+  return get8ctime(bi->bi_fp);+}++/// Reads ""buffer[size]"" from the undo file.+/// @returns false in case of an error.+static bool undo_read(bufinfo_T *bi, uint8_t *buffer, size_t size)+{+  assert(bi != NULL);+  return fread(buffer, size, 1, bi->bi_fp) == 1;+}++/// Reads a string of length ""len"" from ""bi->bi_fd"".+///+/// Appends a zero to the read string.+///+/// @param len can be zero to allocate an empty line.","> If one param is going to be documented, then the other should be as well.I don't agree with that because every time I try to follow this convention I end up writing really obvious comments about parameters. It's better to minimize comments.",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/1805,27854011,2015-04-07T06:31:32Z,src/nvim/undo.c,"@@ -1487,7 +1498,83 @@ void u_read_undo(char_u *name, char_u *hash, char_u *orig_name)   return; } +/// Writes a sequence of bytes to the undo file.+///+/// @returns false in case of an error.+static bool undo_write(bufinfo_T *bi, uint8_t *ptr, size_t len)+{+  return fwrite(ptr, len, 1, bi->bi_fp) == 1;+}++/// Writes a number, MSB first, in ""len"" bytes.+///+/// Must match with undo_read_?c() functions.+///+/// @returns false in case of an error.+static bool undo_write_bytes(bufinfo_T *bi, uintmax_t nr, size_t len)+{+  assert(len > 0);+  uint8_t buf[8];+  for (size_t i = len - 1, bufi = 0; i < len; i--, bufi++) {+    buf[bufi] = (uint8_t)(nr >> (i * 8));+  }+  return undo_write(bi, buf, len);+} +/*+ * Write the pointer to an undo header.  Instead of writing the pointer itself+ * we use the sequence number of the header.  This is converted back to+ * pointers when reading. */+static void put_header_ptr(bufinfo_T *bi, u_header_T *uhp)+{+  assert(uhp == NULL || uhp->uh_seq >= 0);+  undo_write_bytes(bi, (uint64_t)(uhp != NULL ? uhp->uh_seq : 0), 4);+}++static int undo_read_4c(bufinfo_T *bi)+{+  return get4c(bi->bi_fp);+}++static int undo_read_2c(bufinfo_T *bi)+{+  return get2c(bi->bi_fp);+}++static int undo_read_byte(bufinfo_T *bi)+{+  return getc(bi->bi_fp);+}++static time_t undo_read_time(bufinfo_T *bi)+{+  return get8ctime(bi->bi_fp);+}++/// Reads ""buffer[size]"" from the undo file.+/// @returns false in case of an error.+static bool undo_read(bufinfo_T *bi, uint8_t *buffer, size_t size)+{+  assert(bi != NULL);+  return fread(buffer, size, 1, bi->bi_fp) == 1;+}++/// Reads a string of length ""len"" from ""bi->bi_fd"".+///+/// Appends a zero to the read string.+///+/// @param len can be zero to allocate an empty line.","What's wrong with that? IMO it's better to be consistent here, because there's big holes in seemingly arbitrary places throughout the doxygen comments. Well maybe not seemingly arbitrary, but it's inconsistent.On April 6, 2015 11:44:08 PM EDT, Felipe Oliveira Carvalho notifications@github.com wrote:> > -  return get8ctime(bi->bi_fp);> >   +}> >   +> >   +/// Reads ""buffer[size]"" from the undo file.> >   +/// @returns false in case of an error.> >   +static bool undo_read(bufinfo_T *bi, uint8_t *buffer, size_t size)> >   +{> > -  assert(bi != NULL);> > -  return fread(buffer, size, 1, bi->bi_fp) == 1;> >   +}> >   +> >   +/// Reads a string of length ""len"" from ""bi->bi_fd"".> >   +///> >   +/// Appends a zero to the read string.> >   +///> >   +/// @param len can be zero to allocate an empty line.> > > > If one param is going to be documented, then the other should be as> > well.> > I don't agree with that because every time I try to follow this> convention I end up writing really obvious comments about parameters.> It's better to minimize comments.> > ---> > Reply to this email directly or view it on GitHub:> https://github.com/neovim/neovim/pull/1805/files#r27849832",
1837249,muralisc,https://api.github.com/repos/neovim/neovim/pulls/2367,27892783,2015-04-07T16:08:30Z,test/functional/legacy/038_virtual_replace_spec.lua,"@@ -0,0 +1,56 @@+-- Test Virtual replace mode.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('Virtual replace mode', function()+  setup(clear)++  it('is working', function()+    -- Make sure that backspace works, no matter what termcap is used.+    execute('set t_kD=x7f t_kb=x08')+    feed('ggdGa<cr>')+    feed('abcdefghi<cr>')+    feed('jk<tab>lmn<cr>')+    feed('<Space><Space><Space><Space>opq<tab>rst<cr>')+    feed('<C-d>uvwxyz<cr>')+    feed('<esc>gg:set ai<cr>')","done ! made similar change in line 27. but left out line 38 and line 39, because it felt that spliting them might make the test look more cumbersome.",
1837249,muralisc,https://api.github.com/repos/neovim/neovim/pulls/2245,27901839,2015-04-07T17:46:36Z,runtime/doc/message.txt,"@@ -315,10 +315,9 @@ generate this message.  This could be caused by a |-m| commandline argument. You can switch the 'write' option on with "":set write"".  							*E25*  >-  GUI cannot be used: Not enabled at compile time+  Nvim does not have a built-in GUI","Good catch, you are really thorough. How long did this review take? :smile:",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2346,27916816,2015-04-07T20:29:14Z,src/nvim/terminal.c,"@@ -353,8 +353,14 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)   invalidate_terminal(term, -1, -1); } -void terminal_enter(Terminal *term, bool process_deferred)+void terminal_enter(bool process_deferred) {+  Terminal *term = curbuf->terminal;+  assert(term && ""should only be called when curbuf has a terminal"");","> I did it like this because, if I understand the event loop correctly, we have to exit when curbuf->terminal != term or term->buf != curbuf, so even if terminal_enter() takes a buf_T argument, we'd have to assert buf == curbuf && buf->terminal.:+1: for `terminal_enter` this makes sense(little gain in keeping the parameter since we still depend on the global)",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2373,28048232,2015-04-09T09:43:08Z,test/functional/legacy/013_autocommands_on_close_spec.lua,"@@ -0,0 +1,108 @@+-- Tests for autocommands on :close command+-- Write three files and open them, each in a window.+-- Then go to next window, with autocommand that deletes the previous one.+-- Do this twice, writing the file.+-- Also test deleting the buffer on a Unload event.  If this goes wrong there+-- will be the ATTENTION prompt.+-- Also test changing buffers in a BufDel autocommand.  If this goes wrong there+-- are ml_line errors and/or a Crash.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('autocommands_on_close', function()+  setup(clear)++  it('is working', function()+    insert([=[+      start of testfile+      	contents+      	contents+      	contents+      end of testfile]=])++    -- Write the current buffer to ""test13.in"", else subsequent+    -- steps will fail+    execute('w! test13.in')+    execute('?^start of testfile?,?^end of testfile?w! Xtestje1')+    execute('?^start of testfile?,?^end of testfile?w! Xtestje2')+    execute('?^start of testfile?,?^end of testfile?w! Xtestje3')+    execute('e Xtestje1')+    feed('otestje1<esc>')+    execute('write')+    execute('sp Xtestje2')+    feed('otestje2<esc>')+    execute('write')+    execute('sp Xtestje3')+    feed('otestje3<esc>')+    execute('w')+    feed('<c-w><c-w><cr>')+    execute('au WinLeave Xtestje2 bwipe')+    feed('<c-w><c-w><cr>')+    execute('w! test.out')+    execute('au WinLeave Xtestje1 bwipe Xtestje3')+    execute('close')+    execute('w >>test.out')+    execute('e Xtestje1')+    execute('bwipe Xtestje2 Xtestje3 test.out')+    execute('au!')+    execute('au! BufUnload Xtestje1 bwipe')+    execute('e Xtestje3')+    execute('w >>test.out')+    execute('e Xtestje2')+    execute('sp Xtestje1')+    execute('e')+    execute('w >>test.out')+    execute('au!')+    execute('only')+    execute('e Xtestje1')+    execute('bwipe Xtestje2 Xtestje3 test.out test13.in')+    execute('au BufWipeout Xtestje1 buf Xtestje1')+    execute('bwipe')+    execute('w >>test.out')++    ---- Open the output to see if it meets the expections+    execute('e! test.out')++    -- Assert buffer contents.+    expect([=[+      start of testfile+      testje1+      	contents+      	contents+      	contents+      end of testfile+      start of testfile+      testje1+      	contents+      	contents+      	contents+      end of testfile+      start of testfile+      testje3+      	contents+      	contents+      	contents+      end of testfile+      start of testfile+      testje2+      	contents+      	contents+      	contents+      end of testfile+      start of testfile+      testje1+      	contents+      	contents+      	contents+      end of testfile]=])++  end)+  teardown(function()+    os.remove('Xtestje1')+    os.remove('Xtestje2')+    os.remove('Xtestje3')+    os.remove('test13.in')","Must also delete the temporary file `test.out`.I prefer to have the `setup` and `teardown` code together at the top, but I don't think we've been consistent so it's up to you.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2167,28103074,2015-04-09T21:10:31Z,README.md,"@@ -48,7 +48,7 @@ more. See [the wiki](https://github.com/neovim/neovim/wiki/Installing-Neovim)!  ### Community","Twitter and the mailing list are already mentioned at the Community page, so maybe those should be removed too.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2245,28105929,2015-04-09T21:44:49Z,runtime/doc/tips.txt,"@@ -406,20 +405,6 @@ when they are not in the same location as the compressed ""doc"" directory.  See |$VIMRUNTIME|.  ==============================================================================-Executing shell commands in a window			*shell-window*--There have been questions for the possibility to execute a shell in a window-inside Vim.  The answer: you can't!  Including this would add a lot of code to-Vim, which is a good reason not to do this.  After all, Vim is an editor, it-is not supposed to do non-editing tasks.  However, to get something like this,-you might try splitting your terminal screen or display window with the-""splitvt"" program.  You can probably find it on some ftp server.  The person-that knows more about this is Sam Lantinga <slouken@cs.ucdavis.edu>.-An alternative is the ""window"" command, found on BSD Unix systems, which-supports multiple overlapped windows.  Or the ""screen"" program, found at-www.uni-erlangen.de, which supports a stack of windows.","Maybe... but I don't want to come off as smug. Still, it's not like we're saying```lol vim is bad, get a real editor sonny boy```",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2390,28148968,2015-04-10T14:33:13Z,src/nvim/ex_cmds2.c,"@@ -744,40 +744,40 @@ void dbg_breakpoint(char_u *name, linenr_T lnum)  static char_u   *profile_fname = NULL; -/*- * "":profile cmd args""- */+/// "":profile cmd args""+///+/// @param eap Pointer to the command arguments structure.","I think just the `:profile cmd args` is necessary here. Anyone wanting information on how this should work can run `:h :profile`, and the contents of `eap` is required reading for all `ex_cmds[2].c` functions.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2319,28195831,2015-04-11T15:33:18Z,src/nvim/ex_getln.c,"@@ -1834,15 +1839,26 @@ getexmodeline (         } else {           p[line_ga.ga_len] = NUL;           indent = get_indent_str(p, 8, FALSE);+          if (indent == 0) {+            continue;+          }           --indent;           indent -= indent % get_sw_value(curbuf);         }-        while (get_indent_str(p, 8, FALSE) > indent) {-          char_u *s = skipwhite(p); -          memmove(s - 1, s, line_ga.ga_len - (s - p) + 1);-          --line_ga.ga_len;+        // Delete trailing leading whitespaces until enough indentation+        // is removed.",Is this clearer?`Remove a big enough suffix of the whitespace prefix for the Ex command line to reduce the line indentation.`,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2390,28199052,2015-04-11T22:45:28Z,src/nvim/ex_cmds2.c,"@@ -744,40 +744,38 @@ void dbg_breakpoint(char_u *name, linenr_T lnum)  static char_u   *profile_fname = NULL; -/*- * "":profile cmd args""- */+/// :profile cmd args void ex_profile(exarg_T *eap) {   static proftime_T pause_time; -  char_u      *e;-  int len;+  char_u *arg = skiptowhite(eap->arg);+  int len     = (int)(arg - eap->arg);+  arg         = skipwhite(arg); -  e = skiptowhite(eap->arg);-  len = (int)(e - eap->arg);-  e = skipwhite(e);+  const char *cmd = (char *)eap->arg; -  if (len == 5 && STRNCMP(eap->arg, ""start"", 5) == 0 && *e != NUL) {+  if (len == 5 && !strncmp(cmd, ""start"", 5) && *arg) {","Use `NUL` when it is semantically appropriate. Also I believe most code (even new code) that I have seen compares the explicit result of `strcmp` family of functions, for clarity. As far as `STRNCMP` vs `strncmp`, we will make a mass-action decision about this later.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2117,28200773,2015-04-12T05:12:28Z,test/functional/helpers.lua,"@@ -49,6 +53,10 @@ end  local session, loop_running, loop_stopped, last_error +local function set_session(s)+  session = s+end",@bfredl @tarruda This is a temporary hack to allow multiple spawned sessions in a single test. After this PR I plan to refactor helpers.lua into a module with a `new()` constructor so that a test can control multiple sessions. Does that sound ok?Another thing that would be useful (for testing swapfiles) is ability to `kill -9` the session. Any nice way to do that? I see that `loop.c` in the lua client [does not send signals](https://github.com/neovim/lua-client/blob/master/nvim/loop.c#L58).,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2410,28201979,2015-04-12T09:08:53Z,src/nvim/macros.h,"@@ -59,12 +59,12 @@ /* Use our own isdigit() replacement, because on MS-Windows isdigit() returns  * non-zero for superscript 1.  Also avoids that isdigit() crashes for numbers  * below 0 and above 255.  */-#define VIM_ISDIGIT(c) ((unsigned)(c) - '0' < 10)+#define VIM_ISDIGIT(c) ((unsigned)(c) >= '0' && (unsigned)(c) <= '9')  /* Like isalpha() but reject non-ASCII characters.  Can't be used with a  * special key (negative value). */-# define ASCII_ISLOWER(c) ((unsigned)(c) - 'a' < 26)-# define ASCII_ISUPPER(c) ((unsigned)(c) - 'A' < 26)+# define ASCII_ISLOWER(c) ((unsigned)(c) >= 'a' && (unsigned)(c) <= 'z')+# define ASCII_ISUPPER(c) ((unsigned)(c) >= 'A' && (unsigned)(c) <= 'Z')","Yes, it's a pity coverity doesn't understand unsigned wrap-around.In any case, it's not a big deal, and it can be argued new version is a little bit more readable, specially when casts are removed.Regarding that, I think opening a new PR to fix that would be overkill. I will include that fix in my next coverity fixes batch, that will come soon.Thanks!",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2395,28204236,2015-04-12T15:16:05Z,runtime/doc/manpages/nvim.1.md,"@@ -0,0 +1,261 @@+<!---+Should be generated using md2man+https://github.com/sunaku/md2man+-->++# NVIM 1 ""April 2015"" ""Neovim"" ""User Commands""++## NAME++nvim - Vim out of the box++## SYNOPSIS++`nvim` [*options*] [*file*]...  +`nvim` [*options*] `-`  +`nvim` [*options*] `-t` <*tag*>  +`nvim` [*options*] `-t` [*errorfile*]++## DESCRIPTION++`nvim` is an extensible text editor based off of Vim.","Would saying ""forked off of"" be too technical?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2415,28206247,2015-04-12T19:03:19Z,src/nvim/memory.c,"@@ -92,6 +100,12 @@ void *xmalloc(size_t size)   return ret; } +/// free wrapper that returns delegates to the backing memory manager+void xfree(void *ptr)+{+  free(ptr);","In this module, `free` is only a placeholder for the actual `free` implementation(which is `je_free` when `USE_JEMALLOC` is defined). We still need a fixed function address for the other modules to link against. Redefining `free` as a macro globally is definitely not a good approach(we lose sanity when setting breakpoints, for example)> Is the plan to call je_\* explicitly from the xfoo family, in the future?No, but we could eventually use this as a slot for extra deallocation logic. For example, see how redis keeps track of how much memory is currently used in [zmalloc.c](https://github.com/antirez/redis/blob/unstable/src/zmalloc.c).",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2117,28232494,2015-04-13T12:07:30Z,test/functional/helpers.lua,"@@ -49,6 +53,10 @@ end  local session, loop_running, loop_stopped, last_error +local function set_session(s)+  session = s+end","> After this PR I plan to refactor helpers.lua into a module with a new() constructor so that a test can control multiple sessions. Does that sound ok?:+1: > Another thing that would be useful (for testing swapfiles) is ability to kill -9 the session. Any nice way to do that? I see that loop.c in the lua client does not send signals.I added session:exit() to accept arguments for sending SIGTERM/SIGKILL: https://github.com/neovim/lua-client/blob/master/nvim/loop.c#L154-L156, but forgot to forward parameters from the session layer to the loop layer: https://github.com/neovim/lua-client/blob/master/nvim/session.lua#L127-L129 . It should be very simple to enable this functionality, could you send a PR to lua client?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2117,28232583,2015-04-13T12:09:17Z,test/functional/ex_cmds/recover_spec.lua,"@@ -0,0 +1,71 @@+-- Tests for :recover++local helpers = require('test.functional.helpers')+local execute, eq, clear, eval, feed, expect, source =+  helpers.execute, helpers.eq, helpers.clear, helpers.eval, helpers.feed,+  helpers.expect, helpers.source++describe(':recover', function()+  before_each(clear)++  it('fails if given a non-existent swapfile', function()+    local swapname = 'bogus-swapfile'+    execute('recover '..swapname) -- This should not segfault. #2117+    eq('E305: No swap file found for '..swapname, eval('v:errmsg'))+  end)++end)++describe(':preserve', function()+  local swapdir = lfs.currentdir()..'/testdir_recover_spec'+  before_each(function()+    clear()+    os.remove(swapdir)+    lfs.mkdir(swapdir)+  end)+  after_each(function()+    os.remove(swapdir)+  end)++  it(""saves to custom 'directory' and (R)ecovers (issue #1836)"", function()+    local testfile = 'testfile_recover_spec'+    local init = [[+      set swapfile fileformat=unix undolevels=-1+      set directory^=]]..swapdir..[[//+    ]]++    source(init)+    execute('set swapfile fileformat=unix undolevels=-1')+    -- Put swapdir at the start of the 'directory' list. #1836+    execute('set directory^='..swapdir..'//')+    execute('edit '..testfile)+    feed('isometext<esc>')+    execute('preserve')+    source('redir => g:swapname | swapname | redir END')++    local swappath1 = eval('g:swapname')++    --TODO(justinmk): this is an ugly hack to force `helpers` to support+    --multiple sessions.+    local nvim2 = helpers.spawn({helpers.nvim_prog, '-u', 'NONE', '--embed'})+    helpers.set_session(nvim2)","It's my fault, I should have wrapped session methods into another class for the tests :disappointed: ",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2429,28454832,2015-04-15T19:39:53Z,src/nvim/globals.h,"@@ -1051,10 +1051,6 @@ EXTERN int typebuf_was_filled INIT(= FALSE);      /* received text from client EXTERN int term_is_xterm INIT(= FALSE);         /* xterm-like 'term' */","It looks like this can be removed too, although I'm not sure what others think about deviating from patches, but I searched Vim's history and this hasn't been touched in a long time.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2441,28523623,2015-04-16T16:07:38Z,src/nvim/eval.c,"@@ -5421,6 +5421,9 @@ static int list_join(garray_T *gap, list_T *l, char_u *sep, int echo_style, int   garray_T join_ga;   int retval; +  if (l->lv_len < 1)+    return OK;","Need braces. Please put this above the declarations to make it clear `retval` and `join_ga` are unused. Lastly, please return `true` (making this return a `bool` would be welcome, but not necessary).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2441,28542618,2015-04-16T19:40:40Z,src/nvim/eval.c,"@@ -5421,6 +5421,9 @@ static int list_join(garray_T *gap, list_T *l, char_u *sep, int echo_style, int   garray_T join_ga;   int retval; +  if (l->lv_len < 1)+    return OK;","I don���t think it is easy to understand what does `return true` mean. `list_join` name does not tell you what return value means; its documentation explicitly says about `FAIL` and `OK` and it is common to use either `true` or `false` to indicate success/failure.I actually think that for the purpose of cleaning code `OK` should be set to `10992`, `FAIL` to `7918` and `NOTDONE` to `16017` and all `int` functions returning OK/FAIL/NOTDONE should switch to `typedef enum {���} Res;`. Because OK/FAIL/NOTDONE have clear connection with what return value means and `true`/`false` has no such connection.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2441,28549770,2015-04-16T21:03:49Z,src/nvim/eval.c,"@@ -5421,6 +5421,9 @@ static int list_join(garray_T *gap, list_T *l, char_u *sep, int echo_style, int   garray_T join_ga;   int retval; +  if (l->lv_len < 1)+    return OK;",@bfredl Even if you want `bool` for some reason it is better to add two `#define`s and typedef for bool. Your solution is worse because:1. Convention adds cognitive load.2. `if (func())` is less descriptive as `if (func() == OK)`.3. It is easier to automatically find conventions violation for functions that use enum value then for boolean functions.4. It makes it easy to violate convention by accident.,
123376,mbainter,https://api.github.com/repos/neovim/neovim/pulls/2418,28616700,2015-04-17T18:09:29Z,src/nvim/os/env.c,"@@ -410,14 +410,14 @@ static char *remove_tail(char *p, char *pend, char *name) /// @param[out] mustfree Ouput parameter for the caller to determine if they are ///           responsible for releasing memory. Must be initialized to false ///           by the caller.-char_u *vim_getenv(char_u *name, bool *mustfree)+char *vim_getenv(char *name, bool *mustfree) {-  char_u      *p;-  char_u      *pend;+  char *p;+  char *pend;   int vimruntime;  -  p = (char_u *)os_getenv((char *)name);+  p = (char *)os_getenv(name);","Yeah, I noted that somewhere earlier in this PR, that's not a good solution, but I was trying to limit my change to only be the u_char -> char.  I'm not adding any bad behavior, just changing it.  I have another PR to submit as soon as this one merges that refactors get_env to properly handle the const.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2443,28621261,2015-04-17T19:02:54Z,src/nvim/hardcopy.c,"@@ -2117,7 +2117,7 @@ int mch_print_init(prt_settings_T *psettings, char_u *jobname, int forceit)   props = enc_canon_props(p_encoding);   if (!(props & ENC_8BIT) && ((*p_pmcs != NUL) || !(props & ENC_UNICODE))) {     p_mbenc_first = NULL;-    int effective_cmap;+    int effective_cmap = 0;","Argg, I can't comment on unchanged line.Well, on line 2133, changing order of conditions from `if (p_mbchar == NULL && p_mbenc_first != NULL) {` to the opposite, clears the warning without the variable initialization.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2443,28626820,2015-04-17T20:19:06Z,src/nvim/msgpack_rpc/server.c,"@@ -224,7 +224,7 @@ int server_start(const char *endpoint) /// @param endpoint Address of the server. void server_stop(char *endpoint) {-  Server *server;+  Server *server = NULL;","This one is a bug, in fact. One that would never occur, but a bug after all. Problem is in:```  int i = 0;  // The index of the server whose address equals addr.  for (; i < servers.ga_len; i++) {    server = ((Server **)servers.ga_data)[i];    if (strcmp(addr, server->addr) == 0) {      break;    }  }  if (i == servers.ga_len) {    ELOG(""Not listening on %s"", addr);    return;  }```This code wouldn't work for server.ga_len < 0.We know that won't happen, but from the compiler point of view, it's an int, and it could.That case leads to function not exiting at ELOG block, and server being used without initialization.It can all be fixed (without initializing variable) by changing it into:```   int i = -1;  // The index of the server whose address equals addr.                                                                                     for (int j = 0; j < servers.ga_len; j++) {                                                                                                               server = ((Server **)servers.ga_data)[j];                                                                                                              if (strcmp(addr, server->addr) == 0) {                                                                                                                   i = j;                                                                                                                                                 break;                                                                                                                                               }                                                                                                                                                    }                                                                                                                                                      if (i == -1) {                                                                                                                                           ELOG(""Not listening on %s"", addr);                                                                                                                     return;                                                                                                                                              }```Or, alternatively, introducing a server_found bool variable.This is an example of how leaving variables uninitialized where it makes sense can actually help.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2443,28632420,2015-04-17T21:39:51Z,src/nvim/eval.c,"@@ -18911,7 +18911,7 @@ call_user_func (   char_u numbuf[NUMBUFLEN];   char_u      *name;   proftime_T wait_start;-  proftime_T call_start;+  proftime_T call_start = 0;","This one is a bit harder, but solvable nonetheless.Both the initialization of call_start:```   if (do_profiling == PROF_YES) {    if (!fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL))      func_do_profile(fp);    if (fp->uf_profiling        || (fc->caller != NULL && fc->caller->func->uf_profiling)) {      ++fp->uf_tm_count;      call_start = profile_start();      fp->uf_tm_children = profile_zero();    }    script_prof_save(&wait_start);  }```and the (supposedly offending) usage place:```  if (do_profiling == PROF_YES && (fp->uf_profiling                                   || (fc->caller != NULL &&                                       fc->caller->func->uf_profiling))) {    call_start = profile_end(call_start);    ...   }```are under the same logical condition.So, they should both execute, or none, but it seems the compiler can't follow that implication.Therefore, solution is a bit of refactoring to make sure compiler understands condition is the same at both points.For example, transforming the first block into:```  bool func_not_yet_profiling_but_should =                                                                                                               do_profiling == PROF_YES                                                                                                                             && !fp->uf_profiling && has_profiling(FALSE, fp->uf_name, NULL);                                                                                   if (func_not_yet_profiling_but_should)                                                                                                                 func_do_profile(fp);                                                                                                                               bool func_or_func_caller_profiling =                                                                                                                   do_profiling == PROF_YES                                                                                                                             && (fp->uf_profiling                                                                                                                                     || (fc->caller != NULL && fc->caller->func->uf_profiling));                                                                                    if (func_or_func_caller_profiling) {                                                                                                                   ++fp->uf_tm_count;                                                                                                                                   call_start = profile_start();                                                                                                                        fp->uf_tm_children = profile_zero();                                                                                                               }                                                                                                                                                    if (do_profiling == PROF_YES) {                                                                                                                        script_prof_save(&wait_start);                                                                                                                     }```which is also a bit easier to read, and the second block into```  if (func_or_func_caller_profiling) {                                                                                                                   call_start = profile_end(call_start);     ...  }```makes the warning disappear without initializing variable.I'm assuming that value of conditions can't change in-between the two points, which seems a reasonable assumption to me (it it did, it'd probably be a bug rather than an intended purpose).",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2443,28639266,2015-04-18T00:39:11Z,src/nvim/msgpack_rpc/server.c,"@@ -224,7 +224,7 @@ int server_start(const char *endpoint) /// @param endpoint Address of the server. void server_stop(char *endpoint) {-  Server *server;+  Server *server = NULL;","Hrmph.  I had assumed that `ga_len` was an unsigned type and didn't even think to look. :-(I think the fix is far simpler here:``` diffdiff --git a/src/nvim/msgpack_rpc/server.c b/src/nvim/msgpack_rpc/server.cindex 8fb2902..5e3fd10 100644--- a/src/nvim/msgpack_rpc/server.c+++ b/src/nvim/msgpack_rpc/server.c@@ -238,7 +238,7 @@ void server_stop(char *endpoint)     }   }-  if (i == servers.ga_len) {+  if (i >= servers.ga_len) {     ELOG(""Not listening on %s"", addr);     return;   }```Thanks for looking at it closer though!",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2443,28642207,2015-04-18T07:44:07Z,src/nvim/msgpack_rpc/server.c,"@@ -224,7 +224,7 @@ int server_start(const char *endpoint) /// @param endpoint Address of the server. void server_stop(char *endpoint) {-  Server *server;+  Server *server = NULL;","In fact, refactoring ga_len to `size_t` is something we should do at some point. Apart from causing subtle bugs like this, it's also the main cause for a lot of casting between int and size_t. It's something I have in my type-refactoring-todo list, but I haven't reached it yet.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2418,28645213,2015-04-18T16:19:07Z,src/nvim/os/env.c,"@@ -423,43 +423,41 @@ static char *remove_tail(char *p, char *pend, char *name) /// @param[out] mustfree Ouput parameter for the caller to determine if they are ///           responsible for releasing memory. Must be initialized to false ///           by the caller.-char_u *vim_getenv(char_u *name, bool *mustfree)+char *vim_getenv(const char *name, bool *mustfree) {-  char_u      *p;-  char_u      *pend;-  int vimruntime;---  p = (char_u *)os_getenv((char *)name);-  if (p != NULL && *p == NUL)       /* empty is the same as not set */-    p = NULL;--  if (p != NULL) {-    return p;+  const char *kos_env_path = os_getenv(name);+  if (kos_env_path != NULL+      && *kos_env_path == NUL) /* empty is the same as not set */+    kos_env_path = NULL;++  if (kos_env_path != NULL) {+    *mustfree = true;+    return xstrdup(kos_env_path);   } -  vimruntime = (STRCMP(name, ""VIMRUNTIME"") == 0);-  if (!vimruntime && STRCMP(name, ""VIM"") != 0)+  bool vimruntime = (strcmp(name, ""VIMRUNTIME"") == 0);+  if (!vimruntime && strcmp(name, ""VIM"") != 0)     return NULL;    /*    * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.    * Don't do this when default_vimruntime_dir is non-empty.    */+  char *vim_path = NULL;   if (vimruntime #ifdef HAVE_PATHDEF       && *default_vimruntime_dir == NUL #endif       ) {-    p = (char_u *)os_getenv(""VIM"");-    if (p != NULL && *p == NUL)             /* empty is the same as not set */-      p = NULL;-    if (p != NULL) {-      p = (char_u *)vim_version_dir((char *)p);-      if (p != NULL)-        *mustfree = true;-      else-        p = (char_u *)os_getenv(""VIM"");+    kos_env_path = os_getenv(""VIM"");+    if (kos_env_path != NULL+        && *kos_env_path == NUL) /* empty is the same as not set */","We need braces (`{ }`) on all conditionals, and also this C-style comment has to be a c++ style comment (`//`) with at lease two spaces from the code, according to our style guild. http://neovim.org/develop/style-guide.xml?showone=Comment_Style#Comment_Stylehttp://neovim.org/develop/style-guide.xml?showone=Implementation_Comments#Implementation_Comments",
123376,mbainter,https://api.github.com/repos/neovim/neovim/pulls/2418,28645444,2015-04-18T16:45:02Z,src/nvim/os/env.c,"@@ -423,43 +423,41 @@ static char *remove_tail(char *p, char *pend, char *name) /// @param[out] mustfree Ouput parameter for the caller to determine if they are ///           responsible for releasing memory. Must be initialized to false ///           by the caller.-char_u *vim_getenv(char_u *name, bool *mustfree)+char *vim_getenv(const char *name, bool *mustfree) {-  char_u      *p;-  char_u      *pend;-  int vimruntime;---  p = (char_u *)os_getenv((char *)name);-  if (p != NULL && *p == NUL)       /* empty is the same as not set */-    p = NULL;--  if (p != NULL) {-    return p;+  const char *kos_env_path = os_getenv(name);","Yes, for konst, from the style guide constant vars were supposed to have this yes?  I suppose that is a good point on the name itself.  The later parts are path specific, but anything could be passed and returned in that first bit.  Perhaps, kenv_value?  kenv_data?  ",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2418,28646770,2015-04-18T19:38:37Z,src/nvim/os/env.c,"@@ -423,43 +423,41 @@ static char *remove_tail(char *p, char *pend, char *name) /// @param[out] mustfree Ouput parameter for the caller to determine if they are ///           responsible for releasing memory. Must be initialized to false ///           by the caller.-char_u *vim_getenv(char_u *name, bool *mustfree)+char *vim_getenv(const char *name, bool *mustfree) {-  char_u      *p;-  char_u      *pend;-  int vimruntime;---  p = (char_u *)os_getenv((char *)name);-  if (p != NULL && *p == NUL)       /* empty is the same as not set */-    p = NULL;--  if (p != NULL) {-    return p;+  const char *kos_env_path = os_getenv(name);+  if (kos_env_path != NULL+      && *kos_env_path == NUL) /* empty is the same as not set */+    kos_env_path = NULL;++  if (kos_env_path != NULL) {+    *mustfree = true;+    return xstrdup(kos_env_path);","The behaviour you mention was already there before.So, in that sense, I'm ok with these changes as they don't break anything it wasn't already broken.Now, you're right in the sense that this function is still improvable, as it can still return things as `char *` that shouldn't be modified.I didn't mention that because I didn't want to prolong this PR for more time.But it probably was the wrong choice. It would definitely be better to always return an allocated string and remove mustfree parameter. I don't think copying a few strings can harm performance, and we'd have better code.So, @mbainter, could you please have a look on that?",
123376,mbainter,https://api.github.com/repos/neovim/neovim/pulls/2418,28647180,2015-04-18T20:29:31Z,src/nvim/os/env.c,"@@ -423,43 +423,41 @@ static char *remove_tail(char *p, char *pend, char *name) /// @param[out] mustfree Ouput parameter for the caller to determine if they are ///           responsible for releasing memory. Must be initialized to false ///           by the caller.-char_u *vim_getenv(char_u *name, bool *mustfree)+char *vim_getenv(const char *name, bool *mustfree) {-  char_u      *p;-  char_u      *pend;-  int vimruntime;---  p = (char_u *)os_getenv((char *)name);-  if (p != NULL && *p == NUL)       /* empty is the same as not set */-    p = NULL;--  if (p != NULL) {-    return p;+  const char *kos_env_path = os_getenv(name);+  if (kos_env_path != NULL+      && *kos_env_path == NUL) /* empty is the same as not set */+    kos_env_path = NULL;++  if (kos_env_path != NULL) {+    *mustfree = true;+    return xstrdup(kos_env_path);","I'd be happy to improve it further.  I am just trying to avoid overreachingor introducing too much change at once.  The concern makes sense to me, soI'll refactor a little further to make the must_free unnecessary, andcleanup the other calls to always free the result.On Sat, Apr 18, 2015 at 2:39 PM, Eliseo Mart��nez notifications@github.comwrote:> In src/nvim/os/env.c> https://github.com/neovim/neovim/pull/2418#discussion_r28646770:> > > ## > > > > ## > > -  p = (char_u *)os_getenv((char *)name);> > -  if (p != NULL && _p == NUL)       /_ empty is the same as not set */> > > > ## \-    p = NULL;> > -  if (p != NULL) {> > -    return p;> > -  const char *kos_env_path = os_getenv(name);> > -  if (kos_env_path != NULL> > -      && _kos_env_path == NUL) /_ empty is the same as not set */> > -    kos_env_path = NULL;> >   +> > -  if (kos_env_path != NULL) {> > -    *mustfree = true;> > -    return xstrdup(kos_env_path);> > The behaviour you mention was already there before.> So, in that sense, I'm ok with these changes as they don't break anything> it wasn't already broken.> > Now, you're right in the sense that this function is still improvable, as> it can still return things as char \* that shouldn't be modified.> > I didn't mention that because I didn't want to prolong this PR for more> time.> But it probably was the wrong choice.> > It would definitely be better to always return an allocated string and> remove mustfree parameter. I don't think copying a few strings can harm> performance, and we'd have better code.> So, @mbainter https://github.com/mbainter, could you please have a look> on that?> > ���> Reply to this email directly or view it on GitHub> https://github.com/neovim/neovim/pull/2418/files#r28646770.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2418,28647275,2015-04-18T20:43:04Z,src/nvim/os/env.c,"@@ -423,43 +423,41 @@ static char *remove_tail(char *p, char *pend, char *name) /// @param[out] mustfree Ouput parameter for the caller to determine if they are ///           responsible for releasing memory. Must be initialized to false ///           by the caller.-char_u *vim_getenv(char_u *name, bool *mustfree)+char *vim_getenv(const char *name, bool *mustfree) {-  char_u      *p;-  char_u      *pend;-  int vimruntime;---  p = (char_u *)os_getenv((char *)name);-  if (p != NULL && *p == NUL)       /* empty is the same as not set */-    p = NULL;--  if (p != NULL) {-    return p;+  const char *kos_env_path = os_getenv(name);+  if (kos_env_path != NULL+      && *kos_env_path == NUL) /* empty is the same as not set */+    kos_env_path = NULL;++  if (kos_env_path != NULL) {+    *mustfree = true;+    return xstrdup(kos_env_path);","Yes, sorry for dragging this out so long, and refactoring can have a terrible cascading effect. That's why I'm OK if it ends up being too much trouble to revert back to the old behaviour, but I think we need to consider consistency a high priority. Inconsistent design decisions make it harder to understand code and can lead to incorrect usage. Correctness disregarding convention (un-const casting and `must_free`) at least can be implicitly understood.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2424,28653165,2015-04-19T14:17:08Z,runtime/doc/eval.txt,"@@ -4031,9 +4031,11 @@ jobsend({job}, {data})					{Nvim} *jobsend()* 			:call jobsend(j, [""abc"", ""123\n456"", """"]) < 		will send ""abc<NL>123<NUL>456<NL>"". -jobstart({argv}[, {opts}])			{Nvim} *jobstart()*-		Spawns {argv}(list) as a job. If passed, {opts} must be a-		dictionary with any of the following keys:+jobstart({cmd}[, {opts}])				{Nvim} *jobstart()*+		Spawns {cmd} as a job.  If {cmd} is a |String|, it will be ran+		via ""'shell' 'shellcmdflag' {cmd}"", or directly if a |List|.","Perhaps remove the outer quotes here, it could be interpreted as we're concatenating a string here, but we're really building up an argument list.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2424,28653179,2015-04-19T14:19:16Z,runtime/doc/eval.txt,"@@ -6299,15 +6301,20 @@ tempname()					*tempname()* *temp-file-name* 		For MS-Windows forward slashes are used when the 'shellslash' 		option is set or when 'shellcmdflag' starts with '-'. -termopen({command}[, {opts}])			{Nvim} *termopen()*-		Spawns {command} using the shell in a new pseudo-terminal-		session connected to the current buffer.  This function fails-		if the current buffer is modified (all buffer contents are-		destroyed).  The {opts} dict is similar to the one passed to-		|jobstart()|, but the `pty`, `width`, `height`, and `TERM` fields are-		ignored: `height`/`width` are taken from the current window and-		$TERM is set to ""xterm-256color"".  Returns the same values as-		|jobstart()|.+termopen({cmd}[, {opts}])			{Nvim} *termopen()*+		Spawns {cmd} in a new pseudo-terminal session connected+		to the current buffer. If {cmd} is a |String|, it will be+		executed as ""'shell' 'shellcmdflag' {cmd}"", otherwise if {cmd}","similarly here. Perhaps explicitly say something like ""{cmd} is interpreted exactly like in |jobstart| "" ?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2424,28653468,2015-04-19T14:49:20Z,src/nvim/os/shell.c,"@@ -119,14 +119,14 @@ int os_call_shell(char_u *cmd, ShellOpts opts, char_u *extra_args)   }    size_t nread;-  int status = shell((const char *)cmd,-                     (const char *)extra_args,-                     input.data,-                     input.len,-                     output_ptr,-                     &nread,-                     emsg_silent,-                     forward_output);++  int status = do_os_system(shell_build_argv((char *)cmd, (char *)extra_args),","Not really related to this PR, but if I haven't missed something it looks like `extra_args` is only ever used in `mch_expand_wildcards`. Perhaps this function could be refactored  to manipulate the argv list directly, instead of complicating the entire `call_shell` `os_call_shell` `shell_build_argv` chain. (later, no need to do it in this PR). ",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2041,28654861,2015-04-19T17:38:52Z,src/nvim/ex_docmd.c,"@@ -1335,25 +1419,108 @@ static char_u * do_one_cmd(char_u **cmdlinep,    * is equal to the lower.    */ +  if (!IS_USER_CMDIDX(ea.cmdidx)) {+    if (ea.cmdidx != CMD_SIZE && ea.cmdidx >= 0) {+      ea.addr_type = cmdnames[(int)ea.cmdidx].cmd_addr_type;+    } else {+      ea.addr_type = ADDR_LINES;+      // ea.addr_type for user commands is set by find_ucmd+    }+  // :wincmd range depends on the argument+  } else if (ea.cmdidx == CMD_wincmd) {","My fault. This line can be reached, but the condition should always be false, because the previous `if` also matches this condition. `!IS_USER_CMDIDX(ea.cmdidx)` is `(int)(ea.cmdidx)>=0` and `CMD_wincmd` should be not negative.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2465,28675000,2015-04-20T09:35:07Z,CMakeLists.txt,"@@ -178,50 +178,49 @@ endif() include_directories(""${PROJECT_BINARY_DIR}/config"") include_directories(""${PROJECT_SOURCE_DIR}/src"") +# Systemwide (non-bundled) dependencies are usually not provided+# as static libraries, so we can just switch this on by default.+option(USE_STATIC ""Use static dependencies"" ON)","I was trying hard to avoid doing this for two reasons.  First, now it's another knob distros need to be aware of.  Second, because `OFF` doesn't make sense for when we use bundled dependencies (we don't install the dependent libraries anywhere useful).  By only having static libraries available from the third party build, we'd get the behavior we wanted, and things fell back to shared libraries without explicitly asking for it.  That was the hope anyways.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2424,28677606,2015-04-20T10:20:41Z,src/nvim/eval.c,"@@ -10787,47 +10787,74 @@ static void f_jobresize(typval_T *argvars, typval_T *rettv)   rettv->vval.v_number = 1; } -// ""jobstart()"" function-static void f_jobstart(typval_T *argvars, typval_T *rettv)+static char **tv_to_argv(typval_T *cmd) {-  rettv->v_type = VAR_NUMBER;-  rettv->vval.v_number = 0;+  if (cmd->v_type == VAR_STRING) {+    return shell_build_argv((char *)get_tv_string(cmd), NULL);+  } -  if (check_restricted() || check_secure()) {-    return;+  if (cmd->v_type != VAR_LIST) {+    EMSG2(_(e_invarg2), ""expected String or List"");+    return NULL;   } -  if (argvars[0].v_type != VAR_LIST-      || (argvars[1].v_type != VAR_DICT && argvars[1].v_type != VAR_UNKNOWN)) {-    // Wrong argument types-    EMSG(_(e_invarg));-    return;+  list_T *args = cmd->vval.v_list;+  int argc = args->lv_len;+  if (!argc) {+    EMSG(_(""Argument vector must have at least one item""));+    return NULL;   } -  list_T *args = argvars[0].vval.v_list;-  // Assert that all list items are strings+  assert(args->lv_first);++  const char_u *exe = get_tv_string_chk(&args->lv_first->li_tv);+  if (exe == NULL || !os_can_exe(exe, NULL)) {+    // String is not executable+    if (exe) {+      EMSG2(e_jobexe, exe);+    }+    return NULL;+  }+  +  // Build the argument vector+  int i = 0;+  char **argv = xcalloc(argc + 1, sizeof(char *));   for (listitem_T *arg = args->lv_first; arg != NULL; arg = arg->li_next) {-    if (arg->li_tv.v_type != VAR_STRING) {-      EMSG(_(e_invarg));-      return;+    char *a = (char *)get_tv_string_chk(&arg->li_tv);+    if (a == NULL) {+      // Did emsg in get_tv_string; just deallocate argv.+      while (i-- > 0) {+        xfree(argv[i]);+      }+      return NULL;     }+    argv[i++] = xstrdup(a);   } -  int argc = args->lv_len;-  if (!argc) {-    EMSG(_(""Argument vector must have at least one item""));+  return argv;+}++// ""jobstart()"" function+static void f_jobstart(typval_T *argvars, typval_T *rettv)+{+  rettv->v_type = VAR_NUMBER;+  rettv->vval.v_number = 0;++  if (check_restricted() || check_secure()) {     return;   } -  assert(args->lv_first);- -  const char_u *exe = get_tv_string(&args->lv_first->li_tv);-  if (!os_can_exe(exe, NULL)) {-    // String is not executable-    EMSG2(e_jobexe, exe);+  if (argvars[1].v_type != VAR_DICT && argvars[1].v_type != VAR_UNKNOWN) {+    // Wrong argument types+    EMSG2(_(e_invarg2), ""expected dictionary"");     return;   } +  char **argv = tv_to_argv(&argvars[0]);",Maybe refactor `tv_to_argv` so it receives a `char **` out parameter with the command name?,
3303032,ianks,https://api.github.com/repos/neovim/neovim/pulls/2469,28824394,2015-04-21T21:30:20Z,src/nvim/tui/term_input.inl,"@@ -257,13 +258,11 @@ static TermInput *term_input_new(void)   rv->paste_enabled = false;   rv->in_fd = 0; -  // Set terminal encoding based on environment(taken from libtermkey source-  // code)-  const char *e;+  // Set terminal encoding based on environment+  const char *ctype = setlocale(LC_CTYPE, NULL);   int flags = 0;-  if (((e = os_getenv(""LANG"")) || (e = os_getenv(""LC_MESSAGES""))-        || (e = os_getenv(""LC_ALL""))) && (e = strchr(e, '.')) && e++ &&-      (strcasecmp(e, ""UTF-8"") == 0 || strcasecmp(e, ""UTF8"") == 0)) {+  if ( (ctype != NULL) && (ctype = strchr(ctype, '.')) && ctype++ &&",How do you guys feel about to incrementing ctype in the conditional here? I always find it to be confusing as the side effects become significant in the later comparisons.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/2486,28925296,2015-04-22T23:40:26Z,src/nvim/search.c,"@@ -2921,10 +2921,10 @@ int current_sent(oparg_T *oap, long count, int include)      */     if (start_blank) {       find_first_blank(&curwin->w_cursor);-      c = gchar_pos(&curwin->w_cursor);         /* vim_iswhite() is a macro */-      if (vim_iswhite(c))+      c = gchar_pos(&curwin->w_cursor);         /* ascii_iswhite() is a macro */",no longer true,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/2486,28933378,2015-04-23T02:55:06Z,src/nvim/ascii.h,"@@ -87,4 +90,45 @@ # define PATHSEPSTR     ""/"" #endif +static inline bool ascii_iswhite(int c) FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;",I think this change in naming might confuse people porting upstream Vim patches. Getting used to `vim_*` was replaced by `ascii_*` is much easier.,
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/2486,28935668,2015-04-23T04:16:47Z,src/nvim/ascii.h,"@@ -87,4 +90,45 @@ # define PATHSEPSTR     ""/"" #endif +static inline bool ascii_iswhite(int c) FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;","> I think this change in naming might confuse people porting upstream Vim patches:+1: Good thinking, I'll try to consider that in the future.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2486,28937091,2015-04-23T05:21:18Z,src/nvim/ascii.h,"@@ -87,4 +91,42 @@ # define PATHSEPSTR     ""/"" #endif +static inline bool ascii_iswhite(int) FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;+static inline bool ascii_isdigit(int) FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;+static inline bool ascii_isxdigit(int) FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;+static inline bool ascii_isspace(int) FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;++/// Checks if `c` is a space or tab character.+static inline bool ascii_iswhite(int c)+{+  return c == ' ' || c == '\t';+}++/// Use our own isdigit() replacement, because on MS-Windows isdigit() returns+/// non-zero for superscript 1.  Also avoids that isdigit() crashes for numbers+/// below 0 and above 255.","I would write this as```/// Check whether character is a decimal digit.////// Library isdigit() function is officially locale-dependent and, for /// example, returns true for superscript 1 (��) in locales where encoding /// contains it in lower 8 bits. Also avoids crashes in case c is below /// 0 or above 255: library functions are officially defined as accepting /// only EOF and unsigned char values (otherwise it is undefined behaviour) /// what may be used for some optimizations (e.g. simple `return /// isdigit_table[c];`).```because first sentense is expected to be a brief function description. Though it appears I use rather different style then @tarruda uses for doxygen comments.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2483,28965805,2015-04-23T14:14:54Z,src/nvim/os/pty_process.c,"@@ -205,7 +205,11 @@ static void init_termios(struct termios *termios) FUNC_ATTR_NONNULL_ALL   memset(termios, 0, sizeof(struct termios));   // Taken from pangoterm   termios->c_iflag = ICRNL|IXON;+#ifdef TAB0   termios->c_oflag = OPOST|ONLCR|TAB0;+#else+  termios->c_oflag = OPOST|ONLCR;+#endif",You can use this pattern instead (see other examples below in this file):``` c   termios->c_oflag = OPOST|ONLCR;#ifdef TAB0   termios->c_oflag |= TAB0;#endif```,
491850,doppioandante,https://api.github.com/repos/neovim/neovim/pulls/2490,28977325,2015-04-23T16:09:47Z,src/nvim/message.c,"@@ -3114,14 +3114,14 @@ int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs) {   size_t str_l = 0;   bool str_avail = str_l < str_m;-  char        *p = fmt;+  char *p = fmt;   int arg_idx = 1; -  if (p == NULL)+  if (!p)",Am I the only one who prefers explicitly boolean expressions in control statements (like i.e. Java)? No big deal but our style guideline is not clear in this regard,
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2490,28977708,2015-04-23T16:14:45Z,src/nvim/message.c,"@@ -3114,14 +3114,14 @@ int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs) {   size_t str_l = 0;   bool str_avail = str_l < str_m;-  char        *p = fmt;+  char *p = fmt;   int arg_idx = 1; -  if (p == NULL)+  if (!p)","I'm on the opposite camp. Specially for conditions on pointer, I much prefer the abbreviated form.If I recall correctly, abbreviated form is preferred style in neovim.@justinmk Am I right on this?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2490,28984452,2015-04-23T17:33:38Z,src/nvim/message.c,"@@ -3114,14 +3114,14 @@ int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs) {   size_t str_l = 0;   bool str_avail = str_l < str_m;-  char        *p = fmt;+  char *p = fmt;   int arg_idx = 1; -  if (p == NULL)+  if (!p)","@elmart Yes, we settled on that long ago. Some more details here:  https://github.com/neovim/neovim.github.io/issues/53",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2490,28986243,2015-04-23T17:52:47Z,src/nvim/message.c,"@@ -3240,46 +3230,41 @@ int vim_vsnprintf(char *str, size_t str_m, char *fmt, va_list ap, typval_T *tvs)         }       } -      /* parse 'h', 'l' and 'll' length modifiers */-      if (*p == 'h' || *p == 'l') {+      // parse 'h', 'l', 'll' and 'z' length modifiers+      if (*p == 'h' || *p == 'l' || *p == 'z') {         length_modifier = *p;         p++;-        if (length_modifier == 'l' && *p == 'l') { /* double l = long long */-          length_modifier = '2';                   /* double l encoded as '2' */+        if (length_modifier == 'l' && *p == 'l') { // ll, encoded as 2+          length_modifier = '2';           p++;         }       }+       fmt_spec = *p; -      /* common synonyms: */+      // common synonyms       switch (fmt_spec) {-      case 'i': fmt_spec = 'd'; break;-      case 'D': fmt_spec = 'd'; length_modifier = 'l'; break;-      case 'U': fmt_spec = 'u'; length_modifier = 'l'; break;-      case 'O': fmt_spec = 'o'; length_modifier = 'l'; break;-      case 'F': fmt_spec = 'f'; break;-      default: break;+        case 'i': fmt_spec = 'd'; break;+        case 'D': fmt_spec = 'd'; length_modifier = 'l'; break;+        case 'U': fmt_spec = 'u'; length_modifier = 'l'; break;+        case 'O': fmt_spec = 'o'; length_modifier = 'l'; break;+        case 'F': fmt_spec = 'f'; break;+        default: break;       } -      /* get parameter value, do initial processing */+      // get parameter value, do initial processing       switch (fmt_spec) {-      /* '%' and 'c' behave similar to 's' regarding flags and field widths */-      case '%':-      case 'c':-      case 's':-      case 'S':+      // '%' and 'c' behave similar to 's' regarding flags and field widths+      case '%': case 'c': case 's': case 'S':","Yes, that's non-standard. Recommended way is one-line-per-case.I just did it to match other places in the same function where that is done.Though I cleaned up a bit, there are still a lot of style violations in this code (specially in switch statements, which don't indent cases, for example). But they do because there are lots of them and with a lot of nesting. So, it can make sense in this function.If a future PR completely reformats this to guide-blessed style, it can take care of that.I could do it here if it bothers too much, though.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2491,28997737,2015-04-23T20:02:50Z,src/nvim/ex_getln.c,"@@ -3841,6 +3841,7 @@ static void expand_shellcmd(char_u *filepat, int *num_file, char_u ***file,    flags |= EW_FILE | EW_EXEC; +  bool mustfree = false;  // Track memory allocation for *path.","Ooops, sorry, I just saw your comment right after merging.No big deal, though.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2424,29019048,2015-04-24T01:54:01Z,runtime/doc/eval.txt,"@@ -4031,9 +4031,12 @@ jobsend({job}, {data})					{Nvim} *jobsend()* 			:call jobsend(j, [""abc"", ""123\n456"", """"]) < 		will send ""abc<NL>123<NUL>456<NL>"". -jobstart({argv}[, {opts}])			{Nvim} *jobstart()*-		Spawns {argv}(list) as a job. If passed, {opts} must be a-		dictionary with any of the following keys:+jobstart({cmd}[, {opts}])				{Nvim} *jobstart()*+		Spawns {cmd} as a job.  If {cmd} is a |List|, it will be run+		directly.  If {cmd} is a |String|, it will be equivalent to >","The actual help option is `|string|`, so this should either be changed to that, or `*string*` in `eval.txt` should have `*String*` added next to it for consistency with `*List*` and `*list*`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2495,29020714,2015-04-24T02:49:58Z,appveyor.yml,"@@ -0,0 +1,27 @@+version: '{build}-{branch}'+skip_tags: true+os: Windows Server 2012 R2+environment:+  GYP_MSVS_VERSION: 2013+  matrix:+  - GENERATOR: Visual Studio 12 Win64+    DEPS_PATH: deps64+  - GENERATOR: Visual Studio 12+    DEPS_PATH: deps32+install: []+build_script:+# See http://help.appveyor.com/discussions/problems/539-cloning-gyp-fails",can you explain the role of gyp? is it temporary?,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,29028721,2015-04-24T07:16:08Z,appveyor.yml,"@@ -0,0 +1,27 @@+version: '{build}-{branch}'+skip_tags: true+os: Windows Server 2012 R2+environment:+  GYP_MSVS_VERSION: 2013+  matrix:+  - GENERATOR: Visual Studio 12 Win64+    DEPS_PATH: deps64+  - GENERATOR: Visual Studio 12+    DEPS_PATH: deps32+install: []+build_script:+# See http://help.appveyor.com/discussions/problems/539-cloning-gyp-fails",Not temporary In Windows libuv uses gyp as the build system to generate the VS project files. It needs to clone its git repository first.,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,29029754,2015-04-24T07:37:31Z,.ci/mingw.sh,"@@ -0,0 +1,25 @@+. ""$CI_SCRIPTS/common.sh""++# FIXME: When Travis gets a recent version of Mingw-w64 use this+#sudo apt-get install binutils-mingw-w64-i686 gcc-mingw-w64-i686 g++-mingw-w64-i686 mingw-w64-dev mingw-w64-tools +sudo apt-get install wine +sudo apt-get install libc6-dev-i386 ++# mingw-w64 build from http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/+wget ""http://downloads.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/i686-w64-mingw32-gcc-4.8.0-linux64_rubenvb.tar.xz?r=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fmingw-w64%2Ffiles%2FToolchains%2520targetting%2520Win32%2FPersonal%2520Builds%2Frubenvb%2Fgcc-4.8-release%2F&ts=1422959985&use_mirror=heanet"" -O mingw.tar.xz",":S yes, basically this folder http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,29036908,2015-04-24T09:49:45Z,appveyor.yml,"@@ -0,0 +1,27 @@+version: '{build}-{branch}'+skip_tags: true+os: Windows Server 2012 R2+environment:+  GYP_MSVS_VERSION: 2013+  matrix:+  - GENERATOR: Visual Studio 12 Win64+    DEPS_PATH: deps64+  - GENERATOR: Visual Studio 12+    DEPS_PATH: deps32+install: []+build_script:+# See http://help.appveyor.com/discussions/problems/539-cloning-gyp-fails","That particular git config goes around an issue with the Appveyor network killing https connection, it is not specific to the gyp clone.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2495,29037232,2015-04-24T09:55:00Z,.ci/mingw.sh,"@@ -0,0 +1,25 @@+. ""$CI_SCRIPTS/common.sh""++# FIXME: When Travis gets a recent version of Mingw-w64 use this+#sudo apt-get install binutils-mingw-w64-i686 gcc-mingw-w64-i686 g++-mingw-w64-i686 mingw-w64-dev mingw-w64-tools +sudo apt-get install wine +sudo apt-get install libc6-dev-i386 ++# mingw-w64 build from http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/+wget ""http://downloads.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/i686-w64-mingw32-gcc-4.8.0-linux64_rubenvb.tar.xz?r=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fmingw-w64%2Ffiles%2FToolchains%2520targetting%2520Win32%2FPersonal%2520Builds%2Frubenvb%2Fgcc-4.8-release%2F&ts=1422959985&use_mirror=heanet"" -O mingw.tar.xz",It can be shortened to:```wget http://downloads.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/i686-w64-mingw32-gcc-4.8.0-linux64_rubenvb.tar.xz -O mingw.tar.xz```OpenWRT uses urls similar to the one I specified above.,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2495,29038260,2015-04-24T10:17:13Z,third-party/cmake/BuildLuajit.cmake,"@@ -1,25 +1,81 @@-ExternalProject_Add(luajit-  PREFIX ${DEPS_BUILD_DIR}-  URL ${LUAJIT_URL}-  DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/luajit-  DOWNLOAD_COMMAND ${CMAKE_COMMAND}-    -DPREFIX=${DEPS_BUILD_DIR}-    -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/luajit-    -DURL=${LUAJIT_URL}-    -DEXPECTED_SHA256=${LUAJIT_SHA256}-    -DTARGET=luajit-    -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-  CONFIGURE_COMMAND """"-  BUILD_IN_SOURCE 1-  BUILD_COMMAND """"-  INSTALL_COMMAND ${MAKE_PRG} CC=${DEPS_C_COMPILER}-                              PREFIX=${DEPS_INSTALL_DIR}-                              CFLAGS=-fPIC-                              CFLAGS+=-DLUAJIT_DISABLE_JIT-                              CFLAGS+=-DLUA_USE_APICHECK-                              CFLAGS+=-DLUA_USE_ASSERT-                              CCDEBUG+=-g-                              BUILDMODE=static-                              install)+# Reusable function to build Luajit, set the following build commands before+# calling it:+#   LUAJIT_CONFIGURE_COMMAND+#   LUAJIT_BUILD_COMMAND+#   LUAJIT_INSTALL_COMMAND++function(BuildLuajit TARGET_NAME)+  ExternalProject_Add(${TARGET_NAME}+    PREFIX ${DEPS_BUILD_DIR}+    URL ${LUAJIT_URL}+    DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/luajit+    DOWNLOAD_COMMAND ${CMAKE_COMMAND}+      -DPREFIX=${DEPS_BUILD_DIR}+      -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/luajit+      -DURL=${LUAJIT_URL}+      -DEXPECTED_SHA256=${LUAJIT_SHA256}+      -DTARGET=${TARGET_NAME}+      -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake+      CONFIGURE_COMMAND ""${LUAJIT_CONFIGURE_COMMAND}""+    BUILD_IN_SOURCE 1+    BUILD_COMMAND ""${LUAJIT_BUILD_COMMAND}""+    INSTALL_COMMAND ""${LUAJIT_INSTALL_COMMAND}"")","I'm a bit surprised to see quoting around these.  In general, when you have `set(FOO 1 2 3)`, that is seen as a list.  When wrapped in quotes, `""${FOO}""` will produce ""1;2;3"".  It works out for you because you go through an extra layer of variables, but I _think_ you could drop it without harm.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,29038389,2015-04-24T10:20:20Z,third-party/cmake/BuildLibuv.cmake,"@@ -1,18 +1,77 @@-ExternalProject_Add(libuv-  PREFIX ${DEPS_BUILD_DIR}-  URL ${LIBUV_URL}-  DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/libuv-  DOWNLOAD_COMMAND ${CMAKE_COMMAND}-    -DPREFIX=${DEPS_BUILD_DIR}-    -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/libuv-    -DURL=${LIBUV_URL}-    -DEXPECTED_SHA256=${LIBUV_SHA256}-    -DTARGET=libuv-    -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-  CONFIGURE_COMMAND sh ${DEPS_BUILD_DIR}/src/libuv/autogen.sh &&-    ${DEPS_BUILD_DIR}/src/libuv/configure --with-pic --disable-shared-      --prefix=${DEPS_INSTALL_DIR} --libdir=${DEPS_INSTALL_DIR}/lib-      CC=${DEPS_C_COMPILER}-  INSTALL_COMMAND ${MAKE_PRG} install)+# Reusable function to build libuv, the single argument is+# the target name. The following variables are used as build+# commands:+#   LIBUV_CONFIGURE_COMMAND+#   LIBUV_BUILD_COMMAND+#   LIBUV_INSTALL_COMMAND+#+function(BuildLibuv TARGET_NAME)+  ExternalProject_Add(${TARGET_NAME}+    PREFIX ${DEPS_BUILD_DIR}+    URL ${LIBUV_URL}+    DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/libuv+    DOWNLOAD_COMMAND ${CMAKE_COMMAND}+      -DPREFIX=${DEPS_BUILD_DIR}+      -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/libuv+      -DURL=${LIBUV_URL}+      -DEXPECTED_SHA256=${LIBUV_SHA256}+      -DTARGET=${TARGET_NAME}+      -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake+    CONFIGURE_COMMAND ""${LIBUV_CONFIGURE_COMMAND}""+    BUILD_COMMAND ""${LIBUV_BUILD_COMMAND}""+    INSTALL_COMMAND ""${LIBUV_INSTALL_COMMAND}"")+endfunction()++set(UNIX_CFGCMD sh ${DEPS_BUILD_DIR}/src/libuv/autogen.sh &&+      ${DEPS_BUILD_DIR}/src/libuv/configure --with-pic --disable-shared+        --prefix=${DEPS_INSTALL_DIR} --libdir=${DEPS_INSTALL_DIR}/lib+        CC=${DEPS_C_COMPILER}+        )++if (UNIX)+  set(LIBUV_CONFIGURE_COMMAND ${UNIX_CFGCMD})+  set(LIBUV_BUILD_COMMAND """")+  set(LIBUV_INSTALL_COMMAND ${MAKE_PRG} install)+  BuildLibUv(libuv) ++elseif (MINGW AND CMAKE_CROSSCOMPILING)+  # Build libuv for the host+  set(LIBUV_CONFIGURE_COMMAND sh ${DEPS_BUILD_DIR}/src/libuv_host/autogen.sh && ${DEPS_BUILD_DIR}/src/libuv_host/configure --with-pic --disable-shared --prefix=${HOSTDEPS_INSTALL_DIR} CC=${HOST_C_COMPILER})+  set(LIBUV_BUILD_COMMAND """")+  set(LIBUV_INSTALL_COMMAND ${MAKE_PRG} install)+  BuildLibUv(libuv_host)++  # Build libuv for the target+  set(LIBUV_CONFIGURE_COMMAND ${UNIX_CFGCMD} --host=${CROSS_TARGET})+  BuildLibUv(libuv) ++elseif (WIN32 AND MSVC)+ +  find_package(PythonInterp 2.6 REQUIRED)+  if (NOT PYTHONINTERP_FOUND OR PYTHON_VERSION_MAJOR GREATER 2)+    message(FATAL_ERROR ""Python2 is required to build libuv on windows, use -DPYTHON_EXECUTABLE to set a python interpreter"")+  endif()++  string(FIND ${CMAKE_GENERATOR} Win64 VS_WIN64)+  if (VS_WIN64 EQUAL -1)+      set(VS_ARCH x86)+  else()+      set(VS_ARCH x64)+  endif()+  # FIXME: Remove this when libuv is updated (libuv/libuv#240)+  set(LIBUV_CONFIGURE_COMMAND git clone https://chromium.googlesource.com/external/gyp.git ${DEPS_BUILD_DIR}/src/libuv/build/gyp)+  # By default this creates Debug builds",For MSVC the runtimes between all components must match i.e. I cant build a debug Neovim against a static non-debug libuv - well maybe I can but the compiler will complain. Ideally this should match the build type for the main Neovim (let me have a look at that).,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2495,29038890,2015-04-24T10:30:14Z,third-party/cmake/BuildLuarocks.cmake,"@@ -80,24 +129,26 @@ if(USE_BUNDLED_BUSTED)     ARGS build luasocket 3.0rc1-2 ${LUAROCKS_BUILDARGS}     COMMAND ${LUAROCKS_BINARY}     ARGS build xml 1.1.1-1 ${LUAROCKS_BUILDARGS}-    COMMAND touch ${DEPS_LIB_DIR}/luarocks/rocks/stable-busted-deps+    COMMAND touch ${HOSTDEPS_LIB_DIR}/luarocks/rocks/stable-busted-deps     DEPENDS lpeg)   add_custom_target(stable-busted-deps-    DEPENDS ${DEPS_LIB_DIR}/luarocks/rocks/stable-busted-deps)+    DEPENDS ${HOSTDEPS_LIB_DIR}/luarocks/rocks/stable-busted-deps)   -  add_custom_command(OUTPUT ${DEPS_BIN_DIR}/busted+  add_custom_command(OUTPUT ${HOSTDEPS_BIN_DIR}/busted     COMMAND ${LUAROCKS_BINARY}     ARGS build https://raw.githubusercontent.com/Olivine-Labs/busted/v2.0.rc8-0/busted-2.0.rc8-0.rockspec ${LUAROCKS_BUILDARGS}     DEPENDS stable-busted-deps)   add_custom_target(busted-    DEPENDS ${DEPS_BIN_DIR}/busted)+    DEPENDS ${HOSTDEPS_BIN_DIR}/busted)   -  add_custom_command(OUTPUT ${DEPS_LIB_DIR}/luarocks/rocks/nvim-client+  add_custom_command(OUTPUT ${HOSTDEPS_LIB_DIR}/luarocks/rocks/nvim-client     COMMAND ${LUAROCKS_BINARY}-    ARGS build https://raw.githubusercontent.com/neovim/lua-client/8cc5b6090ac61cd0bba53ba984f15792fbb64573/nvim-client-0.0.1-11.rockspec ${LUAROCKS_BUILDARGS} LIBUV_DIR=${DEPS_INSTALL_DIR}+    ARGS build https://raw.githubusercontent.com/neovim/lua-client/8cc5b6090ac61cd0bba53ba984f15792fbb64573/nvim-client-0.0.1-11.rockspec ${LUAROCKS_BUILDARGS} LIBUV_DIR=${HOSTDEPS_INSTALL_DIR}     DEPENDS busted libuv)   add_custom_target(nvim-client-    DEPENDS ${DEPS_LIB_DIR}/luarocks/rocks/nvim-client)+    DEPENDS ${HOSTDEPS_LIB_DIR}/luarocks/rocks/nvim-client)+  list(APPEND THIRD_PARTY_DEPS nvim-client)   -  list(APPEND THIRD_PARTY_DEPS stable-busted-deps busted nvim-client)+  list(APPEND THIRD_PARTY_DEPS stable-busted-deps busted)",Why shuffle the `nvim-client` dependency into it's own list-append?  Is there an ordering issue?,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,29049398,2015-04-24T13:48:04Z,third-party/cmake/BuildLuajit.cmake,"@@ -1,25 +1,81 @@-ExternalProject_Add(luajit-  PREFIX ${DEPS_BUILD_DIR}-  URL ${LUAJIT_URL}-  DOWNLOAD_DIR ${DEPS_DOWNLOAD_DIR}/luajit-  DOWNLOAD_COMMAND ${CMAKE_COMMAND}-    -DPREFIX=${DEPS_BUILD_DIR}-    -DDOWNLOAD_DIR=${DEPS_DOWNLOAD_DIR}/luajit-    -DURL=${LUAJIT_URL}-    -DEXPECTED_SHA256=${LUAJIT_SHA256}-    -DTARGET=luajit-    -P ${CMAKE_CURRENT_SOURCE_DIR}/cmake/DownloadAndExtractFile.cmake-  CONFIGURE_COMMAND """"-  BUILD_IN_SOURCE 1-  BUILD_COMMAND """"-  INSTALL_COMMAND ${MAKE_PRG} CC=${DEPS_C_COMPILER}-                              PREFIX=${DEPS_INSTALL_DIR}-                              CFLAGS=-fPIC-                              CFLAGS+=-DLUAJIT_DISABLE_JIT-                              CFLAGS+=-DLUA_USE_APICHECK-                              CFLAGS+=-DLUA_USE_ASSERT-                              CCDEBUG+=-g-                              BUILDMODE=static-                              install)+# Reusable function to build Luajit, set the following build commands before+# calling it:+#   LUAJIT_CONFIGURE_COMMAND+#   LUAJIT_BUILD_COMMAND+#   LUAJIT_INSTALL_COMMAND",Added a commit for this. The semantics is now similar to ExternalProject_Add.,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2496,29086051,2015-04-24T21:08:46Z,runtime/doc/various.txt,"@@ -35,8 +35,6 @@ CTRL-L			Clear and redraw the screen.  The redraw may happen 			Note: if you like to use <BS> for this, add this 			mapping to your .vimrc: > 				:map CTRL-V <BS>   CTRL-V <Del>-<			See |:fixdel| if your <Del> key does not do what you","The `<` was removed, but I'm not sure it was accidental (isn't only a `>` needed for one line of code in help docs?).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2496,29094225,2015-04-24T23:43:34Z,runtime/doc/vim_diff.txt,"@@ -21,9 +21,9 @@ these differences. ============================================================================== 1. Configuration					    *nvim-configuration* -- Use "".nvimrc"" instead of "".vimrc"" for storing configuration.-- Use "".nvim"" instead of "".vim"" to store configuration files.-- Use "".nviminfo"" instead of "".viminfo"" for persistent session information.+- Use `.nvimrc` instead of `.vimrc` for storing configuration.+- Use `.nvim` instead of `.vim` to store configuration files.+- Use `.nviminfo` instead of `.viminfo` for persistent session information.","vimdoc has supported backticks for a long time, though it's odd it is not mentioned in `:help help`. We should start using these for technical identifiers instead of quotation marks, in most cases.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2496,29095774,2015-04-25T00:45:36Z,runtime/doc/vim_diff.txt,"@@ -21,9 +21,9 @@ these differences. ============================================================================== 1. Configuration					    *nvim-configuration* -- Use "".nvimrc"" instead of "".vimrc"" for storing configuration.-- Use "".nvim"" instead of "".vim"" to store configuration files.-- Use "".nviminfo"" instead of "".viminfo"" for persistent session information.+- Use `.nvimrc` instead of `.vimrc` for storing configuration.+- Use `.nvim` instead of `.vim` to store configuration files.+- Use `.nviminfo` instead of `.viminfo` for persistent session information.","> though it's odd it is not mentioned in :help helpSince this PR's scope doesn't seem precise anymore, perhaps you could add this patch to this PR:``` diffdiff --git a/runtime/doc/helphelp.txt b/runtime/doc/helphelp.txtindex ca109cf..5e3db84 100644--- a/runtime/doc/helphelp.txt+++ b/runtime/doc/helphelp.txt@@ -318,11 +318,14 @@ name between two bars (|) eg. |help-writing|. When referring to a Vim option in the help file, place the option name between two single quotes, eg. 'statusline'+When referring to any other technical term, such as a filename or function+parameter, surround it in backticks (`), e.g., `~/.path/to/nvimrc`.+ HIGHLIGHTING To define a column heading, use a tilde character at the end of the line.-This will highlight the column heading in a different color.  E.g.+This will highlight the column heading in a different color. Column heading~```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2500,29096223,2015-04-25T01:09:08Z,src/nvim/strings.c,"@@ -413,21 +413,18 @@ char_u *vim_strchr(const char_u *string, int c) }  /*- * Version of strchr() that only works for bytes and handles unsigned char- * strings with characters above 128 correctly. It also doesn't return a- * pointer to the NUL at the end of the string.+ * Search for c in buf. Appropriately handles values of c in [0, 255].","Please use Doxygen style comments `///`, and function parameters should be surrounded in backticks, e.g. ``c``.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2470,29104068,2015-04-25T21:06:03Z,src/nvim/fileio.c,"@@ -4333,108 +4333,95 @@ void shorten_fnames(int force)   redraw_tabline = TRUE; } -/*- * add extension to file name - change path/fo.o.h to path/fo.o.h.ext- *- * Assumed that fname is a valid name found in the filesystem we assure that- * the return value is a different name and ends in 'ext'.- * ""ext"" MUST be at most 4 characters long if it starts with a dot, 3- * characters otherwise.- * Space for the returned name is allocated, must be freed later.- * Returns NULL when out of memory.- */-char_u *-modname (-    char_u *fname,-    char_u *ext,-    int prepend_dot                /* may prepend a '.' to file name */-)+/// add extension to file name - change path/fo.o.h to path/fo.o.h.ext+///+/// Assumed that fname is a valid name found in the filesystem we assure that+/// the return value is a different name and ends in 'ext'.+/// ""ext"" MUST be at most 4 characters long if it starts with a dot, 3+/// characters otherwise.+/// Space for the returned name is allocated, must be freed later.+/// Returns NULL when out of memory.+/// @param fname When NULL use the current directory name+/// @param ext The extension to add to the filename, 4 chars max if prefixed +///            with a dot, 3 otherwise.+/// @param prepend_dot If true, prefix the ext with a dot+char *modname (char *fname, char *ext, bool prepend_dot)  {-  char_u      *retval;-  char_u      *s;-  char_u      *e;-  char_u      *ptr;-  int fnamelen, extlen;--  extlen = (int)STRLEN(ext);+  char *retval;+  size_t fnamelen;+  size_t extlen = strlen(ext); -  /*-   * If there is no file name we must get the name of the current directory-   * (we need the full path in case :cd is used).-   */+  // If there is no file name we must get the name of the current directory+  // (we need the full path in case :cd is used).   if (fname == NULL || *fname == NUL) {     retval = xmalloc(MAXPATHL + extlen + 3);-    if (os_dirname(retval, MAXPATHL) == FAIL ||-        (fnamelen = (int)STRLEN(retval)) == 0) {+    if (os_dirname((char_u *)retval, MAXPATHL) == FAIL ||+        (fnamelen = strlen(retval)) == 0) {       xfree(retval);       return NULL;     }-    if (!after_pathsep((char *)retval, (char *)retval + fnamelen)) {+    if (!after_pathsep(retval, retval + fnamelen)) {       retval[fnamelen++] = PATHSEP;       retval[fnamelen] = NUL;     }-    prepend_dot = FALSE;            /* nothing to prepend a dot to */+    prepend_dot = FALSE;  // nothing to prepend a dot to   } else {-    fnamelen = (int)STRLEN(fname);+    fnamelen = strlen(fname);     retval = xmalloc(fnamelen + extlen + 3);-    STRCPY(retval, fname);+    strcpy(retval, fname);   } -  /*-   * search backwards until we hit a '/', '\' or ':'.-   * Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.-   */+  // Search backwards until we hit a '/', '\' or ':'.+  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.+  char *ptr = NULL;   for (ptr = retval + fnamelen; ptr > retval; mb_ptr_back(retval, ptr)) {     if (vim_ispathsep(*ptr)) {-      ++ptr;+      ptr++;       break;     }   } -  /* the file name has at most BASENAMELEN characters. */-  if (STRLEN(ptr) > BASENAMELEN)+  // the file name has at most BASENAMELEN characters.+  if (strlen(ptr) > BASENAMELEN) {     ptr[BASENAMELEN] = '\0';+  } -  s = ptr + STRLEN(ptr);+  char *s;+  s = ptr + strlen(ptr);  #if defined(WIN3264)-  /*-   * If there is no file name, and the extension starts with '.', put a-   * '_' before the dot, because just "".ext"" may be invalid if it's on a-   * FAT partition, and on HPFS it doesn't matter.-   */-  else if ((fname == NULL || *fname == NUL) && *ext == '.')+  // If there is no file name, and the extension starts with '.', put a+  // '_' before the dot, because just "".ext"" may be invalid if it's on a+  // FAT partition, and on HPFS it doesn't matter.+  else if ((fname == NULL || *fname == NUL) && *ext == '.') {","Future note: This pattern `(pointer == NULL || *pointer == NUL)` is repeated over and over again. Not here, but at some point, it would be a nice refactoring replacing this by an `empty(pointer)` inline function (better than macro).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2041,29119864,2015-04-27T04:11:19Z,src/nvim/window.c,"@@ -487,6 +487,16 @@ do_window (   } } +static void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize,+                           uint32_t Prenum)+{+  size_t len = xstrlcpy((char *)bufp, cmd, bufsize);++  if (Prenum > 0 && len < bufsize) {+    vim_snprintf((char *)bufp + len, bufsize - len, ""%ld"", Prenum);","Use a portable format specifier (like the old Neovim version, here: https://github.com/neovim/neovim/pull/2041/files#diff-40d9eb21ee75b3df148c827ec4d4310aL129 ). `Prenum` is `long` so `PRId64` is the format specifier for that. E.g.:``` c  if (Prenum > 0 && len < bufsize) {    vim_snprintf((char *)bufp + len, bufsize - len, ""%"" PRId64, Prenum);```Why does `cmd_with_count()` declare `Prenum` as `uint32_t` instead of `long`?See also: https://github.com/neovim/neovim/pull/1729#discussion_r22436056",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2518,29125833,2015-04-27T07:47:09Z,src/nvim/normal.c,"@@ -3586,13 +3586,16 @@ void scroll_redraw(int up, long count)  */ static void nv_zet(cmdarg_T *cap) {-  long n;+  int n;   colnr_T col;   int nchar = cap->nchar;   long old_fdl = curwin->w_p_fdl;   int old_fen = curwin->w_p_fen;   bool undo = false; +  assert(p_siso <= INT_MAX);+  int p_siso_l = (int)p_siso;",Any reason not to prefix `l_` prefix as you usually do? I'd prefer to always use the same pattern.,
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2340,29127354,2015-04-27T08:13:57Z,.ci/common.sh,"@@ -51,20 +51,8 @@ check_core_dumps() { }  setup_deps() {-	sudo pip install --upgrade pip-	sudo pip install neovim--	# For pip3-	# https://github.com/travis-ci/travis-ci/issues/1528-	# sudo apt-get install -q python3.3-dev-	# curl -Ss http://python-distribute.org/distribute_setup.py | sudo python3-	# curl -Ss https://raw.github.com/pypa/pip/master/contrib/get-pip.py | sudo python3-	# sudo pip3.3 install neovim- 	if [ ""$BUILD_NVIM_DEPS"" != ""true"" ]; then","To get the deps on OS X, you would need to add a condition on `$TRAVIS_OS_NAME` here and put back the `setup_deps` calls into the build files.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2340,29127875,2015-04-27T08:21:21Z,.ci/common.sh,"@@ -51,20 +51,8 @@ check_core_dumps() { }  setup_deps() {-	sudo pip install --upgrade pip-	sudo pip install neovim--	# For pip3-	# https://github.com/travis-ci/travis-ci/issues/1528-	# sudo apt-get install -q python3.3-dev-	# curl -Ss http://python-distribute.org/distribute_setup.py | sudo python3-	# curl -Ss https://raw.github.com/pypa/pip/master/contrib/get-pip.py | sudo python3-	# sudo pip3.3 install neovim- 	if [ ""$BUILD_NVIM_DEPS"" != ""true"" ]; then","And maybe put in an else:``` bash...elif [ ""$TRAVIS_OS_NAME"" = ""linux"" ]; then  # Make sure deps are up-to-date before proceeding  # Remove sources from cache to force download on dependency changes  rm -rf .deps/build/src  make depsfi```Otherwise, if a dependency is updated to a new version, CMake will register that something has changed and rebuild, but skip fetching the new sources (due to [this](https://github.com/neovim/neovim/blob/master/third-party/cmake/DownloadAndExtractFile.cmake#L28)) and just build the old version again.I'm not sure if this is the best solution, though.. Maybe the `rm` should be put in [`before_cache`](https://github.com/neovim/neovim/pull/2340#issuecomment-91253389) instead, or we can improve the ""skip download"" logic in CMake somehow. What do you think @jszakmeister?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2492,29129301,2015-04-27T08:44:48Z,test/functional/legacy/listchars_spec.lua,"@@ -0,0 +1,96 @@+-- Tests for 'listchars' display with 'list' and :list.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe(""'listchars'"", function()+  before_each(clear)++  it(""is working with 'list'"", function()","Mentioning for the future: I suggest leaving out ""is working"" in the test descriptions if a meaningful behavioral description can't be had. `""with 'list'""` is sufficient. Trying to fit in the clever BDD ""it"" format just forces us to repeat this ""is working"" filler which makes reading the test source more noisy. ",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2518,29130207,2015-04-27T08:58:26Z,src/nvim/normal.c,"@@ -3586,13 +3586,16 @@ void scroll_redraw(int up, long count)  */ static void nv_zet(cmdarg_T *cap) {-  long n;+  int n;   colnr_T col;   int nchar = cap->nchar;   long old_fdl = curwin->w_p_fdl;   int old_fen = curwin->w_p_fen;   bool undo = false; +  assert(p_siso <= INT_MAX);+  int p_siso_l = (int)p_siso;",":+1: I just got it wrong.This was a little different than usual. Intention was not to make a local copy to avoid analyzer thinking global variable can change value, but to make a local copy with a different type (long --> int) to avoid casting/checking in several places. I was going to call it `p_siso_int`, or `p_siso_i` to highlight that intention. Then, I thought using normal convention (prefix ""l_"") would be enough, and it wasn't worth introducing a new convention for type-changed vars. But I used the wrong form.So, I can use the ""l_"" prefix, or I can use a prefix ""int_"" or ""i_"", or maybe ""l_i_"". What do you think?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2518,29132889,2015-04-27T09:40:29Z,src/nvim/file_search.c,"@@ -1310,15 +1310,17 @@ static int ff_path_in_stoplist(char_u *path, int path_len, char_u **stopdirs_v) char_u * find_file_in_path (     char_u *ptr,               /* file name */-    int len,                        /* length of file name */+    size_t len,                /* length of file name */     int options,     int first,                      /* use count'th matching file name */     char_u *rel_fname         /* file name searching relative to */ ) {   return find_file_in_path_option(ptr, len, options, first,-      *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,-      FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);+                                  *curbuf->b_p_path == NUL+                                  ? p_path+                                  : curbuf->b_p_path,+                                  FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);","It's different because `?` and `:` are subexpressions of the ternary condition. I believe we _do_ indent nested `&&` and `+`, e.g.:``` cif (foo  && (bar    && baz)) {    ...```instead of:``` cif (foo  && (bar  && baz)) {    ...```If you don't agree, don't worry about it.",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2518,29133023,2015-04-27T09:42:20Z,src/nvim/file_search.c,"@@ -1310,15 +1310,17 @@ static int ff_path_in_stoplist(char_u *path, int path_len, char_u **stopdirs_v) char_u * find_file_in_path (     char_u *ptr,               /* file name */-    int len,                        /* length of file name */+    size_t len,                /* length of file name */     int options,     int first,                      /* use count'th matching file name */     char_u *rel_fname         /* file name searching relative to */ ) {   return find_file_in_path_option(ptr, len, options, first,-      *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,-      FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);+                                  *curbuf->b_p_path == NUL+                                  ? p_path+                                  : curbuf->b_p_path,+                                  FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);","Another solution is to always add surrounding parentheses in that case, which would render the thing:```   ...   other_previous_arg,   (*curbuf->b_p_path == NUL    ? p_path    : curbuf->b_p_path),   other_successive_arg,   ...```That doesn't need to make an exception for ternary operator, and is more legible.I don't have any problem to apply what you said, though. Just suggesting alternatives. I don't like exceptions.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2518,29133178,2015-04-27T09:44:42Z,src/nvim/file_search.c,"@@ -1310,15 +1310,17 @@ static int ff_path_in_stoplist(char_u *path, int path_len, char_u **stopdirs_v) char_u * find_file_in_path (     char_u *ptr,               /* file name */-    int len,                        /* length of file name */+    size_t len,                /* length of file name */     int options,     int first,                      /* use count'th matching file name */     char_u *rel_fname         /* file name searching relative to */ ) {   return find_file_in_path_option(ptr, len, options, first,-      *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,-      FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);+                                  *curbuf->b_p_path == NUL+                                  ? p_path+                                  : curbuf->b_p_path,+                                  FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);",I don't see it as an exception for reason mentioned above. Parentheses form is fine with me though.,
3404250,grtlr,https://api.github.com/repos/neovim/neovim/pulls/2340,29141170,2015-04-27T12:22:10Z,.travis.yml,"@@ -34,38 +43,21 @@ matrix:       compiler: gcc-4.9   fast_finish: true before_install:-  # Pins the version of the java package installed on the Travis VMs-  # and avoids a lengthy upgrade process for them.-  - if [ $TRAVIS_OS_NAME = linux ]; then-      sudo apt-mark hold oracle-java7-installer oracle-java8-installer;-      sudo apt-get update;-    elif [ $TRAVIS_OS_NAME = osx ]; then+  - if [ $TRAVIS_OS_NAME = osx ]; then       brew update;     fi+  - pip install --user -q --upgrade pip install:-  - if [ $TRAVIS_OS_NAME = linux ]; then-      sudo apt-get install xclip gdb;-    elif [ $TRAVIS_OS_NAME = osx ]; then+  - if [ $TRAVIS_OS_NAME = osx ]; then       brew install gettext;     fi-before_script:-  # Adds user to a dummy group.-  # That allows to test changing the group of the file by `os_fchown`.-  # Need xvfb for running some tests with xclip-  - if [ $TRAVIS_OS_NAME = linux ]; then-      sudo groupadd chown_test;-      sudo usermod -a -G chown_test $USER;-      export DISPLAY=:99.0;-      sh -e /etc/init.d/xvfb start;-    elif [ $TRAVIS_OS_NAME = osx ]; then-      sudo dscl . -create /Groups/chown_test;-      sudo dscl . -append /Groups/chown_test GroupMembership $USER;-    fi+  - pip install --user -q cpp-coveralls neovim script:-  # This will pass the environment variables down to a bash process which runs-  # as $USER, while retaining the environment variables defined and belonging-  # to secondary groups given above in usermod.-  - sudo -E su $USER -c ""sh -e \""$CI_SCRIPTS/$CI_TARGET.sh\""""+  - sh -e $CI_SCRIPTS/$CI_TARGET.sh+cache:+  - build/neovim/neovim/.deps","Thank you very much, I was looking for something like this. We should also test `install` dependent on this directory and not depending on `$HOME`?",
135757,elmart,https://api.github.com/repos/neovim/neovim/pulls/2319,29152285,2015-04-27T14:44:32Z,src/nvim/ex_getln.c,"@@ -1781,24 +1781,29 @@ getexmodeline (         msg_col = startcol;         msg_clr_eos();         line_ga.ga_len = 0;-        continue;+        goto redraw;       } +      int num_spaces;       if (c1 == Ctrl_T) {         int sw = get_sw_value(curbuf);          p = (char_u *)line_ga.ga_data;         p[line_ga.ga_len] = NUL;         indent = get_indent_str(p, 8, FALSE);-        indent += sw - indent % sw;+        num_spaces = sw - indent % sw;+        indent += num_spaces;","This line is causing a new warning (dead store). Clang says `indent` isn't read any more after this, but on a quick glance I don't see why. Can you confirm is this line can be safely removed?",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2041,29166722,2015-04-27T17:04:51Z,runtime/doc/editing.txt,"@@ -801,8 +801,9 @@ current window.  The two windows then share this list, until one of them uses USING THE ARGUMENT LIST  						*:argdo*-:argdo[!] {cmd}		Execute {cmd} for each file in the argument list.-			It works like doing this: >+:[range]argdo[!] {cmd}	Execute {cmd} for each file in the argument list or",maybe comma after `list`,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2041,29198777,2015-04-27T22:34:53Z,runtime/doc/editing.txt,"@@ -801,8 +801,9 @@ current window.  The two windows then share this list, until one of them uses USING THE ARGUMENT LIST  						*:argdo*-:argdo[!] {cmd}		Execute {cmd} for each file in the argument list.-			It works like doing this: >+:[range]argdo[!] {cmd}	Execute {cmd} for each file in the argument list or","Turned it into ```:[range]argdo[!] {cmd}  Execute {cmd} for each file in the argument list or,            if [range] is specified, only for arguments in that```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2532,29307365,2015-04-29T02:56:55Z,src/nvim/screen.c,"@@ -6450,7 +6450,6 @@ int screen_ins_lines (   // - there is no valid screen   // - the screen has to be redrawn completely   // - the line count is less than one",this comment doesn't match the condition. And the entire comment is kind of redundant and/or outdated at this point.,
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2539,29441865,2015-04-30T15:49:34Z,src/nvim/eval.c,"@@ -8145,11 +8145,17 @@ static void f_eval(typval_T *argvars, typval_T *rettv)   if (s != NULL)     s = skipwhite(s); -  if (s == NULL || eval1(&s, rettv, TRUE) == FAIL) {+  if (s == NULL || eval1(&s, rettv, true) == FAIL) {+    char_u *p = s;","I think you overshot the goal slightly :)`p` must be left outside the block, it should keep pointing to the input string even after `eval1`ing `s`. As it is the patch is no longer correct.Also, you cannot simply replace `TRUE` with `true` and `FALSE` with `false`, these variables have type `int` (and sometimes hold values other than `0` and `1`). Unless the conversion to `bool` is trivial it is perhaps better to leave it for another pull request.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2542,29450481,2015-04-30T17:27:04Z,runtime/syntax/help.vim,"@@ -85,7 +85,6 @@ syn match helpSpecial		""CTRL-PageDown"" syn match helpSpecial		""CTRL-Insert"" syn match helpSpecial		""CTRL-Del"" syn match helpSpecial		""CTRL-{char}""-syn region helpNotVi		start=""{Vi[: ]"" start=""{not"" start=""{only"" end=""}"" contains=helpLeadBlank,helpHyperTextJump syn match helpLeadBlank		""^\s\+"" contained","As far as I can see, `helpLeadBlank` is now no longer needed and can be deleted. True?",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2542,29450653,2015-04-30T17:28:54Z,runtime/doc/repeat.txt,"@@ -139,17 +139,78 @@ q			Stops recording.  (Implementation note: The 'q' that 			result of evaluating the expression is executed as an 			Ex command. 			Mappings are not recognized in these commands.-			{Vi: only in some versions} Future: Will execute the-			register for each line in the address range.++			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME+			LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME LOOK AT ME++			TODO(Pyrohh): what does the below line mean? I don't+			know what is meant by ""future"", as I'm not sure if+			what is mentioned below is already implemented.","No, it isn't implemented yet but it's in the todo list:> The ""`:@r`"" commands should take a range and execute the register for each line in the range.Personally I would leave it in and deal with it some other time.",
123376,mbainter,https://api.github.com/repos/neovim/neovim/pulls/2470,29464259,2015-04-30T19:58:04Z,src/nvim/memline.c,"@@ -1441,17 +1441,17 @@ recover_names (  * Append the full path to name with path separators made into percent  * signs, to dir. An unnamed buffer is handled as """" (<currentdir>/"""")  */-static char_u *make_percent_swname(char_u *dir, char_u *name)+static char *make_percent_swname(char *dir, char *name)","Not easily.  I'm working on a separate PR to do that, as it requires a chain of changes in other functions that wouldn't integrate simply into this PR.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2424,29467943,2015-04-30T20:41:00Z,runtime/doc/eval.txt,"@@ -6299,15 +6301,19 @@ tempname()					*tempname()* *temp-file-name* 		For MS-Windows forward slashes are used when the 'shellslash' 		option is set or when 'shellcmdflag' starts with '-'. -termopen({command}[, {opts}])			{Nvim} *termopen()*-		Spawns {command} using the shell in a new pseudo-terminal-		session connected to the current buffer.  This function fails-		if the current buffer is modified (all buffer contents are-		destroyed).  The {opts} dict is similar to the one passed to-		|jobstart()|, but the `pty`, `width`, `height`, and `TERM` fields are-		ignored: `height`/`width` are taken from the current window and-		$TERM is set to ""xterm-256color"".  Returns the same values as-		|jobstart()|.+termopen({cmd}[, {opts}])			{Nvim} *termopen()*+		Spawns {cmd} in a new pseudo-terminal session connected+		to the current buffer.  {cmd} is the same as the one passed to+		|jobstart()|.  This function fails if the current buffer is+		modified (all buffer contents are destroyed).","At least the first part of that relates to #2368. `f_termopen()` has``` c  if (curbuf->b_changed) {    EMSG(_(""Can only call this function in an unmodified buffer""));    return;  }```to protect against destroying modified buffers, but doesn't hide it. Also, some reading of code using `b_changed` suggested to me that this check might be insufficient. Hijacking the buffer  causes #2408 because of a static variable in `syntax.c` not getting updated.`termopen` definitely still needs some work, but I want to save that for another PR so I can get this merged.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2424,29469473,2015-04-30T20:56:53Z,runtime/doc/eval.txt,"@@ -6299,15 +6301,19 @@ tempname()					*tempname()* *temp-file-name* 		For MS-Windows forward slashes are used when the 'shellslash' 		option is set or when 'shellcmdflag' starts with '-'. -termopen({command}[, {opts}])			{Nvim} *termopen()*-		Spawns {command} using the shell in a new pseudo-terminal-		session connected to the current buffer.  This function fails-		if the current buffer is modified (all buffer contents are-		destroyed).  The {opts} dict is similar to the one passed to-		|jobstart()|, but the `pty`, `width`, `height`, and `TERM` fields are-		ignored: `height`/`width` are taken from the current window and-		$TERM is set to ""xterm-256color"".  Returns the same values as-		|jobstart()|.+termopen({cmd}[, {opts}])			{Nvim} *termopen()*+		Spawns {cmd} in a new pseudo-terminal session connected+		to the current buffer.  {cmd} is the same as the one passed to+		|jobstart()|.  This function fails if the current buffer is+		modified (all buffer contents are destroyed).++		The {opts} dict is similar to the one passed to |jobstart()|,+		but the `pty`, `width`, `height`, and `TERM` fields are+		ignored: `height`/`width` are taken from the current window","I can't think of a use case for setting a custom `'height'`, but perhaps `'width'` could be set to the maximum of the buffer's width and the given number so that long commands/output get linewrapped. I seem to remember someone opening an issue about this, but I can't find it.I'd like to save that for another PR, though. I haven't modified that code.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2502,29472731,2015-04-30T21:32:32Z,src/nvim/strings.c,"@@ -412,22 +412,18 @@ char_u *vim_strchr(const char_u *string, int c)   return NULL; } -/*- * Version of strchr() that only works for bytes and handles unsigned char- * strings with characters above 128 correctly. It also doesn't return a- * pointer to the NUL at the end of the string.- */-char_u *vim_strbyte(const char_u *string, int c)++/// Search for c in buf.+/// @param buf Buffer where the search is performed.+/// @param c Byte to look for. Can be in the range [0, 255].+char_u *vim_strbyte(const char_u *buf, int c)   FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE {-  const char_u *p = string;--  while (*p != NUL) {-    if (*p == c)-      return (char_u *) p;-    ++p;+  if (c > (unsigned char) -1 || c <= 0) {",Doesn't this conditional return true for any value?,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2424,29479000,2015-04-30T23:07:34Z,src/nvim/ex_docmd.c,"@@ -9409,9 +9409,20 @@ static void ex_folddo(exarg_T *eap)  static void ex_terminal(exarg_T *eap) {-  char cmd[512];-  snprintf(cmd, sizeof(cmd), "":enew%s | call termopen('%s') | startinsert"",-      eap->forceit==TRUE ? ""!"" : """",-      strcmp((char *)eap->arg, """") ? (char *)eap->arg : (char *)p_sh);-  do_cmdline_cmd((uint8_t *)cmd);+  // We will call `termopen()` will `[&shell]` if given a {cmd}.","The brackets denote that we send it as a list, but using `'shell'` instead of `&shell` does seem to make sense.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2562,29539892,2015-05-01T23:00:40Z,src/nvim/regexp.c,"@@ -3293,7 +3293,8 @@ bt_regexec_nl (   ireg_ic = rmp->rm_ic;   ireg_icombine = FALSE;   ireg_maxcol = 0;-  return bt_regexec_both(line, col, NULL) != 0;++  return bt_regexec_both(line, col, NULL);","I need some advice here. `bt_regexec_both` returns `long`, but this function returns `int`.What is the proper way of handling this? Simply cast the result to `int`, or perhaps add an `assert` with a value range?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2574,29557436,2015-05-03T16:17:06Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.+bool striequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcasecmp(a, b) == 0;+}++/// Compares two sized strings for equality ignoring differences in case.+bool strniequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncasecmp(a, b, size) == 0;+}++/// Checks a string for being NULL or empty.+bool strempty(const char *s)+  FUNC_ATTR_PURE+{+  return s == NULL || s[0] == '\0';+}","And how about making this and `strn?equal` functions `static inline` in the header? This way compiler will be able to optimize them out (not suggesting for `strn?iequal` because I do not see gcc optimizing even `strcasecmp(""abc"", ""abc"")` out: most likely due to it being locale-dependent I think).",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/2574,29557449,2015-05-03T16:19:30Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.+bool striequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcasecmp(a, b) == 0;",On that accord: http://botsikas.blogspot.de/2011/12/strcasecmp-identifier-not-found-when.html``` c#if defined(_WIN32) || defined(_WIN64)   #define snprintf _snprintf   #define vsnprintf _vsnprintf   #define strcasecmp _stricmp   #define strncasecmp _strnicmp #endif```For an older version of MSVC. Don't know what the 2015 state is.Our other (wannabe) supported POSIX-like systems should have it: *BSD and Illumos.**EDIT**: docs for Windows' [_stricmp](https://msdn.microsoft.com/en-us/library/k59z8dwe.aspx),
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2574,29557561,2015-05-03T16:32:17Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.+bool striequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcasecmp(a, b) == 0;","@aktau And third condition should not be a error, it should be `vim_stricmp`. Not sure whether `stricmp` (without underscore) needs to be kept: I never saw this function, but apparently Vim authors did.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/2574,29557711,2015-05-03T16:48:03Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.+bool striequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcasecmp(a, b) == 0;","So:`strcasecmp`: modern POSIX function, not supported by Windows`stricmp`: Windows function that appears to be neither POSIX nor ANSI, despite what some blog posts say, it is [deprecated by Microsoft](https://msdn.microsoft.com/en-us/library/ms235365.aspx). Strangely enough, even Microsoft refers to these functions as being POSIX.`_stricmp`: Windows function that's apparently the non-deprecated version of `strcmp`.Btw, [this SO post](http://stackoverflow.com/questions/12413585/difference-of-stricmp-and-stricmp-in-visual-studio) claims that `stricmp` is merely an alias to `stricmp` in MSVC, which wouldn't surprise me.I woudl go for `ifdef`ing towards the underscore version though, since it's explicitly referenced as non-dreprecated.",
189413,aktau,https://api.github.com/repos/neovim/neovim/pulls/2574,29557743,2015-05-03T16:50:58Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.+bool striequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcasecmp(a, b) == 0;","> @aktau And third condition should not be a error, it should be vim_stricmp.`strcasecmp` is supported on Linux, FreeBSD, NetBSD, OpenBSD, DragonFlyBSD and Illumos (checked by finding the relevant docs on Google). `_stricmp` is supported on Windows. These are all of our supported platforms and then some. I would actually advocate that we remove `vim_stricmp()` from our codebase.If anyone bumps into the `#error`, we'll get an issue and we can either re-instate `vim_stricmp()` or find the case insensitive comparison function for that platform instead.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2574,29558979,2015-05-03T19:09:52Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.+bool striequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcasecmp(a, b) == 0;","@aktau the extra underscore is common practice in MSVC they mark the non underscore version as deprecated and throw a warning for the the original ones (even for [close, write, read](https://github.com/equalsraf/neovim/blob/tb-win32-any/src/nvim/os/win_defs.h#L55)) - more [here](http://stackoverflow.com/questions/23477746/what-are-the-posix-like-functions-in-msvcs-c-runtime) and a [full list](https://msdn.microsoft.com/en-us/library/ms235384.aspx).As you said _stricmp seems to be the only way for Windows, assuming the locale is set. There is also a _stricmp_l(str, str, locale_t) and _mbsicmp.Encoding correctness is trickier - most of the cases above compare strings from eval with string literals, the former use &encoding the later are compiler specific. Assuming everyone does the ""right thing TM"", I didnt expect this PR to tackle those - but maybe its time to add unittests for that.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2574,29560759,2015-05-03T21:59:36Z,src/nvim/strings.c,"@@ -45,6 +45,41 @@ #include ""nvim/os/os.h"" #include ""nvim/os/shell.h"" +/// Compares two strings for equality.+bool strequal(const char *a, const char *b)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strcmp(a, b) == 0;+}++/// Compares two sized strings for equality.+bool strnequal(const char *a, const char *b, size_t size)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE+{+  return strncmp(a, b, size) == 0;+}++/// Compares two strings for equality ignoring differences in case.","> $ man 3 strcasecmp actually says for me: ""compare two strings ignoring case"".I didn't mean to imply otherwise; it was a suggestion I thought up independently. Anyways, up to you as they're both clear.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2469,29561058,2015-05-03T22:33:55Z,src/nvim/tui/term_input.inl,"@@ -257,19 +258,17 @@ static TermInput *term_input_new(void)   rv->paste_enabled = false;   rv->in_fd = 0; -  // Set terminal encoding based on environment(taken from libtermkey source-  // code)-  const char *e;-  int flags = 0;-  if (((e = os_getenv(""LANG"")) || (e = os_getenv(""LC_MESSAGES""))-        || (e = os_getenv(""LC_ALL""))) && (e = strchr(e, '.')) && e++ &&-      (strcasecmp(e, ""UTF-8"") == 0 || strcasecmp(e, ""UTF8"") == 0)) {-    flags |= TERMKEY_FLAG_UTF8;+  // Set terminal encoding based on environment+  int enc_flag;+  char *enc = (char *)enc_locale();","`set_init_1()` checks this very early, and then tests `mb_init()` to see if the result is valid:https://github.com/neovim/neovim/blob/98b3dc0571603f07f3e81babe402bb0837fc619b/src/nvim/option.c#L1943If mb_init() fails, we default `p_enc` to utf-8. Is there any reason we wouldn't want to use `p_enc`? Is it conceivable that a user would `set encoding=...`, and yet want something _else_ for the terminal encoding?Actually, based on the docstring for `mb_init()` it looks like you may be able to just check the `enc_utf8` flag:```rv->tk = termkey_new_abstract(os_getenv(""TERM""),   enc_utf8 ? TERMKEY_FLAG_UTF8 : TERMKEY_FLAG_RAW);```I suppose this wouldn't work if the user did  `:let $LC_ALL=...` _after_ nvim started. Is that a valid use case?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2568,29604848,2015-05-04T17:39:10Z,src/nvim/eval.c,"@@ -12251,7 +12255,7 @@ static void f_reltime(typval_T *argvars, typval_T *rettv) FUNC_ATTR_NONNULL_ALL   // (varnumber_T is defined as int). For all our supported platforms, int's   // are at least 32-bits wide. So we'll use two 32-bit values to store it.   union {-    struct { varnumber_T low, high; } split;+    struct { uint32_t low, high; } split;     proftime_T prof;",Do we need to consider big endian platforms? Would the different handling of `low` and `high` still work?,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2578,29625087,2015-05-04T21:22:11Z,src/nvim/os/win_defs.h,"@@ -6,4 +6,51 @@ #define TEMP_DIR_NAMES {""$TMP"", ""$TEMP"", ""$USERPROFILE"", """"} #define TEMP_FILE_PATH_MAXLEN _MAX_PATH +#ifndef USR_EXRC_FILE+#  define USR_EXRC_FILE ""~/.exrc""+#endif++#ifndef USR_VIMRC_FILE+#  define USR_VIMRC_FILE ""~/.nvimrc""+#endif++#ifndef USR_VIMRC_FILE2+#  define USR_VIMRC_FILE2     ""~/.nvim/nvimrc""+#endif++#ifndef VIMINFO_FILE+#  define VIMINFO_FILE ""~/.nviminfo""+#endif++#ifndef EXRC_FILE+#  define EXRC_FILE      "".exrc""+#endif++#ifndef VIMRC_FILE+#  define VIMRC_FILE     "".nvimrc""+#endif++// default for 'backupdir'+#ifndef DFLT_BDIR+#  define DFLT_BDIR    "".,~/tmp,~/""+#endif++// default for 'directory'+#ifndef DFLT_DIR+#  define DFLT_DIR     "".,~/tmp,/var/tmp,/tmp""+#endif++// default for 'viewdir'+#ifndef DFLT_VDIR+#  define DFLT_VDIR    ""~/.nvim/view""+#endif++#ifdef RUNTIME_GLOBAL+#  define DFLT_RUNTIMEPATH  ""~/.nvim,"" RUNTIME_GLOBAL "",$VIMRUNTIME,"" \+                            RUNTIME_GLOBAL ""/after,~/.nvim/after""+#else+#  define DFLT_RUNTIMEPATH \+  ""~/.nvim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,~/.nvim/after""","``` C  ""~\\_nvim,$VIM\\vimfiles,$VIMRUNTIME,$VIM\\vimfiles\\after,~\\.nvim\\after""```but [os_dos.h](https://github.com/vim/vim/blob/7ef82ab257e6e94aa96acfd1c77eefe05109dbf8/src/os_dos.h#L124) uses a different value?",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2568,29638772,2015-05-05T01:14:10Z,src/nvim/eval.c,"@@ -12251,7 +12255,7 @@ static void f_reltime(typval_T *argvars, typval_T *rettv) FUNC_ATTR_NONNULL_ALL   // (varnumber_T is defined as int). For all our supported platforms, int's   // are at least 32-bits wide. So we'll use two 32-bit values to store it.   union {-    struct { varnumber_T low, high; } split;+    struct { uint32_t low, high; } split;     proftime_T prof;","Sort of... I think it'd end up swapping the high and low bits when adding them to the list and also check the high bits for overflow instead of the low. But it should convert to and fro `split` and `proftime_T` consistently.Right now, I'm not sure what big endian platform neovim could run on, or how best to test it.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2554,29816166,2015-05-07T00:32:02Z,src/nvim/ex_cmds.c,"@@ -4833,7 +4833,7 @@ int find_help_tags(char_u *arg, int *num_matches, char_u ***matches, int keep_la {   char_u      *s, *d;   int i;-  static char *(mtable[]) = {""*"", ""g*"", ""[*"", ""]*"", "":*"",+  static char *(mtable[]) = {""*"", ""g*"", ""[*"", ""]*"",                              ""/*"", ""/\\*"", ""\""*"", ""**"",                              ""cpo-*"", ""/\\(\\)"", ""/\\%(\\)"",","The `""cpo-*"",` field should be removed now that the help option is gone. The for loop that parses this below has a helpful comment:``` /*    * Recognize a few exceptions to the rule.   Some strings that contain '*'    * with ""star"".  Otherwise '*' is recognized as a wildcard.    */```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2578,29817405,2015-05-07T01:02:57Z,src/nvim/os/os_defs.h,"@@ -1,10 +1,145 @@ #ifndef NVIM_OS_OS_DEFS_H #define NVIM_OS_OS_DEFS_H +#include <ctype.h>+#include <stdio.h>+#include <stdlib.h>+#include <sys/stat.h>+#include <sys/types.h>+ #ifdef WIN32 # include ""nvim/os/win_defs.h"" #else # include ""nvim/os/unix_defs.h"" #endif +#ifdef SIGHAS3ARGS","@equalsraf these aren't defined anywhere and haven't been touched since the initial import. Do you know if they're needed on Windows? Same goes for `RETSIGTYPE` and `SIGDEFARG`, whose semantics are apparently specified in C89 and above.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2603,29876893,2015-05-07T17:47:37Z,src/nvim/msgpack_rpc/channel.c,"@@ -436,48 +454,107 @@ static void handle_request(Channel *channel, msgpack_object *request)    if (error.set) {     // Validation failed, send response with error-    if (channel_write(channel,-                      serialize_response(channel->id,-                                         request_id,-                                         &error,-                                         NIL,-                                         &out_buffer))) {-      char buf[256];-      snprintf(buf, sizeof(buf),-               ""Channel %"" PRIu64 "" sent an invalid message, closed."",-               channel->id);-      call_set_error(channel, buf);-    }+    request_set_error(&error, channel, request_id);     return;   } -  // Retrieve the request handler-  MsgpackRpcRequestHandler handler;   msgpack_object *method = msgpack_rpc_method(request);+  Array args = ARRAY_DICT_INIT;+  msgpack_rpc_to_array(msgpack_rpc_args(request), &args);++  char *meth_str = NULL; +  // Retrieve the request handler or intercept.+  bool intercepted = false;          // A provider owns this message.+  MsgpackRpcRequestHandler handler;  // Unused if intercepted.   if (method) {-    handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,-                                          method->via.bin.size);+    meth_str = xmemdupz(method->via.bin.ptr, method->via.bin.size);+    char func[256];+    snprintf(func, 256, ""provider#message#%s"", meth_str);+    if (eval_has_func(func)) {+      intercepted = true;+    } else {+      handler = msgpack_rpc_get_handler_for(method->via.bin.ptr,+                                            method->via.bin.size);+    }   } else {     handler.fn = msgpack_rpc_handle_missing_method;     handler.defer = false;   } -  Array args = ARRAY_DICT_INIT;-  msgpack_rpc_to_array(msgpack_rpc_args(request), &args);-  bool defer = (!kv_size(channel->call_stack) && handler.defer);+  // Always defer intercepted messages since they run vim script.+  bool defer = intercepted || (!kv_size(channel->call_stack) && handler.defer);   RequestEvent *event_data = xmalloc(sizeof(RequestEvent));   event_data->channel = channel;+  event_data->method = meth_str;   event_data->handler = handler;   event_data->args = args;   event_data->request_id = request_id;   incref(channel);   event_push((Event) {-    .handler = on_request_event,+    .handler = intercepted ? on_message_event : on_request_event,     .data = event_data   }, defer); } +static void on_message_event(Event event)","> Just for clarification, are you talking about the E###: part of emsgs?No, I meant the [MSGID](https://github.com/neovim/neovim/blob/master/src/nvim/po/de.po#L23) given to Gettext to look up the translation.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2495,29879958,2015-05-07T18:17:02Z,third-party/cmake/BuildJeMalloc.cmake,"@@ -1,3 +1,7 @@+if(WIN32)+  message(STATUS ""Building jemalloc in Windows is not supported (skipping)"")",I think you need an `else()` here with all the rest of the code (similarly in the other `skipping` files).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2608,29909858,2015-05-08T00:47:26Z,runtime/doc/todo.txt,"@@ -2786,9 +2473,6 @@ Most interesting new features to be added when all bugs have been fixed:     scrolls back to where the cursor is. -   Scroll commands by screen line. g CTRL-E and g CTRL-Y ?  Requires the     first line to be able to start halfway through.--   Running a shell command from the GUI still has limitations.  Look into how-    the terminal emulator of the Vim shell project can help:-    http://vimshell.wana.at","Hey, everyone: this was on Vim's todo list.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2609,29920191,2015-05-08T07:02:36Z,src/nvim/message.c,"@@ -2234,15 +2234,11 @@ void mch_errmsg(char *str) {   int len; -#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI)+#if defined(UNIX)   /* On Unix use stderr if it's a tty.    * When not going to start the GUI also use stderr.    * On Mac, when started from Finder, stderr is the console. */-  if (-# ifdef UNIX-    isatty(2)-# endif-    ) {+  if (isatty(2)) {","> without any other check ?What do you mean? I just mean replace the two instances of `isatty` in this PR with `os_isatty`, since they have the same semantics AFAICT:```/// Test whether a file descriptor refers to a terminal.////// @param fd File descriptor./// @return `true` if file descriptor refers to a terminal.bool os_isatty(int fd){    return uv_guess_handle(fd) == UV_TTY;}```",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2608,29972431,2015-05-08T20:11:25Z,runtime/doc/options.txt,"@@ -4320,20 +4319,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	reset this option. |-u| |--noplugin|  						*'macatsui'* *'nomacatsui'*-'macatsui'		boolean	(default on)-			global-			{only available in Mac GUI version}-	This is a workaround for when drawing doesn't work properly.  When set-	and compiled with multi-byte support ATSUI text drawing is used.  When-	not set ATSUI text drawing is not used.  Switch this option off when-	you experience drawing problems.  In a future version the problems may-	be solved and this option becomes obsolete.  Therefore use this method-	to unset it: >-		if exists('&macatsui')-		   set nomacatsui-		endif-<	Another option to check if you have drawing problems is-	'termencoding'.+'macatsui'		Removed. |vim-differences| {Nvim}","IIRC it's been done for at least a few months, even before `vim-diff.txt`, e.g., 2bf085049718a163ddc71b8c02989158ca595596 and 497a688ebc115c6535360f08464309ede9fba0cf.> Why would we want to keep a stub of this legacy option around?So users know that we haven't accidentally removed it (which we've done with some commands), and because a stub saying `Removed.` is arguably more helpful than `Sorry, no help  for salkdjsakldsa`. They take up very little room, so I'd rather we keep them for the practical benefit, at least for the time being.What do you think?",
2079042,Hettomei,https://api.github.com/repos/neovim/neovim/pulls/2609,29990297,2015-05-09T06:12:48Z,runtime/doc/debugger.txt,"@@ -119,7 +119,6 @@ The following compile time preprocessor variables control the features:     Debug Glyphs				FEAT_SIGNS     Debug Highlights				FEAT_SIGNS     Message Footer				FEAT_FOOTER-    Balloon Evaluation				FEAT_BEVAL","Ok, I let you do this. And don't credit me, I just revealed a probably dead doc.",
1327378,Yamakaky,https://api.github.com/repos/neovim/neovim/pulls/2578,29995011,2015-05-09T18:19:00Z,src/nvim/os/os_defs.h,"@@ -1,10 +1,139 @@ #ifndef NVIM_OS_OS_DEFS_H #define NVIM_OS_OS_DEFS_H +#include <ctype.h>+#include <stdio.h>+#include <stdlib.h>+#include <sys/stat.h>+#include <sys/types.h>+ #ifdef WIN32 # include ""nvim/os/win_defs.h"" #else # include ""nvim/os/unix_defs.h"" #endif +#ifdef HAVE_SYS_TIME_H+# include <sys/time.h>+#else+# include <time.h>+#endif++#if defined(DIRSIZ) && !defined(MAXNAMLEN)+# define MAXNAMLEN DIRSIZ+#endif++#if defined(NAME_MAX) && !defined(MAXNAMLEN)+# define MAXNAMLEN NAME_MAX+#endif++// Default value.+#ifndef MAXNAMLEN+# define MAXNAMLEN 512+#endif++#define BASENAMELEN (MAXNAMLEN - 5)++// Use the system path length if it makes sense.+#if defined(PATH_MAX) && (PATH_MAX > 1000)+# define MAXPATHL PATH_MAX+#else+# define MAXPATHL 1024+#endif++#ifndef SYS_VIMRC_FILE+# define SYS_VIMRC_FILE ""$VIM/nvimrc""+#endif++#ifndef DFLT_HELPFILE+# define DFLT_HELPFILE  ""$VIMRUNTIME/doc/help.txt""+#endif++#ifndef FILETYPE_FILE+# define FILETYPE_FILE  ""filetype.vim""+#endif++#ifndef FTPLUGIN_FILE+# define FTPLUGIN_FILE  ""ftplugin.vim""+#endif++#ifndef INDENT_FILE+# define INDENT_FILE    ""indent.vim""+#endif++#ifndef FTOFF_FILE+# define FTOFF_FILE     ""ftoff.vim""+#endif++#ifndef FTPLUGOF_FILE+# define FTPLUGOF_FILE  ""ftplugof.vim""+#endif++#ifndef INDOFF_FILE+# define INDOFF_FILE    ""indoff.vim""+#endif++#ifndef SYS_MENU_FILE+# define SYS_MENU_FILE  ""$VIMRUNTIME/menu.vim""+#endif++#ifndef EXRC_FILE+# define EXRC_FILE      "".exrc""+#endif++#ifndef VIMRC_FILE+# define VIMRC_FILE     "".nvimrc""+#endif++#ifndef SYNTAX_FNAME+# define SYNTAX_FNAME   ""$VIMRUNTIME/syntax/%s.vim""+#endif++#define DFLT_ERRORFILE          ""errors.err""++// Special wildcards that need to be handled by the shell.+#define SPECIAL_WILDCHAR ""`'{""++// Unix has plenty of memory, use large buffers.+// Size of the command processing buffer.+#define CMDBUFFSIZE 1024++// Use up to 5 Mbyte for a buffer.+#ifndef DFLT_MAXMEM+# define DFLT_MAXMEM (5*1024)+#endif+// use up to 10 Mbyte for Vim.+#ifndef DFLT_MAXMEMTOT+# define DFLT_MAXMEMTOT (10*1024)+#endif++#if !defined(S_ISDIR) && defined(S_IFDIR)+# define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)+#endif+#if !defined(S_ISREG) && defined(S_IFREG)+# define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)+#endif+#if !defined(S_ISBLK) && defined(S_IFBLK)+# define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)+#endif+#if !defined(S_ISSOCK) && defined(S_IFSOCK)+# define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)+#endif+#if !defined(S_ISFIFO) && defined(S_IFIFO)+# define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)+#endif+#if !defined(S_ISCHR) && defined(S_IFCHR)+# define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)+#endif++// Note: Some systems need both string.h and strings.h (Savage).  However,+// some systems can't handle both, only use string.h in that case.+#include <string.h>+#ifdef HAVE_STRINGS_H+# include <strings.h>+#endif++// For dup(3).+#define HAVE_DUP","This is apparently in Windows (https://msdn.microsoft.com/en-us/library/8syseb29.aspx), so it can probably be removed along with the checks for it in `fileio.c`. Can you confirm this for Windows @equalsraf, or does it not matter currently?",
1327378,Yamakaky,https://api.github.com/repos/neovim/neovim/pulls/2609,29995399,2015-05-09T19:04:34Z,runtime/doc/debugger.txt,"@@ -119,7 +119,6 @@ The following compile time preprocessor variables control the features:     Debug Glyphs				FEAT_SIGNS     Debug Highlights				FEAT_SIGNS     Message Footer				FEAT_FOOTER-    Balloon Evaluation				FEAT_BEVAL","> And don't credit me, I just revealed a probably dead doc.I just put `spotted by @Hettomei`, that's all :-)",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2605,29996081,2015-05-09T20:34:32Z,man/nvim.1,"@@ -0,0 +1,388 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be associated with a+terminal.+.It Fl t Ar tag+The file to edit and the initial cursor position depends on a+tag, a sort of goto label.+.Ar tag+is looked up in the tags file, the associated file becomes the current+file and the associated command is executed.+If+.Ar tag+is a function name, the file containing that function is opened+with the cursor positioned at the start of the function.+See+.Ic :help tag-commands .+.It Fl q Ar errorfile+QuickFix mode.+Display the first error in+.Ar errorfile .+If+.Ar errorfile+is omitted, the filename is obtained from the 'errorfile' option (defaults to+.Cm errors.err ) .+Further errors can be jumped to with the+.Ic :cnext+command.+See+.Ic :help quickfix .+.It There are a number of other options:+.It Fl -+Interpret all further arguments as files.+Can be used to edit files starting with a hyphen.+.It Fl -literal+Interpret filenames literally, that is do not expand wildcards.+Has no effect on UNIX-like systems, where the shell expands wildcards.+.It Fl e+Ex mode.+.It Fl E+Improved Ex mode.+.It Fl s+Silent mode.+Only takes effect if+.Fl e+is specified before+.Fl s .+.It Fl d Op Ar file ...+Diff mode.+Show the difference between two to four files.+If+.Ar file+is omitted, options related to diff mode are still set.+See+.Ic :help diff .+.It Fl R+Read-only mode.+Sets the option 'readonly'.+Implies+.Fl n .+Buffers can still be edited, but cannot be written to disk if already+associated with a file.+To overwrite a file, add an exclamation mark to the needed Ex command, such as+.Ic :w! .+See+.Ic :help 'readonly' .+.It Fl Z+Restricted mode.+Disable commands that make use of an external shell.+.It Fl m+Disable file modifications.+Unsets the option 'write'.+Writing to a file is disabled, but buffers can still be modified.+.It Fl M+Disable file and buffer modifications.+Unsets the options 'write' and 'modifiable'.+Note that these options can be set to re-enable making modifications.+.It Fl b+Binary mode.+See+.Ic :help edit-binary .+.It Fl l+Lisp mode.+Sets the options 'lisp' and 'showmatch'.+.It Fl A+Arabic mode.+Sets the option 'arabic'.+.It Fl F+Farsi mode.+Sets the options 'fkmap' and 'rightleft'.+.It Fl H+Hebrew mode.+Sets the options 'hkmap' and 'rightleft'.+.It Fl V Ns Oo Ar N Oc Ns Op Ar file+Verbose.+Print messages about which files are being sourced and for reading and+writing an nviminfo file.+.Ar N+is the value for the 'verbose' option; defaults to+.Cm 10+if omitted.+If+.Ar file+is specified, append messages to+.Ar file+instead of printing them.+.It Fl D+Debugging mode.+Started when executing the first command from a script.+.It Fl n+Disable the use of swap files.+Sets the option 'updatecount' to+.Cm 0 .+Can be useful for editing file(s) on a slow medium.+.It Fl r , L+List swap files with information about recovering them.+.It Fl r Ar file+Recovery mode.+The swap file+.Ar file+is used to recover a crashed session.+The swap file has the same filename as the text file, but with "".swp"" appended.+See+.Ic :help recovery .+.It Fl u Ar nvimrc+Use+.Ar nvimrc+instead of the default of+.Pa ~/.nvimrc .+If+.Ar nvimrc+is+.Cm NONE ,+do not read any initialization files or environment variables.+See+.Ic :help initialization .+.It Fl i Ar nviminfo+Use+.Ar nviminfo+instead of the default of+.Pa ~/.nviminfo .+If+.Ar nviminfo+is+.Cm NONE ,+do not read or write an nviminfo file.+See+.Ic :help viminfo .+.It Fl -noplugin+Skip loading plugins.+Implied by+.Cm -u NONE .+.It Fl o Ns Op Ar N+Open",Neither this nor the help say what happens when N is less than the number of file arguments given (it gives the first N files windows or tabpages and hides the rest). Just as a heads up.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2469,30000233,2015-05-10T09:13:19Z,src/nvim/option.c,"@@ -3738,6 +3738,10 @@ did_set_string_option (       if (varp == &p_enc && *curbuf->b_p_keymap != NUL)         (void)keymap_init(); +      if (varp == &p_enc) {+        ui_update_encoding();","Even if changing `&encoding` is weird, as long as it is allowed, it should not cause nvim to an inconsistent broken state where an arbitrary subset of utf-8 input is supported (������ but not ������ for instance),Given the direction we're heading, the other option would be to _force_ `encoding=utf-8` (or always use utf-8 internally no matter its value), and leave both the detection and handling of non-utf8 terminals completely to the `tui` module.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2555,30000331,2015-05-10T09:28:48Z,src/nvim/ops.c,"@@ -3460,12 +3460,10 @@ int do_join(long count,           endcurr1 = endcurr2;         else           ++spaces[t];-        /* extra space when 'joinspaces' set and line ends in '.' */-        if (       p_js-                   && (endcurr1 == '.'-                       || (vim_strchr(p_cpo, CPO_JOINSP) == NULL-                           && (endcurr1 == '?' || endcurr1 == '!'))))+        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'.+        if (p_js && (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {",The conditional expression is quite clear and the line fits in 80 columns. Is there a reason you'd prefer it split?,
1408847,jonthn,https://api.github.com/repos/neovim/neovim/pulls/2549,30001774,2015-05-10T12:49:17Z,runtime/autoload/provider/pythonx.vim,"@@ -13,19 +13,21 @@ function! provider#pythonx#Detect(ver) abort   let skip = exists(skip_var) ? {skip_var} : 0   if exists(host_var)     "" Disable auto detection-    let [check, err] = s:check_interpreter({host_var}, a:ver, skip)+    let [check, err, _] = s:check_interpreter({host_var}, a:ver, skip)     return check ? [{host_var}, err] : ['', err]   endif    let detect_versions = (a:ver == 2) ?-        \   ['2.7', '2.6', '2', '']-        \ : ['3.5', '3.4', '3.3', '3.2', '3', '']+        \   ['2', '2.7', '2.6', '']",@blueyed In my case as long as you test 2.6 and 2.7 before 'python' it would work (or in the worst case I can make it work without too much trouble and maintenance). Thanks for asking,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2578,30001876,2015-05-10T13:02:56Z,src/nvim/os/os_defs.h,"@@ -1,10 +1,139 @@ #ifndef NVIM_OS_OS_DEFS_H #define NVIM_OS_OS_DEFS_H +#include <ctype.h>+#include <stdio.h>+#include <stdlib.h>+#include <sys/stat.h>+#include <sys/types.h>+ #ifdef WIN32 # include ""nvim/os/win_defs.h"" #else # include ""nvim/os/unix_defs.h"" #endif +#ifdef HAVE_SYS_TIME_H+# include <sys/time.h>+#else+# include <time.h>+#endif++#if defined(DIRSIZ) && !defined(MAXNAMLEN)+# define MAXNAMLEN DIRSIZ+#endif++#if defined(NAME_MAX) && !defined(MAXNAMLEN)+# define MAXNAMLEN NAME_MAX+#endif++// Default value.+#ifndef MAXNAMLEN+# define MAXNAMLEN 512+#endif++#define BASENAMELEN (MAXNAMLEN - 5)++// Use the system path length if it makes sense.+#if defined(PATH_MAX) && (PATH_MAX > 1000)+# define MAXPATHL PATH_MAX+#else+# define MAXPATHL 1024+#endif++#ifndef SYS_VIMRC_FILE+# define SYS_VIMRC_FILE ""$VIM/nvimrc""+#endif++#ifndef DFLT_HELPFILE+# define DFLT_HELPFILE  ""$VIMRUNTIME/doc/help.txt""+#endif++#ifndef FILETYPE_FILE+# define FILETYPE_FILE  ""filetype.vim""+#endif++#ifndef FTPLUGIN_FILE+# define FTPLUGIN_FILE  ""ftplugin.vim""+#endif++#ifndef INDENT_FILE+# define INDENT_FILE    ""indent.vim""+#endif++#ifndef FTOFF_FILE+# define FTOFF_FILE     ""ftoff.vim""+#endif++#ifndef FTPLUGOF_FILE+# define FTPLUGOF_FILE  ""ftplugof.vim""+#endif++#ifndef INDOFF_FILE+# define INDOFF_FILE    ""indoff.vim""+#endif++#ifndef SYS_MENU_FILE+# define SYS_MENU_FILE  ""$VIMRUNTIME/menu.vim""+#endif++#ifndef EXRC_FILE+# define EXRC_FILE      "".exrc""+#endif++#ifndef VIMRC_FILE+# define VIMRC_FILE     "".nvimrc""+#endif++#ifndef SYNTAX_FNAME+# define SYNTAX_FNAME   ""$VIMRUNTIME/syntax/%s.vim""+#endif++#define DFLT_ERRORFILE          ""errors.err""++// Special wildcards that need to be handled by the shell.+#define SPECIAL_WILDCHAR ""`'{""++// Unix has plenty of memory, use large buffers.+// Size of the command processing buffer.+#define CMDBUFFSIZE 1024++// Use up to 5 Mbyte for a buffer.+#ifndef DFLT_MAXMEM+# define DFLT_MAXMEM (5*1024)+#endif+// use up to 10 Mbyte for Vim.+#ifndef DFLT_MAXMEMTOT+# define DFLT_MAXMEMTOT (10*1024)+#endif++#if !defined(S_ISDIR) && defined(S_IFDIR)+# define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)+#endif+#if !defined(S_ISREG) && defined(S_IFREG)+# define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)+#endif+#if !defined(S_ISBLK) && defined(S_IFBLK)+# define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)+#endif+#if !defined(S_ISSOCK) && defined(S_IFSOCK)+# define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)+#endif+#if !defined(S_ISFIFO) && defined(S_IFIFO)+# define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)+#endif+#if !defined(S_ISCHR) && defined(S_IFCHR)+# define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)+#endif++// Note: Some systems need both string.h and strings.h (Savage).  However,+// some systems can't handle both, only use string.h in that case.+#include <string.h>+#ifdef HAVE_STRINGS_H+# include <strings.h>+#endif++// For dup(3).+#define HAVE_DUP","_dup is in Windows, but we still have to figure out how to handle the dup, _dup naming in Windows, might as well leave that for a different PR.",
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/2469,30005462,2015-05-10T20:07:27Z,src/nvim/option.c,"@@ -3738,6 +3738,10 @@ did_set_string_option (       if (varp == &p_enc && *curbuf->b_p_keymap != NUL)         (void)keymap_init(); +      if (varp == &p_enc) {+        ui_update_encoding();","Drat, brainfart ��� @justinmk is right, I confused `encoding` and `fileencoding`. Too much Ruby lately :). Disregard my above comment, please!",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2609,30005838,2015-05-10T20:43:41Z,src/nvim/menu.c,"@@ -1360,61 +1329,6 @@ void ex_emenu(exarg_T *eap)     EMSG2(_(""E335: Menu not defined for %s mode""), mode); } -#if defined(FEAT_GUI_MSWIN) \-  || defined(FEAT_GUI_GTK) \-  || defined(FEAT_BEVAL_TIP)-/*- * Given a menu descriptor, e.g. ""File.New"", find it in the menu hierarchy.- */-vimmenu_T *gui_find_menu(char_u *path_name)-{-  vimmenu_T   *menu = NULL;-  char_u      *name;-  char_u      *saved_name;-  char_u      *p;--  menu = root_menu;--  saved_name = vim_strsave(path_name);--  name = saved_name;-  while (*name) {-    /* find the end of one dot-separated name and put a NUL at the dot */-    p = menu_name_skip(name);--    while (menu != NULL) {-      if (menu_name_equal(name, menu)) {-        if (menu->children == NULL) {-          /* found a menu item instead of a sub-menu */-          if (*p == NUL)-            EMSG(_(""E336: Menu path must lead to a sub-menu""));","Yup, translations shouldn't be deleted from the PO files, even if they're unused. They might be useful for fuzzy translations.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2609,30005920,2015-05-10T20:48:35Z,src/nvim/menu.c,"@@ -1360,61 +1329,6 @@ void ex_emenu(exarg_T *eap)     EMSG2(_(""E335: Menu not defined for %s mode""), mode); } -#if defined(FEAT_GUI_MSWIN) \-  || defined(FEAT_GUI_GTK) \-  || defined(FEAT_BEVAL_TIP)-/*- * Given a menu descriptor, e.g. ""File.New"", find it in the menu hierarchy.- */-vimmenu_T *gui_find_menu(char_u *path_name)-{-  vimmenu_T   *menu = NULL;-  char_u      *name;-  char_u      *saved_name;-  char_u      *p;--  menu = root_menu;--  saved_name = vim_strsave(path_name);--  name = saved_name;-  while (*name) {-    /* find the end of one dot-separated name and put a NUL at the dot */-    p = menu_name_skip(name);--    while (menu != NULL) {-      if (menu_name_equal(name, menu)) {-        if (menu->children == NULL) {-          /* found a menu item instead of a sub-menu */-          if (*p == NUL)-            EMSG(_(""E336: Menu path must lead to a sub-menu""));","Fuzzy translations (as opposed to ""manual"" translations done by a human) are automatic translations where an existing translation is used for a similar, but different message. Obviously it won't be an exact translation, hence ""fuzzy"".",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2609,30006476,2015-05-10T21:49:06Z,src/nvim/vim.h,"@@ -338,14 +338,9 @@ enum {  * functions of these names. The declarations would break if the defines had  * been seen at that stage.  But it must be before globals.h, where error_ga  * is declared. */-#if !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_X11) \-  && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC) # define mch_errmsg(str)        fprintf(stderr, ""%s"", (str)) # define display_errors()       fflush(stderr) # define mch_msg(str)           printf(""%s"", (str))",You could consider removing the space before `define` now that it's not nested any longer: `#define` ...,
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2609,30006513,2015-05-10T21:54:06Z,src/nvim/vim.h,"@@ -338,14 +338,9 @@ enum {  * functions of these names. The declarations would break if the defines had  * been seen at that stage.  But it must be before globals.h, where error_ga  * is declared. */-#if !defined(FEAT_GUI_W32) && !defined(FEAT_GUI_X11) \-  && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_MAC) # define mch_errmsg(str)        fprintf(stderr, ""%s"", (str)) # define display_errors()       fflush(stderr) # define mch_msg(str)           printf(""%s"", (str))-#else-# define USE_MCH_ERRMSG","Just in case you hadn't noticed: `USE_MCH_ERRMSG` is now no longer defined in in the source code -- only in `scripts/stripdecls.py`. I suppose that's correct, right?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30012820,2015-05-11T04:40:55Z,src/nvim/main.c,"@@ -905,12 +905,7 @@ static void command_line_scan(mparm_T *parmp)           if (STRICMP(argv[0] + argv_idx, ""help"") == 0)             usage();           else if (STRICMP(argv[0] + argv_idx, ""version"") == 0) {-            Columns = 80;                 /* need to init Columns */-            info_message = TRUE;           /* use mch_msg(), not mch_errmsg() */-            list_version();-            msg_putchar('\n');-            msg_didout = FALSE;-            mch_exit(0);+            version();","It would be better to leave the explicit mch_exit(0) in both cases, instead of hiding it in version() and having to explain what's going on.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30015212,2015-05-11T06:26:06Z,runtime/doc/Makefile,"@@ -51,12 +30,6 @@ tags: doctags $(DOCS) doctags: doctags.c 	$(CC) doctags.c -o doctags -manpages: $(MANPAGES)--# OSX groff doesn't support utf-8 as input encoding, so this won't work there.-.1.man:-	groff -k -mandoc -Tutf8 $< | sed -e s/.^H//g > $@","[After seeing this](https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/groff.1.html) I wasn't sure that it's actually true. Assuming a moderately recent (last decade) version of groff, man pages written in mdoc don't need any pre-processing; you just type `man my-program` and your man page is formatted on the fly, then displayed.Could you test how `nvim.1` and `nvimtutor.1` look on OS X? You should be able to view them using `man -l`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30016169,2015-05-11T06:57:14Z,runtime/doc/Makefile,"@@ -51,12 +30,6 @@ tags: doctags $(DOCS) doctags: doctags.c 	$(CC) doctags.c -o doctags -manpages: $(MANPAGES)--# OSX groff doesn't support utf-8 as input encoding, so this won't work there.-.1.man:-	groff -k -mandoc -Tutf8 $< | sed -e s/.^H//g > $@","It looks fantastic actually.On Mac (BSD I guess), there's no `man -l`, but a slash in the path works similarly: `man ./nvim.1`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30016459,2015-05-11T07:04:47Z,man/nvim.1,"@@ -0,0 +1,417 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be associated with a+terminal.","I also think it's a hyper-correction to change this from the original wording, > Commands are read from stderr, which should be a tty.The new form is totally meaningless to me. I don't know what ""associated with a terminal"" means, but I immediately understand ""should be a tty"". TTY is technical jargon with a specific meaning that is understood in context. No one in the context of a manpage mistakes it for physical teletypes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30017408,2015-05-11T07:29:17Z,man/nvim.1,"@@ -0,0 +1,417 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be associated with a+terminal.","I don't get the insistence on TTY being a misnomer. Literally _everything_ in computing is an analogy of some physical concept. TTY is a technical term with a long history in unix, as is ""socket"", ""port"", ""core dump"", ""page"", ...It makes no sense to try to make it friendly, it won't help any user (who probably also doesn't know the difference between a terminal and a shell--not to mention a pseudo-terminal...).> Someone might see ""should be a terminal"" and say ""oh, well I'm running a terminal so I'm fine"".So they would then know how to send commands to `stderr`? That's quite optimistic :)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30017933,2015-05-11T07:41:30Z,man/nvim.1,"@@ -0,0 +1,417 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be associated with a+terminal.+.It Fl t Ar tag+The file to edit and the initial cursor position depends on a+tag, a sort of goto label.+.Ar tag+is looked up in the tags file, the associated file becomes the current+file and the associated command is executed.+If+.Ar tag+is a function name, the file containing that function is opened+with the cursor positioned at the start of the function.+See+.Ic :help tag-commands .+.It Fl q Ar errorfile+QuickFix mode.+Display the first error in+.Ar errorfile .+If+.Ar errorfile+is omitted, the value of the 'errorfile' option is used (defaults to+.Cm errors.err ) .+Further errors can be jumped to with the+.Ic :cnext+command.+See+.Ic :help quickfix .+.It There are a number of other options:","I didn't do that because the above `-t` and `-q` are also options. Given that the DESCRIPTION has shrunk substantially, I just merged the two sections.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30020238,2015-05-11T08:24:21Z,man/nvim.1,"@@ -0,0 +1,417 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be associated with a+terminal.","> I don't get the insistence on TTY being a misnomer. Literally everything in computing is an analogy of some physical concept. TTY is a technical term with a long history in unix, as is ""socket"", ""port"", ""core dump"", ""page""I hadn't thought about that, although It's still a misnomer in that it's usually not used in the context of Teleprinters, where ""terminal"" makes more sense here because like a physical terminal, it's just a front-end to a system (like an interactive shell is to a login shell). It doesn't really matter much.> It makes no sense to try to make it friendly, it won't help any user (who probably also doesn't know the difference between a terminal and a shell--not to mention a pseudo-terminal...).I suppose I wasn't clear, but I'm more concerned about it being correct than friendly (not that they're mutually exclusive). And since ""correct"" isn't so easily defined in this context, I mean following the de facto standards regarding man pages.The main point I'm making is that `tty` is to `terminal` as `stdXXX` is to `standard XXX`, at least from what I've gathered from various man pages and technical documentation. `tty` looks to be used almost exclusively in a non-general way, things like function names or `/dev` paths, which is no surprise given how UNIX influenced POSIX. However, even POSIX's [`man isatty`](http://pubs.opengroup.org/onlinepubs/009695399/functions/isatty.html) (among many others) uses the term ""terminals"", as there's no need to continue to continue using a misnomer for the sake of matching the interface name (or something else). Most man pages I've read agree as well.",
2482259,yagebu,https://api.github.com/repos/neovim/neovim/pulls/2605,30023009,2015-05-11T09:11:41Z,man/nvim.1,"@@ -0,0 +1,411 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be a terminal.+.It Fl t Ar tag+The file to edit and the initial cursor position depends on a+tag, a sort of goto label.+.Ar tag+is looked up in the tags file, the associated file becomes the current+file and the associated command is executed.+If+.Ar tag+is a function name, the file containing that function is opened+with the cursor positioned at the start of the function.+See+.Ic :help tag-commands .+.It Fl q Ar errorfile+QuickFix mode.+Display the first error in+.Ar errorfile .+If+.Ar errorfile+is omitted, the value of the 'errorfile' option is used (defaults to+.Cm errors.err ) .+Further errors can be jumped to with the+.Ic :cnext+command.+See+.Ic :help quickfix .+.It There are a number of other options:+.It Fl -+Interpret all further arguments as files.+Can be used to edit files starting with a hyphen.+.It Fl -literal+Interpret filenames literally, that is do not expand wildcards.+Has no effect on UNIX-like systems, where the shell expands wildcards.+.It Fl e+Ex mode.+See+.Ic :help Ex-mode .+.It Fl E+Improved Ex mode.+See+.Ic :help gQ .+.It Fl s+Silent mode.+Only takes effect if+.Fl e+or+.Fl E+is specified before+.Fl s .+.It Fl d Op Ar file ...+Diff mode.+Show the difference between two to four files.+If+.Ar file+is omitted, options related to diff mode are still set.+See+.Ic :help diff .+.It Fl R+Read-only mode.+Sets the option 'readonly'.+Implies+.Fl n .+Buffers can still be edited, but cannot be written to disk if already+associated with a file.+To overwrite a file, add an exclamation mark to the needed Ex command, such as+.Ic :w! .+See+.Ic :help 'readonly' .+.It Fl Z+Restricted mode.+Disable commands that make use of an external shell.+.It Fl m+Disable file modifications.+Unsets the option 'write'.+Writing to a file is disabled, but buffers can still be modified.+.It Fl M+Disable file and buffer modifications.+Unsets the options 'write' and 'modifiable'.+Note that these options can be set to re-enable making modifications.+.It Fl b+Binary mode.+See+.Ic :help edit-binary .+.It Fl l+Lisp mode.+Sets the options 'lisp' and 'showmatch'.+.It Fl A+Arabic mode.+Sets the option 'arabic'.+.It Fl F+Farsi mode.+Sets the options 'fkmap' and 'rightleft'.+.It Fl H+Hebrew mode.+Sets the options 'hkmap' and 'rightleft'.+.It Fl V Ns Oo Ar N Oc Ns Op Ar file+Verbose.+Print messages about which files are being sourced and for reading and+writing an nviminfo file.+.Ar N+is the value for the 'verbose' option; defaults to+.Cm 10+if omitted.+If+.Ar file+is specified, append messages to+.Ar file+instead of printing them.+.It Fl D+Debugging mode.+Started when executing the first command from a script.+.It Fl n+Disable the use of swap files.+Sets the option 'updatecount' to+.Cm 0 .+Can be useful for editing file(s) on a slow medium.+.It Fl r , L+List swap files with information about recovering them.+.It Fl r Ar file+Recovery mode.+The swap file+.Ar file+is used to recover a crashed session.+The swap file has the same filename as the text file, but with "".swp"" appended.+See+.Ic :help recovery .+.It Fl u Ar nvimrc+Use+.Ar nvimrc+instead of the default of+.Pa ~/.nvimrc .+If+.Ar nvimrc+is+.Cm NORC ,+do not load any initialization files (excluding plugins),+and do not attempt to parse environment variables.+If+.Ar nvimrc+is+.Cm NONE ,+loading plugins is also skipped.+See+.Ic :help initialization .+.It Fl i Ar nviminfo+Use+.Ar nviminfo+instead of the default of+.Pa ~/.nviminfo .+If+.Ar nviminfo+is+.Cm NONE ,+do not read or write an nviminfo file.+See+.Ic :help viminfo .+.It Fl -noplugin+Skip loading plugins.+Implied by+.Cm -u NONE .+.It Fl o Ns Op Ar N+Open+.Ar N+windows stacked horizontally.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl O Ns Op Ar N+Open+.Ar N+windows stacked vertically.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl p Ns Op Ar N+Open+.Ar N+tab pages.+If+.Ar N+is omitted, open one tab page for each file.+If+.Ar N+is less than the number of file arguments, allocate tab pages for the first+.Ar N+files and hide the rest.+.It Cm + Ns Op Ar linenum+For the first file, position the cursor on line+.Ar linenum .+If+.Ar linenum+is omitted, position the cursor on the last line of the file.+Note that+.Cm +5+and+.Cm -c 5+on the command-line are equivalent to+.Ic :5+inside+.Nm .+.It Cm +/ Ns Op Ar pattern+For the first file, position the cursor on the first occurrence of+.Ar pattern .+If+.Ar pattern+is omitted, the most recently used search pattern is used (if there is one).+Note that+.Cm /foo+and+.Cm -c /foo+on the command-line are equivalent to+.Ic /foo+and+.Ic :/foo+inside+.Nm .+See+.Ic :help search-pattern .+.It Fl -cmd Ar command+Execute+.Ar command+before processing any nvimrc.+Up to 10 instances of these can be used, independently from instances of+.Fl c .+.It Fl c Ar command+Execute","It should be explained that `+command` works the same way as `-c command`, so maybe add `+command` in the left column. From the lines above it might seem that the '+' only works with linenumbers and search patterns",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2605,30083112,2015-05-11T21:16:58Z,man/nvim.1,"@@ -0,0 +1,411 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be a terminal.+.It Fl t Ar tag+The file to edit and the initial cursor position depends on a+tag, a sort of goto label.+.Ar tag+is looked up in the tags file, the associated file becomes the current+file and the associated command is executed.+If+.Ar tag+is a function name, the file containing that function is opened+with the cursor positioned at the start of the function.+See+.Ic :help tag-commands .+.It Fl q Ar errorfile+QuickFix mode.+Display the first error in+.Ar errorfile .+If+.Ar errorfile+is omitted, the value of the 'errorfile' option is used (defaults to+.Cm errors.err ) .+Further errors can be jumped to with the+.Ic :cnext+command.+See+.Ic :help quickfix .+.It There are a number of other options:+.It Fl -+Interpret all further arguments as files.+Can be used to edit files starting with a hyphen.+.It Fl -literal+Interpret filenames literally, that is do not expand wildcards.+Has no effect on UNIX-like systems, where the shell expands wildcards.+.It Fl e+Ex mode.+See+.Ic :help Ex-mode .+.It Fl E+Improved Ex mode.+See+.Ic :help gQ .+.It Fl s+Silent mode.+Only takes effect if+.Fl e+or+.Fl E+is specified before+.Fl s .+.It Fl d Op Ar file ...+Diff mode.+Show the difference between two to four files.+If+.Ar file+is omitted, options related to diff mode are still set.+See+.Ic :help diff .+.It Fl R+Read-only mode.+Sets the option 'readonly'.+Implies+.Fl n .+Buffers can still be edited, but cannot be written to disk if already+associated with a file.+To overwrite a file, add an exclamation mark to the needed Ex command, such as+.Ic :w! .+See+.Ic :help 'readonly' .+.It Fl Z+Restricted mode.+Disable commands that make use of an external shell.+.It Fl m+Disable file modifications.+Unsets the option 'write'.+Writing to a file is disabled, but buffers can still be modified.+.It Fl M+Disable file and buffer modifications.+Unsets the options 'write' and 'modifiable'.+Note that these options can be set to re-enable making modifications.+.It Fl b+Binary mode.+See+.Ic :help edit-binary .+.It Fl l+Lisp mode.+Sets the options 'lisp' and 'showmatch'.+.It Fl A+Arabic mode.+Sets the option 'arabic'.+.It Fl F+Farsi mode.+Sets the options 'fkmap' and 'rightleft'.+.It Fl H+Hebrew mode.+Sets the options 'hkmap' and 'rightleft'.+.It Fl V Ns Oo Ar N Oc Ns Op Ar file+Verbose.+Print messages about which files are being sourced and for reading and+writing an nviminfo file.+.Ar N+is the value for the 'verbose' option; defaults to+.Cm 10+if omitted.+If+.Ar file+is specified, append messages to+.Ar file+instead of printing them.+.It Fl D+Debugging mode.+Started when executing the first command from a script.+.It Fl n+Disable the use of swap files.+Sets the option 'updatecount' to+.Cm 0 .+Can be useful for editing file(s) on a slow medium.+.It Fl r , L+List swap files with information about recovering them.+.It Fl r Ar file+Recovery mode.+The swap file+.Ar file+is used to recover a crashed session.+The swap file has the same filename as the text file, but with "".swp"" appended.+See+.Ic :help recovery .+.It Fl u Ar nvimrc+Use+.Ar nvimrc+instead of the default of+.Pa ~/.nvimrc .+If+.Ar nvimrc+is+.Cm NORC ,+do not load any initialization files (excluding plugins),+and do not attempt to parse environment variables.+If+.Ar nvimrc+is+.Cm NONE ,+loading plugins is also skipped.+See+.Ic :help initialization .+.It Fl i Ar nviminfo+Use+.Ar nviminfo+instead of the default of+.Pa ~/.nviminfo .+If+.Ar nviminfo+is+.Cm NONE ,+do not read or write an nviminfo file.+See+.Ic :help viminfo .+.It Fl -noplugin+Skip loading plugins.+Implied by+.Cm -u NONE .+.It Fl o Ns Op Ar N+Open+.Ar N+windows stacked horizontally.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl O Ns Op Ar N+Open+.Ar N+windows stacked vertically.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl p Ns Op Ar N+Open+.Ar N+tab pages.+If+.Ar N+is omitted, open one tab page for each file.+If+.Ar N+is less than the number of file arguments, allocate tab pages for the first+.Ar N+files and hide the rest.+.It Cm + Ns Op Ar linenum+For the first file, position the cursor on line+.Ar linenum .+If+.Ar linenum+is omitted, position the cursor on the last line of the file.+Note that+.Cm +5+and+.Cm -c 5+on the command-line are equivalent to+.Ic :5+inside+.Nm .+.It Cm +/ Ns Op Ar pattern+For the first file, position the cursor on the first occurrence of+.Ar pattern .+If+.Ar pattern+is omitted, the most recently used search pattern is used (if there is one).+Note that+.Cm /foo+and+.Cm -c /foo+on the command-line are equivalent to+.Ic /foo+and+.Ic :/foo+inside+.Nm .+See+.Ic :help search-pattern .+.It Fl -cmd Ar command+Execute+.Ar command+before processing any nvimrc.+Up to 10 instances of these can be used, independently from instances of+.Fl c .+.It Fl c Ar command+Execute","Huh, good point. I really don't like how similar all these commands are...",
2482259,yagebu,https://api.github.com/repos/neovim/neovim/pulls/2605,30089948,2015-05-11T22:42:31Z,man/nvim.1,"@@ -0,0 +1,411 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be a terminal.+.It Fl t Ar tag+The file to edit and the initial cursor position depends on a+tag, a sort of goto label.+.Ar tag+is looked up in the tags file, the associated file becomes the current+file and the associated command is executed.+If+.Ar tag+is a function name, the file containing that function is opened+with the cursor positioned at the start of the function.+See+.Ic :help tag-commands .+.It Fl q Ar errorfile+QuickFix mode.+Display the first error in+.Ar errorfile .+If+.Ar errorfile+is omitted, the value of the 'errorfile' option is used (defaults to+.Cm errors.err ) .+Further errors can be jumped to with the+.Ic :cnext+command.+See+.Ic :help quickfix .+.It There are a number of other options:+.It Fl -+Interpret all further arguments as files.+Can be used to edit files starting with a hyphen.+.It Fl -literal+Interpret filenames literally, that is do not expand wildcards.+Has no effect on UNIX-like systems, where the shell expands wildcards.+.It Fl e+Ex mode.+See+.Ic :help Ex-mode .+.It Fl E+Improved Ex mode.+See+.Ic :help gQ .+.It Fl s+Silent mode.+Only takes effect if+.Fl e+or+.Fl E+is specified before+.Fl s .+.It Fl d Op Ar file ...+Diff mode.+Show the difference between two to four files.+If+.Ar file+is omitted, options related to diff mode are still set.+See+.Ic :help diff .+.It Fl R+Read-only mode.+Sets the option 'readonly'.+Implies+.Fl n .+Buffers can still be edited, but cannot be written to disk if already+associated with a file.+To overwrite a file, add an exclamation mark to the needed Ex command, such as+.Ic :w! .+See+.Ic :help 'readonly' .+.It Fl Z+Restricted mode.+Disable commands that make use of an external shell.+.It Fl m+Disable file modifications.+Unsets the option 'write'.+Writing to a file is disabled, but buffers can still be modified.+.It Fl M+Disable file and buffer modifications.+Unsets the options 'write' and 'modifiable'.+Note that these options can be set to re-enable making modifications.+.It Fl b+Binary mode.+See+.Ic :help edit-binary .+.It Fl l+Lisp mode.+Sets the options 'lisp' and 'showmatch'.+.It Fl A+Arabic mode.+Sets the option 'arabic'.+.It Fl F+Farsi mode.+Sets the options 'fkmap' and 'rightleft'.+.It Fl H+Hebrew mode.+Sets the options 'hkmap' and 'rightleft'.+.It Fl V Ns Oo Ar N Oc Ns Op Ar file+Verbose.+Print messages about which files are being sourced and for reading and+writing an nviminfo file.+.Ar N+is the value for the 'verbose' option; defaults to+.Cm 10+if omitted.+If+.Ar file+is specified, append messages to+.Ar file+instead of printing them.+.It Fl D+Debugging mode.+Started when executing the first command from a script.+.It Fl n+Disable the use of swap files.+Sets the option 'updatecount' to+.Cm 0 .+Can be useful for editing file(s) on a slow medium.+.It Fl r , L+List swap files with information about recovering them.+.It Fl r Ar file+Recovery mode.+The swap file+.Ar file+is used to recover a crashed session.+The swap file has the same filename as the text file, but with "".swp"" appended.+See+.Ic :help recovery .+.It Fl u Ar nvimrc+Use+.Ar nvimrc+instead of the default of+.Pa ~/.nvimrc .+If+.Ar nvimrc+is+.Cm NORC ,+do not load any initialization files (excluding plugins),+and do not attempt to parse environment variables.+If+.Ar nvimrc+is+.Cm NONE ,+loading plugins is also skipped.+See+.Ic :help initialization .+.It Fl i Ar nviminfo+Use+.Ar nviminfo+instead of the default of+.Pa ~/.nviminfo .+If+.Ar nviminfo+is+.Cm NONE ,+do not read or write an nviminfo file.+See+.Ic :help viminfo .+.It Fl -noplugin+Skip loading plugins.+Implied by+.Cm -u NONE .+.It Fl o Ns Op Ar N+Open+.Ar N+windows stacked horizontally.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl O Ns Op Ar N+Open+.Ar N+windows stacked vertically.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl p Ns Op Ar N+Open+.Ar N+tab pages.+If+.Ar N+is omitted, open one tab page for each file.+If+.Ar N+is less than the number of file arguments, allocate tab pages for the first+.Ar N+files and hide the rest.+.It Cm + Ns Op Ar linenum+For the first file, position the cursor on line+.Ar linenum .+If+.Ar linenum+is omitted, position the cursor on the last line of the file.+Note that+.Cm +5+and+.Cm -c 5+on the command-line are equivalent to+.Ic :5+inside+.Nm .+.It Cm +/ Ns Op Ar pattern+For the first file, position the cursor on the first occurrence of+.Ar pattern .+If+.Ar pattern+is omitted, the most recently used search pattern is used (if there is one).+Note that+.Cm /foo+and+.Cm -c /foo+on the command-line are equivalent to+.Ic /foo+and+.Ic :/foo+inside+.Nm .+See+.Ic :help search-pattern .+.It Fl -cmd Ar command+Execute+.Ar command+before processing any nvimrc.+Up to 10 instances of these can be used, independently from instances of+.Fl c .+.It Fl c Ar command+Execute","> it's already like that in the existing documentationNo ;) Actually `+command` is even listed first and it's also explained how you can use it with commands that include spaces (the '+' has to be between the quotes too):```+{command}.TP\-c {command}{command} will be executed after thefirst file has been read.{command} is interpreted as an Ex command.If the {command} contains spaces it must be enclosed in double quotes (thisdepends on the shell that is used).Example: Vim ""+set si"" main.c```I definitely agree that it's not ideal to have all these very similar options, but as `+command` is the most general one and `+num` and `+/pat` are just special cases of it, I really think we should keep it.",
2482259,yagebu,https://api.github.com/repos/neovim/neovim/pulls/2605,30090419,2015-05-11T22:49:39Z,man/nvim.1,"@@ -0,0 +1,411 @@+.Dd May 7, 2015+.Dt NVIM 1+.Os Neovim+.Sh NAME+.Nm nvim+.Nd edit text+.Sh SYNOPSIS+.Nm+.Op Ar options+.Op Ar file ...+.Nm+.Op Ar options+.Fl+.Nm+.Op Ar options+.Fl t Ar tag+.Nm+.Op Ar options+.Fl q Ar errorfile+.Sh DESCRIPTION+.Nm+is a text editor based on+.Xr vim 1 .+To enter commands in+.Nm ,+type a colon+.Qq ( Cm \&: ) ,+which is also used in this manual to denote commands.+For more information, consult the on-line help system with the+.Ic :help+command.+.Bl -tag -width Fl+.It Ar file ...+File(s) to edit.+If none are specified, open an empty buffer.+If multiple files are specified, open one buffer for each file.+To switch between buffers, use the+.Ic :next+and+.Ic :previous+commands.+.It Fl+Read text from standard input until EOF, then open a buffer with that text.+Commands are read from standard error, which should be a terminal.+.It Fl t Ar tag+The file to edit and the initial cursor position depends on a+tag, a sort of goto label.+.Ar tag+is looked up in the tags file, the associated file becomes the current+file and the associated command is executed.+If+.Ar tag+is a function name, the file containing that function is opened+with the cursor positioned at the start of the function.+See+.Ic :help tag-commands .+.It Fl q Ar errorfile+QuickFix mode.+Display the first error in+.Ar errorfile .+If+.Ar errorfile+is omitted, the value of the 'errorfile' option is used (defaults to+.Cm errors.err ) .+Further errors can be jumped to with the+.Ic :cnext+command.+See+.Ic :help quickfix .+.It There are a number of other options:+.It Fl -+Interpret all further arguments as files.+Can be used to edit files starting with a hyphen.+.It Fl -literal+Interpret filenames literally, that is do not expand wildcards.+Has no effect on UNIX-like systems, where the shell expands wildcards.+.It Fl e+Ex mode.+See+.Ic :help Ex-mode .+.It Fl E+Improved Ex mode.+See+.Ic :help gQ .+.It Fl s+Silent mode.+Only takes effect if+.Fl e+or+.Fl E+is specified before+.Fl s .+.It Fl d Op Ar file ...+Diff mode.+Show the difference between two to four files.+If+.Ar file+is omitted, options related to diff mode are still set.+See+.Ic :help diff .+.It Fl R+Read-only mode.+Sets the option 'readonly'.+Implies+.Fl n .+Buffers can still be edited, but cannot be written to disk if already+associated with a file.+To overwrite a file, add an exclamation mark to the needed Ex command, such as+.Ic :w! .+See+.Ic :help 'readonly' .+.It Fl Z+Restricted mode.+Disable commands that make use of an external shell.+.It Fl m+Disable file modifications.+Unsets the option 'write'.+Writing to a file is disabled, but buffers can still be modified.+.It Fl M+Disable file and buffer modifications.+Unsets the options 'write' and 'modifiable'.+Note that these options can be set to re-enable making modifications.+.It Fl b+Binary mode.+See+.Ic :help edit-binary .+.It Fl l+Lisp mode.+Sets the options 'lisp' and 'showmatch'.+.It Fl A+Arabic mode.+Sets the option 'arabic'.+.It Fl F+Farsi mode.+Sets the options 'fkmap' and 'rightleft'.+.It Fl H+Hebrew mode.+Sets the options 'hkmap' and 'rightleft'.+.It Fl V Ns Oo Ar N Oc Ns Op Ar file+Verbose.+Print messages about which files are being sourced and for reading and+writing an nviminfo file.+.Ar N+is the value for the 'verbose' option; defaults to+.Cm 10+if omitted.+If+.Ar file+is specified, append messages to+.Ar file+instead of printing them.+.It Fl D+Debugging mode.+Started when executing the first command from a script.+.It Fl n+Disable the use of swap files.+Sets the option 'updatecount' to+.Cm 0 .+Can be useful for editing file(s) on a slow medium.+.It Fl r , L+List swap files with information about recovering them.+.It Fl r Ar file+Recovery mode.+The swap file+.Ar file+is used to recover a crashed session.+The swap file has the same filename as the text file, but with "".swp"" appended.+See+.Ic :help recovery .+.It Fl u Ar nvimrc+Use+.Ar nvimrc+instead of the default of+.Pa ~/.nvimrc .+If+.Ar nvimrc+is+.Cm NORC ,+do not load any initialization files (excluding plugins),+and do not attempt to parse environment variables.+If+.Ar nvimrc+is+.Cm NONE ,+loading plugins is also skipped.+See+.Ic :help initialization .+.It Fl i Ar nviminfo+Use+.Ar nviminfo+instead of the default of+.Pa ~/.nviminfo .+If+.Ar nviminfo+is+.Cm NONE ,+do not read or write an nviminfo file.+See+.Ic :help viminfo .+.It Fl -noplugin+Skip loading plugins.+Implied by+.Cm -u NONE .+.It Fl o Ns Op Ar N+Open+.Ar N+windows stacked horizontally.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl O Ns Op Ar N+Open+.Ar N+windows stacked vertically.+If+.Ar N+is omitted, open one window for each file.+If+.Ar N+is less than the number of file arguments, allocate windows for the first+.Ar N+files and hide the rest.+.It Fl p Ns Op Ar N+Open+.Ar N+tab pages.+If+.Ar N+is omitted, open one tab page for each file.+If+.Ar N+is less than the number of file arguments, allocate tab pages for the first+.Ar N+files and hide the rest.+.It Cm + Ns Op Ar linenum+For the first file, position the cursor on line+.Ar linenum .+If+.Ar linenum+is omitted, position the cursor on the last line of the file.+Note that+.Cm +5+and+.Cm -c 5+on the command-line are equivalent to+.Ic :5+inside+.Nm .+.It Cm +/ Ns Op Ar pattern+For the first file, position the cursor on the first occurrence of+.Ar pattern .+If+.Ar pattern+is omitted, the most recently used search pattern is used (if there is one).+Note that+.Cm /foo+and+.Cm -c /foo+on the command-line are equivalent to+.Ic /foo+and+.Ic :/foo+inside+.Nm .+See+.Ic :help search-pattern .+.It Fl -cmd Ar command+Execute+.Ar command+before processing any nvimrc.+Up to 10 instances of these can be used, independently from instances of+.Fl c .+.It Fl c Ar command+Execute","> +num and +/pat are just special cases of itTo be exact, the one exception is that just a `+` will put the cursor at the end of the file.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2634,30117513,2015-05-12T09:25:31Z,contrib/local.mk.example,"@@ -9,7 +9,7 @@  # By default, the jemalloc family of memory allocation functions are used. # Uncomment the following to instead use libc memory allocation functions:-# CMAKE_EXTRA_FLAGS=""-DUSE_JEMALLOC=OFF""+# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_JEMALLOC=OFF","> Assuming it was available at compile-time, right?Yes, exactly.Maybe use a different dependency and change the comment to e.g.:```# By default, Neovim builds and statically links to required third-party dependencies such as # MessagePack. Uncomment the following to instead use a systemwide installation of MessagePack.# See third-party/CMakeLists.txt for a list of dependencies.# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_MSGPACK=OFF```One maybe confusing thing is that some dependencies are required (messagepack, libuv) and some are optional (busted, jemalloc).",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2634,30117701,2015-05-12T09:29:05Z,contrib/local.mk.example,"@@ -9,7 +9,7 @@  # By default, the jemalloc family of memory allocation functions are used. # Uncomment the following to instead use libc memory allocation functions:-# CMAKE_EXTRA_FLAGS=""-DUSE_JEMALLOC=OFF""+# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_JEMALLOC=OFF","> Maybe use a different dependency and change the comment to e.g.:Why use a different dependency? Is jemalloc different from the other deps at compile time? Regardless, thanks for writing that up.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2634,30117986,2015-05-12T09:33:17Z,contrib/local.mk.example,"@@ -9,7 +9,7 @@  # By default, the jemalloc family of memory allocation functions are used. # Uncomment the following to instead use libc memory allocation functions:-# CMAKE_EXTRA_FLAGS=""-DUSE_JEMALLOC=OFF""+# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_JEMALLOC=OFF","> Why use a different dependency? Is jemalloc different from the other deps at compile time?Well, it is an optional dependency, so the explanation is a bit more complicated:- If USE_BUNDLED_JEMALLOC=ON: use jemalloc- If USE_BUNDLED_JEMALLOC=OFF:  - If jemalloc installed systemwide: use jemalloc  - If jemalloc not installed: use libc mallocThis is similar to e.g. busted: if it is not found, the build doesn't fail, it just skips building the ""test parts"".",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2634,30118577,2015-05-12T09:43:12Z,contrib/local.mk.example,"@@ -9,7 +9,7 @@  # By default, the jemalloc family of memory allocation functions are used. # Uncomment the following to instead use libc memory allocation functions:-# CMAKE_EXTRA_FLAGS=""-DUSE_JEMALLOC=OFF""+# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_JEMALLOC=OFF","> USE_JEMALLOC=OFFThat could be added [here](https://github.com/neovim/neovim/blob/master/CMakeLists.txt#L208).. but `USE_BUNDLED_JEMALLOC` is for `third-party/CMakeLists.txt` and `USE_JEMALLOC` would be for `CMakeLists.txt`, that's why you need two (or add something to the main Makefile). If you don't mind jemalloc being downloaded, specifying `USE_JEMALLOC=OFF` would be enough, though.Also, even if you specify `USE_JEMALLOC=ON`, it would silently fall back to libc malloc if jemalloc was not found.. we'd need `USE_JEMALLOC={ON,OFF,AUTO}` (with `AUTO` falling back to libc and `ON` failing if jemalloc not found)?",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2634,30119871,2015-05-12T10:05:38Z,contrib/local.mk.example,"@@ -9,7 +9,7 @@  # By default, the jemalloc family of memory allocation functions are used. # Uncomment the following to instead use libc memory allocation functions:-# CMAKE_EXTRA_FLAGS=""-DUSE_JEMALLOC=OFF""+# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_JEMALLOC=OFF","> I see, although I'm still unsure why there's no option to ""hard"" disable jemalloc (like USE_JEMALLOC=OFF). That way, jemalloc wouldn't be built and you wouldn't need to specify USE_BUNDLED_JEMALLOC=OFF as well as USE_JEMALLOC=OFF.It would be wonderful if we could dependencies and Neovim built as required under one invocation of CMake.  Unfortunately, that's not very possible--at least not without a great deal of work and fragility.  If we attempted to do such a thing, then we could not correctly obtain flags required for the dependencies via pkg-config (because the would not be built at CMake's configure time, and thus would be unavailable for consumption).  Instead, we'd have to re-implement whatever logic each of them has into our build system, which is almost certain to be wrong in some way.  That's why there is this split-brained situation, and why there are two separate knobs.  We could do more in the Makefile to help, but I'd really like to keep that as slim as possible--we don't want two build systems.  CMake is _the_ build system, Make is just some nice glue to make it easier to get up and running.  Truthfully, I don't use Make much with Neovim--I drive CMake directly.> USE_JEMALLOC=OFFYou still have to pass it to both the deps and Neovim builds though (the flags aren't shared between both).  We could come up with some variable that we could share between both... I'm not sure if that's good or bad though.  I'd expect just as many issues when they start trying to pass flags that only makes sense for one and not the other.> Anyways, it's a rather small inconsistency so perhaps it could be dealt with later.That depends on how you look at it. :-)  It's certainly consistent with how the other dependencies are built and included, and they communicate different things.  There's one small section of overlap: when USE_JMALLOC is OFF.  But it's hardly right to say they completely overlap. :-)",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2634,30122240,2015-05-12T10:45:08Z,contrib/local.mk.example,"@@ -9,7 +9,7 @@  # By default, the jemalloc family of memory allocation functions are used. # Uncomment the following to instead use libc memory allocation functions:-# CMAKE_EXTRA_FLAGS=""-DUSE_JEMALLOC=OFF""+# DEPS_CMAKE_FLAGS := -DUSE_BUNDLED_JEMALLOC=OFF","As long as the required logic wouldn't be too complicated then I don't really mind. Then again, this doesn't seem to be much of an issue in (in theory), as if you don't want jemalloc you probably don't have it installed (given how relatively few programs use it). Up to you I suppose. Anyways, I pushed some new commits @fwalch.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,30215190,2015-05-13T09:30:04Z,third-party/cmake/BuildLuarocks.cmake,"@@ -1,35 +1,89 @@-option(USE_BUNDLED_BUSTED ""Use the bundled version of busted to run tests."" ON)+# Luarocks recipe. Luarocks is only required when building Neovim, when+# cross compiling we still want to build for the HOST system, whenever+# writing a recipe than is mean for cross-compile, use the HOSTDEPS_* variables+# instead of DEPS_* - check the main CMakeLists.txt for a list. -if(USE_BUNDLED_LUAJIT)-  list(APPEND LUAROCKS_OPTS-    --with-lua=${DEPS_INSTALL_DIR}-    --with-lua-include=${DEPS_INSTALL_DIR}/include/luajit-2.0)+if(MSVC)+  message(STATUS ""Building busted in Windows is not supported (skipping)"")","It should be undefined anyway since the option(...) is never called - I don't think its bad if someone wants to explicitly force -DUSE_BUNDLED_BUSTED=ON to try it anyway. The problem with busted is not in our recipe, its upstream in nvim-client and lua-xml.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2495,30215993,2015-05-13T09:42:00Z,third-party/cmake/BuildLuarocks.cmake,"@@ -1,35 +1,89 @@-option(USE_BUNDLED_BUSTED ""Use the bundled version of busted to run tests."" ON)+# Luarocks recipe. Luarocks is only required when building Neovim, when+# cross compiling we still want to build for the HOST system, whenever+# writing a recipe than is mean for cross-compile, use the HOSTDEPS_* variables+# instead of DEPS_* - check the main CMakeLists.txt for a list. -if(USE_BUNDLED_LUAJIT)-  list(APPEND LUAROCKS_OPTS-    --with-lua=${DEPS_INSTALL_DIR}-    --with-lua-include=${DEPS_INSTALL_DIR}/include/luajit-2.0)+if(MSVC)+  message(STATUS ""Building busted in Windows is not supported (skipping)"")","I don't think this works```option(USE_BUNDLED_BUSTED ""Use the bundled version of busted to run tests."" NOT MSVC)```maybe this does```cmake_dependent_option(USE_BUNDLED_BUSTED ""Use the bundled version of busted to run tests"" ON ""NOT MSVC"" OFF)```",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2495,30222892,2015-05-13T11:47:30Z,cmake/mingw32-w64-cross-travis.toolchain.cmake,"@@ -0,0 +1,53 @@+#+# Mingw-w64 cross compiler toolchain+#+# - The usual CMAKE variables will point to the cross compiler+# - HOST_EXE_LINKER, HOST_C_COMPILER, HOST_EXE_LINKER_FLAGS,+#   HOST_C_FLAGS point to a host compiler+#++set(MINGW_TRIPLET i686-w64-mingw32)+# For x86_64 use+#set(MINGW_TRIPLET x86_64-w64-mingw32)++# The location of your toolchain sys-root+set(MINGW_PREFIX_PATH /opt/mingw32/${MINGW_TRIPLET}/)+# or sometimes like this+#set(MINGW_PREFIX_PATH /usr/${MINGW_TRIPLET}/sys-root)","I see.  We need to build msgpack via CMake, and it won't pick up the correct value.  We could just add it to the command line there, just like we're adding the toolchain file.  As I've said before though, I don't think all of this needs to get worked out before merging this.  Let's leave it the way it is for now, and perhaps a better solution will emerge down the road.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2655,30337794,2015-05-14T16:46:31Z,src/nvim/ex_docmd.c,"@@ -1684,12 +1684,7 @@ static char_u * do_one_cmd(char_u **cmdlinep,       }     } else if (ea.addr_count != 0) {       if (ea.line2 > curbuf->b_ml.ml_line_count) {-        /* With '-' in 'cpoptions' a line number past the file is an-         * error, otherwise put it at the end of the file. */-        if (vim_strchr(p_cpo, CPO_MINUS) != NULL)-          ea.line2 = -1;-        else-          ea.line2 = curbuf->b_ml.ml_line_count;+        ea.line2 = curbuf->b_ml.ml_line_count;       }        if (ea.line2 < 0)","Can `ea.line2` ever be less than zero at this point? With the first statement gone, perhaps not, but I am not a hundred percent sure so I left this condition intact.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2657,30344704,2015-05-14T17:57:14Z,src/nvim/regexp.c,"@@ -6984,10 +6984,14 @@ regprog_T *vim_regcomp(char_u *expr_arg, int re_flags)   /*    * First try the NFA engine, unless backtracking was requested.    */-  if (regexp_engine != BACKTRACKING_ENGINE)-    prog = nfa_regengine.regcomp(expr, re_flags);-  else+  if (regexp_engine != BACKTRACKING_ENGINE) {+    prog = nfa_regengine.regcomp(expr,+                                 re_flags + (regexp_engine == AUTOMATIC_ENGINE+                                             ? RE_AUTO+                                             : 0));","I don't really like it either. I think we should allow exceptions for cases like this, and allow 2-space indent instead. E.g.:``` c  if (regexp_engine != BACKTRACKING_ENGINE) {    prog = nfa_regengine.regcomp(expr,      re_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));```Especially considering it saves 2 lines here, the vertical alignment thing seems unnecessary to me.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2578,30465342,2015-05-16T22:23:06Z,src/nvim/os/os_defs.h,"@@ -1,10 +1,90 @@ #ifndef NVIM_OS_OS_DEFS_H #define NVIM_OS_OS_DEFS_H +#include <ctype.h>+#include <stdio.h>+#include <stdlib.h>+#include <sys/stat.h>+#include <sys/types.h>+ #ifdef WIN32 # include ""nvim/os/win_defs.h"" #else # include ""nvim/os/unix_defs.h"" #endif +#ifdef HAVE_SYS_TIME_H+# include <sys/time.h>+#else+# include <time.h>+#endif++#ifndef FILETYPE_FILE+# define FILETYPE_FILE  ""filetype.vim""+#endif++#ifndef FTPLUGIN_FILE+# define FTPLUGIN_FILE  ""ftplugin.vim""+#endif++#ifndef INDENT_FILE+# define INDENT_FILE    ""indent.vim""+#endif++#ifndef FTOFF_FILE+# define FTOFF_FILE     ""ftoff.vim""+#endif++#ifndef FTPLUGOF_FILE+# define FTPLUGOF_FILE  ""ftplugof.vim""+#endif++#ifndef INDOFF_FILE+# define INDOFF_FILE    ""indoff.vim""+#endif++#define DFLT_ERRORFILE          ""errors.err""++// Unix has plenty of memory, use large buffers.","Maybe `We have plenty of memory, so use large buffers`.",
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/2563,30468140,2015-05-17T07:35:34Z,test/functional/ui/completion_spec.lua,"@@ -0,0 +1,41 @@+local helpers = require('test.functional.helpers')+local Screen = require('test.functional.ui.screen')+local clear, feed, execute = helpers.clear, helpers.feed, helpers.execute+local eval, eq, source = helpers.eval, helpers.eq, helpers.source++describe(""completion"", function()+  local screen++  before_each(function()+    clear()+    screen = Screen.new(25, 5)+    screen:attach()+  end)++  after_each(function()+    screen:detach()+  end)++  describe(""v:completed_item"", function()",OK.  But I don't know how to add exception check.Please explain it.,
41495,Shougo,https://api.github.com/repos/neovim/neovim/pulls/2563,30468164,2015-05-17T07:41:55Z,test/functional/ui/completion_spec.lua,"@@ -0,0 +1,41 @@+local helpers = require('test.functional.helpers')+local Screen = require('test.functional.ui.screen')+local clear, feed, execute = helpers.clear, helpers.feed, helpers.execute+local eval, eq, source = helpers.eval, helpers.eq, helpers.source++describe(""completion"", function()+  local screen++  before_each(function()+    clear()+    screen = Screen.new(25, 5)+    screen:attach()+  end)++  after_each(function()+    screen:detach()+  end)++  describe(""v:completed_item"", function()",I cannot find error/exception helpers in helpers.lua.I think it is not the PR work.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2650,30473815,2015-05-17T19:34:38Z,src/nvim/lib/rbuffer.h,"@@ -0,0 +1,285 @@+// Ring buffer implementation. This is basically an array that wraps read/write+// pointers around the memory region. It should be more efficient than the old+// RBuffer which required memmove() calls to relocate read/write positions.+//+// The main purpose of RBuffer is simplify memory management when reading from+// uv_stream_t instances:+//+// - The event loop writes data to a RBuffer, advancing the write pointer+// - The main loop reads data, advancing the read pointer+// - If the buffer becomes full(size == capacity) the rstream is temporarily+//   stopped(automatic backpressure handling)+//+// Reference: http://en.wikipedia.org/wiki/Circular_buffer+#ifndef NVIM_LIB_RBUFFER_H+#define NVIM_LIB_RBUFFER_H++#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+++// Macros that simplify working with the read/write pointers directly by hiding+// ring buffer wrap logic. Some examples:+//+// - Pass the write pointer to a function(`write_data`) that incrementally+//   produces data, returning the number of bytes actually written:+//+//       RBUFFER_EACH_WRITE_PTR(rbuf, ptr, cnt)+//         rbuffer_produced(rbuf, write_data(state, ptr, cnt));+//+// - Pass the read pointer to a function(`read_data`) that incrementally+//   consumes data, return the number of bytes actually read:+//+//       RBUFFER_EACH_READ_PTR(rbuf, ptr, cnt)+//         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));",Does not work if `read_data()` does not returns `cnt`. The next read uses a wrong `ptr`.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2650,30474065,2015-05-17T19:54:59Z,src/nvim/lib/rbuffer.h,"@@ -0,0 +1,285 @@+// Ring buffer implementation. This is basically an array that wraps read/write+// pointers around the memory region. It should be more efficient than the old+// RBuffer which required memmove() calls to relocate read/write positions.+//+// The main purpose of RBuffer is simplify memory management when reading from+// uv_stream_t instances:+//+// - The event loop writes data to a RBuffer, advancing the write pointer+// - The main loop reads data, advancing the read pointer+// - If the buffer becomes full(size == capacity) the rstream is temporarily+//   stopped(automatic backpressure handling)+//+// Reference: http://en.wikipedia.org/wiki/Circular_buffer+#ifndef NVIM_LIB_RBUFFER_H+#define NVIM_LIB_RBUFFER_H++#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+++// Macros that simplify working with the read/write pointers directly by hiding+// ring buffer wrap logic. Some examples:+//+// - Pass the write pointer to a function(`write_data`) that incrementally+//   produces data, returning the number of bytes actually written:+//+//       RBUFFER_EACH_WRITE_PTR(rbuf, ptr, cnt)+//         rbuffer_produced(rbuf, write_data(state, ptr, cnt));+//+// - Pass the read pointer to a function(`read_data`) that incrementally+//   consumes data, return the number of bytes actually read:+//+//       RBUFFER_EACH_READ_PTR(rbuf, ptr, cnt)+//         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));+//+// In other words, these functions iterate through each read/write pointers+// passing their values to the `ptr` argument, while the `cnt` argument contains+// the real size of the buffer pointed by `ptr`(the maximum number of bytes that+// can be read or written). `rbuffer_produced`/`rbuffer_consumed` are the+// functions that actually mutate the internal read/write pointers to reflect+// read/written data.+#define RBUFFER_EACH_READ_PTR(buf, rptr, rcnt)                                 \+  for (size_t rcnt = 0, _r = buf->size; _r != SIZE_MAX; _r = SIZE_MAX)         \+    for (char *rptr = rbuffer_read_ptr(buf, &rcnt);                            \+         _r;                                                                   \+         _r -= rcnt, rptr = _r ? buf->start_ptr : NULL, rcnt = _r ? _r : 0)","Would it be problematic to use the macro with an additional (code) argument? Seems to be cleaner, easier to check and does not have the problem with reads that consume less than `rcnt` bytes in one iteration (from the example above `RBUFFER_EACH_READ_PTR(rbuf, ptr, cnt) rbuffer_consumed(rbuf, read_data(state, ptr, cnt));`).``` c#define RBUFFER_EACH_READ_PTR(buf, rptr, rcnt, code)                          \  do {                                                                         \    size_t rcnt;                                                               \    while (buf->size) {                                                        \      char *rptr = rbuffer_read_ptr(buf, &rcnt);                               \      code                                                                     \    }                                                                          \  } while (0)```Usage is similar to the old macro:``` cstatic inline size_t rbuffer_read(RBuffer *buf, char *dst, size_t dst_size)  FUNC_ATTR_NONNULL_ALL{  size_t size = dst_size;  RBUFFER_EACH_READ_PTR(buf, rptr, rcnt, {    size_t copy_count = MIN(dst_size, rcnt);    memcpy(dst, rptr, copy_count);    rbuffer_consumed(buf, copy_count);    if (!(dst_size -= copy_count)) {      return size;    }    dst += copy_count;  });  return size - dst_size;}```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2532,30476393,2015-05-17T23:49:45Z,runtime/doc/options.txt,"@@ -6771,80 +6771,16 @@ A jump table for the options with a short description can be found at |Q_op|. 	by user preferences or the current theme is used.  			     *'ttybuiltin'* *'tbi'* *'nottybuiltin'* *'notbi'*-'ttybuiltin' 'tbi'	Removed. {Nvim}+'ttybuiltin' 'tbi'	Removed. |vim-differences| {Nvim}  				     *'ttyfast'* *'tf'* *'nottyfast'* *'notf'* 'ttyfast' 'tf'		Removed. |vim-differences| {Nvim}  						*'ttymouse'* *'ttym'*-'ttymouse' 'ttym'	string	(default depends on 'term')-			global-			{only in Unix, doesn't work in the GUI; not-			available when compiled without |+mouse|}","This (""only on unix, not in the GUI"") is a good hint that it's not an option we want to keep. Platform-dependent features should be implemented as providers and/or passive events, possibly with lowest-common denominator support existing in the core (as is the case with TUI mouse handling).",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/2569,30477288,2015-05-18T01:05:06Z,src/nvim/os/env.c,"@@ -76,6 +76,31 @@ char *os_getenvname_at_index(size_t index)   return name; } +/// Check if the environment variable `name` exists and has+/// a value of either 1, ""on"", ""yes"", or ""true"".+bool os_env_istruthy(const char *name) FUNC_ATTR_NONNULL_ALL+{+  const char *val = os_getenv(name);+  if (val == NULL || *val == NUL) {  // TODO(Pyrohh): Remove the check for+    return false;                    // NUL after #2574 is merged.+  }++  errno = 0;+  long n = strtol(val, NULL, 10);","In Windows as in Unix os_getenv() is just getenv(), so I am not expecting any update there.> I assume it is not possible for os_getenv to return a non-NUL-terminated stringNot normal, but it doesn't seem impossible, even in Unix. putenv() might allow it, or failing that, if a program really wants to place binary data in an environment variable, it might even write directly to **environ. A quick search shows one such case in [SO](http://stackoverflow.com/questions/15767114/binary-enviornment-variables-and-setenv).Is ""1"" the only number considered ""truthly""? If so can't we just compare against ""1\0""?",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2569,30477691,2015-05-18T01:28:49Z,src/nvim/os/env.c,"@@ -76,6 +76,31 @@ char *os_getenvname_at_index(size_t index)   return name; } +/// Check if the environment variable `name` exists and has+/// a value of either 1, ""on"", ""yes"", or ""true"".+bool os_env_istruthy(const char *name) FUNC_ATTR_NONNULL_ALL+{+  const char *val = os_getenv(name);+  if (val == NULL || *val == NUL) {  // TODO(Pyrohh): Remove the check for+    return false;                    // NUL after #2574 is merged.+  }++  errno = 0;+  long n = strtol(val, NULL, 10);","> Not normal, but it doesn't seem impossible, even in Unix. putenv() might allow it, or failing that, if a program really wants to place binary data in an environment variable, it might even write directly to **environ. A quick search shows one such case in SO.Huh, that's pretty interesting. Regardless, I don't think it's worth it to try to protect against this, assuming it's uncommon.> Is ""1"" the only number considered ""truthly""? If so can't we just compare against ""1\0""?Isn't that already being done below? And yes, as far as I know it is.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2650,30496852,2015-05-18T10:35:40Z,src/nvim/lib/rbuffer.h,"@@ -0,0 +1,285 @@+// Ring buffer implementation. This is basically an array that wraps read/write+// pointers around the memory region. It should be more efficient than the old+// RBuffer which required memmove() calls to relocate read/write positions.+//+// The main purpose of RBuffer is simplify memory management when reading from+// uv_stream_t instances:+//+// - The event loop writes data to a RBuffer, advancing the write pointer+// - The main loop reads data, advancing the read pointer+// - If the buffer becomes full(size == capacity) the rstream is temporarily+//   stopped(automatic backpressure handling)+//+// Reference: http://en.wikipedia.org/wiki/Circular_buffer+#ifndef NVIM_LIB_RBUFFER_H+#define NVIM_LIB_RBUFFER_H++#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+++// Macros that simplify working with the read/write pointers directly by hiding+// ring buffer wrap logic. Some examples:+//+// - Pass the write pointer to a function(`write_data`) that incrementally+//   produces data, returning the number of bytes actually written:+//+//       RBUFFER_EACH_WRITE_PTR(rbuf, ptr, cnt)+//         rbuffer_produced(rbuf, write_data(state, ptr, cnt));+//+// - Pass the read pointer to a function(`read_data`) that incrementally+//   consumes data, return the number of bytes actually read:+//+//       RBUFFER_EACH_READ_PTR(rbuf, ptr, cnt)+//         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));","I forgot to update the usage of these macros which have different semantics. These ones are only useful iterate over the all the data and only consume later:``` csize_t consumed = 0;RBUFFER_EACH_READ_PTR(rbuf, ptr, cnt)  if ((consumed += read_data(state, ptr, cnt)) < cnt) break;rbuffer_consumed(rbuf, consumed);```",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2650,30497190,2015-05-18T10:42:09Z,src/nvim/lib/rbuffer.h,"@@ -0,0 +1,285 @@+// Ring buffer implementation. This is basically an array that wraps read/write+// pointers around the memory region. It should be more efficient than the old+// RBuffer which required memmove() calls to relocate read/write positions.+//+// The main purpose of RBuffer is simplify memory management when reading from+// uv_stream_t instances:+//+// - The event loop writes data to a RBuffer, advancing the write pointer+// - The main loop reads data, advancing the read pointer+// - If the buffer becomes full(size == capacity) the rstream is temporarily+//   stopped(automatic backpressure handling)+//+// Reference: http://en.wikipedia.org/wiki/Circular_buffer+#ifndef NVIM_LIB_RBUFFER_H+#define NVIM_LIB_RBUFFER_H++#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+++// Macros that simplify working with the read/write pointers directly by hiding+// ring buffer wrap logic. Some examples:+//+// - Pass the write pointer to a function(`write_data`) that incrementally+//   produces data, returning the number of bytes actually written:+//+//       RBUFFER_EACH_WRITE_PTR(rbuf, ptr, cnt)+//         rbuffer_produced(rbuf, write_data(state, ptr, cnt));+//+// - Pass the read pointer to a function(`read_data`) that incrementally+//   consumes data, return the number of bytes actually read:+//+//       RBUFFER_EACH_READ_PTR(rbuf, ptr, cnt)+//         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));+//+// In other words, these functions iterate through each read/write pointers+// passing their values to the `ptr` argument, while the `cnt` argument contains+// the real size of the buffer pointed by `ptr`(the maximum number of bytes that+// can be read or written). `rbuffer_produced`/`rbuffer_consumed` are the+// functions that actually mutate the internal read/write pointers to reflect+// read/written data.+#define RBUFFER_EACH_READ_PTR(buf, rptr, rcnt)                                 \+  for (size_t rcnt = 0, _r = buf->size; _r != SIZE_MAX; _r = SIZE_MAX)         \+    for (char *rptr = rbuffer_read_ptr(buf, &rcnt);                            \+         _r;                                                                   \+         _r -= rcnt, rptr = _r ? buf->start_ptr : NULL, rcnt = _r ? _r : 0)",What you suggested has the same semantics as the previous `RBUFFER_UNTIL_EMPTY` macro. (See the response to the above comment for an updated usage).,
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2659,30523971,2015-05-18T16:32:05Z,runtime/doc/eval.txt,"@@ -4891,7 +4892,7 @@ readfile({fname} [, {binary} [, {max}]]) 		separated with CR will result in a single long line (unless a 		NL appears somewhere). 		All NUL characters are replaced with a NL character.-		When {binary} is equal to ""b"" binary mode is used:+		When {binary/append} contains ""b"" binary mode is used:","You're right, this is confusing.. I guess the `{binary}` parameter was supposed to be renamed to `{binary/append}`? It's still unchanged in current Vim..",
1104419,lucc,https://api.github.com/repos/neovim/neovim/pulls/2692,30545881,2015-05-18T20:48:27Z,test/functional/legacy/082_spec.lua,"@@ -0,0 +1,105 @@+-- Tests for case-insensitive UTF-8 comparisons (utf_strnicmp() in mbyte.c)+-- Also test ""g~ap"".++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('82', function()+  setup(clear)++  it('is working', function()+    execute('set enc=utf8')+    feed('ggdG<cr>')+    execute('function! Ch(a, op, b, expected)')+    execute([[  if eval(printf('""%s"" %s ""%s""', a:a, a:op, a:b)) != a:expected]])+    execute([[    call append(line('$'), printf('""%s"" %s ""%s"" should return %d', a:a, a:op, a:b, a:expected))]])+    execute('  else')+    execute('    let b:passed += 1')+    execute('  endif')+    execute('endfunction')+    execute('function! Chk(a, b, result)')+    execute('  if a:result == 0')+    execute([[    call Ch(a:a, '==?', a:b, 1)]])+    execute([[    call Ch(a:a, '!=?', a:b, 0)]])+    execute([[    call Ch(a:a, '<=?', a:b, 1)]])+    execute([[    call Ch(a:a, '>=?', a:b, 1)]])+    execute([[    call Ch(a:a, '<?', a:b, 0)]])+    execute([[    call Ch(a:a, '>?', a:b, 0)]])+    execute('  elseif a:result > 0')+    execute([[    call Ch(a:a, '==?', a:b, 0)]])+    execute([[    call Ch(a:a, '!=?', a:b, 1)]])+    execute([[    call Ch(a:a, '<=?', a:b, 0)]])+    execute([[    call Ch(a:a, '>=?', a:b, 1)]])+    execute([[    call Ch(a:a, '<?', a:b, 0)]])+    execute([[    call Ch(a:a, '>?', a:b, 1)]])+    execute('  else')+    execute([[    call Ch(a:a, '==?', a:b, 0)]])+    execute([[    call Ch(a:a, '!=?', a:b, 1)]])+    execute([[    call Ch(a:a, '<=?', a:b, 1)]])+    execute([[    call Ch(a:a, '>=?', a:b, 0)]])+    execute([[    call Ch(a:a, '<?', a:b, 1)]])+    execute([[    call Ch(a:a, '>?', a:b, 0)]])+    execute('  endif')+    execute('endfunction')+    execute('function! Check(a, b, result)')+    execute('  call Chk(a:a, a:b, a:result)')+    execute('  call Chk(a:b, a:a, -a:result)')+    execute('endfunction')+    execute('function! LT(a, b)')+    execute('  call Check(a:a, a:b, -1)')+    execute('endfunction')+    execute('function! GT(a, b)')+    execute('  call Check(a:a, a:b, 1)')+    execute('endfunction')+    execute('function! EQ(a, b)')+    execute('  call Check(a:a, a:b, 0)')+    execute('endfunction')+    execute('let b:passed=0')+    execute([[call EQ('', '')]])+    execute([[call LT('', 'a')]])+    execute([[call EQ('abc', 'abc')]])+    execute([[call EQ('Abc', 'abC')]])+    execute([[call LT('ab', 'abc')]])+    execute([[call LT('AB', 'abc')]])+    execute([[call LT('ab', 'aBc')]])+    execute([[call EQ('\xd0\xb9\xd1\x86\xd1\x83\xd0\xba\xd0\xb5\xd0\xbd', '\xd0\xb9\xd0\xa6\xd0\xa3\xd0\xba\xd0\x95\xd0\xbd')]])+    execute([[call LT('\xd0\xb9\xd1\x86\xd1\x83\xd0\xba\xd0\xb5\xd0\xbd', '\xd0\xaf\xd1\x86\xd1\x83\xd0\xba\xd0\xb5\xd0\xbd')]])+    execute([[call EQ('\xe2\x84\xaa', 'k')]])+    execute([[call LT('\xe2\x84\xaa', 'kkkkkk')]])+    execute([[call EQ('\xe2\x84\xaa\xe2\x84\xaa\xe2\x84\xaa', 'kkk')]])+    execute([[call LT('kk', '\xe2\x84\xaa\xe2\x84\xaa\xe2\x84\xaa')]])+    execute([[call EQ('\xe2\x84\xaa\xe2\x84\xa6k\xe2\x84\xaak\xcf\x89', 'k\xcf\x89\xe2\x84\xaakk\xe2\x84\xa6')]])+    execute([[call EQ('Abc\x80', 'AbC\x80')]])+    execute([[call LT('Abc\x80', 'AbC\x81')]])+    execute([[call LT('Abc', 'AbC\x80')]])+    -- Case folding stops at the first bad character.+    execute([[call LT('abc\x80DEF', 'abc\x80def')]])+    execute([[call LT('\xc3XYZ', '\xc3xyz')]])+    -- FF3A (upper), FF5A (lower).+    execute([[call EQ('\xef\xbc\xba', '\xef\xbd\x9a')]])+    -- First string is ok and equals \xef\xbd\x9a after folding, second string is illegal and was left unchanged, then the strings were bytewise compared.+    execute([[call GT('\xef\xbc\xba', '\xef\xbc\xff')]])+    execute([[call LT('\xc3', '\xc3\x83')]])+    execute([[call EQ('\xc3\xa3xYz', '\xc3\x83XyZ')]])+    execute([[for n in range(0x60, 0xFF) | call LT(printf('xYz\x%.2X', n-1), printf('XyZ\x%.2X', n)) | endfor]])+    execute([[for n in range(0x80, 0xBF) | call EQ(printf('xYz\xc2\x%.2XUvW', n), printf('XyZ\xc2\x%.2XuVw', n)) | endfor]])+    execute([[for n in range(0xC0, 0xFF) | call LT(printf('xYz\xc2\x%.2XUvW', n), printf('XyZ\xc2\x%.2XuVw', n)) | endfor]])+    execute([[call append(0, printf('%d checks passed', b:passed))]])++    -- Test that g~ap changes one paragraph only.+    execute('new')+    feed('iabcd<cr><cr>')+    feed('defg<esc>gg0g~ap:let lns = getline(1,3)<cr>')+    execute('q!')+    execute([[call append(line('$'), lns)]])++    -- Assert buffer contents.+    expect([=[+3732 checks passed++ABCD++defg]=])",I had trouble with this as the indent must be preset on the empty lines as well but I delete trailing WS with an autocmd similar to this:`autocmd bufwrite *  %s/\s\+$//e`. Now I have the autocmd disabled manually.,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2703,30599308,2015-05-19T13:41:44Z,runtime/autoload/provider/clipboard.vim,"@@ -5,7 +5,8 @@ let s:copy = {} let s:paste = {}  function! s:try_cmd(cmd, ...)-  let out = a:0 ? systemlist(a:cmd, a:1, 1) : systemlist(a:cmd, [''], 1)+  let argv = split(a:cmd, "" "")+  let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)",@ZyX-I was right about sending a list to not invoke the shell being very useful! :+1:,
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2692,30629007,2015-05-19T18:14:28Z,test/functional/legacy/082_string_comparison_spec.lua,"@@ -0,0 +1,118 @@+-- Tests for case-insensitive UTF-8 comparisons (utf_strnicmp() in mbyte.c)+-- Also test ""g~ap"".++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('case-insensitive string comparison in UTF-8', function()+  setup(clear)++  it('is working', function()+    execute('set enc=utf8')+    feed('ggdG<cr>')+    -- first we define some functions that are needed for the test+    source([[","I think you can really keep the format almost one-to-one as in the original test. Just one long source block, I don't think you need to break it up just to have the comments in Lua syntax. (Note that every `source` creates and deletes a temporary file.)I would do it like this more or less:```source([[  function! Ch(a, op, b, expected)    if eval(printf('""%s"" %s ""%s""', a:a, a:op, a:b)) != a:expected      call append(line('$'), printf('""%s"" %s ""%s"" should return %d', a:a, a:op, a:b, a:expected))    else      let b:passed += 1    endif  endfunction  function! Chk(a, b, result)    if a:result == 0      call Ch(a:a, '==?', a:b, 1)      call Ch(a:a, '!=?', a:b, 0)      call Ch(a:a, '<=?', a:b, 1)      call Ch(a:a, '>=?', a:b, 1)      call Ch(a:a, '<?', a:b, 0)      call Ch(a:a, '>?', a:b, 0)    elseif a:result > 0      call Ch(a:a, '==?', a:b, 0)      call Ch(a:a, '!=?', a:b, 1)      call Ch(a:a, '<=?', a:b, 0)      call Ch(a:a, '>=?', a:b, 1)      call Ch(a:a, '<?', a:b, 0)      call Ch(a:a, '>?', a:b, 1)    else      call Ch(a:a, '==?', a:b, 0)      call Ch(a:a, '!=?', a:b, 1)      call Ch(a:a, '<=?', a:b, 1)      call Ch(a:a, '>=?', a:b, 0)      call Ch(a:a, '<?', a:b, 1)      call Ch(a:a, '>?', a:b, 0)    endif  endfunction  function! Check(a, b, result)    call Chk(a:a, a:b, a:result)    call Chk(a:b, a:a, -a:result)  endfunction  function! LT(a, b)    call Check(a:a, a:b, -1)  endfunction  function! GT(a, b)    call Check(a:a, a:b, 1)  endfunction  function! EQ(a, b)    call Check(a:a, a:b, 0)  endfunction  let b:passed=0  call EQ('', '')  call LT('', 'a')  call EQ('abc', 'abc')  call EQ('Abc', 'abC')  call LT('ab', 'abc')  call LT('AB', 'abc')  call LT('ab', 'aBc')  call EQ('\xd0\xb9\xd1\x86\xd1\x83\xd0\xba\xd0\xb5\xd0\xbd', '\xd0\xb9\xd0\xa6\xd0\xa3\xd0\xba\xd0\x95\xd0\xbd')  call LT('\xd0\xb9\xd1\x86\xd1\x83\xd0\xba\xd0\xb5\xd0\xbd', '\xd0\xaf\xd1\x86\xd1\x83\xd0\xba\xd0\xb5\xd0\xbd')  call EQ('\xe2\x84\xaa', 'k')  call LT('\xe2\x84\xaa', 'kkkkkk')  call EQ('\xe2\x84\xaa\xe2\x84\xaa\xe2\x84\xaa', 'kkk')  call LT('kk', '\xe2\x84\xaa\xe2\x84\xaa\xe2\x84\xaa')  call EQ('\xe2\x84\xaa\xe2\x84\xa6k\xe2\x84\xaak\xcf\x89', 'k\xcf\x89\xe2\x84\xaakk\xe2\x84\xa6')  call EQ('Abc\x80', 'AbC\x80')  call LT('Abc\x80', 'AbC\x81')  call LT('Abc', 'AbC\x80')  "" Case folding stops at the first bad character.  call LT('abc\x80DEF', 'abc\x80def')  call LT('\xc3XYZ', '\xc3xyz')  "" FF3A (upper), FF5A (lower).  call EQ('\xef\xbc\xba', '\xef\xbd\x9a')  "" First string is ok and equals \xef\xbd\x9a after folding, second string  "" is illegal and was left unchanged, then the strings were bytewise  "" compared.  call GT('\xef\xbc\xba', '\xef\xbc\xff')  call LT('\xc3', '\xc3\x83')  call EQ('\xc3\xa3xYz', '\xc3\x83XyZ')  for n in range(0x60, 0xFF)    call LT(printf('xYz\x%.2X', n-1), printf('XyZ\x%.2X', n))  endfor  for n in range(0x80, 0xBF)    call EQ(printf('xYz\xc2\x%.2XUvW', n), printf('XyZ\xc2\x%.2XuVw', n))  endfor  for n in range(0xC0, 0xFF)    call LT(printf('xYz\xc2\x%.2XUvW', n), printf('XyZ\xc2\x%.2XuVw', n))  endfor  call append(0, printf('%d checks passed', b:passed))]])```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2650,30653733,2015-05-19T22:13:38Z,src/nvim/rbuffer.c,"@@ -0,0 +1,201 @@+#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+#include ""nvim/rbuffer.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""rbuffer.c.generated.h""+#endif++/// Creates a new `RBuffer` instance.+RBuffer *rbuffer_new(size_t capacity)+{+  if (!capacity) {+    capacity = 0xffff;+  }++  RBuffer *rv = xmalloc(sizeof(RBuffer) + capacity);+  rv->full_cb = rv->nonfull_cb = NULL;+  rv->data = NULL;+  rv->size = 0;+  rv->write_ptr = rv->read_ptr = rv->start_ptr;+  rv->end_ptr = rv->start_ptr + capacity;+  return rv;+}++void rbuffer_free(RBuffer *buf)+{+  xfree(buf);+}++size_t rbuffer_size(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return buf->size;+}++size_t rbuffer_capacity(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return (size_t)(buf->end_ptr - buf->start_ptr);+}++size_t rbuffer_space(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return rbuffer_capacity(buf) - buf->size;+}++/// Return a pointer to a raw buffer containing the first empty slot available+/// for writing. The second argument is a pointer to the maximum number of+/// bytes that could be written.+///+/// It is necessary to call this function twice to ensure all empty space was+/// used. See RBUFFER_UNTIL_WRITTEN_OR_FULL for a macro that simplifies this+/// task.+char *rbuffer_write_ptr(RBuffer *buf, size_t *write_count) FUNC_ATTR_NONNULL_ALL+{+  if (buf->size == rbuffer_capacity(buf)) {+    *write_count = 0;+    return NULL;+  }++  if (buf->write_ptr >= buf->read_ptr) {+    *write_count = (size_t)(buf->end_ptr - buf->write_ptr);+  } else {+    *write_count = (size_t)(buf->read_ptr - buf->write_ptr);+  }++  return buf->write_ptr;+}++/// Adjust `rbuffer` write pointer to reflect produced data. This is called+/// automatically by `rbuffer_write`, but when using `rbuffer_write_ptr`+/// directly, this needs to called after the data was copied to the internal+/// buffer. The write pointer will be wrapped if required.+void rbuffer_produced(RBuffer *buf, size_t count) FUNC_ATTR_NONNULL_ALL+{+  assert(count && count <= rbuffer_space(buf));++  buf->write_ptr += count;+  if (buf->write_ptr >= buf->end_ptr) {+    // wrap around+    buf->write_ptr -= rbuffer_capacity(buf);+  }++  buf->size += count;+  if (buf->full_cb && !rbuffer_space(buf)) {+    buf->full_cb(buf, buf->data);+  }+}++/// Return a pointer to a raw buffer containing the first byte available+/// for reading. The second argument is a pointer to the maximum number of+/// bytes that could be read.+///+/// It is necessary to call this function twice to ensure all available bytes+/// were read. See RBUFFER_UNTIL_READ_OR_EMPTY for a macro that simplifies this+/// task.+char *rbuffer_read_ptr(RBuffer *buf, size_t *read_count) FUNC_ATTR_NONNULL_ALL+{+  if (!buf->size) {+    *read_count = 0;+    return NULL;+  }++  if (buf->read_ptr < buf->write_ptr) {+    *read_count = (size_t)(buf->write_ptr - buf->read_ptr);+  } else {+    *read_count = (size_t)(buf->end_ptr - buf->read_ptr);+  }++  return buf->read_ptr;+}++/// Adjust `rbuffer` read pointer to reflect consumed data. This is called+/// automatically by `rbuffer_read`, but when using `rbuffer_read_ptr`+/// directly, this needs to called after the data was copied from the internal+/// buffer. The read pointer will be wrapped if required.+void rbuffer_consumed(RBuffer *buf, size_t count)+  FUNC_ATTR_NONNULL_ALL+{+  assert(count && count <= buf->size);++  buf->read_ptr += count;+  if (buf->read_ptr >= buf->end_ptr) {+      buf->read_ptr -= rbuffer_capacity(buf);+  }++  bool was_full = buf->size == rbuffer_capacity(buf);+  buf->size -= count;+  if (buf->nonfull_cb && was_full) {+    buf->nonfull_cb(buf, buf->data);+  }+}++// Higher level functions for copying from/to RBuffer instances and data+// pointers+size_t rbuffer_write(RBuffer *buf, char *src, size_t src_size)+  FUNC_ATTR_NONNULL_ALL+{+  size_t size = src_size;++  RBUFFER_UNTIL_FULL(buf, wptr, wcnt) {+    size_t copy_count = MIN(src_size, wcnt);+    memcpy(wptr, src, copy_count);+    rbuffer_produced(buf, copy_count);++    if (!(src_size -= copy_count)) {+      return size;+    }++    src += copy_count;+  }++  return size - src_size;+}++size_t rbuffer_read(RBuffer *buf, char *dst, size_t dst_size)+  FUNC_ATTR_NONNULL_ALL+{+  size_t size = dst_size;++  RBUFFER_UNTIL_EMPTY(buf, rptr, rcnt) {+    size_t copy_count = MIN(dst_size, rcnt);+    memcpy(dst, rptr, copy_count);+    rbuffer_consumed(buf, copy_count);++    if (!(dst_size -= copy_count)) {+      return size;+    }++    dst += copy_count;+  }++  return size - dst_size;+}++char *rbuffer_get(RBuffer *buf, size_t index) FUNC_ATTR_NONNULL_ALL+{+  assert(index < buf->size);+  size_t rcnt;+  (void)rbuffer_read_ptr(buf, &rcnt);+  return index < rcnt ?  buf->read_ptr + index : buf->start_ptr + index - rcnt;+}++int rbuffer_cmp(RBuffer *buf, const char *str, size_t count) FUNC_ATTR_NONNULL_ALL+{+  size_t rcnt;+  (void)rbuffer_read_ptr(buf, &rcnt);+  size_t n = MIN(count, rcnt);+  int rv = memcmp(str, buf->read_ptr, n);+  count -= n;+  size_t remaining = buf->size - rcnt;++  if (rv || !count || !remaining) {+    return rv;+  }++  return memcmp(str + n, buf->start_ptr, MIN(count, remaining));","If always `count <= buf->size`, `MIN(...)` could be replaced with `count`. Otherwise a longer string could still match a shorter buffer. Is this intentional (see unittest)?",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2693,30654586,2015-05-19T22:25:00Z,test/functional/legacy/065_float_and_logic_operators_spec.lua,"@@ -0,0 +1,182 @@+-- Test for floating point and logical operators.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('floating point and logical operators', function()+  setup(clear)++  it('is working', function()+    insert([=[+      Results of test65:]=])++    source([[+      $put =printf('%f', 123.456)+      $put =printf('%e', 123.456)+      $put =printf('%g', 123.456)]])+    -- Check we don't crash on division by zero.+    source([[+      echo 1.0 / 0.0+      $put ='+='+      let v = 1.234+      let v += 6.543+      $put =printf('%g', v)+      let v = 1.234+      let v += 5+      $put =printf('%g', v)+      let a = 5+      let a += 3.333+      $put =string(a)+      $put ='=='+      let v = 1.234+      $put =v == 1.234+      $put =v == 1.2341+      $put ='add-subtract'+      $put =printf('%g', 4 + 1.234)+      $put =printf('%g', 1.234 - 8)+      $put ='mult-div'+      $put =printf('%g', 4 * 1.234)+      $put =printf('%g', 4.0 / 1234)+      $put ='dict'+      $put =string({'x': 1.234, 'y': -2.0e20})+      $put ='list'+      $put =string([-123.4, 2.0e-20])+      $put ='abs'+      $put =printf('%d', abs(1456))+      $put =printf('%d', abs(-4))+    ]])+    -- The test seems to fail if this execute call is put inside the above or+    -- the below source() call.+    execute([[$put =printf('%d', abs([1, 2, 3]))]])","Wow, I'm very sorry, I simply did not see your comment in the code. I must be very tired.Anyways then I think you can leave it as it is but please change the comment to explain _why_ the line must not be inside `source`. The reason is that the expression is actually invalid and throws an exception (`Using an X as a Number` ...). The legacy test runner simply ignores the error and continues on, whereas our `source` ends the session when it encounters an exception. `execute` doesn't have this problem because it ultimately feeds keys directly to nvim I believe, like the old test runner (I didn't dig any further than that.)",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2650,30658813,2015-05-19T23:28:56Z,src/nvim/rbuffer.c,"@@ -0,0 +1,201 @@+#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+#include ""nvim/rbuffer.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""rbuffer.c.generated.h""+#endif++/// Creates a new `RBuffer` instance.+RBuffer *rbuffer_new(size_t capacity)+{+  if (!capacity) {+    capacity = 0xffff;+  }++  RBuffer *rv = xmalloc(sizeof(RBuffer) + capacity);+  rv->full_cb = rv->nonfull_cb = NULL;+  rv->data = NULL;+  rv->size = 0;+  rv->write_ptr = rv->read_ptr = rv->start_ptr;+  rv->end_ptr = rv->start_ptr + capacity;+  return rv;+}++void rbuffer_free(RBuffer *buf)+{+  xfree(buf);+}++size_t rbuffer_size(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return buf->size;+}++size_t rbuffer_capacity(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return (size_t)(buf->end_ptr - buf->start_ptr);+}++size_t rbuffer_space(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return rbuffer_capacity(buf) - buf->size;+}++/// Return a pointer to a raw buffer containing the first empty slot available+/// for writing. The second argument is a pointer to the maximum number of+/// bytes that could be written.+///+/// It is necessary to call this function twice to ensure all empty space was+/// used. See RBUFFER_UNTIL_WRITTEN_OR_FULL for a macro that simplifies this+/// task.+char *rbuffer_write_ptr(RBuffer *buf, size_t *write_count) FUNC_ATTR_NONNULL_ALL+{+  if (buf->size == rbuffer_capacity(buf)) {+    *write_count = 0;+    return NULL;+  }++  if (buf->write_ptr >= buf->read_ptr) {+    *write_count = (size_t)(buf->end_ptr - buf->write_ptr);+  } else {+    *write_count = (size_t)(buf->read_ptr - buf->write_ptr);+  }++  return buf->write_ptr;+}++/// Adjust `rbuffer` write pointer to reflect produced data. This is called+/// automatically by `rbuffer_write`, but when using `rbuffer_write_ptr`+/// directly, this needs to called after the data was copied to the internal+/// buffer. The write pointer will be wrapped if required.+void rbuffer_produced(RBuffer *buf, size_t count) FUNC_ATTR_NONNULL_ALL+{+  assert(count && count <= rbuffer_space(buf));++  buf->write_ptr += count;+  if (buf->write_ptr >= buf->end_ptr) {+    // wrap around+    buf->write_ptr -= rbuffer_capacity(buf);+  }++  buf->size += count;+  if (buf->full_cb && !rbuffer_space(buf)) {+    buf->full_cb(buf, buf->data);+  }+}++/// Return a pointer to a raw buffer containing the first byte available+/// for reading. The second argument is a pointer to the maximum number of+/// bytes that could be read.+///+/// It is necessary to call this function twice to ensure all available bytes+/// were read. See RBUFFER_UNTIL_READ_OR_EMPTY for a macro that simplifies this+/// task.+char *rbuffer_read_ptr(RBuffer *buf, size_t *read_count) FUNC_ATTR_NONNULL_ALL+{+  if (!buf->size) {+    *read_count = 0;+    return NULL;+  }++  if (buf->read_ptr < buf->write_ptr) {+    *read_count = (size_t)(buf->write_ptr - buf->read_ptr);+  } else {+    *read_count = (size_t)(buf->end_ptr - buf->read_ptr);+  }++  return buf->read_ptr;+}++/// Adjust `rbuffer` read pointer to reflect consumed data. This is called+/// automatically by `rbuffer_read`, but when using `rbuffer_read_ptr`+/// directly, this needs to called after the data was copied from the internal+/// buffer. The read pointer will be wrapped if required.+void rbuffer_consumed(RBuffer *buf, size_t count)+  FUNC_ATTR_NONNULL_ALL+{+  assert(count && count <= buf->size);++  buf->read_ptr += count;+  if (buf->read_ptr >= buf->end_ptr) {+      buf->read_ptr -= rbuffer_capacity(buf);+  }++  bool was_full = buf->size == rbuffer_capacity(buf);+  buf->size -= count;+  if (buf->nonfull_cb && was_full) {+    buf->nonfull_cb(buf, buf->data);+  }+}++// Higher level functions for copying from/to RBuffer instances and data+// pointers+size_t rbuffer_write(RBuffer *buf, char *src, size_t src_size)+  FUNC_ATTR_NONNULL_ALL+{+  size_t size = src_size;++  RBUFFER_UNTIL_FULL(buf, wptr, wcnt) {+    size_t copy_count = MIN(src_size, wcnt);+    memcpy(wptr, src, copy_count);+    rbuffer_produced(buf, copy_count);++    if (!(src_size -= copy_count)) {+      return size;+    }++    src += copy_count;+  }++  return size - src_size;+}++size_t rbuffer_read(RBuffer *buf, char *dst, size_t dst_size)+  FUNC_ATTR_NONNULL_ALL+{+  size_t size = dst_size;++  RBUFFER_UNTIL_EMPTY(buf, rptr, rcnt) {+    size_t copy_count = MIN(dst_size, rcnt);+    memcpy(dst, rptr, copy_count);+    rbuffer_consumed(buf, copy_count);++    if (!(dst_size -= copy_count)) {+      return size;+    }++    dst += copy_count;+  }++  return size - dst_size;+}++char *rbuffer_get(RBuffer *buf, size_t index) FUNC_ATTR_NONNULL_ALL+{+  assert(index < buf->size);+  size_t rcnt;+  (void)rbuffer_read_ptr(buf, &rcnt);+  return index < rcnt ?  buf->read_ptr + index : buf->start_ptr + index - rcnt;+}++int rbuffer_cmp(RBuffer *buf, const char *str, size_t count) FUNC_ATTR_NONNULL_ALL+{+  size_t rcnt;+  (void)rbuffer_read_ptr(buf, &rcnt);+  size_t n = MIN(count, rcnt);+  int rv = memcmp(str, buf->read_ptr, n);+  count -= n;+  size_t remaining = buf->size - rcnt;++  if (rv || !count || !remaining) {+    return rv;+  }++  return memcmp(str + n, buf->start_ptr, MIN(count, remaining));","If the string is longer than the buffer, how do we know the rest of it isn't coming down the pipe?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2650,30689710,2015-05-20T10:52:29Z,src/nvim/rbuffer.c,"@@ -0,0 +1,201 @@+#include <assert.h>+#include <stddef.h>+#include <string.h>++#include ""nvim/memory.h""+#include ""nvim/vim.h""+#include ""nvim/rbuffer.h""++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""rbuffer.c.generated.h""+#endif++/// Creates a new `RBuffer` instance.+RBuffer *rbuffer_new(size_t capacity)+{+  if (!capacity) {+    capacity = 0xffff;+  }++  RBuffer *rv = xmalloc(sizeof(RBuffer) + capacity);+  rv->full_cb = rv->nonfull_cb = NULL;+  rv->data = NULL;+  rv->size = 0;+  rv->write_ptr = rv->read_ptr = rv->start_ptr;+  rv->end_ptr = rv->start_ptr + capacity;+  return rv;+}++void rbuffer_free(RBuffer *buf)+{+  xfree(buf);+}++size_t rbuffer_size(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return buf->size;+}++size_t rbuffer_capacity(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return (size_t)(buf->end_ptr - buf->start_ptr);+}++size_t rbuffer_space(RBuffer *buf) FUNC_ATTR_NONNULL_ALL+{+  return rbuffer_capacity(buf) - buf->size;+}++/// Return a pointer to a raw buffer containing the first empty slot available+/// for writing. The second argument is a pointer to the maximum number of+/// bytes that could be written.+///+/// It is necessary to call this function twice to ensure all empty space was+/// used. See RBUFFER_UNTIL_WRITTEN_OR_FULL for a macro that simplifies this+/// task.+char *rbuffer_write_ptr(RBuffer *buf, size_t *write_count) FUNC_ATTR_NONNULL_ALL+{+  if (buf->size == rbuffer_capacity(buf)) {+    *write_count = 0;+    return NULL;+  }++  if (buf->write_ptr >= buf->read_ptr) {+    *write_count = (size_t)(buf->end_ptr - buf->write_ptr);+  } else {+    *write_count = (size_t)(buf->read_ptr - buf->write_ptr);+  }++  return buf->write_ptr;+}++/// Adjust `rbuffer` write pointer to reflect produced data. This is called+/// automatically by `rbuffer_write`, but when using `rbuffer_write_ptr`+/// directly, this needs to called after the data was copied to the internal+/// buffer. The write pointer will be wrapped if required.+void rbuffer_produced(RBuffer *buf, size_t count) FUNC_ATTR_NONNULL_ALL+{+  assert(count && count <= rbuffer_space(buf));++  buf->write_ptr += count;+  if (buf->write_ptr >= buf->end_ptr) {+    // wrap around+    buf->write_ptr -= rbuffer_capacity(buf);+  }++  buf->size += count;+  if (buf->full_cb && !rbuffer_space(buf)) {+    buf->full_cb(buf, buf->data);+  }+}++/// Return a pointer to a raw buffer containing the first byte available+/// for reading. The second argument is a pointer to the maximum number of+/// bytes that could be read.+///+/// It is necessary to call this function twice to ensure all available bytes+/// were read. See RBUFFER_UNTIL_READ_OR_EMPTY for a macro that simplifies this+/// task.+char *rbuffer_read_ptr(RBuffer *buf, size_t *read_count) FUNC_ATTR_NONNULL_ALL+{+  if (!buf->size) {+    *read_count = 0;+    return NULL;+  }++  if (buf->read_ptr < buf->write_ptr) {+    *read_count = (size_t)(buf->write_ptr - buf->read_ptr);+  } else {+    *read_count = (size_t)(buf->end_ptr - buf->read_ptr);+  }++  return buf->read_ptr;+}++/// Adjust `rbuffer` read pointer to reflect consumed data. This is called+/// automatically by `rbuffer_read`, but when using `rbuffer_read_ptr`+/// directly, this needs to called after the data was copied from the internal+/// buffer. The read pointer will be wrapped if required.+void rbuffer_consumed(RBuffer *buf, size_t count)+  FUNC_ATTR_NONNULL_ALL+{+  assert(count && count <= buf->size);++  buf->read_ptr += count;+  if (buf->read_ptr >= buf->end_ptr) {+      buf->read_ptr -= rbuffer_capacity(buf);+  }++  bool was_full = buf->size == rbuffer_capacity(buf);+  buf->size -= count;+  if (buf->nonfull_cb && was_full) {+    buf->nonfull_cb(buf, buf->data);+  }+}++// Higher level functions for copying from/to RBuffer instances and data+// pointers+size_t rbuffer_write(RBuffer *buf, char *src, size_t src_size)+  FUNC_ATTR_NONNULL_ALL+{+  size_t size = src_size;++  RBUFFER_UNTIL_FULL(buf, wptr, wcnt) {+    size_t copy_count = MIN(src_size, wcnt);+    memcpy(wptr, src, copy_count);+    rbuffer_produced(buf, copy_count);++    if (!(src_size -= copy_count)) {+      return size;+    }++    src += copy_count;+  }++  return size - src_size;+}++size_t rbuffer_read(RBuffer *buf, char *dst, size_t dst_size)+  FUNC_ATTR_NONNULL_ALL+{+  size_t size = dst_size;++  RBUFFER_UNTIL_EMPTY(buf, rptr, rcnt) {+    size_t copy_count = MIN(dst_size, rcnt);+    memcpy(dst, rptr, copy_count);+    rbuffer_consumed(buf, copy_count);++    if (!(dst_size -= copy_count)) {+      return size;+    }++    dst += copy_count;+  }++  return size - dst_size;+}++char *rbuffer_get(RBuffer *buf, size_t index) FUNC_ATTR_NONNULL_ALL+{+  assert(index < buf->size);+  size_t rcnt;+  (void)rbuffer_read_ptr(buf, &rcnt);+  return index < rcnt ?  buf->read_ptr + index : buf->start_ptr + index - rcnt;+}++int rbuffer_cmp(RBuffer *buf, const char *str, size_t count) FUNC_ATTR_NONNULL_ALL+{+  size_t rcnt;+  (void)rbuffer_read_ptr(buf, &rcnt);+  size_t n = MIN(count, rcnt);+  int rv = memcmp(str, buf->read_ptr, n);+  count -= n;+  size_t remaining = buf->size - rcnt;++  if (rv || !count || !remaining) {+    return rv;+  }++  return memcmp(str + n, buf->start_ptr, MIN(count, remaining));","> If always count <= buf->size, MIN(...) could be replaced with count. Otherwise a longer string could still match a shorter buffer. Is this intentional (see unittest:+1: , I will just add an assertion for count <= buf->size(the caller should check `rbuffer_size`)> If the string is longer than the buffer, how do we know the rest of it isn't coming down the pipe?This is only supposed to compare the current RBuffer contents",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2650,30695474,2015-05-20T12:27:56Z,test/unit/rbuffer_spec.lua,"@@ -0,0 +1,354 @@+local helpers = require(""test.unit.helpers"")++local ffi     = helpers.ffi+local eq      = helpers.eq++local rbuffer = helpers.cimport(""./test/unit/helpers/rbuffer.h"")++describe('rbuffer functions', function()+  local capacity = 16+  local c_char = ffi.typeof('char[?]')+  local rbuf++  local function inspect()+    return ffi.string(rbuf.start_ptr, capacity)+  end++  local function write(str)+    local len = string.len(str)+    local buf = c_char(len, str)+    return rbuffer.rbuffer_write(rbuf, buf, len)+  end++  local function read(len)+    local buf = c_char(len)+    len = rbuffer.rbuffer_read(rbuf, buf, len)+    return ffi.string(buf, len)+  end++  local function get(idx)+    return ffi.string(rbuffer.rbuffer_get(rbuf, idx), 1)+  end++  before_each(function()+    -- rbuf = ffi.gc(rbuffer.rbuffer_new(capacity), rbuffer.rbuffer_free)+    rbuf = rbuffer.rbuffer_new(capacity)+    -- fill the internal buffer with the character '0' to simplify inspecting+    ffi.C.memset(rbuf.start_ptr, string.byte('0'), capacity)+  end)++  describe('RBUFFER_UNTIL_FULL', function()+    local chunks++    local function collect_write_chunks()+      rbuffer.ut_rbuffer_each_write_chunk(rbuf, function(wptr, wcnt)+        table.insert(chunks, ffi.string(wptr, wcnt))+      end)+    end++    before_each(function()+      chunks = {}+    end)++    describe('with empty buffer in one contiguous chunk', function()+      it('is called once with the empty chunk', function()+        collect_write_chunks()+        eq({'0000000000000000'}, chunks)+      end)+    end)++    describe('with partially empty buffer in one contiguous chunk', function()+      before_each(function()+        write('string')+      end)++      it('is called once with the empty chunk', function()+        collect_write_chunks()+        eq({'0000000000'}, chunks)+      end)+    end)++    describe('with filled buffer in one contiguous chunk', function()+      before_each(function()+        write('abcdefghijklmnopq')+      end)++      it('is not called', function()+        collect_write_chunks()+        eq({}, chunks)+      end)+    end)++    describe('with buffer partially empty in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(8)+      end)++      it('is called twice with each filled chunk', function()+        collect_write_chunks()+        eq({'000000', '12345678'}, chunks)+      end)+    end)++    describe('with buffer empty in two contiguous chunks', function()+      before_each(function()+        write('12345678')+        read(8)+      end)++      it('is called twice with each filled chunk', function()+        collect_write_chunks()+        eq({'00000000', '12345678'}, chunks)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('12345678')+        read(8)+        write('abcdefghijklmnopq')+      end)++      it('is not called', function()+        collect_write_chunks()+        eq({}, chunks)+      end)+    end)+  end)++  describe('RBUFFER_UNTIL_EMPTY', function()+    local chunks++    local function collect_read_chunks()+      rbuffer.ut_rbuffer_each_read_chunk(rbuf, function(rptr, rcnt)+        table.insert(chunks, ffi.string(rptr, rcnt))+      end)+    end++    before_each(function()+      chunks = {}+    end)++    describe('with empty buffer', function()+      it('is not called', function()+        collect_read_chunks()+        eq({}, chunks)+      end)+    end)++    describe('with partially filled buffer in one contiguous chunk', function()+      before_each(function()+        write('string')+      end)++      it('is called once with the filled chunk', function()+        collect_read_chunks()+        eq({'string'}, chunks)+      end)+    end)++    describe('with filled buffer in one contiguous chunk', function()+      before_each(function()+        write('abcdefghijklmnopq')+      end)++      it('is called once with the filled chunk', function()+        collect_read_chunks()+        eq({'abcdefghijklmnop'}, chunks)+      end)+    end)++    describe('with buffer partially filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('is called twice with each filled chunk', function()+        collect_read_chunks()+        eq({'long s', 'tring'}, chunks)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('12345678')+        read(8)+        write('abcdefghijklmnopq')+      end)++      it('is called twice with each filled chunk', function()+        collect_read_chunks()+        eq({'abcdefgh', 'ijklmnop'}, chunks)+      end)+    end)+  end)++  describe('RBUFFER_EACH', function()+    local chars++    local function collect_chars()+      rbuffer.ut_rbuffer_each(rbuf, function(c, i)+        table.insert(chars, {string.char(c), tonumber(i)})+      end)+    end+    before_each(function()+      chars = {}+    end)++    describe('with empty buffer', function()+      it('is not called', function()+        collect_chars()+        eq({}, chars)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('collects each character and index', function()+        collect_chars()+        eq({{'l', 0}, {'o', 1}, {'n', 2}, {'g', 3}, {' ', 4}, {'s', 5},+            {'t', 6}, {'r', 7}, {'i', 8}, {'n', 9}, {'g', 10}}, chars)+      end)+    end)+  end)++  describe('RBUFFER_EACH_REVERSE', function()+    local chars++    local function collect_chars()+      rbuffer.ut_rbuffer_each_reverse(rbuf, function(c, i)+        table.insert(chars, {string.char(c), tonumber(i)})+      end)+    end+    before_each(function()+      chars = {}+    end)++    describe('with empty buffer', function()+      it('is not called', function()+        collect_chars()+        eq({}, chars)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('collects each character and index', function()+        collect_chars()+        eq({{'g', 10}, {'n', 9}, {'i', 8}, {'r', 7}, {'t', 6}, {'s', 5},+            {' ', 4}, {'g', 3}, {'n', 2}, {'o', 1}, {'l', 0}}, chars)+      end)+    end)+  end)++  describe('rbuffer_cmp', function()+    local function cmp(str)+      local len = string.len(str)+      local rv = rbuffer.rbuffer_cmp(rbuf, c_char(len, str), len)+      if rv == 0 then+        return 0+      else+        return rv / math.abs(rv)+      end+    end++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('compares the common longest sequence', function()+        eq(0, cmp('long string'))+        eq(0, cmp('long strin'))+        eq(-1, cmp('long striM'))+        eq(1, cmp('long strio'))+        eq(0, cmp('long'))+        eq(-1, cmp('lonG'))+        eq(1, cmp('lonh'))+        eq(0, cmp('long string2'))","This test will now fail, because the string is longer than the buffer content.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2650,30695490,2015-05-20T12:28:12Z,test/unit/rbuffer_spec.lua,"@@ -0,0 +1,354 @@+local helpers = require(""test.unit.helpers"")++local ffi     = helpers.ffi+local eq      = helpers.eq++local rbuffer = helpers.cimport(""./test/unit/helpers/rbuffer.h"")++describe('rbuffer functions', function()+  local capacity = 16+  local c_char = ffi.typeof('char[?]')+  local rbuf++  local function inspect()+    return ffi.string(rbuf.start_ptr, capacity)+  end++  local function write(str)+    local len = string.len(str)+    local buf = c_char(len, str)+    return rbuffer.rbuffer_write(rbuf, buf, len)+  end++  local function read(len)+    local buf = c_char(len)+    len = rbuffer.rbuffer_read(rbuf, buf, len)+    return ffi.string(buf, len)+  end++  local function get(idx)+    return ffi.string(rbuffer.rbuffer_get(rbuf, idx), 1)+  end++  before_each(function()+    -- rbuf = ffi.gc(rbuffer.rbuffer_new(capacity), rbuffer.rbuffer_free)+    rbuf = rbuffer.rbuffer_new(capacity)+    -- fill the internal buffer with the character '0' to simplify inspecting+    ffi.C.memset(rbuf.start_ptr, string.byte('0'), capacity)+  end)++  describe('RBUFFER_UNTIL_FULL', function()+    local chunks++    local function collect_write_chunks()+      rbuffer.ut_rbuffer_each_write_chunk(rbuf, function(wptr, wcnt)+        table.insert(chunks, ffi.string(wptr, wcnt))+      end)+    end++    before_each(function()+      chunks = {}+    end)++    describe('with empty buffer in one contiguous chunk', function()+      it('is called once with the empty chunk', function()+        collect_write_chunks()+        eq({'0000000000000000'}, chunks)+      end)+    end)++    describe('with partially empty buffer in one contiguous chunk', function()+      before_each(function()+        write('string')+      end)++      it('is called once with the empty chunk', function()+        collect_write_chunks()+        eq({'0000000000'}, chunks)+      end)+    end)++    describe('with filled buffer in one contiguous chunk', function()+      before_each(function()+        write('abcdefghijklmnopq')+      end)++      it('is not called', function()+        collect_write_chunks()+        eq({}, chunks)+      end)+    end)++    describe('with buffer partially empty in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(8)+      end)++      it('is called twice with each filled chunk', function()+        collect_write_chunks()+        eq({'000000', '12345678'}, chunks)+      end)+    end)++    describe('with buffer empty in two contiguous chunks', function()+      before_each(function()+        write('12345678')+        read(8)+      end)++      it('is called twice with each filled chunk', function()+        collect_write_chunks()+        eq({'00000000', '12345678'}, chunks)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('12345678')+        read(8)+        write('abcdefghijklmnopq')+      end)++      it('is not called', function()+        collect_write_chunks()+        eq({}, chunks)+      end)+    end)+  end)++  describe('RBUFFER_UNTIL_EMPTY', function()+    local chunks++    local function collect_read_chunks()+      rbuffer.ut_rbuffer_each_read_chunk(rbuf, function(rptr, rcnt)+        table.insert(chunks, ffi.string(rptr, rcnt))+      end)+    end++    before_each(function()+      chunks = {}+    end)++    describe('with empty buffer', function()+      it('is not called', function()+        collect_read_chunks()+        eq({}, chunks)+      end)+    end)++    describe('with partially filled buffer in one contiguous chunk', function()+      before_each(function()+        write('string')+      end)++      it('is called once with the filled chunk', function()+        collect_read_chunks()+        eq({'string'}, chunks)+      end)+    end)++    describe('with filled buffer in one contiguous chunk', function()+      before_each(function()+        write('abcdefghijklmnopq')+      end)++      it('is called once with the filled chunk', function()+        collect_read_chunks()+        eq({'abcdefghijklmnop'}, chunks)+      end)+    end)++    describe('with buffer partially filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('is called twice with each filled chunk', function()+        collect_read_chunks()+        eq({'long s', 'tring'}, chunks)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('12345678')+        read(8)+        write('abcdefghijklmnopq')+      end)++      it('is called twice with each filled chunk', function()+        collect_read_chunks()+        eq({'abcdefgh', 'ijklmnop'}, chunks)+      end)+    end)+  end)++  describe('RBUFFER_EACH', function()+    local chars++    local function collect_chars()+      rbuffer.ut_rbuffer_each(rbuf, function(c, i)+        table.insert(chars, {string.char(c), tonumber(i)})+      end)+    end+    before_each(function()+      chars = {}+    end)++    describe('with empty buffer', function()+      it('is not called', function()+        collect_chars()+        eq({}, chars)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('collects each character and index', function()+        collect_chars()+        eq({{'l', 0}, {'o', 1}, {'n', 2}, {'g', 3}, {' ', 4}, {'s', 5},+            {'t', 6}, {'r', 7}, {'i', 8}, {'n', 9}, {'g', 10}}, chars)+      end)+    end)+  end)++  describe('RBUFFER_EACH_REVERSE', function()+    local chars++    local function collect_chars()+      rbuffer.ut_rbuffer_each_reverse(rbuf, function(c, i)+        table.insert(chars, {string.char(c), tonumber(i)})+      end)+    end+    before_each(function()+      chars = {}+    end)++    describe('with empty buffer', function()+      it('is not called', function()+        collect_chars()+        eq({}, chars)+      end)+    end)++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('collects each character and index', function()+        collect_chars()+        eq({{'g', 10}, {'n', 9}, {'i', 8}, {'r', 7}, {'t', 6}, {'s', 5},+            {' ', 4}, {'g', 3}, {'n', 2}, {'o', 1}, {'l', 0}}, chars)+      end)+    end)+  end)++  describe('rbuffer_cmp', function()+    local function cmp(str)+      local len = string.len(str)+      local rv = rbuffer.rbuffer_cmp(rbuf, c_char(len, str), len)+      if rv == 0 then+        return 0+      else+        return rv / math.abs(rv)+      end+    end++    describe('with buffer filled in two contiguous chunks', function()+      before_each(function()+        write('1234567890')+        read(10)+        write('long string')+      end)++      it('compares the common longest sequence', function()+        eq(0, cmp('long string'))+        eq(0, cmp('long strin'))+        eq(-1, cmp('long striM'))+        eq(1, cmp('long strio'))+        eq(0, cmp('long'))+        eq(-1, cmp('lonG'))+        eq(1, cmp('lonh'))+        eq(0, cmp('long string2'))+      end)+    end)++    describe('with empty buffer', function()+      it('returns 0 since no characters are compared', function()+        eq(0, cmp('string'))","This test will now fail, because the string is longer than the buffer content.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2714,30741661,2015-05-20T19:52:20Z,src/nvim/sha256.c,"@@ -8,8 +8,6 @@ /// at your choice. /// /// Vim specific notes:-/// Functions exported by this file:-///  2. sha2_seed() generates a random header. /// sha256_self_test() is implicitly called once.  #include <stddef.h>        // for size_t",The `stdlib.h` and `nvim/os/time.h` includes also seem unused.,
116258,steveno,https://api.github.com/repos/neovim/neovim/pulls/810,30747951,2015-05-20T20:52:12Z,.ci/mingw.sh,"@@ -1,18 +1,22 @@ . ""$CI_SCRIPTS/common.sh"" -# FIXME: When Travis gets a recent version of Mingw-w64 use this-#sudo apt-get install binutils-mingw-w64-i686 gcc-mingw-w64-i686 g++-mingw-w64-i686 mingw-w64-dev mingw-w64-tools-#sudo apt-get install wine-sudo apt-get install libc6-dev-i386--# mingw-w64 build from http://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/-wget ""http://downloads.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/rubenvb/gcc-4.8-release/i686-w64-mingw32-gcc-4.8.0-linux64_rubenvb.tar.xz"" -O mingw.tar.xz-sudo tar -axf mingw.tar.xz -C /opt+sudo add-apt-repository ppa:tobydox/mingw-x-precise -y+sudo apt-get update -q+sudo apt-get install mingw32-x-gcc mingw32-x-binutils mingw32-x-runtime export PATH=$PATH:/opt/mingw32/bin +# Needed system headers e.g bits/predefs.h+sudo apt-get install libc6-dev-i386+ # Build third-party mkdir .deps cd .deps cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/mingw32-w64-cross-travis.toolchain.cmake ../third-party/ cmake --build . cd ..++# Build Neovim+mkdir build+cd build+cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/mingw32-w64-cross-travis.toolchain.cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_FLAGS=""-DMIN_LOG_LEVEL=0 -pg"" ..+cmake --build .","Would this not work?```cmake --build .. -DCMAKE_TOOLCHAIN_FILE=../cmake/mingw32-w64-cross-travis.toolchain.cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_FLAGS=""-DMIN_LOG_LEVEL=0 -pg""```",
116258,steveno,https://api.github.com/repos/neovim/neovim/pulls/810,30749898,2015-05-20T21:11:29Z,src/nvim/vim.h,"@@ -8,8 +8,12 @@ #ifndef NVIM_VIM_H # define NVIM_VIM_H -#define MIN(X, Y) (X < Y ? X : Y)-#define MAX(X, Y) (X > Y ? X : Y)+#ifndef MIN+# define MIN(X, Y) (X < Y ? X : Y)+#endif+#ifndef MAX+# define MAX(X, Y) (X > Y ? X : Y)","These need parens around the parameters, and might be better off in `macros.h`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2715,30774080,2015-05-21T05:40:35Z,config/config.h.in,"@@ -27,7 +27,6 @@ #cmakedefine HAVE_LANGINFO_H #cmakedefine HAVE_LIBGEN_H #cmakedefine HAVE_LOCALE_H-#cmakedefine HAVE_LSTAT #cmakedefine HAVE_NL_LANGINFO_CODESET #cmakedefine HAVE_NL_MSG_CAT_CNTR #define HAVE_OSPEED 1",This and `HAVE_SIGVEC` look unused too.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2650,30791878,2015-05-21T11:02:44Z,src/nvim/tui/term_input.inl,"@@ -236,19 +235,25 @@ static void read_cb(RStream *rstream, void *rstream_data, bool eof)     if (handle_bracketed_paste(input) || handle_forced_escape(input)) {       continue;     }-    char *ptr = rbuffer_read_ptr(input->read_buffer);-    size_t len = rbuffer_pending(input->read_buffer);+     // Find the next 'esc' and push everything up to it(excluding)-    size_t i;-    for (i = ptr[0] == ESC ? 1 : 0; i < len; i++) {-      if (ptr[i] == '\x1b') {+    size_t count;+    RBUFFER_EACH(buf, c, i) {+      count = i + 1;+      if (c == '\x1b') {+        break;+      }+    }++    RBUFFER_UNTIL_EMPTY(input->read_buffer, ptr, len) {+      size_t consumed = termkey_push_bytes(input->tk, ptr, MIN(count, len));+      rbuffer_consumed(input->read_buffer, consumed);+      tk_getkeys(input, false);","If I put `tk_getkeys` after, it's possible that libtermkey input buffer will be filled before `count` is consumed, so we'll enter an infinite loop(`termkey_push_bytes` will return 0, waiting for `tk_getkeys` to process the buffered data)",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2683,30829584,2015-05-21T18:06:31Z,src/nvim/terminal.c,"@@ -293,11 +293,11 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)   vterm_get_size(term->vt, &curheight, &curwidth);    if (!width) {-    width = (uint16_t)curwidth;+    width = UINT16_MAX;   }    if (!height) {-    height = (uint16_t)curheight;+    height = UINT16_MAX;","Maybe a better strategy would be to remove the `width` and `height` parameters and set them to `UINT16_MAX` unconditionally. In the four call sites of `terminal_resize()`, two pass `0` and `0`, and the other two pass the height or width of the window being resized. However, even if we know the height of _a_ window being resized, we must still check every window, so it doesn't really save us anything.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2683,30831364,2015-05-21T18:22:27Z,src/nvim/terminal.c,"@@ -907,6 +928,16 @@ static void on_refresh(Event event)       }       continue;     }+    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+      if (wp->w_buffer == term->buf) {+        if ( wp->w_botline > wp->w_buffer->b_ml.ml_line_count ) {+          // if last line is visible, follow the terminal+          wp->following_terminal = true;+        } else {+          wp->following_terminal = false;+        }","Typically, terminals only scroll when the cursor is at the last line, Also, not sure I want unfocused windows being scrolled. I might split a terminal buffer for the specific purpose of keeping the cursor at its current position as an alternative to running `$ cmd-with-long-output | less`.",
3795966,frederikvs,https://api.github.com/repos/neovim/neovim/pulls/2683,30841077,2015-05-21T20:00:54Z,src/nvim/terminal.c,"@@ -907,6 +928,16 @@ static void on_refresh(Event event)       }       continue;     }+    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+      if (wp->w_buffer == term->buf) {+        if ( wp->w_botline > wp->w_buffer->b_ml.ml_line_count ) {+          // if last line is visible, follow the terminal+          wp->following_terminal = true;+        } else {+          wp->following_terminal = false;+        }","In some situations you don't want the unfocused window to scroll, as you described. However, in some situations you do, e.g. I've started a rather long-running command (e.g. a make) and I want to make some minor changes to other files, while monitoring the output. Then I don't want to have to ""jump to the terminal window, go down, jump back"" every once in a while to know what's going on, I want the window to scroll.That's why I chose this solution : if the last line of the output (probably the line where the terminal is adding its stuff) is visible in the vim window, we'll follow what's going on. If you don't want the window to scroll, ensure that the last line is not visible. That's behavior I've seen in a number of terminal emulators that I was very happy with :-)",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2683,30844302,2015-05-21T20:32:58Z,src/nvim/terminal.c,"@@ -907,6 +928,16 @@ static void on_refresh(Event event)       }       continue;     }+    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {+      if (wp->w_buffer == term->buf) {+        if ( wp->w_botline > wp->w_buffer->b_ml.ml_line_count ) {+          // if last line is visible, follow the terminal+          wp->following_terminal = true;+        } else {+          wp->following_terminal = false;+        }","I see. Well, I'd be appeased if the terminal only scrolled when the cursor sat on the last line, and preferably only if at the end, so I could split the window and just move one line up to disable scrolling. If the terminal only has one line, I could just move to the left.Worst case, we could make it a buffer-local option whether to scroll unconditionally, but that doesn't seem like a nice workflow (`:set noscroll | sp  | *do comamnd*`).",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2574,30861503,2015-05-22T00:25:14Z,src/nvim/memory.h,"@@ -2,6 +2,107 @@ #define NVIM_MEMORY_H  #include <stddef.h>  // for size_t+#include <string.h>+#include <strings.h>++#include ""nvim/func_attr.h""++#ifdef HAVE_CONFIG_H+# include ""auto/config.h""  // for the HAVE_* macros+#endif++// defines to avoid typecasts from (char_u *) to (char *) and back+// (vim_strchr() and vim_strrchr() are now in alloc.c)+#define STRLEN(s)           strlen((char *)(s))+#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))+#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))+#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))+#define STRCMP(d, s)        strcmp((char *)(d), (char *)(s))+#define STRNCMP(d, s, n)    strncmp((char *)(d), (char *)(s), (size_t)(n))++#if defined(HAVE_STRCASECMP)+# define STRICMP(d, s)      strcasecmp((char *)(d), (char *)(s))+#elif defined(HAVE_STRICMP)+# define STRICMP(d, s)     stricmp((char *)(d), (char *)(s))+#elif defined(HAVE_U_STRICMP)+# define STRICMP(d, s)     _stricmp((char *)(d), (char *)(s))+#else+# error ""strcasecmp/stricmp are undefined. Please file a bug report.""+#endif++/// Like strcpy() but allows overlapped source and destination.+#define STRMOVE(d, s)       memmove((d), (s), STRLEN(s) + 1)++#if defined(HAVE_STRNCASECMP)+# define STRNICMP(d, s, n)  strncasecmp((char *)(d), (char *)(s), (size_t)(n))+#elif defined(HAVE_STRNICMP)+# define STRNICMP(d, s, n) strnicmp((char *)(d), (char *)(s), (size_t)(n))+#elif defined(HAVE_U_STRNICMP)+# define STRICMP(d, s)     _strnicmp((char *)(d), (char *)(s))",Are you sure this has the correct amount of arguments? I'm confused after looking here:https://msdn.microsoft.com/en-us/library/chd90w8e.aspx,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2563,30950270,2015-05-24T05:19:16Z,src/nvim/eval.c,"@@ -16365,6 +16373,26 @@ void set_vim_var_list(int idx, list_T *val)     ++val->lv_refcount; } +/// Set Dictionary v: variable to ""val"".+void set_vim_var_dict(int idx, dict_T *val)+{+  dict_unref(vimvars[idx].vv_dict);++  // Set readonly+  int todo = (int)val->dv_hashtab.ht_used;+  for (hashitem_T *hi = val->dv_hashtab.ht_array; todo > 0 ; ++hi) {+    if (!HASHITEM_EMPTY(hi)) {+      --todo;+      HI2DI(hi)->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;+    }","@Shougo My mistake, I should have looked first. I see now that you are using the pattern used commonly in the codebase.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2719,30952889,2015-05-24T14:44:29Z,test/functional/legacy/057_spec.lua,"@@ -0,0 +1,973 @@+-- Tests for :sort command.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('57', function()",Change to `describe(':sort')` (and rename file to `057_sort_spec.lua`)? Or something similar..,
3795966,frederikvs,https://api.github.com/repos/neovim/neovim/pulls/2683,30952890,2015-05-24T14:44:47Z,src/nvim/buffer_defs.h,"@@ -1158,6 +1158,12 @@ struct window_S {    * In a non-location list window, w_llist_ref is NULL.    */   qf_info_T   *w_llist_ref;++  /*+   * Are we following the terminal? (Only valid if w_buffer is a terminal+   * buffer.)+   */+  bool following_terminal;","Indeed, we need to decide for each window whether it is following the terminal at that moment in time... A variable that's tied to the buffer is too broad.If there are any suggestions for window-local variables that could be reused, I'll gladly switch. I had a quick look at what's already in the `struct window_S`, and could find nothing that's obviously suitable. OTOH my knowledge of those data structures is rather limited, so I could have missed something...",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2719,30952910,2015-05-24T14:47:52Z,test/functional/legacy/057_spec.lua,"@@ -0,0 +1,973 @@+-- Tests for :sort command.++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('57', function()+  setup(clear)++  it('is working', function()+    insert([=[+      t01: alphebetical+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t02: numeric+      abc+      ab+      a321+      a123+      a122+      a+      x-22+      b321+      b123+      +      c123d+      -24+       123b+      c321d+      0+      b322b+      b321+      b321b+      +      +      t03: hexadecimal+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t04: alpha, unique+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t05: alpha, reverse+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t06: numeric, reverse+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t07: unique, reverse+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t08: octal+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t09: reverse, hexadecimal+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t10: alpha, skip first character+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t11: alpha, skip first 2 characters+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t12: alpha, unique, skip first 2 characters+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t13: numeric, skip first character+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t14: alpha, sort on first character+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t15: alpha, sort on first 2 characters+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t16: numeric, sort on first character+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t17: alpha, skip past first digit+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t18: alpha, sort on first digit+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t19: numeric, skip past first digit+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t20: numeric, sort on first digit+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t21: alpha, skip past first 2 digits+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t22: numeric, skip past first 2 digits+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t23: hexadecimal, skip past first 2 digits+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t24: alpha, sort on first 2 digits+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t25: numeric, sort on first 2 digits+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t26: hexadecimal, sort on first 2 digits+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t27: wrong arguments+      abc+      ab+      a+      a321+      a123+      a122+      b321+      b123+      c123d+       123b+      c321d+      b322b+      b321+      b321b+      +      +      t28: done+      ]=])++    --execute('so small.vim')++    source([[","I think it would be better to use `execute()` here (AFAIR you can execute multiple commands after one another if you chain them with commas, like `execute('/.../', '/...')`. `source` will write a temporary file, which is a bit of overhead I think we can avoid here.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2652,30952948,2015-05-24T14:53:44Z,src/nvim/charset.c,"@@ -1049,29 +1049,54 @@ int win_lbr_chartabsize(win_T *wp, char_u *line, char_u *s, colnr_T col, int *he   added = 0;    if ((*p_sbr != NUL || wp->w_p_bri) && wp->w_p_wrap && (col != 0)) {-    numberextra = win_col_off(wp);+    colnr_T sbrlen = 0;+    int numberwidth = win_col_off(wp);++    numberextra = numberwidth;     col += numberextra + mb_added;      if (col >= (colnr_T)wp->w_width) {       col -= wp->w_width;       numberextra = wp->w_width - (numberextra - win_col_off2(wp));-      if (numberextra > 0) {+      if (col >= numberextra && numberextra > 0) {         col %= numberextra;       }       if (*p_sbr != NUL) {-        colnr_T sbrlen = (colnr_T)MB_CHARLEN(p_sbr);-        if (col >= sbrlen)+        sbrlen = (colnr_T)MB_CHARLEN(p_sbr);+        if (col >= sbrlen) {           col -= sbrlen;+        }       }-      if (numberextra > 0) {-        col = col % numberextra;+      if (col >= numberextra && numberextra > 0) {+        col %= numberextra;+      } else if (col > 0 && numberextra > 0) {+        col += numberwidth - win_col_off2(wp);       }++      numberwidth -= win_col_off2(wp);     } -    if ((col == 0) || (col + size > (colnr_T)wp->w_width)) {+    if (col == 0 || (col + size + sbrlen > (colnr_T)wp->w_width)) {","Apparently we introduced braces around the conditions somewhere? Not sure if we have a style rule somewhere, but the way you changed it makes sense to me.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2653,30952975,2015-05-24T14:58:35Z,src/nvim/regexp_nfa.c,"@@ -5742,17 +5742,28 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm            // Bail out quickly when there can't be a match, avoid the overhead of           // win_linetabsize() on long lines.-          if ((col > t->state->val && op != 1)-              || (col - 1 > t->state->val && op == 1)) {+          if (op != 1 && col > t->state->val) {             break;           }-          uintmax_t lts = win_linetabsize(reg_win == NULL ? curwin : reg_win,-                                          regline,-                                          col);-          assert(t->state->val >= 0);-          result = nfa_re_num_cmp((uintmax_t)t->state->val,-                                  op,-                                  lts + 1);++          result = FALSE;+          win_T *wp = reg_win == NULL ? curwin : reg_win;+          if (op == 1 && col - 1 > t->state->val && col > 100) {+            assert(wp->w_buffer->b_p_ts <= INT_MAX);",":+1:Hm, on second thought, couldn't you also just create `ts` as `long ts`?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2650,30953764,2015-05-24T16:49:06Z,src/nvim/tui/term_input.inl,"@@ -236,19 +235,29 @@ static void read_cb(RStream *rstream, void *rstream_data, bool eof)     if (handle_bracketed_paste(input) || handle_forced_escape(input)) {       continue;     }-    char *ptr = rbuffer_read_ptr(input->read_buffer);-    size_t len = rbuffer_pending(input->read_buffer);-    // Find the next 'esc' and push everything up to it(excluding)-    size_t i;-    for (i = ptr[0] == ESC ? 1 : 0; i < len; i++) {-      if (ptr[i] == '\x1b') {++    // Find the next 'esc' and push everything up to it(excluding). This is done+    // so the `handle_bracketed_paste`/`handle_forced_escape` calls above work+    // as expected.+    size_t count;+    RBUFFER_EACH(input->read_buffer, c, i) {+      count = i + 1;+      if (c == '\x1b' && count > 1) {+        break;+      }+    }++    RBUFFER_UNTIL_EMPTY(input->read_buffer, ptr, len) {+      size_t consumed = termkey_push_bytes(input->tk, ptr, MIN(count, len));","`termkey_push_bytes()` could return a value bigger than `input->read_buffer->size`, so the following call to `rbuffer_consumed()` would fail.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2720,30955168,2015-05-24T19:43:49Z,runtime/doc/nvim-extra-keymaps.txt,"@@ -0,0 +1,35 @@+*nvim-extra-keymaps.txt*    Extra default keymaps                        {Nvim}+For nvim.    Last change:      2015 May++*nvim-extra-keymaps*++The `plugin/extra-keymaps.vim` script provides a few extra keymaps that might+be useful and tries to fix some issues the community has identified with vim's+default keymaps.++The user can disable the plugin by having >++    let g:nvim#defaults#maps#use = 0++in their |vimrc| (additionally, all features can be disabled separately,+using the variables described below).++=============================================================================+The keymaps provided are:++                                        *gr:nvim#defaults#maps#leave_term_mode*+1. Leave |terminal-mode| using <esc><esc>, besides the usual  CTRL-\ CTRL-N+   (see |c_CTRL_\_CTRL_N|).++                                                  *g:nvim#defaults#maps#Y_eol*+2. |Y| yanks to the end of line.++                                            *g:nvim#defaults#maps#undo_ctrl_u*+3. <C-u> can be undoed. (see |i_CTRL-U|)++                                             *g:nvim#defaults#maps#smart_home*+4. <Home> goes to the beginning of the text on first press and the beginning","It means the first non-space character in the current line. I took it from the initial description of the mapping, I can see how it's ambiguous. :+1:",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2598,30957731,2015-05-25T00:55:47Z,src/nvim/os/stream.c,"@@ -0,0 +1,26 @@+// Functions for working with stdio streams (as opposed to RStream/WStream).++#include <stdio.h>+#include <stdbool.h>++#include <uv.h>++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/stream.c.generated.h""+#endif++/// Sets the stream associated with `fd` to ""blocking"" mode.+///+/// @return `0` on success, or `-errno` on failure.+int stream_set_blocking(int fd, bool blocking)+{+  int flags = fcntl(fd, F_GETFL, 0);+  int err = 0;+  if (!blocking && !(flags & O_NONBLOCK)) {+    err = fcntl(fd, F_SETFL, flags | O_NONBLOCK);+  } else if (blocking && (flags & O_NONBLOCK)) {+    err = fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);","Here I'm calling `fcntl` instead of the previous libuv-based implementation (see below for reference), because in the case where some component other than `main.c` was setting `stderr` to non-blocking, using the libuv-based implementation would result in this runtime assertion:```.deps/build/src/libuv/src/unix/core.c:833: uv__io_stop: Assertion `loop->watchers[w->fd] == w' failed.```**As best as I can guess,** this is some sort of conflict with an existing handle in libuv.I'd much prefer to use the libuv-based solution, but this is a temporary band-aid to fix an important bug. There's a remote possibility that it's a libuv bug: https://github.com/joyent/libuv/issues/838#issuecomment-58621040 More likely it is related to use of a watcher on the same `fd`, but the watcher is not being stopped before `stream_set_blocking()` is called. More details: https://github.com/yfinkelstein/node-zookeeper/pull/101---libuv-based implementation:```  int stream_set_blocking(int fd, bool blocking)  {    uv_pipe_t stream;    uv_pipe_init(uv_default_loop(), &stream, 0);    uv_pipe_open(&stream, fd);    int retval = uv_stream_set_blocking((uv_stream_t *)&stream, blocking);    uv_close((uv_handle_t *)&stream, NULL);    return retval;  }```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2735,30959194,2015-05-25T02:18:52Z,runtime/autoload/provider/pythonx.vim,"@@ -43,15 +54,17 @@ function! s:check_version(prog, ver, skip) abort         \ ' -c ""import sys; sys.stdout.write(str(sys.version_info[0]) + '.         \ '\"".\"" + str(sys.version_info[1]))""'   let min_version = (a:ver == 2) ? '2.6' : '3.3'-  if system(a:prog . get_version) >= min_version+  let prog_version = system(a:prog . get_version)+  if prog_version =~ '^' . a:ver && prog_version >= min_version     return [1, '']   endif-  return [0, 'Python ' . get_version . ' interpreter is not supported.']+  return [0, 'The Python ' . prog_version . ' interpreter ' . a:prog .+        \ ' is not suitable for providing support for Python ' . a:ver . '.'] endfunction  function! s:check_interpreter(prog, ver, skip) abort   if !executable(a:prog)-    return [0, 'Python'.a:ver.' interpreter is not executable.']+    return [0, 'The Python interpreter ' . a:prog . ' is not executable.']","I suggest leaving out ""The"", it's almost always a waste of space. I sympathize with the desire for a professional voice, but I think it's totally acceptable in technical messages to leave out articles if the meaning is clear, and the extra space needed usually does more harm than good.",
1483271,glts,https://api.github.com/repos/neovim/neovim/pulls/2653,30969790,2015-05-25T08:56:24Z,src/nvim/regexp_nfa.c,"@@ -5742,17 +5742,28 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm            // Bail out quickly when there can't be a match, avoid the overhead of           // win_linetabsize() on long lines.-          if ((col > t->state->val && op != 1)-              || (col - 1 > t->state->val && op == 1)) {+          if (op != 1 && col > t->state->val) {             break;           }-          uintmax_t lts = win_linetabsize(reg_win == NULL ? curwin : reg_win,-                                          regline,-                                          col);-          assert(t->state->val >= 0);-          result = nfa_re_num_cmp((uintmax_t)t->state->val,-                                  op,-                                  lts + 1);++          result = FALSE;+          win_T *wp = reg_win == NULL ? curwin : reg_win;+          if (op == 1 && col - 1 > t->state->val && col > 100) {+            assert(wp->w_buffer->b_p_ts <= INT_MAX);+            int ts = (int)wp->w_buffer->b_p_ts;++            // Guess that a character won't use more columns than 'tabstop',+            // with a minimum of 4.+            if (ts < 4) {+              ts = 4;+            }+            result = col > t->state->val * ts;","> Hm, on second thought, couldn't you also just create `ts` as `long ts`?It does seem so, yes. Just to be sure: making `ts` a `long` doesn't create a problem here, does it? the comparison will be done in `long`, won't it?",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2549,30970916,2015-05-25T09:24:48Z,runtime/autoload/provider/pythonx.vim,"@@ -13,19 +13,21 @@ function! provider#pythonx#Detect(ver) abort   let skip = exists(skip_var) ? {skip_var} : 0   if exists(host_var)     "" Disable auto detection-    let [check, err] = s:check_interpreter({host_var}, a:ver, skip)+    let [check, err, _] = s:check_interpreter({host_var}, a:ver, skip)     return check ? [{host_var}, err] : ['', err]   endif    let detect_versions = (a:ver == 2) ?-        \   ['2.7', '2.6', '2', '']-        \ : ['3.5', '3.4', '3.3', '3.2', '3', '']+        \   ['2', '2.7', '2.6', '']","> In my case as long as you test 2.6 and 2.7 before 'python' it would work (or in the worst case I can make it work without too much trouble and maintenance). Thanks for asking @jonthn It would work even if 'python' is tested before 2.7, as only 2.7 would have installed the `neovim` module, right?",
1408847,jonthn,https://api.github.com/repos/neovim/neovim/pulls/2549,30971467,2015-05-25T09:38:27Z,runtime/autoload/provider/pythonx.vim,"@@ -13,19 +13,21 @@ function! provider#pythonx#Detect(ver) abort   let skip = exists(skip_var) ? {skip_var} : 0   if exists(host_var)     "" Disable auto detection-    let [check, err] = s:check_interpreter({host_var}, a:ver, skip)+    let [check, err, _] = s:check_interpreter({host_var}, a:ver, skip)     return check ? [{host_var}, err] : ['', err]   endif    let detect_versions = (a:ver == 2) ?-        \   ['2.7', '2.6', '2', '']-        \ : ['3.5', '3.4', '3.3', '3.2', '3', '']+        \   ['2', '2.7', '2.6', '']","@fwalch Yes, in my early issue (#1334) up to now it wouldn't have worked but now I have adopted a ""saner"" setup. And as long as fully specified version of python interpreter (e.g. python2.7) are checked it will work ",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2653,30975849,2015-05-25T11:42:15Z,src/nvim/regexp_nfa.c,"@@ -5742,17 +5742,28 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm            // Bail out quickly when there can't be a match, avoid the overhead of           // win_linetabsize() on long lines.-          if ((col > t->state->val && op != 1)-              || (col - 1 > t->state->val && op == 1)) {+          if (op != 1 && col > t->state->val) {             break;           }-          uintmax_t lts = win_linetabsize(reg_win == NULL ? curwin : reg_win,-                                          regline,-                                          col);-          assert(t->state->val >= 0);-          result = nfa_re_num_cmp((uintmax_t)t->state->val,-                                  op,-                                  lts + 1);++          result = FALSE;+          win_T *wp = reg_win == NULL ? curwin : reg_win;+          if (op == 1 && col - 1 > t->state->val && col > 100) {+            assert(wp->w_buffer->b_p_ts <= INT_MAX);+            int ts = (int)wp->w_buffer->b_p_ts;++            // Guess that a character won't use more columns than 'tabstop',+            // with a minimum of 4.+            if (ts < 4) {+              ts = 4;+            }+            result = col > t->state->val * ts;","> the comparison will be done in long, won't it?I believe it will, yes. So I think it should not be a problem.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2598,30977616,2015-05-25T12:34:57Z,src/nvim/os/stream.c,"@@ -0,0 +1,26 @@+// Functions for working with stdio streams (as opposed to RStream/WStream).++#include <stdio.h>+#include <stdbool.h>++#include <uv.h>++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/stream.c.generated.h""+#endif++/// Sets the stream associated with `fd` to ""blocking"" mode.+///+/// @return `0` on success, or `-errno` on failure.+int stream_set_blocking(int fd, bool blocking)+{+  int flags = fcntl(fd, F_GETFL, 0);+  int err = 0;+  if (!blocking && !(flags & O_NONBLOCK)) {+    err = fcntl(fd, F_SETFL, flags | O_NONBLOCK);+  } else if (blocking && (flags & O_NONBLOCK)) {+    err = fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);","> Here I'm calling fcntl instead of the previous libuv-based implementation (see below for reference), because in the case where some component other than main.c was setting stderr to non-blocking, using the libuv-based implementation would result in this runtime assertion:Would it help to create a new loop with `uv_loop_init()` and use it instead of `uv_default_loop()`?``` cint stream_set_blocking(int fd, bool blocking){  uv_pipe_t stream;  uv_loop_t loop;  uv_loop_init(&loop);  uv_pipe_init(&loop, &stream, 0);  uv_pipe_open(&stream, fd);  int retval = uv_stream_set_blocking((uv_stream_t *)&stream, blocking);  uv_close((uv_handle_t *)&stream, NULL);  uv_run(&loop, UV_RUN_NOWAIT); // do we need to run the loop at least once?  uv_loop_close(&loop);  return retval;}```",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2723,30998125,2015-05-26T00:03:07Z,runtime/doc/matchit.txt,"@@ -18,7 +11,6 @@ For Vim version 6.3.  Last change:  2007 Aug 29 5. Known Bugs and Limitations				|matchit-bugs|  The functionality mentioned here is a plugin, see |add-plugin|.-This plugin is only available if 'compatible' is not set. You can avoid loading this plugin by setting the ""loaded_matchit"" variable in your |vimrc| file: > 	:let loaded_matchit = 1","Also, large parts of the `*matchit-activate*` section are now redundant, as is line 43 given what's been happening to Vi references.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2723,30998189,2015-05-26T00:06:01Z,runtime/doc/usr_05.txt,"@@ -399,45 +399,26 @@ Further reading: |new-filetype|		How to detect a new file type.  ==============================================================================-*05.5*	Adding a help file		*add-local-help* *matchit-install*+*05.5*	Adding a help file		                   *add-local-help*  If you are lucky, the plugin you installed also comes with a help file.  We will explain how to install the help file, so that you can easily find help for your new plugin.-   Let us use the ""matchit.vim"" plugin as an example (it is included with-Vim).  This plugin makes the ""%"" command jump to matching HTML tags,-if/else/endif in Vim scripts, etc.  Very useful, although it's not backwards-compatible (that's why it is not enabled by default).-   This plugin comes with documentation: ""matchit.txt"".  Let's first copy the-plugin to the right directory.  This time we will do it from inside Vim, so-that we can use $VIMRUNTIME.  (You may skip some of the ""mkdir"" commands if-you already have the directory.) >--	:!mkdir ~/.vim-	:!mkdir ~/.vim/plugin-	:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/plugin--The ""cp"" command is for Unix, on MS-DOS you can use ""copy"".--Now create a ""doc"" directory in one of the directories in 'runtimepath'. >+   Let suppose a plugin (""ns"") comes with a help file in a non-standard place.",`Let` -> `Let us`? Also maybe something longer as an example name: how about `my-plugin`?,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2720,30998548,2015-05-26T00:25:33Z,runtime/doc/nvim_terminal_emulator.txt,"@@ -52,8 +52,9 @@ Sending input is possible by entering terminal mode, which is achieved by pressing any key that would enter insert mode in a normal buffer (|i| or |a| for example). The |:terminal| ex command will automatically enter terminal mode once it's spawned. While in terminal mode, Nvim will forward all keys to-the underlying program. The only exception is the <C-\><C-n> key combo,-which will exit back to normal mode.+the underlying program. The only exceptions are the <C-\><C-n> key combo,","`are` was used, so this sounds odd IMO. Maybe `The only exceptions are <C-\><C-n>, ...`",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2720,31003132,2015-05-26T03:54:02Z,runtime/plugin/extra-keymaps.vim,"@@ -0,0 +1,43 @@+"" Extra default keymaps and keyboard behavior++"" Exit quickly if+"" 1) the user has disabled the plugin+"" 2) the file is already loaded+if exists('g:nvim#defaults#maps#use') && g:nvim#defaults#maps#use == 0+  || exists('g:nvim#defaults#maps#loaded') && g:nvim#defaults#maps#loaded == 1+  finish+endif++"" Set defaults:+"" The user can disable parts of the plugin separatedly+"" by setting any of these to 0+if !exists(""g:nvim#defaults#maps#leave_term_mode"")+  let g:nvim#defaults#maps#leave_term_mode = 1+endif+if !exists(""g:nvim#defaults#maps#Y_eol"")",The set of mappings is quite varied; I don't think wanting to disable the whole of it is more likely than wanting to disable any of these separately.,
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/2741,31065718,2015-05-26T18:43:24Z,cmake/GenerateHelptags.cmake.in,"@@ -1,10 +1,10 @@ if(DEFINED ENV{DESTDIR})   file(TO_CMAKE_PATH-    ""$ENV{DESTDIR}/${CMAKE_INSTALL_PREFIX}/share/nvim/runtime/doc""+    ""$ENV{DESTDIR}/@CMAKE_INSTALL_FULL_DATADIR@/nvim/runtime/doc""","> I asked them if that was possible and they said noAsked if what was possible?  We pass arguments in several places by defining variables on the command line.  Take a look at how we [run the unittests](https://github.com/neovim/neovim/blob/master/CMakeLists.txt#L334) as an example.> so maybe they just didn't want me to do something kludgyIt's all kludgy, if you ask me. :-)  CMake can be great in many aspects, but it's lacking in many others.  The fact that we have to create these kinds of scripts everywhere being a prime example of that.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2718,31099451,2015-05-27T02:49:23Z,test/functional/legacy/062_tab_pages_spec.lua,"@@ -0,0 +1,330 @@+-- Tests for tab pages++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('tab pages', function()+  setup(clear)++  it('is working', function()+    insert([=[+      Results:]=])++    execute('lang C')++    -- Simple test for opening and closing a tab page.+    source([[+      tabnew+      let nr = tabpagenr()+      q+      call append(line('$'), 'tab page ' . nr)+      unlet nr+    ]])","We can simplify this test by removing  ""tab page 2"" from the results and instead putting``` luaexecute('tabnew')eq(2, eval('tabpagenr()'))execute('q')```here, and similar for the other sections instead of calling `append(line('$'), ...)`. In fact, I would further add``` luaeq(1, eval('tabpagenr()'))```afterwords, just for completeness.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2585,31141216,2015-05-27T14:49:16Z,test/functional/legacy/074_global_var_in_viminfo_spec.lua,"@@ -0,0 +1,70 @@+-- Tests for storing global variables in the .viminfo file++-- TODO: We need a way to run this test with a real (dummy?) viminfo file.  It+-- will not work with the current session which executes ""nvim ... -i NONE+-- ..."" as this inhibits any kind of viminfo writing.  See "":h -i"".++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect+local os = require('os')++describe('storing global variables in viminfo files', function()+  setup(clear)++  it('is working', function()+    insert([=[+      eof]=])++    -- TODO: Is 'visualbell' meaningfull in the new test environment?+    -- This will cause a few errors, do it silently.+    source([[+      set visualbell+      set viminfo+=!+      let MY_GLOBAL_DICT={'foo': 1, 'bar': 0, 'longvarible': 1000}+    ]])+    -- Store a really long list, so line wrapping will occur in viminfo file.+    source([[+      let MY_GLOBAL_LIST=range(1,100)+      wv! Xviminfo+      unlet MY_GLOBAL_DICT+      unlet MY_GLOBAL_LIST+    ]])+    -- If the (still failing) rv! command is included in the above source(),+    -- the test errors due to output on stderr.+    execute('rv! Xviminfo')+    -- TODO: Actually we want to test if the viminfo file was written but the+    -- test is currently run with ""nvim -i NONE ..."" which inhibits this.  So+    -- the test would fail here.","At the start of this test, you can put``` luaos.remove(""Xviminfo"")  -- ensure it does not exist```and between the `wv` and `rv` commands, put``` luaneq(nil, lfs.attributes('Xviminfo'))  -- assert it exists```There may be a better way, but I don't see a `file_exists` function in lua.Instead of using `redir > test.out` below (since that's not what's being tested), you can just put``` luaeq({'foo'=1, 'longvariable'=1000, 'bar'=0}, eval('MY_GLOBAL_DICT'))```I could have the syntax a little wrong, but that's the general idea.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2747,31150051,2015-05-27T16:04:44Z,src/nvim/tui/term_input.inl,"@@ -269,7 +269,11 @@ static TermInput *term_input_new(void)     flags |= TERMKEY_FLAG_RAW;   } -  rv->tk = termkey_new_abstract(os_getenv(""TERM""), flags);+  const char *term = os_getenv(""TERM"");+  if (!term) {+    term = """";  // termkey_new_abstract assumes non-null (#2745)+  }+  rv->tk = termkey_new_abstract(term, flags);","OK, it'll only return `NULL` on OOM. First, it tries to construct a [CSI-based driver](https://github.com/neovim/libtermkey/blob/619c0c12828a86dcd388b0915b2e9656d6aac92a/driver-csi.c) with terminfo, but that'll fail so it falls back on a [TI driver](https://github.com/neovim/libtermkey/blob/619c0c12828a86dcd388b0915b2e9656d6aac92a/driver-ti.c). The docs don't say what TI stands for (terminal independent?), but the point being this seems safe.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2700,31184055,2015-05-27T21:43:40Z,man/nvim.1,"@@ -393,8 +393,6 @@ The system-global .Nm runtime directory. .El-.Sh SEE ALSO-.Xr nvimtutor 1","In this file, make sure to also remove the argument to `.Os` (line 3): it's only purpose was to signify that `nvim` and `nvimtutor` were part of the ""Neovim"" distribution, so one and the same, which isn't applicable anymore because `nvimtutor.1` is being removed.If you need clarification on why it should be kept without arguments, here's it referenced in `man mdoc`:```Os     Operating system version for display in the page footer.  This is the     mandatory third macro of any mdoc file.  Its syntax is as follows:           .Os [system [version]]     The optional system parameter specifies the relevant operating system or     environment.  It is suggested to leave it unspecified, in which case     mandoc(1) uses its -Ios argument or, if that isn't specified either,     sysname and release as returned by uname(3).     Examples:           .Os           .Os KTH/CSC/TCS           .Os BSD 4.3     See also Dd and Dt.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2720,31291723,2015-05-29T00:47:56Z,runtime/plugin/extra-keymaps.vim,"@@ -0,0 +1,43 @@+"" Extra default keymaps and keyboard behavior++"" Exit quickly if+"" 1) the user has disabled the plugin+"" 2) the file is already loaded+if exists('g:nvim#extra_maps#use') && g:nvim#extra_maps#use == 0+  || exists('g:nvim#extra_maps#loaded') && g:nvim#extra_maps#loaded == 1+  finish+endif++"" Set defaults:+"" The user can disable parts of the plugin separatedly+"" by setting any of these to 0+if !exists(""g:nvim#extra_maps#leave_term_mode"")+  let g:nvim#extra_maps#leave_term_mode = 1+endif+if !exists(""g:nvim#extra_maps#Y_eol"")+  let g:nvim#extra_maps#Y_eol = 1+endif+if !exists(""g:nvim#extra_maps#undo_ctrl_u"")+  let g:nvim#extra_maps#undo_ctrl_u = 1+endif+if !exists(""g:nvim#extra_maps#smart_home"")+  let g:nvim#extra_maps#smart_home = 1+endif++"" Do a mapping+function! s:DefMap(var, lhs, mode, map)+  "" We don't want to mask user defined mappings, so we check+  if eval('g:nvim#extra_maps#'.a:var) == 1 && maparg(a:lhs, a:mode) == ''+    exe a:mode.'noremap '. a:map+  endif+endfunction++"" Do the mappings:+call s:DefMap('leave_term_mode', '<esc><esc>', 't', '<esc><esc> <C-\><c-n>')+call s:DefMap('Y_eol', 'Y', '', 'Y y$')","The `#extra-keymaps` namespace itself IMO is over-engineered. As I mentioned in https://github.com/neovim/neovim/pull/2720#issuecomment-105388220 this is not a precedent that we should set, it's not a pleasant pattern for users to learn, for the core editor. Set the default keymaps before sourcing vimrc.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2760,31298389,2015-05-29T04:30:08Z,runtime/doc/starting.txt,"@@ -471,7 +471,18 @@ accordingly.  Vim proceeds in this order: 	The |-V| argument can be used to display or log what happens next, 	useful for debugging the initializations. -3. Execute Ex commands, from environment variables and/or files+3. Source early plugin files				    *early-plugins*+	This does the same as >+	    source early/**/*.vim+<	The result is that all directories in the default |'runtimepath'| will be+	searched for the ""early"" sub-directory and all files ending in "".vim""+	will be sourced (in alphabetical order per directory), also in+	subdirectories.+	Loading plugins won't be done when:","I must sound like the biggest pedant of all time, but ""if"" might be better in this context... sorry :sweat: ",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2760,31298466,2015-05-29T04:32:32Z,runtime/doc/motion.txt,"@@ -183,6 +183,8 @@ l		or					*l* 			in the same SCREEN column.  <Home> works like ""1|"", 			which differs from ""0"" when the line starts with a 			<Tab>.+                        {Nvim} By default, <Home> is mapped so it alternates+			between behaving like |^| and |0| (see |smart-home|).",":+1: It is written, I just nuked it alongside the variable names references... ",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2760,31298776,2015-05-29T04:43:32Z,src/nvim/main.c,"@@ -1398,6 +1398,17 @@ static void load_plugins(void) }  /*+ * Read all the early plugin files (those are sourced before the vimrc)+ */+static void load_early_plugins(void)","I think it's fine currently; the benefit of having a separate interface outweighs the duplication, IMO.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2760,31356381,2015-05-29T19:21:15Z,src/nvim/main.c,"@@ -1396,6 +1396,24 @@ static void load_plugins(void) }  /*+ * Read all the early plugin files (those are sourced before the vimrc)+ */+static void load_early_plugins(mparm_T *parmp)+{+  if (parmp->use_vimrc != NULL) {+    if (strcmp(parmp->use_vimrc, ""NONE"") == 0+        || strcmp(parmp->use_vimrc, ""NORC"") == 0) {+      if (parmp->use_vimrc[2] == 'N')",Indeed we don't seem to need to. This piece of the code is something I pasted there just to test if this was the issue I was having with `-u NONE`. I should move the check that sets p_lpl around [here](https://github.com/fmoralesc/neovim/blob/early/extra-keymaps/src/nvim/main.c#L297).,
3795966,frederikvs,https://api.github.com/repos/neovim/neovim/pulls/2762,31356575,2015-05-29T19:23:43Z,src/nvim/terminal.c,"@@ -313,6 +313,10 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)     return;   } +  if (height == 0 || width == 0) {+    return;+  }","Above the FOR_ALL_WINDOWS_IN_TAB this wouldn't work yet. If 0 was passed as parameter, the width or height would be set to the current value (not 0, so no return), and then we'd find the minimum (again 0, causing the same problem). Also, as you mentioned in a comment to PR #2683, having width & height as a parameter doesn't really add value, since we need to walk across all windows anyway. There are some other problems with this function as well - currently the terminal's size can only decrease, never increase. All this and more is addressed in PR #2683, which can be completed when this PR gets merged in.The current PR is meant as a minimal bugfix that would enable me to make greater improvements in the other one.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2762,31369601,2015-05-29T22:16:18Z,src/nvim/terminal.c,"@@ -313,6 +313,10 @@ void terminal_resize(Terminal *term, uint16_t width, uint16_t height)     return;   } +  if (height == 0 || width == 0) {+    return;+  }","I see. Just for the record, normally, I'd request that such changes be put in the main PR, but I do prefer to get bug fixes merged sooner than later, and it's only one commit.However, I still have to ask why not check for this in the above loop? It doesn't seem like `height` or `width` should be set to zero under any reasonable circumstances. Could `curwidth` have been zero initially? Can `wp->w_width` ever be zero? Does subtracting `win_col_off()` cause it? I worry that this might hide a bug rather than fix it (even if only temporarily).Ideally, the commit message should document an analysis of the problem that justifies the proposed fix.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2763,31369671,2015-05-29T22:17:39Z,runtime/doc/eval.txt,"@@ -4053,6 +4053,8 @@ jobstart({cmd}[, {opts}])				{Nvim} *jobstart()* 		  - width: Width of the terminal screen(only if pty is set) 		  - height: Height of the terminal screen(only if pty is set) 		  - TERM: $TERM environment variable(only if pty is set)+		  - ignore_stdin: If set, the job will not open an stdin+		    channel (and jobsend() won't work).","Taking a hint [from nodejs](https://github.com/neovim/neovim/issues/2757#issue-82149016) should we anticipate a request for similar features for stdout, stderr? Rather than adding more booleans perhaps we can adapt the nodejs format:```{ stdio: ['ignore', 'pipe', 'pipe'] })```",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2763,31375514,2015-05-30T00:48:50Z,runtime/doc/eval.txt,"@@ -4053,6 +4053,8 @@ jobstart({cmd}[, {opts}])				{Nvim} *jobstart()* 		  - width: Width of the terminal screen(only if pty is set) 		  - height: Height of the terminal screen(only if pty is set) 		  - TERM: $TERM environment variable(only if pty is set)+		  - ignore_stdin: If set, the job will not open an stdin+		    channel (and jobsend() won't work).","Does it accept any value other than ""ignore"" or ""pipe""? Having an ""ingore_stderr"" option would be the same as not associating a callback and adds another error condition to check for. To set up a pipe without actually reading it, one can just pass a `noop` callback.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2716,31377977,2015-05-30T05:20:04Z,src/nvim/macros.h,"@@ -154,6 +154,6 @@ /// zero in those cases (-Wdiv-by-zero in GCC). #define ARRAY_SIZE(arr) ((sizeof(arr)/sizeof((arr)[0])) / ((size_t)(!(sizeof(arr) % sizeof((arr)[0]))))) -#define RGB(r, g, b) ((r << 16) | (g << 8) | b)+#define NVIM_RGB(r, g, b) ((r << 16) | (g << 8) | b)","I forgot to ask earlier, hence the delay.Anyways, I'm curious: what's the benefit of using a function in this case as opposed to the macro mentioned above? I'm guessing the function provides extra type checking, which would avoid or at least reduce the possibility of left-shifting to the point of undefined behaviour if a signed type were accidentally supplied. As I said, I'm unsure :P",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2767,31383238,2015-05-30T18:38:05Z,src/nvim/main.c,"@@ -186,6 +183,12 @@ int nvim_main(int argc, char **argv) int main(int argc, char **argv) #endif {+  argv0 = basename(argv[0]);","`path_tail(argv[0])`, from `nvim/path.c`, would be more OS-independent. Also, never returns `NULL`, but will return an empty string if `argv[0] == NULL`. Is that even possible?",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2767,31383370,2015-05-30T18:54:17Z,src/nvim/main.c,"@@ -186,6 +183,12 @@ int nvim_main(int argc, char **argv) int main(int argc, char **argv) #endif {+  argv0 = basename(argv[0]);","@oni-link I'll respond to your comment here as well (so it doesn't disappear if I amend the commit).> would be more OS-independentCould you explain why? I don't know much about libgen's portability, but it's specified in POSIX (although that doesn't necessarily mean Windows has it :p).> Also, never returns NULL, but will return an empty string if argv[0] == NULLSo does basename, at least I think so after reading the [POSIX article on it](http://pubs.opengroup.org/onlinepubs/9699919799/functions/basename.html). I'm checking for null because the implementation I'm using (OpenBSD) mentions this:```ERRORS     The following error codes may be set in errno:     [ENAMETOOLONG]     The path component to be returned was larger than                        PATH_MAX.```> Is that even possible?I've no idea... maybe if nvim was executed using `exec`?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2771,31384859,2015-05-30T21:54:30Z,src/nvim/os/job.c,"@@ -55,6 +56,22 @@ uv_signal_t schld; #endif // Callbacks for libuv +static int count = 0;  // A cyclical counter used for assigning job IDs.++/// Returns a new job ID within the range `[1, INT_MAX]`.+///+/// This number will be unique between all jobs that have not been stopped, but+/// cycle back to one after reaching `INT_MAX`. This makes it highly unlikely+/// for two jobs to have the same ID.+static int new_job_id(void)+{+  count = count < INT_MAX ? count + 1 : 1;","By the way, now nobody checks for the condition ���job table is full���: this is now equivalent to an infinite cycle.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2771,31384901,2015-05-30T22:00:38Z,src/nvim/os/job.c,"@@ -55,6 +56,22 @@ uv_signal_t schld; #endif // Callbacks for libuv +static int count = 0;  // A cyclical counter used for assigning job IDs.++/// Returns a new job ID within the range `[1, INT_MAX]`.+///+/// This number will be unique between all jobs that have not been stopped, but+/// cycle back to one after reaching `INT_MAX`. This makes it highly unlikely+/// for two jobs to have the same ID.+static int new_job_id(void)+{+  count = count < INT_MAX ? count + 1 : 1;","> By the way, now nobody checks for the condition ���job table is full���fixed",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2771,31385310,2015-05-30T22:58:37Z,src/nvim/os/job.c,"@@ -62,20 +83,22 @@ void job_init(void)   uv_timer_init(uv_default_loop(), &job_stop_timer);   uv_signal_init(uv_default_loop(), &schld);   uv_signal_start(&schld, chld_handler, SIGCHLD);++  job_map = pmap_new(int)(); }  /// Releases job control resources and terminates running jobs void job_teardown(void) {   // Stop all jobs-  for (int i = 0; i < MAX_RUNNING_JOBS; i++) {-    Job *job;-    if ((job = table[i]) != NULL) {-      uv_kill(job->pid, SIGTERM);-      job->term_sent = true;-      job_stop(job);-    }-  }+  Job *job;+  int id; (void)id;",It prevents a compiler warning in Release mode.``` bash/home/oni-link/git/neovim/src/nvim/os/job.c: In function ���job_teardown���:/home/oni-link/git/neovim/src/nvim/os/job.c:95:7: warning: variable ���id��� set but not used [-Wunused-but-set-variable]   int id; //(void)id;       ^```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2762,31391673,2015-05-31T16:15:55Z,src/nvim/window.c,"@@ -4745,7 +4745,9 @@ void win_new_width(win_T *wp, int width)   wp->w_redr_status = TRUE;    if (wp->w_buffer->terminal) {-    terminal_resize(wp->w_buffer->terminal, wp->w_width, 0);+    if (wp->w_height != 0) {+      terminal_resize(wp->w_buffer->terminal, wp->w_width, 0);",Checking `wp->w_height` seems to add some technical debt. We're baking-in knowledge of `terminal_resize`'s implementation (we're passing the literal `0` yet we're checking `wp->w_height` for non-zero... that makes no sense). I suggest removing this check in your other PR.,
3795966,frederikvs,https://api.github.com/repos/neovim/neovim/pulls/2762,31391923,2015-05-31T16:41:46Z,src/nvim/window.c,"@@ -4745,7 +4745,9 @@ void win_new_width(win_T *wp, int width)   wp->w_redr_status = TRUE;    if (wp->w_buffer->terminal) {-    terminal_resize(wp->w_buffer->terminal, wp->w_width, 0);+    if (wp->w_height != 0) {+      terminal_resize(wp->w_buffer->terminal, wp->w_width, 0);","Actually those parameters to terminal_resize are useless. Terminal_resize will loop over all windows on the terminal-buffer to figure out what the minimum size is, and use that as the new size. Passing in the value for this specific window adds no value.The other PR already contains a commit which removes those unnecessary parameters.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2789,31801522,2015-06-05T10:11:31Z,src/nvim/os/shell.c,"@@ -37,6 +37,40 @@ typedef struct { #endif  +/// Process command string with 'shellxescape' (p_sxe) and 'shellxquote'+/// (p_sxq)+///+/// @param cmd Command string+/// @return A newly allocated command string. It must be freed with+///         `xfree` when no longer needed.+static char *cmd_sxe_sxq(const char *cmd)+{+  char *ncmd;++  if (cmd == NULL || *p_sxq == NUL) {+    ncmd = (cmd == NULL) ? NULL : xstrdup(cmd);+  } else {+    char *ecmd = (char *)cmd;++    if (*p_sxe != NUL && STRCMP(p_sxq, ""("") == 0) {+      ecmd = (char *)vim_strsave_escaped_ext((char_u *)cmd, p_sxe, '^', false);+    }+    ncmd = xmalloc(strlen(ecmd) + STRLEN(p_sxq) * 2 + 1);+    STRCPY(ncmd, p_sxq);+    strcat(ncmd, ecmd);+    /* When 'shellxquote' is ( append ).+     * When 'shellxquote' is ""( append )"". */+    STRCAT(ncmd, STRCMP(p_sxq, ""("") == 0 ? (char_u *)"")""+        : STRCMP(p_sxq, ""\""("") == 0 ? (char_u *)"")\""""+        : p_sxq);","Might be more readable to split this using `if` instead of using the conditional operator.Also, since ncmd is a `char` (not `char_u`), I'd suggest using `strcat` and not casting the literals to `char_u`.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2808,31963394,2015-06-08T21:47:47Z,src/nvim/api/buffer.c,"@@ -86,6 +86,12 @@ void buffer_del_line(Buffer buffer, Integer index, Error *err)   FUNC_ATTR_DEFERRED {   Array array = ARRAY_DICT_INIT;+  buf_T *buf = find_buffer_by_handle(buffer, err);++  if(index >= buf->b_ml.ml_line_count) {+    return;","Hmm..., a race condition could cause us to try and delete line 99 after 98 was deleted by something else. Not a problem for this PR, but maybe we should have a way for clients to lock buffers.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2807,31987374,2015-06-09T07:15:05Z,.ci/clang.sh,"@@ -15,13 +20,14 @@ if [ ""$TRAVIS_OS_NAME"" = ""linux"" ]; then 	export CC=/usr/local/clang-$clang_version/bin/clang 	symbolizer=/usr/local/clang-$clang_version/bin/llvm-symbolizer 	export ASAN_SYMBOLIZER_PATH=$symbolizer+	export MSAN_SYMBOLIZER_PATH=$symbolizer","I think the variable has to be named `ASAN_SYMBOLIZER_PATH` (same for MSAN) for Clang to pick it up.http://clang.llvm.org/docs/MemorySanitizer.html> Make sure that llvm-symbolizer binary is in PATH, or set environment variable MSAN_SYMBOLIZER_PATH to point to it.Or we could maybe change the PATH, but looks like `$symbolizer` is used in some other variables as well, so we can't get rid of it. So rename `$symbolizer` to `SAN_SYMBOLIZER_PATH`? _Edit_ but then it doesn't match our naming scheme (lowercase for ""helper variables"") anymore.",
1525226,ghqhxnfizloub,https://api.github.com/repos/neovim/neovim/pulls/2789,32086839,2015-06-10T04:10:02Z,src/nvim/os/shell.c,"@@ -37,6 +37,50 @@ typedef struct { #endif  +/// Process command string with 'shellxescape' (p_sxe) and 'shellxquote'+/// (p_sxq)+///+/// @param cmd Command string+/// @return NULL if `cmd` is NULL. Otherwise, a newly allocated command string.+///         It must be freed with `xfree` when no longer needed.+static char *shell_escape(const char *cmd)+{+  char *ncmd;++  if (cmd == NULL) {+    ncmd = NULL;+  } else if (*p_sxq == NUL) {+    ncmd = xstrdup(cmd);+  } else {+    const char *ecmd;+    size_t ncmd_size;++    if (*p_sxe != NUL && STRCMP(p_sxq, ""("") == 0) {+      ecmd = (char *)vim_strsave_escaped_ext((char_u *)cmd, p_sxe, '^', false);+    } else {+      ecmd = cmd;+    }+    ncmd_size = strlen(ecmd) + STRLEN(p_sxq) * 2 + 1;+    ncmd = xmalloc(ncmd_size);++    // When 'shellxquote' is '(', append ')'.+    // When 'shellxquote' is '""(', append ')""'.+    if (STRCMP(p_sxq, ""("") == 0) {+      snprintf(ncmd, ncmd_size, ""(%s)"", ecmd);+    } else if (STRCMP(p_sxq, ""\""("") == 0) {+      snprintf(ncmd, ncmd_size, ""\""(%s)\"""", ecmd);+    } else {+      snprintf(ncmd, ncmd_size, ""%s%s%s"", p_sxq, ecmd, p_sxq);+    }",There are two places where `make_filter_cmd` is called: https://github.com/neovim/neovim/blob/master/src/nvim/ex_cmds.c#L1064 and https://github.com/neovim/neovim/blob/master/src/nvim/misc1.c#L2779 . `call_shell` is called in both places afterwards. And `make_filter_cmd` is not called in `system()` (`f_system`).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2585,32288971,2015-06-12T04:00:31Z,test/functional/ex_cmds/wviminfo_spec.lua,"@@ -0,0 +1,62 @@+local helpers, lfs = require('test.functional.helpers'), require('lfs')+local clear, execute, eq, neq, spawn, nvim_prog, set_session, wait =+  helpers.clear, helpers.execute, helpers.eq, helpers.neq, helpers.spawn,+  helpers.nvim_prog, helpers.set_session, helpers.wait++-- Lua does not have a sleep function so we use the system command.  If the+-- command does not support sub second precision we use math.floor() to get+-- full seconds.+local sleep = function(millisec)+  local sec = millisec / 1000+  local round = math.floor(sec)+  if round == 0 then round = 1 end+  os.execute('sleep '..sec..' || sleep '..round)+end","I don't see where this sleep function is actually used, but for future reference: would need to wrap this in a `pending()` condition if the environment (e.g. Windows) doesn't have a `sleep` command. Or better yet, use the Vim `:sleep` command if possible.I will remove this function when merging.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2585,32289283,2015-06-12T04:15:07Z,test/functional/ex_cmds/wviminfo_spec.lua,"@@ -0,0 +1,62 @@+local helpers, lfs = require('test.functional.helpers'), require('lfs')+local clear, execute, eq, neq, spawn, nvim_prog, set_session, wait =+  helpers.clear, helpers.execute, helpers.eq, helpers.neq, helpers.spawn,+  helpers.nvim_prog, helpers.set_session, helpers.wait++-- Lua does not have a sleep function so we use the system command.  If the+-- command does not support sub second precision we use math.floor() to get+-- full seconds.+local sleep = function(millisec)+  local sec = millisec / 1000+  local round = math.floor(sec)+  if round == 0 then round = 1 end+  os.execute('sleep '..sec..' || sleep '..round)+end++describe(':wviminfo', function()+  local file = 'foo'+  before_each(function()+    clear()+    os.remove(file)+  end)++  it('creates a file', function()+    -- TODO+    -- Set up the nvim session to be able to write viminfo files.  Is it+    -- possible to do this outside of the it() call?","~~Since clear() sets up a new session, doing it outside of the it() call wouldn't work.~~ Oh, I get it now. You don't need 2 parallel sessions--you just need to override the default session.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2585,32289420,2015-06-12T04:19:52Z,test/functional/ex_cmds/wviminfo_spec.lua,"@@ -0,0 +1,62 @@+local helpers, lfs = require('test.functional.helpers'), require('lfs')+local clear, execute, eq, neq, spawn, nvim_prog, set_session, wait =+  helpers.clear, helpers.execute, helpers.eq, helpers.neq, helpers.spawn,+  helpers.nvim_prog, helpers.set_session, helpers.wait++-- Lua does not have a sleep function so we use the system command.  If the+-- command does not support sub second precision we use math.floor() to get+-- full seconds.+local sleep = function(millisec)+  local sec = millisec / 1000+  local round = math.floor(sec)+  if round == 0 then round = 1 end+  os.execute('sleep '..sec..' || sleep '..round)+end++describe(':wviminfo', function()+  local file = 'foo'+  before_each(function()+    clear()+    os.remove(file)+  end)++  it('creates a file', function()+    -- TODO+    -- Set up the nvim session to be able to write viminfo files.  Is it+    -- possible to do this outside of the it() call?+    local nvim2 = spawn({nvim_prog, '-u', 'NONE', '--embed'})+    --local nvim2 = spawn({nvim_prog, '-u', 'NONE', '--embed', '--cmd', 'let hans=42' })+    set_session(nvim2)+    --eq(43, eval('hans'))++    -- Assert that the file does not exist.+    eq(nil, lfs.attributes(file))+    execute('wv! '..file)+    wait()+    -- Assert that the file does exist.+    neq(nil, lfs.attributes(file))","Instead of using `eq`/`neq` with a comment explaining the meaning, I tend to use `assert(<condition>, ""explanation"")`, for example:```assert(nil ~= lfs.attributes(file), ""viminfo should exist after :wv"")```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2585,32316197,2015-06-12T13:41:28Z,test/functional/ex_cmds/wviminfo_spec.lua,"@@ -0,0 +1,62 @@+local helpers, lfs = require('test.functional.helpers'), require('lfs')+local clear, execute, eq, neq, spawn, nvim_prog, set_session, wait =+  helpers.clear, helpers.execute, helpers.eq, helpers.neq, helpers.spawn,+  helpers.nvim_prog, helpers.set_session, helpers.wait++-- Lua does not have a sleep function so we use the system command.  If the+-- command does not support sub second precision we use math.floor() to get+-- full seconds.+local sleep = function(millisec)+  local sec = millisec / 1000+  local round = math.floor(sec)+  if round == 0 then round = 1 end+  os.execute('sleep '..sec..' || sleep '..round)+end++describe(':wviminfo', function()+  local file = 'foo'+  before_each(function()+    clear()+    os.remove(file)+  end)++  it('creates a file', function()+    -- TODO+    -- Set up the nvim session to be able to write viminfo files.  Is it+    -- possible to do this outside of the it() call?+    local nvim2 = spawn({nvim_prog, '-u', 'NONE', '--embed'})+    --local nvim2 = spawn({nvim_prog, '-u', 'NONE', '--embed', '--cmd', 'let hans=42' })+    set_session(nvim2)+    --eq(43, eval('hans'))++    -- Assert that the file does not exist.+    eq(nil, lfs.attributes(file))+    execute('wv! '..file)+    wait()+    -- Assert that the file does exist.+    neq(nil, lfs.attributes(file))","> but the ""explanation"" is never shown in the test outputAre you sure? That would be a major problem. If I change `~=` to `==` at this line: https://github.com/neovim/neovim/commit/1f0830f7004c60f899fc169baecd68960f26ea70#diff-d587b4ef5d4b7947c66765d46ff9a341R50The test results are:```Failure ��� test/functional/ex_cmds/wviminfo_spec.lua @ 32:wviminfo overwrites existing filestest/functional/ex_cmds/wviminfo_spec.lua:50: wviminfo_test should be a viminfo-formatted file ```>  I don't think it is a good idea to use an argument which I was unable to find in the busted docs.It's actually a stock lua function. Personally I find it annoying that busted doesn't provide an ""explanation"" parameter for all of their assert functions. I assume it has to do with BDD dogma about `it()` blocks being small and self-explanatory :grin:   But if a comment is needed to explain an assertion, then evidently that spec is not self-explanatory (and in practice this is quite common, and not reasonable to avoid it).",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2831,32329559,2015-06-12T16:08:57Z,runtime/doc/msgpack_rpc.txt,"@@ -45,19 +45,19 @@ non-static API functions, converting/validating arguments and return values back to msgpack.  Client libraries will normally provide wrappers that hide msgpack-rpc details-from programmers, which can be automatically generated by reading bundled API-metadata from a compiled nvim instance.+from programmers. The wrappers can be automatically generated by reading+bundled API metadata from a compiled Nvim instance.  There are two ways to obtain API metadata: -1. By connecting to a running nvim instance and calling `vim_get_api_info`-   via msgpack-rpc. This is the preferred way for clients written in-   dynamically-typed languages, which can define functions at runtime.+1. By connecting to a running Nvim instance and calling `vim_get_api_info`+   via msgpack-rpc. This is best for clients written in dynamically-typed +   languages, which can define functions at runtime. -2. Through the `--api-info` command-line option, which makes nvim dump a-   msgpack blob containing metadata to stdout and exit. This is preferred-   when writing clients for statically-typed languages, which require a-   separate compilation step.+2. By running Nvim with the `--api-info` command-line option, which makes Nvim+   dump a msgpack blob containing metadata to stdout and exit. This is ","maybe `..., which make Nvim dump msgpack metadata to standard output and exit.`?",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2831,32330947,2015-06-12T16:26:58Z,runtime/doc/remote_plugin.txt,"@@ -82,16 +82,16 @@ of requests made to it. Here's the plugin source code: <  As can be seen, the plugin is implemented using pure Python idioms (classes,","maybe `... using idiomatic Python (classes, ...`",
2353785,nhynes,https://api.github.com/repos/neovim/neovim/pulls/2831,32374557,2015-06-13T22:37:13Z,runtime/doc/msgpack_rpc.txt,"@@ -45,19 +45,19 @@ non-static API functions, converting/validating arguments and return values back to msgpack.  Client libraries will normally provide wrappers that hide msgpack-rpc details-from programmers, which can be automatically generated by reading bundled API-metadata from a compiled nvim instance.+from programmers. The wrappers can be automatically generated by reading+bundled API metadata from a compiled Nvim instance.  There are two ways to obtain API metadata: -1. By connecting to a running nvim instance and calling `vim_get_api_info`-   via msgpack-rpc. This is the preferred way for clients written in-   dynamically-typed languages, which can define functions at runtime.+1. By connecting to a running Nvim instance and calling `vim_get_api_info`+   via msgpack-rpc. This is best for clients written in dynamically-typed +   languages, which can define functions at runtime. -2. Through the `--api-info` command-line option, which makes nvim dump a-   msgpack blob containing metadata to stdout and exit. This is preferred-   when writing clients for statically-typed languages, which require a-   separate compilation step.+2. By running Nvim with the `--api-info` command-line option, which makes Nvim","This sentence is missing an independent clause. Maybe reword to ""Running Nvim with the `--api-info` command-line option makes Nvim...""",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2227,32382880,2015-06-14T18:47:20Z,src/nvim/if_cscope.c,"@@ -1174,22 +1172,25 @@ static char *GetWin32Error(void) static int cs_insert_filelist(char *fname, char *ppath, char *flags,                               FileInfo *file_info) {-  short i, j;+  size_t i;+  bool empty_found; -  i = -1;   /* can be set to the index of an empty item in csinfo */",[QB build](http://neovim-qb.szakmeister.net/build/1532) complains that `i` is used uninitialized in `cs_insert_filelist`. I'm guessing it is because of this deletion.,
1570381,alysbrooks,https://api.github.com/repos/neovim/neovim/pulls/2831,32490372,2015-06-16T04:28:11Z,runtime/doc/msgpack_rpc.txt,"@@ -45,19 +45,19 @@ non-static API functions, converting/validating arguments and return values back to msgpack.  Client libraries will normally provide wrappers that hide msgpack-rpc details-from programmers, which can be automatically generated by reading bundled API-metadata from a compiled nvim instance.+from programmers. The wrappers can be automatically generated by reading+bundled API metadata from a compiled Nvim instance.  There are two ways to obtain API metadata: -1. By connecting to a running nvim instance and calling `vim_get_api_info`-   via msgpack-rpc. This is the preferred way for clients written in-   dynamically-typed languages, which can define functions at runtime.+1. By connecting to a running Nvim instance and calling `vim_get_api_info`+   via msgpack-rpc. This is best for clients written in dynamically-typed+   languages, which can define functions at runtime. -2. Through the `--api-info` command-line option, which makes nvim dump a-   msgpack blob containing metadata to stdout and exit. This is preferred-   when writing clients for statically-typed languages, which require a-   separate compilation step.+2. By starting Nvim with the `--api-info` command-line option, which makes Nvim+   dump a msgpack metadata to standard output and exit. This is best for clients+   written in statically-typed languages, which require a separate compilation","Should this be ""which _often_ require a separate compilation step""?I'm not actually sure about why a separate compilation step matters. Should it say that functions can't be defined after compile time?The first sentences of 1. and 2. still lack independent clauses. I think that's okay for a list, as long as it sounds natural. Maybe it's because the number sort of reads like a subject to me ""Number one is..."" I can fix them if others disagree.",
1570381,alysbrooks,https://api.github.com/repos/neovim/neovim/pulls/2831,32492186,2015-06-16T05:33:13Z,runtime/doc/msgpack_rpc.txt,"@@ -45,19 +45,19 @@ non-static API functions, converting/validating arguments and return values back to msgpack.  Client libraries will normally provide wrappers that hide msgpack-rpc details-from programmers, which can be automatically generated by reading bundled API-metadata from a compiled nvim instance.+from programmers. The wrappers can be automatically generated by reading+bundled API metadata from a compiled Nvim instance.  There are two ways to obtain API metadata: -1. By connecting to a running nvim instance and calling `vim_get_api_info`-   via msgpack-rpc. This is the preferred way for clients written in-   dynamically-typed languages, which can define functions at runtime.+1. By connecting to a running Nvim instance and calling `vim_get_api_info`+   via msgpack-rpc. This is best for clients written in dynamically-typed+   languages, which can define functions at runtime. -2. Through the `--api-info` command-line option, which makes nvim dump a-   msgpack blob containing metadata to stdout and exit. This is preferred-   when writing clients for statically-typed languages, which require a-   separate compilation step.+2. By starting Nvim with the `--api-info` command-line option, which makes Nvim+   dump a msgpack metadata to standard output and exit. This is best for clients+   written in statically-typed languages, which require a separate compilation","Regarding the actual documentation above, I don't think `dump a msgpack metadata` makes much sense, kind of like `I'll give you a data containing my address`. I might have been unclear in my initial request; anyways, how aboutabout `dump a blob of msgpack ...`, or something like that.> Should this be ""which often require a separate compilation step""?I'd think they would always require a separate compilation step, as type checking of a function can't be done at compile time if the function doesn't exist.> The first sentences of 1. and 2. still lack independent clauses. I think that's okay for a list, as long as it sounds natural.Yes I think so too. I prefer the slightly informal nature of it; it sounds more natural, as you say.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2807,32572957,2015-06-16T21:27:30Z,.ci/clang.sh,"@@ -38,11 +48,14 @@ build/bin/nvim --version make unittest  # Run functional tests.-if ! $MAKE_CMD test; then+# FIXME (fwalch): Disabled for MSAN because of SIGPIPE error.+if [ ""$TRAVIS_OS_NAME"" = ""linux"" -a ""$CLANG_SANITIZER"" -ne ""MSAN"" ]; then","I could be spreading FUD but I believe `[ ... ] && [ ... ]` is the most reliable ""and"" form in [ba]sh conditionals. I also thought `-ne` was for integer-likes, not strings[1]? I would use this instead:```if [ ""$TRAVIS_OS_NAME"" = linux ] && ! [ ""$CLANG_SANITIZER"" = MSAN ]; then```[1] Note that `man test` does indicate that `-ne` is for integers.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2807,32729362,2015-06-18T13:31:53Z,src/nvim/os/fs.c,"@@ -192,13 +192,15 @@ int os_open(const char* path, int flags, int mode)  /// Get stat information for a file. ///-/// @return OK on success, FAIL if a failure occurred.+/// @return `true` on success, `false otherwise. static bool os_stat(const char *name, uv_stat_t *statbuf)   FUNC_ATTR_NONNULL_ALL {   uv_fs_t request;","This should make the error go away, although I wonder if it is hiding a deeper bug (perhaps in libuv?):```uv_fs_t request = {0};```Or alternatively, do that for `statbuf` in `os_getperm`:```uv_stat_t statbuf = {0};```",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2807,32731206,2015-06-18T13:50:56Z,src/nvim/os/fs.c,"@@ -192,13 +192,15 @@ int os_open(const char* path, int flags, int mode)  /// Get stat information for a file. ///-/// @return OK on success, FAIL if a failure occurred.+/// @return `true` on success, `false otherwise. static bool os_stat(const char *name, uv_stat_t *statbuf)   FUNC_ATTR_NONNULL_ALL {   uv_fs_t request;","That works.When [LibUV initializes the `uv_fs_t` data structure](https://github.com/libuv/libuv/blob/v1.x/src/unix/fs.c#L63-L70), it doesn't assign the `statbuf` field. So I guess it is a LibUV bug? I'll try to send a PR.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2855,32793425,2015-06-19T00:43:32Z,test/functional/legacy/038_virtual_replace_spec.lua,"@@ -10,6 +10,8 @@ describe('Virtual replace mode', function()   it('is working', function()     -- Make sure that backspace works, no matter what termcap is used.     execute('set t_kD=x7f t_kb=x08')+    -- Use vi default for 'smarttab'+    execute('set nosmarttab')","Well, technically, vim's default here is to use vi's default, but I can change it if its clearer the other way.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2858,32799161,2015-06-19T03:27:55Z,runtime/doc/pattern.txt,"@@ -141,7 +141,7 @@ CTRL-C			Interrupt current (search) command.  Use CTRL-Break on 			executing autocommands |autocmd-searchpat|. 			Same thing for when invoking a user function. -While typing the search pattern the current match will be shown if the+While typing the search pattern the current match will be shown as long as the","It still reads fine as ""if"". I mention this to avoid however many other similar doc changes may result from defaults changes. Even if this were a new option I would still prefer ""if"", it is more brief, and it is correct.",
1570381,alysbrooks,https://api.github.com/repos/neovim/neovim/pulls/2831,32800819,2015-06-19T04:27:16Z,runtime/doc/msgpack_rpc.txt,"@@ -45,19 +45,19 @@ non-static API functions, converting/validating arguments and return values back to msgpack.  Client libraries will normally provide wrappers that hide msgpack-rpc details-from programmers, which can be automatically generated by reading bundled API-metadata from a compiled nvim instance.+from programmers. The wrappers can be automatically generated by reading+bundled API metadata from a compiled Nvim instance.  There are two ways to obtain API metadata: -1. By connecting to a running nvim instance and calling `vim_get_api_info`-   via msgpack-rpc. This is the preferred way for clients written in-   dynamically-typed languages, which can define functions at runtime.+1. By connecting to a running Nvim instance and calling `vim_get_api_info`+   via msgpack-rpc. This is best for clients written in dynamically-typed+   languages, which can define functions at runtime. -2. Through the `--api-info` command-line option, which makes nvim dump a-   msgpack blob containing metadata to stdout and exit. This is preferred-   when writing clients for statically-typed languages, which require a-   separate compilation step.+2. By starting Nvim with the `--api-info` command-line option, which makes Nvim+   dump a msgpack metadata to standard output and exit. This is best for clients+   written in statically-typed languages, which require a separate compilation","What if I just remove the ""a"" (`which makes Nvim dump a msgpack metadata to standard output and exit.`)?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2851,32898087,2015-06-21T21:44:36Z,test/functional/legacy/061_undo_tree_spec.lua,"@@ -0,0 +1,256 @@+-- Tests for undo tree and :eralier and :later.++local helpers = require('test.functional.helpers')+local feed, insert, source, eq, eval, clear, execute, expect, wait =+  helpers.feed, helpers.insert, helpers.source, helpers.eq, helpers.eval,+  helpers.clear, helpers.execute, helpers.expect, helpers.wait++local expect_empty_buffer = function()+  -- The space will be removed by helpers.dedent but is needed as dedent will+  -- throw an error if it can not find the common indent of the given lines.+  return expect(' ')+end+local expect_line = function(line)+  return eq(line, eval('getline(""."")'))+end",:+1:  good compromise (hiding these workarounds in `expect_foo` functions),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2851,32942442,2015-06-22T14:53:25Z,test/functional/legacy/061_undo_tree_spec.lua,"@@ -0,0 +1,280 @@+-- Tests for undo tree and :earlier and :later.++local helpers = require('test.functional.helpers')+local feed, insert, source, eq, eval, clear, execute, expect, wait =+  helpers.feed, helpers.insert, helpers.source, helpers.eq, helpers.eval,+  helpers.clear, helpers.execute, helpers.expect, helpers.wait++local function expect_empty_buffer()+  -- The space will be removed by helpers.dedent but is needed as dedent will+  -- throw an error if it can not find the common indent of the given lines.+  return expect(' ')+end+local function expect_line(line)+  return eq(line, eval('getline(""."")'))+end+local function write_file(name, text)+  local file = io.open(name, 'w')+  file:write(text)+  file:flush()+  file:close()+end++describe('undo:', function()+  before_each(clear)+  teardown(function()+    os.remove('Xtest.source')+  end)++  describe(':earlier and :later', function()+    before_each(function()+      os.remove('Xtest')+    end)+    teardown(function()+      os.remove('Xtest')+    end)++    it('work with time specifications and g- and g+', function()+      -- We write the test text to a file in order to prevent nvim to record+      -- the inserting of the text into the undo history.+      write_file('Xtest', '\n123456789\n')++      -- Note: This test is not executed directly like the other tests.  It is+      -- encapsuled in a function and will be tried up to three times if it+      -- fails.  This is done because the test is dependent on wall clock time+      -- and somtimes fails if the system is under load or the test is paused+      -- for a long enough interval.","Instead of this comment, consider renaming `test()` to `test_earlier_later()` with this comment:```-- `:earlier` and `:later` are (obviously) time-sensitive, so this test-- sometimes fails if the system is under load. It is wrapped in a local -- function to allow multiple attempts.```",
292468,isbadawi,https://api.github.com/repos/neovim/neovim/pulls/2703,33145912,2015-06-24T13:19:39Z,src/nvim/ops.c,"@@ -5291,6 +5291,8 @@ static yankreg_T *adjust_clipboard_name(int *name, bool quiet)  static bool get_clipboard(int name, yankreg_T **target, bool quiet) {+  bool noerrmsg = false;","Why not `errmsg = true`, and reverse the conditions elsewhere? This would avoid the double-negative below:```if (!noerrmsg) {  EMSG(""clipboard: provider returned invalid data"");}```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2703,33300831,2015-06-25T20:25:48Z,runtime/autoload/provider/clipboard.vim,"@@ -4,43 +4,88 @@ let s:copy = {} let s:paste = {} +"" when caching is enabled, store the jobid of the xclip/xsel process+"" keeping ownership of the selection, so we know how long the cache is valid+let s:selection = { 'owner': 0, 'data': [] }++function! s:selection.on_exit(jobid, data, event)+  "" At this point this nvim instance might already have launched+  "" a new provider instance. Don't drop ownership in this case.+  if self.owner == a:jobid+    let self.owner = 0+  endif+endfunction++let s:selections = { '*': s:selection, '+': copy(s:selection)}+ function! s:try_cmd(cmd, ...)-  let out = a:0 ? systemlist(a:cmd, a:1, 1) : systemlist(a:cmd, [''], 1)+  let argv = split(a:cmd, "" "")+  let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)   if v:shell_error-    echo ""clipboard: error: "".(len(out) ? out[0] : '')-    return ''+    echohl WarningMsg+      echo ""clipboard: error: "".(len(out) ? out[0] : '')+    echohl None+    return 0   endif   return out endfunction +let s:cache_enabled = 1 if executable('pbcopy')   let s:copy['+'] = 'pbcopy'   let s:paste['+'] = 'pbpaste'   let s:copy['*'] = s:copy['+']   let s:paste['*'] = s:paste['+']+  let s:cache_enabled = 0 elseif executable('xclip')-  let s:copy['+'] = 'xclip -i -selection clipboard'+  let s:copy['+'] = 'xclip -quiet -i -selection clipboard'   let s:paste['+'] = 'xclip -o -selection clipboard'-  let s:copy['*'] = 'xclip -i -selection primary'+  let s:copy['*'] = 'xclip -quiet -i -selection primary'   let s:paste['*'] = 'xclip -o -selection primary' elseif executable('xsel')-  let s:copy['+'] = 'xsel -i -b'+  let s:copy['+'] = 'xsel --nodetach -i -b'   let s:paste['+'] = 'xsel -o -b'-  let s:copy['*'] = 'xsel -i -p'+  let s:copy['*'] = 'xsel --nodetach -i -p'   let s:paste['*'] = 'xsel -o -p' else   echom 'clipboard: No shell command for communicating with the clipboard found.'+  echom 'clipboard: see :help nvim-clipboard'   finish endif  let s:clipboard = {}","But this belong together with the two method definitions just below. It is not a ""state"" variable.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2901,33315045,2015-06-25T23:09:56Z,test/functional/legacy/032_insert_expansion_spec.lua,"@@ -0,0 +1,90 @@+-- Test for insert expansion+-- :se cpt=.,w+-- * add-expands (word from next line) from other window+-- * add-expands (current buffer first)+-- * Local expansion, ends in an empty line (unless it becomes a global expansion)+-- * starts Local and switches to global add-expansion+-- :se cpt=.,w,i+-- * i-add-expands and switches to local+-- * add-expands lines (it would end in an empty line if it didn't ignored it self)+-- :se cpt=kXtestfile+-- * checks k-expansion, and file expansion (use Xtest11 instead of test11,+-- * because TEST11.OUT may match first on DOS)+-- :se cpt=w+-- * checks make_cyclic in other window+-- :se cpt=u nohid+-- * checks unloaded buffer expansion+-- * checks adding mode abortion+-- :se cpt=t,d+-- * tag expansion, define add-expansion interrupted+-- * t-expansion++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('Insert expansion', function()+  setup(clear)++  it('is working', function()+    insert([[+      start of testfile+      run1+      run2+      end of testfile++      test11	36Gepeto	/Tag/+      asd	test11file	36G+      Makefile	to	run]])++    execute('se backspace=""""')+    execute('se cpt=.,w ff=unix | $-2,$w!Xtestfile | set ff&')+    execute('se cot=')","In general, prefer to use the long option name instead of the abbreviated name. ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2703,33368169,2015-06-26T15:50:03Z,runtime/autoload/provider/clipboard.vim,"@@ -4,43 +4,88 @@ let s:copy = {} let s:paste = {} +"" when caching is enabled, store the jobid of the xclip/xsel process+"" keeping ownership of the selection, so we know how long the cache is valid+let s:selection = { 'owner': 0, 'data': [] }++function! s:selection.on_exit(jobid, data, event)+  "" At this point this nvim instance might already have launched+  "" a new provider instance. Don't drop ownership in this case.+  if self.owner == a:jobid+    let self.owner = 0+  endif+endfunction++let s:selections = { '*': s:selection, '+': copy(s:selection)}+ function! s:try_cmd(cmd, ...)-  let out = a:0 ? systemlist(a:cmd, a:1, 1) : systemlist(a:cmd, [''], 1)+  let argv = split(a:cmd, "" "")+  let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)   if v:shell_error-    echo ""clipboard: error: "".(len(out) ? out[0] : '')-    return ''+    echohl WarningMsg+      echo ""clipboard: error: "".(len(out) ? out[0] : '')+    echohl None+    return 0   endif   return out endfunction +let s:cache_enabled = 1 if executable('pbcopy')   let s:copy['+'] = 'pbcopy'   let s:paste['+'] = 'pbpaste'   let s:copy['*'] = s:copy['+']   let s:paste['*'] = s:paste['+']+  let s:cache_enabled = 0 elseif executable('xclip')-  let s:copy['+'] = 'xclip -i -selection clipboard'+  let s:copy['+'] = 'xclip -quiet -i -selection clipboard'   let s:paste['+'] = 'xclip -o -selection clipboard'-  let s:copy['*'] = 'xclip -i -selection primary'+  let s:copy['*'] = 'xclip -quiet -i -selection primary'   let s:paste['*'] = 'xclip -o -selection primary' elseif executable('xsel')-  let s:copy['+'] = 'xsel -i -b'+  let s:copy['+'] = 'xsel --nodetach -i -b'   let s:paste['+'] = 'xsel -o -b'-  let s:copy['*'] = 'xsel -i -p'+  let s:copy['*'] = 'xsel --nodetach -i -p'   let s:paste['*'] = 'xsel -o -p' else   echom 'clipboard: No shell command for communicating with the clipboard found.'+  echom 'clipboard: see :help nvim-clipboard'","EXX are for _errors_. It is inconsistent to do this for :echomsg. Also note that1. These messages will not be translated. Translators currently have reasons to expect all messages mentioned in .po files. Users would expect that all messages will _eventually_ be tranlated.2. When defining new messages searching numbers in runtime/ files would be unexpected from developers that got used to Vim.3. When merging patches from Vim it may appear that our error message code conflicts with Vim error message code.4. Exxx messages are expected to be caught as `Vim({command}):E{number}:`, but this is not possible here.5. It is generally harder to maintain unambiguous error numbers, identifiers like `E:[{plugin}/]{component}/{id}` (e.g. `E:clipboard/nocmd` are much less likely to clash (`E:` is needed to mark error as error in :help, without making user remember a convention and is thus not much useful: most of time `:h clipboard/nocmd` will normally get you to the same topic as `:h E:clipboard/nocmd`).I do not agree about :h in error messages _in the current state_: they either need proper identifiers like described above or explicit :h: I would remember the topic only if it is either always there (i.e. as error identifier or explicit :h reference) or if NeoVim often will not work with such messages.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2703,33372966,2015-06-26T16:43:37Z,runtime/autoload/provider/clipboard.vim,"@@ -4,43 +4,88 @@ let s:copy = {} let s:paste = {} +"" when caching is enabled, store the jobid of the xclip/xsel process+"" keeping ownership of the selection, so we know how long the cache is valid+let s:selection = { 'owner': 0, 'data': [] }++function! s:selection.on_exit(jobid, data, event)+  "" At this point this nvim instance might already have launched+  "" a new provider instance. Don't drop ownership in this case.+  if self.owner == a:jobid+    let self.owner = 0+  endif+endfunction++let s:selections = { '*': s:selection, '+': copy(s:selection)}+ function! s:try_cmd(cmd, ...)-  let out = a:0 ? systemlist(a:cmd, a:1, 1) : systemlist(a:cmd, [''], 1)+  let argv = split(a:cmd, "" "")+  let out = a:0 ? systemlist(argv, a:1, 1) : systemlist(argv, [''], 1)   if v:shell_error-    echo ""clipboard: error: "".(len(out) ? out[0] : '')-    return ''+    echohl WarningMsg+      echo ""clipboard: error: "".(len(out) ? out[0] : '')+    echohl None+    return 0   endif   return out endfunction +let s:cache_enabled = 1 if executable('pbcopy')   let s:copy['+'] = 'pbcopy'   let s:paste['+'] = 'pbpaste'   let s:copy['*'] = s:copy['+']   let s:paste['*'] = s:paste['+']+  let s:cache_enabled = 0 elseif executable('xclip')-  let s:copy['+'] = 'xclip -i -selection clipboard'+  let s:copy['+'] = 'xclip -quiet -i -selection clipboard'   let s:paste['+'] = 'xclip -o -selection clipboard'-  let s:copy['*'] = 'xclip -i -selection primary'+  let s:copy['*'] = 'xclip -quiet -i -selection primary'   let s:paste['*'] = 'xclip -o -selection primary' elseif executable('xsel')-  let s:copy['+'] = 'xsel -i -b'+  let s:copy['+'] = 'xsel --nodetach -i -b'   let s:paste['+'] = 'xsel -o -b'-  let s:copy['*'] = 'xsel -i -p'+  let s:copy['*'] = 'xsel --nodetach -i -p'   let s:paste['*'] = 'xsel -o -p' else   echom 'clipboard: No shell command for communicating with the clipboard found.'+  echom 'clipboard: see :help nvim-clipboard'","> It is generally harder to maintain unambiguous error numbers, identifiers like `E:[{plugin}/]{component}/{id}`That's a good idea. > they either need proper identifiers like described above or explicit :hYes. My general request is to find a concise tag convention (EXX or something else). ""See :h foo"" unfortunately is not concise enough in the space constraints of `:echo`.The merged code contains `:h nvim-clipboard` for now.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2923,33425246,2015-06-28T18:09:47Z,src/nvim/os/shell.c,"@@ -63,6 +63,8 @@ char **shell_build_argv(const char *cmd, const char *extra_args)    rv[i] = NULL; +  assert(rv[0]);","It's fine as-is, I made a bad assumption based on line 64.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2700,33499270,2015-06-29T19:01:09Z,runtime/tutorials/en/01-vim-beginner.tutor,"@@ -0,0 +1,959 @@+#             Welcome   to   the   VIM   Tutor++Vim is a very powerful editor that has many commands, too many to explain in a+tutor such as this. This tutor is designed to describe enough of the commands+that you will be able to easily use Vim as an all-purpose editor. It is+IMPORTANT to remember that this tutor is set up to teach by use. That means+that you need to do the exercises to learn them properly. If you only read+the text, you will soon forget what is most important!++NOTE: The commands in the lessons will modify the text, but those changes won't+be saved. Don't worry about messing things up; just remember that pressing+[<Esc>](<Esc>) and then [u](u) will undo the latest change.++This tutorial is interactive, and there are a few things you should know.+Pressing [<Enter>](<Enter>) over text highlighted [like this](holy-grail) will take you to some relevant+help (hopefully), and pressing K over any word will try to do so too. Sometimes+you will be required to modify text like+--->  this here {expect:this here}+Once you have done the changes correctly, the ��� sign at the left will change+to ���. I imagine you can already see how neat Vim can be ;)+Other times, you'll be prompted to run a command (I'll explain this later):+~~~ cmd+    :help <Enter>+~~~+or press a sequence of keys+~~~ normal+    <Esc\>0f<Space>d3wP$P+~~~++Text within <'s and >'s (like `<Enter>`{normal}) describes a key to press instead of text+to type.++Now, make sure that your Shift-Lock key is NOT depressed and press the ��j��+key enough times to move the cursor so that Lesson 1.1 completely fills the+screen.++## Lesson 1.1: MOVING THE CURSOR++** To move the cursor, press the `h`, `j`, `k`, `l` keys as indicated. **++         ���+         k          Hint: The h key is at the left and moves left.+       ��� h   l ���          The l key is at the right and moves right.+         j                The j key looks like a down arrow.+         ���++  1. Move the cursor around the screen until you are comfortable.++  2. Hold down the down key (j) until it repeats.+     Now you know how to move to the next lesson.++  3. Using the down key, move to Lesson 1.2.++NOTE: If you are ever unsure about something you typed, press <Esc> to place+      you in Normal mode.  Then retype the command you wanted.++NOTE: The cursor keys should also work.  But using hjkl you will be able to+      move around much faster, once you get used to it.  Really!++# Lesson 1.2: EXITING VIM++!! NOTE: Before executing any of the steps below, read this entire lesson !!++  1. Press the <Esc> key (to make sure you are in [Normal mode]().++  2. Type:++    `:q!`{vim} `<Enter>`{normal}.++     This exits the editor, DISCARDING any changes you have made.++  3. Open vim and get back here by executing the command that got you into this+     tutor. That might be:++     :Vimtutor <Enter>++  4. If you have these steps memorized and are confident, execute steps+     1 through 3 to exit and re-enter the editor.++NOTE:  [:q!](:q) <Enter>  discards any changes you made.  In a few lessons you+       will learn how to save the changes to a file.++  5. Move the cursor down to Lesson 1.3.++## Lesson 1.3: TEXT EDITING - DELETION++** Press `x`{normal} to delete the character under the cursor. **++1. Move the cursor to the line below marked --->.++2. To fix the errors, move the cursor until it is on top of the+   character to be deleted.++3. Press [the x key](x) to delete the unwanted character.++4. Repeat steps 2 through 4 until the sentence is correct.++---> The ccow jumpedd ovverr thhe mooon. {expect:The cow jumped over the moon.}++5. Now that the line is correct, go on to Lesson 1.4.++NOTE: As you go through this tutor, do not try to memorize, learn by usage.++# Lesson 1.4: TEXT EDITING: INSERTION++** Press `i`{normal} to insert text. **++  1. Move the cursor to the first line below marked --->.++  2. To make the first line the same as the second, move the cursor on top+     of the first character AFTER where the text is to be inserted.++  3. Press  i  and type in the necessary additions.++  4. As each error is fixed press <Esc> to return to Normal mode.+     Repeat steps 2 through 4 to correct the sentence.++---> There is text misng this . {expect:There is some text missing from this line.}+---> There is some text missing from this line. {expect:There is some text missing from this line.}++  5. When you are comfortable inserting text move to lesson 1.5.++# Lesson 1.5: TEXT EDITING: APPENDING++** Press `A`{normal} to append text. **++  1. Move the cursor to the first line below marked --->.+     It does not matter on what character the cursor is in that line.++  2. Press  [A](A)  and type in the necessary additions.++  3. As the text has been appended press <Esc> to return to Normal mode.++  4. Move the cursor to the second line marked ---> and repeat+     steps 2 and 3 to correct this sentence.++---> There is some text missing from th {expect:There is some text missing from this line.}+---> There is some text missing from this line. {expect:There is some text missing from this line.}+---> There is also some text miss {expect:There is also some text missing here.}+---> There is also some text missing here. {expect:There is also some text missing here.}++  5. When you are comfortable appending text move to lesson 1.6.++# Lesson 1.6: EDITING A FILE++** Use `:wq`{vim} to save a file and exit. **++!! NOTE: Before executing any of the steps below, read this entire lesson !!++  1. Exit this tutor as you did in lesson 1.2:  :q!+     Or, if you have access to another terminal, do the following there.++  2. At the shell prompt type this command:+~~~ sh+     $ nvim tutor+~~~+     'nvim' is the command to start the Neovim editor, 'tutor' is the name of the+     file you wish to edit.  Use a file that may be changed.++  3. Insert and delete text as you learned in the previous lessons.++  4. Save the file with changes and exit Neovim with:+~~~ cmd+     :wq+~~~++     Note you'll need to press `<Enter>` to execute the command.++  5. If you have quit this tutorial in step 1 restart it and move down to+     the following summary.++  6. After reading the above steps and understanding them: do it.++# Lesson 1 SUMMARY++  1. The cursor is moved using either the arrow keys or the hjkl keys.+     h (left)   j (down)       k (up)       l (right)++  2. To start Neovim from the shell prompt type:++~~~ sh+    $ nvim FILENAME+~~~++  3. To exit Neovim type:     <Esc>   :q!   <Enter>  to trash all changes.+         OR type:      <Esc>   :wq   <Enter>  to save the changes.++  4. To delete the character at the cursor type:  `x`{normal}++  5. To insert or append text type:+     `i`{normal} type inserted text `<Esc>`{normal}     insert before the cursor+     `A`{normal} type appended text `<Esc>`{normal}     append after the line++NOTE: Pressing `<Esc>`{normal} will place you in Normal mode or will cancel+      an unwanted and partially completed command.++Now continue with Lesson 2.++# Lesson 2.1: DELETION COMMANDS++** Type `dw`{normal} to delete a word. **++  1. Press `<Esc>`{normal} to make sure you are in Normal mode.++  2. Move the cursor to the line below marked --->.++  3. Move the cursor to the beginning of a word that needs to be deleted.++  4. Type [d](d)[w](w)   to make the word disappear.++---> There are a some words fun that don't belong paper in this sentence. {expect:There are some words that don't belong in this sentence.}++  5. Repeat steps 3 and 4 until the sentence is correct and go to Lesson 2.2.++# Lesson 2.2: MORE DELETION COMMANDS++** Type `d$`{normal}  to delete to the end of the line. **++  1. Press  <Esc>  to make sure you are in Normal mode.++  2. Move the cursor to the line below marked --->.++  3. Move the cursor to the end of the correct line (AFTER the first . ).++  4. Type ��d$�� to delete to the end of the line.","Should it be `[d](d)[$]($)` (similar to lesson 2.1, point 4)? Or:````d$`{normal}```?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2700,33506541,2015-06-29T20:09:50Z,runtime/plugin/tutor-mode.vim,"@@ -0,0 +1,12 @@+if exists('g:loaded_tutor_mode_plugin') || &compatible+    finish+endif+let g:loaded_tutor_mode_plugin = 1++"" disable the indent guides plugin in tutor files, to reduce clutter+if exists('g:indent_guides_exclude_filetypes')+    call add(g:indent_guides_exclude_filetypes, 'tutor')+endif++command! -nargs=1 -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<f-args>)+command! -nargs=0 VimTutor Tutor 01-vim-beginner","These commands will now be in the command list _forever_, even though they are only useful once or twice for new users. We can at least eliminate one of these, e.g. `Tutor` could default to `01-vim-beginner` if it is run without args.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2700,33508847,2015-06-29T20:29:05Z,runtime/tutorials/en/01-vim-beginner.tutor,"@@ -0,0 +1,959 @@+#             Welcome   to   the   VIM   Tutor++Vim is a very powerful editor that has many commands, too many to explain in a+tutor such as this. This tutor is designed to describe enough of the commands+that you will be able to easily use Vim as an all-purpose editor. It is+IMPORTANT to remember that this tutor is set up to teach by use. That means+that you need to do the exercises to learn them properly. If you only read+the text, you will soon forget what is most important!++NOTE: The commands in the lessons will modify the text, but those changes won't+be saved. Don't worry about messing things up; just remember that pressing+[<Esc>](<Esc>) and then [u](u) will undo the latest change.++This tutorial is interactive, and there are a few things you should know.+Pressing [<Enter>](<Enter>) over text highlighted [like this](holy-grail) will take you to some relevant+help (hopefully), and pressing K over any word will try to do so too. Sometimes+you will be required to modify text like+--->  this here {expect:this here}+Once you have done the changes correctly, the ��� sign at the left will change+to ���. I imagine you can already see how neat Vim can be ;)+Other times, you'll be prompted to run a command (I'll explain this later):+~~~ cmd+    :help <Enter>+~~~+or press a sequence of keys+~~~ normal+    <Esc\>0f<Space>d3wP$P+~~~++Text within <'s and >'s (like `<Enter>`{normal}) describes a key to press instead of text+to type.++Now, make sure that your Shift-Lock key is NOT depressed and press the ��j��+key enough times to move the cursor so that Lesson 1.1 completely fills the+screen.++## Lesson 1.1: MOVING THE CURSOR++** To move the cursor, press the `h`, `j`, `k`, `l` keys as indicated. **++         ���+         k          Hint: The h key is at the left and moves left.+       ��� h   l ���          The l key is at the right and moves right.+         j                The j key looks like a down arrow.+         ���++  1. Move the cursor around the screen until you are comfortable.++  2. Hold down the down key (j) until it repeats.+     Now you know how to move to the next lesson.++  3. Using the down key, move to Lesson 1.2.++NOTE: If you are ever unsure about something you typed, press <Esc> to place+      you in Normal mode.  Then retype the command you wanted.++NOTE: The cursor keys should also work.  But using hjkl you will be able to+      move around much faster, once you get used to it.  Really!++# Lesson 1.2: EXITING VIM++!! NOTE: Before executing any of the steps below, read this entire lesson !!++  1. Press the <Esc> key (to make sure you are in [Normal mode]().++  2. Type:++    `:q!`{vim} `<Enter>`{normal}.++     This exits the editor, DISCARDING any changes you have made.++  3. Open vim and get back here by executing the command that got you into this+     tutor. That might be:++     :Vimtutor <Enter>++  4. If you have these steps memorized and are confident, execute steps+     1 through 3 to exit and re-enter the editor.++NOTE:  [:q!](:q) <Enter>  discards any changes you made.  In a few lessons you+       will learn how to save the changes to a file.++  5. Move the cursor down to Lesson 1.3.++## Lesson 1.3: TEXT EDITING - DELETION++** Press `x`{normal} to delete the character under the cursor. **++1. Move the cursor to the line below marked --->.++2. To fix the errors, move the cursor until it is on top of the+   character to be deleted.++3. Press [the x key](x) to delete the unwanted character.++4. Repeat steps 2 through 4 until the sentence is correct.++---> The ccow jumpedd ovverr thhe mooon. {expect:The cow jumped over the moon.}++5. Now that the line is correct, go on to Lesson 1.4.++NOTE: As you go through this tutor, do not try to memorize, learn by usage.++# Lesson 1.4: TEXT EDITING: INSERTION++** Press `i`{normal} to insert text. **++  1. Move the cursor to the first line below marked --->.++  2. To make the first line the same as the second, move the cursor on top+     of the first character AFTER where the text is to be inserted.++  3. Press  i  and type in the necessary additions.++  4. As each error is fixed press <Esc> to return to Normal mode.+     Repeat steps 2 through 4 to correct the sentence.++---> There is text misng this . {expect:There is some text missing from this line.}+---> There is some text missing from this line. {expect:There is some text missing from this line.}++  5. When you are comfortable inserting text move to lesson 1.5.++# Lesson 1.5: TEXT EDITING: APPENDING++** Press `A`{normal} to append text. **++  1. Move the cursor to the first line below marked --->.+     It does not matter on what character the cursor is in that line.++  2. Press  [A](A)  and type in the necessary additions.++  3. As the text has been appended press <Esc> to return to Normal mode.++  4. Move the cursor to the second line marked ---> and repeat+     steps 2 and 3 to correct this sentence.++---> There is some text missing from th {expect:There is some text missing from this line.}+---> There is some text missing from this line. {expect:There is some text missing from this line.}+---> There is also some text miss {expect:There is also some text missing here.}+---> There is also some text missing here. {expect:There is also some text missing here.}++  5. When you are comfortable appending text move to lesson 1.6.++# Lesson 1.6: EDITING A FILE++** Use `:wq`{vim} to save a file and exit. **++!! NOTE: Before executing any of the steps below, read this entire lesson !!++  1. Exit this tutor as you did in lesson 1.2:  :q!+     Or, if you have access to another terminal, do the following there.++  2. At the shell prompt type this command:+~~~ sh+     $ nvim tutor+~~~+     'nvim' is the command to start the Neovim editor, 'tutor' is the name of the+     file you wish to edit.  Use a file that may be changed.++  3. Insert and delete text as you learned in the previous lessons.++  4. Save the file with changes and exit Neovim with:+~~~ cmd+     :wq+~~~++     Note you'll need to press `<Enter>` to execute the command.++  5. If you have quit this tutorial in step 1 restart it and move down to+     the following summary.++  6. After reading the above steps and understanding them: do it.++# Lesson 1 SUMMARY++  1. The cursor is moved using either the arrow keys or the hjkl keys.+     h (left)   j (down)       k (up)       l (right)++  2. To start Neovim from the shell prompt type:++~~~ sh+    $ nvim FILENAME+~~~++  3. To exit Neovim type:     <Esc>   :q!   <Enter>  to trash all changes.+         OR type:      <Esc>   :wq   <Enter>  to save the changes.++  4. To delete the character at the cursor type:  `x`{normal}++  5. To insert or append text type:+     `i`{normal} type inserted text `<Esc>`{normal}     insert before the cursor+     `A`{normal} type appended text `<Esc>`{normal}     append after the line++NOTE: Pressing `<Esc>`{normal} will place you in Normal mode or will cancel+      an unwanted and partially completed command.++Now continue with Lesson 2.++# Lesson 2.1: DELETION COMMANDS++** Type `dw`{normal} to delete a word. **++  1. Press `<Esc>`{normal} to make sure you are in Normal mode.++  2. Move the cursor to the line below marked --->.++  3. Move the cursor to the beginning of a word that needs to be deleted.++  4. Type [d](d)[w](w)   to make the word disappear.++---> There are a some words fun that don't belong paper in this sentence. {expect:There are some words that don't belong in this sentence.}++  5. Repeat steps 3 and 4 until the sentence is correct and go to Lesson 2.2.++# Lesson 2.2: MORE DELETION COMMANDS++** Type `d$`{normal}  to delete to the end of the line. **++  1. Press  <Esc>  to make sure you are in Normal mode.++  2. Move the cursor to the line below marked --->.++  3. Move the cursor to the end of the correct line (AFTER the first . ).++  4. Type ��d$�� to delete to the end of the line.++---> Somebody typed the end of this line twice. end of this line twice. {expect:ANYTHING}++  5. Move on to Lesson 2.3 to understand what is happening.++# Lesson 2.3: ON OPERATORS AND MOTIONS+++Many commands that change text are made from an [operator](operator) and a [motion](navigation).+The format for a delete command with the  [d](d)  delete operator is as follows:++    d   motion++  Where:+    d      - is the delete operator.+    motion - is what the operator will operate on (listed below).++  A short list of motions:+    [w](w) - until the start of the next word, EXCLUDING its first character.+    [e](e) - to the end of the current word, INCLUDING the last character.+    [$]($) - to the end of the line, INCLUDING the last character.++  Thus typing  `de`{normal}  will delete from the cursor to the end of the word.++NOTE:  Pressing just the motion while in Normal mode without an operator will+       move the cursor as specified.++# Lesson 2.4: USING A COUNT FOR A MOTION++** Typing a number before a motion repeats it that many times. **++  1. Move the cursor to the start of the line marked ---> below.++  2. Type  `2w`{normal}  to move the cursor two words forward.++  3. Type  `3e`{normal}  to move the cursor to the end of the third word forward.++  4. Type  `0`{normal}  ([zero](0)) to move to the start of the line.++  5. Repeat steps 2 and 3 with different numbers.++---> This is just a line with words you can move around in. {expect:ANYTHING}++  6. Move on to Lesson 2.5.++# Lesson 2.5: USING A COUNT TO DELETE MORE++** Typing a number with an operator repeats it that many times. **++In the combination of the delete operator and a motion mentioned above you+insert a count before the motion to delete more:+     d   number   motion++  1. Move the cursor to the first UPPER CASE word in the line marked --->.++  2. Type  `d2w`{normal}  to delete the two UPPER CASE words++  3. Repeat steps 1 and 2 with a different count to delete the consecutive+     UPPER CASE words with one command++---> this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up. {expect:this line of words is cleaned up.}++# Lesson 2.6: OPERATING ON LINES++** Type  dd   to delete a whole line. **++  Due to the frequency of whole line deletion, the designers of Vi decided+  it would be easier to simply type two d's to delete a line.++  1. Move the cursor to the second line in the phrase below.+  2. Type  [dd](dd)  to delete the line.+  3. Now move to the fourth line.+  4. Type `2dd`{normal} to delete two lines.++--->  1)  Roses are red, {expect:ANYTHING}+--->  2)  Mud is fun, {expect:ANYTHING}+--->  3)  Violets are blue, {expect:ANYTHING}+--->  4)  I have a car, {expect:ANYTHING}+--->  5)  Clocks tell time, {expect:ANYTHING}+--->  6)  Sugar is sweet {expect:ANYTHING}+--->  7)  And so are you. {expect:ANYTHING}++# Lesson 2.7: THE UNDO COMMAND++** Press u to undo the last commands, U to fix a whole line. **++  1. Move the cursor to the line below marked ---> and place it on the+     first error.+  2. Type  `x`{normal}  to delete the first unwanted character.+  3. Now type  `u`{normal}  to undo the last command executed.+  4. This time fix all the errors on the line using the  ��x��  command.+  5. Now type a capital  `U`{normal}  to return the line to its original state.+  6. Now type  `u`{normal}  a few times to undo the  U  and preceding commands.+  7. Now type  `<Ctrl-r>`{normal}  a few times to redo the commands (undo the undo's).++---> Fiix the errors oon thhis line and reeplace them witth undo. {expect:Fix the errors on this line and replace them with undo.}++  8. These are very useful commands.  Now move on to the Lesson 2 Summary.++# Lesson 2 SUMMARY++  1. To delete from the cursor up to the next word type:    `dw`{normal}+  2. To delete from the cursor to the end of a line type:   `d$`{normal}+  3. To delete a whole line type:                           `dd`{normal}+  4. To repeat a motion prepend it with a number:           `2w`{normal}++  5. The format for a change command is:+               operator   [number]   motion+     where:+       operator -   is what to do, such as  [d](d)  for delete+       [number] -   is an optional count to repeat the motion+       motion   -   moves over the text to operate on, such as:+                        [w](w) (word),+                        [$]($) (to the end of line), etc.++  6. To move to the start of the line use a zero:  [0](0)++  7. To undo previous actions, type:            `u`{normal}  (lowercase u)+     To undo all the changes on a line, type:   `U`{normal}  (capital U)+     To undo the undo's, type:                  `<Ctrl-r>`{normal}++# Lesson 3.1: THE PUT COMMAND++** Type p to put previously deleted text after the cursor. **++  1. Move the cursor to the first ---> line below.++  2. Type  `dd`{normal}  to delete the line and store it in a Vim register.++  3. Move the cursor to the c) line, ABOVE where the deleted line should go.++  4. Type `p`{normal}   to put the line below the cursor.++  5. Repeat steps 2 through 4 to put all the lines in correct order.++---> d) Can you learn too? {expect:ANYTHING}+---> b) Violets are blue, {expect:ANYTHING}+---> c) Intelligence is learned, {expect:ANYTHING}+---> a) Roses are red, {expect:ANYTHING}++# Lesson 3.2: THE REPLACE COMMAND++** Type `rx`{normal} to replace the character at the cursor with x. **++  1. Move the cursor to the first line below marked --->.++  2. Move the cursor so that it is on top of the first error.++  3. Type `r`{normal} and then the character which should be there.++  4. Repeat steps 2 and 3 until the first line is equal to the second one.++---> Whan this lime was tuoed in, someone presswd some wrojg keys! {expect:When this line was typed in, someone pressed some wrong keys!}+---> When this line was typed in, someone pressed some wrong keys! {expect:When this line was typed in, someone pressed some wrong keys!}++  5. Now move on to Lesson 3.3.++NOTE: Remember that you should be learning by doing, not memorization.++# Lesson 3.3: THE CHANGE OPERATOR++** To change until the end of a word, type `ce`{normal}  **++  1. Move the cursor to the first line below marked --->.++  2. Place the cursor on the  ""u""  in  ""lubw"".++  3. Type `ce`{normal} and the correct word (in this case, type ""ine"" ).++  4. Press `<Esc>`{normal} and move to the next character that needs to be changed.++  5. Repeat steps 3 and 4 until the first sentence is the same as the second.++---> This lubw has a few wptfd that mrrf changing usf the change operator. {expect:This line has a few words that need changing using the change operator.}+---> This line has a few words that need changing using the change operator. {expect:This line has a few words that need changing using the change operator.}++Notice that [c](c)e deletes the word and places you in Insert mode.++# Lesson 3.4: MORE CHANGES USING c++** The change operator is used with the same motions as delete. **++  1. The change operator works in the same way as delete.  The format is:++         c    [number]   motion++  2. The motions are the same, such as `w`{normal} (word) and `$`{normal} (end of line).++  3. Move to the first line below marked --->.++  4. Move the cursor to the first error.++  5. Type `c$`{normal} and type the rest of the line like the second and press `<Esc>`{normal}.++---> The end of this line needs some help to make it like the second. {expect:The end of this line needs to be corrected using the  c$  command.}+---> The end of this line needs to be corrected using the  c$  command. {expect:The end of this line needs to be corrected using the  c$  command.}++NOTE:  You can use the Backspace key to correct mistakes while typing.++# Lesson 3 SUMMARY++  1. To put back text that has just been deleted, type [p](p).  This puts the+     deleted text AFTER the cursor (if a line was deleted it will go on the+     line below the cursor).++  2. To replace the character under the cursor, type [r](r) and then the+     character you want to have there.++  3. The [change operator](c) allows you to change from the cursor to where the+     motion takes you.  eg. Type  `ce`{normal}  to change from the cursor to the end of+     the word,  `c$`{normal}  to change to the end of a line.++  4. The format for change is:++     c   [number]   motion++Now go on to the next lesson.++# Lesson 4.1: CURSOR LOCATION AND FILE STATUS++** Type `<Ctrl-g>`{normal} to show your location in the file and the file status.+ Type  `G`{normal}  to move to a line in the file. **++NOTE: Read this entire lesson before executing any of the steps!!++  1. Hold down the `<Ctrl>`{normal} key and press `g`{normal}.  We call this `<Ctrl-g>`{normal}.+     A message will appear at the bottom of the page with the filename and the+     position in the file.  Remember the line number for Step 3.++NOTE:  You may see the cursor position in the lower right corner of the screen+       This happens when the ['ruler']('ruler') option is set (see  :help 'ruler'  )++  2. Press [G](G)  to move you to the bottom of the file.+     Type  [gg](gg)  to move you to the start of the file.++  3. Type the number of the line you were on and then  `G`{normal} .  This will+     return you to the line you were on when you first pressed `<Ctrl-g>`{normal}.++  4. If you feel confident to do this, execute steps 1 through 3.++# Lesson 4.2: THE SEARCH COMMAND++** Type `/`{normal} followed by a phrase to search for the phrase. **++  1. In Normal mode type the  `/`{normal} character.  Notice that it and the cursor+     appear at the bottom of the screen as with the  :  command.++  2. Now type 'errroor' `<Enter>`{normal}.  This is the word you want to search for.++  3. To search for the same phrase again, simply type  [n](n) .+     To search for the same phrase in the opposite direction, type  [N](N) .++  4. To search for a phrase in the backward direction, use  [?](?)  instead of  / .++  5. To go back to where you came from press  `<Ctrl-o>`{normal}  (Keep Ctrl down while+     pressing the letter o).  Repeat to go back further.  `<Ctrl-i>`{normal} goes forward.++--->  ""errroor"" is not the way to spell error;  errroor is an error. {expect:ANYTHING}++NOTE: When the search reaches the end of the file it will continue at the+      start, unless the ['wrapscan']('wrapscan') option has been reset.++# Lesson 4.3: MATCHING PARENTHESES SEARCH++** Type `%`{normal} to find a matching ),], or }. **++  1. Place the cursor on any (, [, or { in the line below marked --->.++  2. Now type the  [%](%)  character.++  3. The cursor will move to the matching parenthesis or bracket.++  4. Type `%`{normal} to move the cursor to the other matching bracket.++  5. Move the cursor to another (,),[,],{ or } and see what `%`{normal} does.++---> This ( is a test line with ('s, ['s ] and {'s } in it. )) {expect:ANYTHING}++NOTE: This is very useful in debugging a program with unmatched parentheses!++# Lesson 4.4: THE SUBSTITUTE COMMAND++** Type `:s/old/new/g` to substitute ""new"" for ""old"". **++  1. Move the cursor to the line below marked --->.++  2. Type+~~~ cmd+    :s/thee/the/+~~~++    NOTE that the [:s](:s) command only changed the first occurrence of ""thee"" in the line.++  3. Now type+~~~ cmd+     :s/thee/the/g+~~~++     Adding the g [flag](:s_flags) means to substitute globally in the line, change+     all occurrences of ""thee"" in the line.++---> thee best time to see thee flowers is in thee spring. {expect:the best time to see the flowers is in the spring.}++  4. To change every occurrence of a character string between two lines, type+~~~ cmd+     :#,#s/old/new/g+~~~+     where #,# are the line numbers of the range of lines where the substitution is to be done.++     Type+~~~ cmd+     :%s/old/new/g+~~~+     to change every occurrence in the whole file.++     Type+~~~ cmd+     :%s/old/new/gc+~~~+     to find every occurrence in the whole file, with a prompt whether to substitute or not.++# Lesson 4 SUMMARY++  1. `<Ctrl-g>`{normal}     displays your location in the file and the file status.+             `G`{normal}    moves to the end of the file.+     number  `G`{normal}    moves to that line number.+            `gg`{normal}    moves to the first line.++  2. Typing `/`{normal} followed by a phrase searches FORWARD for the phrase.+     Typing `?`{normal} followed by a phrase searches BACKWARD for the phrase.+     After a search type `n`{normal} to find the next occurrence in the same direction+                      or `N`{normal} to search in the opposite direction.+     `<Ctrl-o>`{normal} takes you back to older positions, `<Ctrl-i>`{normal} to newer positions.++  3. Typing `%`{normal} while the cursor is on a (,),[,],{, or } goes to its match.++  4. To substitute new for the first old in a line type+~~~ cmd+        :s/old/new+~~~+     To substitute new for all 'old's on a line type+~~~ cmd+        :s/old/new/g+~~~+     To substitute phrases between two line #'s type+~~~ cmd+        :#,#s/old/new/g+~~~+     To substitute all occurrences in the file type+~~~ cmd+        :%s/old/new/g+~~~+     To ask for confirmation each time add 'c'+~~~ cmd+        :%s/old/new/gc+~~~++# Lesson 5.1: HOW TO EXECUTE AN EXTERNAL COMMAND++** Type `:!`{vim} followed by an external command to execute that command. **++  1. Type the familiar command `:`{normal} to set the cursor at the bottom of the+     screen.  This allows you to enter a command-line command.++  2. Now type the [!](!cmd) (exclamation point) character.  This allows you to+     execute any external shell command.++  3. As an example type ""ls"" following the ""!"" and then hit `<Enter>`{normal}.  This+     will show you a listing of your directory, just as if you were at the+     shell prompt.++NOTE:  It is possible to execute any external command this way, also with+       arguments.++NOTE:  All  :  commands must be finished by hitting <Enter>+       From here on we will not always mention it.++# Lesson 5.2: MORE ON WRITING FILES++** To save the changes made to the text, type `:w`{vim} FILENAME. **++  1. Type `:!ls`{vim} to get a listing of your directory.+     You already know you must hit `<Enter>`{normal} after this.++  2. Choose a filename that does not exist yet, such as TEST.++  3. Now type:+~~~ cmd+        :w TEST+~~~+    (where TEST is the filename you chose.)++  4. This saves the whole file (the Vim Tutor) under the name TEST.+     To verify this, type `:!ls`{vim} again to see your directory.++NOTE: If you were to exit Neovim and start it again with nvim TEST, the file+      would be an exact copy of the tutor when you saved it.++  5. Now remove the file by typing:+~~~ cmd+        :!rm TEST+~~~++# Lesson 5.3: SELECTING TEXT TO WRITE++** To save part of the file, type `v`{normal} motion  `:w FILENAME`{vim} **++  1. Move the cursor to this line.++  2. Press [v](v) and move the cursor to the fifth item below.  Notice that the+     text is highlighted.++  3. Press the `:`{normal} character.  At the bottom of the screen++        :'<,'>++    will appear.++  4. Type++        `:w TEST`{vim}++     where TEST is a filename that does not exist yet.  Verify that you see++        `:'<,'>w TEST`{vim}++     before you press `<Enter>`{normal}.++  5. Neovim will write the selected lines to the file TEST.  Use `:!ls`{vim} to see it.+     Do not remove it yet!  We will use it in the next lesson.++NOTE:  Pressing [v](v) starts [Visual selection](visual-mode). You can move+       the cursor around to make the selection bigger or smaller. Then you can+       use an operator to do something with the text. For example, `d`{normal} deletes+       the text.++# Lesson 5.4: RETRIEVING AND MERGING FILES++** To insert the contents of a file, type `:r FILENAME`{vim}  **++  1. Place the cursor just above this line.++NOTE:  After executing Step 2 you will see text from Lesson 5.3.  Then move+       DOWN to see this lesson again.++  2. Now retrieve your TEST file using the command++        `:r TEST`{vim}++     where TEST is the name of the file you used.+     The file you retrieve is placed below the cursor line.++  3. To verify that a file was retrieved, cursor back and notice that there+     are now two copies of Lesson 5.3, the original and the file version.++NOTE:  You can also read the output of an external command.  For example,++       `:r !ls`{vim}++       reads the output of the `ls` command and puts it below the cursor.++# Lesson 5 SUMMARY++  1.  [:!command](:!cmd)  executes an external command.++      Some useful examples are:+      `:!ls`{vim}              -  shows a directory listing+      `:!rm FILENAME`{vim}     -  removes file FILENAME++  2.  [:w](:w) FILENAME             writes the current file to disk with +                                    name FILENAME.++  3.  [v](v)  motion  :w FILENAME   saves the Visually selected lines in file+                                    FILENAME.++  4.  [:r](:r) FILENAME             retrieves disk file FILENAME and puts it +                                    below the cursor position.++  5.  [:r !dir](:r!)                reads the output of the dir command and +                                    puts it below the cursor position.++# Lesson 6.1: THE OPEN COMMAND++** Type `o`{normal} to open a line below the cursor and place you in Insert mode. **++  1. Move the cursor to the line below marked --->.++  2. Type the lowercase letter `o`{normal} to [open](o) up a line BELOW the cursor and place+     you in Insert mode.++  3. Now type some text and press `<Esc>`{normal} to exit Insert mode.++---> After typing  o  the cursor is placed on the open line in Insert mode. {expect:ANYTHING}++  4. To open up a line ABOVE the cursor, simply type a [capital O](O), rather+     than a lowercase `o`{normal}.  Try this on the line below.++---> Open up a line above this by typing O while the cursor is on this line. {expect:ANYTHING}++# Lesson 6.2: THE APPEND COMMAND++** Type `a`{normal} to insert text AFTER the cursor. **++  1. Move the cursor to the start of the line below marked --->.++  2. Press `e`{normal} until the cursor is on the end of ""li"".++  3. Type an `a`{normal} (lowercase) to [append](a) text AFTER the cursor.++  4. Complete the word like the line below it.  Press `<Esc>`{normal} to exit Insert+     mode.++  5. Use `e`{normal} to move to the next incomplete word and repeat steps 3 and 4.++---> This li will allow you to pract appendi text to a line. {expect:This line will allow you to practice appending text to a line.}+---> This line will allow you to practice appending text to a line. {expect:This line will allow you to practice appending text to a line.}++NOTE:  [a](a), [i](i) and [A](A) all go to the same Insert mode, the only difference is where+       the characters are inserted.++# Lesson 6.3: ANOTHER WAY TO REPLACE++** Type a capital `R`{normal} to replace more than one character. **++  1. Move the cursor to the first line below marked --->.  Move the cursor to+     the beginning of the first ""xxx"".++  2. Now press `R`{normal} ([capital R](R)) and type the number below it in the second line, so that it+     replaces the ""xxx"".++  3. Press `<Esc>`{normal} to leave [Replace mode](mode-replace).  Notice that the rest of the line+     remains unmodified.++  4. Repeat the steps to replace the remaining ""xxx"".++---> Adding 123 to xxx gives you xxx. {expect:Adding 123 to 456 gives you 579.}+---> Adding 123 to 456 gives you 579. {expect:Adding 123 to 456 gives you 579.}++NOTE:  Replace mode is like Insert mode, but every typed character deletes an+       existing character.++# Lesson 6.4: COPY AND PASTE TEXT++** Use the `y`{normal} operator to copy text and `p`{normal} to paste it **++  1. Go to the line marked with ---> below and place the cursor after ""a)"".++  2. Start Visual mode with `v`{normal} and move the cursor to just before ""first"".++  3. Type `y`{normal} to [yank](yank) (copy) the highlighted text.++  4. Move the cursor to the end of the next line: `j$`{normal}++  5. Type `p`{normal} to [put](put) (paste) the text.  Then type:  ""a second""`<Esc>`{normal}.++  6. Use Visual mode to select "" item."", yank it with `y`{normal}, move to the end of+     the next line with `j$`{normal} and put the text there with `p`{normal}.++---> a) this is the first item.+--->     b)  {expect:    b) this is the second item}++  NOTE: you can also use `y`{normal} as an operator; `yw`{normal} yanks one word.++# Lesson 6.5: SET OPTION++** Set an option so a search or substitute ignores case **++  1. Search for 'ignore' by entering:   `/ignore`+     Repeat several times by pressing `n`{normal}.++  2. Set the 'ic' (Ignore case) option by entering:+~~~ cmd+        :set ic+~~~+  3. Now search for 'ignore' again by pressing  n+     Notice that Ignore and IGNORE are now also found.++  4. Set the 'hlsearch' and 'incsearch' options:+~~~ cmd+        :set hls is+~~~+  5. Now type the search command again and see what happens:  /ignore <Enter>++  6. To disable ignoring case enter:+~~~ cmd+        :set noic+~~~+  7. To toggle the value of a setting, prepend it with ""inv"":+~~~ cmd+        :set invic+~~~+NOTE:  To remove the highlighting of matches enter:+~~~ cmd+        :nohlsearch+~~~+NOTE:  If you want to ignore case for just one search command, use  [\c](/\c)+       in the phrase:  /ignore\c  <Enter>++# Lesson 6 SUMMARY++  1. Type `o`{normal} to open a line BELOW the cursor and start Insert mode.+     Type `O`{normal} to open a line ABOVE the cursor.++  2. Type `a`{normal} to insert text AFTER the cursor.+     Type `A`{normal} to insert text after the end of the line.++  3. The `e`{normal} command moves to the end of a word.++  4. The `y`{normal} operator yanks (copies) text, `p`{normal} puts (pastes) it.++  5. Typing a capital `R`{normal} enters Replace mode until `<Esc>`{normal} is pressed.++  6. Typing ""[:set](:set) xxx"" sets the option ""xxx"".  Some options are:+    +        'ic' 'ignorecase'   ignore upper/lower case when searching+        'is' 'incsearch'    show partial matches for a search phrase+        'hls' 'hlsearch'    highlight all matching phrases++     You can either use the long or the short option name.++  7. Prepend ""no"" to switch an option off:+~~~ cmd+        :set noic+~~~+  8. Prepend ""inv"" to toggle an option:+~~~ cmd+        :set invic+~~~++# Lesson 7.1: GETTING HELP++** Use the on-line help system **++Vim has a comprehensive on-line help system.  To get started, try one of+these three:+    - press the `<HELP>`{normal} key (if you have one)+    - press the `<F1>`{normal} key (if you have one)+    - type+        `:help`{vim}++Read the text in the help window to find out how the help works.+Type `<Ctrl-w><Ctrl-w>`{normal} to jump from one window to another.+Type `:q`{vim} to close the help window.++You can find help on just about any subject, by giving an argument to the+"":help"" command.  Try these (don't forget pressing <Enter>):+~~~ cmd+    :help w+    :help c_CTRL-D+    :help insert-index+    :help user-manual+~~~+# Lesson 7.2: CREATE A STARTUP SCRIPT++** Enable Neovim features **++Neovim has many more features than Vi (and Vim), but some of them are disabled by+default.  To start using more features you have to create a ""nvimrc"" file.++  1. Start editing the ""vimrc"" file.  This depends on your system:+    `:e ~/.nvimrc`{vim}     for Unix-like systems+    `:e $VIM/_nvimrc`{vim}      for Microsoft Windows++  2. Now read the example ""vimrc"" file contents:+    `:r $VIMRUNTIME/vimrc_example.vim`{vim}++  3. Write the file with:+    `:w`{vim}++  The next time you start Neovim it will use syntax highlighting.+  You can add all your preferred settings to this ""nvimrc"" file.+  For more information type  :help vimrc-intro++# Lesson 7.3: COMPLETION++** Command line completion with `<Ctrl-d>`{normal} and `<Tab>`{normal} **++  1. Look what files exist in the directory:  `:!ls`{vim}++  2. Type the start of a command:  `:e`{vim}++  3. Press `<Ctrl-d>`{normal} and Neovim will show a list of commands that start with ""e"".++  4. Press `<Tab>`{normal} and Neovim will complete the command name to "":edit"".++  5. Now add a space and the start of an existing file name: `:edit FIL`{vim}++  6. Press `<Tab>`{normal}.  Neovim will complete the name (if it is unique).++NOTE:  Completion works for many commands. It is especially useful for `:help`{vim}.++# Lesson 7 SUMMARY++  1. Type `:help`{vim} +     or press `<F1>`{normal} or `<Help>`{normal} to open a help window.++  2. Type  `:help TOPIC`{vim} to find help on TOPIC.++  3. Type  `<Ctrl-w><Ctrl-w>`{normal}  to jump to another window++  4. Type  `:q`{vim}  to close the help window++  5. Create a nvimrc startup script to keep your preferred settings.++  6. While in command mode, press `<Ctrl-d>`{normal} to see possible completions.+     Press `<Tab>`{normal} to use one completion.++# CONCLUSION++This was intended to give a brief overview of the Vim editor, just enough to+allow you to use the editor fairly easily. It is far from complete as Vim has+many many more commands.  Consult the help often.++Now, you can try a different tutorial:++    `:Tutor 02-vim-intermediate`{vim}++There are many resources online to learn more about vim. Here's a list of a bunch of them:",suggestion: `Here's a list of a bunch of them` => `Here's a bunch of them` or `Here's a list of them`,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2700,33510897,2015-06-29T20:46:26Z,runtime/doc/usr_01.txt,"@@ -70,52 +70,18 @@ If the file already exists you probably want to keep it. For more info see |vimrc|.  ==============================================================================-*01.3*	Using the Vim tutor				*tutor* *vimtutor*+*01.3*	Using the Vim tutor			      	            *tutor*","There is no longer anything called ""vimtutor"", but I can restore it for compatibiility if you think it's necessary.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2928,33516503,2015-06-29T21:35:32Z,runtime/vimrc_example.vim,"@@ -27,29 +23,18 @@ map Q gq "" so that you can undo CTRL-U after inserting a line break. inoremap <C-U> <C-G>u<C-U> -"" In many terminal emulators the mouse works just fine, thus enable it.-if has('mouse')-  set mouse=a-endif- "" Switch syntax highlighting on, when the terminal has colors","Since it's done unconditionally, should just be `Enable syntax highlighting`",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2928,33516817,2015-06-29T21:38:46Z,runtime/vimrc_example.vim,"@@ -27,29 +23,18 @@ map Q gq "" so that you can undo CTRL-U after inserting a line break. inoremap <C-U> <C-G>u<C-U> -"" In many terminal emulators the mouse works just fine, thus enable it.-if has('mouse')-  set mouse=a-endif- "" Switch syntax highlighting on, when the terminal has colors "" Also switch on highlighting the last used search pattern.-if &t_Co > 2 || has(""gui_running"")-  syntax on-  set hlsearch-endif--"" Only do this part when compiled with support for autocommands.-if has(""autocmd"")+syntax on -  "" Enable file type detection.-  "" Use the default filetype settings, so that mail gets 'tw' set to 72,-  "" 'cindent' is on in C files, etc.-  "" Also load indent files, to automatically do language-dependent indenting.-  filetype plugin indent on+"" Enable file type detection.+"" Use the default filetype settings, so that mail gets 'tw' set to 72,","Since this is an example vimrc, I think the long forms should be used (`tw` -> `textwidth`).",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2928,33516833,2015-06-29T21:38:53Z,runtime/vimrc_example.vim,"@@ -27,29 +23,18 @@ map Q gq "" so that you can undo CTRL-U after inserting a line break. inoremap <C-U> <C-G>u<C-U> -"" In many terminal emulators the mouse works just fine, thus enable it.-if has('mouse')-  set mouse=a-endif- "" Switch syntax highlighting on, when the terminal has colors "" Also switch on highlighting the last used search pattern.-if &t_Co > 2 || has(""gui_running"")-  syntax on-  set hlsearch-endif--"" Only do this part when compiled with support for autocommands.-if has(""autocmd"")+syntax on -  "" Enable file type detection.-  "" Use the default filetype settings, so that mail gets 'tw' set to 72,-  "" 'cindent' is on in C files, etc.-  "" Also load indent files, to automatically do language-dependent indenting.-  filetype plugin indent on+"" Enable file type detection.+"" Use the default filetype settings, so that mail gets 'tw' set to 72,+"" 'cindent' is on in C files, etc.+"" Also load indent files, to automatically do language-dependent indenting.+filetype plugin indent on -  "" Put these in an autocmd group, so that we can delete them easily.-  augroup vimrcEx+"" Put these in an autocmd group, so that we can delete them easily.+augroup vimrcEx   au!",same regarding long form,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2928,33516854,2015-06-29T21:39:06Z,runtime/vimrc_example.vim,"@@ -65,13 +50,7 @@ if has(""autocmd"")     \   exe ""normal! g`\"""" |",same regarding long form,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2650,33577689,2015-06-30T14:24:17Z,src/nvim/tui/term_input.inl,"@@ -236,19 +235,29 @@ static void read_cb(RStream *rstream, void *rstream_data, bool eof)     if (handle_bracketed_paste(input) || handle_forced_escape(input)) {       continue;     }-    char *ptr = rbuffer_read_ptr(input->read_buffer);-    size_t len = rbuffer_pending(input->read_buffer);-    // Find the next 'esc' and push everything up to it(excluding)-    size_t i;-    for (i = ptr[0] == ESC ? 1 : 0; i < len; i++) {-      if (ptr[i] == '\x1b') {++    // Find the next 'esc' and push everything up to it(excluding). This is done+    // so the `handle_bracketed_paste`/`handle_forced_escape` calls above work+    // as expected.+    size_t count;+    RBUFFER_EACH(input->read_buffer, c, i) {+      count = i + 1;+      if (c == '\x1b' && count > 1) {+        break;+      }+    }++    RBUFFER_UNTIL_EMPTY(input->read_buffer, ptr, len) {+      size_t consumed = termkey_push_bytes(input->tk, ptr, MIN(count, len));","I'm not sure on how to handle this error, my  best guess is to treat as an out of memory condition and exit the program. What do you think?@leonerd, is this `tk->buffcount >= tk->buffsize` condition related to libtermkey failing to allocate memory at some point?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2650,33592015,2015-06-30T16:19:15Z,src/nvim/tui/term_input.inl,"@@ -236,19 +235,29 @@ static void read_cb(RStream *rstream, void *rstream_data, bool eof)     if (handle_bracketed_paste(input) || handle_forced_escape(input)) {       continue;     }-    char *ptr = rbuffer_read_ptr(input->read_buffer);-    size_t len = rbuffer_pending(input->read_buffer);-    // Find the next 'esc' and push everything up to it(excluding)-    size_t i;-    for (i = ptr[0] == ESC ? 1 : 0; i < len; i++) {-      if (ptr[i] == '\x1b') {++    // Find the next 'esc' and push everything up to it(excluding). This is done+    // so the `handle_bracketed_paste`/`handle_forced_escape` calls above work+    // as expected.+    size_t count;+    RBUFFER_EACH(input->read_buffer, c, i) {+      count = i + 1;+      if (c == '\x1b' && count > 1) {+        break;+      }+    }++    RBUFFER_UNTIL_EMPTY(input->read_buffer, ptr, len) {+      size_t consumed = termkey_push_bytes(input->tk, ptr, MIN(count, len));","> Not so much failing, as simply trying to keep a bounded size. I felt it best not to grow the buffer arbitrarily.ok, but if the caller consumes all parsed keys right after every `termkey_push_bytes` call, then this condition is not possible right?",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2916,33812793,2015-07-02T19:17:49Z,runtime/doc/todo.txt,"@@ -2091,14 +2089,6 @@ MSDOS and Win32:     backslashes. (Ronald Hoellwarth)  -Windows 95:-8   Editing a file by its short file name and writing it, makes the long file-    name disappear.  Setting 'backupcopy' helps.-    Use FindFirstFile()->cAlternateFileName in fname_case() (George Reilly).-8   Doing wildcard expansion, will match the short filename, but result in the-    long filename (both DJGPP and Win32).-- Win32 console: 9   When editing a file by its short file name, it should be expanded into its     long file name, to avoid problems like these: (Mccollister)",Does nvim still have shor/long name support? I think I saw it removed somewhere.,
244927,chrisbra,https://api.github.com/repos/neovim/neovim/pulls/2916,33815774,2015-07-02T19:50:38Z,runtime/doc/todo.txt,"@@ -2091,14 +2089,6 @@ MSDOS and Win32:     backslashes. (Ronald Hoellwarth)  -Windows 95:-8   Editing a file by its short file name and writing it, makes the long file-    name disappear.  Setting 'backupcopy' helps.-    Use FindFirstFile()->cAlternateFileName in fname_case() (George Reilly).-8   Doing wildcard expansion, will match the short filename, but result in the-    long filename (both DJGPP and Win32).-- Win32 console: 9   When editing a file by its short file name, it should be expanded into its     long file name, to avoid problems like these: (Mccollister)","Hi Justin!On Do, 02 Jul 2015, Justin M. Keyes wrote:> > @@ -2091,14 +2089,6 @@ MSDOS and Win32:> >      backslashes. (Ronald Hoellwarth)> > > > -Windows 95:> > -8   Editing a file by its short file name and writing it, makes the long file> > -    name disappear.  Setting 'backupcopy' helps.> > -    Use FindFirstFile()->cAlternateFileName in fname_case() (George Reilly).> >   -8   Doing wildcard expansion, will match the short filename, but result in the> > > > ## \-    long filename (both DJGPP and Win32).> > > > ## > > > >  Win32 console:> >  9   When editing a file by its short file name, it should be expanded into its> >      long file name, to avoid problems like these: (Mccollister)> > We still support `%:8`. Not sure if that is what this is about though.Are you sure? I believe this was a windows specific so was only available in Windows built. And since Windows support was removed, I wouldn't bet, that :8 actually does anything currently.Best,## ChristianWas die neuen Unwissenden holen m��ssen:Frequenzbiegezangen",
244927,chrisbra,https://api.github.com/repos/neovim/neovim/pulls/2916,33816899,2015-07-02T20:03:23Z,runtime/doc/todo.txt,"@@ -2091,14 +2089,6 @@ MSDOS and Win32:     backslashes. (Ronald Hoellwarth)  -Windows 95:-8   Editing a file by its short file name and writing it, makes the long file-    name disappear.  Setting 'backupcopy' helps.-    Use FindFirstFile()->cAlternateFileName in fname_case() (George Reilly).-8   Doing wildcard expansion, will match the short filename, but result in the-    long filename (both DJGPP and Win32).-- Win32 console: 9   When editing a file by its short file name, it should be expanded into its     long file name, to avoid problems like these: (Mccollister)","I'll leave it for now. Windows support isn't even merged yet, and I don't know much at all about long names and whatnot.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2807,33886917,2015-07-04T11:46:59Z,.ci/clang.sh,"@@ -2,26 +2,36 @@  sudo pip install cpp-coveralls -# Use custom Clang and enable ASAN on Linux.+# Use custom Clang and enable sanitizers on Linux. if [ ""$TRAVIS_OS_NAME"" = ""linux"" ]; then-	clang_version=3.4.2-	clang_suffix=x86_64-unknown-ubuntu12.04.xz-	if [ ! -d /usr/local/clang-$clang_version ]; then-		echo ""Downloading clang $clang_version...""-		sudo mkdir /usr/local/clang-$clang_version-		wget -q -O - http://llvm.org/releases/$clang_version/clang+llvm-$clang_version-$clang_suffix \-			| sudo tar xJf - --strip-components=1 -C /usr/local/clang-$clang_version+	if [ -z ""$CLANG_SANITIZER"" ]; then+		echo ""CLANG_SANITIZER not set.""+		exit 1 	fi-	export CC=/usr/local/clang-$clang_version/bin/clang-	symbolizer=/usr/local/clang-$clang_version/bin/llvm-symbolizer++	clang_version=3.6+	echo ""Installing Clang $clang_version...""++	sudo add-apt-repository ""deb http://ppa.launchpad.net/ubuntu-toolchain-r/test/ubuntu precise main""+	sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA9EF27F++	sudo add-apt-repository ""deb http://llvm.org/apt/precise/ llvm-toolchain-precise-$clang_version main""+	wget -q -O - http://llvm.org/apt/llvm-snapshot.gpg.key | sudo apt-key add -++	sudo apt-get update -qq+	sudo apt-get install -y -q clang-$clang_version++	export CC=/usr/bin/clang-$clang_version+	symbolizer=/usr/bin/llvm-symbolizer-$clang_version 	export ASAN_SYMBOLIZER_PATH=$symbolizer+	export MSAN_SYMBOLIZER_PATH=$symbolizer 	export ASAN_OPTIONS=""detect_leaks=1:log_path=$tmpdir/asan""-	export TSAN_OPTIONS=""external_symbolizer_path=$symbolizer:log_path=$tmpdir/tsan""+	export TSAN_OPTIONS=""external_symbolizer_path=$symbolizer log_path=$tmpdir/tsan""","It should be `log_path=$tmpdir/tsan/tsan`. Unlike with ASAN,  `log_path` doesn't specify the directory but the file pattern for the log.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2807,33887076,2015-07-04T12:18:10Z,.ci/clang.sh,"@@ -2,26 +2,36 @@  sudo pip install cpp-coveralls -# Use custom Clang and enable ASAN on Linux.+# Use custom Clang and enable sanitizers on Linux. if [ ""$TRAVIS_OS_NAME"" = ""linux"" ]; then-	clang_version=3.4.2-	clang_suffix=x86_64-unknown-ubuntu12.04.xz-	if [ ! -d /usr/local/clang-$clang_version ]; then-		echo ""Downloading clang $clang_version...""-		sudo mkdir /usr/local/clang-$clang_version-		wget -q -O - http://llvm.org/releases/$clang_version/clang+llvm-$clang_version-$clang_suffix \-			| sudo tar xJf - --strip-components=1 -C /usr/local/clang-$clang_version+	if [ -z ""$CLANG_SANITIZER"" ]; then+		echo ""CLANG_SANITIZER not set.""+		exit 1 	fi-	export CC=/usr/local/clang-$clang_version/bin/clang-	symbolizer=/usr/local/clang-$clang_version/bin/llvm-symbolizer++	clang_version=3.6+	echo ""Installing Clang $clang_version...""++	sudo add-apt-repository ""deb http://ppa.launchpad.net/ubuntu-toolchain-r/test/ubuntu precise main""+	sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA9EF27F++	sudo add-apt-repository ""deb http://llvm.org/apt/precise/ llvm-toolchain-precise-$clang_version main""+	wget -q -O - http://llvm.org/apt/llvm-snapshot.gpg.key | sudo apt-key add -++	sudo apt-get update -qq+	sudo apt-get install -y -q clang-$clang_version++	export CC=/usr/bin/clang-$clang_version+	symbolizer=/usr/bin/llvm-symbolizer-$clang_version 	export ASAN_SYMBOLIZER_PATH=$symbolizer+	export MSAN_SYMBOLIZER_PATH=$symbolizer 	export ASAN_OPTIONS=""detect_leaks=1:log_path=$tmpdir/asan""-	export TSAN_OPTIONS=""external_symbolizer_path=$symbolizer:log_path=$tmpdir/tsan""+	export TSAN_OPTIONS=""external_symbolizer_path=$symbolizer log_path=$tmpdir/tsan""","I had a look at `asan_check` in `.ci/common.sh`, and I think this should be the file pattern for `check_logs` to find the log. I'll check again._Edit:_ Also, ASAN's log path specifies a file pattern (from [here](https://code.google.com/p/address-sanitizer/wiki/Flags)): ""Path to the log files. If log_path=PATH is given, every process will write error reports to PATH.PID"". So I think this is correct as is. @tarruda Can you confirm?",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/2938,33897500,2015-07-05T18:42:50Z,cmake/i386-linux-gnu.toolchain.cmake,"@@ -1,5 +1,7 @@ set(CMAKE_SYSTEM_PROCESSOR i386) set(CMAKE_SYSTEM_NAME Linux) set(CMAKE_SYSTEM_VERSION gnu)-set(CMAKE_C_COMPILER gcc)+if(NOT ${CMAKE_C_COMPILER})+  set(CMAKE_C_COMPILER gcc)","@jszakmeister I changed this to be able to use a different compiler (in this case, `gcc-5`) to build for 32 bit. `NOT CMAKE_C_COMPILER` and `NOT DEFINED CMAKE_C_COMPILER` both didn't work. Do you think it's okay like this?Also, I'm wondering if we should introduce more toolchain files instead of putting all of these CMake flags in `.travis.yml`.. but not in this PR.",
849039,Oberon00,https://api.github.com/repos/neovim/neovim/pulls/2910,33976887,2015-07-06T20:13:58Z,runtime/autoload/provider/script_host.py,"@@ -198,22 +204,25 @@ def _find_module(fullname, oldtail, path):             name = oldtail[:idx]             tail = oldtail[idx+1:]             fmr = imp.find_module(name, path)-            module = imp.load_module(fullname[:-len(oldtail)] + name, *fmr)+            module = imp.find_module(fullname[:-len(oldtail)] + name, *fmr)             return _find_module(fullname, tail, module.__path__)         else:-            fmr = imp.find_module(fullname, path)-            return imp.load_module(fullname, *fmr)+            return imp.find_module(fullname, path)      class VimModuleLoader(object):         def __init__(self, module):             self.module = module          def load_module(self, fullname, path=None):-            return self.module+            # Check sys.modules, required for reload (see PEP302).+            if fullname in sys.modules:+                return sys.modules[fullname]+            return imp.load_module(fullname, *self.module)      class VimPathFinder(object):         @classmethod","This should probably become an [`@staticmethod`](https://docs.python.org/library/functions.html#staticmethod), since the `cls` parameter is not used at all. Same with `find_spec`.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2979,34082305,2015-07-07T19:51:13Z,src/nvim/api/vim.c,"@@ -164,6 +165,39 @@ Object vim_eval(String str, Error *err)   return rv; } +/// Call the given function with the given arguments stored in an array.+///+/// @param functionName The function to call+/// @param args the functions arguments packed in an Array+/// @param[out] err Details of an error that may have occurred+/// @return The result of the function call if it was successful+Object vim_function(String functionName, Array args, Error *err)+  FUNC_ATTR_DEFERRED+{+  Object rv = OBJECT_INIT;+  typval_T vim_args[args.size+1];++  try_start();+  // Convert the arguments in args from Object to typval_T values+  size_t i = 0;+  for (; i < args.size; i++) {+    if (!object_to_vim(args.items[i], &vim_args[i], err)) {+      break;+    }+  }++  typval_T tmp;+  if (!err->set && func_call((char_u*) functionName.data, vim_args, NULL, &tmp) == FAIL) {","To clarify my earlier comment, you may need something like `char* name = xstrndup(functionName.data, functionName.size)` here.Also, `rettv` would be a more idiomatic name for the return value.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2979,34091330,2015-07-07T21:12:35Z,src/nvim/api/vim.c,"@@ -164,6 +165,39 @@ Object vim_eval(String str, Error *err)   return rv; } +/// Call the given function with the given arguments stored in an array.+///+/// @param functionName The function to call+/// @param args the functions arguments packed in an Array+/// @param[out] err Details of an error that may have occurred+/// @return The result of the function call if it was successful+Object vim_function(String functionName, Array args, Error *err)+  FUNC_ATTR_DEFERRED+{+  Object rv = OBJECT_INIT;+  typval_T vim_args[args.size+1];++  try_start();+  // Convert the arguments in args from Object to typval_T values+  size_t i = 0;+  for (; i < args.size; i++) {+    if (!object_to_vim(args.items[i], &vim_args[i], err)) {+      break;+    }+  }++  typval_T tmp;+  if (!err->set && func_call((char_u*) functionName.data, vim_args, NULL, &tmp) == FAIL) {","I do not know how you can expect it to work: func_call expects vim_args to be a list. _VimL_ list, not an array, you do not even pass a length here.I would suggest to simply call `call_func` directly (make it non-static prior to this) or add another wrapper that expects an array + argc because converting array to a VimL list and then back is a pure waste of time.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2979,34093346,2015-07-07T21:29:07Z,src/nvim/api/vim.c,"@@ -164,6 +165,39 @@ Object vim_eval(String str, Error *err)   return rv; } +/// Call the given function with the given arguments stored in an array.+///+/// @param functionName The function to call+/// @param args the functions arguments packed in an Array+/// @param[out] err Details of an error that may have occurred+/// @return The result of the function call if it was successful+Object vim_function(String functionName, Array args, Error *err)+  FUNC_ATTR_DEFERRED+{+  Object rv = OBJECT_INIT;+  typval_T vim_args[args.size+1];++  try_start();+  // Convert the arguments in args from Object to typval_T values+  size_t i = 0;+  for (; i < args.size; i++) {+    if (!object_to_vim(args.items[i], &vim_args[i], err)) {+      break;+    }+  }++  typval_T tmp;+  if (!err->set && func_call((char_u*) functionName.data, vim_args, NULL, &tmp) == FAIL) {","More: I now see that func_call uses copy_tv. This means that converted objects will be freed at all, at any circumstances. Though you need to solve issue with the list first.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2718,34187869,2015-07-08T19:23:03Z,test/functional/legacy/062_tab_pages_spec.lua,"@@ -0,0 +1,272 @@+-- Tests for tab pages++local helpers = require('test.functional.helpers')+local feed, insert, source, clear, execute, expect, eval, eq =+  helpers.feed, helpers.insert, helpers.source, helpers.clear,+  helpers.execute, helpers.expect, helpers.eval, helpers.eq++describe('tab pages', function()+  setup(clear)++  it('is working', function()+    insert('Results:')++    execute('lang C')++    -- Simple test for opening and closing a tab page.+    execute('tabnew')+    eq(2, eval('tabpagenr()'))+    execute('q')+    eq(1, eval('tabpagenr()'))++    -- Open three tab pages and use "":tabdo"".+    source([[+      0tabnew+      1tabnew+      $tabnew+      tabdo call append(line('$'), 'this is tab page ' . tabpagenr())+      tabclose! 2+      tabrewind+    ]])+    eq('this is tab page 1', eval(""getline('$')""))+    execute('undo')+    execute('q')+    execute('tablast')+    eq('this is tab page 4', eval(""getline('$')""))+    execute('q!')++    -- Test for settabvar() and gettabvar() functions. Open a new tab page and+    -- set 3 variables to a number, string and a list. Verify that the+    -- variables are correctly set.+    source([[+      tabnew+      tabfirst+      call settabvar(2, 'val_num', 100)+      call settabvar(2, 'val_str', 'SetTabVar test')+      call settabvar(2, 'val_list', ['red', 'blue', 'green'])+    ]])++    eq(100, eval('gettabvar(2, ""val_num"")'))+    eq('SetTabVar test', eval('gettabvar(2, ""val_str"")'))+    eq({'red', 'blue', 'green'}, eval('gettabvar(2, ""val_list"")'))+    execute('tabnext 2')+    eq(100, eval('t:val_num'))+    eq('SetTabVar test', eval('t:val_str'))+    eq({'red', 'blue', 'green'}, eval('t:val_list'))+    execute('tabclose')++    -- Test some drop features+    -- Test for "":tab drop exist-file"" to keep current window.+    execute('sp test1')+    execute('tab drop test1')+    eq(1, eval('tabpagenr(""$"")'))+    eq(2, eval('winnr(""$"")'))+    eq(1, eval('winnr()'))+    execute('close')+    -- Test for "":tab drop new-file"" to keep current window of tabpage 1.+    execute('split')+    execute('tab drop newfile')+    eq(2, eval('tabpagenr(""$"")'))+    eq(2, eval('tabpagewinnr(1, ""$"")'))+    eq(1, eval('tabpagewinnr(1)'))+    execute('tabclose')+    execute('q')++    -- Test for "":tab drop multi-opend-file"" to keep current tabpage and+    -- window.+    execute('new test1')+    execute('tabnew')+    execute('new test1')+    execute('tab drop test1')+    eq(2, eval('tabpagenr()'))+    eq(2, eval('tabpagewinnr(2, ""$"")'))+    eq(1, eval('tabpagewinnr(2)'))+    execute('tabclose')+    execute('q')++    execute('for i in range(9) | tabnew | endfor')+    feed('1gt')+    eq(1, eval('tabpagenr()'))+    execute('tabmove 5')+    eq(6, eval('tabpagenr()'))+    execute('tabmove -2')+    eq(4, eval('tabpagenr()'))+    execute('tabmove +4')+    eq(8, eval('tabpagenr()'))+    execute('tabmove')+    eq(10, eval('tabpagenr()'))+    execute('tabmove -20')+    eq(1, eval('tabpagenr()'))+    execute('tabmove +20')+    eq(10, eval('tabpagenr()'))+    execute('3tabmove')+    eq(4, eval('tabpagenr()'))+    execute('7tabmove 5')+    eq(6, eval('tabpagenr()'))+    feed('Go<esc>')+    execute('let a=""No error caught.""')+    execute('try')+    execute('tabmove foo')+    execute('catch E474')+    execute('let a=""E474 caught.""')+    execute('endtry')+    feed('i<C-R>=a<C-M><esc>')++    -- Test autocommands.+    source([[+      tabonly!+      let g:r=[]+      command -nargs=1 -bar C :call add(g:r, '=== '.<q-args>.' ===')|<args>+      function Test()+          let hasau=has('autocmd')","This should always evaluate to `1`, so should be removed. The conditionals below should be adjusted as well.",
1560366,saep,https://api.github.com/repos/neovim/neovim/pulls/2979,34243827,2015-07-09T10:54:58Z,src/nvim/api/vim.c,"@@ -164,6 +164,56 @@ Object vim_eval(String str, Error *err)   return rv; } +/// Call the given function with the given arguments stored in an array.+///+/// @param functionName The function to call+/// @param args the functions arguments packed in an Array+/// @param[out] err Details of an error that may have occurred+/// @return The result of the function call if it was successful+Object vim_call_function(String functionName, Array args, Error *err)+  FUNC_ATTR_DEFERRED+{+  Object retv = OBJECT_INIT;+  if (args.size > MAX_FUNC_ARGS) {+    api_set_error(err, Exception,+      _(""Function called with too many arguments.""));+    return retv;+  }++  try_start();+  // Convert the arguments in args from Object to typval_T values+  typval_T vim_args[MAX_FUNC_ARGS + 1];+  size_t i = 0;  // also used for freeing the variables+  for (; i < args.size; i++) {+    if (!object_to_vim(args.items[i], &vim_args[i], err)) {+      api_set_error(err, Exception,+          _(""Error converting from object in vim_function.""));+      goto free_vim_args;","From what I glimpsed about the definition (which I didn't do before), it suffices to put it around the `call_func` call as it handles vimL exceptions or user interrupt as far as I can tell.",
2353785,nhynes,https://api.github.com/repos/neovim/neovim/pulls/2846,34315526,2015-07-09T23:29:08Z,src/nvim/api/buffer.c,"@@ -179,6 +179,11 @@ void buffer_set_line_slice(Buffer buffer,     return;   } +  if (!inbounds(buf, start)) {","I'm not sure. While it would certainly be convenient, it's not consistent with vim commands like `setline` (if we're trying to emulate those) and it might be confusing for the behavior of `set_line_slice` to be entirely different depending on which end of the buffer has been overrun.At least from my perspective, it would be much more common for an out-of-bounds set to result from plugin/user race conditions than from trying to set lines at a specific position in a file. I'd be interested in hearing of others' experiences, though.It might just be easier and more explicit to just send over a chunk of vimscript/lua that performs the appropriate operations.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/2846,34374749,2015-07-10T17:10:11Z,src/nvim/api/buffer.c,"@@ -179,6 +179,11 @@ void buffer_set_line_slice(Buffer buffer,     return;   } +  if (!inbounds(buf, start)) {","Yeah, I suppose I agree, though it occurs to me that the issue is that we don't have a way to append to a buffer. Perhaps this function should act like `setline`, but we should also have a `buffer_append` function to avoid race conditions.Those that can be in a different PR.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2979,34382159,2015-07-10T18:27:21Z,src/nvim/api/vim.c,"@@ -164,6 +164,83 @@ Object vim_eval(String str, Error *err)   return rv; } +/// Call the given function with the given arguments stored in an array.+///+/// @param functionName The function to call+/// @param args the functions arguments packed in an Array+/// @param self optional self dictionary that may be used by user functions to+///        emulate object-oriented programming+/// @param[out] err Details of an error that may have occurred+/// @return The result of the function call if it was successful+Object vim_call_function(String functionName, Array args, Object self,+                         Error *err)+  FUNC_ATTR_DEFERRED+{+  Object rv = OBJECT_INIT;+  if (args.size > MAX_FUNC_ARGS) {+    api_set_error(err, Validation,+      _(""Function called with too many arguments.""));+    return rv;+  }++  typval_T optional_self_dict;+  dict_T *self_dict = NULL;+  if (self.type == kObjectTypeNil) {+    self_dict = NULL;+  } else if (self.type == kObjectTypeDictionary+             || self.type == kObjectTypeArray) {+    // XXX The tests somehow cause the object to be an array+    self.type = kObjectTypeDictionary;+    if (!object_to_vim(self, &optional_self_dict, err)) {+      free_tv(&optional_self_dict);+      return rv;+    } else if (optional_self_dict.v_type == VAR_DICT) {+      self_dict = optional_self_dict.vval.v_dict;+    } else {+      api_set_error(err, Validation,+          _(""Object was not converted to a dict.""));+      goto free_vim_args;+    }+  } else {","Since I mostly pass empty dictionary here I do not care much. But for running things like `g:SyntasticLoclist.current().filter(���)` this may be handy. I would though say that in this case string must be simply `eval`ed, not that it should be a name of global dictionary.About running global objects: it may make sense to first check functionName for presense in self dictionary and only then pass it to call_func untouched.Or, maybe a better idea: strip off `self` handling from `vim_call_function` completely (restore the original functionality), but additionally add `vim_call_dict_function(Object self, Boolean internal, String functionName, Array args, Error *err)` which will do the following:1. Convert `self` to a dictionary: it should either be a Dictionary or a String object, in first case it is simply converted dictionary, in the last case it is expression passed to `eval()` which must evaluate to a dictionary.2. If `internal` is true then check whether `functionName` is a key in `self` that refers to a function reference. If yes, replace function name with value of this reference. If no, raise an error. If `internal` is false then `functionName` is passed to `call_func` untouched.3. Call `call_func` with arguments and self dictionary.Intended usage: same as `vim_call_func`, but for constructs like `g:SyntasticLoclist.current().filter(���)`: `g:SyntasticLoclist.current()` goes into `self` as a string, arguments of `.filter()` may be different and go into `args`, rationale is the same: first string is a simple static string that does not change, arguments in this case do not require double serializing (from dictionary expected by `.filter()` to string then string to messagepack).Additional rationale (behind the `internal` argument): this make it possible to call anonymous functions without knowing their internal name (i.e. number), thus anonymous functions can be truly anonymous like in extended-funcref branch (they are not stored in a global functions dictionary under any name there). (Or in VimL-to-lua translator, if I remember correctly.)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2846,34417375,2015-07-11T23:56:16Z,test/functional/api/buffer_spec.lua,"@@ -54,6 +60,15 @@ describe('buffer_* functions', function()       eq({'a', 'b'}, curbuf('get_line_slice', 0, -1, true, false))       eq({'b'}, curbuf('get_line_slice', 1, -1, true, false))       eq({'b', 'c'}, curbuf('get_line_slice', -2, -1, true, true))+      eq({}, curbuf('get_line_slice', 2, 3, false, true))","I also noticed that ```get_line_slice(0, 0, false, false)get_line_slice(0, 0, true, false)get_line_slice(0, 0, false, true)```return empty array, yet `get_line_slice(0, 0, true, true)` returns `['a']`. This makes me wonder why we have the `include_start` and `include_end` parameters. Are they really necessary?",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2980,34425843,2015-07-12T21:27:51Z,src/nvim/os/job.c,"@@ -117,63 +112,45 @@ Job *job_start(JobOptions opts, int *status)   job->refcount = 1;   job->stopped_time = 0;   job->term_sent = false;-  job->in = NULL;-  job->out = NULL;-  job->err = NULL;   job->opts = opts;   job->closed = false;--  process_init(job);--  if (opts.writable) {-    handle_set_job((uv_handle_t *)job->proc_stdin, job);-    job->refcount++;-  }--  if (opts.stdout_cb) {-    handle_set_job((uv_handle_t *)job->proc_stdout, job);-    job->refcount++;-  }--  if (opts.stderr_cb) {-    handle_set_job((uv_handle_t *)job->proc_stderr, job);-    job->refcount++;-  }+  job->in.closed = true;+  job->out.closed = true;+  job->err.closed = true;    // Spawn the job   if (!process_spawn(job)) {-    if (opts.writable) {-      uv_close((uv_handle_t *)job->proc_stdin, close_cb);+    if (job->opts.writable) {+      uv_close((uv_handle_t *)job->proc_stdin, NULL);     }-    if (opts.stdout_cb) {-      uv_close((uv_handle_t *)job->proc_stdout, close_cb);+    if (job->opts.stdout_cb) {+      uv_close((uv_handle_t *)job->proc_stdout, NULL);     }-    if (opts.stderr_cb) {-      uv_close((uv_handle_t *)job->proc_stderr, close_cb);+    if (job->opts.stderr_cb) {+      uv_close((uv_handle_t *)job->proc_stderr, NULL);     }     process_close(job);     event_poll(0);","I'm currently refactoring the job module in a similar way that the server/rstream/wstream modules were refactored in this PR. I will take this into consideration for the refactored version, thanks",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2980,34466011,2015-07-13T14:10:31Z,src/nvim/os/job.c,"@@ -117,63 +112,45 @@ Job *job_start(JobOptions opts, int *status)   job->refcount = 1;   job->stopped_time = 0;   job->term_sent = false;-  job->in = NULL;-  job->out = NULL;-  job->err = NULL;   job->opts = opts;   job->closed = false;--  process_init(job);--  if (opts.writable) {-    handle_set_job((uv_handle_t *)job->proc_stdin, job);-    job->refcount++;-  }--  if (opts.stdout_cb) {-    handle_set_job((uv_handle_t *)job->proc_stdout, job);-    job->refcount++;-  }--  if (opts.stderr_cb) {-    handle_set_job((uv_handle_t *)job->proc_stderr, job);-    job->refcount++;-  }+  job->in.closed = true;+  job->out.closed = true;+  job->err.closed = true;    // Spawn the job   if (!process_spawn(job)) {-    if (opts.writable) {-      uv_close((uv_handle_t *)job->proc_stdin, close_cb);+    if (job->opts.writable) {+      uv_close((uv_handle_t *)job->proc_stdin, NULL);     }-    if (opts.stdout_cb) {-      uv_close((uv_handle_t *)job->proc_stdout, close_cb);+    if (job->opts.stdout_cb) {+      uv_close((uv_handle_t *)job->proc_stdout, NULL);     }-    if (opts.stderr_cb) {-      uv_close((uv_handle_t *)job->proc_stderr, close_cb);+    if (job->opts.stderr_cb) {+      uv_close((uv_handle_t *)job->proc_stderr, NULL);     }     process_close(job);     event_poll(0);","This should no longer be a problem, the process memory is now managed by the caller",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/2980,34489095,2015-07-13T17:38:04Z,src/nvim/event/pty_process.c,"@@ -255,3 +202,50 @@ static void init_termios(struct termios *termios) FUNC_ATTR_NONNULL_ALL   termios->c_cc[VMIN]     = 1;   termios->c_cc[VTIME]    = 0; }++static bool set_duplicating_descriptor(int fd, uv_pipe_t *pipe)+  FUNC_ATTR_NONNULL_ALL+{+  int fd_dup = dup(fd);+  if (fd_dup < 0) {+    ELOG(""Failed to dup descriptor %d: %s"", fd, strerror(errno));+    return false;+  }+  int uv_result = uv_pipe_open(pipe, fd_dup);+  if (uv_result) {+    ELOG(""Failed to set pipe to descriptor %d: %s"",+         fd_dup, uv_strerror(uv_result));+    close(fd_dup);+    return false;+  }+  return true;+}++static void chld_handler(uv_signal_t *handle, int signum)","They are handled in the same loop, but it's only possible to have `waitpid` return a pid > 0 once(at least in my tests). So if libuv `SIGCHLD` handler receives it first, this one will short circuit because the process will have already exited. The same will happen for libuv if we catch it first: https://github.com/libuv/libuv/blob/v1.x/src/unix/process.c#L78-L80",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3007,34624310,2015-07-14T21:50:06Z,src/nvim/ex_cmds.lua,"@@ -2678,18 +2678,18 @@ return {     func='ex_ni',   },   {-    command='tearoff',-    flags=bit.bor(NEEDARG, EXTRA, TRLBAR, NOTRLCOM, CMDWIN),-    addr_type=ADDR_LINES,-    func='ex_tearoff',-  },-  {     command='terminal',     flags=bit.bor(BANG, FILES, CMDWIN),     addr_type=ADDR_LINES,     func='ex_terminal',   },   {+    command='tearoff',+    flags=bit.bor(NEEDARG, EXTRA, TRLBAR, NOTRLCOM, CMDWIN),+    addr_type=ADDR_LINES,+    func='ex_tearoff',+  },","There is a list of special cases, if I recall, that overrides the alphabetical precedence here. But I'd rather just remove `:tearoff` and deal with this in 10 years when someone asks for the feature to be implemented. (We will not support `:tearoff` any time soon)Also what @noahfrederick said :)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3007,34625753,2015-07-14T22:04:48Z,src/nvim/ex_cmds.lua,"@@ -2678,18 +2678,18 @@ return {     func='ex_ni',   },   {-    command='tearoff',-    flags=bit.bor(NEEDARG, EXTRA, TRLBAR, NOTRLCOM, CMDWIN),-    addr_type=ADDR_LINES,-    func='ex_tearoff',-  },-  {     command='terminal',     flags=bit.bor(BANG, FILES, CMDWIN),     addr_type=ADDR_LINES,     func='ex_terminal',   },   {+    command='tearoff',+    flags=bit.bor(NEEDARG, EXTRA, TRLBAR, NOTRLCOM, CMDWIN),+    addr_type=ADDR_LINES,+    func='ex_tearoff',+  },","@noahfrederick It is strict alphabetical order for the first lowercase command letter. (_One_ letter, cases where a built-in command starts with something, but lowercase letter are also an exception.) Following letters are not strict because1. When looking up a command there is a quick jump table for one first letter only. (And only for one first lowercase letter.)2. List is processed in a way that command that comes first has shorter minimal abbreviation.@splinterofchaos  It is not list of functions in eval.txt which is looked up using bisection (BTW, why it was not changed to a hash?). Searching is O(n): direct iteration over a list, with a quick jump table listing first letters. Worse, some commands like `noautocmd` (modifier commands) are listed separately, and their effective abbreviations are also defined separately directly in ex_docmd.c, but they are not excluded from the regular search. Even worse, if you type `tearon` command it will search for it starting from `t` and till the end of the commands list (not till the next letter), so you may just as well put new `tearon` command after `~` and it still will be found.Due to 2 it is sometimes reordered for the purposes of giving some command better abbreviation. Also new commands must be appended in a way that will not spoil existing abbreviations.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3007,34751283,2015-07-16T02:44:50Z,src/nvim/option_defs.h,"@@ -200,7 +200,6 @@ #define GO_ASELPLUS     'P'             /* autoselectPlus */ #define GO_RIGHT        'r'             /* use right scrollbar */ #define GO_VRIGHT       'R'             /* right scrollbar with vert split */-#define GO_TEAROFF      't'             /* add tear-off menu items */ #define GO_TOOLBAR      'T'             /* add toolbar */ #define GO_FOOTER       'F'             /* add footer */ #define GO_VERTICAL     'v'             /* arrange dialog buttons vertically */","... or not, since most/all of those flags are unused.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2980,34776510,2015-07-16T11:04:35Z,src/nvim/eval.c,"@@ -10724,15 +10734,13 @@ static void f_jobsend(typval_T *argvars, typval_T *rettv)     return;   } -  Job *job = job_find(argvars[0].vval.v_number);--  if (!is_user_job(job)) {-    // Invalid job id+  TerminalJobData *data = pmap_get(uint64_t)(jobs, argvars[0].vval.v_number);+  if (!data) {     EMSG(_(e_invjob));     return;   } -  if (((TerminalJobData *)job_data(job))->stdin_closed) {+  if (data->stdin_closed) {",Do we still need `stdin_closed` in `TerminalJobData`?We could now do something like this:``` c  Process *proc = (Process *)&data->proc;  if (!proc->in || proc->in->closed) {```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2992,34851774,2015-07-17T00:05:47Z,src/nvim/menu.c,"@@ -1301,11 +1301,15 @@ void ex_emenu(exarg_T *eap)    /* Found the menu, so execute.    * Use the Insert mode entry when returning to Insert mode. */-  if (restart_edit+  if (+      ((State & INSERT) || restart_edit)       && !current_SID       ) {     mode = (char_u *)""Insert"";     idx = MENU_INDEX_INSERT;+  } else if (get_real_state() & VISUAL) {","Shouldn't this extend the condition on line 1313, instead of being its own block? There's more logic in that other block which checks for a selection, restores visual mode, etc.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3028,34888929,2015-07-17T13:33:19Z,runtime/doc/term.txt,"@@ -592,6 +592,17 @@ before using the mouse: 	""g<LeftMouse>""	is ""<C-LeftMouse>	(jump to tag under mouse click) 	""g<RightMouse>"" is ""<C-RightMouse>	(""CTRL-T"") +							*bracketed-paste-mode*+Bracketed paste mode allows users to paste lines into the terminal emulator+without Neovim giving any special meaning to it. Most notably it won't try","I think ""into the terminal emulator"" is ambiguous here: it means the TUI, but it can be understood as `:terminal`. Perhaps:> Bracketed paste mode allows users to paste lines into Neovim without them being processed first, when running in the terminal.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3029,34922429,2015-07-17T19:21:19Z,src/nvim/msgpack_rpc/channel.c,"@@ -823,6 +823,7 @@ static void log_server_msg(uint64_t channel_id,   msgpack_unpack_next(&unpacked, packed->data, packed->size, NULL);   uint64_t type = unpacked.data.via.array.ptr[0].via.u64;   DLOGN(""[msgpack-rpc] nvim -> client(%"" PRIu64 "") "", channel_id);+  log_lock();",">  the usage of log.c mutex is really simple and won't spread beyond this and the standard log functionIt's simple in the context of this PR where we have the state in our heads--but complexity emerges slowly over time. I hope we can keep the number of modules that manage synchronization to very few, isolated cases so that it is easy to keep a mental model of the system. Keep in mind that I don't know your plans and I haven't had a chance to review the previous PR, so I can only comment from a ""principles"" perspective.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/3029,34942030,2015-07-18T00:55:35Z,src/nvim/msgpack_rpc/channel.c,"@@ -823,6 +823,7 @@ static void log_server_msg(uint64_t channel_id,   msgpack_unpack_next(&unpacked, packed->data, packed->size, NULL);   uint64_t type = unpacked.data.via.array.ptr[0].via.u64;   DLOGN(""[msgpack-rpc] nvim -> client(%"" PRIu64 "") "", channel_id);+  log_lock();","What I meant is that specialized log functions like these should be rare enough to ignore this single case where the log mutex is managed outside the log module. I'd say at least 90% of the cases we'll just use the standard log macros which are already synchronized.If we start to see this pattern more, then it might be worth refactoring.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/3028,34945191,2015-07-18T06:53:55Z,runtime/doc/vim_diff.txt,"@@ -69,6 +69,8 @@ are always available and may be used simultaneously in separate plugins.  The  See |nvim-intro| for a list of Nvim's largest new features. +Enables |bracketed-paste-mode|.+","This makes it sound as if it's a Neovim feature, but Neovim merely enables and listens to it.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/3028,34945217,2015-07-18T06:57:24Z,runtime/doc/term.txt,"@@ -592,6 +592,17 @@ before using the mouse: 	""g<LeftMouse>""	is ""<C-LeftMouse>	(jump to tag under mouse click) 	""g<RightMouse>"" is ""<C-RightMouse>	(""CTRL-T"") +							*bracketed-paste-mode*+Bracketed paste mode allows terminal emulators to distinguish between typed+text and pasted text.","Hmm, I'm no fan of including links, to be honest.Actually I left the text short and easy to read, omitting all technical details like escape sequences etc. because an interested reader would look it up anyway (and probably find the mentioned link in the top matches).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2980,34947045,2015-07-18T12:11:25Z,src/nvim/event/pty_process.c,"@@ -120,23 +67,18 @@ bool pty_process_spawn(Job *job) FUNC_ATTR_NONNULL_ALL     goto error;   } -  if (job->opts.writable-      && !set_pipe_duplicating_descriptor(master, &ptyproc->proc_stdin)) {+  if (proc->in && !set_duplicating_descriptor(master, &proc->in->uv.pipe)) {     goto error;   }--  if (job->opts.stdout_cb-      && !set_pipe_duplicating_descriptor(master, &ptyproc->proc_stdout)) {+  if (proc->out && !set_duplicating_descriptor(master, &proc->out->uv.pipe)) {     goto error;   }--  if (job->opts.stderr_cb-      && !set_pipe_duplicating_descriptor(master, &ptyproc->proc_stderr)) {+  if (proc->err && !set_duplicating_descriptor(master, &proc->err->uv.pipe)) {     goto error;   }    ptyproc->tty_fd = master;-  job->pid = pid;+  proc->pid = pid;   return true;  error:","When this label is reached, the child ignores the signal `SIGTERM` and we have to wait for 5 seconds until we can send signal `SIGKILL`.If that happens, nvim hangs with```Vim: Caught deadly signal 'SIGTERM'Vim: Finished.```Can this error handling be simplified to ``` cclose(master);kill(pid,SIGKILL);waitpid(pid,NULL,0);return false;```?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2980,34947095,2015-07-18T12:20:18Z,src/nvim/eval.c,"@@ -15226,19 +15223,15 @@ static void f_termopen(typval_T *argvars, typval_T *rettv)     }   } -  JobOptions opts = common_job_options(argv, on_stdout, on_stderr, on_exit,-      job_opts);-  opts.pty = true;-  opts.width = curwin->w_width;-  opts.height = curwin->w_height;-  opts.term_name = xstrdup(""xterm-256color"");-  Job *job = common_job_start(opts, rettv);-  if (!job) {-    shell_free_argv(argv);+  TerminalJobData *data = common_job_init(argv, on_stdout, on_stderr, on_exit,+      job_opts, true);+  data->proc.pty.width = curwin->w_width;+  data->proc.pty.height = curwin->w_height;+  data->proc.pty.term_name = xstrdup(""xterm-256color"");+  if (!common_job_start(data, rettv)) {     return;",TerminalJobData and term_name are not freed:Cleanup could be:``` c    free(data->proc.pty.term_name);    free_term_job_data(data);```,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3042,34947561,2015-07-18T13:12:15Z,src/nvim/ex_cmds.c,"@@ -5399,9 +5402,12 @@ helptags_one (    * Find all *.txt files.    */   dirlen = (int)STRLEN(dir);-  STRCPY(NameBuff, dir);-  STRCAT(NameBuff, ""/**/*"");-  STRCAT(NameBuff, ext);+  if (STRLCPY(NameBuff, dir, MAXPATHL) >= MAXPATHL)+    EMSG(_(e_pathtoolong));+  if (STRLCAT(NameBuff, ""/**/*"", MAXPATHL) >= MAXPATHL)+    EMSG(_(e_pathtoolong));+  if (STRLCAT(NameBuff, ext, MAXPATHL) >= MAXPATHL)+    EMSG(_(e_pathtoolong));",This code could potentially print that the path is too long 3x and again continue expanding as if there was no error. It can use just one if statement and a chain of `&&`'s.,
1560366,saep,https://api.github.com/repos/neovim/neovim/pulls/2979,34947757,2015-07-18T13:29:17Z,src/nvim/api/vim.c,"@@ -164,6 +164,56 @@ Object vim_eval(String str, Error *err)   return rv; } +/// Call the given function with the given arguments stored in an array.+///+/// @param fname Function to call+/// @param args Functions arguments packed in an Array+/// @param[out] err Details of an error that may have occurred+/// @return Result of the function call+Object vim_call_function(String fname, Array args, Error *err)+  FUNC_ATTR_DEFERRED+{+  Object rv = OBJECT_INIT;+  if (args.size > MAX_FUNC_ARGS) {+    api_set_error(err, Validation,+      _(""Function called with too many arguments.""));+    return rv;+  }++  // Convert the arguments in args from Object to typval_T values+  typval_T vim_args[MAX_FUNC_ARGS + 1];+  size_t i = 0;  // also used for freeing the variables+  for (; i < args.size; i++) {+    if (!object_to_vim(args.items[i], &vim_args[i], err)) {+      goto free_vim_args;+    }+  }+",[`object_to_vim`](https://github.com/neovim/neovim/blob/master/src/nvim/api/private/helpers.c#L393-L396) sets it immediately. Why do you think its necessary?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2980,34947808,2015-07-18T13:38:04Z,src/nvim/eval.c,"@@ -10928,14 +10930,15 @@ static void f_jobstop(typval_T *argvars, typval_T *rettv)     return;   } -  Job *job = job_find(argvars[0].vval.v_number); -  if (!is_user_job(job)) {+  TerminalJobData *data = pmap_get(uint64_t)(jobs, argvars[0].vval.v_number);+  if (!data || data->stopped) {","Most of the other checks for a valid ""job"" do not check for `data->stopped`. Should probably also be added there.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3042,34950781,2015-07-18T19:39:21Z,src/nvim/ex_cmds.c,"@@ -73,6 +73,7 @@  */ typedef struct sign sign_T; +static char_u e_pathtoolong[] = N_(""E854: path too long for completion"");","Move the one in `nvim/file_search.c` to `globals.h` (list starts at line 1086) and use that, instead of repeating it here.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3041,34951140,2015-07-18T20:13:33Z,runtime/doc/eval.txt,"@@ -4573,15 +4573,16 @@ mkdir({name} [, {path} [, {prot}]]) 		If {prot} is given it is used to set the protection bits of 		the new directory.  The default is 0755 (rwxr-xr-x: r/w for 		the user readable for others).	Use 0700 to make it unreadable-		for others.  This is only used for the last part of {name}.-		Thus if you create /tmp/foo/bar then /tmp/foo will be created-		with 0755.+		for others.  Unlike vim is used for all parts of {name}.  Thus ","We mark nvim differences with `{Nvim}` in the docs. This serves two purposes:- makes it possible to generate a list of all differences by parsing the docs- avoids noise phrases throughout the docs like ""this is different than vi/vim...""Suggestion:```                    the user readable for others). Use 0700 to make it                    unreadable for others.                                                                   {Nvim}                    {prot} is applied to all parts of {name}. Thus if you                    create /tmp/foo/bar then /tmp/foo will be created with                    0700.```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3028,34953237,2015-07-19T00:43:56Z,runtime/doc/term.txt,"@@ -592,6 +592,17 @@ before using the mouse: 	""g<LeftMouse>""	is ""<C-LeftMouse>	(jump to tag under mouse click) 	""g<RightMouse>"" is ""<C-RightMouse>	(""CTRL-T"") +							*bracketed-paste-mode*+Bracketed paste mode allows terminal emulators to distinguish between typed+text and pasted text.","> Actually I left the text short and easy to read, omitting all technical details like escape sequences etc. because an interested reader would look it up anyway (and probably find the mentioned link in the top matches)Still, I don't see much downside in giving it a passing mention, perhaps like this:```Bracketed paste mode allows terminal emulators to distinguish between typed text and pasted text. For more information, see the following link:    https://cirw.in/blog/bracketed-paste```",
441141,fdinoff,https://api.github.com/repos/neovim/neovim/pulls/3054,34961744,2015-07-19T20:28:43Z,runtime/doc/index.txt,"@@ -1362,7 +1362,6 @@ tag	      command	      action ~ |:nunmap|	:nun[map]	like "":unmap"" but for Normal mode |:nunmenu|	:nunme[nu]	remove menu for Normal mode |:oldfiles|	:ol[dfiles]	list files that have marks in the viminfo file-|:open|		:o[pen]		start open mode (not implemented) |:omap|		:om[ap]		like "":map"" but for Operator-pending mode",One these gets the `:o` as its short form since `:open` no longer has it. (I'm not sure which),
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/3056,35035081,2015-07-20T19:42:19Z,test/functional/helpers.lua,"@@ -290,6 +290,22 @@ local function expect(contents)   return eq(dedent(contents), curbuf_contents()) end +local function rmdir(path)+  if lfs.attributes(path, 'mode') ~= 'directory' then+    return nil+  end+  for file in lfs.dir(path) do+    if file == '.' or file == '..' then+      goto continue+    end+    if not os.remove(path..'/'..file) then","Yup, both would be possible.Caller handles problems:``` luaret, err = func()if not ret then  return nil, errend```Callee handles problems:``` luaret, err = func()if not ret then  print('func(): '..err)  return nilend```Or a combination of course. I prefer the callee solution, so the tests don't get cluttered with conditionals.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3048,35058812,2015-07-21T00:11:27Z,src/nvim/tui/tui.c,"@@ -641,12 +645,21 @@ static void update_size(UI *ui) {   TUIData *data = ui->data;   int width = 0, height = 0;-  // 1 - try from a system call(ioctl/TIOCGWINSZ on unix)++  // 1 - if starting and the 'columns' and 'lines' options are not+  // the defaults, use their values+  if (starting && (Columns != 80 || Rows != 24)) {","Ok. By the way, I just noticed that `starting` is not a boolean.``` c/* Values for ""starting"" */#define NO_SCREEN       2       /* no screen updating yet */#define NO_BUFFERS      1       /* not all buffers loaded yet *//*          0      not starting anymore */```All other cases in the source compare explicitly `starting == 0` (or the other values), we should continue that pattern.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3048,35066341,2015-07-21T03:07:18Z,src/nvim/tui/tui.c,"@@ -641,12 +646,21 @@ static void update_size(UI *ui) {   TUIData *data = ui->data;   int width = 0, height = 0;-  // 1 - try from a system call(ioctl/TIOCGWINSZ on unix)++  // 1 - if starting and the 'columns' and 'lines' options are not+  // the defaults, use their values+  if (starting != 0 && (Columns != DFLT_COLS || Rows != DFLT_LINES)) {+    width = (int)Columns;","`Columns` is of type `long`, so isn't guaranteed to fit into an `int`.I recall it being discussed earlier that `Columns` and `Rows` should really be of type `int`, but that might be rather invasive of a refactoring.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3048,35111014,2015-07-21T14:52:39Z,src/nvim/option_defs.h,"@@ -59,6 +59,9 @@ #define EOL_DOS         1       /* CR NL */ #define EOL_MAC         2       /* CR */ +#define DFLT_COLS       80      // default value for 'columns'+#define DFLT_LINES      24      // default value for 'lines'",What about the `Columns` and `Rows` declarations in `globals.h`?```EXTERN long Columns INIT(= DFLT_COLS);```The definitions of DFLT_COLS/LINES would need to be moved to globals.h,
1571034,cztchoice,https://api.github.com/repos/neovim/neovim/pulls/3065,35204840,2015-07-22T11:56:39Z,src/nvim/version.c,"@@ -80,8 +80,8 @@ static int included_patches[] = {   784,   //783,   //782,-  //781,-  //780,+  781,+  //780 NA","Ok, if you have time, I have a list about this, and there will be ten now~://777 NA Readme  https://code.google.com/p/vim/source/detail?r=v7-4-777//772 NA makefile related and if_\* file Readme  https://code.google.com/p/vim/source/detail?r=v7-4-772//766 NA term.c Readme  https://code.google.com/p/vim/source/detail?r=v7-4-766//763 NA if_lua.c   https://code.google.com/p/vim/source/detail?r=v7-4-763//762 NA term.c  https://code.google.com/p/vim/source/detail?r=v7-4-762//759 NA if_lua.c https://code.google.com/p/vim/source/detail?r=v7-4-759//756 NA if_perl.xs https://code.google.com/p/vim/source/detail?r=v7-4-756//750 NA makefile https://code.google.com/p/vim/source/detail?r=v7-4-750//445 NA clipboard relate  https://github.com/neovim/neovim/pull/2274/ https://code.google.com/p/vim/source/detail?r=v7-4-750",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3072,35228186,2015-07-22T15:48:29Z,src/nvim/eval.c,"@@ -7102,8 +7102,16 @@ static inline int get_float_arg(typval_T *argvars, float_T *f) }  // Apply a floating point C function on a typval with one float_T.-static inline void float_op_wrapper(typval_T *argvars, typval_T *rettv,-                                    float_T (*function)(float_T))+//+// Some versions of glibc on i386 have an optimization that makes it harder to+// call math functions indirectly from inside an inlined function, causing+// compile-time errors with some versions of gcc. We avoid trying to inline+// float_op_wrapper on that platform.+#ifndef ARCH_32+inline+#endif+static void float_op_wrapper(typval_T *argvars, typval_T *rettv,","@justinmk `gendeclarations.lua` does not support function pointer arguments intentionally: I 1) did not want to write a recursive parser pattern and 2) I think that arguments with function pointer type without typedef look ugly and are less usable (e.g. you cannot cast slightly incompatible function to the needed type (usually this is the case when in type one argument is `void *`, while actually in function it is `Type *`)).",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/3084,35254450,2015-07-22T19:41:20Z,runtime/autoload/provider/clipboard.vim,"@@ -88,5 +81,11 @@ function! s:clipboard.set(lines, regtype, reg) endfunction  function! provider#clipboard#Call(method, args)-  return call(s:clipboard[a:method],a:args,s:clipboard)+  if a:method == 'get'+    let data = s:selections[a:args[0]].data  "" empty or [lines, regtype]+    let regtype = get(data, 1, 'v')+    return [call(s:clipboard[a:method], a:args, s:clipboard), regtype]","You mean the additional list around the return value? I wanted to have the `[lines, regtype]` format, so the handling in the C code would be easier.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3072,35256493,2015-07-22T20:00:11Z,src/nvim/eval.c,"@@ -7102,8 +7102,16 @@ static inline int get_float_arg(typval_T *argvars, float_T *f) }  // Apply a floating point C function on a typval with one float_T.-static inline void float_op_wrapper(typval_T *argvars, typval_T *rettv,-                                    float_T (*function)(float_T))+//+// Some versions of glibc on i386 have an optimization that makes it harder to+// call math functions indirectly from inside an inlined function, causing+// compile-time errors with some versions of gcc. We avoid trying to inline+// float_op_wrapper on that platform.+#ifndef ARCH_32+inline+#endif+static void float_op_wrapper(typval_T *argvars, typval_T *rettv,","> was it not the idea to use all static function freely in the translation unit, regardless of where they were defined?Yes. I thought we allowed exceptions though, for cases not covered by `gendeclarations.lua`.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3083,35264620,2015-07-22T21:11:40Z,scripts/vim-patch.sh,"@@ -26,7 +26,28 @@ usage() {   echo ""The default is '${VIM_SOURCE_DIR_DEFAULT}'."" } +# Checks if a program is in the user's PATH, and is executable.+check_executable() {+  if [[ ! -x $(command -v ""${1}"") ]]; then+    >&2 echo ""${BASENAME}: '${1}' not found in PATH or not executable.""+    >&2 echo ""Aborting execution.""+    exit 1+  fi+}++# Checks for the right number of parameters.+check_params() {","I converted it to getopts, and I think it turned out fine. We lose the long options, but we don't have many options so I don't think it's a big deal, but we do get explicit errors if the user a) doesn't provide an argument to an option b) provides an unknown option argument. Besides that, I think it's just easier to understand: no need to deal with arithmetic on the argument list, nor home-roll a function which getopts already deals with.Also, now that we have two different modes (review mode, and patch mode), I thought it best to just remove the positional arguments in favor of explicit option arguments.``` diffdiff --git a/scripts/vim-patch.sh b/scripts/vim-patch.shindex dd28b2b..10c9d42 100755--- a/scripts/vim-patch.sh+++ b/scripts/vim-patch.sh@@ -11,16 +11,15 @@ usage() {   echo ""Helper script for porting Vim patches. For more information, see""   echo ""https://github.com/neovim/neovim/wiki/Merging-patches-from-upstream-vim""   echo-  echo ""Usage:  ${BASENAME} [option]""-  echo ""        ${BASENAME} vim-revision""+  echo ""Usage:  ${BASENAME} [-h | -l | -p vim-revision | -r pr-number]""   echo   echo ""Options:""-  echo ""    -h, --help                Show this message.""-  echo ""    -l, --list                Show list of Vim patches missing from Neovim.""-  echo ""    -r, --review {pr-number}  Review a vim-patch pull request to Neovim.""-  echo-  echo ""vim-revision can be a version number of the format '7.4.xxx'""-  echo ""or a Mercurial commit hash.""+  echo ""    -h                 Show this message and exit.""+  echo ""    -l                 Show list of Vim patches missing from Neovim.""+  echo ""    -p {vim-revision}  Download and apply the Vim patch vim-revision.""+  echo ""                       vim-revision can be a version number of the ""+  echo ""                       format '7.4.xxx' or a Mercurial commit hash.""+  echo ""    -r {pr-number}     Review a vim-patch pull request to Neovim.""   echo   echo ""Set VIM_SOURCE_DIR to change where Vim's sources are stored.""   echo ""The default is '${VIM_SOURCE_DIR_DEFAULT}'.""@@ -35,16 +34,6 @@ check_executable() {   fi }-# Checks for the right number of parameters.-check_params() {-  # Add one because the expected number of parameters-  # is also passed to this function.-  if [[ ${#} != $((${1}+1)) ]]; then-    usage-    exit 1-  fi-}- get_vim_sources() {   check_executable hg@@ -274,18 +263,30 @@ review_pr() {   exec nvim -O ""${NEOVIM_SOURCE_DIR}/${base_name}.diff"" ""${NEOVIM_SOURCE_DIR}/n${base_name}.diff"" }-if [[ ${#} == 0 || ${1} == ""--help"" || ${1} == ""-h"" ]]; then-  usage-  exit 0-fi+while getopts ""hlp:r:"" opt; do+  case $opt in+    h)+      usage+      exit 0+      ;;+    l)+      list_vim_patches+      exit 0+      ;;+    p)+      get_vim_patch ""$OPTARG""+      exit 0+      ;;+    r)+      review_pr ""$OPTARG""+      exit 0+      ;;+    *)+      exit 1+      ;;+  esac+done-if [[ ${1} == ""--list"" || ${1} == ""-l"" ]]; then-  check_params 1 ""${@}""-  list_vim_patches-elif [[ ${1} == ""--review"" || ${1} == ""-r"" ]]; then-  check_params 2 ""${@}""-  review_pr ""${2}""-else-  check_params 1 ""${@}""-  get_vim_patch ""${1}""-fi+usage++# vim: et sw=2```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2288,35495482,2015-07-26T17:46:42Z,runtime/syntax/vim.vim,"@@ -64,24 +33,20 @@ syn match   vimTermOption contained	""t_&8"" syn match   vimTermOption contained	""t_%i"" syn match   vimTermOption contained	""t_k;"" -"" unsupported settings: these are supported by vi but don't do anything in vim {{{2-syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 --"" AutoCmd Events {{{2+""}}}2 syn case ignore-syn keyword vimAutoEvent contained	BufAdd BufCreate BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufRead BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWrite BufWriteCmd BufWritePost BufWritePre Cmd-event CmdUndefined CmdwinEnter CmdwinLeave ColorScheme CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI EncodingChanged FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileEncoding FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave MenuPopup QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermOpen TermResponse TextChanged TextChangedI User UserGettingBored VimEnter VimLeave VimLeavePre VimResized WinEnter WinLeave-syn keyword nvimAutoEvent contained	TabNew TabNewEntered TabClosed TermEnter- "" Highlight commonly used Groupnames {{{2 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo   "" Default highlighting groups {{{2 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu syn match vimHLGroup contained	""Conceal""+<<<<<<< HEAD syn keyword vimOnlyHLGroup contained	VisualNOS syn keyword nvimHLGroup contained	EndOfBuffer TermCursor TermCursorNC+=======",bad merge,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3108,35505813,2015-07-27T05:03:21Z,runtime/syntax/vim.vim,"@@ -19,14 +19,14 @@ syn cluster vimCommentGroup	contains=vimTodo,@Spell  "" Special and plugin vim commands {{{2 syn match   vimCommand contained	""\<z[-+^.=]\=""-syn keyword vimOnlyCommand contained	fix[del] sh[ell] P[rint]+syn keyword vimOnlyCommand contained fix[del] sh[ell] te[aroff] P[rint] syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns  "" Vim-specific options {{{2-syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert+syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode ttym ttymouse tbi ttybuiltin wiv weirdinvert",If you want to remove these it is better to also revert 6f35bcfb07bae585928e03301eb2f19813c3e400. Otherwise these options will not be listed anywhere: the main reason this commit exists is that I found options that are both in vimOnlyOption and vimOption.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3029,35515998,2015-07-27T08:51:52Z,src/nvim/event/rstream.c,"@@ -167,9 +169,19 @@ static void fread_idle_cb(uv_idle_t *handle)   invoke_read_cb(stream, false); } -static void invoke_read_cb(Stream *stream, bool eof)+static void read_event(void **argv) {+  Stream *stream = argv[0];+  bool eof = (uintptr_t)argv[1];   if (stream->read_cb) {     stream->read_cb(stream, stream->buffer, stream->data, eof);   }+  if (eof && stream->internal_eof_cb) {+    stream->internal_eof_cb(stream, stream->internal_data);+  }+}++static void invoke_read_cb(Stream *stream, bool eof)+{+  queue_put(stream->events, read_event, 2, stream, (void *)(uintptr_t)eof);","`on_job_output()` in eval.c consumes all data in the `RBbuffer` (`RBUFFER_UNTIL_EMPTY`). So if we queue more than one `read_event` for a stream, the first event will use up all data. The other events only see the empty `RBbuffer`. This could lead to reordering of output for different streams if their read events are interleaved.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3029,35538120,2015-07-27T14:00:47Z,src/nvim/event/rstream.c,"@@ -167,9 +169,19 @@ static void fread_idle_cb(uv_idle_t *handle)   invoke_read_cb(stream, false); } -static void invoke_read_cb(Stream *stream, bool eof)+static void read_event(void **argv) {+  Stream *stream = argv[0];+  bool eof = (uintptr_t)argv[1];   if (stream->read_cb) {     stream->read_cb(stream, stream->buffer, stream->data, eof);   }+  if (eof && stream->internal_eof_cb) {+    stream->internal_eof_cb(stream, stream->internal_data);+  }+}++static void invoke_read_cb(Stream *stream, bool eof)+{+  queue_put(stream->events, read_event, 2, stream, (void *)(uintptr_t)eof);","My scenario would look like this:In the terminal you have output combined from stdout and stderr. A program generates output,first you have some output on stdout, then output on stderr, output on stdout, output on stderr,...The whole output should be interleaved from both streams.Each output generates a `read_event` and they are placed in the same queue. If the queue is processed,the first `read_event` will send the whole stdout output to the terminal (`on_job_output()` consumes the whole buffer). The next `read_event` is similar for stderr. The remaining read events do nothing because now both `RBuffer` are already empty. So the terminal would show first the stdout output and after that the stderr output.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3108,35553237,2015-07-27T16:03:36Z,runtime/syntax/vim.vim,"@@ -19,14 +19,14 @@ syn cluster vimCommentGroup	contains=vimTodo,@Spell  "" Special and plugin vim commands {{{2 syn match   vimCommand contained	""\<z[-+^.=]\=""-syn keyword vimOnlyCommand contained	fix[del] sh[ell] P[rint]+syn keyword vimOnlyCommand contained fix[del] sh[ell] te[aroff] P[rint] syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns  "" Vim-specific options {{{2-syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert+syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode ttym ttymouse tbi ttybuiltin wiv weirdinvert","I think these shouldn't be removed. While setting `ttyfast` is not an error, it _is_ a smell. ",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3108,35556142,2015-07-27T16:30:09Z,runtime/syntax/vim.vim,"@@ -19,14 +19,14 @@ syn cluster vimCommentGroup	contains=vimTodo,@Spell  "" Special and plugin vim commands {{{2 syn match   vimCommand contained	""\<z[-+^.=]\=""-syn keyword vimOnlyCommand contained	fix[del] sh[ell] P[rint]+syn keyword vimOnlyCommand contained fix[del] sh[ell] te[aroff] P[rint] syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns  "" Vim-specific options {{{2-syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert+syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode ttym ttymouse tbi ttybuiltin wiv weirdinvert","> it is a smellI agree, but I'm not totally sure, since we already have the compatibility options in place. If they're highlighted as red then people might think they're an error when they aren't.The point of the compatibility shims was so that people could have `set ttyfast` in the same vimrc they use for Vim and Nvim without having to wrap it in `has('nvim')` or `exists('+ttyfast')`. With that said, I'd rather we not define it as an error until we actually remove the compatibility shim.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/3029,35633301,2015-07-28T10:23:05Z,src/nvim/event/rstream.c,"@@ -167,9 +169,19 @@ static void fread_idle_cb(uv_idle_t *handle)   invoke_read_cb(stream, false); } -static void invoke_read_cb(Stream *stream, bool eof)+static void read_event(void **argv) {+  Stream *stream = argv[0];+  bool eof = (uintptr_t)argv[1];   if (stream->read_cb) {     stream->read_cb(stream, stream->buffer, stream->data, eof);   }+  if (eof && stream->internal_eof_cb) {+    stream->internal_eof_cb(stream, stream->internal_data);+  }+}++static void invoke_read_cb(Stream *stream, bool eof)+{+  queue_put(stream->events, read_event, 2, stream, (void *)(uintptr_t)eof);","I have made a small change to pty processes: Now they only duplicate the master fd to stdout instead of stdout and stderr, and it seems to have fixed some random errors in terminal tests.Great job spotting this bug, it was already present on master and it was probably the cause of some random terminal drawing bugs. Fixing it will significantly improve stability.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3029,35856743,2015-07-30T10:13:58Z,src/nvim/event/rstream.c,"@@ -167,9 +169,19 @@ static void fread_idle_cb(uv_idle_t *handle)   invoke_read_cb(stream, false); } -static void invoke_read_cb(Stream *stream, bool eof)+static void read_event(void **argv) {+  Stream *stream = argv[0];+  bool eof = (uintptr_t)argv[1];   if (stream->read_cb) {     stream->read_cb(stream, stream->buffer, stream->data, eof);   }+  if (eof && stream->internal_eof_cb) {+    stream->internal_eof_cb(stream, stream->internal_data);+  }+}++static void invoke_read_cb(Stream *stream, bool eof)+{+  queue_put(stream->events, read_event, 2, stream, (void *)(uintptr_t)eof);","> Is there any other scenario where you can see this reordering would cause a problem?test2.sh:``` bash#!/bin/bashecho ""stdout 1""echo ""stderr 1""  1>&2echo ""stdout 2""echo ""stderr 2""  1>&2```Output for test2.sh in a terminal:``` bashstdout 1stderr 1stdout 2stderr 2```Now with a vim script:``` vimfunction! s:JobHandler(job_id, data, event)    call append(line('$'),a:data)endfunctionlet s:callbacks = {\ 'on_stdout': function('s:JobHandler'),\ 'on_stderr': function('s:JobHandler'),\ }let job1 = jobstart(""sh ./test2.sh"", s:callbacks)```Output:``` vimstdout 1stdout 2stderr 1stderr 2```Now output is printed out of order.Edit:One problem is, we don't read the pipes fast enough to generate the output events in the right order (so we probably should not try to combine output from two streams). But even if we did, the first output event for a stream is ""greedy"" and prints everything what was read so far for a stream (output is ordered by stream).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3117,35914947,2015-07-30T20:13:19Z,src/nvim/fileio.c,"@@ -5755,7 +5755,7 @@ static int do_autocmd_event(event_T event, char_u *pat, int nested, char_u *cmd,      */     brace_level = 0;     for (endpat = pat; *endpat && (*endpat != ',' || brace_level-                                   || endpat[-1] == '\\'); ++endpat) {+                 || (endpat > pat && endpat[-1] == '\\')); ++endpat) {","Instead of checking for a leading ',' after the loop, we can do it before the loop. With that the first loop iteration will never check `endpat[-1]` and for all other iteration the check is okay.``` diff@@ -5753,16 +5753,19 @@ static int do_autocmd_event(event_T event, char_u *pat, int nested, char_u *cmd,      * Find end of the pattern.      * Watch out for a comma in braces, like ""*.\{obj,o\}"".      */+    endpat = pat;+    // ignore single comma+    if (*endpat == ',') {+      continue;+    }     brace_level = 0;-    for (endpat = pat; *endpat && (*endpat != ',' || brace_level-                 || (endpat > pat && endpat[-1] == '\\')); ++endpat) {+    for (; *endpat && (*endpat != ',' || brace_level || endpat[-1] == '\\');+         ++endpat) {       if (*endpat == '{')         brace_level++;       else if (*endpat == '}')         brace_level--;     }-    if (pat == endpat)                  /* ignore single comma */-      continue;     patlen = (int)(endpat - pat);     /*```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3120,36021832,2015-07-31T22:19:47Z,src/nvim/os/env.c,"@@ -427,6 +427,33 @@ char *vim_getenv(const char *name)     return xstrdup(kos_env_path);   } +  // XDG Base Directory expansion.+  if (strncmp(name, ""XDG_"", 4) == 0) {+    const char *home = vim_getenv(""HOME"");+    if (!home) {+        return NULL;+    }++    const char *home_suffix = """";+    if (strcmp(name, ""XDG_DATA_HOME"") == 0) {+      home_suffix = ""/.local/share/"";+    } else if (strcmp(name, ""XDG_CONFIG_HOME"") == 0) {+      home_suffix = ""/.config/"";+    } else if (strcmp(name, ""XDG_CACHE_HOME"") == 0) {+      home_suffix = ""/.cache/"";+    } else if (strcmp(name, ""XDG_RUNTIME_DIR"") == 0) {+      return xstrdup(""/tmp/"");  // Arbitrary value, any idea?+    }","By the way, where are `XDG_{DATA,CONFIG}_DIRS`? One of the suggestions in my issue was initially populating `&runtimepath` from XDG_CONFIG_DIRS+XDG_CONFIG_HOME, but I think that XDG_DATA_{DIRS,HOME} should also be taken into account (reason: /usr/share/vim/vimfiles is where package managers usually put third-party plugins, thus with new directories /usr/share/nvim/site should be included and this is naturally done using XDG_DATA_DIRS, but not XDG_DATA_HOME, XDG_CONFIG_HOME or XDG_CONFIG_DIRS). This way &runtimepath will look like:```$XDG_CONFIG_HOME/nvim$XDG_DATA_HOME/nvim$xdg_config_dir/nvim (repeated for each directory in $XDG_CONFIG_DIRS)$xdg_data_dir/nvim/site (repeated for each directory in $XDG_DATA_DIRS)$VIMRUNTIME (looks something like /usr/share/nvim/runtime)$xdg_data_dir/nvim/site/after (repeated for each directory in $XDG_DATA_DIRS)$xdg_config_dir/nvim/after (repeated for each directory in $XDG_CONFIG_DIRS)$XDG_CONFIG_HOME/nvim/after````XDG_DATA_DIRS` defaults to `/usr/local/share/:/usr/share/` according to the specification. This is why initial suggestion is using `site` in runtimepath only: if it was `runtime` then $VIMRUNTIME was naturally included (effectively meaning that this setting will become obsolete which is bad for compatibility reasons).",
1327378,Yamakaky,https://api.github.com/repos/neovim/neovim/pulls/3120,36034115,2015-08-01T14:37:52Z,src/nvim/os/env.c,"@@ -427,6 +427,33 @@ char *vim_getenv(const char *name)     return xstrdup(kos_env_path);   } +  // XDG Base Directory expansion.+  if (strncmp(name, ""XDG_"", 4) == 0) {+    const char *home = vim_getenv(""HOME"");+    if (!home) {+        return NULL;+    }++    const char *home_suffix = """";+    if (strcmp(name, ""XDG_DATA_HOME"") == 0) {+      home_suffix = ""/.local/share/"";+    } else if (strcmp(name, ""XDG_CONFIG_HOME"") == 0) {+      home_suffix = ""/.config/"";+    } else if (strcmp(name, ""XDG_CACHE_HOME"") == 0) {+      home_suffix = ""/.cache/"";+    } else if (strcmp(name, ""XDG_RUNTIME_DIR"") == 0) {+      return xstrdup(""/tmp/"");  // Arbitrary value, any idea?+    }","You are right. It's just that it's a bigger change than simply using __HOME, since you can't expand XDG___DIR in macros, it needs code changes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3099,36038223,2015-08-02T00:10:50Z,src/nvim/path.c,"@@ -481,6 +481,24 @@ static size_t path_expand(garray_T *gap, const char_u *path, int flags)   return do_path_expand(gap, path, 0, flags, false); } +static const char *os_scandir_next_with_dots(Directory *dir)","`scandir_next_with_dots` since it's a private function, not in ""os"" module.This might be paranoia, but in case it is not called >=3 times, it will be left in a bad state. So there should be a way to ""initialize"" the internal state. I suggest if `dir == NULL` then `count` should be initialized to 0.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,36039898,2015-08-02T06:02:47Z,src/nvim/ex_docmd.c,"@@ -9411,3 +9411,36 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  if (*eap->arg != NUL) {+    if (os_isdir(eap->arg)) {  // full path: plug ~/.config/nvim/plugged/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, FALSE);+    } else {  // spec: plug neovim/neovimplugin+      char_u *user_vim = vim_strsave(p_rtp);+      strtok((char *)user_vim, "",""); // split(&runtimepath, ',')[0]+      char_u *basename = path_tail((char_u *)eap->arg); // 'neovim/neovimplugin' -> 'neovimplugin'+      if (STRNCMP(basename, """", 1) != 0 && STRNCMP(p_bundledir, """", 1) != 0) {+        if (!os_isdir(p_bundledir)) {+          path = concat_fnames(+              concat_fnames((char *)user_vim,+                (char *)p_bundledir, true),+              (char *)basename, true);+        } else {+          path = concat_fnames((char *)p_bundledir, (char *)basename, true);+        }+      }+    }++    if (path != NUL) {+      char ex_cmd[512];+      snprintf(ex_cmd, sizeof(ex_cmd), "":set rtp+=%s"", path);",This code is incomplete because plugin���s `/after` paths are not used.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,36040063,2015-08-02T06:32:15Z,src/nvim/ex_docmd.c,"@@ -9411,3 +9411,36 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  if (*eap->arg != NUL) {+    if (os_isdir(eap->arg)) {  // full path: plug ~/.config/nvim/plugged/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, FALSE);+    } else {  // spec: plug neovim/neovimplugin+      char_u *user_vim = vim_strsave(p_rtp);+      strtok((char *)user_vim, "",""); // split(&runtimepath, ',')[0]+      char_u *basename = path_tail((char_u *)eap->arg); // 'neovim/neovimplugin' -> 'neovimplugin'","Note that some plugin managers (at least, VAM) use variants other then just basename, because basename may contain characters that are not valid in the current filesystem, or because it is incomplete.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3125,36040090,2015-08-02T06:36:41Z,src/nvim/ex_docmd.c,"@@ -9411,3 +9411,36 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  if (*eap->arg != NUL) {+    if (os_isdir(eap->arg)) {  // full path: plug ~/.config/nvim/plugged/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, FALSE);+    } else {  // spec: plug neovim/neovimplugin+      char_u *user_vim = vim_strsave(p_rtp);+      strtok((char *)user_vim, "",""); // split(&runtimepath, ',')[0]+      char_u *basename = path_tail((char_u *)eap->arg); // 'neovim/neovimplugin' -> 'neovimplugin'","For those cases we should probably add support for metadata in v:plugins, like described:``` vimplug 'prefix/name' {'dir': 'realpath'}```and use 'dir' instead of the basename to define the path.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,36040109,2015-08-02T06:39:54Z,src/nvim/ex_docmd.c,"@@ -9411,3 +9411,36 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  if (*eap->arg != NUL) {+    if (os_isdir(eap->arg)) {  // full path: plug ~/.config/nvim/plugged/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, FALSE);+    } else {  // spec: plug neovim/neovimplugin+      char_u *user_vim = vim_strsave(p_rtp);+      strtok((char *)user_vim, "",""); // split(&runtimepath, ',')[0]+      char_u *basename = path_tail((char_u *)eap->arg); // 'neovim/neovimplugin' -> 'neovimplugin'","@fmoralesc Completely invalid, at least for VAM. Plugin name like `github:ludovicchabant/vim-gutentags` is translated to `github-ludovicchabant-vim-gutentags` without requiring user to specify anything. Just `vim-gutentags` is not used because with some common names this name may conflict with plugins found in the database.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,36040446,2015-08-02T07:31:50Z,src/nvim/ex_docmd.c,"@@ -9411,3 +9411,40 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  if (*eap->arg != NUL) {+    if (os_isdir(eap->arg)) {  // full path: plug ~/.config/nvim/plugged/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, FALSE);+    } else {  // spec: plug neovim/coolplugin+      char_u *basename = path_tail((char_u *)eap->arg); // 'neovim/coolplugin' -> 'coolplugin'+      if (STRNCMP(basename, """", 1) != 0 && STRNCMP(p_plugindir, """", 1) != 0) {+        if (!os_isdir(p_plugindir)) {+          // we build a path using the first item in 'runtimepath' (usually, '~/.config/nvim')+	  char_u *rtp_copy = vim_strsave(p_rtp);",What for are you calling `vim_strsave`? `copy_option_part` has rather explicit name: it _will_ do copying on its own. Check out `vim_list_runtime_paths` from `src/nvim/api/vim.c`: it just does `rtp = p_rtp` and then uses `copy_option_part`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,36040728,2015-08-02T08:10:56Z,runtime/doc/options.txt,"@@ -4872,6 +4872,21 @@ A jump table for the options with a short description can be found at |Q_op|. <	Replace the ';' with a ':' or whatever separator is used.  Note that 	this doesn't work when $INCL contains a comma or white space. +							   *'plugindir'*+'plugindir' 'pidir'	string (default ""bundle"")+			global","By the way, what is the policy for `{Nvim}` badge (and where it is written)?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3120,36040791,2015-08-02T08:19:26Z,src/nvim/os/unix_defs.h,"@@ -28,46 +32,51 @@ #ifndef SYNTAX_FNAME # define SYNTAX_FNAME   ""$VIMRUNTIME/syntax/%s.vim"" #endif+// Not used anymore ? #ifndef USR_EXRC_FILE # define USR_EXRC_FILE ""~/.exrc"" #endif #ifndef USR_VIMRC_FILE-# define USR_VIMRC_FILE ""~/.nvimrc""+# define USR_VIMRC_FILE NVIM_CONF_DIR ""/init.vim"" #endif+// Not used anymore ? #ifndef USR_VIMRC_FILE2 # define USR_VIMRC_FILE2     ""~/.nvim/nvimrc"" #endif+// Not used anymore ? #ifndef EXRC_FILE # define EXRC_FILE      "".exrc"" #endif+// Not used anymore ? #ifndef VIMRC_FILE # define VIMRC_FILE     "".nvimrc""","This is for `'exrc'` feature. Removing this is out of scope, will be a long discussion.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3034,36044387,2015-08-02T15:50:05Z,src/nvim/eval.c,"@@ -5177,6 +5265,23 @@ void list_append_string(list_T *l, char_u *str, int len)   } } +/// Append given string to the list+///+/// Unlike list_append_string this function does not copy the string.+///+/// @param[out]  l    List to append to.+/// @param[in]   str  String to append.+void list_append_allocated_string(list_T *l, char *const str)+  FUNC_ATTR_NONNULL_ARG(1)",`list_append_string` can call `list_append_allocated_string()` instead of repeating the logic.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3034,36213338,2015-08-04T17:02:36Z,runtime/doc/eval.txt,"@@ -4613,6 +4621,91 @@ mode([expr])	Return a string that indicates the current mode. 		""c"" or ""n"". 		Also see |visualmode()|. +msgpackdump({list})				   {Nvim} *msgpackdump()*+		Convert a list of VimL objects to msgpack. Returned value is+		|readfile()|-style list. Example: >+			call writefile(msgpackdump([{}]), 'fname.mpack', 'b')+<		This will write the single 0x80 byte to `fname.mpack` file+		(dictionary with zero items is represented by 0x80 byte in+		messagepack).++		Limitations:+		1. |Funcref|s cannot be dumped.+		2. Containers that reference themselves cannot be dumped.+		3. Dictionary keys are always dumped as STR strings.+		4. Other strings are always dumped as BIN strings.+		5. Points 3. and 4. do not apply to |msgpack-special-dict|s.++msgpackparse({list})				   {Nvim} *msgpackparse()*+		Convert a |readfile()|-style list to a list of VimL objects. +		Example: >+			let fname = expand('~/.nvim/shada/main.shada')+			let mpack = readfile(fname, 'b')+			let shada_objects = msgpackparse(mpack)+<		This will read |shada-file| to `shada_objects` list.",This can be an anti-easter-egg until shada gets merged :sweat_smile:,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2809,36219918,2015-08-04T17:57:42Z,src/nvim/ops.c,"@@ -5404,9 +5411,60 @@ static bool get_clipboard(int name, yankreg_T **target, bool quiet)   return false; } ++/*+ * Save and restore clip_unnamed before doing possibly many changes. This+ * prevents accessing the clipboard very often which might slow down Vim+ * considerably.+*/++/*+ * Save clip_unnamed and reset it.+ */+void start_global_changes(void)+{+  if (++global_change_count > 1) {+    return;+  }+  clip_unnamed_saved = clip_unnamed;+  clipboard_needs_update = FALSE;++  if (clip_did_set_selection) {+    clip_unnamed = 0;","`clip_unnamed` did become `cb_flags & CB_UNNAMEDMASK`  in the clipboard refactor. But rather than saving, hiding, and then restoring the value, can't `adjust_clipboard_name` (the only place where `cb_flags` have direct effect) just check the relevant condition directly ? ",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3133,36471831,2015-08-06T22:05:35Z,src/nvim/mbyte.c,"@@ -117,6 +118,27 @@ struct interval { # include ""mbyte.c.generated.h"" #endif +/// To speed up BYTELEN() we fill a table with the byte lengths whenever+/// enc_utf8 or enc_dbcs changes.+static uint8_t mb_bytelen_tab[256];++/// @return byte length of character that starts with byte ""b"".+/// Returns 1 for a single-byte character.+/// mb_byte2len_check() can be used to count a special key as one byte.+uint8_t mb_byte2len(uint8_t b)","@Yamakaky This is related to common subexpression elimination, and also to throwing away unused returns with the function call itself. Compiler does not do caching of the call results.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3145,36581292,2015-08-08T20:07:15Z,src/nvim/tui/tui.c,"@@ -208,10 +210,12 @@ static void try_resize(Event ev)   UI *ui = ev.data;   update_size(ui);   ui_refresh();+  during_winch = false; }  static void sigwinch_cb(SignalWatcher *watcher, int signum, void *data) {+  during_winch = true;",`try_resize` is only called by `sigwinch_cb`. So we don't need to track state at all--we can add a parameter to  `tui_resize` called `try_resize_terminal` and check that before sending the terminal resize sequence.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,36649776,2015-08-10T16:13:28Z,runtime/doc/options.txt,"@@ -5403,6 +5404,124 @@ A jump table for the options with a short description can be found at |Q_op|. 	with Unix.  The Unix version of Vim cannot source dos format scripts, 	but the Windows version of Vim can source unix format scripts. +				*'shada'* *'sd'* *E526* *E527* *E528*+'shada' 'sd'		string	(Vim default for+				   Win32:  '!,100,<50,s10,h,rA:,rB:+				   others: '!,100,<50,s10,h+				 Vi default: """")+			global+	When non-empty, the shada file is read upon startup and written+	when exiting Vim (see |shada-file|).  The string should be a comma+	separated list of parameters, each consisting of a single character+	identifying the particular parameter, followed by a number or string+	which specifies the value of that parameter.  If a particular+	character is left out, then the default value is used for that+	parameter.  The following is a list of the identifying characters and+	the effect of their value.+	CHAR	VALUE	~+							*shada-!*+	!	When included, save and restore global variables that start+		with an uppercase letter, and don't contain a lowercase+		letter.  Thus ""KEEPTHIS and ""K_L_M"" are stored, but ""KeepThis""+		and ""_K_L_M"" are not.  Nested List and Dict items may not be+		read back correctly, you end up with an empty item.+							*shada-quote*+	""	Maximum number of lines saved for each register.  Old name of+		the '<' item, with the disadvantage that you need to put a+		backslash before the "", otherwise it will be recognized as the+		start of a comment!+							*shada-%*+	%	When included, save and restore the buffer list.  If Vim is+		started with a file name argument, the buffer list is not+		restored.  If Vim is started without a file name argument, the+		buffer list is restored from the shada file.  Buffers+		without a file name and buffers for help files are not written+		to the shada file.+		When followed by a number, the number specifies the maximum+		number of buffers that are stored.  Without a number all+		buffers are stored.+							*shada-'*+	'	Maximum number of previously edited files for which the marks+		are remembered.  This parameter must always be included when+		'shada' is non-empty.+		Including this item also means that the |jumplist| and the+		|changelist| are stored in the shada file.+							*shada-/*+	/	Maximum number of items in the search pattern history to be+		saved.  If non-zero, then the previous search and substitute+		patterns are also saved.  When not included, the value of+		'history' is used.+							*shada-:*+	:	Maximum number of items in the command-line history to be+		saved.  When not included, the value of 'history' is used.+							*shada-<*+	<	Maximum number of lines saved for each register.  If zero then+		registers are not saved.  When not included, all lines are+		saved.  '""' is the old name for this item.+		Also see the 's' item below: limit specified in Kbyte.+							*shada-@*+	@	Maximum number of items in the input-line history to be+		saved.  When not included, the value of 'history' is used.+							*shada-c*+	c	Dumb option, kept for compatibility reasons.  Has no actual +		effect.  Current encoding state is described in +		|shada-encoding|.+							*shada-f*+	f	Whether file marks need to be stored.  If zero, file marks ('0+		to '9, 'A to 'Z) are not stored.  When not present or when+		non-zero, they are all stored.  '0 is used for the current+		cursor position (when exiting or when doing |:wshada|).+							*shada-h*+	h	Disable the effect of 'hlsearch' when loading the shada+		file.  When not included, it depends on whether "":nohlsearch""+		has been used since the last search command.+							*shada-n*+	n	Name of the shada file.  The name must immediately follow+		the 'n'.  Must be the last one!  If the ""-i"" argument was+		given when starting Vim, that file name overrides the one+		given here with 'shada'.  Environment variables are expanded+		when opening the file, not when setting the option.+							*shada-r*+	r	Removable media.  The argument is a string (up to the next+		',').  This parameter can be given several times.  Each+		specifies the start of a path for which no marks will be+		stored.  This is to avoid removable media.  For MS-DOS you+		could use ""ra:,rb:"".  You can also use it for temp files,+		e.g., for Unix: ""r/tmp"".  Case is ignored.  Maximum length of+		each 'r' argument is 50 characters.+							*shada-s*+	s	Maximum size of an item contents in KiB.  If zero then nothing +		is saved.  Unlike Vim this applies to all items, except for +		the buffer list and header.  Full item size is off by three +		unsigned integers: with `s10` maximum item size may be 1 byte ","���Three unsigned integers��� is a description of the _data_, not of the _data size_. I do not know actual offset, 13 bytes is1. _Only_ valid for `s10` option. Other numbers will produce other caps.2. Is a cap, not exact value.3. Depends on my knowledge of MessagePack dumper. According to the specification dumpers _should_ use the smallest representation available, but specification allows to make all three integers mentioned occupy 9 bytes. Total all-times cap (at least until 128-bit integers in some of the later versions of the standard) is 9*3 = 27 bytes.4. Also if you use ShaDa compatibility features you can have entry with type 0xFFFFFFFFFFFFFFFFLU which will, of course, be represented using 9 bytes. And for the forward compatibility sake such an entry will be copied in the newly created ShaDa file.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,36654449,2015-08-10T16:54:32Z,runtime/doc/options.txt,"@@ -5403,6 +5404,124 @@ A jump table for the options with a short description can be found at |Q_op|. 	with Unix.  The Unix version of Vim cannot source dos format scripts, 	but the Windows version of Vim can source unix format scripts. +				*'shada'* *'sd'* *E526* *E527* *E528*+'shada' 'sd'		string	(Vim default for+				   Win32:  '!,100,<50,s10,h,rA:,rB:+				   others: '!,100,<50,s10,h+				 Vi default: """")+			global+	When non-empty, the shada file is read upon startup and written+	when exiting Vim (see |shada-file|).  The string should be a comma+	separated list of parameters, each consisting of a single character+	identifying the particular parameter, followed by a number or string+	which specifies the value of that parameter.  If a particular+	character is left out, then the default value is used for that+	parameter.  The following is a list of the identifying characters and+	the effect of their value.+	CHAR	VALUE	~+							*shada-!*+	!	When included, save and restore global variables that start+		with an uppercase letter, and don't contain a lowercase+		letter.  Thus ""KEEPTHIS and ""K_L_M"" are stored, but ""KeepThis""+		and ""_K_L_M"" are not.  Nested List and Dict items may not be+		read back correctly, you end up with an empty item.+							*shada-quote*+	""	Maximum number of lines saved for each register.  Old name of+		the '<' item, with the disadvantage that you need to put a+		backslash before the "", otherwise it will be recognized as the+		start of a comment!+							*shada-%*+	%	When included, save and restore the buffer list.  If Vim is+		started with a file name argument, the buffer list is not+		restored.  If Vim is started without a file name argument, the+		buffer list is restored from the shada file.  Buffers+		without a file name and buffers for help files are not written+		to the shada file.+		When followed by a number, the number specifies the maximum+		number of buffers that are stored.  Without a number all+		buffers are stored.+							*shada-'*+	'	Maximum number of previously edited files for which the marks+		are remembered.  This parameter must always be included when+		'shada' is non-empty.+		Including this item also means that the |jumplist| and the+		|changelist| are stored in the shada file.+							*shada-/*+	/	Maximum number of items in the search pattern history to be+		saved.  If non-zero, then the previous search and substitute+		patterns are also saved.  When not included, the value of+		'history' is used.+							*shada-:*+	:	Maximum number of items in the command-line history to be+		saved.  When not included, the value of 'history' is used.+							*shada-<*+	<	Maximum number of lines saved for each register.  If zero then+		registers are not saved.  When not included, all lines are+		saved.  '""' is the old name for this item.+		Also see the 's' item below: limit specified in Kbyte.+							*shada-@*+	@	Maximum number of items in the input-line history to be+		saved.  When not included, the value of 'history' is used.+							*shada-c*+	c	Dumb option, kept for compatibility reasons.  Has no actual +		effect.  Current encoding state is described in +		|shada-encoding|.+							*shada-f*+	f	Whether file marks need to be stored.  If zero, file marks ('0+		to '9, 'A to 'Z) are not stored.  When not present or when+		non-zero, they are all stored.  '0 is used for the current+		cursor position (when exiting or when doing |:wshada|).+							*shada-h*+	h	Disable the effect of 'hlsearch' when loading the shada+		file.  When not included, it depends on whether "":nohlsearch""+		has been used since the last search command.+							*shada-n*+	n	Name of the shada file.  The name must immediately follow+		the 'n'.  Must be the last one!  If the ""-i"" argument was",I think this was about &clipboard setting: `exclude:{pattern}` is documented as something that must be the last entry.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3134,36672851,2015-08-10T19:21:31Z,src/nvim/charset.c,"@@ -1240,7 +1250,7 @@ void getvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor,           if (enc_utf8 && (c >= 0x80)) {             incr = utf_ptr2cells(ptr);           } else {-            incr = CHARSIZE(c);+            incr = char_size(c);","Wondering how you managed to pass tests with this problem. I am pretty sure that passing int to uint8_t should file -Wconversion warning, even with clang. Does this mean that charset.c is not checked? I see no exceptions made for any file.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3134,36674581,2015-08-10T19:37:17Z,src/nvim/charset.c,"@@ -1240,7 +1250,7 @@ void getvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor,           if (enc_utf8 && (c >= 0x80)) {             incr = utf_ptr2cells(ptr);           } else {-            incr = CHARSIZE(c);+            incr = char_size(c);",charset.c  is not checked yet (CONV_SOURCES is a blacklist): https://github.com/neovim/neovim/blob/a497bf4bfdc79b6fa52a846d7d0a884ba007f452/src/nvim/CMakeLists.txt#L66,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3134,36675263,2015-08-10T19:44:01Z,src/nvim/charset.c,"@@ -1240,7 +1250,7 @@ void getvcol(win_T *wp, pos_T *pos, colnr_T *start, colnr_T *cursor,           if (enc_utf8 && (c >= 0x80)) {             incr = utf_ptr2cells(ptr);           } else {-            incr = CHARSIZE(c);+            incr = char_size(c);","Ah, CMakeLists.txt add -Wconversion unconditionally and then it is filtered out in src/nvim/CmakeLists.txt. I have only checked top-level CMakeLists.txt. (By the way, how about disabling GCC -Wconversion? It constantly produces warnings cmake does not in cases when I do not see any problems.)",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/3152,36798001,2015-08-11T20:58:08Z,.ci/install.sh,"@@ -18,3 +18,5 @@ elif [[ ""${BUILD_MINGW}"" == ON ]]; then fi  pip install --user --upgrade cpp-coveralls neovim+pip-3.3 install --user --upgrade neovim","I thought just adding `python3-pip` to the installed APT packages should be enough, but looks like Ubuntu 12.04 doesn't have this package, for whatever reason. The following should work:- Add `python3-setuptools`, `python3-dev` to APT packages (depends on https://github.com/travis-ci/apt-package-whitelist/issues/771)- Run `easy_install3 --user neovim`",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/3166,37024695,2015-08-13T20:59:57Z,src/nvim/os/fs.c,"@@ -279,13 +279,24 @@ bool os_file_is_readonly(const char *name)   return access(name, W_OK) != 0; } +/// Check if a file is readable.+///+/// @return 0 if `name` is not writable,+/// @return 1 if `name` is writable,+/// @return 2 for a directory which we have rights to write into.+bool os_file_is_readable(const char *name)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  return (access(name, R_OK) == 0);","Should be ok, just need to add a define for R_OK to 04 ([docs](https://msdn.microsoft.com/en-us/library/1w06ktdy.aspx))",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3178,37143628,2015-08-16T08:46:21Z,src/nvim/ex_docmd.c,"@@ -76,6 +76,16 @@ #include ""nvim/event/rstream.h"" #include ""nvim/event/wstream.h"" +/// The scope of a command.+///+/// The higher a number, the deeper a scope.+enum {+  SCOPE_EDITOR,     ///< Affects the entire instance of NeoVim.+  SCOPE_TABPAGE,    ///< Affects on tab page.+  SCOPE_WINDOW,     ///< Affects one window.+  NUMBER_OF_SCOPES  ///< Total number of scoped defined.","Enumerations start at 0 and every consecutive item is one larger, so the last item will be the number of items. This way is automatic, and if someone were to introduce a new scope the number of scopes would adjust automatically. Unlikely to ever happen, but I still prefer in general the compiler to take care of constants instead of me.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3178,37145141,2015-08-16T12:03:22Z,src/nvim/ex_docmd.c,"@@ -76,6 +76,16 @@ #include ""nvim/event/rstream.h"" #include ""nvim/event/wstream.h"" +/// The scope of a command.+///+/// The higher a number, the deeper a scope.+enum {+  SCOPE_EDITOR,     ///< Affects the entire instance of NeoVim.+  SCOPE_TABPAGE,    ///< Affects on tab page.+  SCOPE_WINDOW,     ///< Affects one window.+  NUMBER_OF_SCOPES  ///< Total number of scoped defined.","@HiPhish I know this, but still use `#define` in such cases because SCOPE_* entries have the same kind. NUMBER_OF_SCOPES is different, it is not a valid scope, so it should not be in the enum.Also1. Why it is anonymous enum? I think that some variables may have enumeration type.2. You must use `kScopeEditor` for constant names, **not** `SCOPE_EDITOR`. Check the [style guide](http://neovim.io/develop/style-guide.xml?showone=Enumerator_Names#Enumerator_Names), what you are using is the old naming inherited from Vim. Macros (like NUMBER_OF_SCOPES) on the other side still use ALL_CAPS naming.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3178,37145219,2015-08-16T12:12:54Z,src/nvim/buffer_defs.h,"@@ -814,6 +814,8 @@ struct tabpage_S {   frame_T         *(tp_snapshot[SNAP_COUNT]);    /* window layout snapshots */   dictitem_T tp_winvar;             /* variable for ""t:"" Dictionary */   dict_T          *tp_vars;         /* internal variables, local to tab page */+  char_u          *tp_localdir;     /* absolute path of local directory or+                                       NULL */","`//`-style comment (better `///<` doxygen-style, but useless; I normally use `//` in such cases, it looks like other developers agree). Also use `char *`.Note that surrounding style is inherited from Vim. You _don���t_ need to keep it.",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3178,37145295,2015-08-16T12:24:40Z,src/nvim/window.c,"@@ -3541,6 +3541,19 @@ static void win_enter_ext(win_T *wp, bool undo_sync, int curwin_invalid, int tri     }     if (os_chdir((char *)curwin->w_localdir) == 0)       shorten_fnames(TRUE);+  +  } else if (curtab->tp_localdir != NULL) {+  	// Similar to above, but if the tab has a local directory.+    if (globaldir == NULL) {+      char_u cwd[MAXPATHL];++      if (os_dirname(cwd, MAXPATHL) == OK) {+        globaldir = vim_strsave(cwd);+      }+    }+    if (os_chdir((char *)curtab->tp_localdir) == 0)+      shorten_fnames(TRUE);","`shorten_fnames` uses `int` as its parameter type, should I still pass a boolean anyway?",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3178,37145310,2015-08-16T12:27:16Z,src/nvim/buffer_defs.h,"@@ -814,6 +814,8 @@ struct tabpage_S {   frame_T         *(tp_snapshot[SNAP_COUNT]);    /* window layout snapshots */   dictitem_T tp_winvar;             /* variable for ""t:"" Dictionary */   dict_T          *tp_vars;         /* internal variables, local to tab page */+  char_u          *tp_localdir;     /* absolute path of local directory or+                                       NULL */","The struct has not been refactored, that's why I chose to stick with the old ways. Mixing new and old style in an old style struct seemed like a bad idea to me. That's why I also added the `tp_` prefix to the member variable.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2506,37145560,2015-08-16T13:00:05Z,src/nvim/mark.c,"@@ -68,6 +69,21 @@ int setmark(int c)   return setmark_pos(c, &curwin->w_cursor, curbuf->b_fnum); } +/// Free fmark_T item+void free_fmark(fmark_T fm)+{+  dict_unref(fm.additional_data);+  fm.additional_data = NULL;","`fm` is a copy, so setting `fm.additional_data` changes nothing after this function returns. Should this function expect a `fmark_T*` argument instead?",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3178,37147261,2015-08-16T16:00:22Z,src/nvim/ex_docmd.c,"@@ -6788,27 +6800,59 @@ void free_cd_dir(void)  #endif -/*- * Deal with the side effects of changing the current directory.- * When ""local"" is TRUE then this was after an "":lcd"" command.- */-void post_chdir(int local)-{+/// Deal with the side effects of changing the current directory.+///+/// The value of `scope` reflects the name under which the command was invoked:+///   - `SCOPE_EDITOR` for `:cd` and `chdir`+///   - `SCOPE_TABPAGE` for `:tcd` and `tchdir`+///   - `SCOPE_WINDOW` for `:lcd` and `lchdir`+///+/// @param scope  Scope of the function call (editor, tab or window).+///+/// @pre  The value of `scope` must be less than the number of scopes+///       (`NUMBER_OF_SCOPES`) and higher than zero.",Doesn't work:http://pastebin.com/ZcDMbNgxI had to change the parameter type back to `int`. I can still use an enum variable _inside_ the function so switch gives a warning if a case is being ignored.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3178,37148443,2015-08-16T18:16:43Z,src/nvim/ex_docmd.c,"@@ -76,6 +76,17 @@ #include ""nvim/event/rstream.h"" #include ""nvim/event/wstream.h"" +/// The scope of a command.+///+/// The higher a number, the deeper a scope.+enum cd_scope {+  kCdScopeEditor, ///< Affects the entire instance of NeoVim.+  kCdScopeTab,    ///< Affects on tab page.+  kCdScopeWindow, ///< Affects one window.+};++#define MAX_CD_SCOPE  kCdScopeWindow  ///< Total number of scoped defined.",`///<` (with `<`) comments are for class/struct/enum/union/��� members. Macros is not a member.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3178,37149463,2015-08-16T19:52:42Z,src/nvim/ex_docmd.c,"@@ -6788,27 +6801,51 @@ void free_cd_dir(void)  #endif -/*- * Deal with the side effects of changing the current directory.- * When ""local"" is TRUE then this was after an "":lcd"" command.- */-void post_chdir(int local)+/// Deal with the side effects of changing the current directory.+///+/// @param scope  Scope of the function call (editor, tab or window).+void post_chdir(int scope) {+  assert(scope >= kCdScopeEditor && scope <= MAX_CD_SCOPE);++  enum cd_scope s = scope; // Treat it as an enum so switch catches unused cases.","@HiPhish _Push_. You have a bad habit of not providing context, so I cannot say what is the problem.Most likely you ignored my words about ���typedef should be placed before the generated declarations���. At least I have `ex_docmd.h.generated.h` include on the line 23 of `ex_docmd.h` which (given the compiler log) says that you did this.**_KEEP `#ifdef INCLUDE_GENERATED_DECLARATIONS` SECTION THE LAST ONE IN THE HEADER FILE.**_",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,37149598,2015-08-16T20:02:12Z,src/nvim/eval.c,"@@ -5606,18 +5601,61 @@ int garbage_collect(void)   for (int i = 1; i <= ga_scripts.ga_len; ++i)     set_ref_in_ht(&SCRIPT_VARS(i), copyID); -  /* buffer-local variables */   FOR_ALL_BUFFERS(buf) {+    // buffer-local variables     set_ref_in_item(&buf->b_bufvar.di_tv, copyID);+    // buffer marks (ShaDa additional data)+    set_ref_in_fmark(buf->b_last_cursor, copyID);+    set_ref_in_fmark(buf->b_last_insert, copyID);+    set_ref_in_fmark(buf->b_last_change, copyID);+    for (size_t i = 0; i < NMARKS; i++) {+      set_ref_in_fmark(buf->b_namedm[i], copyID);+    }+    // buffer change list (ShaDa additional data)+    for (int i = 0; i < buf->b_changelistlen; i++) {+      set_ref_in_fmark(buf->b_changelist[i], copyID);+    }+    // buffer ShaDa additional data+    set_ref_dict(buf->additional_data, copyID);   } -  /* window-local variables */   FOR_ALL_TAB_WINDOWS(tp, wp) {+    // window-local variables     set_ref_in_item(&wp->w_winvar.di_tv, copyID);+    // window jump list (ShaDa additional data)+    for (int i = 0; i < wp->w_jumplistlen; i++) {+      set_ref_in_fmark(wp->w_jumplist[i].fmark, copyID);+    }   }   if (aucmd_win != NULL)     set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID); +  // registers (ShaDa additional data)+  {+    const void *reg_iter = NULL;+    do {+      yankreg_T reg;+      char name = NUL;","16.08.2015, 23:00, ""oni-link"" notifications@github.com:> In src/nvim/eval.c:> > > } > if (aucmd_win != NULL) > set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID); > > + // registers (ShaDa additional data) > + { > + const void *reg_iter = NULL; > + do { > + yankreg_T reg; > + char name = NUL;> > op_register_iter(reg_iter, &name, &reg) also sets name to NUL.I know. This is intentional, ���just in case���.> ���> Reply to this email directly or view it on GitHub.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2809,37150115,2015-08-16T20:43:58Z,src/nvim/ops.c,"@@ -72,6 +72,12 @@ static yankreg_T y_regs[NUM_REGISTERS]; static yankreg_T   *y_previous = NULL; /* ptr to last written yankreg */  static bool clipboard_didwarn_unnamed = false;++// for behavior between start_global_changes() and end_global_changes())+static bool delay_clipboard_update = false;  // clipboard's update needs to be delayed+static int global_change_count = 0;          // if set, inside global changes+static bool clipboard_needs_update = true;   // the clipboard was updated","In general in our C code, the pattern is ""noun-verb-foo"". Prefixing with verbs results in two very large ""get"" and ""set"" namespaces.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/2809,37150230,2015-08-16T20:51:35Z,src/nvim/ops.c,"@@ -5404,9 +5418,44 @@ static bool get_clipboard(int name, yankreg_T **target, bool quiet)   return false; } ++/*"," could merge these two comment blocks and into doxygen style. Also I would suggest moving `start_`/`end_` below `set_clipboard` ( as `adjust_clipboard_name`, `get_clipboard`, and `set_clipboard` belong close together, while `*_global_changes` is more of a special case)",
315886,jck,https://api.github.com/repos/neovim/neovim/pulls/3198,37446074,2015-08-19T17:57:48Z,src/nvim/os/stdpaths.c,"@@ -0,0 +1,88 @@+#include ""nvim/os/os.h""+#include ""nvim/strings.h""+#include ""nvim/path.h""+#include ""nvim/garray.h""++typedef enum {+  config_home,+  data_home,+  cache_home,+  runtime_dir,+  config_dirs,+  data_dirs,+} XDGDirType;++static const char *xdg_env_vars[] = {+  [config_home] = ""XDG_CONFIG_HOME"",+  [data_home] = ""XDG_DATA_HOME"",+  [cache_home] = ""XDG_CACHE_HOME"",+  [runtime_dir] = ""XDG_RUNTIME_DIR"",+  [config_dirs] = ""XDG_CONFIG_DIRS"",+  [data_dirs] = ""XDG_DATA_DIRS"",+};++#ifdef __linux__+static const char *const xdg_defaults[] = {+  [config_home] = ""~/.config"",+  [data_home] = ""~/.local/share"",+  [cache_home] = ""~/.cache"",+  [runtime_dir] = """",+  [config_dirs] = ""/etc/xdg/"",+  [data_dirs] = ""/usr/local/share/:/usr/share/"",+};+#endif++static const char *get_xdg(XDGDirType idx)+{+  const char *env = xdg_env_vars[idx];+  const char *fallback = xdg_defaults[idx];++  const char *ret = os_getenv(env);+  if (!ret && fallback) {+    ret = (const char *)expand_env_save((char_u *)fallback);+  }++  return ret;+}++static const char *get_xdg_home(XDGDirType idx)+{+  const char *dir = get_xdg(idx);+  if (dir) {+    dir = (const char *)concat_fnames(dir, ""nvim"", true);+  }+  return dir;+}++static void create_dir(const char *dir, int mode, const char *suffix)+{+  char *failed;+  if (!os_mkdir_recurse(dir, mode, &failed)) {+    // TODO: Create a folder in $TMPDIR instead","Maybe, but right now what I have in mind is that this function will be tailored to create data,cache and runtime dirs. Let us revisit this later.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3198,37446499,2015-08-19T18:01:07Z,src/nvim/os/stdpaths.c,"@@ -0,0 +1,88 @@+#include ""nvim/os/os.h""+#include ""nvim/strings.h""+#include ""nvim/path.h""+#include ""nvim/garray.h""++typedef enum {+  config_home,",Style guide requires naming this like `kXDGConfigHome`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3178,37453223,2015-08-19T18:54:59Z,test/functional/ex_cmds/cd_spec.lua,"@@ -0,0 +1,95 @@+-- Specs for :cd, :tcd, :lcd++local helpers = require('test.functional.helpers')+local nvim, execute, eq, clear, eval, feed =+  helpers.nvim, helpers.execute, helpers.eq, helpers.clear, helpers.eval, helpers.feed++describe(':cd :tcd', function()+  before_each(clear)++  --it('sets to local directory for the program, tabs and windows', function()+    local wd = function()+      return eval('getcwd()')+    end++    -- Test both spellings: cd and chdir+    -- Their variants differ in prefix (none, 't' and 'l')+    for _, cmd in ipairs({'cd', 'chdir'}) do+      describe('*' .. cmd, function()+        it('works', function()+          -- Store the initial working directory+          local globalDir = wd()++          -- Make tree of directories+          local directories = {+            {name = 'lua_test_dir_1', children =  {","(By the way, I highly suggest using names which are unique to the test. Does not matter now, but I hope in the future test files will be run in different processes or threads; my actions though will not help if tests in the same file are run in parallel though.)Specifically I use something like `Xtest-functional-ex_cmds-cd_spec.1`. This also helps to identify test responsible for some leftovers.",
116258,steveno,https://api.github.com/repos/neovim/neovim/pulls/3204,37521518,2015-08-20T12:06:03Z,src/nvim/cursor_shape.c,"@@ -85,18 +85,18 @@ char_u *parse_shape_opt(int what)             len = 1;           else             len = 2;-          if (len == 1 && TOLOWER_ASC(modep[0]) == 'a')++          if (len == 1 && TOLOWER_ASC(modep[0]) == 'a') {             all_idx = SHAPE_IDX_COUNT - 1;-          else {+          } else {             for (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)-              if (STRNICMP(modep, shape_table[idx].name, len)-                  == 0)+              if (STRNICMP(modep, shape_table[idx].name, len) == 0)                 break;-            if (idx == SHAPE_IDX_COUNT-                || (shape_table[idx].used_for & what) == 0)+          +	    if (idx == SHAPE_IDX_COUNT || (shape_table[idx].used_for & what) == 0)               return (char_u *)N_(""E546: Illegal mode"");-            if (len == 2 && modep[0] == 'v' && modep[1] == 'e')-              found_ve = TRUE;+	    if ((len = 2 && modep[0] == 'v' && modep[1] == 'e'))",The extra parens weren't from the lint; they were from GCC actually. The compiler told me that the statement was ambiguous.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3198,37531493,2015-08-20T13:57:09Z,src/nvim/version.c,"@@ -1007,21 +1007,7 @@ void list_version(void)   version_msg(SYS_VIMRC_FILE);   version_msg(""\""\n""); #endif  // ifdef SYS_VIMRC_FILE-#ifdef USR_VIMRC_FILE-  version_msg(_(""     user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE-#ifdef USR_VIMRC_FILE2-  version_msg(_("" 2nd user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE2);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE2-#ifdef USR_VIMRC_FILE3-  version_msg(_("" 3rd user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE3);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE3+  version_msg(_(""     user vimrc file: $XDG_CONFIG_HOME/nvim/init.vim\n""));","I think that this comment is useless. Previously ���* vimrc file��� was included because there _could_ be some differences that depend on compile-time options. Now there can���t be any differences, so this sentence is not needed.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3198,37532455,2015-08-20T14:05:11Z,src/nvim/options.lua,"@@ -2567,7 +2567,7 @@ return {       vi_def=true,       expand=true,       varname='p_vdir',-      defaults={if_true={vi=macros('DFLT_VDIR')}}+      defaults={if_true={vi=''}}","I see that only `viewdir` is touched. Are there plans for other options from #78? Especially for &runtimepath.Don���t forget that for default &runtimepath value you may take code from my `pr-3120` branch:``` Patchdiff --git a/src/nvim/option.c b/src/nvim/option.cindex 9a375c0..f9b8924 100644--- a/src/nvim/option.c+++ b/src/nvim/option.c@@ -301,6 +301,148 @@ static char *(p_cot_values[]) = {""menu"", ""menuone"", ""longest"", ""preview"", # include ""option.c.generated.h"" #endif+/// Count commas in the given string+static size_t count_commas(const char *const s, size_t len)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT+{+  size_t ret = 0;+  for (size_t i = 0; i < len; i++) {+    if (s[i] == ',') {+      ret++;+    }+  }+  return ret;+}++/// Append string with escaped commas+static char *strcpy_comma_escaped(char *dest, const char *src, const size_t len)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  size_t shift = 0;+  for (size_t i = 0; i < len; i++) {+    if (src[i] == ',') {+      dest[i + shift++] = '\\';+    }+    dest[i + shift] = src[i];+  }+  return &dest[len + shift];+}++/// Set &runtimepath to default value+static void set_runtimepath_default(void)+{+  size_t rtp_size = 0;+  char *const data_home = vim_getenv(""XDG_DATA_HOME"");+  char *const config_home = vim_getenv(""XDG_CONFIG_HOME"");+  char *const vimruntime = vim_getenv(""VIMRUNTIME"");+  char *const data_dirs = vim_getenv(""XDG_DATA_DIRS"");+  char *const config_dirs = vim_getenv(""XDG_CONFIG_DIRS"");+#define NVIM_SIZE (sizeof(""/nvim"") - 1)+#define SITE_SIZE (sizeof(""/site"") - 1)+#define AFTER_SIZE (sizeof(""/after"") - 1)+  size_t data_len;+  size_t config_len;+  size_t vimruntime_len;+  if (data_home != NULL) {+    data_len = strlen(data_home);+    rtp_size += ((data_len + count_commas(data_home, data_len)+                  + NVIM_SIZE + SITE_SIZE) * 2 + AFTER_SIZE) + 2;+  }+  if (config_home != NULL) {+    config_len = strlen(config_home);+    rtp_size += ((config_len + count_commas(config_home, config_len)+                  + NVIM_SIZE) * 2 + AFTER_SIZE) + 2;+  }+  if (vimruntime != NULL) {+    vimruntime_len = strlen(vimruntime);+    rtp_size += vimruntime_len + count_commas(vimruntime, vimruntime_len) + 1;+  }+#define COMPUTE_COLON_LEN(rtp_size, additional_size, val) \+  do { \+    if (val != NULL) { \+      const void *iter = NULL; \+      do { \+        size_t dir_len; \+        const char *dir; \+        iter = vim_colon_env_iter(val, iter, &dir, &dir_len); \+        if (dir != NULL && dir_len > 0) { \+          rtp_size += ((dir_len + count_commas(dir, dir_len) \+                        + NVIM_SIZE + additional_size) * 2 \+                       + AFTER_SIZE) + 2; \+        } \+      } while (iter != NULL); \+    } \+  } while (0)+  COMPUTE_COLON_LEN(rtp_size, SITE_SIZE, data_dirs);+  COMPUTE_COLON_LEN(rtp_size, 0, config_dirs);+#undef COMPUTE_COLON_LEN+  if (rtp_size == 0) {+    return;+  }+  // All additions were including comma.+  rtp_size--;+  char *const rtp = xmallocz(rtp_size);+  char *rtp_cur = rtp;+#define ADD_STRING(tgt, src, len) \+  tgt = strcpy_comma_escaped(tgt, src, len)+#define ADD_STATIC_STRING(tgt, src) \+  do { memmove(tgt, src, sizeof(src) - 1); tgt += sizeof(src) - 1; } while (0)+#define ADD_COLON_DIRS(tgt, val, suffix, revsuffix) \+  do { \+    if (val != NULL) { \+      const void *iter = NULL; \+      do { \+        size_t dir_len; \+        const char *dir; \+        iter = vim_colon_env_iter##revsuffix(val, iter, &dir, &dir_len); \+        if (dir != NULL && dir_len > 0) { \+          ADD_STRING(rtp_cur, dir, dir_len); \+          ADD_STATIC_STRING(rtp_cur, ""/nvim"" suffix "",""); \+        } \+      } while (iter != NULL); \+    } \+  } while (0)+  if (config_home != NULL) {+    ADD_STRING(rtp_cur, config_home, config_len);+    ADD_STATIC_STRING(rtp_cur, ""/nvim,"");+  }+  ADD_COLON_DIRS(rtp_cur, config_dirs, """", );+  if (data_home != NULL) {+    ADD_STRING(rtp_cur, data_home, data_len);+    ADD_STATIC_STRING(rtp_cur, ""/nvim/site,"");+  }+  ADD_COLON_DIRS(rtp_cur, data_dirs, ""/site"", );+  if (vimruntime != NULL) {+    ADD_STRING(rtp_cur, vimruntime, vimruntime_len);+    *rtp_cur++ = ',';+  }+  ADD_COLON_DIRS(rtp_cur, data_dirs, ""/site/after"", _rev);+  if (data_home != NULL) {+    ADD_STRING(rtp_cur, data_home, data_len);+    ADD_STATIC_STRING(rtp_cur, ""/nvim/site/after,"");+  }+  ADD_COLON_DIRS(rtp_cur, config_dirs, ""/after"", _rev);+  if (config_home != NULL) {+    ADD_STRING(rtp_cur, config_home, config_len);+    ADD_STATIC_STRING(rtp_cur, ""/nvim/after"");+  } else {+    // Strip trailing comma.+    rtp[rtp_size] = NUL;+  }+#undef ADD_COLON_DIRS+#undef ADD_STATIC_STRING+#undef ADD_STRING+#undef NVIM_SIZE+#undef SITE_SIZE+#undef AFTER_SIZE+  set_string_default(""runtimepath"", (char_u *)rtp);+  xfree(data_dirs);+  xfree(config_dirs);+  xfree(data_home);+  xfree(config_home);+  xfree(vimruntime);+}+ /*  * Initialize the options, first part.  *@@ -437,6 +579,10 @@ void set_init_1(void)       ""system('lpr' . (&printdevice == '' ? '' : ' -P' . &printdevice) . ' ' . v:fname_in) . delete(v:fname_in) + v:shell_error""       );+  // Set default for &runtimepath. All necessary expansions are performed in +  // this function.+  set_runtimepath_default();+   /*    * Set all the options (except the terminal options) to their default    * value.  Also set the global value for local options.diff --git a/src/nvim/os/env.c b/src/nvim/os/env.cindex 7be8a86..e47a63b 100644--- a/src/nvim/os/env.c+++ b/src/nvim/os/env.c@@ -415,6 +415,74 @@ static char *remove_tail(char *p, char *pend, char *name)   return pend; }+/// Iterate over colon-separated list+///+/// @note Environment variables must not be modified during iteration.+///+/// @param[in]   val   Value of the environment variable to iterate over.+/// @param[in]   iter  Pointer used for iteration. Must be NULL on first+///                    iteration.+/// @param[out]  dir   Location where pointer to the start of the current+///                    directory name should be saved. May be set to NULL.+/// @param[out]  len   Location where current directory length should be saved.+///+/// @return Next iter argument value or NULL when iteration should stop.+const void *vim_colon_env_iter(const char *const val,+                               const void *const iter,+                               const char **const dir,+                               size_t *const len)+  FUNC_ATTR_NONNULL_ARG(1,3,4) FUNC_ATTR_WARN_UNUSED_RESULT+{+  const char *varval = (const char *) iter;+  if (varval == NULL) {+    varval = val;+  }+  *dir = varval;+  const char *const dirend = strchr(varval, ':');+  if (dirend == NULL) {+    *len = strlen(varval);+    return NULL;+  } else {+    *len = (size_t) (dirend - varval);+    return dirend + 1;+  }+}++/// Iterate over colon-separated list in reverse order+///+/// @note Environment variables must not be modified during iteration.+///+/// @param[in]   val   Value of the environment variable to iterate over.+/// @param[in]   iter  Pointer used for iteration. Must be NULL on first+///                    iteration.+/// @param[out]  dir   Location where pointer to the start of the current+///                    directory name should be saved. May be set to NULL.+/// @param[out]  len   Location where current directory length should be saved.+///+/// @return Next iter argument value or NULL when iteration should stop.+const void *vim_colon_env_iter_rev(const char *const val,+                                   const void *const iter,+                                   const char **const dir,+                                   size_t *const len)+  FUNC_ATTR_NONNULL_ARG(1,3,4) FUNC_ATTR_WARN_UNUSED_RESULT+{+  const char *varend = (const char *) iter;+  if (varend == NULL) {+    varend = val + strlen(val) - 1;+  }+  const size_t varlen = (size_t) (varend - val) + 1;+  const char *const colon = xmemrchr(val, ':', varlen);+  if (colon == NULL) {+    *len = varlen;+    *dir = val;+    return NULL;+  } else {+    *dir = colon + 1;+    *len = (size_t) (varend - colon);+    return colon - 1;+  }+}+ /// Vim's version of getenv(). /// Special handling of $HOME, $VIM and $VIMRUNTIME, allowing the user to /// override the vim runtime directory at runtime.  Also does ACP to 'enc'```, just replace `vim_getenv` calls.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3207,37577703,2015-08-20T20:33:10Z,test/functional/legacy/059_utf8_spell_checking_spec.lua,"@@ -0,0 +1,953 @@+-- Tests for spell checking with 'encoding' set to ""utf-8"".++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect+local write_file = helpers.write_file++describe(""spell checking with 'encoding' set to utf-8"", function()+  setup(function()+    clear()+    execute(""syntax off"")+    -- This file should be encoded in ISO8859-1.","Both base64 and `\x??` (in lua) are ways to specify _binary_ data.  Base64 might be more effective (fewer text bytes per binary bytes), but in both cases the encoding would be equally ""manual"".an alternative, if that happens to work, might be change to `SET UTF-8\n` and just store the text as utf-8. (Edit: or store it as utf-8 in the lua file and convert it on writing to latin-1, if we happen to consider loading latin-1 spell definition as part of the feature being tested)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3207,37578375,2015-08-20T20:39:57Z,test/functional/legacy/059_utf8_spell_checking_spec.lua,"@@ -0,0 +1,953 @@+-- Tests for spell checking with 'encoding' set to ""utf-8"".++local helpers = require('test.functional.helpers')+local feed, insert, source = helpers.feed, helpers.insert, helpers.source+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect+local write_file = helpers.write_file++describe(""spell checking with 'encoding' set to utf-8"", function()+  setup(function()+    clear()+    execute(""syntax off"")+    -- This file should be encoded in ISO8859-1.","> Both base64 and \x?? (in lua) are ways to specify binary data. Base64 might be more effective (fewer text bytes per binary bytes), but in both cases the encoding would be equally ""manual"".Ah okay, my mistake.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3193,37607404,2015-08-21T05:24:01Z,scripts/vim-patch.sh,"@@ -36,17 +36,22 @@ check_executable() { }  get_vim_sources() {-  check_executable hg+  check_executable git    echo ""Retrieving Vim sources.""   if [[ ! -d ${VIM_SOURCE_DIR} ]]; then     echo ""Cloning Vim sources into '${VIM_SOURCE_DIR}'.""-    hg clone https://code.google.com/p/vim ""${VIM_SOURCE_DIR}""+    git clone https://github.com/vim/vim.git ""${VIM_SOURCE_DIR}""",`git clone --depth=1000` is probably reasonable. Not sure if it saves much space though.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3193,37607422,2015-08-21T05:25:04Z,scripts/vim-patch.sh,"@@ -64,17 +64,17 @@ assign_commit_details() {   if [[ ${1} =~ [0-9]\.[0-9]\.[0-9]{3,4} ]]; then     # Interpret parameter as version number.     vim_version=""${1}""-    vim_commit=""v${1//./-}""+    vim_commit=""v${1}""     local strip_commit_line=true-    vim_commit_url=""https://github.com/vim/vim/commit/${vim_commit}""+    vim_commit_url=""https://github.com/vim/vim/tree/${vim_commit}""","Yeah that's weird, it used to work on the old tryout repo. Maybe github changed something.However `commits` works and shows the list of commits. That might be a bit more obvious to people following the link.",
44155,jwhitley,https://api.github.com/repos/neovim/neovim/pulls/3193,37607601,2015-08-21T05:32:33Z,scripts/vim-patch.sh,"@@ -36,17 +36,22 @@ check_executable() { }  get_vim_sources() {-  check_executable hg+  check_executable git    echo ""Retrieving Vim sources.""   if [[ ! -d ${VIM_SOURCE_DIR} ]]; then     echo ""Cloning Vim sources into '${VIM_SOURCE_DIR}'.""-    hg clone https://code.google.com/p/vim ""${VIM_SOURCE_DIR}""+    git clone https://github.com/vim/vim.git ""${VIM_SOURCE_DIR}""","It saves ~20M space, and it almost halves the clone time.  Added in next commit.",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/3185,37686794,2015-08-21T23:19:51Z,cmake/RunLint.cmake,"@@ -1,18 +1,27 @@-get_filename_component(LINT_DIR ${LINT_DIR} ABSOLUTE)-get_filename_component(LINT_PREFIX ${LINT_DIR} PATH)+get_filename_component(LINT_DIR ""${LINT_DIR}"" ABSOLUTE)+get_filename_component(LINT_PREFIX ""${LINT_DIR}"" PATH)","It's not that it's less reliable, it's just that if you get in the habit of always wrapping in quotes, then you may accidentally turn a list into a semicolon-separated string of the entries.  Just blindly wrapping all variable expansions in quotes will lead to that problem.  As a result, I believe it's better to add them when needed (which is rare), and leave them off otherwise.  Not only to avoid the habit, but so that other contributors don't end up having that issue too when they mimic what was done.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3193,37692786,2015-08-22T05:20:11Z,scripts/vim-patch.sh,"@@ -162,22 +167,17 @@ list_vim_patches() {   # runtime patches before between 384 and 442 have already been ported   # to Neovim as of the creation of this script.   local vim_commits=$(cd ""${VIM_SOURCE_DIR}"" && \-    hg log --removed --template='{if(startswith(""Added tag"", firstline(desc)),-      ""{latesttag}\n"",-      ""{if(startswith(\""updated for version\"", firstline(desc)),-        \""\"",-        \""{node}\n\"")}"")}' -r tip:v7-4-442)+    git log --pretty='tformat:%H|%d' v7.4.442..HEAD | awk -f ${NEOVIM_SOURCE_DIR}/scripts/vim-patch-helper.awk)",Not sure if you saw https://github.com/neovim/neovim/pull/3193#issuecomment-133289081 .What does this list look like? Is it different than `git tag --contains v7.4.442` ?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3193,37692794,2015-08-22T05:20:49Z,scripts/vim-patch.sh,"@@ -162,22 +167,17 @@ list_vim_patches() {   # runtime patches before between 384 and 442 have already been ported   # to Neovim as of the creation of this script.   local vim_commits=$(cd ""${VIM_SOURCE_DIR}"" && \-    hg log --removed --template='{if(startswith(""Added tag"", firstline(desc)),-      ""{latesttag}\n"",-      ""{if(startswith(\""updated for version\"", firstline(desc)),-        \""\"",-        \""{node}\n\"")}"")}' -r tip:v7-4-442)+    git log --pretty='tformat:%H|%d' v7.4.442..HEAD | awk -f ${NEOVIM_SOURCE_DIR}/scripts/vim-patch-helper.awk)+   # Append remaining vim patches.   # Start from 7.4.160, where Neovim was forked.   local vim_old_commits=$(cd ""${VIM_SOURCE_DIR}"" && \-    hg log --removed --template='{if(startswith(""Added tag"",-      firstline(desc)),-      ""{latesttag}\n"")}' -r v7-4-442:v7-4-161)+    git log --pretty='tformat:%d' v7.4.160..v7.4.442 | awk '{ if ($1 != """") { gsub(/[()]/, """", $2); print($2); } }')",What does this list look like?,
44155,jwhitley,https://api.github.com/repos/neovim/neovim/pulls/3193,37697172,2015-08-22T16:25:40Z,scripts/vim-patch.sh,"@@ -162,22 +167,17 @@ list_vim_patches() {   # runtime patches before between 384 and 442 have already been ported   # to Neovim as of the creation of this script.   local vim_commits=$(cd ""${VIM_SOURCE_DIR}"" && \-    hg log --removed --template='{if(startswith(""Added tag"", firstline(desc)),-      ""{latesttag}\n"",-      ""{if(startswith(\""updated for version\"", firstline(desc)),-        \""\"",-        \""{node}\n\"")}"")}' -r tip:v7-4-442)+    git log --pretty='tformat:%H|%d' v7.4.442..HEAD | awk -f ${NEOVIM_SOURCE_DIR}/scripts/vim-patch-helper.awk)+   # Append remaining vim patches.   # Start from 7.4.160, where Neovim was forked.   local vim_old_commits=$(cd ""${VIM_SOURCE_DIR}"" && \-    hg log --removed --template='{if(startswith(""Added tag"",-      firstline(desc)),-      ""{latesttag}\n"")}' -r v7-4-442:v7-4-161)+    git log --pretty='tformat:%d' v7.4.160..v7.4.442 | awk '{ if ($1 != """") { gsub(/[()]/, """", $2); print($2); } }')","See https://gist.github.com/e26aba8e38f56d02a6f8 the output of this and the other similar git log line.For this line in particular, IIRC the point was that with the runtime reintegration, the tests for whether non-patch runtime revs had been integrated didn't really work.  So for the older revs the idea was to extract only the tag/patch names and leave off pulling the non-patch commit hashes.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,37704689,2015-08-23T10:40:20Z,runtime/doc/starting.txt,"@@ -915,62 +914,59 @@ The viminfo file is used to store: - The buffer list. - Global variables. -The viminfo file is not supported when the |+viminfo| feature has been-disabled at compile time.--You could also use a Session file.  The difference is that the viminfo file+You could also use a Session file.  The difference is that the ShaDa file does not depend on what you are working on.  There normally is only one-viminfo file.  Session files are used to save the state of a specific editing+ShaDa file.  Session files are used to save the state of a specific editing Session.  You could have several Session files, one for each project you are-working on.  Viminfo and Session files together can be used to effectively+working on.  ShaDa and Session files together can be used to effectively enter Vim and directly start working in your desired setup. |session-file| -							*viminfo-read*-When Vim is started and the 'viminfo' option is non-empty, the contents of-the viminfo file are read and the info can be used in the appropriate places.+							*shada-read*+When Vim is started and the 'shada' option is non-empty, the contents of+the ShaDa file are read and the info can be used in the appropriate places. The |v:oldfiles| variable is filled.  The marks are not read in at startup-(but file marks are).  See |initialization| for how to set the 'viminfo'+(but file marks are).  See |initialization| for how to set the 'shada' option upon startup. -							*viminfo-write*-When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo-file (it's actually merged with the existing one, if one exists).  The-'viminfo' option is a string containing information about what info should be-stored, and contains limits on how much should be stored (see 'viminfo').+							*shada-write*+When Vim exits and 'shada' is non-empty, the info is stored in the ShaDa file +(it's actually merged with the existing one, if one exists |shada-merging|).  +The 'shada' option is a string containing information about what info should +be stored, and contains limits on how much should be stored (see 'shada').  Notes for Unix:-- The file protection for the viminfo file will be set to prevent other users+- The file protection for the ShaDa file will be set to prevent other users   from being able to read it, because it may contain any text or commands that   you have worked with.-- If you want to share the viminfo file with other users (e.g. when you ""su""+- If you want to share the ShaDa file with other users (e.g. when you ""su""   to another user), you can make the file writable for the group or everybody.-  Vim will preserve this when writing new viminfo files.  Be careful, don't-  allow just anybody to read and write your viminfo file!-- Vim will not overwrite a viminfo file that is not writable by the current+  Vim will preserve this when writing new ShaDa files.  Be careful, don't+  allow just anybody to read and write your ShaDa file!+- Vim will not overwrite a ShaDa file that is not writable by the current",There is a error in this case. Though specifically in this case it does not write to a temporary file: these permissions are checked prior to opening a temporary file.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,37706109,2015-08-23T14:05:21Z,runtime/doc/starting.txt,"@@ -915,62 +914,59 @@ The viminfo file is used to store: - The buffer list. - Global variables. -The viminfo file is not supported when the |+viminfo| feature has been-disabled at compile time.--You could also use a Session file.  The difference is that the viminfo file+You could also use a Session file.  The difference is that the ShaDa file does not depend on what you are working on.  There normally is only one-viminfo file.  Session files are used to save the state of a specific editing+ShaDa file.  Session files are used to save the state of a specific editing Session.  You could have several Session files, one for each project you are-working on.  Viminfo and Session files together can be used to effectively+working on.  ShaDa and Session files together can be used to effectively enter Vim and directly start working in your desired setup. |session-file| -							*viminfo-read*-When Vim is started and the 'viminfo' option is non-empty, the contents of-the viminfo file are read and the info can be used in the appropriate places.+							*shada-read*+When Vim is started and the 'shada' option is non-empty, the contents of+the ShaDa file are read and the info can be used in the appropriate places. The |v:oldfiles| variable is filled.  The marks are not read in at startup-(but file marks are).  See |initialization| for how to set the 'viminfo'+(but file marks are).  See |initialization| for how to set the 'shada' option upon startup. -							*viminfo-write*-When Vim exits and 'viminfo' is non-empty, the info is stored in the viminfo-file (it's actually merged with the existing one, if one exists).  The-'viminfo' option is a string containing information about what info should be-stored, and contains limits on how much should be stored (see 'viminfo').+							*shada-write*+When Vim exits and 'shada' is non-empty, the info is stored in the ShaDa file +(it's actually merged with the existing one, if one exists |shada-merging|).  +The 'shada' option is a string containing information about what info should +be stored, and contains limits on how much should be stored (see 'shada').  Notes for Unix:-- The file protection for the viminfo file will be set to prevent other users+- The file protection for the ShaDa file will be set to prevent other users   from being able to read it, because it may contain any text or commands that   you have worked with.-- If you want to share the viminfo file with other users (e.g. when you ""su""+- If you want to share the ShaDa file with other users (e.g. when you ""su""   to another user), you can make the file writable for the group or everybody.-  Vim will preserve this when writing new viminfo files.  Be careful, don't-  allow just anybody to read and write your viminfo file!-- Vim will not overwrite a viminfo file that is not writable by the current+  Vim will preserve this when writing new ShaDa files.  Be careful, don't+  allow just anybody to read and write your ShaDa file!+- Vim will not overwrite a ShaDa file that is not writable by the current","> I tried again with e287807, but I still see no E137 when using vimrc. I see the error for read only file main.shada when using nvim -u NONE and exiting or using :wsh.I see this error even when using```bin/nvim -u NONE --cmd 'set nomore shortmess=filmnrwxaoOstTWAlc noshowcmd cmdheight=10' -c qa```(used every advice from :h hit-enter which is supposed to allow you to avoid some hit-enter prompts). Using your vimrc makes no difference. I have only it, default plugins and plugins listed in that vimrc installed.I would highly suggest to reduce the vimrc. YCM is rather bold and configurable. I installed it from scratch with `./install --clang-completer --system-libclang --system-boost`.> ���> Reply to this email directly or view it on GitHub.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3198,37708873,2015-08-23T18:00:32Z,src/nvim/os/stdpaths.c,"@@ -0,0 +1,100 @@+#include ""nvim/os/os.h""+#include ""nvim/strings.h""+#include ""nvim/path.h""+#include ""nvim/garray.h""++typedef enum {+  kConfigHome,+  kDataHome,+  kCacheHome,+  kRuntimeDir,+  kConfigDirs,+  kDataDirs,+} XDGDirType;++static const char *xdg_env_vars[] = {+  [kConfigHome] = ""XDG_CONFIG_HOME"",+  [kDataHome] = ""XDG_DATA_HOME"",+  [kCacheHome] = ""XDG_CACHE_HOME"",+  [kRuntimeDir] = ""XDG_RUNTIME_DIR"",+  [kConfigDirs] = ""XDG_CONFIG_DIRS"",+  [kDataDirs] = ""XDG_DATA_DIRS"",+};++static const char *const xdg_defaults[] = {+  // Windows, Apple stuff are just shims right now+#ifdef WIN32+  // Windows+#elif APPLE+  // Apple (this includes iOS, which we might need to handle differently)+  [kConfigHome] = ""~/Library/Preferences"",+  [kDataHome] = ""~/Library/Application Support"",+  [kCacheHome] = ""~/Library/Caches"",+  [kRuntimeDir] = ""~/Library/Application Support"",+  [kConfigDirs] = ""/Library/Application Support"",+  [kDataDirs] = ""/Library/Application Support"",+#else+  // Linux, BSD, CYGWIN+  [kConfigHome] = ""~/.config"",+  [kDataHome] = ""~/.local/share"",+  [kCacheHome] = ""~/.cache"",+  [kRuntimeDir] = """",+  [kConfigDirs] = ""/etc/xdg/"",+  [kDataDirs] = ""/usr/local/share/:/usr/share/"",+};+#endif++static const char *get_xdg(XDGDirType idx)+{+  const char *env = xdg_env_vars[idx];+  const char *fallback = xdg_defaults[idx];++  const char *ret = os_getenv(env);+  if (!ret && fallback) {+    ret = (const char *)expand_env_save((char_u *)fallback);+  }++  return ret;","This returns statically allocated memory when `os_getenv(env)` returns non-null, and heap-allocated memory when it returns null and `fallback` isn't null. How does the caller know whether the return value requires an `xfree()`? We could add a parameter, `bool *must_free`, but it may be simpler to always return allocated memory.``` cconst char *ret = os_getenv(env);if (ret) {  ret = xstrdup(ret);} else if (fallback) {  // ... same as before}```",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3224,37717796,2015-08-24T03:53:47Z,src/nvim/os/fs.c,"@@ -114,17 +114,19 @@ bool os_can_exe(const char_u *name, char_u **abspath) static bool is_executable(const char_u *name)   FUNC_ATTR_NONNULL_ALL {+#ifdef WIN32+    // Windows does not have an executable bit.+    // Instead check if the file exists and is readable.+    return os_file_is_readable((char *) name);+#else",Yea. I just realized that after I pushed. :/Also there appears to be this weird problem with `uv_fs_access` on Windows where if you request anything but `W_OK` it short circuits and returns 0 without actually checking the file attributes which means `os_is_file_readable` always returns true even if the user doesn't have permission to access the given file. :(Personally I feel that's a bug in the libuv implementation so perhaps a libuv PR is in order?See: https://github.com/libuv/libuv/blob/df62b54aa2b3d916ca442ee84f0678129a848c4f/src/win/fs.c#L1346,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3227,37718711,2015-08-24T04:30:49Z,src/nvim/os/os_defs.h,"@@ -33,14 +33,7 @@ # define SIGDUMMYARG #endif -// On some systems, time.h should not be included together with sys/time.h.-#if !defined(HAVE_SYS_TIME_H) || defined(TIME_WITH_SYS_TIME)","This isn't checked in any other places, and we no longer use sys/time.h.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3241,37943771,2015-08-26T03:37:04Z,CMakeLists.txt,"@@ -68,7 +68,9 @@ set(CMAKE_EXPORT_COMPILE_COMMANDS ON) string(REPLACE ""-O3"" ""-O2"" CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS_RELEASE}"")  # Enable -Wconversion.-set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -Wconversion"")+if(NOT MSVC)+  set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -Wconversion"")","It might be because we whitelist which files get Wconversion applied. Might as well leave it, we can revisit after the whitelist is removed.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3243,37945192,2015-08-26T04:18:32Z,man/nvim.1,"@@ -140,7 +136,7 @@ Sets the options 'fkmap' and 'rightleft'. Hebrew mode. Sets the options 'hkmap' and 'rightleft'. .It Fl V Ns Oo Ar N Oc Ns Op Ar file-Verbose.+Be verbose.","suggest ""Verbose mode"", it has parallel form with ""Debugging mode"" and ""Recovery mode"".",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/3137,38069993,2015-08-27T07:49:47Z,CMakeLists.txt,"@@ -122,7 +130,6 @@ if(TRAVIS_CI_BUILD) endif()  if(CMAKE_COMPILER_IS_GNUCC)-  include(CheckCCompilerFlag)   check_c_compiler_flag(-Og HAS_OG_FLAG) else()   set(HAS_OG_FLAG 0)","Yes it was intentional, to keep from trigger bad behavior of some other compiler who might have a similar looking flag, but doesn't do the same thing.  Perhaps that's overly conservative, but I have no idea what other kinds of compilers we might need to support, so it seemed the safe thing to do.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3249,38151573,2015-08-27T22:01:17Z,config/config.h.in,"@@ -57,6 +57,8 @@ #cmakedefine USE_FNAME_CASE #define USEMAN_S 1 +#cmakedefine USE_CRNL","Oh wait, I should have read the cmake docs. It is dependent on the value from CMakeLists.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3256,38169982,2015-08-28T04:14:12Z,src/nvim/options.lua,"@@ -2000,7 +2000,11 @@ return {       vi_def=true,       expand=true,       varname='p_sh',-      defaults={if_true={vi=""sh""}}+      defaults={+        condition='WIN32',+	if_true={vi=""cmd.exe""},+	if_false={vi=""sh""}",`condition` isn't aligned.,
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3256,38170387,2015-08-28T04:31:05Z,src/nvim/options.lua,"@@ -2000,7 +2000,11 @@ return {       vi_def=true,       expand=true,       varname='p_sh',-      defaults={if_true={vi=""sh""}}+      defaults={+        condition='WIN32',+	if_true={vi=""cmd.exe""},+	if_false={vi=""sh""}",`condition` is aligned I think (two spaces) but the `if_` aren't (used a tab). Correct?,
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3256,38171134,2015-08-28T04:59:20Z,src/nvim/options.lua,"@@ -2000,7 +2000,11 @@ return {       vi_def=true,       expand=true,       varname='p_sh',-      defaults={if_true={vi=""sh""}}+      defaults={+        condition='WIN32',+	if_true={vi=""cmd.exe""},+	if_false={vi=""sh""}","Ok. I used all spaces in the updated diff.Spaces are my preference too. :)> On Aug 28, 2015, at 12:54 AM, Justin M. Keyes notifications@github.com wrote:> > In src/nvim/options.lua:> > > @@ -2000,7 +2000,11 @@ return {> >        vi_def=true,> >        expand=true,> >        varname='p_sh',> > -      defaults={if_true={vi=""sh""}}> > -      defaults={> > -        condition='WIN32',> > -   if_true={vi=""cmd.exe""},> > -   if_false={vi=""sh""}> >   We pretty much never use tabs for anything, though there might be some stragglers in some of our build scripts.> > ���> Reply to this email directly or view it on GitHub.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3262,38254234,2015-08-28T23:33:48Z,cmake/FindLuaJit.cmake,"@@ -32,8 +32,11 @@ if(LUAJIT_USE_STATIC) endif()  list(APPEND LUAJIT_NAMES luajit-5.1)+if(MSVC)+  list(APPEND LUAJIT_NAMES lua51)",Can anyone explain this change (and the similar one for libuv)?,
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3262,38254364,2015-08-28T23:36:31Z,cmake/FindLuaJit.cmake,"@@ -32,8 +32,11 @@ if(LUAJIT_USE_STATIC) endif()  list(APPEND LUAJIT_NAMES luajit-5.1)+if(MSVC)+  list(APPEND LUAJIT_NAMES lua51)",cc @equalsraf. All I know is that without this MSVC doesn't find the library. As for why it's that why I have not investigated.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3246,38261272,2015-08-29T11:24:05Z,src/nvim/tui/tui.c,"@@ -202,18 +126,94 @@ static void tui_stop(UI *ui)   }   xfree(data->write_loop);   unibi_destroy(data->ut);-  destroy_screen(data);+  ugrid_free(&data->grid);+  data->stop = true;","If I use `<CTRL-z>`, `tui_stop()` is called and I expected that `tui_main()` would exit at once (thread ends).For example, I don't see the message with the following patch until I use `fg`:``` diffdiff --git a/src/nvim/tui/tui.c b/src/nvim/tui/tui.cindex f678428..63a359e 100644--- a/src/nvim/tui/tui.c+++ b/src/nvim/tui/tui.c@@ -189,6 +189,7 @@ static void tui_main(UIBridgeData *bridge, UI *ui)   while (!data->stop) {     loop_poll_events(&tui_loop, -1);   }+  fprintf(stderr,""tui_main ends\n"");   loop_close(&tui_loop);   xfree(data);```Also program crashes when `fg` is used (here patch is not included).``` cProgram terminated with signal SIGABRT, Aborted.#0  0x00007f744a839a38 in raise () from /lib64/libc.so.6(gdb) bt#0  0x00007f744a839a38 in raise () from /lib64/libc.so.6#1  0x00007f744a83ae0a in abort () from /lib64/libc.so.6#2  0x000000000062abc7 in uv_mutex_lock (mutex=<optimized out>)    at /home/oni-link/git/neovim/.deps/build/src/libuv/src/unix/thread.c:120#3  0x000000000061d0bb in loop_schedule (loop=0x7f7449c528c0, event=...) at /home/oni-link/git/neovim/src/nvim/event/loop.c:62#4  0x0000000000618890 in tui_scheduler (event=..., d=0x7f744a03a2c0) at /home/oni-link/git/neovim/src/nvim/tui/tui.c:202#5  0x00000000004d8a8d in ui_bridge_put (b=0x7f744a024a80, text=0x7ffc4f5af790 "" "", size=1)    at /home/oni-link/git/neovim/src/nvim/ui_bridge.c:244#6  0x00000000005d0f44 in send_output (ptr=0x7ffc4f5af760) at /home/oni-link/git/neovim/src/nvim/ui.c:353#7  0x00000000005d0d46 in ui_puts (str=0x7ffc4f5af790 "" "") at /home/oni-link/git/neovim/src/nvim/ui.c:306#8  0x00000000005d0da0 in ui_putc (c=32 ' ') at /home/oni-link/git/neovim/src/nvim/ui.c:314#9  0x000000000049beba in screen_char (off=1223, row=8, col=135) at /home/oni-link/git/neovim/src/nvim/screen.c:5732#10 0x000000000049c3c4 in screen_fill (start_row=1, end_row=68, start_col=0, end_col=136, c1=126, c2=32, attr=6)    at /home/oni-link/git/neovim/src/nvim/screen.c:5865#11 0x0000000000490b2b in win_draw_end (wp=0x7f744a04e000, c1=126, c2=32, row=1, endrow=68, hl=HLF_EOB)    at /home/oni-link/git/neovim/src/nvim/screen.c:1648#12 0x00000000004904c1 in win_update (wp=0x7f744a04e000) at /home/oni-link/git/neovim/src/nvim/screen.c:1527#13 0x000000000048d5d4 in update_screen (type=40) at /home/oni-link/git/neovim/src/nvim/screen.c:419#14 0x000000000049f972 in screen_resize (width=136, height=70) at /home/oni-link/git/neovim/src/nvim/screen.c:7279#15 0x00000000005d04fd in ui_refresh () at /home/oni-link/git/neovim/src/nvim/ui.c:142#16 0x00000000005ba2dc in ex_stop (eap=0x7ffc4f5afb60) at /home/oni-link/git/neovim/src/nvim/ex_docmd.c:5937#17 0x00000000005b1a5c in do_one_cmd (cmdlinep=0x7ffc4f5afc80, sourcing=1, cstack=0x7ffc4f5afd90, fgetline=0x0, cookie=0x0)    at /home/oni-link/git/neovim/src/nvim/ex_docmd.c:2195#18 0x00000000005ae5df in do_cmdline (cmdline=0x69fd5e ""st"", fgetline=0x0, cookie=0x0, flags=11)    at /home/oni-link/git/neovim/src/nvim/ex_docmd.c:621#19 0x00000000005adc5d in do_cmdline_cmd (cmd=0x69fd5e ""st"") at /home/oni-link/git/neovim/src/nvim/ex_docmd.c:293#20 0x00000000005661ee in nv_suspend (cap=0x7ffc4f5b0300) at /home/oni-link/git/neovim/src/nvim/normal.c:6011#21 0x000000000055a9b5 in normal_cmd (oap=0x7ffc4f5b03a0, toplevel=true) at /home/oni-link/git/neovim/src/nvim/normal.c:912#22 0x0000000000553227 in main_loop (cmdwin=0, noexmode=0) at /home/oni-link/git/neovim/src/nvim/main.c:747#23 0x0000000000552be0 in main (argc=3, argv=0x7ffc4f5b0668) at /home/oni-link/git/neovim/src/nvim/main.c:534```",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3262,38262570,2015-08-29T14:34:57Z,cmake/FindLuaJit.cmake,"@@ -32,8 +32,11 @@ if(LUAJIT_USE_STATIC) endif()  list(APPEND LUAJIT_NAMES luajit-5.1)+if(MSVC)","No. @equalsraf's branch compiles on MinGW too which doesn't need this one.See equalsraf@bcd0579.To be honest I should probably squash equalsraf@94dcbe0, and equalsraf@bcd0579into this:```if(MSVC)  list(APPEND LUAJIT_NAMES lua51)elseif(MINGW)  list(APPEND LUAJIT_NAMES libluajit)else()  list(APPEND LUAJIT_NAMES luajit-5.1)endif()```Further for consistency with the rest of the build system if we want to check for Windows we do this: `if(WIN32)`.@justinmk in response to your earlier question I'm not sure why the library names are different but you can see that `third-party/cmake/BuildLuajit.cmake` and `third-party/cmake/BuildLibuv.cmake` is also using those library names. The MinGW support for `luajit` is in equalsraf@b95df5e.",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/810,38264770,2015-08-29T18:47:37Z,src/nvim/os/win_defs.h,"@@ -1,25 +1,88 @@ #ifndef NVIM_OS_WIN_DEFS_H #define NVIM_OS_WIN_DEFS_H +#include ""auto/config.h""++#ifndef LC_MESSAGES+// FIXME: this is a hack - also used in ex_cmds2.c+// to build in windows without libintl+# define LC_MESSAGES LC_COLLATE+#endif++// winsock2.h must be before windows.h - or so says Mingw+#include <winsock2.h> #include <windows.h>+// We have our own RGB macro in macros.h+#undef RGB++#include <io.h>+#include <uv.h>++#include <stdio.h>+#include <time.h>+#include <sys/stat.h>++// FIXME: this is only used by if_cscope.c+#ifndef S_ISLNK+# define S_ISLNK(mode) 0+#endif++// For MSVC+#ifdef _MSC_VER+# ifndef restrict+#  define restrict __restrict+# endif+# ifndef inline+#  define inline __inline+# endif+# ifndef __func__+#  define __func__ __FUNCTION__+# endif",Yes. For some reason `__func__` is defined when compiling in `C++` (compiler flag is `/TP`) mode but not in `C` (compiler flag is `/TC`) mode on MSVC.MSDN seems to indicate it should work since it's listed as an C99 predefined macro.See [here](https://msdn.microsoft.com/en-us/library/b0084kay.aspx).I opened a connect bug:https://connect.microsoft.com/VisualStudio/feedback/details/1729717we'll see what happens.In the meantime I suppose we will have to stick with our own definition.,
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/3229,38699739,2015-09-03T21:38:19Z,runtime/doc/editing.txt,"@@ -1236,29 +1244,50 @@ present in 'cpoptions' and ""!"" is not used in the command. 							*:chd* *:chdir* :chd[ir][!] [path]	Same as |:cd|. +							*:tc* *:tcd*+:tc[d][!] {path}        Like |:cd|, but set the current directory for the+                        current tab.  The current directory for other tabs+                        or the local directory of windows in this tab is not+                        changed, except for the current window.++							*:tcd-*+:tcd[!] -		Change to the previous current directory (before the+			previous "":tcd {path}"" command).++							*:tch* *:tchdir*+:tch[dir][!]		Same as |:tcd|.+ 							*:lc* *:lcd* :lc[d][!] {path}	Like |:cd|, but only set the current directory for the 			current window.  The current directory for other-			windows is not changed.+			windows or any tabs is not changed.","@HiPhish Vim script has bitwise operators, implemented as functions called ��� `and()`, `or()` and `xor()`. I kid you not. Anyway, as you pointed out, this might introduce some odd bugs in non-Neovim aware scripts testing the return value of `haslocaldir()`, as leveraging implicit Boolean coercion is a pervasive bad practice in Vim script.",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3229,38708583,2015-09-03T23:30:46Z,runtime/doc/editing.txt,"@@ -1236,29 +1244,50 @@ present in 'cpoptions' and ""!"" is not used in the command. 							*:chd* *:chdir* :chd[ir][!] [path]	Same as |:cd|. +							*:tc* *:tcd*+:tc[d][!] {path}        Like |:cd|, but set the current directory for the+                        current tab.  The current directory for other tabs+                        or the local directory of windows in this tab is not+                        changed, except for the current window.++							*:tcd-*+:tcd[!] -		Change to the previous current directory (before the+			previous "":tcd {path}"" command).++							*:tch* *:tchdir*+:tch[dir][!]		Same as |:tcd|.+ 							*:lc* *:lcd* :lc[d][!] {path}	Like |:cd|, but only set the current directory for the 			current window.  The current directory for other-			windows is not changed.+			windows or any tabs is not changed.","@kopischke OK, I'm not surprised, I just didn't know. I never used VimScript outside of the usual `.vimrc` settings, and it doesn't help that the language has a huge standard library and more edge cases than a stairway. Is there book to recommend? I read _The VimL Primer_ by Benjamin Klein, but it's really just an introduction, something that should be the first two chapters of a much larger book.@justinmk And what if yet another scope gets added in the future? Off the top of my head I could imagine a UI managing several instances of NeoVim and we would need an `:icd` command. Then the unified `haslocaldir()` would need to return a three-bit number:```0b000 ""global0b001 ""window0b010 ""tab0b011 ""window & tab0b100 ""instance0b101 ""instance & window0b110 ""instance & tab0b111 ""instance & tab & window```So plugin authors would have to update their plugins _again_. Whereas if they `AND` the result with `1` it will work for all eternity.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/3309,38939286,2015-09-08T15:25:02Z,src/nvim/path.c,"@@ -2080,8 +2080,14 @@ static int path_get_absolute_path(const char_u *fname, char_u *buf, int len, int   // expand it if forced or not an absolute path   if (force || !path_is_absolute_path(fname)) {     if ((p = vim_strrchr(fname, '/')) != NULL) {-      STRNCPY(relative_directory, fname, p-fname);-      relative_directory[p-fname] = NUL;+      if (p == fname) {+        // relative to root","I didn't explain well, this path is executed if there's only one component AND it's relative to root",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3318,38983843,2015-09-08T21:39:47Z,CMakeLists.txt,"@@ -47,21 +47,29 @@ if(NOT CMAKE_BUILD_TYPE) endif()  # Version tokens-include(GetGitRevisionDescription)-get_git_head_revision(GIT_REFSPEC NVIM_VERSION_COMMIT)-if(NOT NVIM_VERSION_COMMIT)-  set(NVIM_VERSION_COMMIT ""?"")-endif() set(NVIM_VERSION_MAJOR 0)-set(NVIM_VERSION_MINOR 0)+set(NVIM_VERSION_MINOR 1) set(NVIM_VERSION_PATCH 0) set(NVIM_VERSION_PRERELEASE ""-alpha"")-# TODO(justinmk): UTC time would be nice here #1071-git_timestamp(GIT_TIMESTAMP)-# TODO(justinmk): do not set this for ""release"" builds #1071","I think I have changed my mind on this, unless others object. If git _is_ available, I don't see why _not_ collect a SHA and list it in `:version`.",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/3318,38984423,2015-09-08T21:45:00Z,CMakeLists.txt,"@@ -47,21 +47,29 @@ if(NOT CMAKE_BUILD_TYPE) endif()  # Version tokens-include(GetGitRevisionDescription)-get_git_head_revision(GIT_REFSPEC NVIM_VERSION_COMMIT)-if(NOT NVIM_VERSION_COMMIT)-  set(NVIM_VERSION_COMMIT ""?"")-endif() set(NVIM_VERSION_MAJOR 0)-set(NVIM_VERSION_MINOR 0)+set(NVIM_VERSION_MINOR 1) set(NVIM_VERSION_PATCH 0) set(NVIM_VERSION_PRERELEASE ""-alpha"")-# TODO(justinmk): UTC time would be nice here #1071-git_timestamp(GIT_TIMESTAMP)-# TODO(justinmk): do not set this for ""release"" builds #1071","For almost any packaged version of Neovim, this would be ""?"", though, as the tarballs don't include a `.git` directory. Maybe we could change it to hide this line from `:version` if we can't detect a revision.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3318,38984613,2015-09-08T21:46:42Z,CMakeLists.txt,"@@ -47,21 +47,29 @@ if(NOT CMAKE_BUILD_TYPE) endif()  # Version tokens-include(GetGitRevisionDescription)-get_git_head_revision(GIT_REFSPEC NVIM_VERSION_COMMIT)-if(NOT NVIM_VERSION_COMMIT)-  set(NVIM_VERSION_COMMIT ""?"")-endif() set(NVIM_VERSION_MAJOR 0)-set(NVIM_VERSION_MINOR 0)+set(NVIM_VERSION_MINOR 1) set(NVIM_VERSION_PATCH 0) set(NVIM_VERSION_PRERELEASE ""-alpha"")-# TODO(justinmk): UTC time would be nice here #1071-git_timestamp(GIT_TIMESTAMP)-# TODO(justinmk): do not set this for ""release"" builds #1071",> Maybe we could change it to hide this line from :version if we can't detect a revision.:+1:,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3319,39006176,2015-09-09T04:22:27Z,src/nvim/CMakeLists.txt,"@@ -234,6 +234,11 @@ list(APPEND NVIM_LINK_LIBRARIES     ${CMAKE_THREAD_LIBS_INIT}     ) +if(WIN32)+  # libuv needs these+  list(APPEND NVIM_LINK_LIBRARIES iphlpapi psapi userenv ws2_32)+endif(WIN32)","I think the place for this is in `cmake/FindLibUV.cmake`. It defines `LIBUV_LIBRARIES` (which is later used to build `NVIM_LINK_LIBRARIES` on line 225, above). Another nice thing about `FindLibUV.cmake` is that it calls `check_library_exists()` and then defines appropriate `HAVE_LIB` symbols.If possible we should continue following the example @jszakmeister set.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3315,39006640,2015-09-09T04:35:06Z,src/nvim/api/buffer.c,"@@ -467,7 +467,7 @@ void buffer_insert(Buffer buffer,                    ArrayOf(String) lines,                    Error *err) {-  buffer_set_line_slice(buffer, lnum, lnum, false, true, lines, err);+  buffer_set_line_slice(buffer, lnum, lnum, true, false, lines, err);",As I mentioned in https://github.com/neovim/neovim/pull/2846 I think `include_start`/`include_end` parameters shouldn't exist at all. Thanks for the bug fix in the meantime.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3307,39007230,2015-09-09T04:52:34Z,third-party/CMakeLists.txt,"@@ -22,6 +22,8 @@ option(USE_BUNDLED_MSGPACK ""Use the bundled msgpack."" ${USE_BUNDLED}) option(USE_BUNDLED_LUAJIT ""Use the bundled version of luajit."" ${USE_BUNDLED}) option(USE_BUNDLED_LUAROCKS ""Use the bundled version of luarocks."" ${USE_BUNDLED}) +option(ALLOW_EXISTING_SRC_DIR ""Skip download of deps sources in case of existing source directory."" OFF)",Suggest naming it `USE_EXISTING_SRC_DIR` for parallel form with the `USE_BUNDLED_` family.,
286080,alkino,https://api.github.com/repos/neovim/neovim/pulls/3297,39017047,2015-09-09T08:17:12Z,src/nvim/move.c,"@@ -1345,20 +1309,15 @@ void scroll_cursor_top(int min_scroll, int always)   new_topline = top + 1;    /* count filler lines of the cursor window as context */-  i = diff_check_fill(curwin, curwin->w_cursor.lnum);-  used += i;-  extra += i;+  int extra = diff_check_fill(curwin, curwin->w_cursor.lnum);+  used += extra;","So.i is here only for a temporary var that is equal to extra. Why? Look, extra is initialized during declaration to 0.extra += i => extra = extra + i => extra = 0 + i => extra = iIf you look some lines below, you can see that i is set at the beginning of while. So the value of i here is not used anymore. I find it more readable (imho)""extra"" is ""diff_check_fill"" and we add it to ""used""than ""i"" is ""diff_check_fill"" and add it to ""extra"" and ""used""",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/3307,39018367,2015-09-09T08:35:26Z,third-party/cmake/DownloadAndExtractFile.cmake,"@@ -22,7 +22,7 @@ set(SRC_DIR ${PREFIX}/src/${TARGET})  # Check whether the source has been downloaded. If true, skip it. # Useful for external downloads like homebrew.-if(EXISTS ""${SRC_DIR}"" AND IS_DIRECTORY ""${SRC_DIR}"")+if(ALLOW_EXISTING_SRC_DIR AND EXISTS ""${SRC_DIR}"" AND IS_DIRECTORY ""${SRC_DIR}"")","Kind of. This prevents that running `make deps` automatically builds updated dependencies. You can test it locally by changing some dependency version. CMake detects that CMakeLists has been changed, but it won't download the new version as the old source directory is still there.Another problem with the cache is that it only stored the compiled output. As we don't know when a dependency has been updated and we have to re-run CMake, now I just cache the whole build directory and always run CMake. This makes the amount of cached data larger, though.We could store only the compiled output and do something with timestamps, maybe compare the cache marker timestamp with the one from third-party/CMakeLists.txt and just rebuild everything if that has changed.. but I'm not sure if that would be such a good idea.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3319,39103348,2015-09-09T22:09:16Z,cmake/FindLibUV.cmake,"@@ -89,6 +99,16 @@ if(HAVE_LIBSENDFILE)   list(APPEND LIBUV_LIBRARIES sendfile) endif() +check_library_exists(userenv GetUserProfileDirectoryW ""userenv.h"" HAVE_LIBUSERENV)+if(HAVE_LIBUSERENV)+  list(APPEND LIBUV_LIBRARIES userenv)+endif()++check_library_exists(ws2_32 WSAStartup ""winsock2.h"" HAVE_LIBWS232)+if(HAVE_LIBWS232)+  list(APPEND LIBUV_LIBRARIES ws2_32)+endif()",For grouping purposes it's probably still a good idea to wrap your changes here in one big `if(MSVC) ...` block. It will help us to keep Windows-specific changes in isolated blocks as much as possible.,
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/3309,39261216,2015-09-11T11:03:32Z,src/nvim/search.c,"@@ -653,7 +653,7 @@ int searchit(               }               if (matchcol == 0 && (options & SEARCH_START))                 break;-              if (ptr[matchcol] == NUL+              if (STRLEN(ptr) <= (size_t)matchcol || ptr[matchcol] == NUL","Did you see the comment below(at `ml_get_buf`)? Even though it is theoretically getting the same line, is it guaranteed that `ptr` will point to the same string? I'd rather not optimize this prematurely and risk introducing bugs, especially because vim is too complex and hard to have its state predicted after a non-trivial function is called(`vim_regexec_multi`)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3321,39324090,2015-09-11T22:18:46Z,src/nvim/api/buffer.c,"@@ -467,7 +467,13 @@ void buffer_insert(Buffer buffer,                    ArrayOf(String) lines,                    Error *err) {-  buffer_set_line_slice(buffer, lnum, lnum, true, false, lines, err);+  linenr_T nlines = buffer_line_count(buffer, err);","Use `Integer` here, not `linenr_T`. Otherwise you will need one (here) or two (here and in condition) casts to pass travis tests. Also note that `buffer_set_line_slice` accepts Integer as well, though I think it will not complain because `sizeof(Integer) >= sizeof(linenr_T)` always.And I think that you need to abort if `buffer_line_count` returned zero (== aborted with error, but checking for `err->set` is rather uncommon for some reason).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3339,39346893,2015-09-13T11:41:26Z,src/nvim/buffer.c,"@@ -3062,25 +3040,26 @@ build_stl_str_hl (       s++;       continue;     }-    opt = *s++;+    char_u opt = *s++;      /* OK - now for the real work */-    base = 'D';-    itemisflag = FALSE;-    fillable = TRUE;-    num = -1;-    str = NULL;+    char_u base = 'D';+    bool itemisflag = false;+    bool fillable = true;+    long num = -1;+    char_u *str = NULL;     switch (opt) {     case STL_FILEPATH:     case STL_FULLPATH:     case STL_FILENAME:-      fillable = FALSE;         /* don't change ' ' to fillchar */-      if (buf_spname(wp->w_buffer) != NULL)+    {+      fillable = false;         /* don't change ' ' to fillchar */+      if (buf_spname(wp->w_buffer) != NULL) {         STRLCPY(NameBuff, buf_spname(wp->w_buffer), MAXPATHL);-      else {-        t = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname-            : wp->w_buffer->b_fname;-        home_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);","@war1025 Linter silences the errors for _blocks_ containing _three_ lines, line with the error in the middle. Should you change any of the lines in the block you need to also change adjacent lines.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3303,39463652,2015-09-15T00:29:17Z,src/nvim/os/env.c,"@@ -456,6 +456,15 @@ char *vim_getenv(const char *name)     if (p_hf != NULL && vim_strchr(p_hf, '$') == NULL) {       vim_path = (char *)p_hf;     }++#ifdef WIN32+    char exe_name[MAXPATHL];+    if (vim_path == NULL) {+      GetModuleFileName(NULL, exe_name, MAXPATHL);+      vim_path = exe_name;","In Vim: https://github.com/vim/vim/blob/ac360bf2ca293735fc7c6654dc2b3066f4c62488/src/os_win32.c#L357 it mentions that ""Maximum length of $PATH is more than MAXPATHL""--around 10x more. But MSDN uses MAXPATHL so whatever.Anyways libuv `uv_exepath` function looks useful, and it avoids problems with Unicode paths. There is `GetModuleFileNameA` (ASCII) and `GetModuleFileNameW`, but we are calling `GetModuleFileName`, what does that do? libuv takes care of it for us.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3104,39679005,2015-09-16T20:14:25Z,runtime/ftplugin/vim.vim,"@@ -75,3 +75,6 @@ unlet s:cpo_save  "" removed this, because 'cpoptions' is a global option. "" setlocal cpo+=M		"" makes \%( match \)++"" Open the help file when pressing 'K'.+nnoremap <silent><buffer> K :exe 'help '.HelpTopic()<CR>",Note that without using autoloaded functions naming convention (i.e.��`autoload/path/to/file.vim` transforms into functions looking like `path#to#file#funcname`) all this code does is displaying E117 error.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3104,39680143,2015-09-16T20:24:12Z,runtime/autoload/help.vim,"@@ -0,0 +1,38 @@+function! s:synnames(...) abort+  if a:0+    let [line, col] = [a:1, a:2]+  else+    let [line, col] = [line('.'), col('.')]+  endif+  return reverse(map(synstack(line, col), 'synIDattr(v:val,""name"")'))+endfunction++function! HelpTopic()+  let col = col('.') - 1+  while col && getline('.')[col] =~# '\k'+    let col -= 1+  endwhile+  let pre = col == 0 ? '' : getline('.')[0 : col]+  let col = col('.') - 1+  while col && getline('.')[col] =~# '\k'+    let col += 1+  endwhile+  let post = getline('.')[col : -1]+  let syn = get(synnames(), 0, '')+  let cword = expand('<cword>')+  if syn ==# 'vimFuncName'",The entire function is for `.vim` files: this and the following conditions will never match in a help file. I think this needs to be altered: topic for functions should be opened if current word is immediately followed by a parenthesis in addition to `syn` check.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3104,39681319,2015-09-16T20:33:55Z,runtime/autoload/help.vim,"@@ -0,0 +1,38 @@+function! s:synnames(...) abort+  if a:0+    let [line, col] = [a:1, a:2]+  else+    let [line, col] = [line('.'), col('.')]+  endif+  return reverse(map(synstack(line, col), 'synIDattr(v:val,""name"")'))+endfunction++function! HelpTopic()+  let col = col('.') - 1+  while col && getline('.')[col] =~# '\k'+    let col -= 1+  endwhile+  let pre = col == 0 ? '' : getline('.')[0 : col]+  let col = col('.') - 1+  while col && getline('.')[col] =~# '\k'+    let col += 1+  endwhile+  let post = getline('.')[col : -1]+  let syn = get(synnames(), 0, '')+  let cword = expand('<cword>')+  if syn ==# 'vimFuncName'+    return cword.'()'+  elseif syn ==# 'vimOption'+    return ""'"".cword.""'""+  elseif syn ==# 'vimUserAttrbKey'+    return ':command-'.cword+  elseif pre =~# '^\s*:\=$'","Specifically for vim files open help with `:` if word happens to contain the first non-whitespace characters on the current line, or is preceded with `:` (there is a common convention to write `autocmd BufWritePre * :command`, same for some other complex commands like `:command` itself). Specifically for help files leave _only_ the condition that current word is preceded with a colon.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3353,39766950,2015-09-17T16:27:16Z,src/nvim/options.lua,"@@ -2525,11 +2525,7 @@ return {       type='number', scope={'global', 'buffer'},       vi_def=true,       varname='p_ul',-      defaults={-        condition={'!UNIX', '!WIN3264'},-        if_true={vi=100},-        if_false={vi=1000},-      }+      defaults={if_true={vi=1000}}",@ZyX-I Is `if_true` needed if there is no `condition`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3353,39767090,2015-09-17T16:28:38Z,runtime/doc/options.txt,"@@ -6580,46 +6504,10 @@ A jump table for the options with a short description can be found at |Q_op|. 	{not available when compiled without the |+statusline| feature}  				*'toolbar'* *'tb'*-'toolbar' 'tb'		string	(default ""icons,tooltips"")-			global-			{only for |+GUI_GTK|, |+GUI_Athena|, and |+GUI_Motif|}-	The contents of this option controls various toolbar settings.  The-	possible values are:-		icons		Toolbar buttons are shown with icons.-		text		Toolbar buttons shown with text.-		horiz		Icon and text of a toolbar button are-				horizontally arranged.  {only in GTK+ 2 GUI}-		tooltips	Tooltips are active for toolbar buttons.-	Tooltips refer to the popup help text which appears after the mouse-	cursor is placed over a toolbar button for a brief moment.--	If you want the toolbar to be shown with icons as well as text, do the-	following: >-		:set tb=icons,text-<	Motif and Athena cannot display icons and text at the same time.  They-	will show icons if both are requested.--	If none of the strings specified in 'toolbar' are valid or if-	'toolbar' is empty, this option is ignored.  If you want to disable-	the toolbar, you need to set the 'guioptions' option.  For example: >-		:set guioptions-=T-<	Also see |gui-toolbar|.+'toolbar' 'tb'		Removed. |vim-differences| {Nvim}  						*'toolbariconsize'* *'tbis'*-'toolbariconsize' 'tbis'	string	(default ""small"")-				global-				{only in the GTK+ 2 GUI}-	Controls the size of toolbar icons.  The possible values are:-		tiny		Use tiny toolbar icons.-		small		Use small toolbar icons (default).-		medium		Use medium-sized toolbar icons.-		large		Use large toolbar icons.-	The exact dimensions in pixels of the various icon sizes depend on-	the current theme.  Common dimensions are large=32x32, medium=24x24,-	small=20x20 and tiny=16x16.--	If 'toolbariconsize' is empty, the global default size as determined-	by user preferences or the current theme is used.+'toolbariconsize' 'tbis'	Removed. |vim-differences| {Nvim}","Need to list this (and `'toolbar'`) in `vim_diff.txt`, in the ""Removed features"" section.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3229,39858400,2015-09-18T14:12:01Z,src/nvim/eval.c,"@@ -9442,22 +9442,71 @@ static void f_getcmdwintype(typval_T *argvars, typval_T *rettv)   rettv->vval.v_string[0] = cmdwin_type; } -/*- * ""getcwd()"" function- */+/// `getcwd('s')` function+///+/// @pre The type of the argument `s` must be a string or nothing. static void f_getcwd(typval_T *argvars, typval_T *rettv) {-  char_u      *cwd;+  assert(argvars->v_type == VAR_STRING || argvars->v_type == VAR_UNKNOWN);++  char_u *cwd = NULL;+  char_u *scp = argvars->vval.v_string;  // scope    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;+   cwd = xmalloc(MAXPATHL);-  if (os_dirname(cwd, MAXPATHL) != FAIL) {-    rettv->vval.v_string = vim_strsave(cwd);+  cwd[0] = '\0';  // initialize to empty string++  // If there is no argument return the current working directory.+  // This is the same behaviour as in Vim.+  //+  // Also if global is requested and the current working directory is the+  // global one.+  if (argvars->v_type == VAR_UNKNOWN || (!globaldir && scp[0] == 'g')) {+    if (os_dirname(cwd, MAXPATHL) != FAIL) {+      goto done;+    } else {+      goto end;+    }+  }++  char_u *from = NULL;  // The original string to copy++  switch (scp[0]) {  // only check the first character+    case 'g':  // global+      from = globaldir;+      break;+    case 't':  // tab+      from = curtab->localdir;+      break;+    case 'w':  // window+      from = curwin->w_localdir;+      break;+    default:+      EMSG(""E740: valid arguments are either 't' or 'w' or nothing."");+      break;+  }++  if (!from) {+    goto done;+  }+  // Copy the `from` string+  for (int i = 0; i < MAXPATHL; ++i) {+    cwd[i] = from[i];+    if (from[i] == '\0') {+      goto done;+    }+  }+  // If we made it through the loop the string was too large for copying+  goto end;++done:+  rettv->vval.v_string = vim_strsave(cwd);",Here we could use `cwd` instead of `vim_strsave(cwd)`. No need to duplicate the string again.The `goto end;` further up could be replaced with an error message and `xfree(cwd);return;`.,
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3229,39859415,2015-09-18T14:22:11Z,src/nvim/eval.c,"@@ -9442,22 +9442,71 @@ static void f_getcmdwintype(typval_T *argvars, typval_T *rettv)   rettv->vval.v_string[0] = cmdwin_type; } -/*- * ""getcwd()"" function- */+/// `getcwd('s')` function+///+/// @pre The type of the argument `s` must be a string or nothing. static void f_getcwd(typval_T *argvars, typval_T *rettv) {-  char_u      *cwd;+  assert(argvars->v_type == VAR_STRING || argvars->v_type == VAR_UNKNOWN);++  char_u *cwd = NULL;+  char_u *scp = argvars->vval.v_string;  // scope    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;+   cwd = xmalloc(MAXPATHL);-  if (os_dirname(cwd, MAXPATHL) != FAIL) {-    rettv->vval.v_string = vim_strsave(cwd);+  cwd[0] = '\0';  // initialize to empty string++  // If there is no argument return the current working directory.+  // This is the same behaviour as in Vim.+  //+  // Also if global is requested and the current working directory is the+  // global one.+  if (argvars->v_type == VAR_UNKNOWN || (!globaldir && scp[0] == 'g')) {+    if (os_dirname(cwd, MAXPATHL) != FAIL) {+      goto done;+    } else {+      goto end;+    }+  }++  char_u *from = NULL;  // The original string to copy++  switch (scp[0]) {  // only check the first character+    case 'g':  // global+      from = globaldir;+      break;+    case 't':  // tab+      from = curtab->localdir;+      break;+    case 'w':  // window+      from = curwin->w_localdir;+      break;+    default:+      EMSG(""E740: valid arguments are either 't' or 'w' or nothing."");+      break;+  }++  if (!from) {+    goto done;+  }+  // Copy the `from` string+  for (int i = 0; i < MAXPATHL; ++i) {+    cwd[i] = from[i];+    if (from[i] == '\0') {+      goto done;+    }+  }","Is it safe to use that function with `char_u` instead of `char`? What if a character is above `127`? That's why I wrote the loop instead of using the usual library functions. Also, what's the deal with these `x`-functions, where do they come from?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3229,39860935,2015-09-18T14:35:41Z,src/nvim/eval.c,"@@ -9442,22 +9442,71 @@ static void f_getcmdwintype(typval_T *argvars, typval_T *rettv)   rettv->vval.v_string[0] = cmdwin_type; } -/*- * ""getcwd()"" function- */+/// `getcwd('s')` function+///+/// @pre The type of the argument `s` must be a string or nothing. static void f_getcwd(typval_T *argvars, typval_T *rettv) {-  char_u      *cwd;+  assert(argvars->v_type == VAR_STRING || argvars->v_type == VAR_UNKNOWN);++  char_u *cwd = NULL;+  char_u *scp = argvars->vval.v_string;  // scope    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;+   cwd = xmalloc(MAXPATHL);-  if (os_dirname(cwd, MAXPATHL) != FAIL) {-    rettv->vval.v_string = vim_strsave(cwd);+  cwd[0] = '\0';  // initialize to empty string++  // If there is no argument return the current working directory.+  // This is the same behaviour as in Vim.+  //+  // Also if global is requested and the current working directory is the+  // global one.+  if (argvars->v_type == VAR_UNKNOWN || (!globaldir && scp[0] == 'g')) {+    if (os_dirname(cwd, MAXPATHL) != FAIL) {+      goto done;+    } else {+      goto end;+    }+  }++  char_u *from = NULL;  // The original string to copy++  switch (scp[0]) {  // only check the first character+    case 'g':  // global+      from = globaldir;+      break;+    case 't':  // tab+      from = curtab->localdir;+      break;+    case 'w':  // window+      from = curwin->w_localdir;+      break;+    default:+      EMSG(""E740: valid arguments are either 't' or 'w' or nothing."");+      break;+  }++  if (!from) {+    goto done;+  }+  // Copy the `from` string+  for (int i = 0; i < MAXPATHL; ++i) {+    cwd[i] = from[i];+    if (from[i] == '\0') {+      goto done;+    }+  }","We cast between `char_u` and `char` all the time, we even have a macro `STRLCPY` that hides the cast. So it should be safe. Also see `os_dirname()` where we get the pathname as a `char` array, but save it in a `char_u` array.`x`-functions are our implementation of the functions without a `x` (see `memory.c`) that uses our memory allocation functions. ",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3229,39861125,2015-09-18T14:37:20Z,src/nvim/eval.c,"@@ -9442,22 +9442,71 @@ static void f_getcmdwintype(typval_T *argvars, typval_T *rettv)   rettv->vval.v_string[0] = cmdwin_type; } -/*- * ""getcwd()"" function- */+/// `getcwd('s')` function+///+/// @pre The type of the argument `s` must be a string or nothing. static void f_getcwd(typval_T *argvars, typval_T *rettv) {-  char_u      *cwd;+  assert(argvars->v_type == VAR_STRING || argvars->v_type == VAR_UNKNOWN);++  char_u *cwd = NULL;+  char_u *scp = argvars->vval.v_string;  // scope    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;+   cwd = xmalloc(MAXPATHL);-  if (os_dirname(cwd, MAXPATHL) != FAIL) {-    rettv->vval.v_string = vim_strsave(cwd);+  cwd[0] = '\0';  // initialize to empty string++  // If there is no argument return the current working directory.+  // This is the same behaviour as in Vim.+  //+  // Also if global is requested and the current working directory is the+  // global one.+  if (argvars->v_type == VAR_UNKNOWN || (!globaldir && scp[0] == 'g')) {+    if (os_dirname(cwd, MAXPATHL) != FAIL) {+      goto done;+    } else {+      goto end;+    }+  }++  char_u *from = NULL;  // The original string to copy++  switch (scp[0]) {  // only check the first character+    case 'g':  // global+      from = globaldir;+      break;+    case 't':  // tab+      from = curtab->localdir;+      break;+    case 'w':  // window+      from = curwin->w_localdir;+      break;+    default:+      EMSG(""E740: valid arguments are either 't' or 'w' or nothing."");+      break;+  }++  if (!from) {+    goto done;+  }+  // Copy the `from` string+  for (int i = 0; i < MAXPATHL; ++i) {+    cwd[i] = from[i];+    if (from[i] == '\0') {+      goto done;+    }+  }+  // If we made it through the loop the string was too large for copying+  goto end;++done:+  rettv->vval.v_string = vim_strsave(cwd);","The original code did duplicate the string and free the original, so I just imitated it, don't blame me :P",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3229,39878260,2015-09-18T17:12:37Z,src/nvim/ex_docmd.c,"@@ -6816,7 +6840,7 @@ void post_chdir(int local)   /*- * "":cd"", "":lcd"", "":chdir"" and "":lchdir"".+ * "":cd"", "":tcd"", "":lcd"", "":chdir"", "":tchdir"" and "":lchdir"".","I have no idea how you managed to pass clint test (should break because multiline comment starts on the previous line and clint complains about ���complex multiline comments���), but this needs to be transformed into `///`.",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3229,39887069,2015-09-18T18:38:46Z,test/functional/ex_cmds/cd_spec.lua,"@@ -0,0 +1,101 @@+-- Specs for :cd, :tcd, :lcd and hastabdir(), haslocaldir()++local helpers = require('test.functional.helpers')+local execute, eq, clear, eval, feed =+  helpers.execute, helpers.eq, helpers.clear, helpers.eval, helpers.feed+++-- These directories will be created for testing+local directories = {+  'Xtest-functional-ex_cmds-cd_spec.1', -- Tab+  'Xtest-functional-ex_cmds-cd_spec.2', -- Window+  'Xtest-functional-ex_cmds-cd_spec.3', -- New global+}++-- Shorthand writing to get the current working directory+local  cwd = function() return eval('getcwd()'   ) end  -- working dir+local gcwd = function() return eval('getcwd(""g"")') end  -- global dir+local tcwd = function() return eval('getcwd(""t"")') end  -- tab dir+local wcwd = function() return eval('getcwd(""w"")') end  -- window dir++-- Test both the `cd` and `chdir` variants+for _, cmd in ipairs {'cd', 'chdir'} do+  describe(':*' .. cmd, function()+    before_each(function()+      clear()+      for _, d in ipairs(directories) do+        lfs.mkdir(d)+      end+    end)++    after_each(function()+      for _, d in ipairs(directories) do+        lfs.rmdir(d)+      end+    end)++    it('works', function()+      -- Store the initial working directory+      local globalDir = cwd()++      -- Create a new tab first and verify that is has the same working dir+      execute('tabnew')+      eq(globalDir, cwd())+      eq('', tcwd())  -- has neither tab- nor window-local directory+      eq('', wcwd())++      -- Change tab-local working directory and verify it is different+      execute('t' .. cmd .. ' ' .. directories[1])+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(cwd(), tcwd())  -- working directory maches tab directory+      eq(   '', wcwd())  -- still no window-directory++      -- Create a new window in this tab to test `:lcd`+      execute('new')+      eq(cwd(), tcwd())  -- Still tab-local working directory+      eq(   '', wcwd())  -- Still no window-local working directory+      eq(globalDir .. '/' .. directories[1], cwd())+      execute('l' .. cmd .. ' ../' .. directories[2])+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(                             cwd(), wcwd())++      -- Verify the first window still has the tab local directory+      execute('wincmd w')+      eq(globalDir .. '/' .. directories[1],  cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(                                '', wcwd())++      -- Change back to initial tab and verify working directory has stayed+      feed('gt')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())++      -- Verify global changes don't affect local ones+      execute('' .. cmd .. ' ' .. directories[3])+      eq(globalDir .. '/' .. directories[3], cwd())+      feed('gt')+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(globalDir .. '/' .. directories[1],  tcwd())+      eq(                                '', wcwd())++      -- Unless the global change happened in a tab with local directory+      execute('' .. cmd .. ' ..')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())+      -- Which also affects the first tab+      feed('gt')+      eq(globalDir, cwd())++      -- But not in a window with its own local directory+      feed('gt')+      execute('wincmd w')+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(                                '', tcwd())+      eq(globalDir .. '/' .. directories[2], wcwd())","How do I test for errors and how do I test for invalid argument types? For longer strings only the first character is evaluated, so one could write `getcwd('tashdfkh')` and it would act like `getcwd('t')`, the only precondition is that the argument is either a string or nothing. Is that bad practice?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3229,39888878,2015-09-18T18:55:21Z,test/functional/ex_cmds/cd_spec.lua,"@@ -0,0 +1,101 @@+-- Specs for :cd, :tcd, :lcd and hastabdir(), haslocaldir()++local helpers = require('test.functional.helpers')+local execute, eq, clear, eval, feed =+  helpers.execute, helpers.eq, helpers.clear, helpers.eval, helpers.feed+++-- These directories will be created for testing+local directories = {+  'Xtest-functional-ex_cmds-cd_spec.1', -- Tab+  'Xtest-functional-ex_cmds-cd_spec.2', -- Window+  'Xtest-functional-ex_cmds-cd_spec.3', -- New global+}++-- Shorthand writing to get the current working directory+local  cwd = function() return eval('getcwd()'   ) end  -- working dir+local gcwd = function() return eval('getcwd(""g"")') end  -- global dir+local tcwd = function() return eval('getcwd(""t"")') end  -- tab dir+local wcwd = function() return eval('getcwd(""w"")') end  -- window dir++-- Test both the `cd` and `chdir` variants+for _, cmd in ipairs {'cd', 'chdir'} do+  describe(':*' .. cmd, function()+    before_each(function()+      clear()+      for _, d in ipairs(directories) do+        lfs.mkdir(d)+      end+    end)++    after_each(function()+      for _, d in ipairs(directories) do+        lfs.rmdir(d)+      end+    end)++    it('works', function()+      -- Store the initial working directory+      local globalDir = cwd()++      -- Create a new tab first and verify that is has the same working dir+      execute('tabnew')+      eq(globalDir, cwd())+      eq('', tcwd())  -- has neither tab- nor window-local directory+      eq('', wcwd())++      -- Change tab-local working directory and verify it is different+      execute('t' .. cmd .. ' ' .. directories[1])+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(cwd(), tcwd())  -- working directory maches tab directory+      eq(   '', wcwd())  -- still no window-directory++      -- Create a new window in this tab to test `:lcd`+      execute('new')+      eq(cwd(), tcwd())  -- Still tab-local working directory+      eq(   '', wcwd())  -- Still no window-local working directory+      eq(globalDir .. '/' .. directories[1], cwd())+      execute('l' .. cmd .. ' ../' .. directories[2])+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(                             cwd(), wcwd())++      -- Verify the first window still has the tab local directory+      execute('wincmd w')+      eq(globalDir .. '/' .. directories[1],  cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(                                '', wcwd())++      -- Change back to initial tab and verify working directory has stayed+      feed('gt')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())++      -- Verify global changes don't affect local ones+      execute('' .. cmd .. ' ' .. directories[3])+      eq(globalDir .. '/' .. directories[3], cwd())+      feed('gt')+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(globalDir .. '/' .. directories[1],  tcwd())+      eq(                                '', wcwd())++      -- Unless the global change happened in a tab with local directory+      execute('' .. cmd .. ' ..')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())+      -- Which also affects the first tab+      feed('gt')+      eq(globalDir, cwd())++      -- But not in a window with its own local directory+      feed('gt')+      execute('wincmd w')+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(                                '', tcwd())+      eq(globalDir .. '/' .. directories[2], wcwd())",@HiPhish I use `exc_exec` function for this case: https://github.com/ZyX-I/neovim/blob/239de1f43326b3c0e818bd211472b24a49e35c49/test/functional/shada/helpers.lua#L45. Put it into the `test/functional/helpers.lua`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3229,39892872,2015-09-18T19:36:50Z,src/nvim/ex_docmd.c,"@@ -6816,7 +6840,7 @@ void post_chdir(int local)   /*- * "":cd"", "":lcd"", "":chdir"" and "":lchdir"".+ * "":cd"", "":tcd"", "":lcd"", "":chdir"", "":tchdir"" and "":lchdir"".","@HiPhish It should complain _because you changed the line adjacent to the comment start_. It does not care about _original_ comments, error suppresion works only as long as some line and its adjacent lines are not change.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3229,39909146,2015-09-18T22:56:49Z,test/functional/ex_cmds/cd_spec.lua,"@@ -0,0 +1,101 @@+-- Specs for :cd, :tcd, :lcd and hastabdir(), haslocaldir()++local helpers = require('test.functional.helpers')+local execute, eq, clear, eval, feed =+  helpers.execute, helpers.eq, helpers.clear, helpers.eval, helpers.feed+++-- These directories will be created for testing+local directories = {+  'Xtest-functional-ex_cmds-cd_spec.1', -- Tab+  'Xtest-functional-ex_cmds-cd_spec.2', -- Window+  'Xtest-functional-ex_cmds-cd_spec.3', -- New global+}++-- Shorthand writing to get the current working directory+local  cwd = function() return eval('getcwd()'   ) end  -- working dir+local gcwd = function() return eval('getcwd(""g"")') end  -- global dir+local tcwd = function() return eval('getcwd(""t"")') end  -- tab dir+local wcwd = function() return eval('getcwd(""w"")') end  -- window dir++-- Test both the `cd` and `chdir` variants+for _, cmd in ipairs {'cd', 'chdir'} do+  describe(':*' .. cmd, function()+    before_each(function()+      clear()+      for _, d in ipairs(directories) do+        lfs.mkdir(d)+      end+    end)++    after_each(function()+      for _, d in ipairs(directories) do+        lfs.rmdir(d)+      end+    end)++    it('works', function()+      -- Store the initial working directory+      local globalDir = cwd()++      -- Create a new tab first and verify that is has the same working dir+      execute('tabnew')+      eq(globalDir, cwd())+      eq('', tcwd())  -- has neither tab- nor window-local directory+      eq('', wcwd())++      -- Change tab-local working directory and verify it is different+      execute('t' .. cmd .. ' ' .. directories[1])+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(cwd(), tcwd())  -- working directory maches tab directory+      eq(   '', wcwd())  -- still no window-directory++      -- Create a new window in this tab to test `:lcd`+      execute('new')+      eq(cwd(), tcwd())  -- Still tab-local working directory+      eq(   '', wcwd())  -- Still no window-local working directory+      eq(globalDir .. '/' .. directories[1], cwd())+      execute('l' .. cmd .. ' ../' .. directories[2])+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(                             cwd(), wcwd())++      -- Verify the first window still has the tab local directory+      execute('wincmd w')+      eq(globalDir .. '/' .. directories[1],  cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(                                '', wcwd())++      -- Change back to initial tab and verify working directory has stayed+      feed('gt')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())++      -- Verify global changes don't affect local ones+      execute('' .. cmd .. ' ' .. directories[3])+      eq(globalDir .. '/' .. directories[3], cwd())+      feed('gt')+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(globalDir .. '/' .. directories[1],  tcwd())+      eq(                                '', wcwd())++      -- Unless the global change happened in a tab with local directory+      execute('' .. cmd .. ' ..')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())+      -- Which also affects the first tab+      feed('gt')+      eq(globalDir, cwd())++      -- But not in a window with its own local directory+      feed('gt')+      execute('wincmd w')",Can be `execute('tabnext | wicmd w')`. With `gt` replaced with `'tabnext'` you can remove `feed` function. With `tabnext` you can no longer import `feed` function.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3229,39935562,2015-09-20T22:18:18Z,test/functional/ex_cmds/cd_spec.lua,"@@ -0,0 +1,117 @@+-- Specs for :cd, :tcd, :lcd and getcwd()++local helpers = require('test.functional.helpers')+local execute, eq, clear, eval, exc_exec =+  helpers.execute, helpers.eq, helpers.clear, helpers.eval, helpers.exc_exec+++-- These directories will be created for testing+local directories = {+  'Xtest-functional-ex_cmds-cd_spec.1', -- Tab+  'Xtest-functional-ex_cmds-cd_spec.2', -- Window+  'Xtest-functional-ex_cmds-cd_spec.3', -- New global+}++-- Shorthand writing to get the current working directory+local  cwd = function() return eval('getcwd()'   ) end  -- working dir+local gcwd = function() return eval('getcwd(""g"")') end  -- global dir+local tcwd = function() return eval('getcwd(""t"")') end  -- tab dir+local wcwd = function() return eval('getcwd(""w"")') end  -- window dir++-- Test both the `cd` and `chdir` variants+for _, cmd in ipairs {'cd', 'chdir'} do+  describe(':*' .. cmd, function()+    before_each(function()+      clear()+      for _, d in ipairs(directories) do+        lfs.mkdir(d)+      end+    end)++    after_each(function()+      for _, d in ipairs(directories) do+        lfs.rmdir(d)+      end+    end)++    it('works', function()+      -- Store the initial working directory+      local globalDir = cwd()++      -- Create a new tab first and verify that is has the same working dir+      execute('tabnew')+      eq(globalDir, cwd())+      eq('', tcwd())  -- has neither tab- nor window-local directory+      eq('', wcwd())++      -- Change tab-local working directory and verify it is different+      execute('t' .. cmd .. ' ' .. directories[1])+      eq(globalDir .. '/' .. directories[1], cwd())+      eq(cwd(), tcwd())  -- working directory maches tab directory+      eq(''   , wcwd())  -- still no window-directory++      -- Create a new window in this tab to test `:lcd`+      execute('new')+      eq(cwd(), tcwd())  -- Still tab-local working directory+      eq(''   , wcwd())  -- Still no window-local working directory+      eq(globalDir .. '/' .. directories[1], cwd())+      execute('l' .. cmd .. ' ../' .. directories[2])+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(cwd()                             , wcwd())++      -- Verify the first window still has the tab local directory+      execute('wincmd w')+      eq(globalDir .. '/' .. directories[1],  cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(''                                , wcwd())++      -- Change back to initial tab and verify working directory has stayed+      execute('tabnext')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())++      -- Verify global changes don't affect local ones+      execute('' .. cmd .. ' ' .. directories[3])+      eq(globalDir .. '/' .. directories[3], cwd())+      execute('tabnext')+      eq(globalDir .. '/' .. directories[1],  cwd())+      eq(globalDir .. '/' .. directories[1], tcwd())+      eq(''                                , wcwd())++      -- Unless the global change happened in a tab with local directory+      execute('' .. cmd .. ' ..')+      eq(globalDir, cwd())+      eq('', tcwd())+      eq('', wcwd())+      -- Which also affects the first tab+      execute('tabnext')+      eq(globalDir, cwd())++      -- But not in a window with its own local directory+      execute('tabnext | wincmd w')+      eq(globalDir .. '/' .. directories[2], cwd())+      eq(''                                , tcwd())+      eq(globalDir .. '/' .. directories[2], wcwd())+    end)++    it('requires string argument', function()+    	-- eq('', eval('getcwd(1)'))+    	exc_exec('getcwd(1               )') -- Call with number","You may see correct example usage in #3359 which is now merged in master, specifically https://github.com/neovim/neovim/blob/2417aeebbffe58eab6ac39feac0f64a27aafbee2/test/functional/eval/msgpack_functions_spec.lua#L467-L496 may be copied here with minimal modifications:1. Replace ���fails to parse��� with ���fails when called with���.2. Replace ���fails to parse a string��� with test that checks for failing with lists.3. Replace all occurences of `msgpackparse` with `getcwd`.4. Replace entire E686 error message with whatever `getcwd` actually returns.Basically three `:s` commands and a manual edit.(BTW: #3359 existence is a good example why such tests are needed at all.)",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2506,40497322,2015-09-26T19:20:11Z,src/nvim/ex_getln.c,"@@ -4641,7 +4638,6 @@ int del_history_idx(int histype, int idx)     history[histype][i] = history[histype][j];     i = j;   }-  clear_hist_entry(&history[histype][i]);","We just removed entry `i` by copying entries with index [i+1,idx](modulo `hislen`) one field to the ""left"". Why is the entry with index `idx`(`==i`) not cleared anymore, it is now unused?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3318,40505690,2015-09-27T15:35:20Z,CMakeLists.txt,"@@ -71,6 +88,54 @@ set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # Default to -O2 on release builds. string(REPLACE ""-O3"" ""-O2"" CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS_RELEASE}"") +# Disable log for release-type builds.+if(NOT CMAKE_C_FLAGS_RELEASE MATCHES DDISABLE_LOG)+  set(CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS_RELEASE} -DDISABLE_LOG"")+endif()+if(NOT CMAKE_C_FLAGS_MINSIZEREL MATCHES DDISABLE_LOG)+  set(CMAKE_C_FLAGS_MINSIZEREL ""${CMAKE_C_FLAGS_MINSIZEREL} -DDISABLE_LOG"")+endif()+if(NOT CMAKE_C_FLAGS_RELWITHDEBINFO MATCHES DDISABLE_LOG)+  set(CMAKE_C_FLAGS_RELWITHDEBINFO ""${CMAKE_C_FLAGS_RELWITHDEBINFO} -DDISABLE_LOG"")+endif()++# Set build flags for custom Dev build type.+# -DNDEBUG purposely omitted because we want assertions.+if(MSVC)+  SET(CMAKE_C_FLAGS_DEV """"+      CACHE STRING ""Flags used by the compiler during development (optimized, but with debug info and logging) builds.""+      FORCE)+  SET(CMAKE_EXE_LINKER_FLAGS_DEV """"+      CACHE STRING ""Flags used for linking binaries during development (optimized, but with debug info and logging) builds.""+      FORCE)+  SET(CMAKE_SHARED_LINKER_FLAGS_DEV """"+      CACHE STRING ""Flags used by the shared libraries linker during development (optimized, but with debug info and logging) builds.""+      FORCE)+else()+  if(CMAKE_COMPILER_IS_GNUCC)+    check_c_compiler_flag(-Og HAS_OG_FLAG)+  else()+    set(HAS_OG_FLAG 0)+  endif()++  if(HAS_OG_FLAG)+    set(CMAKE_C_FLAGS_DEV ""-Og -g -DDISABLE_LOG""+        CACHE STRING ""Flags used by the compiler during development (optimized, but with debug info and logging) builds.""+        FORCE)+  else()+    set(CMAKE_C_FLAGS_DEV ""-O2 -g -DDISABLE_LOG""+        CACHE STRING ""Flags used by the compiler during development (optimized, but with debug info and logging) builds.""+        FORCE)+  endif()++  SET(CMAKE_EXE_LINKER_FLAGS_DEV """"+      CACHE STRING ""Flags used for linking binaries during development (optimized, but with debug info and logging) builds.""+      FORCE)+  SET(CMAKE_SHARED_LINKER_FLAGS_DEV """"+      CACHE STRING ""Flags used by the shared libraries linker during development (optimized, but with debug info and logging) builds.""",Can this code that is duplicated inside the `if(MSVC)` block be done outside the condition to avoid the duplicate code?,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/2506,40507736,2015-09-27T18:44:24Z,src/nvim/ex_getln.c,"@@ -4308,11 +4306,12 @@ in_history (       last_i = i;     }     history[type][i].hisnum = ++hisnum[type];-    history[type][i].viminfo = FALSE;     history[type][i].hisstr = str;-    return TRUE;+    history[type][i].timestamp = os_time();+    history[type][i].additional_elements = NULL;","We have to recreate the found entry in the last entry, but we only remember pointer `hisstr`.Is `additional_elements` always `NULL` for a history entry? Otherwise we need to remember this value too:``` diffdiff --git a/src/nvim/ex_getln.c b/src/nvim/ex_getln.cindex 88b9a21..f8e5c9c 100644--- a/src/nvim/ex_getln.c+++ b/src/nvim/ex_getln.c@@ -4299,6 +4299,7 @@ in_history (   if (last_i >= 0) {     str = history[type][i].hisstr;+    list_T* list = history[type][i].additional_elements;     while (i != hisidx[type]) {       if (++i >= hislen)         i = 0;@@ -4308,7 +4309,7 @@ in_history (     history[type][i].hisnum = ++hisnum[type];     history[type][i].hisstr = str;     history[type][i].timestamp = os_time();-    history[type][i].additional_elements = NULL;+    history[type][i].additional_elements = list;     return true;   }   return false;```But this change makes a test fail:```Failure ��� test/functional/shada/compatibility_spec.lua @ 346ShaDa forward compatibility support code works with history item with BOOL additional value in listtest/functional/shada/compatibility_spec.lua:368: Expected objects to be the same.Passed in:(number) 3Expected:(number) 2stack traceback:    test/functional/shada/compatibility_spec.lua:368: in function <test/functional/shada/compatibility_spec.lua:346>```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,40507836,2015-09-27T18:53:57Z,src/nvim/ex_getln.c,"@@ -4308,11 +4306,12 @@ in_history (       last_i = i;     }     history[type][i].hisnum = ++hisnum[type];-    history[type][i].viminfo = FALSE;     history[type][i].hisstr = str;-    return TRUE;+    history[type][i].timestamp = os_time();+    history[type][i].additional_elements = NULL;","@oni-link This is intentional. ���Moved��� entry is assumed to be semantically a new entry, so additional_elements list is not kept. I guess this code did not produce a memory leak only due to `garbagecollect()` calls and list becoming unreferenced due to history item being overwritten.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/2506,40508163,2015-09-27T19:15:38Z,src/nvim/ex_getln.c,"@@ -4308,11 +4306,12 @@ in_history (       last_i = i;     }     history[type][i].hisnum = ++hisnum[type];-    history[type][i].viminfo = FALSE;     history[type][i].hisstr = str;-    return TRUE;+    history[type][i].timestamp = os_time();+    history[type][i].additional_elements = NULL;","And because all lists are arranged in a linked list, so you will not ever have an unreferenced list. I will just add a `list_unref` call without any tests because I have no idea how to test this.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3042,40542749,2015-09-28T11:41:44Z,src/nvim/ex_cmds.c,"@@ -5289,9 +5288,13 @@ void ex_helptags(exarg_T *eap)   }    /* Get a list of all files in the help directory and in subdirectories. */-  STRCPY(NameBuff, dirname);+  STRLCPY(NameBuff, dirname, MAXPATHL);   add_pathsep((char *)NameBuff);","This function could use `strcat()` to add to `NameBuff` and overflow the array, right in the middle of all these ""safe"" functions.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3125,40588601,2015-09-28T18:39:42Z,src/nvim/ex_docmd.c,"@@ -9426,3 +9429,88 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  char_u *rtp_copy = vim_strsave(p_rtp);++  if (*eap->arg != NUL) {+    if (path_is_absolute_path(eap->arg)) {+      // full path: plug ~/.config/nvim/bundle/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, false);+    } else {  // spec: plug neovim/coolplugin+      // 'neovim/coolplugin' -> 'coolplugin'+      char_u *basename = vim_strsave(path_tail((char_u *)eap->arg));+      if (STRNCMP(basename, """", 1) != 0 && STRNCMP(p_plugindir, """", 1) != 0) {+        if (!path_is_absolute_path(p_plugindir)) {+          // we build a path using the first item in 'runtimepath'+          // this is usually '~/.config/nvim'+          char_u *user_vim = xmallocz(MAXPATHL);+          copy_option_part(&rtp_copy, user_vim, MAXPATHL, "","");+          if (STRNCMP(user_vim, """", 1) != 0) {+            path = concat_fnames(concat_fnames((char *)user_vim,+                                               (char *)p_plugindir, true),+                                 (char *)basename, true);+          }+          xfree(user_vim);+        }+        // either the path is not an absolute path, or &rtp is empty+        if (path == NULL) {+          path = concat_fnames((char *)p_plugindir, (char *)basename, true);+        }+      xfree(basename);+      }+    }++    if (path != NUL) {+      // 1. rebuild rtp+      if (STRNCMP(p_rtp, """", 1) == 0) {  // """" -> ""path""+        p_rtp = xrealloc(p_rtp, STRLEN(path) + 1);+        snprintf((char *)p_rtp, STRLEN(path) + 1, ""%s"", path);+      } else {+        int new_rtp_size;+        int match = 0;+        regmatch_T regmatch;+        regmatch.regprog = vim_regcomp((char_u *)"",[^,]\\+/after,"",+                                        RE_MAGIC | RE_STRING);+        regmatch.rm_ic = p_ic;+        if (regmatch.regprog != NULL) {+          match = vim_regexec(&regmatch, p_rtp, 0);+        }+        if (match) {+          // insert after the comma, ""p1,p1/after"" -> ""p1,p2,p1/after""+          int pos = (int)(regmatch.startp[0] - p_rtp + 1);+          char_u *head = xmallocz(pos);+          memcpy(head, p_rtp, pos);+          char_u *tail;+          tail = vim_strsave(p_rtp + pos);+          new_rtp_size = STRLEN(head) + STRLEN(path) + STRLEN(tail) + 3;+          p_rtp = xrealloc(p_rtp, new_rtp_size);+          snprintf((char *)p_rtp, new_rtp_size, ""%s%s,%s"", head, path, tail);+        } else {  // append, ""path1"" -> ""path1,path2""+          new_rtp_size = STRLEN(p_rtp) + STRLEN(path) + 2;+          p_rtp = xrealloc(p_rtp, new_rtp_size);+          snprintf((char *)p_rtp, new_rtp_size, ""%s,%s"", rtp_copy, path);+        }+        vim_regfree(regmatch.regprog);+      }++      // 2. source .vim files in the plugin/ folder of the bundle+      if (eap->forceit == true) {+        char_u *save_rtp = vim_strsave(p_rtp);+        p_rtp = (char_u *)path;+        source_runtime((char_u *)""plugin/**/*.vim"", true);+        p_rtp = save_rtp;+      }++      // 3. update v:plugins+      char ex_cmd[MAXPATHL * 2];+      snprintf(ex_cmd, sizeof(ex_cmd),+               "":let v:plugins['%s'] = { 'path': '%s' }"", eap->arg, path);","Yes, but that is _way_ more complicated; at least I couldn't figure out a way to build this dictionary of dictionaries. Since `v:plugins` is not readonly (and not because of this, but because it seems desirable to be able to modify v:plugins during runtime to attach more metadata to the entries), this seemed good enough. Anyway, hints would be appreciated.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,40590015,2015-09-28T18:50:58Z,src/nvim/ex_docmd.c,"@@ -9426,3 +9429,88 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  char_u *rtp_copy = vim_strsave(p_rtp);++  if (*eap->arg != NUL) {+    if (path_is_absolute_path(eap->arg)) {+      // full path: plug ~/.config/nvim/bundle/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, false);+    } else {  // spec: plug neovim/coolplugin+      // 'neovim/coolplugin' -> 'coolplugin'+      char_u *basename = vim_strsave(path_tail((char_u *)eap->arg));+      if (STRNCMP(basename, """", 1) != 0 && STRNCMP(p_plugindir, """", 1) != 0) {+        if (!path_is_absolute_path(p_plugindir)) {+          // we build a path using the first item in 'runtimepath'+          // this is usually '~/.config/nvim'+          char_u *user_vim = xmallocz(MAXPATHL);+          copy_option_part(&rtp_copy, user_vim, MAXPATHL, "","");+          if (STRNCMP(user_vim, """", 1) != 0) {+            path = concat_fnames(concat_fnames((char *)user_vim,+                                               (char *)p_plugindir, true),+                                 (char *)basename, true);+          }+          xfree(user_vim);+        }+        // either the path is not an absolute path, or &rtp is empty+        if (path == NULL) {+          path = concat_fnames((char *)p_plugindir, (char *)basename, true);+        }+      xfree(basename);+      }+    }++    if (path != NUL) {+      // 1. rebuild rtp+      if (STRNCMP(p_rtp, """", 1) == 0) {  // """" -> ""path""+        p_rtp = xrealloc(p_rtp, STRLEN(path) + 1);+        snprintf((char *)p_rtp, STRLEN(path) + 1, ""%s"", path);+      } else {+        int new_rtp_size;+        int match = 0;+        regmatch_T regmatch;+        regmatch.regprog = vim_regcomp((char_u *)"",[^,]\\+/after,"",+                                        RE_MAGIC | RE_STRING);+        regmatch.rm_ic = p_ic;+        if (regmatch.regprog != NULL) {+          match = vim_regexec(&regmatch, p_rtp, 0);+        }+        if (match) {+          // insert after the comma, ""p1,p1/after"" -> ""p1,p2,p1/after""+          int pos = (int)(regmatch.startp[0] - p_rtp + 1);+          char_u *head = xmallocz(pos);+          memcpy(head, p_rtp, pos);+          char_u *tail;+          tail = vim_strsave(p_rtp + pos);+          new_rtp_size = STRLEN(head) + STRLEN(path) + STRLEN(tail) + 3;+          p_rtp = xrealloc(p_rtp, new_rtp_size);+          snprintf((char *)p_rtp, new_rtp_size, ""%s%s,%s"", head, path, tail);+        } else {  // append, ""path1"" -> ""path1,path2""+          new_rtp_size = STRLEN(p_rtp) + STRLEN(path) + 2;+          p_rtp = xrealloc(p_rtp, new_rtp_size);+          snprintf((char *)p_rtp, new_rtp_size, ""%s,%s"", rtp_copy, path);+        }+        vim_regfree(regmatch.regprog);+      }++      // 2. source .vim files in the plugin/ folder of the bundle+      if (eap->forceit == true) {+        char_u *save_rtp = vim_strsave(p_rtp);+        p_rtp = (char_u *)path;+        source_runtime((char_u *)""plugin/**/*.vim"", true);+        p_rtp = save_rtp;+      }++      // 3. update v:plugins+      char ex_cmd[MAXPATHL * 2];+      snprintf(ex_cmd, sizeof(ex_cmd),+               "":let v:plugins['%s'] = { 'path': '%s' }"", eap->arg, path);","``` Cdict_T *const plugin_dict = dict_alloc();if (dict_add_nr_str(plugin_dict, ""path"", 0, path) == FAIL) {    assert(false);  // dict_add* fail when item with key ""path"" already exists, which must be false for an newly allocated dictionary.}dictitem_T *const plugdictitem = dictitem_alloc(eap->arg);plugdictitem->di_tv.v_lock = 0;plugdictitem->di_tv.v_type = VAR_DICT;plugdictitem->di_tv.vval.v_list = list;dict_T *const plugins = get_vim_var_dict(VV_PLUGINS);if (dict_add(plugins, plugdictitem) == FAIL) {    // Entry with key eap->arg was already added. Not sure what to do here, if it is needed to override dict item better to first use dict_find}```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3125,40590189,2015-09-28T18:52:25Z,src/nvim/ex_docmd.c,"@@ -9426,3 +9429,88 @@ static void ex_terminal(exarg_T *eap)     xfree(name);   } }++static void ex_plug(exarg_T *eap)+{+  char *path = NULL;+  char_u *rtp_copy = vim_strsave(p_rtp);++  if (*eap->arg != NUL) {+    if (path_is_absolute_path(eap->arg)) {+      // full path: plug ~/.config/nvim/bundle/coolplugin+      path = (char *)vim_strsave_fnameescape(eap->arg, false);+    } else {  // spec: plug neovim/coolplugin+      // 'neovim/coolplugin' -> 'coolplugin'+      char_u *basename = vim_strsave(path_tail((char_u *)eap->arg));+      if (STRNCMP(basename, """", 1) != 0 && STRNCMP(p_plugindir, """", 1) != 0) {+        if (!path_is_absolute_path(p_plugindir)) {+          // we build a path using the first item in 'runtimepath'+          // this is usually '~/.config/nvim'+          char_u *user_vim = xmallocz(MAXPATHL);+          copy_option_part(&rtp_copy, user_vim, MAXPATHL, "","");+          if (STRNCMP(user_vim, """", 1) != 0) {+            path = concat_fnames(concat_fnames((char *)user_vim,+                                               (char *)p_plugindir, true),+                                 (char *)basename, true);+          }+          xfree(user_vim);+        }+        // either the path is not an absolute path, or &rtp is empty+        if (path == NULL) {+          path = concat_fnames((char *)p_plugindir, (char *)basename, true);+        }+      xfree(basename);+      }+    }++    if (path != NUL) {+      // 1. rebuild rtp+      if (STRNCMP(p_rtp, """", 1) == 0) {  // """" -> ""path""+        p_rtp = xrealloc(p_rtp, STRLEN(path) + 1);+        snprintf((char *)p_rtp, STRLEN(path) + 1, ""%s"", path);+      } else {+        int new_rtp_size;+        int match = 0;+        regmatch_T regmatch;+        regmatch.regprog = vim_regcomp((char_u *)"",[^,]\\+/after,"",+                                        RE_MAGIC | RE_STRING);+        regmatch.rm_ic = p_ic;+        if (regmatch.regprog != NULL) {+          match = vim_regexec(&regmatch, p_rtp, 0);+        }+        if (match) {+          // insert after the comma, ""p1,p1/after"" -> ""p1,p2,p1/after""+          int pos = (int)(regmatch.startp[0] - p_rtp + 1);+          char_u *head = xmallocz(pos);+          memcpy(head, p_rtp, pos);+          char_u *tail;+          tail = vim_strsave(p_rtp + pos);+          new_rtp_size = STRLEN(head) + STRLEN(path) + STRLEN(tail) + 3;+          p_rtp = xrealloc(p_rtp, new_rtp_size);+          snprintf((char *)p_rtp, new_rtp_size, ""%s%s,%s"", head, path, tail);+        } else {  // append, ""path1"" -> ""path1,path2""+          new_rtp_size = STRLEN(p_rtp) + STRLEN(path) + 2;+          p_rtp = xrealloc(p_rtp, new_rtp_size);+          snprintf((char *)p_rtp, new_rtp_size, ""%s,%s"", rtp_copy, path);+        }+        vim_regfree(regmatch.regprog);+      }++      // 2. source .vim files in the plugin/ folder of the bundle+      if (eap->forceit == true) {+        char_u *save_rtp = vim_strsave(p_rtp);+        p_rtp = (char_u *)path;+        source_runtime((char_u *)""plugin/**/*.vim"", true);+        p_rtp = save_rtp;+      }++      // 3. update v:plugins+      char ex_cmd[MAXPATHL * 2];+      snprintf(ex_cmd, sizeof(ex_cmd),+               "":let v:plugins['%s'] = { 'path': '%s' }"", eap->arg, path);","Something like this. For adding a dict item it is probably to copy `dict_add_list` function to `dict_add_dict`, but only in case it is OK to error out if dictionary item was already defined.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3042,40593808,2015-09-28T19:23:07Z,src/nvim/path.c,"@@ -360,7 +360,7 @@ void add_pathsep(char *p)   FUNC_ATTR_NONNULL_ALL {   if (*p != NUL && !after_pathsep(p, p + strlen(p)))-    strcat(p, PATHSEPSTR);+    STRLCAT(p, PATHSEPSTR, MAXPATHL);",Did you check all call sites of function `add_pathsep()` that the buffer is always big enough or not bigger than `MAXPATHL`?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3042,40594457,2015-09-28T19:29:16Z,src/nvim/path.c,"@@ -360,7 +360,7 @@ void add_pathsep(char *p)   FUNC_ATTR_NONNULL_ALL {   if (*p != NUL && !after_pathsep(p, p + strlen(p)))-    strcat(p, PATHSEPSTR);+    STRLCAT(p, PATHSEPSTR, MAXPATHL);","By the way, what is the policy for STR macros? I see that this function has no reason to use `STRLCAT` in place of `xstrlcat` because `p` is `char*`, `PATHSEPSTR` is `char[2]` or `const char[2]` and `MAXPATHL` is an integer constant which thus is implicitly treated as `size_t` without needing any casts. I personally mostly omit upper-case macros. Also note that this function _did not_ use `STRCAT` macros, it used library `strcat`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3402,40615040,2015-09-28T22:39:43Z,runtime/doc/usr_05.txt,"@@ -387,8 +383,91 @@ Only files of this filetype will use the settings from the plugin.  The <name> part of the plugin file doesn't matter, you can use it to have several plugins for the same filetype.  Note that it must end in "".vim"". +USING PLUGIN BUNDLES                                      *plugin-bundles*++The manual method described above has the problem that things can get messy+once you install a few plugins, specially if they include more than one file+(which is common). A way to solve this is to install plugins in their own+directories and then add the path of those to the 'runtimepath' setting (so+Vim will use the files from those directories when looking for plugins). In+practice, this means that instead of having a |vimfiles| tree like >++	~.vim/+	    plugin/+		a.vim+	    ftplugin/+		b.vim+		e.vim+	    syntax/+		b.vim++you can have something like this >++	~.vim/+	    bundles/+		a/+		    plugin/+			a.vim+		b/+		    ftplugin/+			b.vim+		    syntax/+			b.vim+		e/+		    ftplugin/+			e.vim++This method allows the plugins to be distributed as their own trees, so they+can be installed without affecting other plugins. This is very helpful when+synchronizing with a version control repository.++So supposing the user wants to install a plugin that's distributed as this tree: >++	autoload/+	    awesome.vim+	plugin/+	    awesome.vim+	doc/+	    awesome.txt++from http://github.com/developer/awesome-vim, they can do so by (assuming there+is no ""bundles"" directory)++    1. creating the plugin directory >+	$ mkdir -p ~/.vim/bundles/awesome-vim+<    2. copying the files into the ""bundles/awesome-vim/"" folder >+	$ cp awesome-vim/* ~/.vim/bundles/awesome-vim/+<    3. adding >++	set runtimepath+=~/.vim/bundles/awesome-vim","29.09.2015, 01:36, ""Felipe Morales"" notifications@github.com:> In runtime/doc/usr_05.txt:> > > - awesome.vim > + plugin/ > + awesome.vim > + doc/ > + awesome.txt > + > +from http://github.com/developer/awesome-vim, they can do so by (assuming there > +is no ""bundles"" directory) > + > + 1. creating the plugin directory > > + $ mkdir -p ~/.vim/bundles/awesome-vim > +< 2. copying the files into the ""bundles/awesome-vim/"" folder > > + $ cp awesome-vim/\* ~/.vim/bundles/awesome-vim/ > +< 3. adding > > + > + set runtimepath+=~/.vim/bundles/awesome-vim> > Yeah, I thought it looked weird too close to the surrounding lines since this is not prefixed by a $, like in the other cases. It looks clearer this way to me. I could give more room to the previous codeblocks, but I won't remove the empty lines in this one.It does not matter as long as you are consistent. If you think that less space here looks bad, add more space there.> ���> Reply to this email directly or view it on GitHub.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3402,40615786,2015-09-28T22:48:47Z,runtime/doc/usr_05.txt,"@@ -378,17 +373,102 @@ The generic names for the filetype plugins are: > Here ""<name>"" can be any name that you prefer. Examples for the ""stuff"" filetype on Unix: > -	~/.vim/ftplugin/stuff.vim-	~/.vim/ftplugin/stuff_def.vim-	~/.vim/ftplugin/stuff/header.vim+	~/.nvim/ftplugin/stuff.vim+	~/.nvim/ftplugin/stuff_def.vim+	~/.nvim/ftplugin/stuff/header.vim  The <filetype> part is the name of the filetype the plugin is to be used for. Only files of this filetype will use the settings from the plugin.  The <name> part of the plugin file doesn't matter, you can use it to have several plugins for the same filetype.  Note that it must end in "".vim"". +USING PLUGIN BUNDLES                                      *plugin-bundles*++The manual method described above has the problem that things can get messy+once you install a few plugins, specially if they include more than one file+(which is common).  A way to solve this is to install plugins in their own+directories and then add the path of those to the 'runtimepath' setting (so+Vim will use the files from those directories when looking for plugins).  In+practice, this means that instead of having a |vimfiles| tree like >++	~.nvim/+	    plugin/+		a.vim+	    ftplugin/+		b.vim+		e.vim+	    syntax/+		b.vim++you can have something like this >++	~.nvim/+	    bundles/+		a/+		    plugin/+			a.vim+		b/+		    ftplugin/+			b.vim+		    syntax/+			b.vim+		e/+		    ftplugin/+			e.vim++This method allows the plugins to be distributed as their own trees, so they+can be installed without affecting other plugins.  This is very helpful when+synchronizing with a version control repository.++So supposing the user wants to install a plugin that's distributed as this tree: >++	autoload/+	    awesome.vim+	plugin/+	    awesome.vim+	doc/+	    awesome.txt++from http://github.com/developer/awesome-vim, they can do so by (assuming there+is no ""bundles"" directory)++    1. creating the plugin directory >++	$ mkdir -p ~/.nvim/bundles/awesome-vim++<    2. copying the files into the ""bundles/awesome-vim/"" folder >++	$ cp awesome-vim/* ~/.nvim/bundles/awesome-vim/++<    3. adding >++	set runtimepath+=~/.nvim/bundles/awesome-vim++<       to their |vimrc|.++Most commonly, instead of steps 1-2, this should work: >",Adverb which modifies what? In this position with these commas this looks like an introductory phrase (where adverb has nothing to modify because this is rather independent) and not something that modifies verb ���work���. I would rephrase this as ���Most likely steps 1 and 2 can be replaced with��� because I am pretty sure ���instead of steps 1-2��� could not be placed in that position.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3408,40842469,2015-09-30T19:52:04Z,CMakeLists.txt,"@@ -116,6 +119,24 @@ if(NOT HAS_ACCEPTABLE_FORTIFY)   set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} ${_FORTIFY_SOURCE_PREFIX}-U_FORTIFY_SOURCE ${_FORTIFY_SOURCE_PREFIX}-D_FORTIFY_SOURCE=1"") endif() +# Remove --sort-common from linker flags, as this seems to cause bugs (see #2641, #3374).+# TODO: Figure out the root cause.+if(CMAKE_EXE_LINKER_FLAGS MATCHES ""--sort-common"" OR+   CMAKE_SHARED_LINKER_FLAGS MATCHES ""--sort-common"" OR+   CMAKE_MODULE_LINKER_FLAGS MATCHES ""--sort-common"")+  message(STATUS ""Removing --sort-common from linker flags."")+  string(REGEX REPLACE "",--sort-common(=[^,]+)?"" """" CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS}"")+  string(REGEX REPLACE "",--sort-common(=[^,]+)?"" """" CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS}"")+  string(REGEX REPLACE "",--sort-common(=[^,]+)?"" """" CMAKE_MODULE_LINKER_FLAGS ""${CMAKE_MODULE_LINKER_FLAGS}"")+endif()++# If no linker flags remain for a -Wl argument, remove it.+# '-Wl$' will match LDFLAGS=""-Wl,--sort-common"",+# '-Wl ' will match LDFLAGS=""-Wl,--sort-common -Wl,...""+string(REGEX REPLACE ""-Wl($| )"" """" CMAKE_EXE_LINKER_FLAGS ""${CMAKE_EXE_LINKER_FLAGS}"")+string(REGEX REPLACE ""-Wl($| )"" """" CMAKE_SHARED_LINKER_FLAGS ""${CMAKE_SHARED_LINKER_FLAGS}"")+string(REGEX REPLACE ""-Wl($| )"" """" CMAKE_MODULE_LINKER_FLAGS ""${CMAKE_MODULE_LINKER_FLAGS}"")","This should go in the if() block, otherwise we could be hiding a problem.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3392,40940180,2015-10-01T17:17:10Z,test/functional/ex_cmds/menu_spec.lua,"@@ -36,3 +36,37 @@ describe(':emenu', function()   end)  end)++describe('emenu Edit.Paste while in commandline', function()+    before_each(clear)++    it('ok', function()+        local screen = require('test.functional.ui.screen').new()","Can you change the `new()` call to `new(40, 8)` and adjust the test below? Most tests (like this one) don't need such a big space, so this compacts the tests a bit for readability.See `test/functional/api/vim_spec.lua` for an example (you can copy-paste the layout).",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/1909,40967385,2015-10-01T21:17:00Z,src/nvim/msgpack_rpc/server.c,"@@ -67,6 +68,30 @@ void server_teardown(void)   GA_DEEP_CLEAR(&watchers, SocketWatcher *, close_socket_watcher); } +/// Return unique address for local server.+///+/// In Windows this is a local pipe address in the format+///     \\.\pipe\nvim-<PID>-<COUNTER>.+///+/// For other systems it is a path returned by vim_tempname().+///+/// This function is NOT thread safe+///+char *server_address(void)+{+#ifdef WIN32+  static uint32_t count = 0;+  char template[ADDRESS_MAX_SIZE] = """";+  if (template[0] == '\0') {",Why use an `if`? The condition is always true.,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3198,41061846,2015-10-02T20:03:36Z,src/nvim/os/stdpaths.c,"@@ -0,0 +1,100 @@+#include ""nvim/os/os.h""+#include ""nvim/strings.h""+#include ""nvim/path.h""+#include ""nvim/garray.h""++typedef enum {+  kXDGConfigHome,+  kXDGDataHome,+  kXDGCacheHome,+  kXDGRuntimeDir,+  kXDGConfigDirs,+  kXDGDataDirs,+} XDGDirType;++static const char *xdg_env_vars[] = {+  [kXDGConfigHome] = ""XDG_CONFIG_HOME"",+  [kXDGDataHome] = ""XDG_DATA_HOME"",+  [kXDGCacheHome] = ""XDG_CACHE_HOME"",+  [kXDGRuntimeDir] = ""XDG_RUNTIME_DIR"",+  [kXDGConfigDirs] = ""XDG_CONFIG_DIRS"",+  [kXDGDataDirs] = ""XDG_DATA_DIRS"",+};++static const char *const xdg_defaults[] = {+  // Windows, Apple stuff are just shims right now+#ifdef WIN32+  // Windows+#elif APPLE+  // Apple (this includes iOS, which we might need to handle differently)+  [kXDGConfigHome] = ""~/Library/Preferences"",+  [kXDGDataHome] = ""~/Library/Application Support"",+  [kXDGCacheHome] = ""~/Library/Caches"",+  [kXDGRuntimeDir] = ""~/Library/Application Support"",+  [kXDGConfigDirs] = ""/Library/Application Support"",+  [kXDGDataDirs] = ""/Library/Application Support"",+#else+  // Linux, BSD, CYGWIN+  [kXDGConfigHome] = ""~/.config"",+  [kXDGDataHome] = ""~/.local/share"",+  [kXDGCacheHome] = ""~/.cache"",+  [kXDGRuntimeDir] = """",+  [kXDGConfigDirs] = ""/etc/xdg/"",+  [kXDGDataDirs] = ""/usr/local/share/:/usr/share/"",+};+#endif++static const char *get_xdg(XDGDirType idx)+{+  const char *env = xdg_env_vars[idx];+  const char *fallback = xdg_defaults[idx];++  const char *ret = os_getenv(env);+  if (!ret && fallback) {+    ret = (const char *)expand_env_save((char_u *)fallback);+  }++  return ret;+}++static const char *get_xdg_home(XDGDirType idx)+{+  const char *dir = get_xdg(idx);+  if (dir) {+    dir = (const char *)concat_fnames(dir, ""nvim"", true);+  }+  return dir;+}++static void create_dir(const char *dir, int mode, const char *suffix)+{+  char *failed;+  if (!os_mkdir_recurse(dir, mode, &failed)) {+    // TODO: Create a folder in $TMPDIR instead+    DLOG(""Create dir failed"");+  }+}++const char *get_user_conf_dir(void)+{+  return get_xdg_home(kXDGConfigHome);+}++const char *get_from_user_conf(const char * fname)+{+  return (const char *)concat_fnames(get_user_conf_dir(), fname, true);+}++const char *get_user_data_dir(void)+{+  return get_xdg_home(kXDGDataHome);+}++const char *get_from_user_data(const char * fname)+{+  const char *dir = (const char *)concat_fnames(get_user_data_dir(), fname, true);",clint says this line is too long,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3198,41088753,2015-10-03T16:25:45Z,src/nvim/os/unix_defs.h,"@@ -31,12 +31,6 @@ #ifndef USR_EXRC_FILE # define USR_EXRC_FILE ""~/.exrc"" #endif-#ifndef USR_VIMRC_FILE-# define USR_VIMRC_FILE ""~/.nvimrc""","@Earnestly Where does the standard specify the default locations for OSX and Windows? So far only source examples like https://github.com/ActiveState/appdirs/blob/master/appdirs.py have been offered, which indicate ""best guesses"" about default locations, there is no reference to a specification.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3198,41088853,2015-10-03T16:33:08Z,src/nvim/os/unix_defs.h,"@@ -31,12 +31,6 @@ #ifndef USR_EXRC_FILE # define USR_EXRC_FILE ""~/.exrc"" #endif-#ifndef USR_VIMRC_FILE-# define USR_VIMRC_FILE ""~/.nvimrc""","@justinmk For Windows, it's best to use the OS convention, which is discussed [here](http://windows.microsoft.com/en-us/windows-8/what-appdata-folder) and [here](http://blogs.msdn.com/b/patricka/archive/2010/03/18/where-should-i-store-my-data-and-configuration-files-if-i-target-multiple-os-versions.aspx). ",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3198,41088943,2015-10-03T16:39:16Z,src/nvim/os/unix_defs.h,"@@ -31,12 +31,6 @@ #ifndef USR_EXRC_FILE # define USR_EXRC_FILE ""~/.exrc"" #endif-#ifndef USR_VIMRC_FILE-# define USR_VIMRC_FILE ""~/.nvimrc""","For OSX, there's this: https://developer.apple.com/library/mac/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html#//apple_ref/doc/uid/TP40010672-CH10-SW1",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3422,41097753,2015-10-04T13:32:22Z,src/nvim/tui/tui.c,"@@ -779,6 +779,9 @@ static void fix_terminfo(TUIData *data)   } else if (STARTS_WITH(term, ""screen"")) {     unibi_set_if_empty(ut, unibi_to_status_line, ""\x1b_"");     unibi_set_if_empty(ut, unibi_from_status_line, ""\x1b\\"");+  } else if (STARTS_WITH(term, ""tmux"")) {",Can this condition be ORed to the previous `else if` one?,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3042,41355566,2015-10-07T06:27:41Z,src/nvim/path.c,"@@ -359,8 +359,12 @@ char *concat_fnames(const char *fname1, const char *fname2, bool sep) void add_pathsep(char *p)   FUNC_ATTR_NONNULL_ALL {-  if (*p != NUL && !after_pathsep(p, p + strlen(p)))-    strcat(p, PATHSEPSTR);+  const size_t len = strlen(p);+  if (*p != NUL && !after_pathsep(p, p + len) && len < MAXPATHL - 1) {+    memcpy(p + len, PATHSEPSTR, sizeof(PATHSEPSTR));+  } else if (len >= MAXPATHL - 1) {+    EMSG(_(e_pathtoolong));","Callers of `add_pathsep()` may also print `EMSG()`. Small utility functions like this should return a `bool`, or arguably even `strlen(p) + 1` to mirror its usage with `strlcpy`/`cat`/etc.Notably, this change makes it an implicit precondition that `p` is a `MAXPATHL`-sized buffer.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3198,41365438,2015-10-07T08:48:06Z,src/nvim/main.c,"@@ -1837,16 +1837,9 @@ static void source_startup_scripts(mparm_T *parmp)      * - second user exrc file ($VIM/.exrc for Dos)      * The first that exists is used, the rest is ignored.      */+    char_u *user_vimrc = (char_u *)get_from_user_conf(""init.vim"");     if (process_env(""VIMINIT"", true) != OK) {-      if (do_source((char_u *)USR_VIMRC_FILE, TRUE, DOSO_VIMRC) == FAIL-#ifdef USR_VIMRC_FILE2-          && do_source((char_u *)USR_VIMRC_FILE2, TRUE,-            DOSO_VIMRC) == FAIL-#endif-#ifdef USR_VIMRC_FILE3-          && do_source((char_u *)USR_VIMRC_FILE3, TRUE,-            DOSO_VIMRC) == FAIL-#endif+      if (do_source(user_vimrc, TRUE, DOSO_VIMRC) == FAIL","No, just change these, the travis build won't pass until you do so. Merely stylistic PRs are not terribly important, and since the linter starts looking for issues in the surrounding lines, they can become quite unwieldy.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3339,41445894,2015-10-07T20:54:31Z,src/nvim/buffer.c,"@@ -2833,15 +2816,16 @@ build_stl_str_hl (       Trunc     }               type;   }           item[STL_MAX_ITEM];-  int minwid;-  int maxwid;-  int zeropad;-  char_u base;-  char_u opt;++  typedef enum {+     DECIMAL     = 10,+     OCTAL       = 8,+     HEXIDECIMAL = 16+  } number_base;",@war1025 Why do you need better solution? Just do not place it _inside the function_ and correct naming.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3339,41540825,2015-10-08T17:13:43Z,src/nvim/buffer.c,"@@ -2770,6 +2770,16 @@ void free_titles(void)  # endif +/**+ * Enumeration specifying the valid numeric bases that can+ * be used when printing numbers in the status line.+ **/",Style guide accepts _only_ `//`-style comments (specifically `///` for doxygen). `/*���*/` would be fine only inside a macros and only as long as they are one-line.,
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/3198,41556908,2015-10-08T19:27:16Z,src/nvim/os/unix_defs.h,"@@ -31,12 +31,6 @@ #ifndef USR_EXRC_FILE # define USR_EXRC_FILE ""~/.exrc"" #endif-#ifndef USR_VIMRC_FILE-# define USR_VIMRC_FILE ""~/.nvimrc""","@fmoralesc I���m always a bit surprised when people bring up Mac OS X GUI level configuration locations in the context of the XDG spec. When it comes to the command line, OS X is a BSD (OK, a user space BSD layer wrapped around a Mach micro kernel, but that is academic for the purpose of this thread) and as such firmly rooted in the *nix world. The relevant Vim OS class is `macunix`, BTW, which says it pretty clearly ;).To my understanding, this means the XDG default locations can and should match the spec: `~/.config`, `~/.cache` etc., an understanding shared by all XDG aware CLI applications I have met on on OS X (front and centre: Git).",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3198,41688862,2015-10-10T00:00:08Z,src/nvim/option.c,"@@ -301,6 +301,15 @@ static char *(p_cot_values[]) = {""menu"", ""menuone"", ""longest"", ""preview"", # include ""option.c.generated.h"" #endif +static void set_runtimepath_default(void)+{+  garray_T rtp_ga;+  ga_init(&rtp_ga, (int)sizeof(const char *), 1);+  GA_APPEND(const char *, &rtp_ga, get_user_conf_dir());+  GA_APPEND(const char *, &rtp_ga, concat_fnames(get_user_conf_dir(), ""after"", true));+  set_string_default(""runtimepath"", ga_concat_strings(&rtp_ga));","Unfortunately (I guess), we have a lot of code that check paths are less than the maximum, so this convention wouldn't be easy to remove from the codebase, even if it's wrong. For the moment, I think it would be correct to just say ""we don't support unreasonably large paths,"" and if supporting them means unleashing such inefficient code such as in the linked article, I don't see any benefit.Also, I double checked: I should have said `MAXPATHL`, an os-independent variable that we define.",
6589866,brcolow,https://api.github.com/repos/neovim/neovim/pulls/3402,41694323,2015-10-10T07:22:35Z,runtime/doc/usr_05.txt,"@@ -250,121 +250,115 @@ The "":map"" command (with no arguments) lists your current mappings.  At least the ones for Normal mode.  More about mappings in section |40.1|.  ==============================================================================-*05.4*	Adding a plugin					*add-plugin* *plugin*--Vim's functionality can be extended by adding plugins.  A plugin is nothing-more than a Vim script file that is loaded automatically when Vim starts.  You-can add a plugin very easily by dropping it in your plugin directory.-{not available when Vim was compiled without the |+eval| feature}--There are two types of plugins:--    global plugin: Used for all kinds of files-  filetype plugin: Only used for a specific type of file--The global plugins will be discussed first, then the filetype ones-|add-filetype-plugin|.---GLOBAL PLUGINS						*standard-plugin*-+*05.4*	Plugins					*add-plugin* *plugin*++Vim's functionality can be extended by adding plugins.  A plugin is+essentially a set of Vim script files that are loaded automatically when Vim+starts or on some other event (like opening a file of a certain type).+Plugins can be used to add support to more programming languages, extend Vim's+command ""vocabulary"", simplify some use-cases, add some bling to Vim, and even+turn it into a different sort of application.  Thankfully, the community has+made available on the net a great ammount of plugins that any user can benefit+from.++You can add a plugin very easily by dropping it in your |vimfiles| directory,+but there are more advanced ways to manage plugins, which will be described+below.++KINDS OF PLUGIN                                         *plugin-types*++There are mainly two kinds of plugin: global and filetype-specific.++Global plugins are sourced on startup and usually add functionality that will+be available regardless of the opened files.  For example, the |matchparen|+plugin can be used in any kind of file whatsoever to highlight matching+parentheses on cursor movement.+					                *standard-plugin* When you start Vim, it will automatically load a number of global plugins. You don't have to do anything for this.  They add functionality that most people will want to use, but which was implemented as a Vim script instead of being compiled into Vim.  You can find them listed in the help index |standard-plugin-list|.  Also see |load-plugins|. -							*add-global-plugin*-You can add a global plugin to add functionality that will always be present-when you use Vim.  There are only two steps for adding a global plugin:-1. Get a copy of the plugin.-2. Drop it in the right directory.+Global plugins reside under the `plugin/` |vimfiles| directory.++                                                        *ftplugins*+Filetype plugins (""ftplugins"") are only used for a specific type of file, and+usually change the buffer-local settings.  For example, the standard vim C+ftplugin sets 'formatoptions' to break comment lines but not other lines, and+to insert the comment leader when hitting <CR> or using |o|.  Filetype plugins+are usually distributed alongside syntax files, and indent and filetype","I don't like the double and here, as in ""...usually distributed alongside syntax files, _and_ indent _and_ filetype detection scripts..."" but I am not sure how to fix it.",
521538,Earnestly,https://api.github.com/repos/neovim/neovim/pulls/3198,41710287,2015-10-11T13:17:24Z,src/nvim/option.c,"@@ -301,6 +301,15 @@ static char *(p_cot_values[]) = {""menu"", ""menuone"", ""longest"", ""preview"", # include ""option.c.generated.h"" #endif +static void set_runtimepath_default(void)+{+  garray_T rtp_ga;+  ga_init(&rtp_ga, (int)sizeof(const char *), 1);+  GA_APPEND(const char *, &rtp_ga, get_user_conf_dir());+  GA_APPEND(const char *, &rtp_ga, concat_fnames(get_user_conf_dir(), ""after"", true));+  set_string_default(""runtimepath"", ga_concat_strings(&rtp_ga));",@ZyX-I ���53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.��� ��� Alan J. Perlis,
3303032,ianks,https://api.github.com/repos/neovim/neovim/pulls/3450,41829184,2015-10-13T05:52:59Z,src/nvim/normal.c,"@@ -3611,6 +3625,107 @@ void scroll_redraw(int up, long count)   redraw_later(VALID); } +static linenr_T longest_lnum;+/*+ * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.+ */+int gui_do_horiz_scroll(int leftcol, bool compute_longest_lnum)+{+    /* no wrapping, no scrolling */+    if (curwin->w_p_wrap)+      return false;++    if (curwin->w_leftcol == (colnr_T)leftcol)+      return false;++    curwin->w_leftcol = (colnr_T)leftcol;++    /* When the line of the cursor is too short, move the cursor to the+     * longest visible line. */+    if (!virtual_active()+      && (colnr_T)leftcol > scroll_line_len(curwin->w_cursor.lnum))+    {+      if (compute_longest_lnum)+      {+          curwin->w_cursor.lnum = gui_find_longest_lnum();+          curwin->w_cursor.col = 0;+      } else if (longest_lnum >= curwin->w_topline+        && longest_lnum < curwin->w_botline) {+        /* Do a sanity check on ""longest_lnum"", just in case. */+        curwin->w_cursor.lnum = longest_lnum;+        curwin->w_cursor.col = 0;+      }+    }++    return leftcol_changed();+}++/*+ * Find longest visible line number.  If this is not possible (or not desired,+ * by setting 'h' in ""guioptions"") then the current line number is returned.+ */+static linenr_T gui_find_longest_lnum()+{+    linenr_T ret = 0;++    /* Calculate maximum for horizontal scrollbar.  Check for reasonable+     * line numbers, topline and botline can be invalid when displaying is+     * postponed. */+    if (curwin->w_topline <= curwin->w_cursor.lnum+      && curwin->w_botline > curwin->w_cursor.lnum+      && curwin->w_botline <= curbuf->b_ml.ml_line_count + 1)+    {+      linenr_T    lnum;+      colnr_T     n;+      long      max = 0;++      /* Use maximum of all visible lines.  Remember the lnum of the+       * longest line, closest to the cursor line.  Used when scrolling+       * below. */+      for (lnum = curwin->w_topline; lnum < curwin->w_botline; ++lnum)+      {+          n = scroll_line_len(lnum);+          if (n > (colnr_T)max)+          {+            max = n;+            ret = lnum;+          } else if (n == (colnr_T)max+            && abs((int)(lnum - curwin->w_cursor.lnum))+               < abs((int)(ret - curwin->w_cursor.lnum))) {+              ret = lnum;+          }+      }+    } else {+      /* Use cursor line only. */+      ret = curwin->w_cursor.lnum;+    }++    return ret;+}++/*+ * Return length of line ""lnum"" for horizontal scrolling.+ */+static colnr_T scroll_line_len(linenr_T lnum)+{+    char_u  *p;+    colnr_T col;+    int   w;++    p = ml_get(lnum);+    col = 0;+    if (*p != NUL)+      for (;;)+      {",This if statement is very ambiguous,
564972,bambu,https://api.github.com/repos/neovim/neovim/pulls/3450,41860397,2015-10-13T12:43:27Z,src/nvim/normal.c,"@@ -3611,6 +3625,107 @@ void scroll_redraw(int up, long count)   redraw_later(VALID); } +static linenr_T longest_lnum;+/*+ * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.+ */+int gui_do_horiz_scroll(int leftcol, bool compute_longest_lnum)+{+    /* no wrapping, no scrolling */+    if (curwin->w_p_wrap)+      return false;++    if (curwin->w_leftcol == (colnr_T)leftcol)+      return false;++    curwin->w_leftcol = (colnr_T)leftcol;++    /* When the line of the cursor is too short, move the cursor to the+     * longest visible line. */+    if (!virtual_active()+      && (colnr_T)leftcol > scroll_line_len(curwin->w_cursor.lnum))+    {+      if (compute_longest_lnum)+      {+          curwin->w_cursor.lnum = gui_find_longest_lnum();+          curwin->w_cursor.col = 0;+      } else if (longest_lnum >= curwin->w_topline+        && longest_lnum < curwin->w_botline) {+        /* Do a sanity check on ""longest_lnum"", just in case. */+        curwin->w_cursor.lnum = longest_lnum;+        curwin->w_cursor.col = 0;+      }+    }++    return leftcol_changed();+}++/*+ * Find longest visible line number.  If this is not possible (or not desired,+ * by setting 'h' in ""guioptions"") then the current line number is returned.+ */+static linenr_T gui_find_longest_lnum()+{+    linenr_T ret = 0;++    /* Calculate maximum for horizontal scrollbar.  Check for reasonable+     * line numbers, topline and botline can be invalid when displaying is+     * postponed. */+    if (curwin->w_topline <= curwin->w_cursor.lnum+      && curwin->w_botline > curwin->w_cursor.lnum+      && curwin->w_botline <= curbuf->b_ml.ml_line_count + 1)+    {+      linenr_T    lnum;+      colnr_T     n;+      long      max = 0;++      /* Use maximum of all visible lines.  Remember the lnum of the+       * longest line, closest to the cursor line.  Used when scrolling+       * below. */+      for (lnum = curwin->w_topline; lnum < curwin->w_botline; ++lnum)+      {+          n = scroll_line_len(lnum);+          if (n > (colnr_T)max)+          {+            max = n;+            ret = lnum;+          } else if (n == (colnr_T)max+            && abs((int)(lnum - curwin->w_cursor.lnum))+               < abs((int)(ret - curwin->w_cursor.lnum))) {+              ret = lnum;+          }+      }+    } else {+      /* Use cursor line only. */+      ret = curwin->w_cursor.lnum;+    }++    return ret;+}++/*+ * Return length of line ""lnum"" for horizontal scrolling.+ */+static colnr_T scroll_line_len(linenr_T lnum)+{+    char_u  *p;+    colnr_T col;+    int   w;++    p = ml_get(lnum);+    col = 0;+    if (*p != NUL)+      for (;;)+      {","That is the way that it is written in the VIM source. If necessary, I can modify it to be less ambiguous but I tried to leave the code as close as possible to the original. ",
1525226,ghqhxnfizloub,https://api.github.com/repos/neovim/neovim/pulls/2789,42097093,2015-10-15T08:46:50Z,src/nvim/os/shell.c,"@@ -37,6 +37,50 @@ typedef struct { #endif  +/// Process command string with 'shellxescape' (p_sxe) and 'shellxquote'+/// (p_sxq)+///+/// @param cmd Command string+/// @return NULL if `cmd` is NULL. Otherwise, a newly allocated command string.+///         It must be freed with `xfree` when no longer needed.+static char *shell_escape(const char *cmd)+{+  char *ncmd;++  if (cmd == NULL) {+    ncmd = NULL;+  } else if (*p_sxq == NUL) {+    ncmd = xstrdup(cmd);+  } else {+    const char *ecmd;+    size_t ncmd_size;++    if (*p_sxe != NUL && STRCMP(p_sxq, ""("") == 0) {+      ecmd = (char *)vim_strsave_escaped_ext((char_u *)cmd, p_sxe, '^', false);+    } else {+      ecmd = cmd;+    }+    ncmd_size = strlen(ecmd) + STRLEN(p_sxq) * 2 + 1;+    ncmd = xmalloc(ncmd_size);++    // When 'shellxquote' is '(', append ')'.+    // When 'shellxquote' is '""(', append ')""'.+    if (STRCMP(p_sxq, ""("") == 0) {+      snprintf(ncmd, ncmd_size, ""(%s)"", ecmd);+    } else if (STRCMP(p_sxq, ""\""("") == 0) {+      snprintf(ncmd, ncmd_size, ""\""(%s)\"""", ecmd);+    } else {+      snprintf(ncmd, ncmd_size, ""%s%s%s"", p_sxq, ecmd, p_sxq);+    }","After reading Vim's code, I found the fish shell support is only added in `make_filter_cmd` (https://github.com/vim/vim/blob/master/src/ex_cmds.c#L1600), which is already in nvim's code (https://github.com/neovim/neovim/blob/master/src/nvim/ex_cmds.c#L1323). Since I don't use fish shell, I would not make more changes here.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/1909,42312578,2015-10-17T18:39:22Z,src/nvim/msgpack_rpc/server.c,"@@ -67,6 +68,27 @@ void server_teardown(void)   GA_DEEP_CLEAR(&watchers, SocketWatcher *, close_socket_watcher); } +/// Return unique address for local server.+///+/// In Windows this is a local pipe address in the format+///     \\.\pipe\nvim-<PID>-<COUNTER>.+///+/// For other systems it is a path returned by vim_tempname().+///+/// This function is NOT thread safe+char *server_address(void)",`server_address_create` or `server_address_generate` would be a less ambiguous name.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3470,42312716,2015-10-17T18:47:45Z,src/nvim/os/stdpaths.c,"@@ -0,0 +1,101 @@+#include <stdbool.h>++#include ""nvim/os/stdpaths_defs.h""+#include ""nvim/os/os.h""+#include ""nvim/path.h""+#include ""nvim/memory.h""++/// Names of the environment variables, mapped to XDGVarType values+static const char *xdg_env_vars[] = {+  [kXDGConfigHome] = ""XDG_CONFIG_HOME"",+  [kXDGDataHome] = ""XDG_DATA_HOME"",+  [kXDGCacheHome] = ""XDG_CACHE_HOME"",+  [kXDGRuntimeDir] = ""XDG_RUNTIME_DIR"",+  [kXDGConfigDirs] = ""XDG_CONFIG_DIRS"",+  [kXDGDataDirs] = ""XDG_DATA_DIRS"",+};++/// Defaults for XDGVarType values+///+/// Used in case environment variables contain nothing. Need to be expanded.+static const char *const xdg_defaults[] = {+  // Windows, Apple stuff are just shims right now+#ifdef WIN32+  // Windows",We can stub it out with the examples from https://github.com/ActiveState/appdirs/blob/master/appdirs.py .,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3470,42312940,2015-10-17T19:08:03Z,src/nvim/os/stdpaths.c,"@@ -0,0 +1,101 @@+#include <stdbool.h>++#include ""nvim/os/stdpaths_defs.h""+#include ""nvim/os/os.h""+#include ""nvim/path.h""+#include ""nvim/memory.h""++/// Names of the environment variables, mapped to XDGVarType values+static const char *xdg_env_vars[] = {+  [kXDGConfigHome] = ""XDG_CONFIG_HOME"",+  [kXDGDataHome] = ""XDG_DATA_HOME"",+  [kXDGCacheHome] = ""XDG_CACHE_HOME"",+  [kXDGRuntimeDir] = ""XDG_RUNTIME_DIR"",+  [kXDGConfigDirs] = ""XDG_CONFIG_DIRS"",+  [kXDGDataDirs] = ""XDG_DATA_DIRS"",+};++/// Defaults for XDGVarType values+///+/// Used in case environment variables contain nothing. Need to be expanded.+static const char *const xdg_defaults[] = {+  // Windows, Apple stuff are just shims right now+#ifdef WIN32+  // Windows","@ZyX-I  `AppAuthor` in this case should be `Neovim`, and the same for `AppName`. Supposedly, you could use the `%AppData%` environment variable, see http://blogs.msdn.com/b/patricka/archive/2010/03/18/where-should-i-store-my-data-and-configuration-files-if-i-target-multiple-os-versions.aspx",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3470,42312951,2015-10-17T19:08:53Z,runtime/doc/autocmd.txt,"@@ -994,7 +994,7 @@ expect. Environment variables can be used in a pattern: > 	:autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab And ~ can be used for the home directory (if $HOME is defined): >-	:autocmd BufWritePost ~/.vimrc   so ~/.vimrc+	:autocmd BufWritePost ~/.config/nvim/init.vim   so <afile>","17.10.2015, 22:01, ""Michael Reed"" notifications@github.com:> In runtime/doc/autocmd.txt:> > > @@ -994,7 +994,7 @@ expect. > Environment variables can be used in a pattern: > > :autocmd BufRead $VIMRUNTIME/doc/*.txt set expandtab > And ~ can be used for the home directory (if $HOME is defined): > > - :autocmd BufWritePost ~/.vimrc so ~/.vimrc > + :autocmd BufWritePost ~/.config/nvim/init.vim so <afile>> > Regarding all these references to ~/.config/...: shouldn't these instead say $XDG_CONFIG_HOME/...?Not all of them: $XDG_CONFIG_HOME is not guaranteed to be defined since PR with approach which adds support for XDG_\* vars to vim_getenv was rejected.Most of other stay as-is because I am not fond of explaining WTF is $XDG_CONFIG_HOME and what is its default. I guess we need another section somewhere in documentation (options.txt?) with explanations.> ���> Reply to this email directly or view it on GitHub.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3470,42315208,2015-10-17T23:18:03Z,src/nvim/version.c,"@@ -1067,31 +1067,6 @@ void list_version(void)   version_msg(SYS_VIMRC_FILE);   version_msg(""\""\n""); #endif  // ifdef SYS_VIMRC_FILE-#ifdef USR_VIMRC_FILE-  version_msg(_(""     user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE-#ifdef USR_VIMRC_FILE2-  version_msg(_("" 2nd user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE2);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE2-#ifdef USR_VIMRC_FILE3-  version_msg(_("" 3rd user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE3);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE3-#ifdef USR_EXRC_FILE-  version_msg(_(""      user exrc file: \""""));-  version_msg(USR_EXRC_FILE);-  version_msg(""\""\n"");-#endif  // ifdef USR_EXRC_FILE-#ifdef USR_EXRC_FILE2-  version_msg(_(""  2nd user exrc file: \""""));-  version_msg(USR_EXRC_FILE2);-  version_msg(""\""\n"");-#endif  // ifdef USR_EXRC_FILE2",Users may still like to see the paths listed in :version.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3470,42315314,2015-10-17T23:33:15Z,src/nvim/version.c,"@@ -1067,31 +1067,6 @@ void list_version(void)   version_msg(SYS_VIMRC_FILE);   version_msg(""\""\n""); #endif  // ifdef SYS_VIMRC_FILE-#ifdef USR_VIMRC_FILE-  version_msg(_(""     user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE-#ifdef USR_VIMRC_FILE2-  version_msg(_("" 2nd user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE2);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE2-#ifdef USR_VIMRC_FILE3-  version_msg(_("" 3rd user vimrc file: \""""));-  version_msg(USR_VIMRC_FILE3);-  version_msg(""\""\n"");-#endif  // ifdef USR_VIMRC_FILE3-#ifdef USR_EXRC_FILE-  version_msg(_(""      user exrc file: \""""));-  version_msg(USR_EXRC_FILE);-  version_msg(""\""\n"");-#endif  // ifdef USR_EXRC_FILE-#ifdef USR_EXRC_FILE2-  version_msg(_(""  2nd user exrc file: \""""));-  version_msg(USR_EXRC_FILE2);-  version_msg(""\""\n"");-#endif  // ifdef USR_EXRC_FILE2","This breaks the purpose of `:version`. And `$MYVIMRC` is still there. Also vimrc file name placed here means that without `-u` Neovim will _always_ source _exactly this_ vimrc which1. Is useless if it is written as `$XDG_CONFIG_HOME/.config/init.vim`. (BTW, I have not yet implemented #78/1/ii which will make this variant look even more strange.)2. Contains even more information which has nothing to do with compilation options if I also provide $XDG_CONFIG_HOME (and $XDG_CONFIG_DIRS) values in addition to their defaults.3. Is generally incorrect if I perform the expansion before providing any information, and also will contain lots of unrelated information with 1/ii: next time you launch nvim environment variables may change.4. Is useless for the purpose of determining ���where I need to put init.vim file��� in case I provide only the effective file from all the variants with 1/ii (still useful if 1/ii is not implemented, but again generally incorrect).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3470,42339564,2015-10-19T06:37:13Z,runtime/doc/options.txt,"@@ -6762,8 +6776,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	displayed when 'verbosefile' is set.  						*'viewdir'* *'vdir'*-'viewdir' 'vdir'	string	(default for MS-DOS and Win32: ""$VIM/vimfiles/view"",-				 for Unix: ""~/.vim/view"")+'viewdir' 'vdir'	string	(default: ""$XDG_DATA_HOME/nvim/view"")",`'directory'` doc needs a similar update.,
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/3470,42363693,2015-10-19T12:16:30Z,runtime/doc/options.txt,"@@ -6762,8 +6776,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	displayed when 'verbosefile' is set.  						*'viewdir'* *'vdir'*-'viewdir' 'vdir'	string	(default for MS-DOS and Win32: ""$VIM/vimfiles/view"",-				 for Unix: ""~/.vim/view"")+'viewdir' 'vdir'	string	(default: ""$XDG_DATA_HOME/nvim/view"")","I know we have discussed this before in #78, but I���m still wondering if we are correct in defining view session files, backups, swap files etc. as **essential** data [according to the spec](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html).I have had some doubts since my last [contribution to that discussion](https://github.com/neovim/neovim/issues/78#issuecomment-39668459) (which applied to the inadvisability of using `$XDG_RUNTIME_DIR`, a directory that _must_ not survive log offs or reboots), but now that this feature is nearing release, I would be remiss in not bringing up my suspicion that we might be off base in our interpretation of the XDG spec. I know I should have brought this up earlier (especially as it has [been brought up in #78](https://github.com/neovim/neovim/issues/78#issuecomment-77776048), a fact I seem to have completely missed), but are we absolutely certain that  `$XDG_DATA_HOME` isn���t meant for things like user installed spelling dictionaries and such, while state should better go into `$XDG_CACHE_HOME`?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3470,42883377,2015-10-23T16:11:31Z,src/nvim/option.c,"@@ -301,6 +301,243 @@ static char *(p_cot_values[]) = {""menu"", ""menuone"", ""longest"", ""preview"", # include ""option.c.generated.h"" #endif +/// Append string with escaped commas+static char *strcpy_comma_escaped(char *dest, const char *src, const size_t len)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  size_t shift = 0;+  for (size_t i = 0; i < len; i++) {+    if (src[i] == ',') {+      dest[i + shift++] = '\\';+    }+    dest[i + shift] = src[i];+  }+  return &dest[len + shift];+}++/// Compute length of a colon-separated value, doubled and with some suffixes+///+/// @param[in]  val  Colon-separated array value.+/// @param[in]  common_suf_len  Length of the common suffix which is appended to+///                             each item in the array, twice.+/// @param[in]  single_suf_len  Length of the suffix which is appended to each+///                             item in the array once.+///+/// @return Length of the comma-separated string array that contains each item+///         in the original array twice with suffixes with given length+///         (common_suf is present after each new item, single_suf is present+///         after half of the new items) and with commas after each item, commas+///         inside the values are escaped.+static inline size_t compute_double_colon_len(const char *const val,+                                              const size_t common_suf_len,+                                              const size_t single_suf_len)+  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE","In this case it looks like only stack memory is used, but I would consider it global memory from the point of the called function: gcc pure attribute description is a bit ""short/unclear"", what I refer to is an extract from https://lwn.net/Articles/285332/, (bold part marked by me)> A pure function is a function with basically no side effect. This means that pure functions return a value that is calculated based on given parameters and global memory, but cannot affect the value of any other global variable. Pure functions cannot reasonably lack a return type (i.e. have a void return type). and> A counter-example of a non-pure function is the strcpy() function. This function takes two pointers as parameters. It accesses the latter to read the source string, and the former to write to the destination string. As I said, **the memory areas pointed to by the parameters are not parameters on their own, but are considered global memory** and, in that function, global memory is not only accessed for reading, but also for writing. The return value derives directly from the parameters (it is the same as the first parameter), but global memory is affected by the side effect of strcpy(), making it not pure. According to this ""interpretation"" of attribute pure a functions with ""out"" arguments could not be pure.I'm always a bit worried when attribute pure is used: If the user declares a function pure, is the compiler allowed to deduce that every called function in this function is also pure?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3450,43115596,2015-10-27T12:40:42Z,src/nvim/normal.c,"@@ -3611,6 +3625,107 @@ void scroll_redraw(int up, long count)   redraw_later(VALID); } +static linenr_T longest_lnum;+/*+ * Do a horizontal scroll.  Return TRUE if the cursor moved, FALSE otherwise.+ */+int gui_do_horiz_scroll(int leftcol, bool compute_longest_lnum)+{+    /* no wrapping, no scrolling */+    if (curwin->w_p_wrap)+      return false;++    if (curwin->w_leftcol == (colnr_T)leftcol)+      return false;++    curwin->w_leftcol = (colnr_T)leftcol;++    /* When the line of the cursor is too short, move the cursor to the+     * longest visible line. */+    if (!virtual_active()+      && (colnr_T)leftcol > scroll_line_len(curwin->w_cursor.lnum))+    {+      if (compute_longest_lnum)+      {+          curwin->w_cursor.lnum = gui_find_longest_lnum();+          curwin->w_cursor.col = 0;+      } else if (longest_lnum >= curwin->w_topline+        && longest_lnum < curwin->w_botline) {+        /* Do a sanity check on ""longest_lnum"", just in case. */+        curwin->w_cursor.lnum = longest_lnum;+        curwin->w_cursor.col = 0;+      }+    }++    return leftcol_changed();+}++/*+ * Find longest visible line number.  If this is not possible (or not desired,+ * by setting 'h' in ""guioptions"") then the current line number is returned.+ */+static linenr_T gui_find_longest_lnum()+{+    linenr_T ret = 0;++    /* Calculate maximum for horizontal scrollbar.  Check for reasonable+     * line numbers, topline and botline can be invalid when displaying is+     * postponed. */+    if (curwin->w_topline <= curwin->w_cursor.lnum+      && curwin->w_botline > curwin->w_cursor.lnum+      && curwin->w_botline <= curbuf->b_ml.ml_line_count + 1)+    {+      linenr_T    lnum;+      colnr_T     n;+      long      max = 0;++      /* Use maximum of all visible lines.  Remember the lnum of the+       * longest line, closest to the cursor line.  Used when scrolling+       * below. */+      for (lnum = curwin->w_topline; lnum < curwin->w_botline; ++lnum)+      {+          n = scroll_line_len(lnum);+          if (n > (colnr_T)max)+          {+            max = n;+            ret = lnum;+          } else if (n == (colnr_T)max+            && abs((int)(lnum - curwin->w_cursor.lnum))+               < abs((int)(ret - curwin->w_cursor.lnum))) {+              ret = lnum;+          }+      }+    } else {+      /* Use cursor line only. */+      ret = curwin->w_cursor.lnum;+    }++    return ret;+}++/*+ * Return length of line ""lnum"" for horizontal scrolling.+ */+static colnr_T scroll_line_len(linenr_T lnum)+{+    char_u  *p;+    colnr_T col;+    int   w;++    p = ml_get(lnum);+    col = 0;+    if (*p != NUL)+      for (;;)+      {",@bambu ���As close as possible��� is a bad idea. We have different code style.,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3540,43249287,2015-10-28T12:38:19Z,runtime/autoload/spellfile.vim,"@@ -197,8 +197,12 @@ endfunc  function! spellfile#WritableSpellDir()   if has(""unix"")-    "" For Unix always use the $HOME/.nvim directory-    return $HOME . ""/.nvim/spell""+    "" For Unix always use the $XDG_DATA_HOME/nvim/site directory+    if exists('$XDG_DATA_HOME')+	return $HOME . $XDG_DATA_HOME . ""/nvim/site/spell""",:+1: My bad.,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3565,43574324,2015-10-31T17:58:49Z,src/nvim/screen.c,"@@ -2750,7 +2759,9 @@ win_line (           }           p_extra = NULL;           c_extra = ' ';-          n_extra = get_breakindent_win(wp, ml_get_buf(wp->w_buffer, lnum, FALSE));+          c_final = NUL;+          n_extra = get_breakindent_win(wp,+            ml_get_buf(wp->w_buffer, lnum, false));","This line should be indented under 'w' in 'wp':```+          n_extra = get_breakindent_win(wp,+                                        ml_get_buf(wp->w_buffer, lnum, false));```but since that brings the issue of line length, perhaps indenting 2 spaces after `get_breakindent_win` might be better?```+          n_extra = get_breakindent_win(wp,+                      ml_get_buf(wp->w_buffer, lnum, false));```Either way, no big deal.EDIT: I made some mistakes on this. Anyway: my suggestion is not ""in-style"" either, it just seems less awkward than splitting this line like this:```+          n_extra = get_breakindent_win(wp,+                                        ml_get_buf(wp->w_buffer,+                                                   lnum, false));```",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3565,43574341,2015-10-31T18:00:58Z,src/nvim/message.c,"@@ -1399,7 +1400,9 @@ void msg_prt_line(char_u *s, int list)   while (!got_int) {     if (n_extra > 0) {       --n_extra;-      if (c_extra)+      if (n_extra == 0 && c_final)","Please add braces to this conditional, we typically want them even when the body of the clauses is 1 line long, for readability.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/3565,43574345,2015-10-31T18:01:07Z,src/nvim/option.c,"@@ -3320,7 +3320,7 @@ static char_u *set_chars_option(char_u **varp)         if (tab[i].cp != NULL)           *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');       if (varp == &p_lcs)",Perhaps add braces to this conditional too?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3603,44185204,2015-11-06T20:42:05Z,src/nvim/eval.c,"@@ -16753,6 +16855,83 @@ static void f_visualmode(typval_T *argvars, typval_T *rettv)     curbuf->b_visual_mode_eval = NUL; } +// watcheradd(dict, key, funcref) function+static void f_watcheradd(typval_T *argvars, typval_T *rettv)+{+  if (check_restricted() || check_secure()) {+    return;+  }++  if (argvars[0].v_type != VAR_DICT ||+      argvars[1].v_type != VAR_STRING ||+      (argvars[2].v_type != VAR_FUNC && argvars[2].v_type != VAR_STRING)) {+    // Wrong argument types+    EMSG(_(e_invarg));+    return;+  }++  if (!STRLEN(argvars[1].vval.v_string)) {+    EMSG(_(""Can't use an empty string as the watched key""));+    return;+  }++  ufunc_T *func = find_ufunc(argvars[2].vval.v_string);+  if (!func) {+    // Invalid function name. Error already reported by `find_ufunc`.+    return;+  }++  func->uf_refcount++;+  DictWatcher *watcher = xmalloc(sizeof(DictWatcher));+  watcher->key_pattern = xstrdup((char *)argvars[1].vval.v_string);","Since key length is already checked I would suggest to use``` Cconst size_t key_len = STRLEN(argvars[1].vval.v_string);if (key_len == 0) {  EMSG(_(e_emptykey));}���watcher->key_pattern = xmemdupz(argvars[1].vval.v_string, key_len)```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3603,44186070,2015-11-06T20:51:26Z,src/nvim/eval.c,"@@ -21757,3 +21971,81 @@ bool eval_has_provider(char *name)    return false; }++static DictWatcher *dictwatcher_node_data(QUEUE *q)+{+  return QUEUE_DATA(q, DictWatcher, node);+}++static void dictwatcher_notify(dict_T *dict, const char *key,+    typval_T *newtv, typval_T *oldtv)+{+  typval_T argv[2];+  for (size_t i = 0; i < ARRAY_SIZE(argv); i++) {+    init_tv(argv + i);+  }++  argv[0].v_type = VAR_STRING;+  argv[0].vval.v_string = (uint8_t *)xstrdup(key);+  argv[1].v_type = VAR_DICT;+  argv[1].vval.v_dict = dict_alloc();+  argv[1].vval.v_dict->dv_refcount++;++  if (newtv) {+    dictitem_T *v = dictitem_alloc((uint8_t *)""new"");+    copy_tv(newtv, &v->di_tv);+    dict_add(argv[1].vval.v_dict, v);+  }++  if (oldtv) {+    dictitem_T *v = dictitem_alloc((uint8_t *)""old"");+    copy_tv(oldtv, &v->di_tv);+    dict_add(argv[1].vval.v_dict, v);+  }++  typval_T rettv;++  QUEUE *w;+  QUEUE_FOREACH(w, &dict->watchers) {","I predict Neovim-specific optimization principle: ���don���t touch global and buffer vars, if you must squash all settings in one `g:` subdictionary���. If this mechanizm is expected to be used by plugins for their setting then there would be _lots_ of watchers over time watching keys in `g:`. Hash servers much better here then a queue with `O(n)` querying. You can���t have any patterns in this case, but plugins usually know all of the possible settings and for others there are two things:1. subdictionaries2. I really hope that function will be added that allows watching for any events inside a dictionary, and not just specific keys (like currently `*` if I am not mistaking)",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/3603,44211640,2015-11-07T12:30:24Z,src/nvim/eval.c,"@@ -21757,3 +21971,81 @@ bool eval_has_provider(char *name)    return false; }++static DictWatcher *dictwatcher_node_data(QUEUE *q)+{+  return QUEUE_DATA(q, DictWatcher, node);+}++static void dictwatcher_notify(dict_T *dict, const char *key,+    typval_T *newtv, typval_T *oldtv)+{+  typval_T argv[2];+  for (size_t i = 0; i < ARRAY_SIZE(argv); i++) {+    init_tv(argv + i);+  }++  argv[0].v_type = VAR_STRING;+  argv[0].vval.v_string = (uint8_t *)xstrdup(key);+  argv[1].v_type = VAR_DICT;+  argv[1].vval.v_dict = dict_alloc();+  argv[1].vval.v_dict->dv_refcount++;++  if (newtv) {+    dictitem_T *v = dictitem_alloc((uint8_t *)""new"");+    copy_tv(newtv, &v->di_tv);+    dict_add(argv[1].vval.v_dict, v);+  }++  if (oldtv) {+    dictitem_T *v = dictitem_alloc((uint8_t *)""old"");+    copy_tv(oldtv, &v->di_tv);+    dict_add(argv[1].vval.v_dict, v);+  }++  typval_T rettv;++  QUEUE *w;+  QUEUE_FOREACH(w, &dict->watchers) {",">  Hash servers much better here then a queue with O(n) querying. You can���t have any patterns in this case, but plugins usually know all of the possible settings and for others there are two things:It is theoretically possible to build a DFA for matching all patterns installed in a dictionary in a single walk over the key. In this case the DFA would have to be updated after every `watcher{add,del}`), but the number of watchers would not affect match performance.(And we would still have patterns)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3603,44214251,2015-11-07T16:46:43Z,runtime/doc/eval.txt,"@@ -2664,6 +2666,36 @@ delete({fname})							*delete()* 		To delete a line from the buffer use |:delete|.  Use |:exe| 		when the line number is in a variable. +dictwatcheradd({dict}, {pattern}, {callback})		      *dictwatcheradd()*+		Adds a watcher to a dictionary. A dictionary watcher is+		identified by three components:++		- A dictionary({dict});+		- A key pattern({pattern}).+		- A function({callback}).++		After this is called, every change on {dict} and on keys+		matching {pattern} will result in {callback} being invoked.+		The {callback} receives two arguments:++		- The key which changed.+		- A dictionary containg the new and old values for the key.","I would also highly suggest to pass also a dictionary being watched. And I think you may simplify the code thus, because in this case only needed things are1. Dictionary being watched.2. Changed key.3. (optional) Old value. (Or new value, I did not check when you call this watcher: before or after value changed.)I.e. function signature will be `watcher(dict, key, ...)`. This saves you up to four allocates (dictionary, dictionary item for old value, dictionary item for new value, hash table allocate). Passing dictionary for which notification was created allows using notifications not only for options: e.g. I can imagine how you can use this feature to implement monkey-patching in some OOP implementations (i.e. you have a class dictionary where you put new method, but since instance dictionaries are separate to attach new method to all instances you need to patch them. Patching may be done in notification function, but it would be very, _very_ inconvenient to implement without passing `dict` argument).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3611,44217575,2015-11-07T21:51:55Z,src/nvim/eval.c,"@@ -21032,6 +21032,23 @@ void ex_oldfiles(exarg_T *eap)     /* Assume ""got_int"" was set to truncate the listing. */     got_int = FALSE; +    // File selection prompt on "":oldfiles!""+    if (eap->forceit) {+      quit_more = false;+      nr = prompt_for_number(false);+      msg_starthere();+      if (nr > 0) {+        char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES), nr);","Why use `get_vim_var_list()`, is `list_find_str(l, nr)` not equivalent?",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/3611,44217976,2015-11-07T22:29:10Z,src/nvim/eval.c,"@@ -21032,6 +21032,23 @@ void ex_oldfiles(exarg_T *eap)     /* Assume ""got_int"" was set to truncate the listing. */     got_int = FALSE; +    // File selection prompt on "":oldfiles!""+    if (eap->forceit) {+      quit_more = false;+      nr = prompt_for_number(false);+      msg_starthere();+      if (nr > 0) {+        char_u *p = list_find_str(get_vim_var_list(VV_OLDFILES), nr);","`get_vim_var_list()` basically gets me `v:oldfiles` and `list_find_str()` gets me the correct entry.EDIT: D'oh, you meant because I have `l` already.. right.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/3611,44218345,2015-11-07T22:59:44Z,src/nvim/eval.c,"@@ -21032,6 +21032,23 @@ void ex_oldfiles(exarg_T *eap)     /* Assume ""got_int"" was set to truncate the listing. */     got_int = FALSE; +    // File selection prompt on "":oldfiles!""+    if (eap->forceit) {+      quit_more = false;+      nr = prompt_for_number(false);+      msg_starthere();+      if (nr > 0) {","If `:oldfiles` prints 65 items, using just `<` won't allow you to select the 65th item, presumably because `list_find_str()` indexes `l` at `nr - 1`, not `nr`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3242,44235478,2015-11-09T01:41:48Z,src/nvim/os/win_defs.h,"@@ -6,16 +6,22 @@ #define TEMP_DIR_NAMES {""$TMP"", ""$TEMP"", ""$USERPROFILE"", """"} #define TEMP_FILE_PATH_MAXLEN _MAX_PATH -// Defines needed to fix the build on Windows:-// - DFLT_DIR-// - DFLT_BDIR-// - DFLT_VDIR-// - EXRC_FILE-// - VIMRC_FILE-// - SYNTAX_FNAME-// - DFLT_HELPFILE-// - SYS_VIMRC_FILE-// - SPECIAL_WILDCHAR+// Windows system-dependent file names+#ifndef SYS_VIMRC_FILE+# define SYS_VIMRC_FILE ""$VIM\\sysinit.vim""+#endif+#ifndef DFLT_HELPFILE+# define DFLT_HELPFILE  ""$VIMRUMTIME\\doc\\help.txt""+#endif+#ifndef SYNTAX_FNAME+# define SYNTAX_FNAME   ""$VIMRUNTIME\\syntax\\%s.vim""","Let's move all of these up to `globals.h` (unless you find somewhere more appropriate) and just concat `PATHSEPSTR` to use the correct separator. E.g.:``` c#ifndef SYNTAX_FNAME# define SYNTAX_FNAME   ""$VIMRUNTIME"" PATHSEPSTR ""syntax"" PATHSEPSTR ""%s.vim""#endif```It seems weird that `PATHSEPSTR` is defined in `ascii.h`, might need to move that, or define a duplicate concept specifically for use in globals.h.After this we can delete the corresponding lines in unix_defs.h.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3647,44477007,2015-11-10T22:41:39Z,test/functional/ex_cmds/oldfiles_spec.lua,"@@ -1,49 +1,92 @@-local h = require('test.functional.helpers')+local Helpers = require('test.functional.helpers')+local Screen  = require('test.functional.ui.screen') -local buf     = h.curbufmeths-local command = h.command-local eq      = h.eq-local execute = h.execute-local feed    = h.feed-local nvim    = h.nvim+local buf         = Helpers.curbufmeths+local command     = Helpers.command+local eq          = Helpers.eq+local execute     = Helpers.execute+local feed        = Helpers.feed+local nvim        = Helpers.nvim+local nvim_prog   = Helpers.nvim_prog+local set_session = Helpers.set_session+local spawn       = Helpers.spawn  local shada_file = 'test.shada' --- h.clear() uses ""-i NONE"", which is not useful for this test.-local function clear()+--+-- Helpers.clear() uses ""-i NONE"", which is not useful for this test.+--+local function reset()","prefixing it with a underscore (`_clear()`) would also be fine, to show that the semantics are the same, but the scope and implementation are different.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3647,44477228,2015-11-10T22:43:29Z,test/functional/ex_cmds/oldfiles_spec.lua,"@@ -1,49 +1,92 @@-local h = require('test.functional.helpers')+local Helpers = require('test.functional.helpers')+local Screen  = require('test.functional.ui.screen') -local buf     = h.curbufmeths-local command = h.command-local eq      = h.eq-local execute = h.execute-local feed    = h.feed-local nvim    = h.nvim+local buf         = Helpers.curbufmeths+local command     = Helpers.command+local eq          = Helpers.eq+local execute     = Helpers.execute+local feed        = Helpers.feed+local nvim        = Helpers.nvim+local nvim_prog   = Helpers.nvim_prog+local set_session = Helpers.set_session+local spawn       = Helpers.spawn","Though we haven't come up with a strong set of best practices for lua, I suggest following the patterns from other test files in the meantime, even if they aren't the best. Example: https://github.com/mhinz/neovim/blob/tests/improve-oldfiles/test/functional/ex_cmds/menu_spec.lua#L2-L4",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3651,44490338,2015-11-11T01:08:15Z,runtime/doc/options.txt,"@@ -2299,7 +2299,7 @@ A jump table for the options with a short description can be found at |Q_op|. 	directory.  If you switch this option on you should also consider 	setting the 'secure' option (see |initialization|).  Using a local 	.exrc, .nvimrc or .ngvimrc is a potential security leak, use with care!","~~I agree, although perhaps `ex_cmds2.c:2415` should be updated too. In `do_source()`, the `check_other` parameter is true for a few calls, although I'm not sure if that block is needed, as I thought nvim doesn't check for `.nvimrc` files; perhaps it's for Windows?~~",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/3339,44495516,2015-11-11T02:25:41Z,src/nvim/buffer.c,"@@ -3088,42 +3205,62 @@ build_stl_str_hl (       else         str = path_tail(NameBuff);       break;-+    }     case STL_VIM_EXPR:     /* '{' */-      itemisflag = TRUE;-      t = p;-      while (*s != '}' && *s != NUL && p + 1 < out + outlen)-        *p++ = *s++;-      if (*s != '}')            /* missing '}' or out of space */+    {+      itemisflag = true;++      // Attempt to copy the expression to evaluate into+      // the output buffer as a null-terminated string.+      char_u *t = out_p;+      while (*fmt_p != '}' && *fmt_p != NUL && out_p < out_end_p)+        *out_p++ = *fmt_p++;+      if (*fmt_p != '}')            /* missing '}' or out of space */         break;-      s++;-      *p = 0;-      p = t;+      fmt_p++;+      *out_p = 0;++      // Move our position in the output buffer+      // to the beginning of the expression+      out_p = t; +      // { Evaluate the expression++      // Store the current buffer number as a string variable       vim_snprintf((char *)tmp, sizeof(tmp), ""%d"", curbuf->b_fnum);       set_internal_string_var((char_u *)""actual_curbuf"", tmp); -      o_curbuf = curbuf;-      o_curwin = curwin;+      // Switch the curbuf and curwin to the buffer and window we are+      // evaluating the statusline for.","I am a bit on the fence about this one. One of the big issues I have with open source projects vs the codebase where I work is that everything tends to be super under-documented. If I am random person wondering how the code works, I have to know a bunch of quirks about the codebase before I can understand anything. IMHO if you are changing a global variable to something that isn't what it actually is, that deserves a comment, no matter how common it is. If we don't want the comment, we should refactor things to not rely on the global variables.That said, if you really want to, I will remove this comment.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/3339,44497205,2015-11-11T03:00:17Z,src/nvim/buffer.c,"@@ -3088,42 +3205,62 @@ build_stl_str_hl (       else         str = path_tail(NameBuff);       break;-+    }     case STL_VIM_EXPR:     /* '{' */-      itemisflag = TRUE;-      t = p;-      while (*s != '}' && *s != NUL && p + 1 < out + outlen)-        *p++ = *s++;-      if (*s != '}')            /* missing '}' or out of space */+    {+      itemisflag = true;++      // Attempt to copy the expression to evaluate into+      // the output buffer as a null-terminated string.+      char_u *t = out_p;+      while (*fmt_p != '}' && *fmt_p != NUL && out_p < out_end_p)+        *out_p++ = *fmt_p++;+      if (*fmt_p != '}')            /* missing '}' or out of space */         break;-      s++;-      *p = 0;-      p = t;+      fmt_p++;+      *out_p = 0;++      // Move our position in the output buffer+      // to the beginning of the expression+      out_p = t; +      // { Evaluate the expression++      // Store the current buffer number as a string variable       vim_snprintf((char *)tmp, sizeof(tmp), ""%d"", curbuf->b_fnum);       set_internal_string_var((char_u *)""actual_curbuf"", tmp); -      o_curbuf = curbuf;-      o_curwin = curwin;+      // Switch the curbuf and curwin to the buffer and window we are+      // evaluating the statusline for.",There is a `WITH_BUFFER` macro. It looks like similar commands exist to create a `WITH_WINDOW` macro. I would not be opposed to creating that and using it here.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3339,44505161,2015-11-11T06:29:37Z,src/nvim/buffer.c,"@@ -3107,42 +3222,54 @@ build_stl_str_hl (       else         str = path_tail(NameBuff);       break;-+    }     case STL_VIM_EXPR:     /* '{' */-      itemisflag = TRUE;-      t = p;-      while (*s != '}' && *s != NUL && p + 1 < out + outlen)-        *p++ = *s++;-      if (*s != '}')            /* missing '}' or out of space */+    {+      itemisflag = true;++      // Attempt to copy the expression to evaluate into+      // the output buffer as a null-terminated string.+      char_u *t = out_p;+      while (*fmt_p != '}' && *fmt_p != NUL && out_p < out_end_p)+        *out_p++ = *fmt_p++;+      if (*fmt_p != '}')            /* missing '}' or out of space */         break;-      s++;-      *p = 0;-      p = t;+      fmt_p++;+      *out_p = 0;++      // Move our position in the output buffer+      // to the beginning of the expression+      out_p = t;++      // { Evaluate the expression +      // Store the current buffer number as a string variable       vim_snprintf((char *)tmp, sizeof(tmp), ""%d"", curbuf->b_fnum);       set_internal_string_var((char_u *)""actual_curbuf"", tmp); -      o_curbuf = curbuf;-      o_curwin = curwin;-      curwin = wp;-      curbuf = wp->w_buffer;+      // Evaluate the expression using the correct window+      WITH_WINDOW(wp, {+        // Note: The result stored in `t` is unused.+        str = eval_to_string_safe(out_p, &t, use_sandbox);+      });","Sadly, this is not equivalent because `switch_win()` calls `block_autocmds()`. Test case:``` vim    autocmd! TermOpen * echom 'termopen' localtime()    function! Foo()      doautocmd TermOpen    endfunction    set statusline=%{Foo()}```The autocmd is not triggered by statusline evaluation (""No matching autocmds"" is reported every time statusline redraws).Perhaps `WITH_WINDOW` could take a parameter which prevents disabling of autocmds?Note that `update_topline_win()` potentially has the same issue.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3339,44507563,2015-11-11T07:28:35Z,src/nvim/buffer.c,"@@ -3272,212 +3433,362 @@ build_stl_str_hl (       break;      case STL_HIGHLIGHT:-      t = s;-      while (*s != '#' && *s != NUL)-        ++s;-      if (*s == '#') {+    {+      // { The name of the highlight is surrounded by `#`+      char_u *t = fmt_p;+      while (*fmt_p != '#' && *fmt_p != NUL) {+        ++fmt_p;+      }+      // }++      // Create a highlight item based on the name+      if (*fmt_p == '#') {         item[curitem].type = Highlight;-        item[curitem].start = p;-        item[curitem].minwid = -syn_namen2id(t, (int)(s - t));+        item[curitem].start = out_p;+        item[curitem].minwid = -syn_namen2id(t, (int)(fmt_p - t));         curitem++;+        fmt_p++;       }-      if (*s != NUL)-        ++s;       continue;     }+    } -    item[curitem].start = p;+    // If we made it this far, the item is normal and starts at+    // our current position in the output buffer.+    // Non-normal items would have `continued`.+    item[curitem].start = out_p;     item[curitem].type = Normal;++    // Copy the item string into the output buffer     if (str != NULL && *str) {-      t = str;+      // { Skip the leading `,` or ` ` if the item is a flag+      //  and the proper conditions are met+      char_u *t = str;       if (itemisflag) {         if ((t[0] && t[1])             && ((!prevchar_isitem && *t == ',')                 || (prevchar_isflag && *t == ' ')))           t++;-        prevchar_isflag = TRUE;+        prevchar_isflag = true;       }-      l = vim_strsize(t);-      if (l > 0)-        prevchar_isitem = TRUE;+      // }++      long l = vim_strsize(t);++      // If this item is non-empty, record that the last thing+      // we put in the output buffer was an item+      if (l > 0) {+        prevchar_isitem = true;+      }++      // If the item is too wide, truncate it from the beginning       if (l > maxwid) {         while (l >= maxwid)           if (has_mbyte) {             l -= ptr2cells(t);             t += (*mb_ptr2len)(t);-          } else+          } else {             l -= byte2cells(*t++);-        if (p + 1 >= out + outlen)+          }++        // Early out if there isn't enough room for the truncation marker+        if (out_p >= out_end_p)           break;-        *p++ = '<';++        // Add the truncation marker+        *out_p++ = '<';       }++      // If the item is right aligned and not wide enough,+      // pad with fill characters.       if (minwid > 0) {-        for (; l < minwid && p + 1 < out + outlen; l++) {-          /* Don't put a ""-"" in front of a digit. */+        for (; l < minwid && out_p < out_end_p; l++) {+          // Don't put a ""-"" in front of a digit.           if (l + 1 == minwid && fillchar == '-' && ascii_isdigit(*t))-            *p++ = ' ';+            *out_p++ = ' ';           else-            *p++ = fillchar;+            *out_p++ = fillchar;         }         minwid = 0;-      } else+      } else {+        // Note: The negative value denotes a left aligned item.+        //       Here we switch the minimum width back to a positive value.         minwid *= -1;-      while (*t && p + 1 < out + outlen) {-        *p++ = *t++;-        /* Change a space by fillchar, unless fillchar is '-' and a-         * digit follows. */-        if (fillable && p[-1] == ' '+      }++      // { Copy the string text into the output buffer+      while (*t && out_p < out_end_p) {+        *out_p++ = *t++;+        // Change a space by fillchar, unless fillchar is '-' and a+        // digit follows.+        if (fillable && out_p[-1] == ' '             && (!ascii_isdigit(*t) || fillchar != '-'))-          p[-1] = fillchar;+          out_p[-1] = fillchar;       }-      for (; l < minwid && p + 1 < out + outlen; l++)-        *p++ = fillchar;-    } else if (num >= 0) {-      int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));-      char_u nstr[20];+      // } -      if (p + 20 >= out + outlen)+      // For left-aligned items, fill any remaining space with the fillchar+      for (; l < minwid && out_p < out_end_p; l++) {+        *out_p++ = fillchar;+      }++    // Otherwise if the item is a number, copy that to the output buffer.+    } else if (num >= 0) {+      if (out_p + 20 > out_end_p)         break;                  /* not sufficient space */-      prevchar_isitem = TRUE;-      t = nstr;+      prevchar_isitem = true;++      // { Build the formatting string+      char_u nstr[20];+      char_u *t = nstr;       if (opt == STL_VIRTCOL_ALT) {         *t++ = '-';         minwid--;       }       *t++ = '%';-      if (zeropad)+      if (zeropad) {         *t++ = '0';+      }++      // Note: The `*` means we take the width as one of the arguments       *t++ = '*';-      *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');+      *t++ = (char_u) (base == kNumBaseHexadecimal ? 'X'+                        : (base == kNumBaseOctal ? 'o'+                        : 'd'));       *t = 0;+      // }++      // { Determine how many characters the number will take up when printed+      //  Note: We have to cast the base because the compiler uses+      //        unsigned ints for the enum values.+      long num_chars = 1;+      for (long n = num; n >= (int) base; n /= (int) base) {+        num_chars++;+      } -      for (n = num, l = 1; n >= nbase; n /= nbase)-        l++;-      if (opt == STL_VIRTCOL_ALT)-        l++;-      if (l > maxwid) {-        l += 2;-        n = l - maxwid;-        while (l-- > maxwid)-          num /= nbase;+      // VIRTCOL_ALT takes up an extra character because+      // of the `-` we added above.+      if (opt == STL_VIRTCOL_ALT) {+        num_chars++;+      }+      // }++      size_t remaining_buf_len = (out_end_p - out_p) + 1;++      // If the number is going to take up too much room+      // Figure out the approximate number in ""scientific"" type notation.+      // Ex: 14532 with maxwid of 4 -> '14>3'+      if (num_chars > maxwid) {+        // Add two to the width because the power piece will take+        // two extra characters+        num_chars += 2;++        // How many extra characters there are+        long n = num_chars - maxwid;++        // { Reduce the number by base^n+        while (num_chars-- > maxwid) {+          num /= base;+        }+        // }++        // { Add the format string for the exponent bit         *t++ = '>';         *t++ = '%';+        // Use the same base as the first number         *t = t[-3];         *++t = 0;-        vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,+        // }++        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,             0, num, n);-      } else-        vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,+      } else {+        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,             minwid, num);-      p += STRLEN(p);-    } else+      }++      // Advance the output buffer position to the end of the+      // number we just printed+      out_p += STRLEN(out_p);++    // Otherwise, there was nothing to print so mark the item as empty+    } else {       item[curitem].type = Empty;+    } -    if (opt == STL_VIM_EXPR)+    // Free the string buffer if we allocated it.+    // Note: This is not needed if `str` is pointing at `tmp`+    if (opt == STL_VIM_EXPR) {       xfree(str);+    }      if (num >= 0 || (!itemisflag && str && *str))-      prevchar_isflag = FALSE;              /* Item not NULL, but not a flag */+      prevchar_isflag = false;              /* Item not NULL, but not a flag */++    // Item processed, move to the next     curitem++;   }-  *p = NUL;-  itemcnt = curitem; -  if (usefmt != fmt)+  // Null terminate the output buffer+  *out_p = NUL;+  int itemcnt = curitem;++  // Free the format buffer if we allocated it internally+  if (usefmt != fmt) {     xfree(usefmt);+  } -  width = vim_strsize(out);+  int width = vim_strsize(out);   if (maxwidth > 0 && width > maxwidth) {-    /* Result is too long, must truncate somewhere. */-    l = 0;-    if (itemcnt == 0)-      s = out;-    else {-      for (; l < itemcnt; l++)-        if (item[l].type == Trunc) {-          /* Truncate at %< item. */-          s = item[l].start;+    // Result is too long, must truncate somewhere.+    int item_idx = 0;+    char_u *trunc_p;++    // If there are no items, truncate from beginning+    if (itemcnt == 0) {+      trunc_p = out;++    // Otherwise, look for the truncation item+    } else {+      // Default to truncating at the first item+      trunc_p = item[0].start;+      item_idx = 0;++      for (int i = 0; i < itemcnt; i++)+        if (item[i].type == Trunc) {+          // Truncate at %< item.+          trunc_p = item[i].start;+          item_idx = i;           break;         }-      if (l == itemcnt) {-        /* No %< item, truncate first item. */-        s = item[0].start;-        l = 0;-      }     } -    if (width - vim_strsize(s) >= maxwidth) {-      /* Truncation mark is beyond max length */+    // If the truncation point we found is beyond the maximum+    // length of the string, truncate the end of the string.+    if (width - vim_strsize(trunc_p) >= maxwidth) {+      // If we are using a multi-byte encoding, walk from the beginning of the+      // string to find the last character that will fit.       if (has_mbyte) {-        s = out;+        trunc_p = out;         width = 0;         for (;; ) {-          width += ptr2cells(s);+          width += ptr2cells(trunc_p);           if (width >= maxwidth)             break;-          s += (*mb_ptr2len)(s);++          // Note: Only advance the pointer if the next+          //       character will fit in the available output space+          trunc_p += (*mb_ptr2len)(trunc_p);         }-        /* Fill up for half a double-wide character. */-        while (++width < maxwidth)-          *s++ = fillchar;-      } else-        s = out + maxwidth - 1;-      for (l = 0; l < itemcnt; l++)-        if (item[l].start > s)+        // Fill up for half a double-wide character.+        // XXX : This seems impossible given the exit condition above?+        while (++width < maxwidth) {+          *trunc_p++ = fillchar;+        }++      // Otherwise put the truncation point at the end, leaving enough room+      // for a single-character truncation marker+      } else {+        trunc_p = out + maxwidth - 1;+      }++      // Ignore any items in the statusline that occur after+      // the truncation point+      for (int i = 0; i < itemcnt; i++) {+        if (item[i].start > trunc_p) {+          itemcnt = i;           break;-      itemcnt = l;-      *s++ = '>';-      *s = 0;+        }+      }++      // Truncate the output+      *trunc_p++ = '>';+      *trunc_p = 0;++    // Truncate at the truncation point we found     } else {+      // { Determine how many bytes to remove+      long trunc_len;       if (has_mbyte) {-        n = 0;+        trunc_len = 0;         while (width >= maxwidth) {-          width -= ptr2cells(s + n);-          n += (*mb_ptr2len)(s + n);+          width     -= ptr2cells(trunc_p + trunc_len);+          trunc_len += (*mb_ptr2len)(trunc_p + trunc_len);         }-      } else-        n = width - maxwidth + 1;-      p = s + n;-      STRMOVE(s + 1, p);-      *s = '<';+      } else {+        // Truncate an extra character so we can insert our `<`.+        trunc_len = (width - maxwidth) + 1;+      }+      // }++      // { Truncate the string+      char_u *trunc_end_p = trunc_p + trunc_len;+      STRMOVE(trunc_p + 1, trunc_end_p); -      /* Fill up for half a double-wide character. */+      // Put a `<` to mark where we truncated at+      *trunc_p = '<';++      // Advance the pointer to the end of the string+      trunc_p = trunc_p + STRLEN(trunc_p);","Correct me if I'm wrong: on each loop, `*trunc_p++ = fillchar;` overwrites the previous `NUL`, then the pointer is incremented and its value set to `NUL`. That means `STRLEN(trunc_p)` would be longer after each loop.",
1585463,bohrshaw,https://api.github.com/repos/neovim/neovim/pulls/3078,44610990,2015-11-12T01:17:46Z,runtime/doc/windows.txt,"@@ -999,6 +1000,21 @@ list of buffers. |unlisted-buffer| 		    +	a modified buffer 		    x   a buffer with read errors +		[flags] can be a combination of the following characters,+		which restrict the buffers to be listed:+			+	modified buffers+			-	buffers with 'modifiable' off+			=	readonly buffers+			a	active buffers+			u	unloaded buffers (overrides the ""!"")","Should 'u' means ""unlisted"" buffers instead of ""unloaded""? @mhinzFor example, `:ls u` would list active/visible HELP buffers which are unlisted but actually loaded.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3229,44851102,2015-11-14T01:09:08Z,src/nvim/eval.c,"@@ -10054,23 +10054,68 @@ static void f_getcmdwintype(typval_T *argvars, typval_T *rettv)   rettv->vval.v_string[0] = cmdwin_type; } -/*- * ""getcwd()"" function- */+/// `getcwd('s')` function+///+/// @pre The type of the argument `s` must be a string or nothing. static void f_getcwd(typval_T *argvars, typval_T *rettv) {-  char_u      *cwd;+  // Pre-condition+  if (argvars->v_type != VAR_STRING && argvars->v_type != VAR_UNKNOWN) {+    EMSG(_(e_invarg));+    return;+  }++  char_u *cwd = NULL;                    // current working directory to print+  char_u *scp = argvars->vval.v_string;  // scope    rettv->v_type = VAR_STRING;   rettv->vval.v_string = NULL;+   cwd = xmalloc(MAXPATHL);-  if (os_dirname(cwd, MAXPATHL) != FAIL) {-    rettv->vval.v_string = vim_strsave(cwd);+  cwd[0] = '\0';  // initialize to empty string++  // If there is no argument return the current working directory.+  // This is the same behaviour as in Vim.+  //+  // Also if global is requested and the current working directory is the+  // global one.+  if (argvars->v_type == VAR_UNKNOWN || (!globaldir && scp[0] == 'g')) {+    if (os_dirname(cwd, MAXPATHL) != FAIL) {+      goto prepare_result;+    } else {+      EMSG(""E41: Could not allocate memory to display path."");+      xfree(cwd);+      return;+    }+  }++  char_u *from = NULL;  // The original string to copy++  switch (scp[0]) {  // only check the first character+    case 'g':  // global+      from = globaldir;+      break;+    case 't':  // tab+      from = curtab->localdir;+      break;+    case 'w':  // window+      from = curwin->w_localdir;+      break;+    default:+      EMSG(""E740: valid arguments are either 'g', 't', 'w', or nothing."");","@Pyrohh Check out #387, specifically a **_huge**_ list of identical error messages replaced with something else. I am completely against the tradition of writing error messages which say only that there was some problem.",
1002908,war1025,https://api.github.com/repos/neovim/neovim/pulls/3339,44862323,2015-11-14T19:13:52Z,src/nvim/buffer.c,"@@ -3272,212 +3433,362 @@ build_stl_str_hl (       break;      case STL_HIGHLIGHT:-      t = s;-      while (*s != '#' && *s != NUL)-        ++s;-      if (*s == '#') {+    {+      // { The name of the highlight is surrounded by `#`+      char_u *t = fmt_p;+      while (*fmt_p != '#' && *fmt_p != NUL) {+        ++fmt_p;+      }+      // }++      // Create a highlight item based on the name+      if (*fmt_p == '#') {         item[curitem].type = Highlight;-        item[curitem].start = p;-        item[curitem].minwid = -syn_namen2id(t, (int)(s - t));+        item[curitem].start = out_p;+        item[curitem].minwid = -syn_namen2id(t, (int)(fmt_p - t));         curitem++;+        fmt_p++;       }-      if (*s != NUL)-        ++s;       continue;     }+    } -    item[curitem].start = p;+    // If we made it this far, the item is normal and starts at+    // our current position in the output buffer.+    // Non-normal items would have `continued`.+    item[curitem].start = out_p;     item[curitem].type = Normal;++    // Copy the item string into the output buffer     if (str != NULL && *str) {-      t = str;+      // { Skip the leading `,` or ` ` if the item is a flag+      //  and the proper conditions are met+      char_u *t = str;       if (itemisflag) {         if ((t[0] && t[1])             && ((!prevchar_isitem && *t == ',')                 || (prevchar_isflag && *t == ' ')))           t++;-        prevchar_isflag = TRUE;+        prevchar_isflag = true;       }-      l = vim_strsize(t);-      if (l > 0)-        prevchar_isitem = TRUE;+      // }++      long l = vim_strsize(t);++      // If this item is non-empty, record that the last thing+      // we put in the output buffer was an item+      if (l > 0) {+        prevchar_isitem = true;+      }++      // If the item is too wide, truncate it from the beginning       if (l > maxwid) {         while (l >= maxwid)           if (has_mbyte) {             l -= ptr2cells(t);             t += (*mb_ptr2len)(t);-          } else+          } else {             l -= byte2cells(*t++);-        if (p + 1 >= out + outlen)+          }++        // Early out if there isn't enough room for the truncation marker+        if (out_p >= out_end_p)           break;-        *p++ = '<';++        // Add the truncation marker+        *out_p++ = '<';       }++      // If the item is right aligned and not wide enough,+      // pad with fill characters.       if (minwid > 0) {-        for (; l < minwid && p + 1 < out + outlen; l++) {-          /* Don't put a ""-"" in front of a digit. */+        for (; l < minwid && out_p < out_end_p; l++) {+          // Don't put a ""-"" in front of a digit.           if (l + 1 == minwid && fillchar == '-' && ascii_isdigit(*t))-            *p++ = ' ';+            *out_p++ = ' ';           else-            *p++ = fillchar;+            *out_p++ = fillchar;         }         minwid = 0;-      } else+      } else {+        // Note: The negative value denotes a left aligned item.+        //       Here we switch the minimum width back to a positive value.         minwid *= -1;-      while (*t && p + 1 < out + outlen) {-        *p++ = *t++;-        /* Change a space by fillchar, unless fillchar is '-' and a-         * digit follows. */-        if (fillable && p[-1] == ' '+      }++      // { Copy the string text into the output buffer+      while (*t && out_p < out_end_p) {+        *out_p++ = *t++;+        // Change a space by fillchar, unless fillchar is '-' and a+        // digit follows.+        if (fillable && out_p[-1] == ' '             && (!ascii_isdigit(*t) || fillchar != '-'))-          p[-1] = fillchar;+          out_p[-1] = fillchar;       }-      for (; l < minwid && p + 1 < out + outlen; l++)-        *p++ = fillchar;-    } else if (num >= 0) {-      int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));-      char_u nstr[20];+      // } -      if (p + 20 >= out + outlen)+      // For left-aligned items, fill any remaining space with the fillchar+      for (; l < minwid && out_p < out_end_p; l++) {+        *out_p++ = fillchar;+      }++    // Otherwise if the item is a number, copy that to the output buffer.+    } else if (num >= 0) {+      if (out_p + 20 > out_end_p)         break;                  /* not sufficient space */-      prevchar_isitem = TRUE;-      t = nstr;+      prevchar_isitem = true;++      // { Build the formatting string+      char_u nstr[20];+      char_u *t = nstr;       if (opt == STL_VIRTCOL_ALT) {         *t++ = '-';         minwid--;       }       *t++ = '%';-      if (zeropad)+      if (zeropad) {         *t++ = '0';+      }++      // Note: The `*` means we take the width as one of the arguments       *t++ = '*';-      *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');+      *t++ = (char_u) (base == kNumBaseHexadecimal ? 'X'+                        : (base == kNumBaseOctal ? 'o'+                        : 'd'));       *t = 0;+      // }++      // { Determine how many characters the number will take up when printed+      //  Note: We have to cast the base because the compiler uses+      //        unsigned ints for the enum values.+      long num_chars = 1;+      for (long n = num; n >= (int) base; n /= (int) base) {+        num_chars++;+      } -      for (n = num, l = 1; n >= nbase; n /= nbase)-        l++;-      if (opt == STL_VIRTCOL_ALT)-        l++;-      if (l > maxwid) {-        l += 2;-        n = l - maxwid;-        while (l-- > maxwid)-          num /= nbase;+      // VIRTCOL_ALT takes up an extra character because+      // of the `-` we added above.+      if (opt == STL_VIRTCOL_ALT) {+        num_chars++;+      }+      // }++      size_t remaining_buf_len = (out_end_p - out_p) + 1;++      // If the number is going to take up too much room+      // Figure out the approximate number in ""scientific"" type notation.+      // Ex: 14532 with maxwid of 4 -> '14>3'+      if (num_chars > maxwid) {+        // Add two to the width because the power piece will take+        // two extra characters+        num_chars += 2;++        // How many extra characters there are+        long n = num_chars - maxwid;++        // { Reduce the number by base^n+        while (num_chars-- > maxwid) {+          num /= base;+        }+        // }++        // { Add the format string for the exponent bit         *t++ = '>';         *t++ = '%';+        // Use the same base as the first number         *t = t[-3];         *++t = 0;-        vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,+        // }++        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,             0, num, n);-      } else-        vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,+      } else {+        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,             minwid, num);-      p += STRLEN(p);-    } else+      }++      // Advance the output buffer position to the end of the+      // number we just printed+      out_p += STRLEN(out_p);++    // Otherwise, there was nothing to print so mark the item as empty+    } else {       item[curitem].type = Empty;+    } -    if (opt == STL_VIM_EXPR)+    // Free the string buffer if we allocated it.+    // Note: This is not needed if `str` is pointing at `tmp`+    if (opt == STL_VIM_EXPR) {       xfree(str);+    }      if (num >= 0 || (!itemisflag && str && *str))-      prevchar_isflag = FALSE;              /* Item not NULL, but not a flag */+      prevchar_isflag = false;              /* Item not NULL, but not a flag */++    // Item processed, move to the next     curitem++;   }-  *p = NUL;-  itemcnt = curitem; -  if (usefmt != fmt)+  // Null terminate the output buffer+  *out_p = NUL;+  int itemcnt = curitem;++  // Free the format buffer if we allocated it internally+  if (usefmt != fmt) {     xfree(usefmt);+  } -  width = vim_strsize(out);+  int width = vim_strsize(out);   if (maxwidth > 0 && width > maxwidth) {-    /* Result is too long, must truncate somewhere. */-    l = 0;-    if (itemcnt == 0)-      s = out;-    else {-      for (; l < itemcnt; l++)-        if (item[l].type == Trunc) {-          /* Truncate at %< item. */-          s = item[l].start;+    // Result is too long, must truncate somewhere.+    int item_idx = 0;+    char_u *trunc_p;++    // If there are no items, truncate from beginning+    if (itemcnt == 0) {+      trunc_p = out;++    // Otherwise, look for the truncation item+    } else {+      // Default to truncating at the first item+      trunc_p = item[0].start;+      item_idx = 0;++      for (int i = 0; i < itemcnt; i++)+        if (item[i].type == Trunc) {+          // Truncate at %< item.+          trunc_p = item[i].start;+          item_idx = i;           break;         }-      if (l == itemcnt) {-        /* No %< item, truncate first item. */-        s = item[0].start;-        l = 0;-      }     } -    if (width - vim_strsize(s) >= maxwidth) {-      /* Truncation mark is beyond max length */+    // If the truncation point we found is beyond the maximum+    // length of the string, truncate the end of the string.+    if (width - vim_strsize(trunc_p) >= maxwidth) {+      // If we are using a multi-byte encoding, walk from the beginning of the+      // string to find the last character that will fit.       if (has_mbyte) {-        s = out;+        trunc_p = out;         width = 0;         for (;; ) {-          width += ptr2cells(s);+          width += ptr2cells(trunc_p);           if (width >= maxwidth)             break;-          s += (*mb_ptr2len)(s);++          // Note: Only advance the pointer if the next+          //       character will fit in the available output space+          trunc_p += (*mb_ptr2len)(trunc_p);         }-        /* Fill up for half a double-wide character. */-        while (++width < maxwidth)-          *s++ = fillchar;-      } else-        s = out + maxwidth - 1;-      for (l = 0; l < itemcnt; l++)-        if (item[l].start > s)+        // Fill up for half a double-wide character.+        // XXX : This seems impossible given the exit condition above?+        while (++width < maxwidth) {+          *trunc_p++ = fillchar;+        }++      // Otherwise put the truncation point at the end, leaving enough room+      // for a single-character truncation marker+      } else {+        trunc_p = out + maxwidth - 1;+      }++      // Ignore any items in the statusline that occur after+      // the truncation point+      for (int i = 0; i < itemcnt; i++) {+        if (item[i].start > trunc_p) {+          itemcnt = i;           break;-      itemcnt = l;-      *s++ = '>';-      *s = 0;+        }+      }++      // Truncate the output+      *trunc_p++ = '>';+      *trunc_p = 0;++    // Truncate at the truncation point we found     } else {+      // { Determine how many bytes to remove+      long trunc_len;       if (has_mbyte) {-        n = 0;+        trunc_len = 0;         while (width >= maxwidth) {-          width -= ptr2cells(s + n);-          n += (*mb_ptr2len)(s + n);+          width     -= ptr2cells(trunc_p + trunc_len);+          trunc_len += (*mb_ptr2len)(trunc_p + trunc_len);         }-      } else-        n = width - maxwidth + 1;-      p = s + n;-      STRMOVE(s + 1, p);-      *s = '<';+      } else {+        // Truncate an extra character so we can insert our `<`.+        trunc_len = (width - maxwidth) + 1;+      }+      // }++      // { Truncate the string+      char_u *trunc_end_p = trunc_p + trunc_len;+      STRMOVE(trunc_p + 1, trunc_end_p); -      /* Fill up for half a double-wide character. */+      // Put a `<` to mark where we truncated at+      *trunc_p = '<';++      // Advance the pointer to the end of the string+      trunc_p = trunc_p + STRLEN(trunc_p);","The string is getting longer after each loop, however we are also moving `trunc_p` a character ahead each loop.`STRLEN(trunc_p)` counts the number of characters until a null is found starting from `trunc_p`, which at the end of the loop we just set to `NUL`. So `STRLEN(trunc_p)` has to be `0` on each subsequent loop.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3667,44994566,2015-11-16T22:30:41Z,src/nvim/edit.c,"@@ -7045,16 +7074,18 @@ static void ins_ctrl_hat(void)   status_redraw_curbuf(); } -/*- * Handle ESC in insert mode.- * Returns TRUE when leaving insert mode, FALSE when going to repeat the- * insert.- */-static int-ins_esc (+/// Handle ESC in insert mode.+///+/// @param count+/// @param cmdchar+/// @param nomove  When true, don't move the cursor.+///+/// @return true when leaving insert mode, false when going to repeat the+///         insert.+static bool ins_esc(",Signatures should be joined to single line (as long as it fits),
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3752,46073564,2015-11-28T00:04:49Z,CONTRIBUTING.md,"@@ -154,48 +131,19 @@ The purpose of these guidelines is to *make reviews easier* and make the     - Granularity helps, but it's conceptual size that matters, not extent size.",I think this section is too long; also the `activity/scope-oriented` thing is a bit too abstract.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46077758,2015-11-28T08:43:01Z,src/nvim/option.c,"@@ -3822,8 +3861,22 @@ set_bool_option (    * End of handling side effects for bool options.    */ +  /* after handling side effects, call autocommand */+   options[opt_idx].flags |= P_WAS_SET; +  if (!starting) {+    char_u buf_old[2], buf_new[2], buf_type[7];+    vim_snprintf((char *)buf_old, 2, ""%d"", old_value ? TRUE: FALSE);+    vim_snprintf((char *)buf_new, 2, ""%d"", value ? TRUE: FALSE);+    vim_snprintf((char *)buf_type, 7, ""%s"", (opt_flags & OPT_LOCAL) ? ""local"" : ""global"");",This looks like too long line.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46077788,2015-11-28T08:46:27Z,test/functional/legacy/autocmd_option_spec.lua,"@@ -0,0 +1,128 @@+local helpers = require('test.functional.helpers')+local clear, nvim, eq = helpers.clear, helpers.nvim, helpers.eq+local source, execute = helpers.source, helpers.execute++describe('au OptionSet', function()+  setup(clear)++  describe('with * as <amatch>', function()+    describe('matches when being set any option', function()++      local function expected_str(option, oldval, newval, scope)+        return ''+          .. string.format('Autocmd Option: <%s>,', option)+          .. string.format(' OldVal: <%s>,', oldval)+          .. string.format(' NewVal: <%s>,', newval)+          .. string.format(' Scope: <%s>', scope)+      end++      local function get_result()+        return nvim('get_var', 'ret')+      end++      local function expected_combination(option, oldval, newval, scope)+        eq(expected_str(option, oldval, newval, scope), get_result())+      end++      local function expected_empty()+        eq('', get_result())+      end++      setup(function()++        source([[+          fu! AutoCommand(match)+            let g:ret.=printf('Autocmd Option: <%s>,', a:match)+            let g:ret.=printf(' OldVal: <%s>,', v:option_old)+            let g:ret.=printf(' NewVal: <%s>,', v:option_new)+            let g:ret.=printf(' Scope: <%s>', v:option_type)","`g:ret` may be a list `[a:match, v:option_old, v:option_new, v:option_type]`. And this list may be matched directly in place of using `expected_str`. Unlike Vim we are not using `.ok` files and plain string matching always, so there is no need to add additional code for dumping the result.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46077848,2015-11-28T08:53:26Z,test/functional/legacy/autocmd_option_spec.lua,"@@ -0,0 +1,128 @@+local helpers = require('test.functional.helpers')+local clear, nvim, eq = helpers.clear, helpers.nvim, helpers.eq+local source, execute = helpers.source, helpers.execute++describe('au OptionSet', function()+  setup(clear)++  describe('with * as <amatch>', function()",`*` is _not_ `<amatch>`. `*` is a pattern. `<amatch>` is the result of the pattern matching.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46077860,2015-11-28T08:55:09Z,test/functional/legacy/autocmd_option_spec.lua,"@@ -0,0 +1,128 @@+local helpers = require('test.functional.helpers')+local clear, nvim, eq = helpers.clear, helpers.nvim, helpers.eq+local source, execute = helpers.source, helpers.execute++describe('au OptionSet', function()+  setup(clear)++  describe('with * as <amatch>', function()",Missing test that checks specific pattern.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46081042,2015-11-28T15:49:32Z,src/nvim/option.c,"@@ -1788,6 +1795,21 @@ do_set (             /* If error detected, print the error message. */             if (errmsg != NULL)               goto skip;+            if (saved_origval != NULL) {+              char_u buf_type[7];++              vim_snprintf((char *)buf_type, 7, ""%s"",","It is better to use `ARRAY_SIZE(buf_type)` in place of 7, even though replacing `snprintf` with `vim_snprintf` will silence these warnings. Also I would suggest using `char buf_type[7]`: in any case there will be one cast, but cast to `char_u` with ���proper��� base type is better then cast to `char` with deprecated type.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46081120,2015-11-28T15:54:35Z,test/functional/legacy/autocmd_option_spec.lua,"@@ -0,0 +1,120 @@+local helpers = require('test.functional.helpers')+local clear, nvim, eq = helpers.clear, helpers.nvim, helpers.eq+local source, execute = helpers.source, helpers.execute++describe('au OptionSet', function()+  describe('with * as <amatch>', function()","Still `*` is not `<amatch>`, it is a pattern.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46081231,2015-11-28T16:04:34Z,test/functional/legacy/autocmd_option_spec.lua,"@@ -0,0 +1,120 @@+local helpers = require('test.functional.helpers')+local clear, nvim, eq = helpers.clear, helpers.nvim, helpers.eq+local source, execute = helpers.source, helpers.execute++describe('au OptionSet', function()+  describe('with * as <amatch>', function()+    describe('matches when being set any option', function()","You should do something with test names: this way they look like ���au OptionSet with \* as &lt;amatch> **_matches**_ when being set any option **_should set**_ several global list and number option��� which is incorrect. Note the naming: first argument to `describe` should show what tests describes and it should not contain any verbs. This is basically why function is named `describe`. Functions `it` actually describe the behaviour, `it` plus first argument should read like a sentence. So ���matches��� can only be in a `it` argument, but not here or you will get weird results. I do not really see why you need this third `describe` call, two `describe`s are enough.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46081709,2015-11-28T16:39:44Z,src/nvim/option.c,"@@ -3822,8 +3865,25 @@ set_bool_option (    * End of handling side effects for bool options.    */ +  // after handling side effects, call autocommand+   options[opt_idx].flags |= P_WAS_SET; +  if (!starting) {+    char_u buf_old[2], buf_new[2], buf_type[7];+    vim_snprintf((char *)buf_old, 2, ""%d"", old_value ? true: false);+    vim_snprintf((char *)buf_new, 2, ""%d"", value ? true: false);","By the way, `true` and `false` have single byte `_Bool` type. `%d` expects >=2 bytes (system-dependent) `int`. I think you need a cast just in case.",
199728,watiko,https://api.github.com/repos/neovim/neovim/pulls/3753,46089522,2015-11-29T09:30:29Z,src/nvim/option.c,"@@ -3822,8 +3865,25 @@ set_bool_option (    * End of handling side effects for bool options.    */ +  // after handling side effects, call autocommand+   options[opt_idx].flags |= P_WAS_SET; +  if (!starting) {+    char_u buf_old[2], buf_new[2], buf_type[7];+    vim_snprintf((char *)buf_old, 2, ""%d"", old_value ? true: false);+    vim_snprintf((char *)buf_new, 2, ""%d"", value ? true: false);","> %d expects >=2 bytes (system-dependent) intIs that true? > | conversion specifier | description |> | :-- | :-: |> | d,i | The **int** argument is converted to signed decimal in the style _[���]dddd_. The precision specifies the minimum number of digits to appear; if the value being converted can be represented in fewer digits, it is expanded with leading zeros. The default precision is 1. The result of converting a zero value with a precision of zero is no characters. |and> ### integer promotion> - The rank of **_Bool** shall be less than the rank of all other standard integer types.> - The following may be used in an expression wherever an **int** or **unsigned int** may>   be used:>   - An object or expression with an integer type whose integer conversion rank is less>     than or equal to the rank of **int** and **unsigned int**.> - If an **int** can represent all values of the original type, the value is converted to an **int**;>   otherwise, it is converted to an **unsigned int**. These are called the _integer>   promotions_.> -  The integer promotions preserve value including sign.cf : http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdfImplicit(correct thunks to default argument promotions(using integer promotion internally)):``` cvim_snprintf((char *)buf_new, 2, ""%d"", value ? true: false)```explicit(of cause correct):``` cvim_snprintf((char *)buf_new, 2, ""%d"", value ? (int)true: (int)false)vim_snprintf((char *)buf_new, 2, ""%d"", (int)(value ? true: false))```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3753,46090434,2015-11-29T10:41:47Z,src/nvim/option.c,"@@ -3822,8 +3865,25 @@ set_bool_option (    * End of handling side effects for bool options.    */ +  // after handling side effects, call autocommand+   options[opt_idx].flags |= P_WAS_SET; +  if (!starting) {+    char_u buf_old[2], buf_new[2], buf_type[7];+    vim_snprintf((char *)buf_old, 2, ""%d"", old_value ? true: false);+    vim_snprintf((char *)buf_new, 2, ""%d"", value ? true: false);","Though no, you are right about this: there are default promotions performed when calling functions, and one of this default promotion is integer promotion which promotes every integer having rank less then `int` to `int` (or `unsigned`).���Integer promotions��� are in C99, 6.3.1.1, end of paragraph 2:> If an int can represent all values of the original type, the value is converted to an int;> otherwise, it is converted to an unsigned int. These are called the integer> promotions.48) All other types are unchanged by the integer promotions.Default promotions when using function calls are defined in C99 6.5.2.2, paragraph 6:> If the expression that denotes the called function has a type that does not include a> prototype, the integer promotions are performed on each argument, and arguments that> have type float are promoted to double. These are called the default argument> promotions. If the number of arguments does not equal the number of parameters, the> behavior is undefined. If the function is defined with a type that includes a prototype, and> either the prototype ends with an ellipsis (, ...) or the types of the arguments after> promotion are not compatible with the types of the parameters, the behavior is undefined.> If the function is defined with a type that does not include a prototype, and the types of> the arguments after promotion are not compatible with those of the parameters after> promotion, the behavior is undefined, except for the following cases:and 7 it is stated that they apply to `...`:> If the expression that denotes the called function has a type that does include a prototype,> the arguments are implicitly converted, as if by assignment, to the types of the> corresponding parameters, taking the type of each parameter to be the unqualified version> of its declared type. The ellipsis notation in a function prototype declarator causes> argument type conversion to stop after the last declared parameter. The default argument> promotions are performed on trailing arguments.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3753,46096108,2015-11-29T18:36:20Z,src/nvim/option.c,"@@ -4195,6 +4255,21 @@ set_num_option (    options[opt_idx].flags |= P_WAS_SET; +  if (!starting && errmsg == NULL) {+    char_u buf_old[11], buf_new[11], buf_type[7];+    vim_snprintf((char *)buf_old, 10, ""%ld"", old_value);","Do we have negative values for options (`-1234567890` would need a `12` char buffer) or option values bigger than `INT_MAX` (`old_value` has type `long`, could need a >11 char buffer)?",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/2675,46096355,2015-11-29T18:59:13Z,src/nvim/os/unix_defs.h,"@@ -28,6 +28,9 @@ #ifndef SYNTAX_FNAME # define SYNTAX_FNAME   ""$VIMRUNTIME/syntax/%s.vim"" #endif+#ifndef SYNTAX_FILE+# define SYNTAX_FILE   ""$VIMRUNTIME/syntax/syntax.vim""+#endif","Not sure, it's not a big deal for now IMO.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3339,46597225,2015-12-03T19:20:28Z,src/nvim/buffer.c,"@@ -3272,212 +3433,362 @@ build_stl_str_hl (       break;      case STL_HIGHLIGHT:-      t = s;-      while (*s != '#' && *s != NUL)-        ++s;-      if (*s == '#') {+    {+      // { The name of the highlight is surrounded by `#`+      char_u *t = fmt_p;+      while (*fmt_p != '#' && *fmt_p != NUL) {+        ++fmt_p;+      }+      // }++      // Create a highlight item based on the name+      if (*fmt_p == '#') {         item[curitem].type = Highlight;-        item[curitem].start = p;-        item[curitem].minwid = -syn_namen2id(t, (int)(s - t));+        item[curitem].start = out_p;+        item[curitem].minwid = -syn_namen2id(t, (int)(fmt_p - t));         curitem++;+        fmt_p++;       }-      if (*s != NUL)-        ++s;       continue;     }+    } -    item[curitem].start = p;+    // If we made it this far, the item is normal and starts at+    // our current position in the output buffer.+    // Non-normal items would have `continued`.+    item[curitem].start = out_p;     item[curitem].type = Normal;++    // Copy the item string into the output buffer     if (str != NULL && *str) {-      t = str;+      // { Skip the leading `,` or ` ` if the item is a flag+      //  and the proper conditions are met+      char_u *t = str;       if (itemisflag) {         if ((t[0] && t[1])             && ((!prevchar_isitem && *t == ',')                 || (prevchar_isflag && *t == ' ')))           t++;-        prevchar_isflag = TRUE;+        prevchar_isflag = true;       }-      l = vim_strsize(t);-      if (l > 0)-        prevchar_isitem = TRUE;+      // }++      long l = vim_strsize(t);++      // If this item is non-empty, record that the last thing+      // we put in the output buffer was an item+      if (l > 0) {+        prevchar_isitem = true;+      }++      // If the item is too wide, truncate it from the beginning       if (l > maxwid) {         while (l >= maxwid)           if (has_mbyte) {             l -= ptr2cells(t);             t += (*mb_ptr2len)(t);-          } else+          } else {             l -= byte2cells(*t++);-        if (p + 1 >= out + outlen)+          }++        // Early out if there isn't enough room for the truncation marker+        if (out_p >= out_end_p)           break;-        *p++ = '<';++        // Add the truncation marker+        *out_p++ = '<';       }++      // If the item is right aligned and not wide enough,+      // pad with fill characters.       if (minwid > 0) {-        for (; l < minwid && p + 1 < out + outlen; l++) {-          /* Don't put a ""-"" in front of a digit. */+        for (; l < minwid && out_p < out_end_p; l++) {+          // Don't put a ""-"" in front of a digit.           if (l + 1 == minwid && fillchar == '-' && ascii_isdigit(*t))-            *p++ = ' ';+            *out_p++ = ' ';           else-            *p++ = fillchar;+            *out_p++ = fillchar;         }         minwid = 0;-      } else+      } else {+        // Note: The negative value denotes a left aligned item.+        //       Here we switch the minimum width back to a positive value.         minwid *= -1;-      while (*t && p + 1 < out + outlen) {-        *p++ = *t++;-        /* Change a space by fillchar, unless fillchar is '-' and a-         * digit follows. */-        if (fillable && p[-1] == ' '+      }++      // { Copy the string text into the output buffer+      while (*t && out_p < out_end_p) {+        *out_p++ = *t++;+        // Change a space by fillchar, unless fillchar is '-' and a+        // digit follows.+        if (fillable && out_p[-1] == ' '             && (!ascii_isdigit(*t) || fillchar != '-'))-          p[-1] = fillchar;+          out_p[-1] = fillchar;       }-      for (; l < minwid && p + 1 < out + outlen; l++)-        *p++ = fillchar;-    } else if (num >= 0) {-      int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));-      char_u nstr[20];+      // } -      if (p + 20 >= out + outlen)+      // For left-aligned items, fill any remaining space with the fillchar+      for (; l < minwid && out_p < out_end_p; l++) {+        *out_p++ = fillchar;+      }++    // Otherwise if the item is a number, copy that to the output buffer.+    } else if (num >= 0) {+      if (out_p + 20 > out_end_p)         break;                  /* not sufficient space */-      prevchar_isitem = TRUE;-      t = nstr;+      prevchar_isitem = true;++      // { Build the formatting string+      char_u nstr[20];+      char_u *t = nstr;       if (opt == STL_VIRTCOL_ALT) {         *t++ = '-';         minwid--;       }       *t++ = '%';-      if (zeropad)+      if (zeropad) {         *t++ = '0';+      }++      // Note: The `*` means we take the width as one of the arguments       *t++ = '*';-      *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');+      *t++ = (char_u) (base == kNumBaseHexadecimal ? 'X'+                        : (base == kNumBaseOctal ? 'o'+                        : 'd'));       *t = 0;+      // }++      // { Determine how many characters the number will take up when printed+      //  Note: We have to cast the base because the compiler uses+      //        unsigned ints for the enum values.+      long num_chars = 1;+      for (long n = num; n >= (int) base; n /= (int) base) {+        num_chars++;+      } -      for (n = num, l = 1; n >= nbase; n /= nbase)-        l++;-      if (opt == STL_VIRTCOL_ALT)-        l++;-      if (l > maxwid) {-        l += 2;-        n = l - maxwid;-        while (l-- > maxwid)-          num /= nbase;+      // VIRTCOL_ALT takes up an extra character because+      // of the `-` we added above.+      if (opt == STL_VIRTCOL_ALT) {+        num_chars++;+      }+      // }++      size_t remaining_buf_len = (out_end_p - out_p) + 1;++      // If the number is going to take up too much room+      // Figure out the approximate number in ""scientific"" type notation.+      // Ex: 14532 with maxwid of 4 -> '14>3'+      if (num_chars > maxwid) {+        // Add two to the width because the power piece will take+        // two extra characters+        num_chars += 2;++        // How many extra characters there are+        long n = num_chars - maxwid;++        // { Reduce the number by base^n+        while (num_chars-- > maxwid) {+          num /= base;+        }+        // }++        // { Add the format string for the exponent bit         *t++ = '>';         *t++ = '%';+        // Use the same base as the first number         *t = t[-3];         *++t = 0;-        vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,+        // }++        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,             0, num, n);-      } else-        vim_snprintf((char *)p, outlen - (p - out), (char *)nstr,+      } else {+        vim_snprintf((char *)out_p, remaining_buf_len, (char *)nstr,             minwid, num);-      p += STRLEN(p);-    } else+      }++      // Advance the output buffer position to the end of the+      // number we just printed+      out_p += STRLEN(out_p);++    // Otherwise, there was nothing to print so mark the item as empty+    } else {       item[curitem].type = Empty;+    } -    if (opt == STL_VIM_EXPR)+    // Free the string buffer if we allocated it.+    // Note: This is not needed if `str` is pointing at `tmp`+    if (opt == STL_VIM_EXPR) {       xfree(str);+    }      if (num >= 0 || (!itemisflag && str && *str))-      prevchar_isflag = FALSE;              /* Item not NULL, but not a flag */+      prevchar_isflag = false;              /* Item not NULL, but not a flag */++    // Item processed, move to the next     curitem++;   }-  *p = NUL;-  itemcnt = curitem; -  if (usefmt != fmt)+  // Null terminate the output buffer+  *out_p = NUL;+  int itemcnt = curitem;++  // Free the format buffer if we allocated it internally+  if (usefmt != fmt) {     xfree(usefmt);+  } -  width = vim_strsize(out);+  int width = vim_strsize(out);   if (maxwidth > 0 && width > maxwidth) {-    /* Result is too long, must truncate somewhere. */-    l = 0;-    if (itemcnt == 0)-      s = out;-    else {-      for (; l < itemcnt; l++)-        if (item[l].type == Trunc) {-          /* Truncate at %< item. */-          s = item[l].start;+    // Result is too long, must truncate somewhere.+    int item_idx = 0;+    char_u *trunc_p;++    // If there are no items, truncate from beginning+    if (itemcnt == 0) {+      trunc_p = out;++    // Otherwise, look for the truncation item+    } else {+      // Default to truncating at the first item+      trunc_p = item[0].start;+      item_idx = 0;++      for (int i = 0; i < itemcnt; i++)+        if (item[i].type == Trunc) {+          // Truncate at %< item.+          trunc_p = item[i].start;+          item_idx = i;           break;         }-      if (l == itemcnt) {-        /* No %< item, truncate first item. */-        s = item[0].start;-        l = 0;-      }     } -    if (width - vim_strsize(s) >= maxwidth) {-      /* Truncation mark is beyond max length */+    // If the truncation point we found is beyond the maximum+    // length of the string, truncate the end of the string.+    if (width - vim_strsize(trunc_p) >= maxwidth) {+      // If we are using a multi-byte encoding, walk from the beginning of the+      // string to find the last character that will fit.       if (has_mbyte) {-        s = out;+        trunc_p = out;         width = 0;         for (;; ) {-          width += ptr2cells(s);+          width += ptr2cells(trunc_p);           if (width >= maxwidth)             break;-          s += (*mb_ptr2len)(s);++          // Note: Only advance the pointer if the next+          //       character will fit in the available output space+          trunc_p += (*mb_ptr2len)(trunc_p);         }-        /* Fill up for half a double-wide character. */-        while (++width < maxwidth)-          *s++ = fillchar;-      } else-        s = out + maxwidth - 1;-      for (l = 0; l < itemcnt; l++)-        if (item[l].start > s)+        // Fill up for half a double-wide character.+        // XXX : This seems impossible given the exit condition above?+        while (++width < maxwidth) {+          *trunc_p++ = fillchar;+        }++      // Otherwise put the truncation point at the end, leaving enough room+      // for a single-character truncation marker+      } else {+        trunc_p = out + maxwidth - 1;+      }++      // Ignore any items in the statusline that occur after+      // the truncation point+      for (int i = 0; i < itemcnt; i++) {+        if (item[i].start > trunc_p) {+          itemcnt = i;           break;-      itemcnt = l;-      *s++ = '>';-      *s = 0;+        }+      }++      // Truncate the output+      *trunc_p++ = '>';+      *trunc_p = 0;++    // Truncate at the truncation point we found     } else {+      // { Determine how many bytes to remove+      long trunc_len;       if (has_mbyte) {-        n = 0;+        trunc_len = 0;         while (width >= maxwidth) {-          width -= ptr2cells(s + n);-          n += (*mb_ptr2len)(s + n);+          width     -= ptr2cells(trunc_p + trunc_len);+          trunc_len += (*mb_ptr2len)(trunc_p + trunc_len);         }-      } else-        n = width - maxwidth + 1;-      p = s + n;-      STRMOVE(s + 1, p);-      *s = '<';+      } else {+        // Truncate an extra character so we can insert our `<`.+        trunc_len = (width - maxwidth) + 1;+      }+      // }++      // { Truncate the string+      char_u *trunc_end_p = trunc_p + trunc_len;+      STRMOVE(trunc_p + 1, trunc_end_p); -      /* Fill up for half a double-wide character. */+      // Put a `<` to mark where we truncated at+      *trunc_p = '<';++      // Advance the pointer to the end of the string+      trunc_p = trunc_p + STRLEN(trunc_p);",This line also needs to check `width+1<maxwidth` before changing `trunc_p`. Otherwise too long tablines could crash nvim.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3787,46758639,2015-12-05T14:05:57Z,src/nvim/globals.h,"@@ -116,12 +116,13 @@ #define DFLT_COLS       80              /* default value for 'columns' */ #define DFLT_ROWS       24              /* default value for 'lines' */ -EXTERN long Rows                        /* nr of rows in the screen */ #ifdef DO_INIT-  = DFLT_ROWS+  EXTERN long Rows = DFLT_ROWS;          // nr of rows in the screen+#else+  EXTERN long Rows; #endif","Do we need macro `DO_INIT` here? Is this whole block not equivalent to `EXTERN long Rows INIT(= DFLT_ROWS);`?Looking at the other uses of macro `DO_INIT`, we could remove it completly from this file, if we change macro `INIT` into a variadic macro:``` diffdiff --git a/src/nvim/globals.h b/src/nvim/globals.hindex 52eebeb..197a609 100644--- a/src/nvim/globals.h+++ b/src/nvim/globals.h@@ -7,11 +7,10 @@ // actually defined and initialized. #ifndef EXTERN # define EXTERN extern-# define INIT(x)+# define INIT(...) #else # ifndef INIT-#  define INIT(x) x-#  define DO_INIT+#  define INIT(...) __VA_ARGS__ # endif #endif```So something like this``` cEXTERN typebuf_T typebuf                /* typeahead buffer */#ifdef DO_INIT  = {NULL, NULL, 0, 0, 0, 0, 0, 0, 0}#endif;```could be changed into``` cEXTERN typebuf_T typebuf  INIT(= {NULL, NULL, 0, 0, 0, 0, 0, 0, 0});              /* typeahead buffer */```",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3803,46918758,2015-12-08T06:22:40Z,src/nvim/window.c,"@@ -3074,10 +3076,9 @@ int tabpage_index(tabpage_T *ftp)  * FAIL.  * Careful: When OK is returned need to get a new tab page very very soon!  */-static int -leave_tabpage (-    buf_T *new_curbuf,        /* what is going to be the new curbuf,-                                          NULL if unknown */+static int leave_tabpage(+    buf_T *new_curbuf,        // what is going to be the new curbuf,+                              // NULL if unknown     int trigger_leave_autocmds )","Generally, stylistic changes make reviewing PRs like this harder, but if you want to make this look like neovim code...``` c/// Prepare for leaving the current tab page./// /// When autocommands change ""curtab"" we don't leave the tab page and return false./// @warn When true is returned need to get a new tab page very very soon!/// @param new_curbuf what is going to be the new curbuf or NULL if unknown/// @oaram trigger_leave_autocmds If true, trigger leave autocomds.static int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds) {  ...}```Been a while since I double checked doxygen syntax, and I didn't check the lines are under 80 chars, but this is basically how it should look.",
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3803,46919325,2015-12-08T06:35:21Z,src/nvim/window.c,"@@ -3653,7 +3652,8 @@ static win_T *win_alloc(win_T *after, int hidden)     win_append(after, new_wp);    new_wp->w_wincol = 0;-  new_wp->w_width = Columns;+  assert(Columns <= INT_MAX);+  new_wp->w_width = (int)Columns;",I'm starting to wonder if we shouldn't just have a `long_to_int()` that does this assert automatically.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3805,46932337,2015-12-08T09:43:04Z,src/nvim/os/env.c,"@@ -141,6 +141,36 @@ void init_homedir(void)    char_u *var = (char_u *)os_getenv(""HOME""); +#ifdef WIN32+  /*+   * Typically, $HOME is not defined on Windows, unless the user has+   * specifically defined it for Vim's sake.  However, on Windows NT+   * platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for+   * each user.  Try constructing $HOME from these.+   */+  if (var == NULL)+  {+    const char *homedrive, *homepath;++    homedrive = os_getenv(""HOMEDRIVE"");+    homepath = os_getenv(""HOMEPATH"");+    if (homepath == NULL) {+        homepath = ""\\"";",Too big indent.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3805,47039903,2015-12-09T01:09:45Z,src/nvim/os/env.c,"@@ -141,6 +141,28 @@ void init_homedir(void)    char_u *var = (char_u *)os_getenv(""HOME""); +#ifdef WIN32+  // Typically, $HOME is not defined on Windows, unless the user has+  // specifically defined it for Vim's sake. However, on Windows NT+  // platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for+  // each user. Try constructing $HOME from these.+  if (var == NULL) {+    const char *homedrive = os_getenv(""HOMEDRIVE"");+    const char *homepath = os_getenv(""HOMEPATH"");+    if (homepath == NULL) {+        homepath = ""\\"";+    }+    if (homedrive != NULL && strlen(homedrive) + strlen(homepath) < MAXPATHL) {+      snprintf((char *)NameBuff, MAXPATHL, ""%s%s"", homedrive, homepath);+      if (NameBuff[0] != NUL) {+        var = NameBuff;+        // Also set $HOME, it's needed for .viminfo.","Replacing `_viminfo` with `.viminfo` is useless and incorrect. Useless because _both_ names are no longer used as viminfo was replaced with ShaDa with different naming convention (`main.shada`, `main.shada.tmp.{char}`, XDG-compliant location). Incorrect because ShaDa code does not need this.",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3787,47178862,2015-12-10T01:26:41Z,src/nvim/message.c,"@@ -241,12 +240,12 @@ msg_strtrunc (  * Truncate a string ""s"" to ""buf"" with cell width ""room"".  * ""s"" and ""buf"" may be equal.  */-void trunc_string(char_u *s, char_u *buf, int room, int buflen)+void trunc_string(char_u *s, char_u *buf, long room, long buflen) {-  int half;-  int len;+  long half;+  long len;+  long i;",~~Is it a good idea to create a sister function for the ones that takes bad types across the codebase to mitigate the need of casting and eventually replace the old one? Because your proposed change seems good but the variables interact with a lot of these functions.~~Turns out this was not a good plan for this case.,
38515,splinterofchaos,https://api.github.com/repos/neovim/neovim/pulls/3787,47318138,2015-12-11T03:15:18Z,src/nvim/message.c,"@@ -279,33 +277,35 @@ void trunc_string(char_u *s, char_u *buf, int room, int buflen)     /* For DBCS going backwards in a string is slow, but      * computing the cell width isn't too slow: go forward      * until the rest fits. */-    n = vim_strsize(s + i);+    n = (size_t)vim_strsize(s + i);     while (len + n > room) {-      n -= ptr2cells(s + i);-      i += (*mb_ptr2len)(s + i);+      n -= (size_t)ptr2cells(s + i);+      i += (size_t)(*mb_ptr2len)(s + i);     }   } else if (enc_utf8) {     /* For UTF-8 we can go backwards easily. */-    half = i = (int)STRLEN(s);+    half = i = STRLEN(s);     for (;; ) {-      do-        half = half - (*mb_head_off)(s, s + half - 1) - 1;-      while (utf_iscomposing(utf_ptr2char(s + half)) && half > 0);-      n = ptr2cells(s + half);+      do {+        half = half - (size_t)(*mb_head_off)(s, s + half - 1) - 1;+      } while (utf_iscomposing(utf_ptr2char(s + half)) && half > 0);+      n = (size_t)ptr2cells(s + half);       if (len + n > room)         break;       len += n;       i = half;     }   } else {-    for (i = (int)STRLEN(s); len + (n = ptr2cells(s + i - 1)) <= room; --i)+    for (i = STRLEN(s);+         len + (n = (size_t)ptr2cells(s + i - 1)) <= room; --i) {","That might be simplest. Or we could try and prove that `i > 0` is invariant, but it really depends on `room` being sufficiently large. This function seems to have some undocumented preconditions.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3807,47436808,2015-12-12T21:05:43Z,src/nvim/shada.c,"@@ -3482,6 +3489,8 @@ static inline char *get_converted_string(const vimconv_T *const sd_conv,           (tgt) = aetv.vval.v_list; \         } \       } while (0)+// Workaround for silencing linter.+#define ELSE else",Or we should just commit without fixing this so that the exception is noted in errors.json.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3807,47437003,2015-12-12T21:23:19Z,src/nvim/shada.c,"@@ -3482,6 +3489,8 @@ static inline char *get_converted_string(const vimconv_T *const sd_conv,           (tgt) = aetv.vval.v_list; \         } \       } while (0)+// Workaround for silencing linter.+#define ELSE else","This workaround is a direct consequence of used macros (more specifically, using `if` as a top-level macros block). I do not like the idea of committing without the fix because I always thought that one of the goals is evenually have zero lint errors in the codebase. There is another variant of fixing: make `CHECK_KEY_IS_STR` start the `if` block. Then `CHECKED_KEY` macros may start with `ELSE`:``` C#define CHECKED_KEY(entry_name, name, error_desc, tgt, condition, attr, proc) \  ELSE if (CHECK_KEY(unpacked.data.via.map.ptr[i].key, name)) { \```. Using `else` is not possible because it will trigger the same rule, but `ELSE` will then only be placed in one line and not in many.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3807,47437124,2015-12-12T21:35:43Z,src/nvim/shada.c,"@@ -3482,6 +3489,8 @@ static inline char *get_converted_string(const vimconv_T *const sd_conv,           (tgt) = aetv.vval.v_list; \         } \       } while (0)+// Workaround for silencing linter.+#define ELSE else","@justinmk `//` inside a macros?! And for `CHECKED_KEY` this will look like``` C  else if (CHECK_KEY( /* NOLINT(readability/braces) */ \      unpacked.data.via.map.ptr[i].key, name)) { \```: otherwise there is not enough space.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3623,47440722,2015-12-13T05:55:54Z,src/nvim/indent_c.c,"@@ -65,6 +66,62 @@ find_start_comment (  /* XXX */ }  /*+ * Find the start of a comment or raw string, not knowing if we are in a+ * comment or raw string right now.+ * Search starts at w_cursor.lnum and goes backwards.+ * Return NULL when not inside a comment or raw string.+ * ""CORS"" -> Comment Or Raw String+ */+static pos_T *ind_find_start_CORS(void)+{ /* XXX */+    pos_T *comment_pos = find_start_comment(curbuf->b_ind_maxcomment);+    pos_T *rs_pos = find_start_rawstring(curbuf->b_ind_maxcomment);++    /* If comment_pos is before rs_pos the raw string is inside the comment.+     * If rs_pos is before comment_pos the comment is inside the raw string. */+    if (comment_pos == NULL || (rs_pos != NULL && lt(*rs_pos, *comment_pos)))+        return rs_pos;+    return comment_pos;+}++/*+ * Find the start of a raw string, not knowing if we are in one right now.+ * Search starts at w_cursor.lnum and goes backwards.+ * Return NULL when not inside a raw string.+ */+static pos_T *find_start_rawstring(int ind_maxcomment)+{ /* XXX */+    pos_T *pos;+    char_u *line;+    char_u *p;+    long int cur_maxcomment = ind_maxcomment;",@johanhelsing Why not just `long`?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3623,47440724,2015-12-13T05:56:07Z,src/nvim/indent_c.c,"@@ -97,7 +154,26 @@ static char_u *skip_string(char_u *p)           break;       }       if (p[0] == '""')-        continue;+          continue; /* continue for another string */+    } else if (p[0] == 'R' && p[1] == '""') {+        /* Raw string: R""[delim](...)[delim]"" */+        char_u *delim = p + 2;+        char_u *paren = vim_strchr(delim, '(');++        if (paren != NULL)+        {+            long int delim_len = paren - delim;",`long`,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3812,47441695,2015-12-13T08:17:56Z,test/functional/shell/viml_system_spec.lua,"@@ -200,6 +201,27 @@ describe('system()', function()       eq('* $NOTHING ~/file',          eval(""system(['echo', '-n', '*', '$NOTHING', '~/file'])""))     end)++    it('quotes arguments correctly', function()+      local pwd = helpers.funcs.getcwd()+      local fname+      if ffi.os == ""Windows"" then+        fname = ""countargs.bat""+      else+        fname = ""countargs.sh""+      end+      local script = pwd .. '/test/functional/shell/' .. fname+      local out0 = eval('system(""' .. script .. ' 1 \\\""2 3\\\"""")')++      local cmd1+      if ffi.os == ""Windows"" then+        cmd1 = 'system([""cmd"", ""/c"", ""' .. script ..'"", ""1"", ""2 3""])'+      else+        cmd1 = 'system([""' .. script ..'"", ""1"", ""2 3""])'+      end+      local out1 = eval(cmd1)+      eq(out0, out1)","I'd suggest hard-coding the expected results to avoid hiding a bug that causes both system() variants to return the same wrong output.``` luaeq(""2"", out0)eq(""2"", out1)```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3787,47442197,2015-12-13T09:21:06Z,src/nvim/message.c,"@@ -237,17 +237,15 @@ msg_strtrunc (   return buf; } -/*- * Truncate a string ""s"" to ""buf"" with cell width ""room"".- * ""s"" and ""buf"" may be equal.- */-void trunc_string(char_u *s, char_u *buf, int room, int buflen)+/// Truncate a string ""s"" to ""buf"" with cell width ""room"".+/// ""s"" and ""buf"" may be equal.+void trunc_string(char_u *s, char_u *buf, size_t room, size_t buflen) {-  int half;-  int len;-  int e;-  int i;-  int n;+  size_t half;+  size_t len;+  size_t i;+  size_t e;+  size_t n;    room -= 3;","Can we be sure that with the change `size_t room` in the parameter list, this will not wrap around (`room<3`)?",
2620557,johanhelsing,https://api.github.com/repos/neovim/neovim/pulls/3623,47443398,2015-12-13T11:48:30Z,src/nvim/indent_c.h,"@@ -3,6 +3,12 @@  #include ""nvim/vim.h"" +// Find result cache for cpp_baseclass+typedef struct {+    int found;+    lpos_T lpos;+} cpp_baseclass_cache_T;","@justinmk I tried moving the struct to `indent_c.c`, but I keep getting this:```[11/50] Building C object src/nvim/CMakeFiles/nvim.dir/indent_c.c.oFAILED: /usr/lib/colorgcc/bin/cc  -DHAVE_CONFIG_H -DINCLUDE_GENERATED_DECLARATIONS -Iconfig -I../src -isystem ../.deps/usr/include -isystem ../.deps/usr/include/luajit-2.0 -Isrc/nvim/auto -Iinclude -Wconversion -g   -Wall -Wextra -pedantic -Wno-unused-parameter -Wstrict-prototypes -std=gnu99 -Wvla -fstack-protector-strong -fdiagnostics-color=auto -MMD -MT src/nvim/CMakeFiles/nvim.dir/indent_c.c.o -MF src/nvim/CMakeFiles/nvim.dir/indent_c.c.o.d -o src/nvim/CMakeFiles/nvim.dir/indent_c.c.o   -c ../src/nvim/indent_c.cIn file included from ../src/nvim/indent_c.c:23:0:src/nvim/auto/indent_c.c.generated.h:36:33: error: unknown type name ���cpp_baseclass_cache_T��� static int cin_is_cpp_baseclass(cpp_baseclass_cache_T *cached);```I don't quite understand how the header auto generation works so I don't know how to fix it.Here's a branch where I moved the struct to `indent_c.c` https://github.com/johanhelsing/neovim/tree/vim-7.4.803-move-struct",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3803,47503382,2015-12-14T14:34:24Z,src/nvim/option.c,"@@ -1458,12 +1454,12 @@ do_set (             else if (nextchar == '<') {               /* For 'undolevels' NO_LOCAL_UNDOLEVEL means to                * use the global value. */-              if ((long *)varp == &curbuf->b_p_ul-                  && opt_flags == OPT_LOCAL)+              if ((int *)varp == &curbuf->b_p_ul && opt_flags == OPT_LOCAL) {                 value = NO_LOCAL_UNDOLEVEL;-              else-                value = *(long *)get_varp_scope(-                    &(options[opt_idx]), OPT_GLOBAL);+              } else {+                value = *(long *)get_varp_scope(&(options[opt_idx]),",changed to ask int and cast to long,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3839,47625328,2015-12-15T11:32:52Z,CMakeLists.txt,"@@ -51,6 +51,14 @@ endif() set(NVIM_VERSION_MAJOR 0) set(NVIM_VERSION_MINOR 1) set(NVIM_VERSION_PATCH 1)+# Package maintainers should define this according to their package system+# conventions, if the source code or runtime files were modified, e.g.:+#   cmake -DNVIM_VERSION_PRERELEASE=-deb3+# or define it as empty to prevent ""-dev"", if no modifications were made:+#   cmake -DNVIM_VERSION_PRERELEASE=+if(NOT DEFINED NVIM_VERSION_PRERELEASE)+  set(NVIM_VERSION_PRERELEASE ""-dev"")+endif()","> If a source snapshot is not a release, it should have ""-dev"", otherwise it shouldn't.AFAIK that is how this PR functions. In which case would that not be the case (except in a git tree)? > Semi-related: currently we number versions like: 0.1.0 -> 0.1.0-dev -> 0.1.1 -> 0.1.1-dev -> ... This doesn't follow SemVer:Ok, what if we did `0.1.0 -> 0.1.1-dev -> 0.1.1 -> 0.1.2-dev -> ...` ?> libuv more or less at random.. looks like they do what I described: tagging a release, follow-up commitI tend to look at git, which AFAICT does not do that. We've been burned before by following node.js habits (e.g.: CLA). How about other projects (e.g., Rust, Atom--I did not check these myself)?> git describe complicates the situation somewhat. We don't really follow SemVer anymore since we introduced that. Hm.Section 9 of semver.org says arbitrary pre-release data may be appended after a hyphen...",
339435,fwalch,https://api.github.com/repos/neovim/neovim/pulls/3839,47628327,2015-12-15T12:11:32Z,CMakeLists.txt,"@@ -51,6 +51,14 @@ endif() set(NVIM_VERSION_MAJOR 0) set(NVIM_VERSION_MINOR 1) set(NVIM_VERSION_PATCH 1)+# Package maintainers should define this according to their package system+# conventions, if the source code or runtime files were modified, e.g.:+#   cmake -DNVIM_VERSION_PRERELEASE=-deb3+# or define it as empty to prevent ""-dev"", if no modifications were made:+#   cmake -DNVIM_VERSION_PRERELEASE=+if(NOT DEFINED NVIM_VERSION_PRERELEASE)+  set(NVIM_VERSION_PRERELEASE ""-dev"")+endif()","> AFAIK that is how this PR functions. In which case would that not be the case (except in a git tree)? You can build any revision with `-DNVIM_VERSION_PRERELEASE=`, which would make it look like a release. We hardcode the version number, so I feel like we should also hardcode this part of the version and make it do ""the right thing"" for packagers out of the box. It's more of a personal preference thing, though.> How about other projects (e.g., Rust, Atom--I did not check these myself)?I will check some more projects.> Section 9 of semver.org says arbitrary pre-release data may be appended after a hyphen...Yes, but git describe appends ""post-release data"", i.e. it's supposed to be 0.1.0 < 0.1.0-1, whereas semver would treat it as 0.1.0-1 < 0.1.0, as the pre-release data after the hyphen is a string, not a number (see also https://github.com/mojombo/semver/issues/106). Also, if we do the 0.1.0 -> 0.1.1-dev versioning scheme, then we would have a version of e.g. 0.1.1-dev for tarball builds and 0.1.0-5-abcdef for `git describe` builds.. maybe we should not use git describe directly, but e.g. `0.1.1-dev` for tarball builds and `0.1.1-dev+abcdef` for Git tree builds? :grimacing:If we decide to change anything, I would create the PR, so you don't have to do all the work.. I hope I'm not overcomplicating things :grimacing: ",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/3839,47629184,2015-12-15T12:22:47Z,CMakeLists.txt,"@@ -51,6 +51,14 @@ endif() set(NVIM_VERSION_MAJOR 0) set(NVIM_VERSION_MINOR 1) set(NVIM_VERSION_PATCH 1)+# Package maintainers should define this according to their package system+# conventions, if the source code or runtime files were modified, e.g.:+#   cmake -DNVIM_VERSION_PRERELEASE=-deb3+# or define it as empty to prevent ""-dev"", if no modifications were made:+#   cmake -DNVIM_VERSION_PRERELEASE=+if(NOT DEFINED NVIM_VERSION_PRERELEASE)+  set(NVIM_VERSION_PRERELEASE ""-dev"")+endif()","> I don't like this too much.. I think the version should not depend on how Nvim is built. If a source snapshot is not a release, it should have ""-dev"", otherwise it shouldn't. I agree that it's cumbersome to remove NVIM_VERSION_PRERELEASE when we tag a release, though.. but I don't have a better idea.Another idea--that might be slightly better--is to include an extra file in the release, say .version-info.  We can then have CMake pickup on this file and coerce the version number (leaving off the ""-dev"", for instance), and when it's not there keep the current behavior.We use a similar mechanism at our workplace so that we can control the version number via our QuickBuild instance, and it allows us to promote the builds through to a final release--ultimately dropping things out of the version that mark it as a dev or a release candidate.  We also use it to label our dev versions separately than the git commit numbers--because sometimes there are packaging issues and you need to rebuild from the same commit number, but it's not the same build.The downside is that there's an extra file you need to include as part of the tag, but at least you don't have to remember to pass yet another argument.",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3842,47662587,2015-12-15T16:44:07Z,CMakeLists.txt,"@@ -6,8 +6,13 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"")  # Prefer our bundled versions of dependencies. set(DEPS_PREFIX ""${CMAKE_CURRENT_SOURCE_DIR}/.deps/usr"" CACHE PATH ""Path prefix for finding dependencies"")-list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX})-set(ENV{PKG_CONFIG_PATH} ""$ENV{PKG_CONFIG_PATH}:${DEPS_PREFIX}/lib/pkgconfig"")+if(CMAKE_CROSSCOMPILING)+  list(INSERT CMAKE_FIND_ROOT_PATH 0 ${DEPS_PREFIX})+  list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX}/../host/bin)",Not sure. I looked in our cross compile toolchain file (`cmake/mingw32-w64-cross-travis.toolchain.cmake`) and didn't see anything.@equalsraf?Also note that this PR is currently breaking travis. I think we need to set `-m32` in the linker flags in `cmake/i386-linux-gnu.toolchain.cmake` too but I'm not sure.,
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/3842,47667091,2015-12-15T17:14:05Z,CMakeLists.txt,"@@ -6,8 +6,13 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"")  # Prefer our bundled versions of dependencies. set(DEPS_PREFIX ""${CMAKE_CURRENT_SOURCE_DIR}/.deps/usr"" CACHE PATH ""Path prefix for finding dependencies"")-list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX})-set(ENV{PKG_CONFIG_PATH} ""$ENV{PKG_CONFIG_PATH}:${DEPS_PREFIX}/lib/pkgconfig"")+if(CMAKE_CROSSCOMPILING)+  list(INSERT CMAKE_FIND_ROOT_PATH 0 ${DEPS_PREFIX})+  list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX}/../host/bin)","/host/ comes from third-party/cmake/Build\* recipes. e.g. when cross compiling we need to build luajit and libuv both for the host and target system. Libs for the target system are installed in .deps/usr/ and libs for the host are placed in .deps/host. (here is an [example](https://github.com/neovim/neovim/blob/master/third-party/cmake/BuildLibuv.cmake#L48))> Also note that this PR is currently breaking travis.Weird, but it is only breaking Travis in the gcc-5-m32 job. Ahh maybe the CMAKE_CROSSCOMPILING is evaluating as true for that case (because we are cross compiling from a 64 bit host to 32 bit target). Does changing `if(CMAKE_CROSSCOMPILING)` to `if(MINGW AND CMAKE_CROSSCOMPILING)` help? Still does not explain why the error is happening though.> think we need to set -m32 in the linker flags in cmake/i386-linux-gnu.toolchain.cmakeIts already there.",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3842,47679999,2015-12-15T18:51:25Z,CMakeLists.txt,"@@ -6,8 +6,13 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"")  # Prefer our bundled versions of dependencies. set(DEPS_PREFIX ""${CMAKE_CURRENT_SOURCE_DIR}/.deps/usr"" CACHE PATH ""Path prefix for finding dependencies"")-list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX})-set(ENV{PKG_CONFIG_PATH} ""$ENV{PKG_CONFIG_PATH}:${DEPS_PREFIX}/lib/pkgconfig"")+if(CMAKE_CROSSCOMPILING)+  list(INSERT CMAKE_FIND_ROOT_PATH 0 ${DEPS_PREFIX})+  list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX}/../host/bin)",> Where does /host/ come from? See [`third-party/CMakeLists.txt`](https://github.com/neovim/neovim/blob/65b47a05d68c966266b0ee5e1fc2709086941f62/third-party/CMakeLists.txt#L60),
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3842,47731930,2015-12-16T03:01:27Z,CMakeLists.txt,"@@ -6,8 +6,13 @@ list(APPEND CMAKE_MODULE_PATH ""${PROJECT_SOURCE_DIR}/cmake"")  # Prefer our bundled versions of dependencies. set(DEPS_PREFIX ""${CMAKE_CURRENT_SOURCE_DIR}/.deps/usr"" CACHE PATH ""Path prefix for finding dependencies"")-list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX})-set(ENV{PKG_CONFIG_PATH} ""$ENV{PKG_CONFIG_PATH}:${DEPS_PREFIX}/lib/pkgconfig"")+if(CMAKE_CROSSCOMPILING AND NOT UNIX)+  list(INSERT CMAKE_FIND_ROOT_PATH 0 ${DEPS_PREFIX})+  list(INSERT CMAKE_PREFIX_PATH 0 ${DEPS_PREFIX}/../host/bin)",Would it make sense to use `${CMAKE_BINARY_DIR}/host/bin` here as done in https://github.com/neovim/neovim/blob/65b47a05d68c966266b0ee5e1fc2709086941f62/third-party/CMakeLists.txt#L61 ?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3846,47732695,2015-12-16T03:17:20Z,src/nvim/os/win_defs.h,"@@ -15,6 +16,15 @@ # ifndef restrict #  define restrict __restrict # endif+# ifndef S_ISDIR+#  define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)+# endif+# ifndef S_ISREG+#  define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)+# endif+# ifndef S_IXUSR+#  define S_IXUSR S_IEXEC+# endif",Unless I am mistaken the only one that is needed is `S_IXUSR`. The others are here:https://github.com/neovim/neovim/blob/master/src/nvim/os/os_defs.h#L54-L71,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3867,48088433,2015-12-19T03:43:11Z,src/nvim/testdir/test_breakindent.in,"@@ -101,7 +101,7 @@ fygjyl:let line2 = @0 :$put =line2 :"" :let g:test=""Test 14: breakindent + visual blockwise delete #1""-:set all& breakindent+:set all& breakindent viminfo+=nviminfo","I would suggest to use `shada+=nX-test-breakindent.shada`. `&viminfo` is now a deprecated option, ShaDa uses `.shada` extension and it is preferred to have at least test-file-local names of the temporary files.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/3869,48095747,2015-12-19T19:13:21Z,test/functional/api/server_requests_spec.lua,"@@ -32,6 +32,20 @@ describe('server -> client', function()     end)   end) +  describe('NULL-initialized string handling', function()+    it('works', function()+      local function on_setup()+        eq({'', ''}, eval('rpcrequest('..cid..', ""nstring"")'))+        stop()+      end++      local function on_request(method, args)+        return {'', ''}","Don't know enough lua. I would assume, we are only interested in the request response which should be a list of empty strings (see #3844). Perhaps @snoe can help here?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3869,48104611,2015-12-20T15:44:16Z,test/functional/api/server_requests_spec.lua,"@@ -32,6 +32,24 @@ describe('server -> client', function()     end)   end) +  describe('empty string handling', function()+    -- Checks whether `rpcrequest` can handle a response that contains+    -- empty strings.",In this variant comment is rather useless. I expected some addition like ���: msgpack parser used to represent second empty string as NULL .ptr���.,
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3889,48291792,2015-12-22T19:58:47Z,runtime/doc/os_dos.txt,"@@ -266,10 +253,10 @@ create a file is used: ============================================================================== 9. Shell option default					*dos-shell* -The default for the 'sh' ('shell') option is ""command.com"" on Windows 95 and-""cmd.exe"" on Windows NT.  If SHELL is defined, Vim uses SHELL instead, and if-SHELL is not defined but COMSPEC is, Vim uses COMSPEC.  Vim starts external-commands with ""<shell> /c <command_name>"".  Typing CTRL-Z starts a new command+The default for the 'sh' ('shell') option is ""cmd.exe"" on Windows.","Instead of referring to the long-form of `sh` in parens, you could just do: `The default for the 'shell' option`",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3890,48309078,2015-12-22T23:12:26Z,runtime/doc/vi_diff.txt,"@@ -57,10 +57,9 @@ argument when starting Vim.  Support for different systems. 	Vim can be used on:-	- All Unix systems (it works on all systems it was tested on, although-	  the GUI and Perl interface may not work everywhere).-	- Windows 95 and Windows NT, with support for long file names.-	- Macintosh+	- Modern Unix systems (*BSD, Linux, etc.)",Could work but technically OS X is a Unix-like system...,
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3891,48309680,2015-12-22T23:21:21Z,runtime/doc/syntax.txt,"@@ -4866,10 +4866,9 @@ Menu		Current font, background and foreground colors of the menus. 		Also used for the toolbar. 		Applicable highlight arguments: font, guibg, guifg. -		NOTE: For Motif and Athena the font argument actually-		specifies a fontset at all times, no matter if 'guifontset' is-		empty, and as such it is tied to the current |:language| when-		set.+                NOTE: For Motif the font argument actually specifies a fontset+                at all times, no matter if 'guifontset' is empty, and as such+                it is tied to the current |:language| when set.",Oh right. I don't have `listchars` on and default to soft tabs although I thought the runtime files were  setting that in the modeline....,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48447075,2015-12-26T13:00:29Z,src/nvim/ops.c,"@@ -2345,9 +2349,11 @@ static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)   }    reg->y_size = yanklines;-  reg->y_type = yanktype;     /* set the yank register type */+  assert(yanktype <= UCHAR_MAX);","as yanktype is not really a numerical quantity but essentially an enum (one of MLINE, MCHAR, MBLOCK, MAUTO), this assert doesn't really make sense. I think you can just drop this one, but if an assert is added for motiontype/yanktype anywhere, it is better to tightly check that is is one of the 4 (or sometimes less) legal values.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48447224,2015-12-26T13:35:05Z,src/nvim/ops.c,"@@ -516,8 +515,9 @@ static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def     memset(newp + offset, ' ', (size_t)spaces);      /* copy the new text */-    memmove(newp + offset + spaces, s, (size_t)s_len);-    offset += s_len;+    memmove(newp + offset + spaces, s, s_len);+    assert(s_len <= INT_MAX);","assert can be removed, as inserted text `s` (inserted by the user on the first line of the block) couldn't be longer than MAXCOL to start with.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48447877,2015-12-26T15:47:41Z,src/nvim/buffer_defs.h,"@@ -649,7 +649,7 @@ struct file_buffer {   bool b_p_swf;                 /* 'swapfile' */   long b_p_smc;                 /* 'synmaxcol' */   char_u      *b_p_syn;         /* 'syntax' */-  long b_p_ts;                  /* 'tabstop' */+  int b_p_ts;                   // 'tabstop'","do we already have any numeric option that is not `long` ? If not then I don't think we can be sure that it is safe, for instance in `option.c` all numeric options are read/written as `*(long*)`. ",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3745,48448205,2015-12-26T16:36:57Z,src/nvim/buffer_defs.h,"@@ -649,7 +649,7 @@ struct file_buffer {   bool b_p_swf;                 /* 'swapfile' */   long b_p_smc;                 /* 'synmaxcol' */   char_u      *b_p_syn;         /* 'syntax' */-  long b_p_ts;                  /* 'tabstop' */+  int b_p_ts;                   // 'tabstop'",it creates a great deal of warnings if I keep it to long. See #3803 for my change of numerical options to int. There is no problem in this PR for now but indeed this is not ideal and the changes in #3803 will hopefully change that if it's deemed good enough.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3903,48451071,2015-12-27T01:29:47Z,src/nvim/buffer.c,"@@ -1718,8 +1718,8 @@ static buf_T *buflist_findname_file_id(char_u *ffname, FileID *file_id,  */ int  buflist_findpat (-    char_u *pattern,-    char_u *pattern_end,       /* pointer to first char after pattern */+    const char_u *pattern,+    const char_u *pattern_end,       /* pointer to first char after pattern */",The `const` changes here cascaded from `write_reg_contents_ex`. This is fine because `buflist_findpat` and `file_pat_to_reg_pat` do not modify the contents of their pointer params.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48453435,2015-12-27T10:25:07Z,src/nvim/message.c,"@@ -468,7 +468,7 @@ int emsg_not_now(void)  *  * return TRUE if wait_return not called  */-int emsg(char_u *s)",unrelated (this belongs in a PR for message.c),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48453496,2015-12-27T10:35:45Z,src/nvim/ops.c,"@@ -1169,8 +1162,7 @@ static void stuffescaped(char_u *arg, int literally)  * If ""regname"" is a special register, return TRUE and store a pointer to its  * value in ""argp"".  */-int -get_spec_reg (+int get_spec_reg(","In future PRs please avoid style changes in functions that otherwise are unrelated to the subject of the PR, or at least in a separate commit so that semantic changes (integer types and casts in this case) can be reviewed separately from the stylistic ones. (small changes close to lines that are changed anyway are of course ok, and sometimes required by the linter)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3695,48453650,2015-12-27T10:55:44Z,src/nvim/charset.c,"@@ -799,32 +799,41 @@ unsigned int win_linetabsize(win_T *wp, char_u *line, colnr_T len)   return (unsigned int)col; } -/// Return TRUE if 'c' is a normal identifier character:+/// Return true if 'c' is a normal identifier character:",to be consistent with functions below next line should be joined with this (otherwise the `:` looks misplaced),
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3745,48513208,2015-12-28T23:34:30Z,src/nvim/buffer_defs.h,"@@ -649,7 +649,7 @@ struct file_buffer {   bool b_p_swf;                 /* 'swapfile' */   long b_p_smc;                 /* 'synmaxcol' */   char_u      *b_p_syn;         /* 'syntax' */-  long b_p_ts;                  /* 'tabstop' */+  int b_p_ts;                   // 'tabstop'","I will revert this change and cast to dissociate this PR from the ""numerical options"" problem so this PR can be merged independently.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48545969,2015-12-29T15:11:21Z,src/nvim/normal.h,"@@ -10,53 +10,50 @@ #define FIND_STRING     2       /* find any string (WORD) */ #define FIND_EVAL       4       /* include ""->"", ""[]"" and ""."" */ -/*- * Arguments for operators.- */+// Arguments for operators. typedef struct oparg_S {-  int op_type;                  /* current pending operator type */-  int regname;                  /* register to use for the operator */-  int motion_type;              /* type of the current cursor motion */-  int motion_force;             /* force motion type: 'v', 'V' or CTRL-V */-  bool use_reg_one;             /* true if delete uses reg 1 even when not-                                   linewise */-  bool inclusive;               /* true if char motion is inclusive (only-                                   valid when motion_type is MCHAR */-  bool end_adjusted;            /* backuped b_op_end one char (only used by-                                   do_format()) */-  pos_T start;                  /* start of the operator */-  pos_T end;                    /* end of the operator */-  pos_T cursor_start;           /* cursor position before motion for ""gw"" */--  long line_count;              /* number of lines from op_start to op_end-                                   (inclusive) */-  bool empty;                   /* op_start and op_end the same (only used by-                                   op_change()) */-  bool is_VIsual;               /* operator on Visual area */-  bool block_mode;              /* current operator is Visual block mode */-  colnr_T start_vcol;           /* start col for block mode operator */-  colnr_T end_vcol;             /* end col for block mode operator */-  long prev_opcount;            // ca.opcount saved for K_EVENT","Still, I'm not happy with this change in this PR, as `count`s affect much code outside of `ops.c`. (it is also not consistent, there is still count parameters as `long`) Reverting all the changed `count` types back to `long` creates just two warnings in `ops.c`, which should be easy to fix.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,48564444,2015-12-29T19:39:12Z,src/nvim/globals.h,"@@ -847,8 +847,8 @@ EXTERN int* (*iconv_errno)(void); EXTERN int State INIT(= NORMAL);        /* This is the current state of the                                          * command interpreter. */ -EXTERN int finish_op INIT(= FALSE);     /* TRUE while an operator is pending */-EXTERN long opcount INIT(= 0);          /* count for pending operator */+EXTERN bool finish_op INIT(= false);    // true while an operator is pending+EXTERN int opcount INIT(= 0);           // count for pending operator",this should be reverted to long as well (`opcount` is not even used in `ops.c`).,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3871,48588765,2015-12-30T06:30:40Z,src/nvim/option_defs.h,"@@ -209,44 +209,58 @@ #define COM_ALL         ""nbsmexflrO""    /* all flags for 'comments' option */ #define COM_MAX_LEN     50              /* maximum length of a part */ -/* flags for 'statusline' option */-#define STL_FILEPATH    'f'             /* path of file in buffer */-#define STL_FULLPATH    'F'             /* full path of file in buffer */-#define STL_FILENAME    't'             /* last part (tail) of file path */-#define STL_COLUMN      'c'             /* column og cursor*/-#define STL_VIRTCOL     'v'             /* virtual column */-#define STL_VIRTCOL_ALT 'V'             /* - with 'if different' display */-#define STL_LINE        'l'             /* line number of cursor */-#define STL_NUMLINES    'L'             /* number of lines in buffer */-#define STL_BUFNO       'n'             /* current buffer number */-#define STL_KEYMAP      'k'             /* 'keymap' when active */-#define STL_OFFSET      'o'             /* offset of character under cursor*/-#define STL_OFFSET_X    'O'             /* - in hexadecimal */-#define STL_BYTEVAL     'b'             /* byte value of character */-#define STL_BYTEVAL_X   'B'             /* - in hexadecimal */-#define STL_ROFLAG      'r'             /* readonly flag */-#define STL_ROFLAG_ALT  'R'             /* - other display */-#define STL_HELPFLAG    'h'             /* window is showing a help file */-#define STL_HELPFLAG_ALT 'H'            /* - other display */-#define STL_FILETYPE    'y'             /* 'filetype' */-#define STL_FILETYPE_ALT 'Y'            /* - other display */-#define STL_PREVIEWFLAG 'w'             /* window is showing the preview buf */-#define STL_PREVIEWFLAG_ALT 'W'         /* - other display */-#define STL_MODIFIED    'm'             /* modified flag */-#define STL_MODIFIED_ALT 'M'            /* - other display */-#define STL_QUICKFIX    'q'             /* quickfix window description */-#define STL_PERCENTAGE  'p'             /* percentage through file */-#define STL_ALTPERCENT  'P'             /* percentage as TOP BOT ALL or NN% */-#define STL_ARGLISTSTAT 'a'             /* argument list status as (x of y) */-#define STL_PAGENUM     'N'             /* page number (when printing)*/-#define STL_VIM_EXPR    '{'             /* start of expression to substitute */-#define STL_MIDDLEMARK  '='             /* separation between left and right */-#define STL_TRUNCMARK   '<'             /* truncation mark if line is too long*/-#define STL_USER_HL     '*'             /* highlight from (User)1..9 or 0 */-#define STL_HIGHLIGHT   '#'             /* highlight name */-#define STL_TABPAGENR   'T'             /* tab page label nr */-#define STL_TABCLOSENR  'X'             /* tab page close nr */-#define STL_ALL         ((char_u *) ""fFtcvVlLknoObBrRhHmYyWwMqpPaN{#"")+/// 'statusline' option flags+enum {+  STL_FILEPATH        = 'f',  ///< Path of file in buffer.+  STL_FULLPATH        = 'F',  ///< Full path of file in buffer.+  STL_FILENAME        = 't',  ///< Last part (tail) of file path.+  STL_COLUMN          = 'c',  ///< Column og cursor.+  STL_VIRTCOL         = 'v',  ///< Virtual column.+  STL_VIRTCOL_ALT     = 'V',  ///< - with 'if different' display.+  STL_LINE            = 'l',  ///< Line number of cursor.+  STL_NUMLINES        = 'L',  ///< Number of lines in buffer.+  STL_BUFNO           = 'n',  ///< Current buffer number.+  STL_KEYMAP          = 'k',  ///< 'keymap' when active.+  STL_OFFSET          = 'o',  ///< Offset of character under cursor.+  STL_OFFSET_X        = 'O',  ///< - in hexadecimal.+  STL_BYTEVAL         = 'b',  ///< Byte value of character.+  STL_BYTEVAL_X       = 'B',  ///< - in hexadecimal.+  STL_ROFLAG          = 'r',  ///< Readonly flag.+  STL_ROFLAG_ALT      = 'R',  ///< - other display.+  STL_HELPFLAG        = 'h',  ///< Window is showing a help file.+  STL_HELPFLAG_ALT    = 'H',  ///< - other display.+  STL_FILETYPE        = 'y',  ///< 'filetype'.+  STL_FILETYPE_ALT    = 'Y',  ///< - other display.+  STL_PREVIEWFLAG     = 'w',  ///< Window is showing the preview buf.+  STL_PREVIEWFLAG_ALT = 'W',  ///< - other display.+  STL_MODIFIED        = 'm',  ///< Modified flag.+  STL_MODIFIED_ALT    = 'M',  ///< - other display.+  STL_QUICKFIX        = 'q',  ///< Quickfix window description.+  STL_PERCENTAGE      = 'p',  ///< Percentage through file.+  STL_ALTPERCENT      = 'P',  ///< Percentage as TOP BOT ALL or NN%.+  STL_ARGLISTSTAT     = 'a',  ///< Argument list status as (x of y).+  STL_PAGENUM         = 'N',  ///< Page number (when printing).+  STL_VIM_EXPR        = '{',  ///< Start of expression to substitute.+  STL_MIDDLEMARK      = '=',  ///< Separation between left and right.+  STL_TRUNCMARK       = '<',  ///< Truncation mark if line is too long.+  STL_USER_HL         = '*',  ///< Highlight from (User)1..9 or 0.+  STL_HIGHLIGHT       = '#',  ///< Highlight name.+  STL_TABPAGENR       = 'T',  ///< Tab page label nr.+  STL_TABCLOSENR      = 'X',  ///< Tab page close nr.+  STL_CLICK_FUNC      = '@',  ///< Click region start.",A full stop (period) at the end of sentence fragments or item lists is not meaningful or useful. Does clint require it?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3916,48596975,2015-12-30T10:29:57Z,src/nvim/eval.c,"@@ -15804,7 +15804,7 @@ static void f_str2nr(typval_T *argvars, typval_T *rettv)   p = skipwhite(get_tv_string(&argvars[0]));   if (*p == '+')     p = skipwhite(p + 1);-  vim_str2nr(p, NULL, NULL, base == 8 ? 2 : 0, base == 16 ? 2 : 0, &n, NULL);+  vim_str2nr(p, NULL, NULL, base == 2 ? 2 : 0, base == 8 ? 2 : 0, base == 16 ? 2 : 0, &n, NULL);",Too long line,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3914,48598667,2015-12-30T11:09:37Z,src/nvim/ex_cmds.c,"@@ -283,8 +283,8 @@ static int sort_abort;                  /* flag to indicate if sorting has been /* Struct to store info to be sorted. */ typedef struct {   linenr_T lnum;                        /* line number */-  long start_col_nr;                    /* starting column number or number */-  long end_col_nr;                      /* ending column number */+  NumOpt start_col_nr;                  /* starting column number or number */","I think it is better to leave this, and instead `vim_str2nr` to a temporary and then convert. (If anything,  these should be changed to `colnr_T` but that's a change for another PR)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3916,48616385,2015-12-30T17:05:55Z,src/nvim/charset.c,"@@ -1720,33 +1748,38 @@ int vim_isblankline(char_u *lbuf) }  /// Convert a string into a long and/or unsigned long, taking care of-/// hexadecimal and octal numbers.  Accepts a '-' sign.-/// If ""hexp"" is not NULL, returns a flag to indicate the type of the number:+/// hexadecimal, octal and binary numbers.  Accepts a '-' sign.+/// If ""prep"" is not NULL, returns a flag to indicate the type of the number: ///   0      decimal ///   '0'    octal+///   'B'	   bin+///   'b'	   bin",align with the other items in this list,
3147166,uxcn,https://api.github.com/repos/neovim/neovim/pulls/3916,48629613,2015-12-30T20:37:19Z,src/nvim/charset.c,"@@ -1720,33 +1748,38 @@ int vim_isblankline(char_u *lbuf) }  /// Convert a string into a long and/or unsigned long, taking care of-/// hexadecimal and octal numbers.  Accepts a '-' sign.-/// If ""hexp"" is not NULL, returns a flag to indicate the type of the number:+/// hexadecimal, octal and binary numbers.  Accepts a '-' sign.+/// If ""prep"" is not NULL, returns a flag to indicate the type of the number: ///   0      decimal ///   '0'    octal+///   'B'	   bin+///   'b'	   bin ///   'X'    hex ///   'x'    hex /// If ""len"" is not NULL, the length of the number in characters is returned. /// If ""nptr"" is not NULL, the signed result is returned in it. /// If ""unptr"" is not NULL, the unsigned result is returned in it.+/// If ""dobin"" is non-zero recognize binary numbers, when > 1 always assume+/// binary number. /// If ""dooct"" is non-zero recognize octal numbers, when > 1 always assume /// octal number. /// If ""dohex"" is non-zero recognize hex numbers, when > 1 always assume /// hex number. /// /// @param start-/// @param hexp Returns type of number 0 = decimal, 'x' or 'X' is hex,-//         '0' = octal+/// @param prep Returns type of number 0 = decimal, 'x' or 'X' is hex,+//         '0' = octal, 'b' or 'B' is bin /// @param len Returns the detected length of number.+/// @param dobin recognize binary number /// @param dooct recognize octal number /// @param dohex recognize hex number /// @param nptr Returns the signed result. /// @param unptr Returns the unsigned result.-void vim_str2nr(char_u *start, int *hexp, int *len, int dooct, int dohex,+void vim_str2nr(char_u *start, int *prep, int *len, int dobin, int dooct, int dohex,","I agree with Bram, but I wanted to avoid changing the semantics in the code at least for this PR.  Changing APIs always worries me.  There were a couple other things I noticed though.I think a bitmask of _do_ parse bases could replace the three _doX_ bases, and then for the _doX_ > 1, add an explicit base parameter.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3916,48631602,2015-12-30T21:09:11Z,src/nvim/charset.c,"@@ -1720,33 +1748,38 @@ int vim_isblankline(char_u *lbuf) }  /// Convert a string into a long and/or unsigned long, taking care of-/// hexadecimal and octal numbers.  Accepts a '-' sign.-/// If ""hexp"" is not NULL, returns a flag to indicate the type of the number:+/// hexadecimal, octal and binary numbers.  Accepts a '-' sign.+/// If ""prep"" is not NULL, returns a flag to indicate the type of the number: ///   0      decimal ///   '0'    octal+///   'B'	   bin+///   'b'	   bin ///   'X'    hex ///   'x'    hex /// If ""len"" is not NULL, the length of the number in characters is returned. /// If ""nptr"" is not NULL, the signed result is returned in it. /// If ""unptr"" is not NULL, the unsigned result is returned in it.+/// If ""dobin"" is non-zero recognize binary numbers, when > 1 always assume+/// binary number. /// If ""dooct"" is non-zero recognize octal numbers, when > 1 always assume /// octal number. /// If ""dohex"" is non-zero recognize hex numbers, when > 1 always assume /// hex number. /// /// @param start-/// @param hexp Returns type of number 0 = decimal, 'x' or 'X' is hex,-//         '0' = octal+/// @param prep Returns type of number 0 = decimal, 'x' or 'X' is hex,+//         '0' = octal, 'b' or 'B' is bin /// @param len Returns the detected length of number.+/// @param dobin recognize binary number /// @param dooct recognize octal number /// @param dohex recognize hex number /// @param nptr Returns the signed result. /// @param unptr Returns the unsigned result.-void vim_str2nr(char_u *start, int *hexp, int *len, int dooct, int dohex,+void vim_str2nr(char_u *start, int *prep, int *len, int dobin, int dooct, int dohex,","@uxcn I do not think this is correct concern. By adding a new argument you already did change the API, and semantics cannot be changed by converting three boolean options into a flag. Semantics would change if you converted three booleans into a `struct { char *prefix; int base; }[]`: to generalize the function it is logical to make it be called like```vim_str2nr(""0b10110"", &type, &len, (Bases[]) { { ""0x"", 16 }, { ""0"", 8 }, { ""0b"", 2 }, { NULL, 10 }, { NULL, 0 } }, &n, &un)```: change makes sense, but here you supply prefixes to try (determining order) and thus change function that supports fixed formats defined internally to a function that accepts rather broad range of formats defined externally.",
3147166,uxcn,https://api.github.com/repos/neovim/neovim/pulls/3916,48669722,2015-12-31T20:06:16Z,src/nvim/charset.c,"@@ -1720,33 +1748,38 @@ int vim_isblankline(char_u *lbuf) }  /// Convert a string into a long and/or unsigned long, taking care of-/// hexadecimal and octal numbers.  Accepts a '-' sign.-/// If ""hexp"" is not NULL, returns a flag to indicate the type of the number:+/// hexadecimal, octal and binary numbers.  Accepts a '-' sign.+/// If ""prep"" is not NULL, returns a flag to indicate the type of the number: ///   0      decimal ///   '0'    octal+///   'B'	   bin+///   'b'	   bin ///   'X'    hex ///   'x'    hex /// If ""len"" is not NULL, the length of the number in characters is returned. /// If ""nptr"" is not NULL, the signed result is returned in it. /// If ""unptr"" is not NULL, the unsigned result is returned in it.+/// If ""dobin"" is non-zero recognize binary numbers, when > 1 always assume+/// binary number. /// If ""dooct"" is non-zero recognize octal numbers, when > 1 always assume /// octal number. /// If ""dohex"" is non-zero recognize hex numbers, when > 1 always assume /// hex number. /// /// @param start-/// @param hexp Returns type of number 0 = decimal, 'x' or 'X' is hex,-//         '0' = octal+/// @param prep Returns type of number 0 = decimal, 'x' or 'X' is hex,+//         '0' = octal, 'b' or 'B' is bin /// @param len Returns the detected length of number.+/// @param dobin recognize binary number /// @param dooct recognize octal number /// @param dohex recognize hex number /// @param nptr Returns the signed result. /// @param unptr Returns the unsigned result.-void vim_str2nr(char_u *start, int *hexp, int *len, int dooct, int dohex,+void vim_str2nr(char_u *start, int *prep, int *len, int dobin, int dooct, int dohex,","Making `vim_str2nr` completely generic would be a much bigger change.  The function is pretty tightly coupled to base representations.  For example, pattern matching is done explicitly.  Patterns can also overlap (e.g. `0x0b01` could match as `0b01` or `0x0b01`).  There are other places in code that rely on explicit representations for numbers as well.  Another question might also be, should multiple prefixes be allowed (e.g. `0x` and `0h` or `h`)?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3916,48671894,2015-12-31T21:38:21Z,src/nvim/charset.c,"@@ -1720,33 +1748,38 @@ int vim_isblankline(char_u *lbuf) }  /// Convert a string into a long and/or unsigned long, taking care of-/// hexadecimal and octal numbers.  Accepts a '-' sign.-/// If ""hexp"" is not NULL, returns a flag to indicate the type of the number:+/// hexadecimal, octal and binary numbers.  Accepts a '-' sign.+/// If ""prep"" is not NULL, returns a flag to indicate the type of the number: ///   0      decimal ///   '0'    octal+///   'B'	   bin+///   'b'	   bin ///   'X'    hex ///   'x'    hex /// If ""len"" is not NULL, the length of the number in characters is returned. /// If ""nptr"" is not NULL, the signed result is returned in it. /// If ""unptr"" is not NULL, the unsigned result is returned in it.+/// If ""dobin"" is non-zero recognize binary numbers, when > 1 always assume+/// binary number. /// If ""dooct"" is non-zero recognize octal numbers, when > 1 always assume /// octal number. /// If ""dohex"" is non-zero recognize hex numbers, when > 1 always assume /// hex number. /// /// @param start-/// @param hexp Returns type of number 0 = decimal, 'x' or 'X' is hex,-//         '0' = octal+/// @param prep Returns type of number 0 = decimal, 'x' or 'X' is hex,+//         '0' = octal, 'b' or 'B' is bin /// @param len Returns the detected length of number.+/// @param dobin recognize binary number /// @param dooct recognize octal number /// @param dohex recognize hex number /// @param nptr Returns the signed result. /// @param unptr Returns the unsigned result.-void vim_str2nr(char_u *start, int *hexp, int *len, int dooct, int dohex,+void vim_str2nr(char_u *start, int *prep, int *len, int dobin, int dooct, int dohex,","@uxcn It was an _illustration_ to what I think does change the semantics, opposed to converting three booleans into a flag option which does not.",
3147166,uxcn,https://api.github.com/repos/neovim/neovim/pulls/3916,48672286,2015-12-31T21:57:18Z,src/nvim/charset.c,"@@ -1720,33 +1748,38 @@ int vim_isblankline(char_u *lbuf) }  /// Convert a string into a long and/or unsigned long, taking care of-/// hexadecimal and octal numbers.  Accepts a '-' sign.-/// If ""hexp"" is not NULL, returns a flag to indicate the type of the number:+/// hexadecimal, octal and binary numbers.  Accepts a '-' sign.+/// If ""prep"" is not NULL, returns a flag to indicate the type of the number: ///   0      decimal ///   '0'    octal+///   'B'	   bin+///   'b'	   bin ///   'X'    hex ///   'x'    hex /// If ""len"" is not NULL, the length of the number in characters is returned. /// If ""nptr"" is not NULL, the signed result is returned in it. /// If ""unptr"" is not NULL, the unsigned result is returned in it.+/// If ""dobin"" is non-zero recognize binary numbers, when > 1 always assume+/// binary number. /// If ""dooct"" is non-zero recognize octal numbers, when > 1 always assume /// octal number. /// If ""dohex"" is non-zero recognize hex numbers, when > 1 always assume /// hex number. /// /// @param start-/// @param hexp Returns type of number 0 = decimal, 'x' or 'X' is hex,-//         '0' = octal+/// @param prep Returns type of number 0 = decimal, 'x' or 'X' is hex,+//         '0' = octal, 'b' or 'B' is bin /// @param len Returns the detected length of number.+/// @param dobin recognize binary number /// @param dooct recognize octal number /// @param dohex recognize hex number /// @param nptr Returns the signed result. /// @param unptr Returns the unsigned result.-void vim_str2nr(char_u *start, int *hexp, int *len, int dooct, int dohex,+void vim_str2nr(char_u *start, int *prep, int *len, int dobin, int dooct, int dohex,","They actually have `int` semantics for now (1: maybe/prefix, 2: always/no-prefix).  The `ex_sort` function is roughly the same.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3707,48677412,2016-01-01T11:53:59Z,src/nvim/ops.c,"@@ -2497,9 +2499,7 @@ static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)    */   curbuf->b_op_start = oap->start;   curbuf->b_op_end = oap->end;-  if (yanktype == MLINE-      && !oap->block_mode-      ) {+  if (yanktype == MLINE) {","You're right that oap->block_mode could have be true even if oap->motion_type == MLINE, if a linewise motion get forced into block-mode (`d^V3d`). But then the operation is still purely block-wise, the fact that it ""once was"" a linewise motion has no effect. (I mean, this if block will be executed under the same set of circumstances as before, even if the condition _looks_ different)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3655,48686323,2016-01-02T18:13:40Z,src/nvim/mbyte.c,"@@ -2425,11 +2420,8 @@ char_u *enc_canonize(char_u *enc) FUNC_ATTR_NONNULL_RET   int i;    if (STRCMP(enc, ""default"") == 0) {-    /* Use the default encoding as it's found by set_init_1(). */-    char_u *r = get_encoding_default();-    if (r == NULL)-      r = (char_u *)""latin1"";-    return vim_strsave(r);+    // Use the default encoding as it's found by set_init_1().+    return vim_strsave(enc_default);","~~""as it's found by set_init_1()"" is no longer relevant.~~ oops, I get it now. I was confused by the name. I suggest renaming to `fenc_default`.",
715238,equalsraf,https://api.github.com/repos/neovim/neovim/pulls/3303,48696189,2016-01-03T19:41:18Z,src/nvim/os/env.c,"@@ -557,6 +557,27 @@ char *vim_getenv(const char *name)     if (p_hf != NULL && vim_strchr(p_hf, '$') == NULL) {       vim_path = (char *)p_hf;     }++#ifdef WIN32+    // Find runtime path relative to the nvim binary i.e. ../share/runtime+    char exe_name[MAXPATHL];+    char abs_runtime_path[MAXPATHL];+    if (vim_path == NULL) {+      if (os_exepath(exe_name, MAXPATHL) == 0) {+        // Remove trailing bin/nvim.exe+        char *path_end = (char *)path_tail_with_sep((char_u *)exe_name);+        *path_end = '\0';+        path_end = (char *)path_tail((char_u *)exe_name);+        *path_end = '\0';","I messed up there. Notice abs_runtime_path is not even being used. The idea was to remove the last two components in the path, first `/nvim.exe` and then `bin`. path_end is not discarded it is just used to find the end of the path and place a '\0'.",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3698,49013496,2016-01-06T21:41:06Z,src/nvim/fileio.c,"@@ -4082,19 +4091,21 @@ static int buf_write_bytes(struct bw_info *ip)   return (wlen < len) ? FAIL : OK; } -/*- * Convert a Unicode character to bytes.- * Return TRUE for an error, FALSE when it's OK.- */-static int -ucs2bytes (-    unsigned c,                     /* in: character */-    char_u **pp,               /* in/out: pointer to result */-    int flags                      /* FIO_ flags */+/// Convert a Unicode character to bytes.+///+/// @param         c     The character to convert+/// @param[in,out] pp    The pointer to store the result at+/// @param         flags The FIO_ flags to use+///+/// @return true for an error, false when it's OK.+static bool ucs2bytes(+    unsigned c,+    char_u **pp,+    int flags",This doesn't follow the style guide. It should be on same line or aligned on parenthese if too long. This comment stands for every same issue in this PR.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3952,49021723,2016-01-06T22:56:32Z,runtime/doc/various.txt,"@@ -272,19 +272,15 @@ g8			Print the hex values of the bytes used in the :!!			Repeat last "":!{cmd}"".  							*:ve* *:version*-:ve[rsion]		Print the version number of the editor.  If the-			compiler used understands ""__DATE__"" the compilation-			date is mentioned.  Otherwise a fixed release-date is-			shown.-			The following lines contain information about which-			features were enabled when Vim was compiled.  When-			there is a preceding '+', the feature is included,-			when there is a '-' it is excluded.  To change this,-			you have to edit feature.h and recompile Vim.-			To check for this in an expression, see |has()|.-			Here is an overview of the features.-			The first column shows the smallest version in which-			they are included:+:ve[rsion]		Print the version number of the editor.  The following+			lines contain information about which features were+			enabled when Vim was compiled.  When there is a+			preceding '+', the feature is included, when there is+			a '-' it is excluded.  To change this, you have to+			edit feature.h and recompile Vim.  To check for this+			in an expression, see |has()|.  Here is an overview of+			the features.  The first column shows the smallest+			version in which they are included: 			   T	tiny","But this whole section mentions deprecated concepts, so let's not hold this up for now.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3954,49120562,2016-01-07T20:17:19Z,runtime/doc/insert.txt,"@@ -1941,9 +1941,9 @@ If the 'fileformats' option is not empty Vim tries to recognize the type of changed, the detected format is only used while reading the file. A similar thing happens with 'fileencodings'. -On non-MS-DOS and Win32 systems the message ""[dos format]"" is shown if+On non-Windows systems the message ""[dos format]"" is shown if a file is read in DOS format, to remind you that something unusual is done.-On Macintosh, MS-DOS, and Win32 the message ""[unix format]"" is shown if+On Macintosh and Windows the message ""[unix format]"" is shown if","I would suggest one word, ""OSX"". That's how libuv does it in their source code, it makes grepping and web-searching easier, avoid bad word-wrap, etc. Who cares if it's not pedantically correct :P",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3954,49120918,2016-01-07T20:20:40Z,runtime/doc/insert.txt,"@@ -1941,9 +1941,9 @@ If the 'fileformats' option is not empty Vim tries to recognize the type of changed, the detected format is only used while reading the file. A similar thing happens with 'fileencodings'. -On non-MS-DOS and Win32 systems the message ""[dos format]"" is shown if+On non-Windows systems the message ""[dos format]"" is shown if a file is read in DOS format, to remind you that something unusual is done.-On Macintosh, MS-DOS, and Win32 the message ""[unix format]"" is shown if+On Macintosh and Windows the message ""[unix format]"" is shown if",Heh. I'm pedantic. Whatever we use `OSX` or `OS X` we should just be consistent. I would prefer `OS X` for user docs though.,
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3954,49120929,2016-01-07T20:20:47Z,runtime/doc/insert.txt,"@@ -1941,9 +1941,9 @@ If the 'fileformats' option is not empty Vim tries to recognize the type of changed, the detected format is only used while reading the file. A similar thing happens with 'fileencodings'. -On non-MS-DOS and Win32 systems the message ""[dos format]"" is shown if+On non-Windows systems the message ""[dos format]"" is shown if a file is read in DOS format, to remind you that something unusual is done.-On Macintosh, MS-DOS, and Win32 the message ""[unix format]"" is shown if+On Macintosh and Windows the message ""[unix format]"" is shown if","> it makes grepping and web-searching easier, avoid bad word-wrap:+1: but let's do that in another PR",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3953,49120984,2016-01-07T20:21:23Z,runtime/doc/options.txt,"@@ -4929,7 +4929,7 @@ A jump table for the options with a short description can be found at |Q_op|. 			 *'restorescreen'* *'rs'* *'norestorescreen'* *'nors'* 'restorescreen' 'rs'	boolean	(default on) 			global-			{only in Windows 95/NT console version}+			{Windows only}","Given no such code seems for this option seems to exist in Neovim, I think this is a prime candidate for removal. Here's a patch:``` diffdiff --git a/runtime/doc/options.txt b/runtime/doc/options.txtindex 926f26f..c3fb23a 100644--- a/runtime/doc/options.txt+++ b/runtime/doc/options.txt@@ -4927,18 +4927,7 @@ A jump table for the options with a short description can be found at |Q_op|.    instead of the number of lines.             *'restorescreen'* *'rs'* *'norestorescreen'* *'nors'*-'restorescreen' 'rs'   boolean (default on)-           global-           {Windows only}-   When set, the screen contents is restored when exiting Vim.  This also-   happens when executing external commands.--   For non-Windows Vim: You can set or reset the 't_ti' and 't_te'-   options in your vimrc.  To disable restoring:-       set t_ti= t_te=-   To enable restoring (for an xterm):-       set t_ti=^[7^[[r^[[?47h t_te=^[[?47l^[8-   (Where ^[ is an <Esc>, type CTRL-V <Esc> to insert it)+'restorescreen' 'rs'   Removed. |vim-differences| {Nvim}                *'revins'* *'ri'* *'norevins'* *'nori'* 'revins' 'ri'      boolean (default off)diff --git a/runtime/doc/os_win32.txt b/runtime/doc/os_win32.txtindex 57a6ad9..3c7ca4e 100644--- a/runtime/doc/os_win32.txt+++ b/runtime/doc/os_win32.txt@@ -14,9 +14,8 @@ The 32 bit version also runs on 64 bit MS-Windows systems. 1. Known problems      |win32-problems| 2. Startup         |win32-startup|-3. Restore screen contents |win32-restore|-4. Using the mouse     |win32-mouse|-5. Win32 mini FAQ          |win32-faq|+3. Using the mouse     |win32-mouse|+4. Win32 mini FAQ          |win32-faq| Additionally, there are a number of common Win32 and DOS items: File locations         |dos-locations|@@ -77,14 +76,7 @@ make ""!xxd"" work, as it is in the Tools menu.  And it also means that when executable() returns 1 the executable can actually be executed. ==============================================================================-3. Restore screen contents             *win32-restore*--When 'restorescreen' is set (which is the default), Vim will restore the-original contents of the console when exiting or when executing external-commands.  If you don't want this, use "":set nors"".    |'restorescreen'|--==============================================================================-4. Using the mouse                 *win32-mouse*+3. Using the mouse                 *win32-mouse* The Win32 version of Vim supports using the mouse.  If you have a two-button mouse, the middle button can be emulated by pressing both left and right@@ -96,7 +88,7 @@ When the mouse doesn't work, try disabling the ""Quick Edit Mode"" feature of the console. ==============================================================================-5. Win32 mini FAQ                  *win32-faq*+4. Win32 mini FAQ                  *win32-faq* Q. How do I change the font? A. In the GUI version, you can use the 'guifont' option.  Example: >diff --git a/runtime/doc/quickref.txt b/runtime/doc/quickref.txtindex ea73b99..1346a83 100644--- a/runtime/doc/quickref.txt+++ b/runtime/doc/quickref.txt@@ -820,7 +820,6 @@ Short explanation of each option:       *option-list* 'relativenumber'  'rnu'        show relative line number in front of each line 'remap'                allow mappings to work recursively 'report'           threshold for reporting nr. of lines changed-'restorescreen'   'rs'     Win32: restore screen when exiting 'revins'     'ri'      inserting characters will work backwards 'rightleft'      'rl'      window is right-to-left oriented 'rightleftcmd'   'rlc'     commands for which editing works right-to-leftdiff --git a/runtime/optwin.vim b/runtime/optwin.vimindex dde5dd0..03e44ab 100644--- a/runtime/optwin.vim+++ b/runtime/optwin.vim@@ -540,10 +540,6 @@ if has(""title"")   call append(""$"", ""iconstring\twhen not empty, text for the icon of this window"")   call <SID>OptionG(""iconstring"", &iconstring) endif-if has(""win32"")-  call append(""$"", ""restorescreen\trestore the screen contents when exiting Vim"")-  call <SID>BinOptionG(""rs"", &rs)-endif call <SID>Header(""using the mouse"")diff --git a/src/nvim/options.lua b/src/nvim/options.luaindex 945626f..cdac6ff 100644--- a/src/nvim/options.lua+++ b/src/nvim/options.lua@@ -1856,13 +1856,6 @@ return {       defaults={if_true={vi=2}}     },     {-      full_name='restorescreen', abbreviation='rs',-      type='bool', scope={'global'},-      vi_def=true,-      enable_if=false,-      defaults={if_true={vi=true}}-    },-    {       full_name='revins', abbreviation='ri',       type='bool', scope={'global'},       vi_def=true,```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3839,49160985,2016-01-08T06:13:04Z,CMakeLists.txt,"@@ -51,15 +51,25 @@ if(NOT CMAKE_BUILD_TYPE)   set(CMAKE_BUILD_TYPE ""Dev"" CACHE STRING ""Choose the type of build."" FORCE) endif() -# If not in a git repo (e.g., a tarball) these tokens set the version string,-# otherwise the result of `git describe` is used.+# If not in a git repo (e.g., a tarball) these tokens define the complete+# version string, else it is combined with the result of `git describe`. set(NVIM_VERSION_MAJOR 0) set(NVIM_VERSION_MINOR 1)-set(NVIM_VERSION_PATCH 1)+set(NVIM_VERSION_PATCH 2)+set(NVIM_VERSION_PRERELEASE ""-dev"") # for package maintainers  file(TO_CMAKE_PATH ${CMAKE_CURRENT_LIST_DIR}/.git FORCED_GIT_DIR) include(GetGitRevisionDescription)-git_describe(NVIM_VERSION_MEDIUM)+get_git_head_revision(GIT_REFSPEC NVIM_VERSION_COMMIT)+if(NVIM_VERSION_COMMIT) # is a git repo","@Pyrohh I had to restore this condition because otherwise NVIM_VERSION_MEDIUM gets a dummy value ""HEAD-HASH-NOTFOUND"".re 7be12edd38b1da0a506f39651d8c6a6f9aa5626a",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3962,49246558,2016-01-08T22:30:48Z,runtime/doc/mbyte.txt,"@@ -837,14 +837,11 @@ WHAT IS IME     URL.  WHAT IS GLOBAL IME					*global-ime*-    Global IME makes capability to input Chinese, Japanese, and Korean text-    into Vim buffer on any language version of Windows 98, Windows 95, and-    Windows NT 4.0.-    On Windows 2000 and XP it should work as well (without downloading).  On-    Windows 2000 Professional, Global IME is built in, and the Input Locales-    can be added through Control Panel/Regional Options/Input Locales.-    Please see below URL for detail of Global IME.  You can also find various-    language version of Global IME at same place.+    Global IME enables input of Chinese, Japanese, and Korean text into Vim+    buffer on any language version of Windows.  Global IME is built in, and+    the Input Locales can be added through Control Panel/Regional+    Options/Input Locales.  Please see below URL for detail of Global IME.+    You can also find various language version of Global IME at same place.","I'm pretty sure we can nuke large parts of this file, but that might be better left to a separate PR.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3967,49259813,2016-01-09T03:42:37Z,src/nvim/fileio.c,"@@ -5992,18 +6005,20 @@ void ex_doautoall(exarg_T *eap)   check_cursor();           /* just in case lines got deleted */ } -/*- * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise- * return TRUE and advance *argp to after it.- * Thus return TRUE when do_modelines() should be called.- */-int check_nomodeline(char_u **argp)+/// Check *argp for <nomodeline>.  When it is present return false, otherwise+/// return true and advance *argp to after it.+/// Thus return true when do_modelines() should be called.+///+/// @param[in,out] The argument string",There is no parameter `The`.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3967,49259949,2016-01-09T03:54:23Z,src/nvim/fileio.c,"@@ -5992,18 +6005,20 @@ void ex_doautoall(exarg_T *eap)   check_cursor();           /* just in case lines got deleted */ } -/*- * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise- * return TRUE and advance *argp to after it.- * Thus return TRUE when do_modelines() should be called.- */-int check_nomodeline(char_u **argp)+/// Check *argp for <nomodeline>.  When it is present return false, otherwise+/// return true and advance *argp to after it.+/// Thus return true when do_modelines() should be called.+///+/// @param[in,out] The argument string","I strongly urge everyone to omit ""The"" from parameter the start of parameter descriptions unless it really is unreadable otherwise.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/2667,49271938,2016-01-10T05:52:15Z,CMakeLists.txt,"@@ -381,6 +381,20 @@ install_helper(   FILES ${MANPAGES}   DESTINATION ${CMAKE_INSTALL_MANDIR}/man1) +# MIN_LOG_LEVEL for log.h+if(DEFINED MIN_LOG_LEVEL)+  if(NOT MIN_LOG_LEVEL MATCHES ""^[0-3]$"")+    message(FATAL_ERROR ""MIN_LOG_LEVEL must be a number DEBUG (0), INFO (1), WARNING (2) or ERROR (3)"")+  endif()+  message(STATUS ""Log level set to ${MIN_LOG_LEVEL}"")+elseif(TRAVIS_CI_BUILD)",Why move this from `.travis.yml`? I think we should avoid sprinkling CI-specific conditions in the build files--try to keep it in .travis.yml.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3973,49277728,2016-01-10T16:17:22Z,test/functional/job/job_spec.lua,"@@ -228,10 +228,10 @@ describe('jobs', function()     it('returns a list of status codes', function()       source([[       call rpcnotify(g:channel, 'wait', jobwait([-      \  jobstart([&sh, '-c', 'sleep 0.10; exit 4']),-      \  jobstart([&sh, '-c', 'sleep 0.110; exit 5']),-      \  jobstart([&sh, '-c', 'sleep 0.210; exit 6']),-      \  jobstart([&sh, '-c', 'sleep 0.310; exit 7'])+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.10; exit 4']),+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.110; exit 5']),+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.210; exit 6']),+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.310; exit 7'])","sleep isn't typically available on Windows 7. The old [`ping` trick](http://ss64.com/nt/sleep.html)```ping -n 4 -w 110 127.0.0.1>nul```even with the `-w` option seems not very precise. We can ship `sleep.exe` with the Windows build, but even if we do that we should skip these tests if `sleep` cannot be found, so that running the tests on Windows is not unpleasant for new contributors. ``` cif eval(""executable('sleep')"") == 0 then  pending('missing ""sleep"" command', function() end)else  it('returns a list of status codes', function()  ...```reference: https://github.com/neovim/neovim/wiki/Unit-tests",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3973,49278362,2016-01-10T17:07:19Z,test/functional/job/job_spec.lua,"@@ -228,10 +228,10 @@ describe('jobs', function()     it('returns a list of status codes', function()       source([[       call rpcnotify(g:channel, 'wait', jobwait([-      \  jobstart([&sh, '-c', 'sleep 0.10; exit 4']),-      \  jobstart([&sh, '-c', 'sleep 0.110; exit 5']),-      \  jobstart([&sh, '-c', 'sleep 0.210; exit 6']),-      \  jobstart([&sh, '-c', 'sleep 0.310; exit 7'])+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.10; exit 4']),+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.110; exit 5']),+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.210; exit 6']),+      \  jobstart([&sh, &shellcmdflag, 'sleep 0.310; exit 7'])","Actually you should have here `jobstart(split(&shell) + split(&shellcmdflag) + ['sleep 0.10; exit 4'])`. Documentation that says that `jobstart('{cmd}')` has something to do with```            :call jobstart([&shell, &shellcmdflag, '{cmd}'])```is incorrect. My variant is neither because &shell and &shellcmdflag are split with quotes taken into account (which I find rather useless because I have not found where it is unquoted and additionally it does not take backslash into account), but this is closer.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3979,49280410,2016-01-10T19:45:52Z,src/nvim/os/os_defs.h,"@@ -18,11 +18,15 @@ #endif  #if defined(UFS_MAXNAMLEN) && !defined(MAXNAMLEN)-# define MAXNAMLEN UFS_MAXNAMLEN    /* for dynix/ptx */+# define MAXNAMLEN UFS_MAXNAMLEN    // for dynix/ptx","At least one reason is that it can silently break multi-line macros: http://stackoverflow.com/a/1511383/152142TBH I don't remember if there is any technical reason to disallow `//` in single-line macros like this, other than having a consistent practice and avoiding future mistakes.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3982,49282462,2016-01-10T22:24:17Z,src/nvim/keymap.c,"@@ -665,19 +662,12 @@ int extract_modifiers(int key, int *modp)     modifiers &= ~MOD_MASK_SHIFT;   }   if ((modifiers & MOD_MASK_CTRL)-      && ((key >= '?' && key <= '_') || ASCII_ISALPHA(key))-      ) {+      && ((key >= '?' && key <= '_') || ASCII_ISALPHA(key))) {     key = Ctrl_chr(key);     modifiers &= ~MOD_MASK_CTRL;-    /* <C-@> is <Nul> */-    if (key == 0)+    if (key == 0) {  // <C-@> is <Nul>       key = K_ZERO;-  }-  if ((modifiers & MOD_MASK_ALT) && key < 0x80-      && !enc_dbcs                      /* avoid creating a lead byte */-      ) {-    key |= 0x80;-    modifiers &= ~MOD_MASK_ALT;         /* remove the META modifier */","By deleting this block, - we no longer set the high bit to represent alt- the global `mod_mask` keeps the `MOD_MASK_ALT` flag",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3967,49282565,2016-01-10T22:31:05Z,src/nvim/fileio.c,"@@ -5992,18 +6011,20 @@ void ex_doautoall(exarg_T *eap)   check_cursor();           /* just in case lines got deleted */ } -/*- * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise- * return TRUE and advance *argp to after it.- * Thus return TRUE when do_modelines() should be called.- */-int check_nomodeline(char_u **argp)+/// Check *argp for <nomodeline>.  When it is present return false, otherwise+/// return true and advance *argp to after it.+///+/// @param[in,out] argp argument string+///+/// @return true when do_modelines() should be called.","I just mean this change splits the information about the return value in two parts, for no reason. Becuse the return value is related to the side-effect (argp), the _simplest_ fix would be to just move back this to the describtion. (but if you prefere you can edit it otherwise, as long as the split is resolved)",
448087,jszakmeister,https://api.github.com/repos/neovim/neovim/pulls/3983,49303300,2016-01-11T09:51:00Z,runtime/CMakeLists.txt,"@@ -26,11 +26,15 @@ foreach(DF ${DOCFILES})   list(APPEND BUILDDOCFILES ${GENERATED_RUNTIME_DIR}/doc/${F}) endforeach() -add_custom_command(OUTPUT ${BUILDDOCFILES}-  COMMAND ${CMAKE_COMMAND} -E copy_directory-    ${PROJECT_SOURCE_DIR}/runtime/doc ${GENERATED_RUNTIME_DIR}/doc-  DEPENDS-    ${DOCFILES})+set(DOCFILE_DEPS ${DOCFILES})+foreach(DOCFILE ${BUILDDOCFILES})+  list(REMOVE_AT DOCFILE_DEPS 0)+  add_custom_command(OUTPUT ${DOCFILE}+    COMMAND ${CMAKE_COMMAND} -E copy_directory+      ${PROJECT_SOURCE_DIR}/runtime/doc ${GENERATED_RUNTIME_DIR}/doc+    DEPENDS+    ${DOCFILE_DEPS})+endforeach()","Two things.  First, your repeatedly copying all the files into the directory over and over again--I don't think we want that.Second, perhaps the better thing to do would be make each docfile depend on it's original source file, instead of this set that gradually dwindles?  We could pitch this loop, and re-use the one above:``` cmakeset(BUILDDOCFILES)foreach(DF ${DOCFILES})  get_filename_component(F ${DF} NAME)  set(BF ${GENERATED_RUNTIME_DIR}/doc/${F})  list(APPEND BUILDDOCFILES ${BF})  add_custom_command(OUTPUT ${BF}    COMMAND ${CMAKE_COMMAND} -E copy ${DF} ${BF}    DEPENDS ${DF})endforeach()```I think something like this would be better, IMHO, since we're only copying the source file and nothing more for a particular output.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,49447588,2016-01-12T12:27:35Z,src/nvim/ops.c,"@@ -2874,7 +2872,8 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)      /* adjust '] mark */     curbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;-    curbuf->b_op_end.col = bd.textcol + totlen - 1;+    assert(totlen <= INT_MAX);","I don't really like just adding a assert everytime a value is downcast, at least not where there is a more relevant _dynamic_ condition to check, i e `bd.textcol + totlen - 1 < MAXCOL` in this case  (unless this already directly/indirectly checked above somewhere...)",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3745,49511176,2016-01-12T20:50:48Z,src/nvim/ops.c,"@@ -2927,13 +2926,14 @@ void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)      */     if (y_type == MCHAR && y_size == 1) {       do {-        totlen = count * yanklen;+        assert(count <= INT_MAX);",actually I tried to blame the `count == -1` line in vim but got stuck at 7.0.001 and I was to lazy to look up the archival repository. I suppose this was once used somewhere but that got deleted. Let's say assuming count >= 0 is fine.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3992,49585690,2016-01-13T12:46:31Z,src/nvim/shada.c,"@@ -21,6 +13,11 @@ #include ""nvim/os/os.h"" #include ""nvim/os/time.h"" #include ""nvim/vim.h""+#ifdef HAVE_BE64TOH+# define _BSD_SOURCE 1+# define _DEFAULT_SOURCE 1+# include <endian.h>+#endif","And I would say it is better placed after `nvim` defines list, not break this large group into pieces. Or be in the same group as `vim.h` above: `vim.h+endian.h`, blank, `os/os.h+���+lib/kvec.h`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3914,49840767,2016-01-15T10:40:06Z,src/nvim/globals.h,"@@ -117,12 +117,8 @@ #define DFLT_COLS       80              /* default value for 'columns' */ #define DFLT_ROWS       24              /* default value for 'lines' */ -EXTERN long Rows                        /* nr of rows in the screen */-#ifdef DO_INIT-  = DFLT_ROWS-#endif-;-EXTERN long Columns INIT(= DFLT_COLS);         /* nr of columns in the screen */+EXTERN NumOpt Rows INIT(= DFLT_ROWS);     // nr of rows in the screen",Better write proper documentanion:``` C/// Number of rows in the screen.EXTERN long Rows INIT(= DFLT_ROWS);```,
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3914,49860026,2016-01-15T14:46:37Z,src/nvim/option.c,"@@ -3843,26 +3847,23 @@ set_bool_option (   return NULL; } -/*- * Set the value of a number option, and take care of side effects.- * Returns NULL for success, or an error message for an error.- */-static char_u *-set_num_option (-    int opt_idx,                            /* index in options[] table */-    char_u *varp,                      /* pointer to the option variable */-    long value,                             /* new value */-    char_u *errbuf,                    /* buffer for error messages */-    size_t errbuflen,                       /* length of ""errbuf"" */-    int opt_flags                          /* OPT_LOCAL, OPT_GLOBAL and-                                           OPT_MODELINE */-)+/// Set the value of a number option, and take care of side effects.+/// Returns NULL for success, or an error message for an error.+///+/// @param opt_idx index in options[] table+/// @param varp pointer to the option variable+/// @param value new value+/// @param effbuf buffer for error messages+/// @param errbuflen length of ""errbuf""+/// @param opt_flags OPT_LOCAL, OPT_GLOBAL and OPT_MODELINE+static char_u *set_num_option(int opt_idx, char_u *varp, NumOpt value,",it is indeed a generic pointer AFAIK. I though it was not deal breaker for this PR which is quite large and I wanted to do it in another one. What do you prefer?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3954,49896999,2016-01-15T19:50:09Z,runtime/doc/options.txt,"@@ -5287,7 +5287,7 @@ A jump table for the options with a short description can be found at |Q_op|.  						*'shell'* *'sh'* *E91* 'shell' 'sh'		string	(default $SHELL or ""sh"",-					MS-DOS and Win32: ""command.com"" or+					Windows: ""command.com"" or","I don't think this is true; from `options.lua`:```    {      full_name='shell', abbreviation='sh',      type='string', scope={'global'},      secure=true,      vi_def=true,      expand=true,      varname='p_sh',      defaults={        condition='WIN32',        if_true={vi=""cmd.exe""},        if_false={vi=""sh""}      }    },```",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3954,49898533,2016-01-15T20:02:46Z,runtime/doc/options.txt,"@@ -6342,9 +6342,8 @@ A jump table for the options with a short description can be found at |Q_op|. 'term'			string	(default is $TERM, if that fails: 				      in the GUI: ""builtin_gui"" 					  on Mac: ""mac-ansi""-				       on MS-DOS: ""pcterm""","There are some more refs to pcterm:``` diffdiff --git a/runtime/doc/options.txt b/runtime/doc/options.txtindex 1a9c951..79db9b1 100644--- a/runtime/doc/options.txt+++ b/runtime/doc/options.txt@@ -779,7 +779,7 @@ A jump table for the options with a short description can be found at |Q_op|.    Normally this option would be set in the vimrc file.  Possibly    depending on the terminal name.  Example: >-       :if &term == ""pcterm""+       :if &term == ""xterm""        :  set background=dark        :endif <  When this option is set, the default settings for the highlight groups@@ -7099,6 +7099,6 @@ A jump table for the options with a short description can be found at |Q_op|.            global    The number of microseconds to wait for each character sent to the    screen.  When non-zero, characters are sent to the terminal one by-   one.  For MS-DOS pcterm this does not work.  For debugging purposes.+   one.  For debugging purposes.  vim:tw=78:ts=8:ft=help:noet:norl:diff --git a/runtime/doc/term.txt b/runtime/doc/term.txtindex 961ec1b..9c74a7e 100644--- a/runtime/doc/term.txt+++ b/runtime/doc/term.txt@@ -425,11 +425,9 @@ cleared when scrolling). Unfortunately it is not possible to deduce from the termcap how cursor positioning should be done when using a scrolling region: Relative to the beginning of the screen or relative to the beginning of the scrolling region.-Most terminals use the first method.  A known exception is the MS-DOS console-(pcterm).  The 't_CS' option should be set to any string when cursor-positioning is relative to the start of the scrolling region.  It should be-set to an empty string otherwise.  It defaults to ""yes"" when 'term' is-""pcterm"".+Most terminals use the first method.  The 't_CS' option should be set to any+string when cursor positioning is relative to the start of the scrolling+region.  It should be set to an empty string otherwise. Note for xterm users: The shifted cursor keys normally don't work.  You can    make them work with the xmodmap command and some mappings in Vim.```",
6191831,sethjackson,https://api.github.com/repos/neovim/neovim/pulls/3954,49899238,2016-01-15T20:09:11Z,runtime/doc/usr_27.txt,"@@ -83,7 +83,7 @@ matter if 'ignorecase' or 'smartcase' was changed.  	Note: 	If your search takes much longer than you expected, you can interrupt-	it with CTRL-C on Unix and  CTRL-Break on MS-DOS and MS-Windows.+	it with CTRL-C on Unix and CTRL-Break on Windows.","[This page](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682541%28v=vs.85%29.aspx) seems to agree with you. Do you have a system with Windows that this can be tested on? If Neovim doesn't work on Windows yet, then I bet Vim could still be used to demonstrate `CTRL-C` behavior in console.",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3914,49925374,2016-01-16T02:14:42Z,src/nvim/option.c,"@@ -5913,15 +5919,16 @@ option_value2string (   varp = get_varp_scope(opp, opt_flags);    if (opp->flags & P_NUM) {-    long wc = 0;+    NumOpt wc = 0; -    if (wc_use_keyname(varp, &wc))+    if (wc_use_keyname(varp, &wc)) {       STRCPY(NameBuff, get_special_key_name((int)wc, 0));-    else if (wc != 0)+    } else if (wc != 0) {       STRCPY(NameBuff, transchar((int)wc));-    else-      sprintf((char *)NameBuff, ""%"" PRId64, (int64_t)*(long *)varp);-  } else { /* P_STRING */+    } else {+      sprintf((char *)NameBuff, ""%"" PRId64, (int64_t)*(NumOpt *)varp); // NOLINT",neither option worked. The define changes nothing and `intmax_t` is interpreted as `long` and not `long long`.,
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/2892,49928083,2016-01-16T06:26:49Z,src/nvim/ex_cmds.c,"@@ -166,10 +167,10 @@ void ex_align(exarg_T *eap) {   pos_T save_curpos;   int len;-  int indent = 0;-  int new_indent;+  long indent = 0;+  long new_indent;   int has_tab;-  int width;+  long width;",You are not supposed to add `long` variables based on the style guide. You should try to change the other end of the error so that this change is not necessary.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3914,49928238,2016-01-16T06:41:30Z,src/nvim/option.c,"@@ -5913,15 +5919,16 @@ option_value2string (   varp = get_varp_scope(opp, opt_flags);    if (opp->flags & P_NUM) {-    long wc = 0;+    NumOpt wc = 0; -    if (wc_use_keyname(varp, &wc))+    if (wc_use_keyname(varp, &wc)) {       STRCPY(NameBuff, get_special_key_name((int)wc, 0));-    else if (wc != 0)+    } else if (wc != 0) {       STRCPY(NameBuff, transchar((int)wc));-    else-      sprintf((char *)NameBuff, ""%"" PRId64, (int64_t)*(long *)varp);-  } else { /* P_STRING */+    } else {+      sprintf((char *)NameBuff, ""%"" PRId64, (int64_t)*(NumOpt *)varp); // NOLINT","What did you do and what do you mean by ���not worked���? If you create a define you should use it (and remove the cast to `int64_t`), if you use intmax_t you should change PRId64 to PRIdMAX. `intmax_t` is valid to be `long` on e.g. 64-bit linux.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4030,49958971,2016-01-18T03:03:00Z,src/nvim/os/unix_defs.h,"@@ -2,7 +2,7 @@ #define NVIM_OS_UNIX_DEFS_H  // Windows doesn't have unistd.h, so we include it here to avoid numerous-// instances of `#ifdef HAVE_UNISTD_H'.+// instances of `#ifdef WIN32'. #include <unistd.h>","Aren't we stepping backwards from the goal of https://github.com/neovim/neovim/issues/549, which is to ""flatten"" the includes instead of centralizing them in a mega-include? For the purpose of #549 we _should_ use HAVE_UNISTD_H, explicitly include `<unistd.h>` in the respective `.c` files, and _remove_ this centralized include from `unix_defs.h`.We started out trying to pull apart `globals.h` and `vim.h`, but `os_defs.h` is now turning into something similar.If I'm mistaken please let me know.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4030,49960079,2016-01-18T03:39:00Z,src/nvim/os/unix_defs.h,"@@ -2,7 +2,7 @@ #define NVIM_OS_UNIX_DEFS_H  // Windows doesn't have unistd.h, so we include it here to avoid numerous-// instances of `#ifdef HAVE_UNISTD_H'.+// instances of `#ifdef WIN32'. #include <unistd.h>","As a middle ground, we could have granular headers like `os_unistd.h` whose contents are essentially:```#ifdef UNIX# include <unistd.h>#else# include <io.h>#endif```Then only `nvim/os_unistd.h` need be included in the various `.c` files. Would like to hear from @aktau @ZyX-I @elmart regarding this.",
199728,watiko,https://api.github.com/repos/neovim/neovim/pulls/4049,50369012,2016-01-21T07:48:30Z,test/functional/legacy/039_visual_block_mode_commands_spec.lua,"@@ -0,0 +1,234 @@+-- Test Visual block mode commands+-- And test ""U"" in Visual mode, also on German sharp S.++local helpers = require('test.functional.helpers')+local nvim, eq = helpers.meths, helpers.eq+local insert, feed = helpers.insert, helpers.feed+local clear, expect = helpers.clear, helpers.expect+local source, execute = helpers.source, helpers.execute++describe('Visual block mode', function()++  before_each(function()+    clear()++    execute('set ts&vi sw&vi sts&vi noet') -- Vim compatible+  end)++  it('should shift, insert, replace and change a block', function()+    insert([[+      abcdefghijklm+      abcdefghijklm+      abcdefghijklm+      abcdefghijklm+      abcdefghijklm]])++    feed('gg')+    -- Test shift-right of a block+    feed('jllll<C-v>jj>wll<C-v>jlll><CR>')+    -- Test shift-left of a block+    feed('G$hhhh<C-v>kk<lt>')+    -- Test block-insert+    feed('Gkl<C-v>kkkIxyz<ESC>')+    -- Test block-replace+    feed('Gllll<C-v>kkklllrq')+    -- Test block-change+    feed('G$khhh<C-v>hhkkcmno<ESC>')++    expect([[+      axyzbcdefghijklm+      axyzqqqq   mno	      ghijklm+      axyzqqqqef mno        ghijklm+      axyzqqqqefgmnoklm+      abcdqqqqijklm]])+  end)++  it('should insert a block using cursor keys for movement', function()+    insert([[+      aaaaaa+      bbbbbb+      cccccc+      dddddd+      +      xaaa+      bbbb+      cccc+      dddd]])++    execute('/^aa')+    feed('l<C-v>jjjlllI<Right><Right>  <ESC>')+    execute('/xaaa$')+    feed('<C-v>jjjI<lt>><Left>p<ESC>')++    expect([[+      aaa  aaa+      bbb  bbb+      ccc  ccc+      ddd  ddd+      +      <p>xaaa+      <p>bbbb+      <p>cccc+      <p>dddd]])+  end)++  it('should create a block', function()+    insert([[+      A23+      4567+      +      B23+      4567+      +      C23+      4567]])++    -- Test for Visual block was created with the last <C-v>$.+    execute('/^A23$/')+    feed('l<C-v>j$Aab<ESC>')+    -- Test for Visual block was created with the middle <C-v>$ (1).+    execute('/^B23$/')+    feed('l<C-v>j$hAab<ESC>')+    -- Test for Visual block was created with the middle <C-v>$ (2).+    execute('/^C23$/')+    feed('l<C-v>j$hhAab<ESC>')++    expect([[+      A23ab+      4567ab+      +      B23 ab+      4567ab+      +      C23ab+      456ab7]])+  end)++  it('should insert and append a block when virtualedit=all', function()+    insert([[+      		line1+      		line2+      		line3+      ]])++    -- Test for Visual block insert when virtualedit=all and utf-8 encoding.+    execute('set ve=all')+    execute('/\t\tline')+    feed('07l<C-v>jjIx<ESC>')++    expect([[+             x 	line1+             x 	line2+             x 	line3+      ]])++    -- Test for Visual block append when virtualedit=all.+    feed('012l<C-v>jjAx<ESC>')++    expect([[+             x     x   line1+             x     x   line2+             x     x   line3+      ]])+  end)++  it('should make a selected part uppercase', function()+    -- GUe must uppercase a whole word, also when �� changes to SS.+    feed('Gothe youtu��euu end<ESC>Ypk0wgUe<CR>')+    -- GUfx must uppercase until x, inclusive.+    feed('O- you��tu��exu -<ESC>0fogUfx<CR>')+    -- VU must uppercase a whole line.+    feed('YpkVU<CR>')+    -- Same, when it's the last line in the buffer.+    feed('YPGi111<ESC>VUddP<CR>')+    -- Uppercase two lines.+    feed('Oblah di<CR>')+    feed('doh dut<ESC>VkUj<CR>')+    -- Uppercase part of two lines.+    feed('ddppi333<ESC>k0i222<esc>fyllvjfuUk<CR>')++    expect([[+      +      the YOUTUSSEUU end+      - yOUSSTUSSEXu -+      THE YOUTUSSEUU END+      111THE YOUTUSSEUU END+      BLAH DI+      DOH DUT+      222the yoUTUSSEUU END+      333THE YOUTU��euu end]])+  end)++  it('should replace using Enter or NL', function()+    -- Visual replace using Enter or NL.+    feed('G3o123456789<ESC>2k05l<C-v>2jr<CR>')+    feed('G3o98765<ESC>2k02l<C-v>2jr<C-v><CR>')+    feed('G3o123456789<ESC>2k05l<C-v>2jr<CR>')+    feed('G3o98765<ESC>2k02l<C-v>2jr<C-v><Nul>')++    local expected = [[+      +      12345+      789+      12345+      789+      12345+      789+      98<CR>65+      98<CR>65+      98<CR>65+      12345+      789+      12345+      789+      12345+      789+      98<Nul>65+      98<Nul>65+      98<Nul>65]]+    expected = expected:gsub('<CR>', '\r')+    expected = expected:gsub('<Nul>', '\x00')","Oh, I see. Yes, `opening long bracket` (eg: `[[]]`, `[=[]=]` etc...) does not allow us to escape special characters. String concatenation will also work but I think the current form is better too.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4007,50619826,2016-01-23T12:44:08Z,src/nvim/quickfix.c,"@@ -2274,10 +2267,13 @@ static void qf_update_buffer(qf_info_T *qi)   } } +// Set ""w:quickfix_title"" if ""qi"" has a title. static void qf_set_title_var(qf_info_T *qi) {-  set_internal_string_var((char_u *)""w:quickfix_title"",-      qi->qf_lists[qi->qf_curlist].qf_title);+  if (qi->qf_lists[qi->qf_curlist].qf_title != NULL) {+      set_internal_string_var((char_u *)""w:quickfix_title"",+                              qi->qf_lists[qi->qf_curlist].qf_title);","I would try to make it a bit more readable:``` cchar_u * const title = qi->qf_lists[qi->qf_curlist].qf_title;if (title) {  set_internal_string_var((char_u *)""w:quickfix_title"", title);}```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4070,50620047,2016-01-23T13:09:40Z,src/nvim/regexp_nfa.c,"@@ -6093,7 +6106,7 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm  * Try match of ""prog"" with at regline[""col""].  * Returns <= 0 for failure, number of lines contained in the match otherwise.  */-static long nfa_regtry(nfa_regprog_T *prog, colnr_T col)+static long nfa_regtry(nfa_regprog_T *prog, colnr_T col, proftime_T *tm)",Comment for new parameter is missing.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4001,50625566,2016-01-23T21:03:53Z,src/nvim/version.c,"@@ -79,50 +176,50 @@ static int included_patches[] = {   // 1048,   // 1047,   // 1046,-  // 1045,-  // 1044,-  // 1043,+  // 1045 NA,+  // 1044 NA,+  // 1043 NA,   // 1042,   // 1041,-  // 1040,+  // 1040 NA,   // 1039,-  // 1038,+  // 1038 NA,   // 1037,   // 1036,   // 1035,   // 1034,-  // 1033,+  // 1033 NA,   1032,-  // 1031,+  // 1031 NA,   // 1030,   // 1029,   // 1028,-  // 1027,-  // 1026,-  // 1025,-  // 1024,-  // 1023,-  // 1022,-  // 1021,-  // 1020,-  // 1019,+  // 1027 NA,",Is not mentioned in commit message. Perhaps `vim_str2nr()` parameter change could be useful.,
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/4076,50627004,2016-01-23T22:59:11Z,src/nvim/api/buffer.c,"@@ -291,7 +291,11 @@ void buffer_set_line_slice(Buffer buffer,   // Only adjust marks if we managed to switch to a window that holds   // the buffer, otherwise line numbers will be invalid.   if (save_curbuf == NULL) {-    mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra);+    /// WCONV: extra is ssize_t, representing lines added or removed, so+    /// WCONF: logically it should be < MAXLNUM, which is INT32_MAX+    /// WCONF: Add an assertion to be sure+    assert( -MAXLNUM <= extra && extra <= MAXLNUM);","`ssize_t` is, by definition, not supposed to have any other negative value than `-1`. In practice, that's not how the type is implemented but if extra takes more negatives in a way that we need to test it like that, that's not the right type to use. I am no big shot but I think it's reasonable to change extra to `int` (or `linenr_T` if we want to keep it but I don't know the plan for that).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4076,50631654,2016-01-24T07:50:47Z,src/nvim/api/buffer.c,"@@ -291,7 +291,11 @@ void buffer_set_line_slice(Buffer buffer,   // Only adjust marks if we managed to switch to a window that holds   // the buffer, otherwise line numbers will be invalid.   if (save_curbuf == NULL) {-    mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra);+    /// WCONV: extra is ssize_t, representing lines added or removed, so+    /// WCONF: logically it should be < MAXLNUM, which is INT32_MAX+    /// WCONF: Add an assertion to be sure+    assert( -MAXLNUM <= extra && extra <= MAXLNUM);","@cacplate If one needs signed `size_t` common recomendation is `ptrdiff_t`, not `int`: it has the necessary semantics, `int` has not. `linenr_T` is a good idea as well since `extra` means line numbers.",
4117685,KillTheMule,https://api.github.com/repos/neovim/neovim/pulls/4076,50632514,2016-01-24T09:07:22Z,src/nvim/api/buffer.c,"@@ -291,7 +291,11 @@ void buffer_set_line_slice(Buffer buffer,   // Only adjust marks if we managed to switch to a window that holds   // the buffer, otherwise line numbers will be invalid.   if (save_curbuf == NULL) {-    mark_adjust((linenr_T)start, (linenr_T)(end - 1), MAXLNUM, extra);+    /// WCONV: extra is ssize_t, representing lines added or removed, so+    /// WCONF: logically it should be < MAXLNUM, which is INT32_MAX+    /// WCONF: Add an assertion to be sure+    assert( -MAXLNUM <= extra && extra <= MAXLNUM);","I don't think `linenr_T` is right, since `extra` designates a number of lines (as in a quantity) rather than line numbers (as in addresses). As such, I think the type of `extra` is determined by the type of `linenr_T`. `ptrdiff_t` sounds reasonable, but might be to big (probably not an issue).",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/1817,50640735,2016-01-24T19:38:01Z,src/nvim/screen.c,"@@ -3338,6 +3346,16 @@ win_line (             char_attr = hl_combine_attr(spell_attr, char_attr);         } +        if (has_bufhl && v > 0) {+          bufhl_attr = bufhl_get_attr(&bufhl_info, (colnr_T)v);+          if( bufhl_attr != 0) {+            if (!attr_pri)+              char_attr = hl_combine_attr(char_attr, bufhl_attr);+            else+              char_attr = hl_combine_attr(bufhl_attr, char_attr);+          }+        }","Was some time ago, I thought about simplifying the combination logic but didn't dare given the exponential cases of combination to test. I did it this way because it would work ""as least as well"" as spell attrs. Your suggestion would mean, IMHO, leaking parts of this complex logic to a separate  function, and could rather make it harder to reason what happens, say if an upstream patch includes a new highlighting source. ( I mean it might give the impression of ""separating concerns"" but that is not actually possible without deeper analysis/refactor of the highlight combining logic)",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4070,51350521,2016-01-30T20:42:17Z,src/nvim/regexp_nfa.c,"@@ -6064,10 +6070,17 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm       break;      // Allow interrupting with CTRL-C.-    fast_breakcheck();+    line_breakcheck();","Looks like for unittest `buffer_spec.lua` somehow the queue `loop.uv.pending_queue` was not initialized (`event_init()` or `loop_init()` was not called?) or was left in an undefined state after use.The queue is not empty but it's `prev` and `next` pointer point to `NULL`.``` cProgram terminated with signal SIGSEGV, Segmentation fault.#0  0x00007f50d3d21928 in uv__run_pending (loop=0x7f50d3fe3360 <loop>)    at /home/oni-link/git/neovim/.deps/build/src/libuv/src/unix/core.c:726726   QUEUE_SPLIT(&loop->pending_queue, q, &pq);(gdb) bt#0  0x00007f50d3d21928 in uv__run_pending (loop=0x7f50d3fe3360 <loop>)    at /home/oni-link/git/neovim/.deps/build/src/libuv/src/unix/core.c:726#1  uv_run (loop=0x7f50d3fe3360 <loop>, mode=UV_RUN_NOWAIT) at /home/oni-link/git/neovim/.deps/build/src/libuv/src/unix/core.c:333#2  0x00007f50d3d1c86c in loop_poll_events (loop=0x7f50d3fe3360 <loop>, ms=0) at /home/oni-link/git/neovim/src/nvim/event/loop.c:49#3  0x00007f50d3d03139 in os_breakcheck () at /home/oni-link/git/neovim/src/nvim/os/input.c:150#4  0x00007f50d3c6438f in line_breakcheck () at /home/oni-link/git/neovim/src/nvim/misc1.c:2717#5  0x00007f50d3bfaeca in nfa_regmatch (prog=0x128bbc0, start=0x128bcd8, submatch=0x7fff66d727a0, m=0x7fff66d72990)    at /home/oni-link/git/neovim/src/nvim/regexp_nfa.c:6079#6  0x00007f50d3bfb065 in nfa_regtry (prog=0x128bbc0, col=0, tm=0x0) at /home/oni-link/git/neovim/src/nvim/regexp_nfa.c:6151#7  0x00007f50d3bfb862 in nfa_regexec_both (line=0x128b6b0 ""path_test_file"", startcol=0, tm=0x0)    at /home/oni-link/git/neovim/src/nvim/regexp_nfa.c:6315#8  0x00007f50d3bfbbf7 in nfa_regexec_nl (rmp=0x7fff66d72d90, line=0x128b6b0 ""path_test_file"", col=0, line_lbr=false)    at /home/oni-link/git/neovim/src/nvim/regexp_nfa.c:6467#9  0x00007f50d3bfbecc in vim_regexec_both (rmp=0x7fff66d72d90, line=0x128b6b0 ""path_test_file"", col=0, nl=false)    at /home/oni-link/git/neovim/src/nvim/regexp.c:7059#10 0x00007f50d3bfc09d in vim_regexec (rmp=0x7fff66d72d90, line=0x128b6b0 ""path_test_file"", col=0)    at /home/oni-link/git/neovim/src/nvim/regexp.c:7098#11 0x00007f50d3bd0f83 in fname_match (rmp=0x7fff66d72d90, name=0x128b6b0 ""path_test_file"", ignore_case=false)    at /home/oni-link/git/neovim/src/nvim/buffer.c:1933#12 0x00007f50d3bd0ee3 in buflist_match (rmp=0x7fff66d72d90, buf=0x128f140, ignore_case=false)    at /home/oni-link/git/neovim/src/nvim/buffer.c:1914#13 0x00007f50d3bd09b9 in buflist_findpat (pattern=0x40de8410 ""path"", pattern_end=0x0, unlisted=0, diffmode=0, curtab_only=0)    at /home/oni-link/git/neovim/src/nvim/buffer.c:1781#14 0x00000000004207df in ?? ()#15 0x0000000000000005 in ?? ()#16 0x0000000000000000 in ?? ()```",
116470,jbradaric,https://api.github.com/repos/neovim/neovim/pulls/4070,51359419,2016-01-31T11:55:45Z,src/nvim/regexp_nfa.c,"@@ -6064,10 +6070,17 @@ static int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *subm       break;      // Allow interrupting with CTRL-C.-    fast_breakcheck();+    line_breakcheck();","@oni-link Thanks, `make unittest` triggers a segfault with the following backtrace:```#0  0x00007ffff6839ab4 in queue_remove (queue=0x663480) at /home/jurica/sources/neovim/src/nvim/event/queue.c:163#1  0x00007ffff6839858 in queue_get (queue=0x663480) at /home/jurica/sources/neovim/src/nvim/event/queue.c:124#2  0x00007ffff6839964 in queue_process_events (queue=0x663480) at /home/jurica/sources/neovim/src/nvim/event/queue.c:140#3  0x00007ffff683c476 in loop_poll_events (loop=0x7ffff6afdc20 <loop>, ms=0) at /home/jurica/sources/neovim/src/nvim/event/loop.c:56#4  0x00007ffff6822316 in os_breakcheck () at /home/jurica/sources/neovim/src/nvim/os/input.c:150#5  0x00007ffff678aac1 in line_breakcheck () at /home/jurica/sources/neovim/src/nvim/misc1.c:2717#6  0x00007ffff67635f7 in nfa_regmatch (prog=0x66fac0, start=0x66fbd8, submatch=0x7fffffffd660, m=0x7fffffffd850) at /home/jurica/sources/neovim/src/nvim/regexp_nfa.c:6073#7  0x00007ffff6763792 in nfa_regtry (prog=0x66fac0, col=0, tm=0x0) at /home/jurica/sources/neovim/src/nvim/regexp_nfa.c:6145#8  0x00007ffff6763f8f in nfa_regexec_both (line=0x663890 ""path_test_file"", startcol=0, tm=0x0) at /home/jurica/sources/neovim/src/nvim/regexp_nfa.c:6309#9  0x00007ffff6764324 in nfa_regexec_nl (rmp=0x7fffffffdc50, line=0x663890 ""path_test_file"", col=0, line_lbr=false) at /home/jurica/sources/neovim/src/nvim/regexp_nfa.c:6461#10 0x00007ffff67645f9 in vim_regexec_both (rmp=0x7fffffffdc50, line=0x663890 ""path_test_file"", col=0, nl=false) at /home/jurica/sources/neovim/src/nvim/regexp.c:7058#11 0x00007ffff67647ca in vim_regexec (rmp=0x7fffffffdc50, line=0x663890 ""path_test_file"", col=0) at /home/jurica/sources/neovim/src/nvim/regexp.c:7097#12 0x00007ffff680a446 in fname_match (rmp=0x7fffffffdc50, name=0x663890 ""path_test_file"", ignore_case=false) at /home/jurica/sources/neovim/src/nvim/buffer.c:1933#13 0x00007ffff680a3a6 in buflist_match (rmp=0x7fffffffdc50, buf=0x676fe0, ignore_case=false) at /home/jurica/sources/neovim/src/nvim/buffer.c:1914#14 0x00007ffff6809e7c in buflist_findpat (pattern=0x40467f08 ""path"", pattern_end=0x0, unlisted=0, diffmode=0, curtab_only=0) at /home/jurica/sources/neovim/src/nvim/buffer.c:1781#15 0x000000000042078f in lj_vm_ffi_call ()#16 0x000000000042ba88 in lj_ccall_func (L=L@entry=0x40000378, cd=<optimized out>) at lj_ccall.c:878#17 0x000000000041c296 in lj_cf_ffi_meta___call (L=0x40000378) at lib_ffi.c:229#18 0x000000000041e847 in lj_BC_FUNCC ()#19 0x000000000040d4b6 in lua_pcall (L=L@entry=0x40000378, nargs=nargs@entry=7, nresults=-1, errfunc=errfunc@entry=2) at lj_api.c:1052#20 0x0000000000403db0 in docall (L=0x40000378, narg=7, clear=0) at luajit.c:122#21 0x0000000000404c76 in handle_script (n=<optimized out>, argv=<optimized out>, L=<optimized out>) at luajit.c:289#22 pmain (L=0x40000378) at luajit.c:538#23 0x000000000041e847 in lj_BC_FUNCC ()#24 0x000000000040d598 in lua_cpcall (L=L@entry=0x40000378, func=func@entry=0x4043d0 <pmain>, ud=ud@entry=0x0) at lj_api.c:1074#25 0x00000000004038d6 in main (argc=13, argv=0x7fffffffe268) at luajit.c:566```",
3017675,g0xA52A2A,https://api.github.com/repos/neovim/neovim/pulls/4144,51380768,2016-02-01T05:37:44Z,runtime/autoload/man.vim,"@@ -75,7 +75,13 @@ function man#get_page(...) abort    setlocal modifiable   silent keepjumps norm! 1G""_dG-  let $MANWIDTH = winwidth(0)+  if empty($MANWIDTH)+    if &textwidth+      let $MANWIDTH = &textwidth+    else+      let $MANWIDTH = winwidth(0)+    endif",Thanks and changed! I've forced pushed this as I'm not sure how else to alter an open pull request. Apologies if this is bad form.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/3914,51643958,2016-02-02T22:07:50Z,src/nvim/option.c,"@@ -1405,27 +1406,26 @@ do_set (              * other    error              */             ++arg;-            if (nextchar == '&')-              value = (long)options[opt_idx].def_val[-                ((flags & P_VI_DEF) || cp_val)-                ?  VI_DEFAULT : VIM_DEFAULT];-            else if (nextchar == '<') {-              /* For 'undolevels' NO_LOCAL_UNDOLEVEL means to-               * use the global value. */-              if ((long *)varp == &curbuf->b_p_ul-                  && opt_flags == OPT_LOCAL)+            if (nextchar == '&') {+              value = (intptr_t)options[opt_idx].def_val[+                  ((flags & P_VI_DEF) || cp_val) ?  VI_DEFAULT : VIM_DEFAULT];+            } else if (nextchar == '<') {+              // For 'undolevels' NO_LOCAL_UNDOLEVEL means to+              // use the global value.+              if ((NumOpt *)varp == &curbuf->b_p_ul && opt_flags == OPT_LOCAL) {                 value = NO_LOCAL_UNDOLEVEL;-              else-                value = *(long *)get_varp_scope(-                    &(options[opt_idx]), OPT_GLOBAL);-            } else if (((long *)varp == &p_wc-                        || (long *)varp == &p_wcm)+              } else {+                value = *(intmax_t *)get_varp_scope(&(options[opt_idx]),","This should be `(intmax_t) *((NumOpt *) get_varp_scope(���))` otherwise you may get various errors on 32-bit systems (where `ptrdiff_t` is 32-bit and `intmax_t` is still 64-bit): at least buffer overflow, maybe also unaligned memory access exception.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4139,51674523,2016-02-03T03:28:19Z,src/nvim/diff.c,"@@ -1116,68 +1119,50 @@ void diff_win_options(win_T *wp, int addbuf) /// @param eap void ex_diffoff(exarg_T *eap) {-  win_T *old_curwin = curwin;-  int diffwin = FALSE;+  int diffwin = false;    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {     if (eap->forceit ? wp->w_p_diff : (wp == curwin)) {-      // Set 'diff', 'scrollbind' off and 'wrap' on. If option values-      // were saved in diff_win_options() restore them.-      wp->w_p_diff = FALSE;--      if (wp->w_p_scb) {-        wp->w_p_scb = wp->w_p_diff_saved ? wp->w_p_scb_save : FALSE;-      }--      if (wp->w_p_crb) {-        wp->w_p_crb = wp->w_p_diff_saved ? wp->w_p_crb_save : FALSE;-      }--      if (!wp->w_p_wrap) {-        wp->w_p_wrap = wp->w_p_diff_saved ? wp->w_p_wrap_save : TRUE;-      }-      curwin = wp;-      curbuf = curwin->w_buffer;+      // Set 'diff' off. If option values were saved in+      // diff_win_options(), restore the ones whose settings seem to have+      // been left over from diff mode.+      wp->w_p_diff = false;        if (wp->w_p_diff_saved) {-        free_string_option(wp->w_p_fdm);-        wp->w_p_fdm = wp->w_p_fdm_save;-        wp->w_p_fdm_save = empty_option;-      } else {-        set_string_option_direct((char_u *)""fdm"", -1,-                                 (char_u *)""manual"", OPT_LOCAL | OPT_FREE, 0);-      }-      curwin = old_curwin;-      curbuf = curwin->w_buffer;+        if (wp->w_p_scb) {+          wp->w_p_scb = wp->w_p_diff_saved ? wp->w_p_scb_save : false;+        } -      if (wp->w_p_fdc == diff_foldcolumn) {-        wp->w_p_fdc = wp->w_p_diff_saved ? wp->w_p_fdc_save : 0;-      }+        if (wp->w_p_crb) {+          wp->w_p_crb = wp->w_p_diff_saved ? wp->w_p_crb_save : false;+        } -      if ((wp->w_p_fdl == 0)-          && wp->w_p_diff_saved) {-        wp->w_p_fdl = wp->w_p_fdl_save;-      }+        if (!wp->w_p_wrap) {+          wp->w_p_wrap = wp->w_p_diff_saved ? wp->w_p_wrap_save : true;+        }","For this trio of conditions (starting from line 1132), patch at https://github.com/vim/vim/commit/4392996461f56803d5c4a4919ba6dc509434bef5 removed the ternary, so it looks like this:```wp->w_p_scb = wp->w_p_scb_save;```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4144,51933931,2016-02-04T20:40:10Z,runtime/autoload/man.vim,"@@ -75,7 +75,9 @@ function man#get_page(...) abort    setlocal modifiable   silent keepjumps norm! 1G""_dG-  let $MANWIDTH = winwidth(0)+  if empty($MANWIDTH)+    let $MANWIDTH = winwidth(0)+  endif",@george-b I just noticed that [the ftplugin](https://github.com/neovim/neovim/blob/399864dc28498496bb82cdeb7b4aeae935cd667d/runtime/ftplugin/man.vim#L17-L20) clobbers MANWIDTH. Does it work for you more than once?,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4168,51947897,2016-02-04T22:24:18Z,runtime/autoload/man.vim,"@@ -118,15 +118,12 @@ endfunction "" Expects a string like 'access' or 'access(2)'. function s:parse_page_and_section(sect, str) abort   try-    let save_isk = &iskeyword-    setlocal iskeyword-=(,)-    let page = substitute(a:str, '(*\(\k\+\).*', '\1', '')-    let sect = substitute(a:str, '\(\k\+\)(\([^()]*\)).*', '\2', '')+    let page = substitute(a:str, '\([-.[:alnum:]_]\+\).*', '\1', '')+    let sect = substitute(a:str, '\([-.[:alnum:]_]\+\)(\([^()]*\)).*', '\2', '')","Can���t this be a single expression:```let [page, sect] = matchlist(a:str, '\([-.[:alnum:]_]\+\)(\([^()]*\))')[1:2]```?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4168,51948515,2016-02-04T22:28:50Z,runtime/autoload/man.vim,"@@ -118,15 +118,12 @@ endfunction "" Expects a string like 'access' or 'access(2)'. function s:parse_page_and_section(sect, str) abort   try-    let save_isk = &iskeyword-    setlocal iskeyword-=(,)-    let page = substitute(a:str, '(*\(\k\+\).*', '\1', '')-    let sect = substitute(a:str, '\(\k\+\)(\([^()]*\)).*', '\2', '')+    let page = substitute(a:str, '\([-.[:alnum:]_]\+\).*', '\1', '')+    let sect = substitute(a:str, '\([-.[:alnum:]_]\+\)(\([^()]*\)).*', '\2', '')","No,```let [page, sect] = matchlist(a:str, '\v\C([-.[:alnum:]_]+)%(\(([^()]*))?\)')[1:2]```: using ���very magic��� mode reduces the number of backslashes and `\C` should simply be a convention, regardless of whether or not it changes something in the regular expression (`match*` functions depend on &ignorecase option, establishing such convention should prevent the possible damage of unexpected option value, just like `#` after comparison operators which do string comparison).Edit: added `%(���)?` aroung section.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4168,51948799,2016-02-04T22:30:58Z,runtime/autoload/man.vim,"@@ -118,15 +118,12 @@ endfunction "" Expects a string like 'access' or 'access(2)'. function s:parse_page_and_section(sect, str) abort   try-    let save_isk = &iskeyword-    setlocal iskeyword-=(,)-    let page = substitute(a:str, '(*\(\k\+\).*', '\1', '')-    let sect = substitute(a:str, '\(\k\+\)(\([^()]*\)).*', '\2', '')+    let page = substitute(a:str, '\([-.[:alnum:]_]\+\).*', '\1', '')+    let sect = substitute(a:str, '\([-.[:alnum:]_]\+\)(\([^()]*\)).*', '\2', '')","I suggested such change earlier, but got confused by `(*` absent in the second regex. If these regular expressions are really fine, `matchlist()` could safely be used.",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/4168,51953721,2016-02-04T23:13:09Z,runtime/autoload/man.vim,"@@ -118,15 +118,12 @@ endfunction "" Expects a string like 'access' or 'access(2)'. function s:parse_page_and_section(sect, str) abort   try-    let save_isk = &iskeyword-    setlocal iskeyword-=(,)-    let page = substitute(a:str, '(*\(\k\+\).*', '\1', '')-    let sect = substitute(a:str, '\(\k\+\)(\([^()]*\)).*', '\2', '')+    let page = substitute(a:str, '\([-.[:alnum:]_]\+\).*', '\1', '')+    let sect = substitute(a:str, '\([-.[:alnum:]_]\+\)(\([^()]*\)).*', '\2', '')     if sect == page || -1 == match(sect, '^[0-9 ]\+$')","If rendered as```  let [page, sect] = matchlist(a:str, '\v\C([-.[:alnum:]_]+)%(\((\d+)\))?')[1:2]```the second part of the condition can be removed���`sect` is guaranteed to either be empty or contain only numeric characters.This works for various inputs:- `:Man man`- `:Man man(1)`- `:Man git-branch`- `:Man foo.bar`If that looks good, I will update the commit.",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/4168,52020020,2016-02-05T14:18:52Z,runtime/autoload/man.vim,"@@ -118,15 +118,12 @@ endfunction "" Expects a string like 'access' or 'access(2)'. function s:parse_page_and_section(sect, str) abort   try-    let save_isk = &iskeyword-    setlocal iskeyword-=(,)-    let page = substitute(a:str, '(*\(\k\+\).*', '\1', '')-    let sect = substitute(a:str, '\(\k\+\)(\([^()]*\)).*', '\2', '')+    let page = substitute(a:str, '\([-.[:alnum:]_]\+\).*', '\1', '')+    let sect = substitute(a:str, '\([-.[:alnum:]_]\+\)(\([^()]*\)).*', '\2', '')     if sect == page || -1 == match(sect, '^[0-9 ]\+$')","> By the way, what with sections like {number}p and {letter}?I wasn't aware of this, but yes, this should be accommodated. I'm only able to find examples in the forms- `{number}`- `{number}{letter}`- `{letter}`but I suppose there is no point in restricting the pattern to these options.> This makes test if 0 + a:sect > 0 invalid.The section name is assumed to be numeric in several places throughout the script, including `man#get_page()`. Changing this makes the single-argument version of the function ambiguous: the argument could either be a page name or section name (in which case the page is set to `expand('cword')`).The function is referenced in `ftplugin/man.vim` with one argument:``` vimnnoremap <silent> <buffer> <C-]> :call man#get_page(v:count)<CR>"" ...nnoremap <silent> <buffer> K :call man#get_page(v:count)<CR>```where `[count]` can be used to specify the section number. I propose the following change:``` vimnnoremap <silent> <buffer> <C-]> :call man#get_page(expand('<cword>'), v:count)<CR>"" ...nnoremap <silent> <buffer> K :call man#get_page(expand('<cword>'), v:count)<CR>```And to always interpret a single argument as page name. I think this is easier to understand anyway (""it takes one required argument, the page name, and an optional second argument, the section name""). I realize `v:count` _must_ be numeric, alleviating the ambiguity somewhat, but it shouldn't be assumed that `man#get_page()` will only be used in this context.",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/4168,52067661,2016-02-05T20:20:45Z,runtime/autoload/man.vim,"@@ -20,24 +22,13 @@ function man#get_page(...) abort   elseif a:0 > 2     echoerr 'too many arguments'     return-  elseif a:0 == 2-    let [page, sect] = [a:2, 0 + a:1]-  elseif type(1) == type(a:1)-    let [page, sect] = ['<cword>', a:1]-  else-    let [page, sect] = [a:1, '']   endif -  if page == '<cword>'-    let page = expand('<cword>')-  endif+  let sect = get(a:000, 0)+  let page = get(a:000, 1, sect)    let [page, sect] = s:parse_page_and_section(sect, page) -  if 0 + sect > 0 && s:find_page(sect, page) == 0-    let sect = ''-  endif",Removing this was an oversight. I will restore it (with corrected condition).,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,52239384,2016-02-08T22:42:58Z,src/nvim/eval/encode.c,"@@ -0,0 +1,1260 @@+/// @file encode.c+///+/// File containing functions for encoding and decoding VimL values.+///+/// Split out from eval.c.++#include <msgpack.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/eval/encode.h""+#include ""nvim/buffer_defs.h""  // vimconv_T+#include ""nvim/eval.h""+#include ""nvim/eval_defs.h""+#include ""nvim/garray.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_isprintc()+#include ""nvim/macros.h""+#include ""nvim/ascii.h""+#include ""nvim/vim.h""  // For _()+#include ""nvim/lib/kvec.h""++#define ga_concat(a, b) ga_concat(a, (char_u *)b)+#define utf_ptr2char(b) utf_ptr2char((char_u *)b)+#define utf_ptr2len(b) ((size_t)utf_ptr2len((char_u *)b))+#define utf_char2len(b) ((size_t)utf_char2len(b))+#define string_convert(a, b, c) \+      ((char *)string_convert((vimconv_T *)a, (char_u *)b, c))+#define convert_setup(vcp, from, to) \+    (convert_setup(vcp, (char_u *)from, (char_u *)to))++/// Structure representing current VimL to messagepack conversion state+typedef struct {+  enum {+    kMPConvDict,   ///< Convert dict_T *dictionary.+    kMPConvList,   ///< Convert list_T *list.+    kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.+  } type;+  union {+    struct {+      dict_T *dict;    ///< Currently converted dictionary.+      hashitem_T *hi;  ///< Currently converted dictionary item.+      size_t todo;     ///< Amount of items left to process.+    } d;  ///< State of dictionary conversion.+    struct {+      list_T *list;    ///< Currently converted list.+      listitem_T *li;  ///< Currently converted list item.+    } l;  ///< State of list or generic mapping conversion.+  } data;  ///< Data to convert.+} MPConvStackVal;++/// Stack used to convert VimL values to messagepack.+typedef kvec_t(MPConvStackVal) MPConvStack;++const char *const encode_special_var_names[] = {+  [kSpecialVarNull] = ""null"",+  [kSpecialVarTrue] = ""true"",+  [kSpecialVarFalse] = ""false"",+};++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/encode.c.generated.h""+#endif++/// Msgpack callback for writing to readfile()-style list+int encode_list_write(void *data, const char *buf, size_t len)+{+  if (len == 0) {+    return 0;+  }+  list_T *const list = (list_T *) data;+  const char *const end = buf + len;+  const char *line_end = buf;+  if (list->lv_last == NULL) {+    list_append_string(list, NULL, 0);+  }+  listitem_T *li = list->lv_last;+  do {+    const char *line_start = line_end;+    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));+    if (line_end == line_start) {+      list_append_allocated_string(list, NULL);","`li != NULL` seems to indicate that the string in the last list item must be completed. If thefirst byte in `buf` is a `NL`,  this is not necessary. `li` should be set to `NULL` here.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4131,52248504,2016-02-08T23:59:29Z,src/nvim/eval/encode.c,"@@ -0,0 +1,1260 @@+/// @file encode.c+///+/// File containing functions for encoding and decoding VimL values.+///+/// Split out from eval.c.++#include <msgpack.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/eval/encode.h""+#include ""nvim/buffer_defs.h""  // vimconv_T+#include ""nvim/eval.h""+#include ""nvim/eval_defs.h""+#include ""nvim/garray.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_isprintc()+#include ""nvim/macros.h""+#include ""nvim/ascii.h""+#include ""nvim/vim.h""  // For _()+#include ""nvim/lib/kvec.h""++#define ga_concat(a, b) ga_concat(a, (char_u *)b)+#define utf_ptr2char(b) utf_ptr2char((char_u *)b)+#define utf_ptr2len(b) ((size_t)utf_ptr2len((char_u *)b))+#define utf_char2len(b) ((size_t)utf_char2len(b))+#define string_convert(a, b, c) \+      ((char *)string_convert((vimconv_T *)a, (char_u *)b, c))+#define convert_setup(vcp, from, to) \+    (convert_setup(vcp, (char_u *)from, (char_u *)to))++/// Structure representing current VimL to messagepack conversion state+typedef struct {+  enum {+    kMPConvDict,   ///< Convert dict_T *dictionary.+    kMPConvList,   ///< Convert list_T *list.+    kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.+  } type;+  union {+    struct {+      dict_T *dict;    ///< Currently converted dictionary.+      hashitem_T *hi;  ///< Currently converted dictionary item.+      size_t todo;     ///< Amount of items left to process.+    } d;  ///< State of dictionary conversion.+    struct {+      list_T *list;    ///< Currently converted list.+      listitem_T *li;  ///< Currently converted list item.+    } l;  ///< State of list or generic mapping conversion.+  } data;  ///< Data to convert.+} MPConvStackVal;++/// Stack used to convert VimL values to messagepack.+typedef kvec_t(MPConvStackVal) MPConvStack;++const char *const encode_special_var_names[] = {+  [kSpecialVarNull] = ""null"",+  [kSpecialVarTrue] = ""true"",+  [kSpecialVarFalse] = ""false"",+};++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/encode.c.generated.h""+#endif++/// Msgpack callback for writing to readfile()-style list+int encode_list_write(void *data, const char *buf, size_t len)+{+  if (len == 0) {+    return 0;+  }+  list_T *const list = (list_T *) data;+  const char *const end = buf + len;+  const char *line_end = buf;+  if (list->lv_last == NULL) {+    list_append_string(list, NULL, 0);+  }+  listitem_T *li = list->lv_last;+  do {+    const char *line_start = line_end;+    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));+    if (line_end == line_start) {+      list_append_allocated_string(list, NULL);","It is more complicated then this. I am now writing unit tests, but it seems that at least the following change is needed:``` Patchdiff --git a/src/nvim/eval/encode.c b/src/nvim/eval/encode.cindex 2fd1c9d..fb3c237 100644--- a/src/nvim/eval/encode.c+++ b/src/nvim/eval/encode.c@@ -80,7 +80,11 @@ int encode_list_write(void *data, const char *buf, size_t len)     const char *line_start = line_end;     line_end = xmemscan(line_start, NL, (size_t) (end - line_start));     if (line_end == line_start) {-      list_append_allocated_string(list, NULL);+      if (li) {+        li = NULL;+      } else {+        list_append_allocated_string(list, NULL);+      }     } else {       const size_t line_length = (size_t) (line_end - line_start);       char *str;```",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,52251562,2016-02-09T00:31:38Z,src/nvim/eval/encode.c,"@@ -0,0 +1,1260 @@+/// @file encode.c+///+/// File containing functions for encoding and decoding VimL values.+///+/// Split out from eval.c.++#include <msgpack.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/eval/encode.h""+#include ""nvim/buffer_defs.h""  // vimconv_T+#include ""nvim/eval.h""+#include ""nvim/eval_defs.h""+#include ""nvim/garray.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_isprintc()+#include ""nvim/macros.h""+#include ""nvim/ascii.h""+#include ""nvim/vim.h""  // For _()+#include ""nvim/lib/kvec.h""++#define ga_concat(a, b) ga_concat(a, (char_u *)b)+#define utf_ptr2char(b) utf_ptr2char((char_u *)b)+#define utf_ptr2len(b) ((size_t)utf_ptr2len((char_u *)b))+#define utf_char2len(b) ((size_t)utf_char2len(b))+#define string_convert(a, b, c) \+      ((char *)string_convert((vimconv_T *)a, (char_u *)b, c))+#define convert_setup(vcp, from, to) \+    (convert_setup(vcp, (char_u *)from, (char_u *)to))++/// Structure representing current VimL to messagepack conversion state+typedef struct {+  enum {+    kMPConvDict,   ///< Convert dict_T *dictionary.+    kMPConvList,   ///< Convert list_T *list.+    kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.+  } type;+  union {+    struct {+      dict_T *dict;    ///< Currently converted dictionary.+      hashitem_T *hi;  ///< Currently converted dictionary item.+      size_t todo;     ///< Amount of items left to process.+    } d;  ///< State of dictionary conversion.+    struct {+      list_T *list;    ///< Currently converted list.+      listitem_T *li;  ///< Currently converted list item.+    } l;  ///< State of list or generic mapping conversion.+  } data;  ///< Data to convert.+} MPConvStackVal;++/// Stack used to convert VimL values to messagepack.+typedef kvec_t(MPConvStackVal) MPConvStack;++const char *const encode_special_var_names[] = {+  [kSpecialVarNull] = ""null"",+  [kSpecialVarTrue] = ""true"",+  [kSpecialVarFalse] = ""false"",+};++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/encode.c.generated.h""+#endif++/// Msgpack callback for writing to readfile()-style list+int encode_list_write(void *data, const char *buf, size_t len)+{+  if (len == 0) {+    return 0;+  }+  list_T *const list = (list_T *) data;+  const char *const end = buf + len;+  const char *line_end = buf;+  if (list->lv_last == NULL) {+    list_append_string(list, NULL, 0);+  }+  listitem_T *li = list->lv_last;+  do {+    const char *line_start = line_end;+    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));+    if (line_end == line_start) {+      list_append_allocated_string(list, NULL);","Should `encode_list_write(data,""\n\n\n"",3);` and `encode_list_write(data,""\n"",1);encode_list_write(data,""\n"",1);encode_list_write(data,""\n"",1);` result in the same list?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4203,52266706,2016-02-09T04:31:29Z,runtime/vimrc_example.vim,"@@ -1,8 +1,8 @@ "" An example for a vimrc file. "" "" To use it, copy it to-""     for Unix:  ~/.vimrc-""     for Windows:  $VIM\_vimrc+""     for Unix:  ${XDG_CONFIG_HOME:=$HOME/.config}/nvim/init.vim","For most users, `${XDG_CONFIG_HOME:=$HOME/.config}` is just confusing and pedantic. Users who are just getting started are almost certainly not going to care about XDG, so `~/.config` is sufficient as a general assumption.",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3229,52279661,2016-02-09T08:43:37Z,runtime/doc/eval.txt,"@@ -3507,9 +3507,22 @@ getcurpos()	Get the position of the cursor.  This is like getpos('.'), but 			MoveTheCursorAround 			call setpos('.', save_cursor) <-							*getcwd()*-getcwd()	The result is a String, which is the name of the current-		working directory.+getcwd([{window}[, {tab}]])					*getcwd()*+		With no argument the result is a String, which is the name of the+		current effective working directory. If an arguments are provided for a+		window or a tabpage the working directory of that scope is returned.++		Tabs and windows are identified using their respective number. If a+		number is 0 the current tab or window is implied. If one is not given+		it defaults to 0. Thus+		+			getcwd()+			getcwd(0)+			getcwd(0, 0)++		are all equal. If {window} is -1 it will be ignored and only the tab+		will be looked at.","Yes, we dropped that in favour of window/tab numbers because Vim was going to change `getcwd()` as well: the user could pass the number of a window as an argument to get the working directory of that window, so I did the same and extended it by one optional parameter for the level above (tabs).",
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/3229,52285269,2016-02-09T09:43:44Z,runtime/doc/eval.txt,"@@ -3507,9 +3507,22 @@ getcurpos()	Get the position of the cursor.  This is like getpos('.'), but 			MoveTheCursorAround 			call setpos('.', save_cursor) <-							*getcwd()*-getcwd()	The result is a String, which is the name of the current-		working directory.+getcwd([{window}[, {tab}]])					*getcwd()*+		With no argument the result is a String, which is the name of the+		current effective working directory. If an arguments are provided for a+		window or a tabpage the working directory of that scope is returned.++		Tabs and windows are identified using their respective number. If a+		number is 0 the current tab or window is implied. If one is not given+		it defaults to 0. Thus+		+			getcwd()+			getcwd(0)+			getcwd(0, 0)++		are all equal. If {window} is -1 it will be ignored and only the tab+		will be looked at.","While the task of checking for the exact tab local or window local working directory is more convoluted in this implementation than it would have been with scoping targets, the flexibility of targeting any window or tab and API compatibility with Vim probably are worth it, provided `haslocaldir()` semantics allow for sufficiently diffentiating working directory scopes. I find the docs a bit hazy on that topic, though: what does `haslocaldir(winnr, 0)` return when a tab local working directory is set for the tab containing `winnr`, but not a window local one?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3914,52291341,2016-02-09T10:40:32Z,src/nvim/option.c,"@@ -1442,15 +1442,18 @@ do_set (               goto skip;             } -            if (adding)-              value = *(long *)varp + value;-            if (prepending)-              value = *(long *)varp * value;-            if (removing)-              value = *(long *)varp - value;-            errmsg = set_num_option(opt_idx, varp, value,-                errbuf, sizeof(errbuf), opt_flags);-          } else if (opt_idx >= 0) {                      /* string */+            if (adding) {+              value = *(intmax_t *)varp + value;",same issue here (`varp` is `NumOpt*`). I wonder if it's not cleaner to let `value` be `NumOpt` and just have a `intmax_t` temporary just around `vim_str2nr`. Also these are exclusive so use `else if` between cases.,
80906,kopischke,https://api.github.com/repos/neovim/neovim/pulls/3229,52312001,2016-02-09T14:17:25Z,runtime/doc/eval.txt,"@@ -3507,9 +3507,22 @@ getcurpos()	Get the position of the cursor.  This is like getpos('.'), but 			MoveTheCursorAround 			call setpos('.', save_cursor) <-							*getcwd()*-getcwd()	The result is a String, which is the name of the current-		working directory.+getcwd([{window}[, {tab}]])					*getcwd()*+		With no argument the result is a String, which is the name of the+		current effective working directory. If an arguments are provided for a+		window or a tabpage the working directory of that scope is returned.++		Tabs and windows are identified using their respective number. If a+		number is 0 the current tab or window is implied. If one is not given+		it defaults to 0. Thus+		+			getcwd()+			getcwd(0)+			getcwd(0, 0)++		are all equal. If {window} is -1 it will be ignored and only the tab+		will be looked at.","@HiPhish I understand the semantics of working directories (I think) and by extension of `getcwd()` ��� my question was about `haslocaldir()` which returns a Boolean value whose cascading seems less obvious to me. To reiterate my question:> what does `haslocaldir(winnr, 0)` return when a tab local working directory is set for the tab containing `winnr`, but not a window local one��� 1 (because there is a local working directory set for the current tab) or 0 (because there is no local working directory set for the window)? If the former, how do we check if a local working directory is window scoped only (`haslocaldir(winnr, tabnr) && !haslocaldir(-1, tabnr)` would work but seems needlessly convoluted)?",
199728,watiko,https://api.github.com/repos/neovim/neovim/pulls/4204,52432677,2016-02-10T09:24:54Z,src/nvim/option.c,"@@ -218,20 +218,22 @@ typedef struct vimoption { #define P_RALL          0x6000U  /* redraw all windows */ #define P_RCLR          0x7000U  /* clear and redraw all */ -#define P_COMMA         0x8000U  /* comma separated list */-#define P_NODUP         0x10000U /* don't allow duplicate strings */-#define P_FLAGLIST      0x20000U /* list of single-char flags */--#define P_SECURE        0x40000U /* cannot change in modeline or secure mode */-#define P_GETTEXT       0x80000U /* expand default value with _() */-#define P_NOGLOB       0x100000U /* do not use local value for global vimrc */-#define P_NFNAME       0x200000U /* only normal file name chars allowed */-#define P_INSECURE     0x400000U /* option was set from a modeline */-#define P_PRI_MKRC     0x800000U /* priority for :mkvimrc (setting option has-                                    side effects) */-#define P_NO_ML       0x1000000U /* not allowed in modeline */-#define P_CURSWANT    0x2000000U /* update curswant required; not needed when-                                  * there is a redraw flag */+#define P_COMMA         0x8000U    ///< comma separated list","By e1f782187449870b04301fc68d5f7e38d47a1faf, `flags` was replaced `long_u` with `uint32_t` and `L` with `U`. Besides `n1124` reads that the `integer-suffix` of `U` (or `u`) can be represented `unsigned int`, `unsigned long int`, `unsigned long long int` for Hexadecimal Constant. So I think this is acceptable.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3914,52434994,2016-02-10T09:46:14Z,src/nvim/option.c,"@@ -1442,15 +1442,18 @@ do_set (               goto skip;             } -            if (adding)-              value = *(long *)varp + value;-            if (prepending)-              value = *(long *)varp * value;-            if (removing)-              value = *(long *)varp - value;-            errmsg = set_num_option(opt_idx, varp, value,-                errbuf, sizeof(errbuf), opt_flags);-          } else if (opt_idx >= 0) {                      /* string */+            if (adding) {+              value = *(intmax_t *)varp + value;","You decide, but the issue is not aesthetics but semantics (`value` is meant to range over all valid option values). Alternatively, can't we just remove the `(intmax_t)` casts as `intmax_t` is guaranteed to be at least as big as `ptrdiff_t` ?  (the final `(NumOpt)` cast is still needed of course)",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,52514051,2016-02-10T19:48:00Z,src/nvim/eval/encode.c,"@@ -0,0 +1,1258 @@+/// @file encode.c+///+/// File containing functions for encoding and decoding VimL values.+///+/// Split out from eval.c.++#include <msgpack.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/eval/encode.h""+#include ""nvim/buffer_defs.h""  // vimconv_T+#include ""nvim/eval.h""+#include ""nvim/eval_defs.h""+#include ""nvim/garray.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_isprintc()+#include ""nvim/macros.h""+#include ""nvim/ascii.h""+#include ""nvim/vim.h""  // For _()+#include ""nvim/lib/kvec.h""++#define ga_concat(a, b) ga_concat(a, (char_u *)b)+#define utf_ptr2char(b) utf_ptr2char((char_u *)b)+#define utf_ptr2len(b) ((size_t)utf_ptr2len((char_u *)b))+#define utf_char2len(b) ((size_t)utf_char2len(b))+#define string_convert(a, b, c) \+      ((char *)string_convert((vimconv_T *)a, (char_u *)b, c))+#define convert_setup(vcp, from, to) \+    (convert_setup(vcp, (char_u *)from, (char_u *)to))++/// Structure representing current VimL to messagepack conversion state+typedef struct {+  enum {+    kMPConvDict,   ///< Convert dict_T *dictionary.+    kMPConvList,   ///< Convert list_T *list.+    kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.+  } type;+  union {+    struct {+      dict_T *dict;    ///< Currently converted dictionary.+      hashitem_T *hi;  ///< Currently converted dictionary item.+      size_t todo;     ///< Amount of items left to process.+    } d;  ///< State of dictionary conversion.+    struct {+      list_T *list;    ///< Currently converted list.+      listitem_T *li;  ///< Currently converted list item.+    } l;  ///< State of list or generic mapping conversion.+  } data;  ///< Data to convert.+} MPConvStackVal;++/// Stack used to convert VimL values to messagepack.+typedef kvec_t(MPConvStackVal) MPConvStack;++const char *const encode_special_var_names[] = {+  [kSpecialVarNull] = ""null"",+  [kSpecialVarTrue] = ""true"",+  [kSpecialVarFalse] = ""false"",+};++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/encode.c.generated.h""+#endif++/// Msgpack callback for writing to readfile()-style list+int encode_list_write(void *data, const char *buf, size_t len)+{+  if (len == 0) {+    return 0;+  }+  list_T *const list = (list_T *) data;+  const char *const end = buf + len;+  const char *line_end = buf;+  if (list->lv_last == NULL) {+    list_append_string(list, NULL, 0);+  }","This `if` block could be removed. If the list is empty, the loop code will add the first element.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4131,52536127,2016-02-10T22:24:24Z,src/nvim/eval/encode.c,"@@ -0,0 +1,1258 @@+/// @file encode.c+///+/// File containing functions for encoding and decoding VimL values.+///+/// Split out from eval.c.++#include <msgpack.h>+#include <inttypes.h>+#include <assert.h>++#include ""nvim/eval/encode.h""+#include ""nvim/buffer_defs.h""  // vimconv_T+#include ""nvim/eval.h""+#include ""nvim/eval_defs.h""+#include ""nvim/garray.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_isprintc()+#include ""nvim/macros.h""+#include ""nvim/ascii.h""+#include ""nvim/vim.h""  // For _()+#include ""nvim/lib/kvec.h""++#define ga_concat(a, b) ga_concat(a, (char_u *)b)+#define utf_ptr2char(b) utf_ptr2char((char_u *)b)+#define utf_ptr2len(b) ((size_t)utf_ptr2len((char_u *)b))+#define utf_char2len(b) ((size_t)utf_char2len(b))+#define string_convert(a, b, c) \+      ((char *)string_convert((vimconv_T *)a, (char_u *)b, c))+#define convert_setup(vcp, from, to) \+    (convert_setup(vcp, (char_u *)from, (char_u *)to))++/// Structure representing current VimL to messagepack conversion state+typedef struct {+  enum {+    kMPConvDict,   ///< Convert dict_T *dictionary.+    kMPConvList,   ///< Convert list_T *list.+    kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.+  } type;+  union {+    struct {+      dict_T *dict;    ///< Currently converted dictionary.+      hashitem_T *hi;  ///< Currently converted dictionary item.+      size_t todo;     ///< Amount of items left to process.+    } d;  ///< State of dictionary conversion.+    struct {+      list_T *list;    ///< Currently converted list.+      listitem_T *li;  ///< Currently converted list item.+    } l;  ///< State of list or generic mapping conversion.+  } data;  ///< Data to convert.+} MPConvStackVal;++/// Stack used to convert VimL values to messagepack.+typedef kvec_t(MPConvStackVal) MPConvStack;++const char *const encode_special_var_names[] = {+  [kSpecialVarNull] = ""null"",+  [kSpecialVarTrue] = ""true"",+  [kSpecialVarFalse] = ""false"",+};++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/encode.c.generated.h""+#endif++/// Msgpack callback for writing to readfile()-style list+int encode_list_write(void *data, const char *buf, size_t len)+{+  if (len == 0) {+    return 0;+  }+  list_T *const list = (list_T *) data;+  const char *const end = buf + len;+  const char *line_end = buf;+  if (list->lv_last == NULL) {+    list_append_string(list, NULL, 0);+  }+  listitem_T *li = list->lv_last;+  do {+    const char *line_start = line_end;+    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));+    char *str = NULL;+    if (line_end != line_start) {+      const size_t line_length = (size_t) (line_end - line_start);+      if (li == NULL) {+        str = xmemdupz(line_start, line_length);+      } else {+        const size_t li_len = (li->li_tv.vval.v_string == NULL+                               ? 0+                               : STRLEN(li->li_tv.vval.v_string));+        li->li_tv.vval.v_string = xrealloc(li->li_tv.vval.v_string,+                                           li_len + line_length + 1);+        str = (char *) li->li_tv.vval.v_string + li_len;+        memcpy(str, line_start, line_length);+        str[line_length] = 0;+      }+      for (size_t i = 0; i < line_length; i++) {+        if (str[i] == NUL) {+          str[i] = NL;+        }+      }+    }+    if (li == NULL) {+      list_append_allocated_string(list, str);+    } else {+      li = NULL;+    }+    if (line_end == end - 1) {+      list_append_allocated_string(list, NULL);+    }+    line_end++;+  } while (line_end < end);+  return 0;+}++/// Abort conversion to string after a recursion error.+static bool did_echo_string_emsg = false;++/// Show a error message when converting to msgpack value+///+/// @param[in]  msg  Error message to dump. Must contain exactly two %s that+///                  will be replaced with what was being dumped: first with+///                  something like ���F��� or ���function argument���, second with path+///                  to the failed value.+/// @param[in]  mpstack  Path to the failed value.+/// @param[in]  objname  Dumped object name.+///+/// @return FAIL.+static int conv_error(const char *const msg, const MPConvStack *const mpstack,+                      const char *const objname)+  FUNC_ATTR_NONNULL_ALL+{+  garray_T msg_ga;+  ga_init(&msg_ga, (int)sizeof(char), 80);+  char *const key_msg = _(""key %s"");+  char *const key_pair_msg = _(""key %s at index %i from special map"");+  char *const idx_msg = _(""index %i"");+  for (size_t i = 0; i < kv_size(*mpstack); i++) {+    if (i != 0) {+      ga_concat(&msg_ga, "", "");+    }+    MPConvStackVal v = kv_A(*mpstack, i);+    switch (v.type) {+      case kMPConvDict: {+        typval_T key_tv = {+            .v_type = VAR_STRING,+            .vval = { .v_string = (v.data.d.hi == NULL+                                   ? v.data.d.dict->dv_hashtab.ht_array+                                   : (v.data.d.hi - 1))->hi_key },+        };+        char *const key = encode_tv2string(&key_tv, NULL);+        vim_snprintf((char *) IObuff, IOSIZE, key_msg, key);+        xfree(key);+        ga_concat(&msg_ga, IObuff);+        break;+      }+      case kMPConvPairs:+      case kMPConvList: {+        int idx = 0;+        const listitem_T *li;+        for (li = v.data.l.list->lv_first;+             li != NULL && li->li_next != v.data.l.li;+             li = li->li_next) {+          idx++;+        }+        if (v.type == kMPConvList+            || li == NULL+            || (li->li_tv.v_type != VAR_LIST+                && li->li_tv.vval.v_list->lv_len <= 0)) {+          vim_snprintf((char *) IObuff, IOSIZE, idx_msg, idx);+          ga_concat(&msg_ga, IObuff);+        } else {+          typval_T key_tv = li->li_tv.vval.v_list->lv_first->li_tv;+          char *const key = encode_tv2echo(&key_tv, NULL);+          vim_snprintf((char *) IObuff, IOSIZE, key_pair_msg, key, idx);+          xfree(key);+          ga_concat(&msg_ga, IObuff);+        }+        break;+      }+    }+  }+  EMSG3(msg, objname, (kv_size(*mpstack) == 0+                       ? _(""itself"")+                       : (char *) msg_ga.ga_data));+  ga_clear(&msg_ga);+  return FAIL;+}++/// Convert readfile()-style list to a char * buffer with length+///+/// @param[in]  list  Converted list.+/// @param[out]  ret_len  Resulting buffer length.+/// @param[out]  ret_buf  Allocated buffer with the result or NULL if ret_len is+///                       zero.+///+/// @return true in case of success, false in case of failure.+bool encode_vim_list_to_buf(const list_T *const list, size_t *const ret_len,+                            char **const ret_buf)+  FUNC_ATTR_NONNULL_ARG(2, 3) FUNC_ATTR_WARN_UNUSED_RESULT+{+  size_t len = 0;+  if (list != NULL) {+    for (const listitem_T *li = list->lv_first;+         li != NULL;+         li = li->li_next) {+      if (li->li_tv.v_type != VAR_STRING) {+        return false;+      }+      len++;+      if (li->li_tv.vval.v_string != 0) {+        len += STRLEN(li->li_tv.vval.v_string);+      }+    }+    if (len) {+      len--;+    }+  }+  *ret_len = len;+  if (len == 0) {+    *ret_buf = NULL;+    return true;+  }+  ListReaderState lrstate = encode_init_lrstate(list);+  char *const buf = xmalloc(len);+  size_t read_bytes;+  if (encode_read_from_list(&lrstate, buf, len, &read_bytes) != OK) {+    assert(false);+  }+  assert(len == read_bytes);+  *ret_buf = buf;+  return true;+}++/// Read bytes from list+///+/// @param[in,out]  state  Structure describing position in list from which+///                        reading should start. Is updated to reflect position+///                        at which reading ended.+/// @param[out]  buf  Buffer to write to.+/// @param[in]  nbuf  Buffer length.+/// @param[out]  read_bytes  Is set to amount of bytes read.+///+/// @return OK when reading was finished, FAIL in case of error (i.e. list item+///         was not a string), NOTDONE if reading was successfull, but there are+///         more bytes to read.+int encode_read_from_list(ListReaderState *const state, char *const buf,+                          const size_t nbuf, size_t *const read_bytes)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  char *const buf_end = buf + nbuf;+  char *p = buf;+  while (p < buf_end) {+    for (size_t i = state->offset; i < state->li_length && p < buf_end; i++) {+      const char ch = (char) state->li->li_tv.vval.v_string[state->offset++];+      *p++ = (char) ((char) ch == (char) NL ? (char) NUL : (char) ch);+    }+    if (p < buf_end) {+      state->li = state->li->li_next;+      if (state->li == NULL) {+        *read_bytes = (size_t) (p - buf);+        return OK;+      }+      *p++ = NL;+      if (state->li->li_tv.v_type != VAR_STRING) {+        *read_bytes = (size_t) (p - buf);+        return FAIL;+      }+      state->offset = 0;+      state->li_length = (state->li->li_tv.vval.v_string == NULL+                          ? 0+                          : STRLEN(state->li->li_tv.vval.v_string));+    }+  }+  *read_bytes = nbuf;+  return (state->offset < state->li_length || state->li->li_next != NULL+          ? NOTDONE+          : OK);+}++/// Code for checking whether container references itself+///+/// @param[in,out]  val  Container to check.+/// @param  copyID_attr  Name of the container attribute that holds copyID.+///                      After checking whether value of this attribute is+///                      copyID (variable) it is set to copyID.+#define CHECK_SELF_REFERENCE(val, copyID_attr, conv_type) \+    do { \+      if ((val)->copyID_attr == copyID) { \+        CONV_RECURSE((val), conv_type); \+      } \+      (val)->copyID_attr = copyID; \+    } while (0)++/// Define functions which convert VimL value to something else+///+/// Creates function `vim_to_{name}(firstargtype firstargname, typval_T *const+/// tv)` which returns OK or FAIL and helper functions.+///+/// @param  firstargtype  Type of the first argument. It will be used to return+///                       the results.+/// @param  firstargname  Name of the first argument.+/// @param  name  Name of the target converter.+#define DEFINE_VIML_CONV_FUNCTIONS(scope, name, firstargtype, firstargname) \+static int name##_convert_one_value(firstargtype firstargname, \+                                    MPConvStack *const mpstack, \+                                    typval_T *const tv, \+                                    const int copyID, \+                                    const char *const objname) \+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT \+{ \+  switch (tv->v_type) { \+    case VAR_STRING: { \+      CONV_STRING(tv->vval.v_string, STRLEN(tv->vval.v_string)); \+      break; \+    } \+    case VAR_NUMBER: { \+      CONV_NUMBER(tv->vval.v_number); \+      break; \+    } \+    case VAR_FLOAT: { \+      CONV_FLOAT(tv->vval.v_float); \+      break; \+    } \+    case VAR_FUNC: { \+      CONV_FUNC(tv->vval.v_string); \+      break; \+    } \+    case VAR_LIST: { \+      if (tv->vval.v_list == NULL || tv->vval.v_list->lv_len == 0) { \+        CONV_EMPTY_LIST(); \+        break; \+      } \+      CHECK_SELF_REFERENCE(tv->vval.v_list, lv_copyID, kMPConvList); \+      CONV_LIST_START(tv->vval.v_list); \+      kv_push(MPConvStackVal, *mpstack, ((MPConvStackVal) { \+        .type = kMPConvList, \+        .data = { \+          .l = { \+            .list = tv->vval.v_list, \+            .li = tv->vval.v_list->lv_first, \+          }, \+        }, \+      })); \+      break; \+    } \+    case VAR_SPECIAL: { \+      switch (tv->vval.v_special) { \+        case kSpecialVarNull: { \+          CONV_NIL(); \+          break; \+        } \+        case kSpecialVarTrue: \+        case kSpecialVarFalse: { \+          CONV_BOOL(tv->vval.v_special == kSpecialVarTrue); \+          break; \+        } \+      } \+      break; \+    } \+    case VAR_DICT: { \+      if (tv->vval.v_dict == NULL \+          || tv->vval.v_dict->dv_hashtab.ht_used == 0) { \+        CONV_EMPTY_DICT(); \+        break; \+      } \+      const dictitem_T *type_di; \+      const dictitem_T *val_di; \+      if (CONV_ALLOW_SPECIAL \+          && tv->vval.v_dict->dv_hashtab.ht_used == 2 \+          && (type_di = dict_find((dict_T *) tv->vval.v_dict, \+                                  (char_u *) ""_TYPE"", -1)) != NULL \+          && type_di->di_tv.v_type == VAR_LIST \+          && (val_di = dict_find((dict_T *) tv->vval.v_dict, \+                                 (char_u *) ""_VAL"", -1)) != NULL) { \+        size_t i; \+        for (i = 0; i < ARRAY_SIZE(eval_msgpack_type_lists); i++) { \+          if (type_di->di_tv.vval.v_list == eval_msgpack_type_lists[i]) { \+            break; \+          } \+        } \+        if (i == ARRAY_SIZE(eval_msgpack_type_lists)) { \+          goto name##_convert_one_value_regular_dict; \+        } \+        switch ((MessagePackType) i) { \+          case kMPNil: { \+            CONV_NIL(); \+            break; \+          } \+          case kMPBoolean: { \+            if (val_di->di_tv.v_type != VAR_NUMBER) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            CONV_BOOL(val_di->di_tv.vval.v_number); \+            break; \+          } \+          case kMPInteger: { \+            const list_T *val_list; \+            varnumber_T sign; \+            varnumber_T highest_bits; \+            varnumber_T high_bits; \+            varnumber_T low_bits; \+            /* List of 4 integers; first is signed (should be 1 or -1, but */ \+            /* this is not checked), second is unsigned and have at most */ \+            /* one (sign is -1) or two (sign is 1) non-zero bits (number of */ \+            /* bits is not checked), other unsigned and have at most 31 */ \+            /* non-zero bits (number of bits is not checked).*/ \+            if (val_di->di_tv.v_type != VAR_LIST \+                || (val_list = val_di->di_tv.vval.v_list) == NULL \+                || val_list->lv_len != 4 \+                || val_list->lv_first->li_tv.v_type != VAR_NUMBER \+                || (sign = val_list->lv_first->li_tv.vval.v_number) == 0 \+                || val_list->lv_first->li_next->li_tv.v_type != VAR_NUMBER \+                || (highest_bits = \+                    val_list->lv_first->li_next->li_tv.vval.v_number) < 0 \+                || val_list->lv_last->li_prev->li_tv.v_type != VAR_NUMBER \+                || (high_bits = \+                    val_list->lv_last->li_prev->li_tv.vval.v_number) < 0 \+                || val_list->lv_last->li_tv.v_type != VAR_NUMBER \+                || (low_bits = val_list->lv_last->li_tv.vval.v_number) < 0) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            uint64_t number = ((uint64_t) (((uint64_t) highest_bits) << 62) \+                               | (uint64_t) (((uint64_t) high_bits) << 31) \+                               | (uint64_t) low_bits); \+            if (sign > 0) { \+              CONV_UNSIGNED_NUMBER(number); \+            } else { \+              CONV_NUMBER(-number); \+            } \+            break; \+          } \+          case kMPFloat: { \+            if (val_di->di_tv.v_type != VAR_FLOAT) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            CONV_FLOAT(val_di->di_tv.vval.v_float); \+            break; \+          } \+          case kMPString: \+          case kMPBinary: { \+            const bool is_string = ((MessagePackType) i == kMPString); \+            if (val_di->di_tv.v_type != VAR_LIST) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            size_t len; \+            char *buf; \+            if (!encode_vim_list_to_buf(val_di->di_tv.vval.v_list, &len, \+                                        &buf)) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            if (is_string) { \+              CONV_STR_STRING(buf, len); \+            } else { \+              CONV_STRING(buf, len); \+            } \+            xfree(buf); \+            break; \+          } \+          case kMPArray: { \+            if (val_di->di_tv.v_type != VAR_LIST) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            CHECK_SELF_REFERENCE(val_di->di_tv.vval.v_list, lv_copyID, \+                                 kMPConvList); \+            CONV_LIST_START(val_di->di_tv.vval.v_list); \+            kv_push(MPConvStackVal, *mpstack, ((MPConvStackVal) { \+              .type = kMPConvList, \+              .data = { \+                .l = { \+                  .list = val_di->di_tv.vval.v_list, \+                  .li = val_di->di_tv.vval.v_list->lv_first, \+                }, \+              }, \+            })); \+            break; \+          } \+          case kMPMap: { \+            if (val_di->di_tv.v_type != VAR_LIST) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            list_T *const val_list = val_di->di_tv.vval.v_list; \+            if (val_list == NULL || val_list->lv_len == 0) { \+              CONV_EMPTY_DICT(); \+              break; \+            } \+            for (const listitem_T *li = val_list->lv_first; li != NULL; \+                 li = li->li_next) { \+              if (li->li_tv.v_type != VAR_LIST \+                  || li->li_tv.vval.v_list->lv_len != 2) { \+                goto name##_convert_one_value_regular_dict; \+              } \+            } \+            CHECK_SELF_REFERENCE(val_list, lv_copyID, kMPConvPairs); \+            CONV_DICT_START(val_list->lv_len); \+            kv_push(MPConvStackVal, *mpstack, ((MPConvStackVal) { \+              .type = kMPConvPairs, \+              .data = { \+                .l = { \+                  .list = val_list, \+                  .li = val_list->lv_first, \+                }, \+              }, \+            })); \+            break; \+          } \+          case kMPExt: { \+            const list_T *val_list; \+            varnumber_T type; \+            if (val_di->di_tv.v_type != VAR_LIST \+                || (val_list = val_di->di_tv.vval.v_list) == NULL \+                || val_list->lv_len != 2 \+                || (val_list->lv_first->li_tv.v_type != VAR_NUMBER) \+                || (type = val_list->lv_first->li_tv.vval.v_number) > INT8_MAX \+                || type < INT8_MIN \+                || (val_list->lv_last->li_tv.v_type != VAR_LIST)) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            size_t len; \+            char *buf; \+            if (!encode_vim_list_to_buf(val_list->lv_last->li_tv.vval.v_list, \+                                        &len, &buf)) { \+              goto name##_convert_one_value_regular_dict; \+            } \+            CONV_EXT_STRING(buf, len, type); \+            xfree(buf); \+            break; \+          } \+        } \+        break; \+      } \+name##_convert_one_value_regular_dict: \+      CHECK_SELF_REFERENCE(tv->vval.v_dict, dv_copyID, kMPConvDict); \+      CONV_DICT_START(tv->vval.v_dict->dv_hashtab.ht_used); \+      kv_push(MPConvStackVal, *mpstack, ((MPConvStackVal) { \+        .type = kMPConvDict, \+        .data = { \+          .d = { \+            .dict = tv->vval.v_dict, \+            .hi = tv->vval.v_dict->dv_hashtab.ht_array, \+            .todo = tv->vval.v_dict->dv_hashtab.ht_used, \+          }, \+        }, \+      })); \+      break; \+    } \+    case VAR_UNKNOWN: { \+      EMSG2(_(e_intern2), #name ""_convert_one_value()""); \+      return FAIL; \+    } \+  } \+  return OK; \+} \+\+scope int encode_vim_to_##name(firstargtype firstargname, typval_T *const tv, \+                               const char *const objname) \+  FUNC_ATTR_WARN_UNUSED_RESULT \+{ \+  const int copyID = get_copyID(); \+  MPConvStack mpstack; \+  kv_init(mpstack); \+  if (name##_convert_one_value(firstargname, &mpstack, tv, copyID, objname) \+      == FAIL) { \+    goto encode_vim_to_##name##_error_ret; \+  } \+  while (kv_size(mpstack)) { \+    MPConvStackVal *cur_mpsv = &kv_A(mpstack, kv_size(mpstack) - 1); \+    typval_T *cur_tv = NULL; \+    switch (cur_mpsv->type) { \+      case kMPConvDict: { \+        if (!cur_mpsv->data.d.todo) { \+          (void) kv_pop(mpstack); \+          cur_mpsv->data.d.dict->dv_copyID = copyID - 1; \+          CONV_DICT_END(); \+          continue; \+        } else if (cur_mpsv->data.d.todo \+                   != cur_mpsv->data.d.dict->dv_hashtab.ht_used) { \+          CONV_DICT_BETWEEN_ITEMS(); \+        } \+        while (HASHITEM_EMPTY(cur_mpsv->data.d.hi)) { \+          cur_mpsv->data.d.hi++; \+        } \+        dictitem_T *const di = HI2DI(cur_mpsv->data.d.hi); \+        cur_mpsv->data.d.todo--; \+        cur_mpsv->data.d.hi++; \+        CONV_STR_STRING(&di->di_key[0], STRLEN(&di->di_key[0])); \+        CONV_DICT_AFTER_KEY(); \+        cur_tv = &di->di_tv; \+        break; \+      } \+      case kMPConvList: { \+        if (cur_mpsv->data.l.li == NULL) { \+          (void) kv_pop(mpstack); \+          cur_mpsv->data.l.list->lv_copyID = copyID - 1; \+          CONV_LIST_END(cur_mpsv->data.l.list); \+          continue; \+        } else if (cur_mpsv->data.l.li != cur_mpsv->data.l.list->lv_first) { \+          CONV_LIST_BETWEEN_ITEMS(); \+        } \+        cur_tv = &cur_mpsv->data.l.li->li_tv; \+        cur_mpsv->data.l.li = cur_mpsv->data.l.li->li_next; \+        break; \+      } \+      case kMPConvPairs: { \+        if (cur_mpsv->data.l.li == NULL) { \+          (void) kv_pop(mpstack); \+          cur_mpsv->data.l.list->lv_copyID = copyID - 1; \+          CONV_DICT_END(); \+          continue; \+        } else if (cur_mpsv->data.l.li != cur_mpsv->data.l.list->lv_first) { \+          CONV_DICT_BETWEEN_ITEMS(); \+        } \+        const list_T *const kv_pair = cur_mpsv->data.l.li->li_tv.vval.v_list; \+        CONV_SPECIAL_DICT_KEY_CHECK(name, kv_pair); \+        if (name##_convert_one_value(firstargname, &mpstack, \+                                     &kv_pair->lv_first->li_tv, copyID, \+                                     objname) == FAIL) { \+          goto encode_vim_to_##name##_error_ret; \+        } \+        CONV_DICT_AFTER_KEY(); \+        cur_tv = &kv_pair->lv_last->li_tv; \+        cur_mpsv->data.l.li = cur_mpsv->data.l.li->li_next; \+        break; \+      } \+    } \+    assert(cur_tv != NULL); \+    if (name##_convert_one_value(firstargname, &mpstack, cur_tv, copyID, \+                                 objname) == FAIL) { \+      goto encode_vim_to_##name##_error_ret; \+    } \+  } \+  kv_destroy(mpstack); \+  return OK; \+encode_vim_to_##name##_error_ret: \+  kv_destroy(mpstack); \+  return FAIL; \+}++#define CONV_STRING(buf, len) \+    do { \+      const char *const buf_ = (const char *) buf; \+      if (buf == NULL) { \+        ga_concat(gap, ""''""); \+      } else { \+        const size_t len_ = (len); \+        size_t num_quotes = 0; \+        for (size_t i = 0; i < len_; i++) { \+          if (buf_[i] == '\'') { \+            num_quotes++; \+          } \+        } \+        ga_grow(gap, (int) (2 + len_ + num_quotes)); \+        ga_append(gap, '\''); \+        for (size_t i = 0; i < len_; i++) { \+          if (buf_[i] == '\'') { \+            num_quotes++; \+            ga_append(gap, '\''); \+          } \+          ga_append(gap, buf_[i]); \+        } \+        ga_append(gap, '\''); \+      } \+    } while (0)++#define CONV_STR_STRING(buf, len) \+    CONV_STRING(buf, len)++#define CONV_EXT_STRING(buf, len, type)++#define CONV_NUMBER(num) \+    do { \+      char numbuf[NUMBUFLEN]; \+      vim_snprintf(numbuf, NUMBUFLEN - 1, ""%"" PRId64, (int64_t) (num)); \+      ga_concat(gap, numbuf); \+    } while (0)++#define CONV_FLOAT(flt) \+    do { \+      char numbuf[NUMBUFLEN]; \+      vim_snprintf(numbuf, NUMBUFLEN - 1, ""%g"", (flt)); \+      ga_concat(gap, numbuf); \+    } while (0)++#define CONV_FUNC(fun) \+    do { \+      ga_concat(gap, ""function(""); \+      CONV_STRING(fun, STRLEN(fun)); \+      ga_append(gap, ')'); \+    } while (0)++#define CONV_EMPTY_LIST() \+    ga_concat(gap, ""[]"")++#define CONV_LIST_START(lst) \+    ga_append(gap, '[')++#define CONV_EMPTY_DICT() \+    ga_concat(gap, ""{}"")++#define CONV_NIL() \+    ga_concat(gap, ""v:null"")++#define CONV_BOOL(num) \+    ga_concat(gap, ((num)? ""v:true"": ""v:false""))++#define CONV_UNSIGNED_NUMBER(num)++#define CONV_DICT_START(len) \+    ga_append(gap, '{')++#define CONV_DICT_END() \+    ga_append(gap, '}')++#define CONV_DICT_AFTER_KEY() \+    ga_concat(gap, "": "")++#define CONV_DICT_BETWEEN_ITEMS() \+    ga_concat(gap, "", "")++#define CONV_SPECIAL_DICT_KEY_CHECK(name, kv_pair)++#define CONV_LIST_END(lst) \+    ga_append(gap, ']')++#define CONV_LIST_BETWEEN_ITEMS() \+    CONV_DICT_BETWEEN_ITEMS()++#define CONV_RECURSE(val, conv_type) \+    do { \+      if (!did_echo_string_emsg) { \+        /* Only give this message once for a recursive call to avoid */ \+        /* flooding the user with errors. */ \+        did_echo_string_emsg = true; \+        EMSG(_(""E724: unable to correctly dump variable "" \+               ""with self-referencing container"")); \+      } \+      char ebuf[NUMBUFLEN + 7]; \+      size_t backref = 0; \+      for (; backref < kv_size(*mpstack); backref++) { \+        const MPConvStackVal mpval = kv_A(*mpstack, backref); \+        if (mpval.type == conv_type) { \+          if (conv_type == kMPConvDict) { \+            if ((void *) mpval.data.d.dict == (void *) (val)) { \+              break; \+            } \+          } else if (conv_type == kMPConvList) { \+            if ((void *) mpval.data.l.list == (void *) (val)) { \+              break; \+            } \+          } \+        } \+      } \+      vim_snprintf(ebuf, NUMBUFLEN + 6, ""{E724@%zu}"", backref); \+      ga_concat(gap, &ebuf[0]); \+      return OK; \+    } while (0)++#define CONV_ALLOW_SPECIAL false++DEFINE_VIML_CONV_FUNCTIONS(static, string, garray_T *const, gap)++#undef CONV_RECURSE+#define CONV_RECURSE(val, conv_type) \+    do { \+      char ebuf[NUMBUFLEN + 7]; \+      size_t backref = 0; \+      for (; backref < kv_size(*mpstack); backref++) { \+        const MPConvStackVal mpval = kv_A(*mpstack, backref); \+        if (mpval.type == conv_type) { \+          if (conv_type == kMPConvDict) { \+            if ((void *) mpval.data.d.dict == (void *) val) { \+              break; \+            } \+          } else if (conv_type == kMPConvList) { \+            if ((void *) mpval.data.l.list == (void *) val) { \+              break; \+            } \+          } \+        } \+      } \+      if (conv_type == kMPConvDict) { \+        vim_snprintf(ebuf, NUMBUFLEN + 6, ""{...@%zu}"", backref); \+      } else { \+        vim_snprintf(ebuf, NUMBUFLEN + 6, ""[...@%zu]"", backref); \+      } \+      ga_concat(gap, &ebuf[0]); \+      return OK; \+    } while (0)++DEFINE_VIML_CONV_FUNCTIONS(, echo, garray_T *const, gap)++#undef CONV_RECURSE+#define CONV_RECURSE(val, conv_type) \+    do { \+      if (!did_echo_string_emsg) { \+        /* Only give this message once for a recursive call to avoid */ \+        /* flooding the user with errors. */ \+        did_echo_string_emsg = true; \+        EMSG(_(""E724: unable to correctly dump variable "" \+               ""with self-referencing container"")); \+      } \+      return OK; \+    } while (0)++#undef CONV_ALLOW_SPECIAL+#define CONV_ALLOW_SPECIAL true++#undef CONV_NIL+#define CONV_NIL() \+      ga_concat(gap, ""null"")++#undef CONV_BOOL+#define CONV_BOOL(num) \+      ga_concat(gap, ((num)? ""true"": ""false""))++#undef CONV_UNSIGNED_NUMBER+#define CONV_UNSIGNED_NUMBER(num) \+      do { \+        char numbuf[NUMBUFLEN]; \+        vim_snprintf(numbuf, sizeof(numbuf), ""%"" PRIu64, (num)); \+        ga_concat(gap, numbuf); \+      } while (0)++/// Last used p_enc value+///+/// Generic pointer: it is not used as a string, only pointer comparisons are+/// performed. Must not be freed.+static const void *last_p_enc = NULL;++/// Conversion setup for converting from last_p_enc to UTF-8+static vimconv_T p_enc_conv = {+  .vc_type = CONV_NONE,+};++/// Escape sequences used in JSON+static const char escapes[][3] = {+  [BS] = ""\\b"",+  [TAB] = ""\\t"",+  [NL] = ""\\n"",+  [CAR] = ""\\r"",+  ['""'] = ""\\\"""",+  ['\\'] = ""\\\\"",+};++static const char xdigits[] = ""0123456789ABCDEF"";++/// Convert given string to JSON string+///+/// @param[out]  gap  Garray where result will be saved.+/// @param[in]  buf  Converted string.+/// @param[in]  len  Converted string length.+///+/// @return OK in case of success, FAIL otherwise.+static inline int convert_to_json_string(garray_T *const gap,+                                         const char *const buf,+                                         const size_t len)+  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_ALWAYS_INLINE+{+  const char *utf_buf = buf;+  if (utf_buf == NULL) {+    ga_concat(gap, ""\""\"""");+  } else {+    size_t utf_len = len;+    char *tofree = NULL;+    if (last_p_enc != (const void *) p_enc) {+      p_enc_conv.vc_type = CONV_NONE;+      convert_setup(&p_enc_conv, p_enc, ""utf-8"");+      p_enc_conv.vc_fail = true;+      last_p_enc = p_enc;+    }+    if (p_enc_conv.vc_type != CONV_NONE) {+      tofree = string_convert(&p_enc_conv, buf, &utf_len);+      if (tofree == NULL) {+        EMSG2(_(""E474: Failed to convert string \""%s\"" to UTF-8""), utf_buf);+        return FAIL;+      }+      utf_buf = tofree;+    }+    size_t str_len = 0;+    // Encode character as \u0000 if+    // 1. It is an ASCII control character (0x0 .. 0x1F).+    // 2. &encoding is not UTF-8 and code point is above 0x7F.+    // 3. &encoding is UTF-8 and code point is printable according to+    //    utf_printable().+    // This is done to make it possible to :echo values when &encoding is not+    // UTF-8.+#define ENCODE_RAW(p_enc_conv, ch) \+    (ch >= 0x20 && (p_enc_conv.vc_type == CONV_NONE \+                    ? utf_printable(ch) \+                    : ch < 0x7F))+    for (size_t i = 0; i < utf_len;) {+      const int ch = utf_ptr2char(utf_buf + i);+      const size_t shift = (ch == 0? 1: utf_ptr2len(utf_buf + i));+      assert(shift > 0);+      i += shift;+      switch (ch) {+        case BS:+        case TAB:+        case NL:+        case FF:+        case CAR:+        case '""':+        case '\\': {+          str_len += 2;+          break;+        }+        default: {+          if (ch > 0x7F && shift == 1) {+            EMSG2(_(""E474: String \""%s\"" contains byte that does not start any ""+                    ""UTF-8 character""), utf_buf);+            return FAIL;+          } else if ((0xD800 <= ch && ch <= 0xDB7F)+                     || (0xDC00 <= ch && ch <= 0xDFFF)) {+            EMSG2(_(""E474: UTF-8 string contains code point which belongs ""+                    ""to surrogate pairs: %s""), utf_buf + i);+            return FAIL;",> Missing xfree(tofree);?Not actually: these conditions should not happen after string_convert with .vc_fail=true. Though I will add them just in case.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,52835399,2016-02-13T23:40:35Z,src/nvim/eval/decode.c,"@@ -0,0 +1,941 @@+#include <stddef.h>++#include <msgpack.h>++#include ""nvim/eval_defs.h""+#include ""nvim/eval.h""+#include ""nvim/eval/encode.h""+#include ""nvim/ascii.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_str2nr+#include ""nvim/lib/kvec.h""+#include ""nvim/vim.h""  // OK, FAIL++/// Helper structure for container_struct+typedef struct {+  size_t stack_index;   ///< Index of current container in stack.+  list_T *special_val;  ///< _VAL key contents for special maps.+                        ///< When container is not a special dictionary it is+                        ///< NULL.+  const char *s;        ///< Location where container starts.+  typval_T container;   ///< Container. Either VAR_LIST, VAR_DICT or VAR_LIST+                        ///< which is _VAL from special dictionary.+} ContainerStackItem;++/// Helper structure for values struct+typedef struct {+  bool is_special_string;  ///< Indicates that current value is a special+                           ///< dictionary with string.+  bool didcomma;           ///< True if previous token was comma.+  bool didcolon;           ///< True if previous token was colon.+  typval_T val;            ///< Actual value.+} ValuesStackItem;++/// Vector containing values not yet saved in any container+typedef kvec_t(ValuesStackItem) ValuesStack;++/// Vector containing containers, each next container is located inside previous+typedef kvec_t(ContainerStackItem) ContainerStack;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/decode.c.generated.h""+#endif++/// Create special dictionary+///+/// @param[out]  rettv  Location where created dictionary will be saved.+/// @param[in]  type  Type of the dictionary.+/// @param[in]  val  Value associated with the _VAL key.+static inline void create_special_dict(typval_T *const rettv,+                                       const MessagePackType type,+                                       typval_T val)+  FUNC_ATTR_NONNULL_ALL+{+  dict_T *const dict = dict_alloc();+  dictitem_T *const type_di = dictitem_alloc((char_u *) ""_TYPE"");+  type_di->di_tv.v_type = VAR_LIST;+  type_di->di_tv.v_lock = 0;+  type_di->di_tv.vval.v_list = (list_T *) eval_msgpack_type_lists[type];+  type_di->di_tv.vval.v_list->lv_refcount++;+  dict_add(dict, type_di);+  dictitem_T *const val_di = dictitem_alloc((char_u *) ""_VAL"");+  val_di->di_tv = val;+  dict_add(dict, val_di);+  dict->dv_refcount++;+  *rettv = (typval_T) {+    .v_type = VAR_DICT,+    .v_lock = VAR_UNLOCKED,+    .vval = { .v_dict = dict },+  };+}++#define DICT_LEN(dict) (dict)->dv_hashtab.ht_used++/// Helper function used for working with stack vectors used by JSON decoder+///+/// @param[in]  obj  New object.+/// @param[out]  stack  Object stack.+/// @param[out]  container_stack  Container objects stack.+/// @param[in,out]  pp  Position in string which is currently being parsed. Used+///                     for error reporting and is also set when decoding is+///                     restarted due to the necessity of converting regular+///                     dictionary to a special map.+/// @param[out]  next_map_special  Is set to true when dictionary is converted+///                                to a special map, otherwise not touched.+/// @param[out]  didcomma  True if previous token was comma. Is set to recorded+///                        value when decoder is restarted, otherwise unused.+/// @param[out]  didcolon  True if previous token was colon. Is set to recorded+///                        value when decoder is restarted, otherwise unused.+///+/// @return OK in case of success, FAIL in case of error.+static inline int json_decoder_pop(ValuesStackItem obj,+                                   ValuesStack *const stack,+                                   ContainerStack *const container_stack,+                                   const char **const pp,+                                   bool *const next_map_special,+                                   bool *const didcomma,+                                   bool *const didcolon)+  FUNC_ATTR_NONNULL_ALL+{+  if (kv_size(*container_stack) == 0) {+    kv_push(ValuesStackItem, *stack, obj);+    return OK;+  }+  ContainerStackItem last_container = kv_last(*container_stack);+  const char *val_location = *pp;+  if (obj.val.v_type == last_container.container.v_type+      // vval.v_list and vval.v_dict should have the same size and offset+      && ((void *) obj.val.vval.v_list+          == (void *) last_container.container.vval.v_list)) {+    (void) kv_pop(*container_stack);+    val_location = last_container.s;+    last_container = kv_last(*container_stack);+  }+  if (last_container.container.v_type == VAR_LIST) {+    if (last_container.container.vval.v_list->lv_len != 0+        && !obj.didcomma) {+      EMSG2(_(""E474: Expected comma before list item: %s""), val_location);+      clear_tv(&obj.val);+      return FAIL;+    }+    assert(last_container.special_val == NULL);+    listitem_T *obj_li = listitem_alloc();+    obj_li->li_tv = obj.val;+    list_append(last_container.container.vval.v_list, obj_li);+  } else if (last_container.stack_index == kv_size(*stack) - 2) {+    if (!obj.didcolon) {+      EMSG2(_(""E474: Expected colon before dictionary value: %s""),+            val_location);+      clear_tv(&obj.val);+      return FAIL;+    }+    ValuesStackItem key = kv_pop(*stack);+    if (last_container.special_val == NULL) {+      // These cases should have already been handled.+      assert(!(key.is_special_string+               || key.val.vval.v_string == NULL+               || *key.val.vval.v_string == NUL));+      dictitem_T *obj_di = dictitem_alloc(key.val.vval.v_string);+      clear_tv(&key.val);+      if (dict_add(last_container.container.vval.v_dict, obj_di)+          == FAIL) {+        assert(false);+      }+      obj_di->di_tv = obj.val;+    } else {+      list_T *const kv_pair = list_alloc();+      list_append_list(last_container.special_val, kv_pair);+      listitem_T *const key_li = listitem_alloc();+      key_li->li_tv = key.val;+      list_append(kv_pair, key_li);+      listitem_T *const val_li = listitem_alloc();+      val_li->li_tv = obj.val;+      list_append(kv_pair, val_li);+    }+  } else {+    // Object with key only+    if (!obj.is_special_string && obj.val.v_type != VAR_STRING) {+      EMSG2(_(""E474: Expected string key: %s""), *pp);+      clear_tv(&obj.val);+      return FAIL;+    } else if (!obj.didcomma+               && (last_container.special_val == NULL+                   && (DICT_LEN(last_container.container.vval.v_dict) != 0))) {+      EMSG2(_(""E474: Expected comma before dictionary key: %s""), val_location);+      clear_tv(&obj.val);+      return FAIL;+    }+    // Handle empty key and key represented as special dictionary+    if (last_container.special_val == NULL+        && (obj.is_special_string+            || obj.val.vval.v_string == NULL+            || *obj.val.vval.v_string == NUL+            || dict_find(last_container.container.vval.v_dict,+                         obj.val.vval.v_string, -1))) {+      clear_tv(&obj.val);++      // Restart+      (void) kv_pop(*container_stack);+      ValuesStackItem last_container_val =+          kv_A(*stack, last_container.stack_index);+      while (kv_size(*stack) > last_container.stack_index) {+        clear_tv(&(kv_pop(*stack).val));+      }+      *pp = last_container.s;+      *didcomma = last_container_val.didcomma;+      *didcolon = last_container_val.didcolon;+      *next_map_special = true;+      return OK;+    }+    kv_push(ValuesStackItem, *stack, obj);+  }+  return OK;+}++#define OBJ(obj_tv, is_sp_string) \+  ((ValuesStackItem) { \+    .is_special_string = (is_sp_string), \+    .val = (obj_tv), \+    .didcomma = didcomma, \+    .didcolon = didcolon, \+  })+#define POP(obj_tv, is_sp_string) \+  do { \+    if (json_decoder_pop(OBJ(obj_tv, is_sp_string), &stack, &container_stack, \+                         &p, &next_map_special, &didcomma, &didcolon) \+        == FAIL) { \+      goto json_decode_string_fail; \+    } \+    if (next_map_special) { \+      goto json_decode_string_cycle_start; \+    } \+  } while (0)++/// Convert JSON string into VimL object+///+/// @param[in]  buf  String to convert. UTF-8 encoding is assumed.+/// @param[in]  len  Length of the string.+/// @param[out]  rettv  Location where to save results.+///+/// @return OK in case of success, FAIL otherwise.+int json_decode_string(const char *const buf, const size_t len,+                       typval_T *const rettv)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  vimconv_T conv = { .vc_type = CONV_NONE };+  convert_setup(&conv, (char_u *) ""utf-8"", p_enc);+  conv.vc_fail = true;+  int ret = OK;+  ValuesStack stack;+  kv_init(stack);+  ContainerStack container_stack;+  kv_init(container_stack);+  rettv->v_type = VAR_UNKNOWN;+  const char *const e = buf + len;+  bool didcomma = false;+  bool didcolon = false;+  bool next_map_special = false;+  const char *p = buf;+  for (; p < e; p++) {+json_decode_string_cycle_start:+    assert(*p == '{' || next_map_special == false);+    switch (*p) {+      case '}':+      case ']': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: No container to close: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (*p == '}' && last_container.container.v_type != VAR_DICT) {+          EMSG2(_(""E474: Closing list with figure brace: %s""), p);+          goto json_decode_string_fail;+        } else if (*p == ']' && last_container.container.v_type != VAR_LIST) {+          EMSG2(_(""E474: Closing dictionary with bracket: %s""), p);+          goto json_decode_string_fail;+        } else if (didcomma) {+          EMSG2(_(""E474: Trailing comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Expected value after colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.stack_index != kv_size(stack) - 1) {+          assert(last_container.stack_index < kv_size(stack) - 1);+          EMSG2(_(""E474: Expected value: %s""), p);+          goto json_decode_string_fail;+        }+        if (kv_size(stack) == 1) {+          p++;+          (void) kv_pop(container_stack);+          goto json_decode_string_after_cycle;+        } else {+          if (json_decoder_pop(kv_pop(stack), &stack, &container_stack, &p,+                               &next_map_special, &didcomma, &didcolon)+              == FAIL) {+            goto json_decode_string_fail;+          }+          assert(!next_map_special);+          break;+        }+      }+      case ',': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: Comma not inside container: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (didcomma) {+          EMSG2(_(""E474: Duplicate comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Comma after colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.container.v_type == VAR_DICT+                   && last_container.stack_index != kv_size(stack) - 1) {+          EMSG2(_(""E474: Using comma in place of colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.special_val == NULL+                   ? (last_container.container.v_type == VAR_DICT+                      ? (DICT_LEN(last_container.container.vval.v_dict) == 0)+                      : (last_container.container.vval.v_list->lv_len == 0))+                   : (last_container.special_val->lv_len == 0)) {+          EMSG2(_(""E474: Leading comma: %s""), p);+          goto json_decode_string_fail;+        }+        didcomma = true;+        continue;+      }+      case ':': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: Colon not inside container: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (last_container.container.v_type != VAR_DICT) {+          EMSG2(_(""E474: Using colon not in dictionary: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.stack_index != kv_size(stack) - 2) {+          EMSG2(_(""E474: Unexpected colon: %s""), p);+          goto json_decode_string_fail;+        } else if (didcomma) {+          EMSG2(_(""E474: Colon after comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Duplicate colon: %s""), p);+          goto json_decode_string_fail;+        }+        didcolon = true;+        continue;+      }+      case ' ':+      case TAB:+      case NL: {+        continue;+      }+      case 'n': {+        if (strncmp(p + 1, ""ull"", 3) != 0) {+          EMSG2(_(""E474: Expected null: %s""), p);+          goto json_decode_string_fail;+        }+        p += 3;+        POP(((typval_T) {+          .v_type = VAR_SPECIAL,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_special = kSpecialVarNull },+        }), false);+        break;+      }+      case 't': {+        if (strncmp(p + 1, ""rue"", 3) != 0) {+          EMSG2(_(""E474: Expected true: %s""), p);+          goto json_decode_string_fail;+        }+        p += 3;+        POP(((typval_T) {+          .v_type = VAR_SPECIAL,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_special = kSpecialVarTrue },+        }), false);+        break;+      }+      case 'f': {+        if (strncmp(p + 1, ""alse"", 4) != 0) {+          EMSG2(_(""E474: Expected false: %s""), p);+          goto json_decode_string_fail;+        }+        p += 4;+        POP(((typval_T) {+          .v_type = VAR_SPECIAL,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_special = kSpecialVarFalse },+        }), false);+        break;+      }+      case '""': {+        size_t len = 0;+        const char *const s = ++p;+        while (p < e && *p != '""') {+          if (*p == '\\') {+            p++;+            if (p == e) {+              EMSG2(_(""E474: Unfinished escape sequence: %s""), buf);+              goto json_decode_string_fail;+            }+            switch (*p) {+              case 'u': {+                if (p + 4 >= e) {+                  EMSG2(_(""E474: Unfinished unicode escape sequence: %s""), buf);+                  goto json_decode_string_fail;+                } else if (!ascii_isxdigit(p[1])+                           || !ascii_isxdigit(p[2])+                           || !ascii_isxdigit(p[3])+                           || !ascii_isxdigit(p[4])) {+                  EMSG2(_(""E474: Expected four hex digits after \\u: %s""),+                        p - 1);+                  goto json_decode_string_fail;+                }+                // One UTF-8 character below U+10000 can take up to 3 bytes,+                // above up to 6, but they are encoded using two \u escapes.+                len += 3;+                p += 5;+                break;+              }+              case '\\':+              case '/':+              case '""':+              case 't':+              case 'b':+              case 'n':+              case 'r':+              case 'f': {+                len++;+                p++;+                break;+              }+              default: {+                EMSG2(_(""E474: Unknown escape sequence: %s""), p - 1);+                goto json_decode_string_fail;+              }+            }+          } else {+            uint8_t p_byte = (uint8_t) *p;+            // unescaped = %x20-21 / %x23-5B / %x5D-10FFFF+            if (p_byte < 0x20) {+              EMSG2(_(""E474: ASCII control characters cannot be present ""+                      ""inside string: %s""), p);+              goto json_decode_string_fail;+            }+            const int ch = utf_ptr2char((char_u *) p);+            // All characters above U+007F are encoded using two or more bytes+            // and thus cannot possibly be equal to *p. But utf_ptr2char({0xFF,+            // 0}) will return 0xFF, even though 0xFF cannot start any UTF-8+            // code point at all.+            if (ch >= 0x80 && p_byte == ch) {+              EMSG2(_(""E474: Only UTF-8 strings allowed: %s""), p);+              goto json_decode_string_fail;+            } else if (ch > 0x10FFFF) {+              EMSG2(_(""E474: Only UTF-8 code points up to U+10FFFF ""+                      ""are allowed to appear unescaped: %s""), p);+              goto json_decode_string_fail;+            }+            const size_t ch_len = (size_t) utf_char2len(ch);+            assert(ch_len == (size_t) (ch ? utf_ptr2len((char_u *) p) : 1));+            len += ch_len;+            p += ch_len;+          }+        }+        if (*p != '""') {+          EMSG2(_(""E474: Expected string end: %s""), buf);+          goto json_decode_string_fail;+        }+        if (len == 0) {+          POP(((typval_T) {+            .v_type = VAR_STRING,+            .vval = { .v_string = NULL },+          }), false);+          break;+        }+        char *str = xmalloc(len + 1);+        int fst_in_pair = 0;+        char *str_end = str;+        bool hasnul = false;+        for (const char *t = s; t < p; t++) {+          if (t[0] != '\\' || t[1] != 'u') {+            if (fst_in_pair != 0) {+              str_end += utf_char2bytes(fst_in_pair, (char_u *) str_end);+              fst_in_pair = 0;+            }+          }+          if (*t == '\\') {+            t++;+            switch (*t) {+              case 'u': {+                const char ubuf[] = { t[1], t[2], t[3], t[4] };+                t += 4;+                unsigned long ch;+                vim_str2nr((char_u *) ubuf, NULL, NULL,+                           STR2NR_HEX | STR2NR_FORCE, NULL, &ch, 4);+                if (ch == 0) {+                  hasnul = true;+                }+                if (SURROGATE_HI_START <= ch && ch <= SURROGATE_HI_END) {+                  fst_in_pair = (int) ch;+                } else if (SURROGATE_LO_START <= ch && ch <= SURROGATE_LO_END+                           && fst_in_pair != 0) {+                  const int full_char = (+                      (int) (ch - SURROGATE_LO_START)+                      + ((fst_in_pair - SURROGATE_HI_START) << 10)+                      + SURROGATE_FIRST_CHAR);+                  str_end += utf_char2bytes(full_char, (char_u *) str_end);+                  fst_in_pair = 0;+                } else {+                  str_end += utf_char2bytes((int) ch, (char_u *) str_end);+                }+                break;+              }+              case '\\':+              case '/':+              case '""':+              case 't':+              case 'b':+              case 'n':+              case 'r':+              case 'f': {+                static const char escapes[] = {+                  ['\\'] = '\\',+                  ['/'] = '/',+                  ['""'] = '""',+                  ['t'] = TAB,+                  ['b'] = BS,+                  ['n'] = NL,+                  ['r'] = CAR,+                  ['f'] = FF,+                };+                *str_end++ = escapes[(int) *t];+                break;+              }+              default: {+                assert(false);+              }+            }+          } else {+            *str_end++ = *t;+          }+        }+        if (fst_in_pair != 0) {+          str_end += utf_char2bytes((int) fst_in_pair, (char_u *) str_end);+        }+        if (conv.vc_type != CONV_NONE) {+          size_t str_len = (size_t) (str_end - str);+          char *const new_str = (char *) string_convert(&conv, (char_u *) str,+                                                        &str_len);+          if (new_str == NULL) {+            EMSG2(_(""E474: Failed to convert string \""%s\"" from UTF-8""), str);+            xfree(str);+            goto json_decode_string_fail;+          }+          xfree(str);+          str = new_str;+          str_end = new_str + str_len;+        }+        if (hasnul) {+          typval_T obj;+          list_T *const list = list_alloc();+          list->lv_refcount++;+          create_special_dict(&obj, kMPString, ((typval_T) {+            .v_type = VAR_LIST,+            .v_lock = 0,+            .vval = { .v_list = list },+          }));+          if (encode_list_write((void *) list, str, (size_t) (str_end - str))+              == -1) {+            clear_tv(&obj);+            goto json_decode_string_fail;+          }+          xfree(str);+          POP(obj, true);+        } else {+          *str_end = NUL;+          POP(((typval_T) {+            .v_type = VAR_STRING,+            .vval = { .v_string = (char_u *) str },+          }), false);+        }+        break;+      }+      case '-':+      case '0':+      case '1':+      case '2':+      case '3':+      case '4':+      case '5':+      case '6':+      case '7':+      case '8':+      case '9': {+        // a.bE[+-]exp+        const char *const s = p;+        const char *ints = NULL;+        const char *fracs = NULL;+        const char *exps = NULL;+        if (*p == '-') {+          p++;+        }+        ints = p;+        while (p < e && ascii_isdigit(*p)) {+          p++;+        }+        if (p < e && *p == '.') {+          p++;+          fracs = p;+          while (p < e && ascii_isdigit(*p)) {+            p++;+          }+          if (p < e && (*p == 'e' || *p == 'E')) {+            p++;+            if (p < e && (*p == '-' || *p == '+')) {+              p++;+            }+            exps = p;+            while (p < e && ascii_isdigit(*p)) {+              p++;+            }+          }+        }+        if (p == ints) {+          EMSG2(_(""E474: Missing number after minus sign: %s""), s);+          goto json_decode_string_fail;+        } else if (p == fracs) {+          EMSG2(_(""E474: Missing number after decimal dot: %s""), s);+          goto json_decode_string_fail;+        } else if (p == exps) {+          EMSG2(_(""E474: Missing exponent: %s""), s);+          goto json_decode_string_fail;+        }+        typval_T tv = {+          .v_type = VAR_NUMBER,+          .v_lock = VAR_UNLOCKED,+        };+        if (fracs) {+          // Convert floating-point number+          (void) string2float(s, &tv.vval.v_float);+          tv.v_type = VAR_FLOAT;+        } else {+          // Convert integer+          long nr;+          vim_str2nr((char_u *) s, NULL, NULL, 0, &nr, NULL, (int) (p - s));+          tv.vval.v_number = (varnumber_T) nr;+        }+        POP(tv, false);+        p--;+        break;+      }+      case '[': {+        list_T *list = list_alloc();+        list->lv_refcount++;+        typval_T tv = {+          .v_type = VAR_LIST,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_list = list },+        };+        kv_push(ContainerStackItem, container_stack, ((ContainerStackItem) {+          .stack_index = kv_size(stack),+          .s = p,+          .container = tv,+          .special_val = NULL,+        }));+        kv_push(ValuesStackItem, stack, OBJ(tv, false));+        break;+      }+      case '{': {+        typval_T tv;+        list_T *val_list = NULL;+        if (next_map_special) {+          next_map_special = false;+          val_list = list_alloc();+          val_list->lv_refcount++;+          create_special_dict(&tv, kMPMap, ((typval_T) {+            .v_type = VAR_LIST,+            .v_lock = VAR_UNLOCKED,+            .vval = { .v_list = val_list },+          }));+        } else {+          dict_T *dict = dict_alloc();+          dict->dv_refcount++;+          tv = (typval_T) {+            .v_type = VAR_DICT,+            .v_lock = VAR_UNLOCKED,+            .vval = { .v_dict = dict },+          };+        }+        kv_push(ContainerStackItem, container_stack, ((ContainerStackItem) {+          .stack_index = kv_size(stack),+          .s = p,+          .container = tv,+          .special_val = val_list,+        }));+        kv_push(ValuesStackItem, stack, OBJ(tv, false));+        break;+      }+      default: {+        EMSG2(_(""E474: Unidentified byte: %s""), p);+        goto json_decode_string_fail;+      }+    }+    didcomma = false;+    didcolon = false;+    if (kv_size(container_stack) == 0) {+      p++;+      break;+    }+  }+json_decode_string_after_cycle:+  for (; p < e; p++) {+    switch (*p) {+      case NL:+      case ' ':+      case TAB: {+        break;+      }+      default: {+        EMSG2(_(""E474: Trailing characters: %s""), p);+        goto json_decode_string_fail;+      }+    }+  }+  if (kv_size(stack) > 1 || kv_size(container_stack)) {+    EMSG2(_(""E474: Unexpected end of input: %s""), buf);+    goto json_decode_string_fail;+  }+  goto json_decode_string_ret;+json_decode_string_fail:+  ret = FAIL;+  while (kv_size(stack)) {+    clear_tv(&(kv_pop(stack).val));+  }+json_decode_string_ret:+  if (ret != FAIL) {+    assert(kv_size(stack) == 1);+    *rettv = kv_pop(stack).val;+  }+  kv_destroy(stack);+  kv_destroy(container_stack);+  return ret;+}++#undef POP+#undef OBJ++#undef DICT_LEN++/// Convert msgpack object to a VimL one+int msgpack_to_vim(const msgpack_object mobj, typval_T *const rettv)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  switch (mobj.type) {+    case MSGPACK_OBJECT_NIL: {+      *rettv = (typval_T) {+        .v_type = VAR_SPECIAL,+        .v_lock = VAR_UNLOCKED,+        .vval = { .v_special = kSpecialVarNull },+      };+      break;+    }+    case MSGPACK_OBJECT_BOOLEAN: {+      *rettv = (typval_T) {+        .v_type = VAR_SPECIAL,+        .v_lock = VAR_UNLOCKED,+        .vval = {+          .v_special = mobj.via.boolean ? kSpecialVarTrue : kSpecialVarFalse+        },+      };+      break;+    }+    case MSGPACK_OBJECT_POSITIVE_INTEGER: {+      if (mobj.via.u64 <= VARNUMBER_MAX) {+        *rettv = (typval_T) {+          .v_type = VAR_NUMBER,+          .v_lock = 0,+          .vval = { .v_number = (varnumber_T) mobj.via.u64 },+        };+      } else {+        list_T *const list = list_alloc();+        list->lv_refcount++;+        create_special_dict(rettv, kMPInteger, ((typval_T) {+          .v_type = VAR_LIST,+          .v_lock = 0,+          .vval = { .v_list = list },+        }));+        uint64_t n = mobj.via.u64;+        list_append_number(list, 1);+        list_append_number(list, (varnumber_T) ((n >> 62) & 0x3));+        list_append_number(list, (varnumber_T) ((n >> 31) & 0x7FFFFFFF));+        list_append_number(list, (varnumber_T) (n & 0x7FFFFFFF));+      }+      break;+    }+    case MSGPACK_OBJECT_NEGATIVE_INTEGER: {+      if (mobj.via.i64 >= VARNUMBER_MIN) {+        *rettv = (typval_T) {+          .v_type = VAR_NUMBER,+          .v_lock = 0,+          .vval = { .v_number = (varnumber_T) mobj.via.i64 },+        };+      } else {+        list_T *const list = list_alloc();+        list->lv_refcount++;+        create_special_dict(rettv, kMPInteger, ((typval_T) {+          .v_type = VAR_LIST,+          .v_lock = 0,+          .vval = { .v_list = list },+        }));+        uint64_t n = -((uint64_t) mobj.via.i64);+        list_append_number(list, -1);+        list_append_number(list, (varnumber_T) ((n >> 62) & 0x3));+        list_append_number(list, (varnumber_T) ((n >> 31) & 0x7FFFFFFF));+        list_append_number(list, (varnumber_T) (n & 0x7FFFFFFF));+      }+      break;+    }+    case MSGPACK_OBJECT_FLOAT: {+      *rettv = (typval_T) {+        .v_type = VAR_FLOAT,+        .v_lock = 0,+        .vval = { .v_float = mobj.via.f64 },+      };+      break;+    }+    case MSGPACK_OBJECT_STR: {+      list_T *const list = list_alloc();+      list->lv_refcount++;+      create_special_dict(rettv, kMPString, ((typval_T) {+        .v_type = VAR_LIST,+        .v_lock = 0,+        .vval = { .v_list = list },+      }));+      if (encode_list_write((void *) list, mobj.via.str.ptr, mobj.via.str.size)+          == -1) {",`encode_list_write()` always returns `0`.,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/4252,52850409,2016-02-14T22:48:57Z,src/nvim/syntax.c,"@@ -3286,17 +3288,28 @@ static void syn_cmd_off(exarg_T *eap, int syncing) }  static void syn_cmd_onoff(exarg_T *eap, char *name)+  FUNC_ATTR_NONNULL_ALL {-  char buf[100];-+  did_syntax_onoff = true;   eap->nextcmd = check_nextcmd(eap->arg);   if (!eap->skip) {-    strcpy(buf, ""so "");+    char buf[100];+    strncpy(buf, ""so "", 3);","@justinmk As a fix to the issue you mention, perhaps change this to `strncpy(buf, ""silent! so "", 11);`, perhaps conditional on the global `starting` != 0.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4252,52850639,2016-02-14T23:02:41Z,src/nvim/syntax.c,"@@ -3286,17 +3288,28 @@ static void syn_cmd_off(exarg_T *eap, int syncing) }  static void syn_cmd_onoff(exarg_T *eap, char *name)+  FUNC_ATTR_NONNULL_ALL {-  char buf[100];-+  did_syntax_onoff = true;   eap->nextcmd = check_nextcmd(eap->arg);   if (!eap->skip) {-    strcpy(buf, ""so "");+    char buf[100];+    strncpy(buf, ""so "", 3);",Something like that.. but might need some more conditions to avoid hiding errors in the wrong cases.,
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/4252,52850702,2016-02-14T23:05:17Z,src/nvim/syntax.c,"@@ -3286,17 +3288,28 @@ static void syn_cmd_off(exarg_T *eap, int syncing) }  static void syn_cmd_onoff(exarg_T *eap, char *name)+  FUNC_ATTR_NONNULL_ALL {-  char buf[100];-+  did_syntax_onoff = true;   eap->nextcmd = check_nextcmd(eap->arg);   if (!eap->skip) {-    strcpy(buf, ""so "");+    char buf[100];+    strncpy(buf, ""so "", 3);","I think as long as `starting` is equal to `NO_SCREEN`, it should be fine (the messages wouldn't be displayed anyway)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4252,52850805,2016-02-14T23:09:41Z,src/nvim/syntax.c,"@@ -3286,17 +3288,28 @@ static void syn_cmd_off(exarg_T *eap, int syncing) }  static void syn_cmd_onoff(exarg_T *eap, char *name)+  FUNC_ATTR_NONNULL_ALL {-  char buf[100];-+  did_syntax_onoff = true;   eap->nextcmd = check_nextcmd(eap->arg);   if (!eap->skip) {-    strcpy(buf, ""so "");+    char buf[100];+    strncpy(buf, ""so "", 3);","But that would hide errors in the case of `--cmd 'syntax on'`, for example.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4140,52864511,2016-02-15T06:43:23Z,test/functional/legacy/search_mbyte_spec.lua,"@@ -0,0 +1,31 @@+-- Test for search('multi-byte char', 'bce')",these comments can go in the `describe()` or `it()` descriptions instead. I'll fix this when merging so we don't hold up this PR any longer.,
1104419,lucc,https://api.github.com/repos/neovim/neovim/pulls/4249,52871413,2016-02-15T08:39:35Z,test/functional/legacy/charsearch_spec.lua,"@@ -0,0 +1,42 @@+-- Test for character searches++local helpers = require('test.functional.helpers')+local feed, insert = helpers.feed, helpers.insert+local clear, execute, expect = helpers.clear, helpers.execute, helpers.expect++describe('charsearch', function()+  setup(clear)++  it('is working', function()+    insert([[+      Xabcdefghijkemnopqretuvwxyz+      Yabcdefghijkemnopqretuvwxyz+      Zabcdefghijkemnokqretkvwxyz]])++    -- Check that ""fe"" and "";"" work.+    execute('/^X')+    feed('ylfep;;p,,p')+    -- Check that save/restore works.+    execute('/^Y')+    feed('ylfep')+    execute('let csave = getcharsearch()')+    feed('fip')+    execute('call setcharsearch(csave)')+    feed(';p;p')+    -- Check that setcharsearch() changes the settins.+    execute('/^Z')+    feed('ylfep')+    execute(""call setcharsearch({'char': 'k'})"")+    feed(';p')+    execute(""call setcharsearch({'forward': 0})"")+    feed('$;p')+    execute(""call setcharseearch({'until': 1})"")",I didn't even notice this typo in the original test. If I correct it the test fails. Is this a vim bug? Could you ask on the vim mailing list (James McCoy wrote the patch 7.4.813 for these functions). Or should we just fix it somehow or leave it?(I'm not on the vim list that's why I ask.),
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/3951,52927090,2016-02-15T17:48:33Z,src/nvim/misc1.c,"@@ -1281,11 +1280,13 @@ int plines_win_nofold(win_T *wp, linenr_T lnum)    * Add column offset for 'number', 'relativenumber' and 'foldcolumn'.    */   width = wp->w_width - win_col_off(wp);-  if (width <= 0)+  if (width <= 0) {     return 32000;",seems like it. so it's bigger than the number of lines of the window.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4211,53160934,2016-02-17T13:11:59Z,src/nvim/edit.c,"@@ -2395,44 +2404,41 @@ static void ins_compl_del_pum(void)   } } -/*- * Return TRUE if the popup menu should be displayed.- */-static int pum_wanted(void)+/// Check if the popup menu should be displayed.+static bool pum_wanted(void)+  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT {-  /* 'completeopt' must contain ""menu"" or ""menuone"" */-  if (vim_strchr(p_cot, 'm') == NULL)-    return FALSE;+  // ""completeopt"" must contain ""menu"" or ""menuone""+  if (vim_strchr(p_cot, 'm') == NULL) {+    return false;+  } -  /* The display looks bad on a B&W display. */-  if (t_colors < 8-      )-    return FALSE;-  return TRUE;+  // The display looks bad on a B&W display.","weird logic, if the user sets `menu` they do want the menu no matter how bad it looks. But anyway nvim would never initialize `t_colors` below 8 so it shouldn't case any trouble.",
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4289,53338877,2016-02-18T16:24:41Z,src/nvim/ex_cmds2.c,"@@ -1942,10 +1950,12 @@ void ex_listdo(exarg_T *eap)         ex_cc(eap);          buf = curbuf;-        i = eap->line1 - 1;+        assert(eap->line1 <= INT_MAX);+        i = (int)eap->line1 - 1;         if (eap->addr_count <= 0) {           // Default to all quickfix/location list entries.-          eap->line2 = qf_size;+          assert(qf_size <= LONG_MAX);","`linenr_T` is a type alias to `long`, and `qf_size` is `unsigned long` so I added this assertion. However it is brittle, if `linenr_T` changes, this will have to be updated. Is there a better way to do this?",
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4289,53345178,2016-02-18T17:00:50Z,src/nvim/ex_cmds2.c,"@@ -1847,19 +1852,21 @@ void ex_argdelete(exarg_T *eap)     /* "":1,4argdel"": Delete all arguments in the range. */     if (eap->line2 > ARGCOUNT)       eap->line2 = ARGCOUNT;-    int n = eap->line2 - eap->line1 + 1;+    long n = eap->line2 - eap->line1 + 1;     if (*eap->arg != NUL || n <= 0)       EMSG(_(e_invarg));     else {-      for (int i = eap->line1; i <= eap->line2; ++i)+      assert(eap->line1 <= INT_MAX);","`w_arg_index` is int anyway, so I decided to cast linenumbers to int. I now have a bad feeling about this. Should we change loop index `i` to long instead, and cast to int only on 1869, since 1868 already guarantees it is safe?",
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4289,53345669,2016-02-18T17:03:50Z,src/nvim/ex_cmds2.c,"@@ -1847,19 +1852,21 @@ void ex_argdelete(exarg_T *eap)     /* "":1,4argdel"": Delete all arguments in the range. */     if (eap->line2 > ARGCOUNT)       eap->line2 = ARGCOUNT;-    int n = eap->line2 - eap->line1 + 1;+    long n = eap->line2 - eap->line1 + 1;     if (*eap->arg != NUL || n <= 0)       EMSG(_(e_invarg));     else {-      for (int i = eap->line1; i <= eap->line2; ++i)+      assert(eap->line1 <= INT_MAX);+      assert(eap->line2 <= INT_MAX);+      for (int i = (int)eap->line1; i <= eap->line2; ++i)         xfree(ARGLIST[i - 1].ae_fname);       memmove(ARGLIST + eap->line1 - 1, ARGLIST + eap->line2,-          (size_t)((ARGCOUNT - eap->line2) * sizeof(aentry_T)));+          (size_t)((unsigned long)(ARGCOUNT - eap->line2) * sizeof(aentry_T)));",My bad. Done.,
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4289,53345932,2016-02-18T17:05:36Z,src/nvim/ex_cmds2.c,"@@ -1847,19 +1852,21 @@ void ex_argdelete(exarg_T *eap)     /* "":1,4argdel"": Delete all arguments in the range. */     if (eap->line2 > ARGCOUNT)       eap->line2 = ARGCOUNT;-    int n = eap->line2 - eap->line1 + 1;","But what is the guarantee that it will be an int? I can open a gigantic file and select all of it for deletion, it is a crazy use case, but shouldn't this be long, or more precisely `linenr_T` instead?",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4289,53346816,2016-02-18T17:11:43Z,src/nvim/ex_cmds2.c,"@@ -1847,19 +1852,21 @@ void ex_argdelete(exarg_T *eap)     /* "":1,4argdel"": Delete all arguments in the range. */     if (eap->line2 > ARGCOUNT)       eap->line2 = ARGCOUNT;-    int n = eap->line2 - eap->line1 + 1;",For now linenumber differences are guaranteed to fit in an `int`. But you're right it's probably cleaner to keep it `linenr_T` as long as reasonable and then cast to an `int` when necessary.,
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4289,53348927,2016-02-18T17:26:23Z,src/nvim/ex_cmds2.c,"@@ -3403,16 +3413,20 @@ static void script_host_execute_file(char *name, exarg_T *eap)   // filename   list_append_string(args, buffer, -1);   // current range-  list_append_number(args, eap->line1);-  list_append_number(args, eap->line2);+  assert(eap->line1 <= INT_MAX);+  assert(eap->line2 <= INT_MAX);+  list_append_number(args, (int)eap->line1);+  list_append_number(args, (int)eap->line2);",Is this right? Feels bad casting linenumbers to int unconditionally.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/3951,53350376,2016-02-18T17:37:06Z,src/nvim/misc1.c,"@@ -1281,11 +1280,13 @@ int plines_win_nofold(win_T *wp, linenr_T lnum)    * Add column offset for 'number', 'relativenumber' and 'foldcolumn'.    */   width = wp->w_width - win_col_off(wp);-  if (width <= 0)+  if (width <= 0) {     return 32000;","I guess it's fine, but let's add a comment (""bigger than the number of lines of the screen"")",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/4289,53355975,2016-02-18T18:15:11Z,src/nvim/ex_cmds2.c,"@@ -72,7 +72,7 @@ typedef struct scriptitem_S {   proftime_T sn_prl_start;      /* start time for current line */   proftime_T sn_prl_children;    /* time spent in children for this line */   proftime_T sn_prl_wait;       /* wait start time for current line */-  int sn_prl_idx;               /* index of line being timed; -1 if none */+  long sn_prl_idx;               /* index of line being timed; -1 if none */",Can you do without adding more `long`'s? It's not permitted from style guide.,
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4289,53364977,2016-02-18T19:07:42Z,src/nvim/ex_cmds2.c,"@@ -3403,16 +3413,20 @@ static void script_host_execute_file(char *name, exarg_T *eap)   // filename   list_append_string(args, buffer, -1);   // current range-  list_append_number(args, eap->line1);-  list_append_number(args, eap->line2);+  assert(eap->line1 <= INT_MAX);+  assert(eap->line2 <= INT_MAX);+  list_append_number(args, (int)eap->line1);+  list_append_number(args, (int)eap->line2);","Because a linenumber is guaranteed to fit in an `int` (yes, one day we might want to lift the restriction and allow more than 2G lines, however this would be a long-term effort and I don't think cluttering our codebase with asserts would help towards that goal)",
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4289,53366151,2016-02-18T19:13:41Z,src/nvim/ex_cmds2.c,"@@ -3403,16 +3413,20 @@ static void script_host_execute_file(char *name, exarg_T *eap)   // filename   list_append_string(args, buffer, -1);   // current range-  list_append_number(args, eap->line1);-  list_append_number(args, eap->line2);+  assert(eap->line1 <= INT_MAX);+  assert(eap->line2 <= INT_MAX);+  list_append_number(args, (int)eap->line1);+  list_append_number(args, (int)eap->line2);","Makes sense, but if that is the case, what is the rationale behind having `linenr_T` as an alias for `long` instead of an `int`?If we have a casting where code does not guarantee it is safe, I prefer to add an assertion. line numbers in any sane use case will fit in an int, but technically linenr_T is a long, so..Apologies for being persistent, I'm trying to understand the rationale here.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4289,53371673,2016-02-18T19:47:17Z,src/nvim/ex_cmds2.c,"@@ -3403,16 +3413,20 @@ static void script_host_execute_file(char *name, exarg_T *eap)   // filename   list_append_string(args, buffer, -1);   // current range-  list_append_number(args, eap->line1);-  list_append_number(args, eap->line2);+  assert(eap->line1 <= INT_MAX);+  assert(eap->line2 <= INT_MAX);+  list_append_number(args, (int)eap->line1);+  list_append_number(args, (int)eap->line2);","Likely just because vim does it, and noone has seriously suggested changing it :) Note as vim (and neovim) compiles works just fine on ILP32 or IL32P64 (64-bit windows) it cannot be that vim relies on `linenr_T > INT_MAX` as sentinel values or say temporary overflow in the midst of a calculation.I don't like adding an assert for every technicallity, it makes sense on some casts but here it just adds noise. Rather we should continue to slowly but steadly refactor to use better and more consistent int types, to reduce the number of casts needed. (It might be worthwhile to try change `linenr_T` to say `int32_t` in the short run but it could generate a lot of warnings and follow-on changes, so it might not be an obvious change, but could be worth trying.)",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/4289,53376372,2016-02-18T20:20:00Z,src/nvim/ex_cmds2.c,"@@ -551,7 +553,7 @@ void ex_debuggreedy(exarg_T *eap) void ex_breakdel(exarg_T *eap) {   struct debuggy *bp, *bpi;-  int nr;+  long nr;","same, no `long` if possible.",
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/4281,53381320,2016-02-18T20:59:14Z,src/nvim/path.c,"@@ -1246,13 +1251,11 @@ static int vim_backtick(char_u *p)   return *p == '`' && *(p + 1) != NUL && *(p + STRLEN(p) - 1) == '`'; } -/*- * Expand an item in `backticks` by executing it as a command.- * Currently only works when pat[] starts and ends with a `.- * Returns number of file names found.- */-static int -expand_backtick (+// Expand an item in `backticks` by executing it as a command.+// Currently only works when pat[] starts and ends with a `.+// Returns number of file names found, -1 if an error is encountered.+static int+expand_backtick(","type, name and parameters on same line is better.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4289,53446402,2016-02-19T10:47:55Z,src/nvim/ex_cmds2.c,"@@ -3403,16 +3413,20 @@ static void script_host_execute_file(char *name, exarg_T *eap)   // filename   list_append_string(args, buffer, -1);   // current range-  list_append_number(args, eap->line1);-  list_append_number(args, eap->line2);+  assert(eap->line1 <= INT_MAX);+  assert(eap->line2 <= INT_MAX);+  list_append_number(args, (int)eap->line1);+  list_append_number(args, (int)eap->line2);",your points in #4076 seem reasonable but maybe rename or break out the `linenr_T` part to a separate issue/PR because changing `linenr_T` seems like a bigger change/concern than fixing conversion in `diff.c`,
199728,watiko,https://api.github.com/repos/neovim/neovim/pulls/4302,53545255,2016-02-20T05:47:26Z,test/functional/autocmd/text_deletepost.lua,"@@ -0,0 +1,25 @@+local helpers = require('test.functional.helpers')+local clear, eval, eq, neq = helpers.clear, helpers.eval, helpers.eq, helpers.neq","Some functions are missing: `execute`, `feed`, `nvim`. And `neq` is unused. `make testlint` is useful.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4304,53552776,2016-02-20T16:18:08Z,runtime/doc/autocmd.txt,"@@ -722,6 +724,26 @@ InsertCharPre			When a character is typed in Insert mode, 				It is not allowed to change the text |textlock|. 				The event is not triggered when 'paste' is 				set.+							*TextYankPost*+TextYankPost			Just after a |yank| or |deleting| command+				is issued. Not issued if the black hole register+				(|quote_|) is used. Information about the yank+				can be found in the |v:event| dictionary,+				which has the following keys:+				regcontents+					yanked text stored in register as a list+					of lines.+				regtype+					resulting type of register, as returned+					by |getregtype()|+				regname+					requested register [""x] or the empty+					string for an unnamed operation+				operator+					The operation performed ([d]elete,+					[y]ank, or [c]hange). Unlike |v:operator|,+					it is correct even if an Ex mode+					operation was used, like |:yank|","The documentation of the various keys on `v:event` should probably live at `v:event`. And the autocmd itself just mentions which keys it actually uses. For all autocmds, if the same `v:event` key is used, it should have the _same_ semantics across any autocmd that uses that key. E.g. `v:event.operator` means the same thing for any event that sets it.For an autocmd that does not set `v:event.operator`, if a plugin tries `v:event.operator` it will get a `E716: Key not present in Dictionary: v:event`. But `v:event` itself should exist as an empty dictionary (at minimum) for all autocmds.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4296,53555338,2016-02-20T18:55:51Z,src/nvim/terminal.c,"@@ -288,8 +288,9 @@ void terminal_close(Terminal *term, char *msg)    term->forward_mouse = false;   term->closed = true;+  buf_T *buf = handle_get_buffer(term->buf_handle);","@mhinz  In the `if` block below this, it sets `term->buf_handle = 0`, with the implication that `terminal_close()` may be called again later with that value. `handle_get_buffer()` is a map lookup; if I am reading `build/src/nvim/auto/map.i` correctly, requesting key `0` from it could be a segfault or at least wrong.Suggestion:``` diffdiff --git a/src/nvim/terminal.c b/src/nvim/terminal.cindex 0a7807d..e616728 100644--- a/src/nvim/terminal.c+++ b/src/nvim/terminal.c@@ -288,8 +288,12 @@ void terminal_close(Terminal *term, char *msg)   term->forward_mouse = false;   term->closed = true;+  buf_T *buf = NULL;+  if (term->buf_handle > 0) {+    buf = handle_get_buffer(term->buf_handle);+  }+   if (!msg || exiting) {-    buf_T *buf = handle_get_buffer(term->buf_handle);     // If no msg was given, this was called by close_buffer(buffer.c).  Or if     // exiting, we must inform the buffer the terminal no longer exists so that     // close_buffer() doesn't call this again.@@ -304,6 +308,10 @@ void terminal_close(Terminal *term, char *msg)   } else {     terminal_receive(term, msg, strlen(msg));   }++  if (buf) {+    apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);+  } } void terminal_resize(Terminal *term, uint16_t width, uint16_t height)```",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4313,53570861,2016-02-21T18:42:10Z,CMakeLists.txt,"@@ -82,6 +82,12 @@ if(CMAKE_C_FLAGS_RELEASE MATCHES ""-O3"")   string(REPLACE ""-O3"" ""-O2"" CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS_RELEASE}"") endif() +# Enable link-time optimisations on release builds.+check_c_compiler_flag(-flto HAS_FLTO_FLAG)+if(HAS_FLTO_FLAG)+  set(CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS} -flto"")",Maybe it's only needed for gcc? I (and probably most OSX users?) usually build using clang.For my quick test I simply added `-lfto` to this line: https://github.com/neovim/neovim/blob/master/CMakeLists.txt#L144,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4313,53571130,2016-02-21T18:59:03Z,CMakeLists.txt,"@@ -82,6 +82,12 @@ if(CMAKE_C_FLAGS_RELEASE MATCHES ""-O3"")   string(REPLACE ""-O3"" ""-O2"" CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS_RELEASE}"") endif() +# Enable link-time optimisations on release builds.+check_c_compiler_flag(-flto HAS_FLTO_FLAG)+if(HAS_FLTO_FLAG)+  set(CMAKE_C_FLAGS_RELEASE ""${CMAKE_C_FLAGS} -flto"")","Confirmed, only adding to `CMAKE_C_FLAGS` leads to errors like this in the Release build:```[103/108] Building C object src/nvim/CMakeFiles/nvim.dir/regexp.c.oclang: warning: -lfto: 'linker' input unused```",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/4304,53698445,2016-02-22T21:46:36Z,runtime/doc/eval.txt,"@@ -1386,6 +1386,23 @@ v:errors	Errors found by assert functions, such as |assert_true()|. <		If v:errors is set to anything but a list it is made an empty 		list by the assert function. +					*v:event*+v:event		Data related to an |autocommand| event as a Dictionary. The+		available keys differ between different events and are+		specificed at the documentation for each |event|. The possible+		keys are:+	regname","The formatting of this is a bit weird, perhaps make it more similar to what, for example, `:help 'buftype'` or `:help v:fcs_reason` has.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4304,53706854,2016-02-22T22:44:36Z,test/functional/autocmd/textyankpost_spec.lua,"@@ -0,0 +1,166 @@+local helpers = require('test.functional.helpers')+local clear, eval, eq, insert = helpers.clear, helpers.eval, helpers.eq, helpers.insert+local feed, execute, expect = helpers.feed, helpers.execute, helpers.expect+++describe('TextYankPost', function()+  before_each(function()+    clear()++    -- emulate the clipboard so system clipboard isn't affected+    execute('let &rtp = ""test/functional/fixtures,"".&rtp')++    execute('let g:count = 0')+    execute('autocmd TextYankPost * let g:event = copy(v:event)')+    execute('autocmd TextYankPost * let g:count += 1')","What does the pattern match against? I think in the doc, we should mention that the pattern should always be `*`, because it may change in the future to match against something more useful than ""the current filename"".",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4304,53708008,2016-02-22T22:53:26Z,test/functional/autocmd/textyankpost_spec.lua,"@@ -0,0 +1,166 @@+local helpers = require('test.functional.helpers')+local clear, eval, eq, insert = helpers.clear, helpers.eval, helpers.eq, helpers.insert+local feed, execute, expect = helpers.feed, helpers.execute, helpers.expect+++describe('TextYankPost', function()+  before_each(function()+    clear()++    -- emulate the clipboard so system clipboard isn't affected+    execute('let &rtp = ""test/functional/fixtures,"".&rtp')++    execute('let g:count = 0')+    execute('autocmd TextYankPost * let g:event = copy(v:event)')+    execute('autocmd TextYankPost * let g:count += 1')",can we enforce this by setting amatch to something useless?,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4274,53708585,2016-02-22T22:58:00Z,src/nvim/terminal.c,"@@ -250,12 +253,16 @@ Terminal *terminal_open(TerminalOptions opts)   rv->sb_size = MIN(rv->sb_size, 100000);   rv->sb_buffer = xmalloc(sizeof(ScrollbackLine *) * rv->sb_size); +  if (!true_color) {+      return rv;+  }+   // Configure the color palette. Try to get the color from:   //   // - b:terminal_color_{NUM}   // - g:terminal_color_{NUM}   // - the VTerm instance","the lines removed below mean that ""the VTerm instance"" is no longer queried for default colors. Why was that removed? And if we go with that, then this comment needs to be updated to reflect that. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4304,53710544,2016-02-22T23:13:45Z,test/functional/autocmd/textyankpost_spec.lua,"@@ -0,0 +1,166 @@+local helpers = require('test.functional.helpers')+local clear, eval, eq, insert = helpers.clear, helpers.eval, helpers.eq, helpers.insert+local feed, execute, expect = helpers.feed, helpers.execute, helpers.expect+++describe('TextYankPost', function()+  before_each(function()+    clear()++    -- emulate the clipboard so system clipboard isn't affected+    execute('let &rtp = ""test/functional/fixtures,"".&rtp')++    execute('let g:count = 0')+    execute('autocmd TextYankPost * let g:event = copy(v:event)')+    execute('autocmd TextYankPost * let g:count += 1')","if we want to enforce it, probably best to enhance `ex_autocmd()` to reject non-approved patterns. But I think just documenting it is fine for now.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,53737977,2016-02-23T05:32:04Z,src/nvim/ops.c,"@@ -2524,6 +2528,58 @@ static void yank_copy_line(yankreg_T *reg, struct block_def *bd, long y_idx)   *pnew = NUL; } +static void yank_do_autocmd(oparg_T *oap, yankreg_T *reg)+{+  char buf[NUMBUFLEN+2];++  if (!has_event(EVENT_TEXTYANKPOST)) {+    // No autocommand was defined+    return;+  }++  // set v:event to a dictionary with information about the yank+  dict_T *dict = dict_alloc();++  // the yanked text+  list_T *list = list_alloc();+  for (int i = 0; i < reg->y_size; i++) {+    list_append_string(list, reg->y_array[i], -1);+  }+  dict_add_list(dict, ""regcontents"", list);++  // the register type+  buf[0] = NUL;+  buf[1] = NUL;+  switch (reg->y_type) {+  case MLINE: buf[0] = 'V'; break;+  case MCHAR: buf[0] = 'v'; break;+  case MBLOCK:+    buf[0] = Ctrl_V;+    snprintf(buf + 1, ARRAY_SIZE(buf) - 1, ""%"" PRId64,+             (int64_t)(reg->y_width + 1));+    break;+  default:+    assert(false);","AFAIR compiler does not bother warning about no `default` with standard types. At least, both clang and gcc have nothing against``` Cint main(int argc, char **argv, char **environ){    switch (argc) {        case 1: break;    }    return 0;}```(actually, the same code, but without line breaks because I used `echo ��� | {compiler} -xc {-Wall(gcc)|-Weverything(clang)} -`; clang though complained about unused parameters argv and environ).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,53738311,2016-02-23T05:39:32Z,runtime/doc/eval.txt,"@@ -1386,6 +1386,19 @@ v:errors	Errors found by assert functions, such as |assert_true()|. <		If v:errors is set to anything but a list it is made an empty 		list by the assert function. +					*v:event*+v:event		Data related to an |autocommand| event as a Dictionary. The+		available keys differ between different events and are+		specificed at the documentation for each |event|. The possible+		keys are:+	regname 	requested register [""x] or the empty string for an","Indentation does not look right, check `v:fcs_reason`. Also use proper sentences _always_ or _never_ in a list, this should be ���Requested register (e.g. ""x"" for ""xyy) or the empty string for an unnamed operation.��� because you probably cannot shrink `operator` description.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,53738489,2016-02-23T05:43:00Z,runtime/doc/eval.txt,"@@ -1386,6 +1386,19 @@ v:errors	Errors found by assert functions, such as |assert_true()|. <		If v:errors is set to anything but a list it is made an empty 		list by the assert function. +					*v:event*+v:event		Data related to an |autocommand| event as a Dictionary. The+		available keys differ between different events and are+		specificed at the documentation for each |event|. The possible+		keys are:+	regname 	requested register [""x] or the empty string for an+			unnamed operation.+	regcontents	text stored in the register as a list of lines.",Usually when such list of lines is referenced `readfile()` or `getline()` is also mentioned. E.g. `|readfile()|-style list of lines`.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,53738969,2016-02-23T05:53:25Z,test/functional/autocmd/textyankpost_spec.lua,"@@ -0,0 +1,166 @@+local helpers = require('test.functional.helpers')+local clear, eval, eq, insert = helpers.clear, helpers.eval, helpers.eq, helpers.insert+local feed, execute, expect = helpers.feed, helpers.execute, helpers.expect+++describe('TextYankPost', function()+  before_each(function()+    clear()++    -- emulate the clipboard so system clipboard isn't affected+    execute('let &rtp = ""test/functional/fixtures,"".&rtp')++    execute('let g:count = 0')+    execute('autocmd TextYankPost * let g:event = copy(v:event)')+    execute('autocmd TextYankPost * let g:count += 1')+  end)++  it('is executed after yank and handles register types', function()+    insert([[+      foo bar+      baz text]])","Test text should contain `NUL` (to check that result is really readfile()-style list of lines because here `NUL` is transformed into `NL`). I would suggest writing this as``` Luacurbufmeths.set_line_slice(0, 0, true, true, {  'foo\0bar',  'baz text',})```and put this into `before_each` function, you in any case set buffer text to two lines _always_, what���s the point of having these lines be different?(BTW, @tarruda set_line_slice is not tested for it throwing any errors at all and not tested for NUL handling. Also why ���string cannot contain newlines��� is Exception and not Validation?)",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4274,53739615,2016-02-23T06:08:00Z,src/nvim/terminal.c,"@@ -217,10 +214,14 @@ Terminal *terminal_open(TerminalOptions opts)   vterm_set_utf8(rv->vt, 1);   // Setup state   VTermState *state = vterm_obtain_state(rv->vt);+  // Only relevant in terminal true color mode+  if (true_color) {+    vterm_state_set_bold_highbright(state, true);","As long as we aren't regressing #3333 it does not matter to me. If we can avoid the option, great. @cHoco does this work for you?",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,53794600,2016-02-23T15:24:52Z,src/nvim/ops.c,"@@ -2524,6 +2528,61 @@ static void yank_copy_line(yankreg_T *reg, struct block_def *bd, long y_idx)   *pnew = NUL; } +static void yank_do_autocmd(oparg_T *oap, yankreg_T *reg)+{+  char buf[NUMBUFLEN+2];++  if (!has_event(EVENT_TEXTYANKPOST)) {+    // No autocommand was defined+    return;+  }++  // set v:event to a dictionary with information about the yank+  dict_T *dict = get_vim_var_dict(VV_EVENT);++  // the yanked text+  list_T *list = list_alloc();+  for (linenr_T i = 0; i < reg->y_size; i++) {+    list_append_string(list, reg->y_array[i], -1);+  }+  dict_add_list(dict, ""regcontents"", list);++  // the register type+  buf[0] = NUL;+  buf[1] = NUL;+  switch (reg->y_type) {+    case MLINE:+      buf[0] = 'V';+      break;+    case MCHAR:+      buf[0] = 'v';+      break;+    case MBLOCK:+      buf[0] = Ctrl_V;+      snprintf(buf + 1, ARRAY_SIZE(buf) - 1, ""%"" PRId64,+               (int64_t)(reg->y_width + 1));+      break;+    case MAUTO:+      assert(false);+  }","It would be logical to move this code out of here to a function used both for `getregtype` and `yank_do_autocmd`:``` Patchdiff --git a/src/nvim/eval.c b/src/nvim/eval.cindex a0a686f..3693fba 100644--- a/src/nvim/eval.c+++ b/src/nvim/eval.c@@ -10052,16 +10052,8 @@ static void f_getregtype(typval_T *argvars, typval_T *rettv)   if (regname == 0)     regname = '""';-  buf[0] = NUL;-  buf[1] = NUL;-  switch (get_reg_type(regname, &reglen)) {-  case MLINE: buf[0] = 'V'; break;-  case MCHAR: buf[0] = 'v'; break;-  case MBLOCK:-    buf[0] = Ctrl_V;-    sprintf((char *)buf + 1, ""%"" PRId64, (int64_t)(reglen + 1));-    break;-  }+  op_get_register_type(NULL, regname, buf, sizeof(buf));+   rettv->v_type = VAR_STRING;   rettv->vval.v_string = vim_strsave(buf); }diff --git a/src/nvim/ops.c b/src/nvim/ops.cindex b1adc85..968a7c8 100644--- a/src/nvim/ops.c+++ b/src/nvim/ops.c@@ -4626,39 +4626,58 @@ theend:   return did_change; }-/*- * Return the type of a register.- * Used for getregtype()- * Returns MAUTO for error.- */-char_u get_reg_type(int regname, long *reglen)+/// Write register type to a buffer+///+/// @param[in]  reg  Register to use.+/// @param[in]  regname  Register name. Used in case reg is NULL.+/// @param[out]  ret_buf  Buffer where results will be saved. If requested+///                       register is not valid, ret_buf[0] is set to NUL, in+///                       any other case it will be one of 'v', 'V' or Ctrl_V.+///                       In the latter case Ctrl_V will be followed by a width.+/// @param[in]  ret_buf_len  Buffer length. Must be at least two characters.+void op_get_register_type(const yankreg_T *reg, const int regname,+                          char *const ret_buf, const size_t ret_buf_len)+  FUNC_ATTR_NONNULL_ARG(3) {-  switch (regname) {-  case '%':                     /* file name */-  case '#':                     /* alternate file name */-  case '=':                     /* expression */-  case ':':                     /* last command line */-  case '/':                     /* last search-pattern */-  case '.':                     /* last inserted text */-  case Ctrl_F:                  /* Filename under cursor */-  case Ctrl_P:                  /* Path under cursor, expand via ""path"" */-  case Ctrl_W:                  /* word under cursor */-  case Ctrl_A:                  /* WORD (mnemonic All) under cursor */-  case '_':                     /* black hole: always empty */-    return MCHAR;+  assert(buf_len > 1);+  if (reg == NULL) {+    switch (regname) {+      case '%':     // file name+      case '#':     // alternate file name+      case '=':     // expression+      case ':':     // last command line+      case '/':     // last search-pattern+      case '.':     // last inserted text+      case Ctrl_F:  // filename under cursor+      case Ctrl_P:  // path under cursor, expand via ""path""+      case Ctrl_W:  // word under cursor+      case Ctrl_A:  // WORD (mnemonic All) under cursor+      case '_': {   // black hole: always empty+        ret_buf[0] = 'v';+        ret_buf[1] = NUL;+        return;+      }+      default: {+        if (regname != NUL && !valid_yank_reg(regname, false)) {+          reg = get_yank_register(regname, YREG_PASTE);+        }+        break;+      }+    }   }--  if (regname != NUL && !valid_yank_reg(regname, false))-    return MAUTO;--  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);-   if (reg->y_array != NULL) {-    if (reglen != NULL && reg->y_type == MBLOCK)-      *reglen = reg->y_width;-    return reg->y_type;+    switch (reg->y_type) {+      case MLINE: ret_buf[0] = 'V'; ret_buf[1] = NUL; break;+      case MCHAR: ret_buf[0] = 'v'; ret_buf[1] = NUL; break;+      case MBLOCK: {+        snprintf(ret_buf, ret_buf_len, CTRL_V_STR ""%"" PRIdCOLNR,+                 reg->y_width + 1);+        break;+      }+    }+    return;   }-  return MAUTO;+  ret_buf[0] = NUL; } /// When `flags` has `kGRegList` return a list with text `s`.diff --git a/src/nvim/pos.h b/src/nvim/pos.hindex 7071df5..674d9e9 100644--- a/src/nvim/pos.h+++ b/src/nvim/pos.h@@ -1,8 +1,15 @@ #ifndef NVIM_POS_H #define NVIM_POS_H-typedef long linenr_T;         // line number type-typedef int colnr_T;           // column number type+/// Line number type+typedef long linenr_T;+/// Format used to print values which have linenr_T type+#define PRIdLINENR ""ld""++/// Column number type+typedef int colnr_T;+/// Format used to print values which have colnr_T type+#define PRIdCOLNR ""d"" #define MAXLNUM 0x7fffffff     // maximum (invalid) line number #define MAXCOL  0x7fffffff     // maximum column number, 31 bits```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,53814786,2016-02-23T17:18:37Z,src/nvim/ops.c,"@@ -2524,6 +2528,61 @@ static void yank_copy_line(yankreg_T *reg, struct block_def *bd, long y_idx)   *pnew = NUL; } +static void yank_do_autocmd(oparg_T *oap, yankreg_T *reg)+{+  char buf[NUMBUFLEN+2];++  if (!has_event(EVENT_TEXTYANKPOST)) {+    // No autocommand was defined+    return;+  }++  // set v:event to a dictionary with information about the yank+  dict_T *dict = get_vim_var_dict(VV_EVENT);++  // the yanked text+  list_T *list = list_alloc();+  for (linenr_T i = 0; i < reg->y_size; i++) {+    list_append_string(list, reg->y_array[i], -1);+  }+  dict_add_list(dict, ""regcontents"", list);++  // the register type+  buf[0] = NUL;+  buf[1] = NUL;+  switch (reg->y_type) {+    case MLINE:+      buf[0] = 'V';+      break;+    case MCHAR:+      buf[0] = 'v';+      break;+    case MBLOCK:+      buf[0] = Ctrl_V;+      snprintf(buf + 1, ARRAY_SIZE(buf) - 1, ""%"" PRId64,+               (int64_t)(reg->y_width + 1));+      break;+    case MAUTO:+      assert(false);+  }","Which two input kinds? Steps cannot be cleanely separated because sometimes function needs `yankreg_T` and sometimes it exits right after checking register name because such structure does not exist for requested register. this is also second reason why I had to place `reg` and `regname` together, first is because your code receives `reg` and I do not like doing useless job of finding `reg` for the second time.I do see how creating two steps out of one will make code simpler.",
4954650,HiPhish,https://api.github.com/repos/neovim/neovim/pulls/3229,53876224,2016-02-24T00:34:19Z,src/nvim/eval.c,"@@ -11034,12 +11161,101 @@ static void f_has_key(typval_T *argvars, typval_T *rettv)       get_tv_string(&argvars[1]), -1) != NULL; } -/*- * ""haslocaldir()"" function- */+/// `haslocaldir([{win}[, {tab}]])` function+///+/// Returns `1` if the scope object has a local directory, `0` otherwise. If a+/// scope object is not specified the current one is implied. This function+/// share a lot of code with `f_getcwd`.+///+/// @pre  The arguments must be of type number.+/// @pre  There may not be more than two arguments.+/// @pre  An argument may not be -1 if preceding arguments are not all -1.+///+/// @post  The return value will be either the number `1` or `0`. static void f_haslocaldir(typval_T *argvars, typval_T *rettv) {-  rettv->vval.v_number = (curwin->w_localdir != NULL);+  // Possible scope of working directory to return.+  CdScope scope = kCdScopeWindow;++  // Numbers of the scope objects (window, tab) we want the working directory+  // of. A `-1` means to skip this scope, a `0` means the current object.+  int scope_number[NUMBER_OF_CD_SCOPES] = {+    [kCdScopeWindow] = 0,  // Number of window to look at.+    [kCdScopeTab   ] = 0,  // Number of tab to look at.+  };++  tabpage_T *tp  = curtab;  // The tabpage to look at.+  win_T     *win = curwin;  // The window to look at.++  rettv->v_type = VAR_NUMBER;+  rettv->vval.v_number = 0;++  // Pre-conditions and scope extraction together+  for (int i = 0; i < kCdScopeGlobal; i++) {+    if (argvars[i].v_type == VAR_UNKNOWN) {+      break;+    }+    if (argvars[i].v_type != VAR_NUMBER) {+      EMSG(_(e_invarg));+      return;+    }+    scope_number[i] = argvars[i].vval.v_number;+    // The scope is the current iteration step.+    scope = i;+    // It is an error for the scope number to be less than `-1`.+    if (scope_number[i] < -1) {+      EMSG(_(e_invarg));+      return;+    }+  }++  // It the highest scope number is `-1` lower the scope by one.+  if (scope_number[scope] < 0) {+    ++scope;+  }++  // Find the tabpage by number+  if (scope_number[kCdScopeTab] == -1) {+    tp = NULL;+  } else if (scope_number[kCdScopeTab] > 0) {+    tp = find_tabpage(scope_number[kCdScopeTab]);+    if (!tp) {+      EMSG(_(""E740: Cannot find tab number.""));+      return;+    }+  }++  // Find the window in `tp` by number, `NULL` if none.+  if (scope_number[kCdScopeWindow] == -1) {+    win = NULL;+  } else if (scope_number[kCdScopeWindow] >= 0) {+    // If `tp` is `NULL` that's an error+    if (!tp) {+      EMSG(_(""E740: Second argument cannot be -1 if first argument is >= 0.""));+      return;+    }++    if (scope_number[kCdScopeWindow] > 0) {+      win = find_win_by_nr(&argvars[0], curtab);+      if (!win) {+        EMSG(_(""E740: Cannot find window number.""));","I don't know, I was just looking for some error that that something to do with arguments. I don't know about Vim error codes and I haven't been able to find a concise list. If you have a better suggestion or a link let me know, changing the codes is trivial.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4337,53984973,2016-02-24T18:42:15Z,runtime/doc/eval.txt,"@@ -5732,11 +5732,12 @@ setline({lnum}, {text})					*setline()* 			:endfor <		Note: The '[ and '] marks are not set. -setloclist({nr}, {list} [, {action}])			*setloclist()*+setloclist({nr}, {list} [, {action}[, {title}]])	*setloclist()*",AFAIR there is a list of functions up there which also needs to be changed.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4337,53986183,2016-02-24T18:49:34Z,runtime/doc/eval.txt,"@@ -5832,6 +5833,9 @@ setqflist({list} [, {action}])				*setqflist()* 		with the items from {list}. If {action} is not present or is 		set to ' ', then a new list is created. +		If {title} is given, it will be stored in the variable+		|w:quickfix_title|.+","���If {title} is given it will be used as the {quickfix,location} window title available through |w:quickfix_title| after opening the window.��� Title is stored even if there is no window available, so it is not correct to state that it is stored there. Also this specific phrase sounds like ���setqflist() will do `let w:quickfix_title = {title}`��� because when not said otherwise variable is expected to refer to the _current_ window.",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4337,54027589,2016-02-24T23:44:04Z,runtime/doc/eval.txt,"@@ -5732,11 +5732,12 @@ setline({lnum}, {text})					*setline()* 			:endfor <		Note: The '[ and '] marks are not set. -setloclist({nr}, {list} [, {action}])			*setloclist()*+setloclist({nr}, {list} [, {action}[, {title}]])	*setloclist()*","Right, there's also `:h functions`. (And `:h function-list`, but no arguments are given there.):+1:",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4337,54032866,2016-02-25T00:43:10Z,test/functional/viml/errorlist_spec.lua,"@@ -0,0 +1,30 @@+local helpers = require('test.functional.helpers')++local clear   = helpers.clear+local command = helpers.command+local eq      = helpers.eq+local eval    = helpers.eval","As usual I would suggest replacing `eval` with `helpers.funcs.setqflist(���)` and `helpers.curwinmeths.get_var('quickfix_title')`, there is no need to invoke expression parser.Also it is not good idea to align equal signs because it needs realignment once somebody adds something more lengthy like `curwinmeths`. (I sometimes entertain myself arranging variables by their length which also may look good yet does not require realigning, but not rearranging though. And sometimes, not always.)",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4337,54033883,2016-02-25T00:56:07Z,src/nvim/eval.c,"@@ -15219,10 +15219,13 @@ static void f_setline(typval_T *argvars, typval_T *rettv) /*  * Used by ""setqflist()"" and ""setloclist()"" functions  */","``` C/// Create quickfix/location list from VimL values////// Used by `setqflist()` and `setloclist()` functions. Accepts invalid/// list_arg, action_arg and title_arg arguments in which case errors out,/// including VAR_UNKNOWN parameters.////// @param[in,out]  wp  Window to create location list for. May be NULL in///                     which case quickfix list will be created./// @param[in]  list_arg  Quickfix list contents./// @param[in]  action_arg  Action to perform: append to an existing list,///                         replace its content or create a new one./// @param[in]  title_arg  New list title. Defaults to caller function name./// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.```",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4337,54036459,2016-02-25T01:24:48Z,src/nvim/eval.c,"@@ -15239,9 +15242,20 @@ static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg,         action = *act;     } -    if (l != NULL && set_errorlist(wp, l, action,-            (char_u *)(wp == NULL ? ""setqflist()"" : ""setloclist()"")) == OK)+    if (title_arg->v_type == VAR_STRING) {","Ah, right. This makes `setqflist(..., ..., 5)` work just as well. Neat. :+1:",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4337,54038240,2016-02-25T01:46:28Z,src/nvim/eval.c,"@@ -15239,9 +15242,20 @@ static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg,         action = *act;     } -    if (l != NULL && set_errorlist(wp, l, action,-            (char_u *)(wp == NULL ? ""setqflist()"" : ""setloclist()"")) == OK)+    if (title_arg->v_type == VAR_STRING) {","What's the proper way of catching errors? `helpers.exc_exec('call setqflist([""""], ""r"", {})')` doesn't seem to return an error message, but it does on the command-line.EDIT: Nevermind. :)",
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4337,54038474,2016-02-25T01:48:59Z,src/nvim/eval.c,"@@ -15239,9 +15242,20 @@ static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg,         action = *act;     } -    if (l != NULL && set_errorlist(wp, l, action,-            (char_u *)(wp == NULL ? ""setqflist()"" : ""setloclist()"")) == OK)+    if (title_arg->v_type == VAR_STRING) {","Is this sane?``` lualocal exc = exc_exec('call setqflist([""""], ""r"", {})')eq(exc, 'Vim(call):E731: using Dictionary as a String')```",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4337,54049651,2016-02-25T05:13:41Z,src/nvim/eval.c,"@@ -15215,14 +15215,26 @@ static void f_setline(typval_T *argvars, typval_T *rettv)     appended_lines_mark(lcount, added); } --/*- * Used by ""setqflist()"" and ""setloclist()"" functions- */-static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *rettv)+/// Create quickfix/location list from VimL values+///+/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid+/// list_arg, action_arg and title_arg arguments in which case errors out,+/// including VAR_UNKNOWN parameters.+///+/// @param[in,out]  wp  Function to create location list for. May be NULL in","You have copied this from comment version which contained a typo: ���Window to create location list for���, not ���Function ������. I silently edited it later.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,54108192,2016-02-25T15:07:09Z,src/nvim/eval.c,"@@ -10571,18 +10594,13 @@ static void f_getregtype(typval_T *argvars, typval_T *rettv)   if (regname == 0)     regname = '""'; -  buf[0] = NUL;-  buf[1] = NUL;-  switch (get_reg_type(regname, &reglen)) {-  case MLINE: buf[0] = 'V'; break;-  case MCHAR: buf[0] = 'v'; break;-  case MBLOCK:-    buf[0] = Ctrl_V;-    sprintf((char *)buf + 1, ""%"" PRId64, (int64_t)(reglen + 1));-    break;-  }+  colnr_T reglen = 0;+  char buf[NUMBUFLEN + 2];+  char_u reg_type = get_reg_type(regname, &reglen);+  format_reg_type(reg_type, reglen, buf, ARRAY_SIZE(buf));+   rettv->v_type = VAR_STRING;-  rettv->vval.v_string = vim_strsave(buf);+  rettv->vval.v_string = vim_strsave((char_u *)buf);","If you have buffer updated to `char` it is also logical to update `vim_strsave((char_u *)` to `(char_u *) xstrdup(`: when `char_u` is removed `vim_strsave` is no longer needed (it is actually doing nothing more then simply calling `xstrdup` in turn, but has different types; `xstrdup` is newer).",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,54111325,2016-02-25T15:26:56Z,src/nvim/ops.c,"@@ -2524,6 +2528,46 @@ static void yank_copy_line(yankreg_T *reg, struct block_def *bd, long y_idx)   *pnew = NUL; } +static void yank_do_autocmd(oparg_T *oap, yankreg_T *reg)+{+  char buf[NUMBUFLEN+2];++  if (!has_event(EVENT_TEXTYANKPOST)) {+    // No autocommand was defined+    return;+  }++  // set v:event to a dictionary with information about the yank+  dict_T *dict = get_vim_var_dict(VV_EVENT);++  // the yanked text+  list_T *list = list_alloc();+  for (linenr_T i = 0; i < reg->y_size; i++) {+    list_append_string(list, reg->y_array[i], -1);+  }+  list->lv_lock = VAR_FIXED;+  dict_add_list(dict, ""regcontents"", list);","Note that while list lock will protect list from modifications one can still do `let v:event.regcontents = 0` because it is dictionary that is locked during initialization, dictionary keys created by `dict_add_*` are explicitly created unlocked.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4304,54206277,2016-02-26T05:21:57Z,src/nvim/ops.c,"@@ -2524,6 +2528,46 @@ static void yank_copy_line(yankreg_T *reg, struct block_def *bd, long y_idx)   *pnew = NUL; } +static void yank_do_autocmd(oparg_T *oap, yankreg_T *reg)+{+  char buf[NUMBUFLEN+2];++  if (!has_event(EVENT_TEXTYANKPOST)) {+    // No autocommand was defined+    return;+  }++  // set v:event to a dictionary with information about the yank+  dict_T *dict = get_vim_var_dict(VV_EVENT);++  // the yanked text+  list_T *list = list_alloc();+  for (linenr_T i = 0; i < reg->y_size; i++) {+    list_append_string(list, reg->y_array[i], -1);+  }+  list->lv_lock = VAR_FIXED;+  dict_add_list(dict, ""regcontents"", list);","@bfredl No, these are flags for scope dictionaries only. You can set them, but this action is absolutely useless. di_tv.v_lock.Also note that you must not use `���di_flags = ���` in this case because this clears out DI_FLAGS_ALLOC which leads to a memory leak.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4337,54331586,2016-02-27T10:15:43Z,src/nvim/eval.c,"@@ -15255,8 +15278,9 @@ static void f_setloclist(typval_T *argvars, typval_T *rettv)   rettv->vval.v_number = -1;    win = find_win_by_nr(&argvars[0], NULL);-  if (win != NULL)-    set_qf_ll_list(win, &argvars[1], &argvars[2], rettv);+  if (win != NULL) {+    set_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);","Was already mentioned on gitter: We need to check that there are really four arguments, if we call `set_qf_ll_list()` like this.Perhaps it would be easier if we change the arguments of `set_qf_ll_list()` and just forward the argument array: `set_qf_ll_list(win, &argvars[1], typeval_T *rettv)` and do the argument checks there.",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4337,54331625,2016-02-27T10:18:56Z,src/nvim/eval.c,"@@ -15392,7 +15416,7 @@ static void f_setpos(typval_T *argvars, typval_T *rettv)  */ static void f_setqflist(typval_T *argvars, typval_T *rettv) {-  set_qf_ll_list(NULL, &argvars[0], &argvars[1], rettv);+  set_qf_ll_list(NULL, &argvars[0], &argvars[1], &argvars[2], rettv);",Same problem here as in `f_setloclist()`. We are missing argument checks to prevent  calling `set_qf_ll_list()` with arguments that do not exist.,
972014,mhinz,https://api.github.com/repos/neovim/neovim/pulls/4337,54332212,2016-02-27T11:26:40Z,src/nvim/eval.c,"@@ -15255,8 +15278,9 @@ static void f_setloclist(typval_T *argvars, typval_T *rettv)   rettv->vval.v_number = -1;    win = find_win_by_nr(&argvars[0], NULL);-  if (win != NULL)-    set_qf_ll_list(win, &argvars[1], &argvars[2], rettv);+  if (win != NULL) {+    set_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);","> Perhaps it would be easier if we change the arguments of set_qf_ll_list() and just forward the argument array:+1: If you're not already doing it, I'll look into it later today.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4304,54357202,2016-02-28T21:54:09Z,runtime/doc/eval.txt,"@@ -1386,6 +1386,23 @@ v:errors	Errors found by assert functions, such as |assert_true()|. <		If v:errors is set to anything but a list it is made an empty 		list by the assert function. +					*v:event* *event-variable*+v:event		Data related to an |autocommand| event as a Dictionary.  The+		available keys differ between different events and are+		specificed at the documentation for each |event|.  The possible+		keys are:+			regname 	Requested register (e.g ""x"" for ""xyy)+					or the empty string for an unnamed+					operation.+			regcontents	Text stored in the register as a+					|readfile()|-style list of lines.+			regtype		Type of register as returned by+					|getregtype()|.+			operator	The operation performed.  Unlike+					|v:operator|, it is set also for an Ex+					mode command.  For instance, |:yank| is+					translated to ""|y|"".",key names should be listed in alphabetical order.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4304,54407727,2016-02-29T13:19:20Z,runtime/doc/eval.txt,"@@ -1386,6 +1386,23 @@ v:errors	Errors found by assert functions, such as |assert_true()|. <		If v:errors is set to anything but a list it is made an empty 		list by the assert function. +					*v:event* *event-variable*+v:event		Data related to an |autocommand| event as a Dictionary.  The",``` Dictionary of event data for the current |autocommand|.```,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/3657,54582740,2016-03-01T15:29:24Z,test/functional/viml/max_args_spec.lua,"@@ -0,0 +1,29 @@+local helpers = require('test.functional.helpers')++local clear = helpers.clear+local eq = helpers.eq+local exc_exec = helpers.exc_exec++describe('Up to MAX_FUNC_ARGS arguments are handled by', function()","Consider renaming the test to `function_spec.lua`. (Unless it already exists, then these should be moved there)",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/4377,54607283,2016-03-01T18:02:23Z,src/nvim/window.c,"@@ -2973,6 +2973,7 @@ int win_new_tabpage(int after)     return FAIL;   }   curtab = newtp;+  apply_autocmds(EVENT_TABNEW, arg, arg, false, curbuf);    /* Create a new empty window. */   if (win_alloc_firstwin(tp->tp_curwin) == OK) {","Yes, that seems better to me. After all, the success condition of `win_new_tabpage` only happens within that branch, it would be weird to trigger the event when the function fails (not sure how likely that is though). ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4384,54681821,2016-03-02T05:39:18Z,runtime/plugin/rplugin.vim,"@@ -1,5 +1,16 @@-if exists('g:loaded_remote_plugins') || &cp+if exists('g:loaded_remote_plugins')   finish endif let g:loaded_remote_plugins = 1-call remote#host#LoadRemotePlugins()++command! UpdateRemotePlugins call remote#command#UpdateRemotePlugins()++augroup neovim-rplugin","`nvim` instead of `neovim`. We never user ""neovim"" in technical identifiers. ",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4403,54958991,2016-03-03T22:23:30Z,src/nvim/os/stdpaths.c,"@@ -66,12 +66,23 @@ char *stdpaths_get_xdg_var(const XDGVarType idx) /// @param[in]  idx  XDG directory to use. /// /// @return [allocated] `{xdg_directory}/nvim`+///+/// In WIN32 get_xdg_home(kXDGDataHome) returns `{xdg_directory}/nvim-data` to+/// avoid storing configuration and data files in the same path. static char *get_xdg_home(const XDGVarType idx)   FUNC_ATTR_WARN_UNUSED_RESULT {   char *dir = stdpaths_get_xdg_var(idx);   if (dir) {+#if defined(WIN32)+    if (idx == kXDGDataHome) {+      dir = concat_fnames_realloc(dir, ""nvim-data"", true);+    } else {+      dir = concat_fnames_realloc(dir, ""nvim"", true);+    }","ternary would avoid the extra indentation, etc.``` c    dir = concat_fnames_realloc(dir, (idx == kXDGDataHome ? ""nvim-data"" : ""nvim""),                                 true);```alternative:``` c        dir = concat_fnames_realloc(dir, ""nvim"", true);    #if defined(WIN32)        if (idx == kXDGDataHome) {          dir = concat_fnames_realloc(dir, ""nvim-data"", true);        }    #endif```",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4384,54989658,2016-03-04T04:42:59Z,runtime/plugin/rplugin.vim,"@@ -1,5 +1,16 @@-if exists('g:loaded_remote_plugins') || &cp+if exists('g:loaded_remote_plugins')   finish endif let g:loaded_remote_plugins = 1-call remote#host#LoadRemotePlugins()++command! UpdateRemotePlugins call remote#host#UpdateRemotePlugins()++augroup nvim-rplugin+  autocmd!+  autocmd FuncUndefined *+        \ call remote#host#LoadRemotePluginsEvent(+        \   'FuncUndefined', expand('<amatch>'))+  autocmd CmdUndefined *+        \ call remote#host#LoadRemotePluginsEvent(+        \   'FuncUndefined', expand('<amatch>'))","It listens to `CmdUndefined`, but sends `'FuncUndefined'`. What's this needed for?",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4389,55067311,2016-03-04T18:22:19Z,cmake/GetCompileFlags.cmake,"@@ -10,9 +10,12 @@ function(get_compile_flags _compile_flags)     ""${compile_flags}"")    # Get flags set by add_definition().-  get_directory_property(definitions+  get_directory_property(definition_list     DIRECTORY ""src/nvim""-    DEFINITIONS)+    COMPILE_DEFINITIONS)+  foreach(def ${definition_list})+    set(definitions ""${definitions} -D${def}"")+  endforeach()","Instead of this, can the code below be changed to use `definition_list` ?",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,55139542,2016-03-06T13:55:55Z,src/nvim/eval/decode.c,"@@ -0,0 +1,945 @@+#include <stddef.h>++#include <msgpack.h>++#include ""nvim/eval_defs.h""+#include ""nvim/eval.h""+#include ""nvim/eval/encode.h""+#include ""nvim/ascii.h""+#include ""nvim/message.h""+#include ""nvim/charset.h""  // vim_str2nr+#include ""nvim/lib/kvec.h""+#include ""nvim/vim.h""  // OK, FAIL++/// Helper structure for container_struct+typedef struct {+  size_t stack_index;   ///< Index of current container in stack.+  list_T *special_val;  ///< _VAL key contents for special maps.+                        ///< When container is not a special dictionary it is+                        ///< NULL.+  const char *s;        ///< Location where container starts.+  typval_T container;   ///< Container. Either VAR_LIST, VAR_DICT or VAR_LIST+                        ///< which is _VAL from special dictionary.+} ContainerStackItem;++/// Helper structure for values struct+typedef struct {+  bool is_special_string;  ///< Indicates that current value is a special+                           ///< dictionary with string.+  bool didcomma;           ///< True if previous token was comma.+  bool didcolon;           ///< True if previous token was colon.+  typval_T val;            ///< Actual value.+} ValuesStackItem;++/// Vector containing values not yet saved in any container+typedef kvec_t(ValuesStackItem) ValuesStack;++/// Vector containing containers, each next container is located inside previous+typedef kvec_t(ContainerStackItem) ContainerStack;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/decode.c.generated.h""+#endif++/// Create special dictionary+///+/// @param[out]  rettv  Location where created dictionary will be saved.+/// @param[in]  type  Type of the dictionary.+/// @param[in]  val  Value associated with the _VAL key.+static inline void create_special_dict(typval_T *const rettv,+                                       const MessagePackType type,+                                       typval_T val)+  FUNC_ATTR_NONNULL_ALL+{+  dict_T *const dict = dict_alloc();+  dictitem_T *const type_di = dictitem_alloc((char_u *) ""_TYPE"");+  type_di->di_tv.v_type = VAR_LIST;+  type_di->di_tv.v_lock = 0;+  type_di->di_tv.vval.v_list = (list_T *) eval_msgpack_type_lists[type];+  type_di->di_tv.vval.v_list->lv_refcount++;+  dict_add(dict, type_di);+  dictitem_T *const val_di = dictitem_alloc((char_u *) ""_VAL"");+  val_di->di_tv = val;+  dict_add(dict, val_di);+  dict->dv_refcount++;+  *rettv = (typval_T) {+    .v_type = VAR_DICT,+    .v_lock = VAR_UNLOCKED,+    .vval = { .v_dict = dict },+  };+}++#define DICT_LEN(dict) (dict)->dv_hashtab.ht_used++/// Helper function used for working with stack vectors used by JSON decoder+///+/// @param[in]  obj  New object.+/// @param[out]  stack  Object stack.+/// @param[out]  container_stack  Container objects stack.+/// @param[in,out]  pp  Position in string which is currently being parsed. Used+///                     for error reporting and is also set when decoding is+///                     restarted due to the necessity of converting regular+///                     dictionary to a special map.+/// @param[out]  next_map_special  Is set to true when dictionary is converted+///                                to a special map, otherwise not touched.+/// @param[out]  didcomma  True if previous token was comma. Is set to recorded+///                        value when decoder is restarted, otherwise unused.+/// @param[out]  didcolon  True if previous token was colon. Is set to recorded+///                        value when decoder is restarted, otherwise unused.+///+/// @return OK in case of success, FAIL in case of error.+static inline int json_decoder_pop(ValuesStackItem obj,+                                   ValuesStack *const stack,+                                   ContainerStack *const container_stack,+                                   const char **const pp,+                                   bool *const next_map_special,+                                   bool *const didcomma,+                                   bool *const didcolon)+  FUNC_ATTR_NONNULL_ALL+{+  if (kv_size(*container_stack) == 0) {+    kv_push(ValuesStackItem, *stack, obj);+    return OK;+  }+  ContainerStackItem last_container = kv_last(*container_stack);+  const char *val_location = *pp;+  if (obj.val.v_type == last_container.container.v_type+      // vval.v_list and vval.v_dict should have the same size and offset+      && ((void *) obj.val.vval.v_list+          == (void *) last_container.container.vval.v_list)) {+    (void) kv_pop(*container_stack);+    val_location = last_container.s;+    last_container = kv_last(*container_stack);+  }+  if (last_container.container.v_type == VAR_LIST) {+    if (last_container.container.vval.v_list->lv_len != 0+        && !obj.didcomma) {+      EMSG2(_(""E474: Expected comma before list item: %s""), val_location);+      clear_tv(&obj.val);+      return FAIL;+    }+    assert(last_container.special_val == NULL);+    listitem_T *obj_li = listitem_alloc();+    obj_li->li_tv = obj.val;+    list_append(last_container.container.vval.v_list, obj_li);+  } else if (last_container.stack_index == kv_size(*stack) - 2) {+    if (!obj.didcolon) {+      EMSG2(_(""E474: Expected colon before dictionary value: %s""),+            val_location);+      clear_tv(&obj.val);+      return FAIL;+    }+    ValuesStackItem key = kv_pop(*stack);+    if (last_container.special_val == NULL) {+      // These cases should have already been handled.+      assert(!(key.is_special_string+               || key.val.vval.v_string == NULL+               || *key.val.vval.v_string == NUL));+      dictitem_T *obj_di = dictitem_alloc(key.val.vval.v_string);+      clear_tv(&key.val);+      if (dict_add(last_container.container.vval.v_dict, obj_di)+          == FAIL) {+        assert(false);+      }+      obj_di->di_tv = obj.val;+    } else {+      list_T *const kv_pair = list_alloc();+      list_append_list(last_container.special_val, kv_pair);+      listitem_T *const key_li = listitem_alloc();+      key_li->li_tv = key.val;+      list_append(kv_pair, key_li);+      listitem_T *const val_li = listitem_alloc();+      val_li->li_tv = obj.val;+      list_append(kv_pair, val_li);+    }+  } else {+    // Object with key only+    if (!obj.is_special_string && obj.val.v_type != VAR_STRING) {+      EMSG2(_(""E474: Expected string key: %s""), *pp);+      clear_tv(&obj.val);+      return FAIL;+    } else if (!obj.didcomma+               && (last_container.special_val == NULL+                   && (DICT_LEN(last_container.container.vval.v_dict) != 0))) {+      EMSG2(_(""E474: Expected comma before dictionary key: %s""), val_location);+      clear_tv(&obj.val);+      return FAIL;+    }+    // Handle empty key and key represented as special dictionary+    if (last_container.special_val == NULL+        && (obj.is_special_string+            || obj.val.vval.v_string == NULL+            || *obj.val.vval.v_string == NUL+            || dict_find(last_container.container.vval.v_dict,+                         obj.val.vval.v_string, -1))) {+      clear_tv(&obj.val);++      // Restart+      (void) kv_pop(*container_stack);+      ValuesStackItem last_container_val =+          kv_A(*stack, last_container.stack_index);+      while (kv_size(*stack) > last_container.stack_index) {+        clear_tv(&(kv_pop(*stack).val));+      }+      *pp = last_container.s;+      *didcomma = last_container_val.didcomma;+      *didcolon = last_container_val.didcolon;+      *next_map_special = true;+      return OK;+    }+    kv_push(ValuesStackItem, *stack, obj);+  }+  return OK;+}++#define OBJ(obj_tv, is_sp_string) \+  ((ValuesStackItem) { \+    .is_special_string = (is_sp_string), \+    .val = (obj_tv), \+    .didcomma = didcomma, \+    .didcolon = didcolon, \+  })+#define POP(obj_tv, is_sp_string) \+  do { \+    if (json_decoder_pop(OBJ(obj_tv, is_sp_string), &stack, &container_stack, \+                         &p, &next_map_special, &didcomma, &didcolon) \+        == FAIL) { \+      goto json_decode_string_fail; \+    } \+    if (next_map_special) { \+      goto json_decode_string_cycle_start; \+    } \+  } while (0)++/// Convert JSON string into VimL object+///+/// @param[in]  buf  String to convert. UTF-8 encoding is assumed.+/// @param[in]  len  Length of the string.+/// @param[out]  rettv  Location where to save results.+///+/// @return OK in case of success, FAIL otherwise.+int json_decode_string(const char *const buf, const size_t len,+                       typval_T *const rettv)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  vimconv_T conv = { .vc_type = CONV_NONE };+  convert_setup(&conv, (char_u *) ""utf-8"", p_enc);+  conv.vc_fail = true;+  int ret = OK;+  ValuesStack stack;+  kv_init(stack);+  ContainerStack container_stack;+  kv_init(container_stack);+  rettv->v_type = VAR_UNKNOWN;+  const char *const e = buf + len;+  bool didcomma = false;+  bool didcolon = false;+  bool next_map_special = false;+  const char *p = buf;+  for (; p < e; p++) {+json_decode_string_cycle_start:+    assert(*p == '{' || next_map_special == false);+    switch (*p) {+      case '}':+      case ']': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: No container to close: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (*p == '}' && last_container.container.v_type != VAR_DICT) {+          EMSG2(_(""E474: Closing list with figure brace: %s""), p);+          goto json_decode_string_fail;+        } else if (*p == ']' && last_container.container.v_type != VAR_LIST) {+          EMSG2(_(""E474: Closing dictionary with bracket: %s""), p);+          goto json_decode_string_fail;+        } else if (didcomma) {+          EMSG2(_(""E474: Trailing comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Expected value after colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.stack_index != kv_size(stack) - 1) {+          assert(last_container.stack_index < kv_size(stack) - 1);+          EMSG2(_(""E474: Expected value: %s""), p);+          goto json_decode_string_fail;+        }+        if (kv_size(stack) == 1) {+          p++;+          (void) kv_pop(container_stack);+          goto json_decode_string_after_cycle;+        } else {+          if (json_decoder_pop(kv_pop(stack), &stack, &container_stack, &p,+                               &next_map_special, &didcomma, &didcolon)+              == FAIL) {+            goto json_decode_string_fail;+          }+          assert(!next_map_special);+          break;+        }+      }+      case ',': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: Comma not inside container: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (didcomma) {+          EMSG2(_(""E474: Duplicate comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Comma after colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.container.v_type == VAR_DICT+                   && last_container.stack_index != kv_size(stack) - 1) {+          EMSG2(_(""E474: Using comma in place of colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.special_val == NULL+                   ? (last_container.container.v_type == VAR_DICT+                      ? (DICT_LEN(last_container.container.vval.v_dict) == 0)+                      : (last_container.container.vval.v_list->lv_len == 0))+                   : (last_container.special_val->lv_len == 0)) {+          EMSG2(_(""E474: Leading comma: %s""), p);+          goto json_decode_string_fail;+        }+        didcomma = true;+        continue;+      }+      case ':': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: Colon not inside container: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (last_container.container.v_type != VAR_DICT) {+          EMSG2(_(""E474: Using colon not in dictionary: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.stack_index != kv_size(stack) - 2) {+          EMSG2(_(""E474: Unexpected colon: %s""), p);+          goto json_decode_string_fail;+        } else if (didcomma) {+          EMSG2(_(""E474: Colon after comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Duplicate colon: %s""), p);+          goto json_decode_string_fail;+        }+        didcolon = true;+        continue;+      }+      case ' ':+      case TAB:+      case NL: {+        continue;+      }+      case 'n': {+        if (strncmp(p + 1, ""ull"", 3) != 0) {+          EMSG2(_(""E474: Expected null: %s""), p);+          goto json_decode_string_fail;+        }+        p += 3;+        POP(((typval_T) {+          .v_type = VAR_SPECIAL,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_special = kSpecialVarNull },+        }), false);+        break;+      }+      case 't': {+        if (strncmp(p + 1, ""rue"", 3) != 0) {+          EMSG2(_(""E474: Expected true: %s""), p);+          goto json_decode_string_fail;+        }+        p += 3;+        POP(((typval_T) {+          .v_type = VAR_SPECIAL,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_special = kSpecialVarTrue },+        }), false);+        break;+      }+      case 'f': {+        if (strncmp(p + 1, ""alse"", 4) != 0) {+          EMSG2(_(""E474: Expected false: %s""), p);+          goto json_decode_string_fail;+        }+        p += 4;+        POP(((typval_T) {+          .v_type = VAR_SPECIAL,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_special = kSpecialVarFalse },+        }), false);+        break;+      }+      case '""': {+        size_t len = 0;+        const char *const s = ++p;+        while (p < e && *p != '""') {+          if (*p == '\\') {+            p++;+            if (p == e) {+              EMSG2(_(""E474: Unfinished escape sequence: %s""), buf);+              goto json_decode_string_fail;+            }+            switch (*p) {+              case 'u': {+                if (p + 4 >= e) {+                  EMSG2(_(""E474: Unfinished unicode escape sequence: %s""), buf);+                  goto json_decode_string_fail;+                } else if (!ascii_isxdigit(p[1])+                           || !ascii_isxdigit(p[2])+                           || !ascii_isxdigit(p[3])+                           || !ascii_isxdigit(p[4])) {+                  EMSG2(_(""E474: Expected four hex digits after \\u: %s""),+                        p - 1);+                  goto json_decode_string_fail;+                }+                // One UTF-8 character below U+10000 can take up to 3 bytes,+                // above up to 6, but they are encoded using two \u escapes.+                len += 3;+                p += 5;+                break;+              }+              case '\\':+              case '/':+              case '""':+              case 't':+              case 'b':+              case 'n':+              case 'r':+              case 'f': {+                len++;+                p++;+                break;+              }+              default: {+                EMSG2(_(""E474: Unknown escape sequence: %s""), p - 1);+                goto json_decode_string_fail;+              }+            }+          } else {+            uint8_t p_byte = (uint8_t) *p;+            // unescaped = %x20-21 / %x23-5B / %x5D-10FFFF+            if (p_byte < 0x20) {+              EMSG2(_(""E474: ASCII control characters cannot be present ""+                      ""inside string: %s""), p);+              goto json_decode_string_fail;+            }+            const int ch = utf_ptr2char((char_u *) p);+            // All characters above U+007F are encoded using two or more bytes+            // and thus cannot possibly be equal to *p. But utf_ptr2char({0xFF,+            // 0}) will return 0xFF, even though 0xFF cannot start any UTF-8+            // code point at all.+            if (ch >= 0x80 && p_byte == ch) {","That is not always right: `U+00C3` has byte encoding `0xC3 0x83`, so with `p_byte == ch` we could detect an UTF-8 character as an encoding error.Also see here:https://github.com/neovim/neovim/blob/master/src/nvim/mbyte.c#L1199-L1204",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4423,55166293,2016-03-07T06:30:55Z,.ci/common/test.sh,"@@ -53,7 +53,10 @@ run_unittests() { }  run_functionaltests() {-  if ! ${MAKE_CMD} -C ""${BUILD_DIR}"" functionaltest; then+  if [ -z $FUNCTIONALTEST ]; then+    FUNCTIONALTEST=functionaltest","defaults should be set somewhere higher up the chain, e.g. `run_tests.sh`.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4083,55370838,2016-03-08T15:05:29Z,src/nvim/api/buffer.c,"@@ -170,20 +192,34 @@ void buffer_set_line_slice(Buffer buffer,                       ArrayOf(String) replacement,                       Error *err) {","This and the other functions that take `include_start`/`include_end` should be marked as deprecated. I guess doxygen has a marker for that, but also gcc/clang have an attribute... http://stackoverflow.com/a/12839666/152142",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4083,55371229,2016-03-08T15:08:16Z,src/nvim/api/buffer.c,"@@ -170,20 +192,34 @@ void buffer_set_line_slice(Buffer buffer,                       ArrayOf(String) replacement,                       Error *err) {+  if (start < 0) start -= 1;+  if (end < 0) end -= 1;",This and the other cases should use `normalize_index` or a new similar private function.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4409,55527770,2016-03-09T14:46:02Z,src/nvim/globals.h,"@@ -1039,6 +1039,10 @@ EXTERN int fill_vert INIT(= ' '); EXTERN int fill_fold INIT(= '-'); EXTERN int fill_diff INIT(= '-'); +// Set when doing something for completion that may call edit() recursively,+// which is not allowed. Also used to disable folding during completion+EXTERN int compl_busy INIT(= false);","can you move this under [compl_interrupted](https://github.com/nhooyr/neovim/blob/master/src/nvim/globals.h#L215), seems like that is where the compl-related variables live.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4438,55880183,2016-03-11T19:56:41Z,runtime/autoload/remote/host.vim,"@@ -162,9 +164,10 @@ function! s:RegistrationCommands(host) abort       call add(lines, ""      \\ "".string(spec)."","")     endfor     call add(lines, ""     \\ ])"")+    call add(registered, path)   endfor   echomsg printf(""remote/host: %s host registered plugins %s"",-        \ a:host, string(map(copy(paths), ""fnamemodify(v:val, ':t')"")))+        \ a:host, string(map(registered, ""fnamemodify(v:val, ':t')"")))","`map()` modifies list in-place. It is a good practice to not use `copy(list)` or `list[:]` _only_ when you need in-place modification in `:call` or when you need super optimization, not when it is harmless in the current state of code because it is only harmless in the _current_ state, not outside of `:call` because it is hard to mention side-effects otherwise and not when your goal is something other then making code that is called really often run a bit faster (I needed such optimizations only for a few thousand calls).",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4448,55960175,2016-03-14T06:32:16Z,src/nvim/tui/input.c,"@@ -282,27 +289,56 @@ static bool handle_focus_event(TermInput *input)  static bool handle_bracketed_paste(TermInput *input) {-  if (rbuffer_size(input->read_stream.buffer) > 5 &&-      (!rbuffer_cmp(input->read_stream.buffer, ""\x1b[200~"", 6) ||-       !rbuffer_cmp(input->read_stream.buffer, ""\x1b[201~"", 6))) {-    bool enable = *rbuffer_get(input->read_stream.buffer, 4) == '0';-    // Advance past the sequence-    rbuffer_consumed(input->read_stream.buffer, 6);-    if (input->paste_enabled == enable) {-      return true;+  RBuffer *rbuf = input->read_stream.buffer;+  if (rbuffer_size(rbuf) > 5+      && (!rbuffer_cmp(rbuf, ""\x1b[200~"", 6)+          || !rbuffer_cmp(rbuf, ""\x1b[201~"", 6))) {+    bool enable = *rbuffer_get(rbuf, 4) == '0';++    if (enable && input->paste_started) {+      // Received a bogus ""paste start"" after paste was already started.+      return false;+    }++    rbuffer_consumed(rbuf, 6);  // Advance past the sequence+    input->paste_started = enable;+    if (enable) {+      loop_schedule(&loop, event_create(1, apply_pastepre, 0));+    } else {+      enqueue_input(input, PASTEPOST_KEY, sizeof(PASTEPOST_KEY) - 1);","@tarruda / @oni-link, Wondering if you can help my understanding. `loop_schedule()` on the ""start paste"" case (line 306) works well, because it puts the event on the main queue before any input gets processed. But for the ""stop paste"" case, I had to enqueue this `PASTEPOST_KEY` in order to guarantee that all paste data was processed before queuing the `PastePost` event.  Do we currently have any better mechanism for placing an event at a precise location in the input stream (I'm guessing the answer is ""no"", hence why we still have these pseudokeys)? I also tried using a mutex, but that had problems and isn't really desirable anyways.I am wondering if it would be a good idea to provide some internal generic mechanism for placing `K_EVENT` in the input stream and associating it with a callback.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/4448,55980685,2016-03-14T10:31:55Z,src/nvim/tui/input.c,"@@ -233,9 +237,12 @@ static void tk_getkeys(TermInput *input, bool force)     }   } -  if (result != TERMKEY_RES_AGAIN || input->paste_enabled) {+  if (result != TERMKEY_RES_AGAIN /*|| input->paste_started */) {","No, but this probably isn't needed anymore(I don't think it is possible to have `result == TERMKEY_RES_AGAIN && input->paste_enabled` because `read_cb` will only push data up to the next `\x1b`(esc). I'm not sure why this is there, probably an oversight or leftover from previous code.",
842846,tarruda,https://api.github.com/repos/neovim/neovim/pulls/4448,55982470,2016-03-14T10:49:19Z,src/nvim/tui/input.c,"@@ -376,8 +412,8 @@ static void read_cb(Stream *stream, RBuffer *buf, size_t c, void *data,     }   } while (rbuffer_size(input->read_stream.buffer));   flush_input(input, true);-  // Make sure the next input escape sequence fits into the ring buffer-  // without wrap around, otherwise it could be misinterpreted.+  // CSI and K_SPECIAL are double-escaped later (input_enqueue).+  // Make sure they can fit into the ring buffer without wrap around.   rbuffer_reset(input->read_stream.buffer);","No, `input->read_stream.buffer` is only read by the loop above. There could be an multi-byte key sequence that is trimmed by the end of the buffer(wrapping around to the beginning), but `termkey_push_bytes` is not aware of that, so it could misinterpret the key. `rbuffer_reset` simply moves the data so it is all in contiguous memory.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4449,56021934,2016-03-14T15:46:15Z,runtime/ftplugin/man.vim,"@@ -1,37 +1,26 @@-"" Vim filetype plugin file-"" Language:	man-"" Maintainer:	SungHyun Nam <goweol@gmail.com>--if has('vim_starting') && &filetype !=# 'man'-  finish-endif--"" Only do this when not done yet for this buffer if exists('b:did_ftplugin')   finish endif let b:did_ftplugin = 1 -"" Ensure Vim is not recursively invoked (man-db does this)-"" when doing ctrl-[ on a man page reference.-if exists('$MANPAGER')-  let $MANPAGER = ''-endif--setlocal iskeyword+=\.,-,(,)--setlocal buftype=nofile noswapfile-setlocal nomodifiable readonly bufhidden=hide nobuflisted tabstop=8","Please restore this line. Avoid needless changes like this, it makes the diff bigger and harder to review.",
151598,noahfrederick,https://api.github.com/repos/neovim/neovim/pulls/4449,56025415,2016-03-14T16:07:00Z,runtime/autoload/man.vim,"@@ -1,137 +1,211 @@-let s:man_tag_depth = 0-let s:man_sect_arg = ''-let s:man_find_arg = '-w'--try-  if !has('win32') && $OSTYPE !~? 'cygwin\|linux' && system('uname -s') =~? 'SunOS' && system('uname -r') =~? '^5'-    let s:man_sect_arg = '-s'-    let s:man_find_arg = '-l'-  endif-catch /E145:/-  "" Ignore the error in restricted mode-endtry--"" Load man page {page} from {section}-""   call man#get_page([{section}, ]{page})-function man#get_page(...) abort-  let invoked_from_man = (&filetype ==# 'man')--  if a:0 == 0-    echoerr 'argument required'-    return-  elseif a:0 > 2-    echoerr 'too many arguments'+let s:man_cmd = 'man 2>/dev/null'+"" regex for valid extensions that manpages can have+let s:man_extensions = '[glx]z\|bz2\|lzma\|Z'+let s:man_tag_stack = []+function! man#get_page(bang, editcmd, ...) abort+  "" fpage is a string like 'printf(2)'+  if empty(a:000)+    let fpage = expand('<cWORD>')+    if empty(fpage)+      call s:error(""no WORD under cursor"")+      return+    endif+  elseif len(a:000) > 2+    call s:error('too many arguments')     return+  elseif len(a:000) == 1+    let fpage = a:000[0]+  else+    let fpage = a:000[1].'('.a:000[0].')'   endif",This block is harder to follow than what you replaced. Why the change from `a:0` to `len(a:000)`? Why not rely on `get()`? Restoring and updating the documentation of the function parameters above would be good.,
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1791,56084734,2016-03-14T22:06:36Z,src/nvim/os/fsnotification.c,"@@ -0,0 +1,248 @@+#include <stdbool.h>+#include <stdlib.h>+#include <assert.h>++#include <uv.h>++#include ""nvim/vim.h""+#include ""nvim/buffer.h""+#include ""nvim/lib/khash.h""+#include ""nvim/lib/klist.h""+#include ""nvim/fileio.h""+#include ""nvim/os/fs_defs.h""+#include ""nvim/os/fsnotification.h""+#include ""nvim/os/event.h""+++// Apparentely, the destruction mechanism is not very well implemented in klist.+// Proper resource handling will be done manually+#define _destroy(x)","I would actually suggest to move this to `klist.h`. I saw only a single other instance of `KLIST_INIT` in `loop.h` and it also uses `_noop`, so it is better to make both use `KLIST_INIT_NOFREE` to be placed in `klist.h`.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/1791,56085393,2016-03-14T22:12:23Z,src/nvim/os/fsnotification.c,"@@ -0,0 +1,248 @@+#include <stdbool.h>+#include <stdlib.h>+#include <assert.h>++#include <uv.h>++#include ""nvim/vim.h""+#include ""nvim/buffer.h""+#include ""nvim/lib/khash.h""+#include ""nvim/lib/klist.h""+#include ""nvim/fileio.h""+#include ""nvim/os/fs_defs.h""+#include ""nvim/os/fsnotification.h""+#include ""nvim/os/event.h""+++// Apparentely, the destruction mechanism is not very well implemented in klist.+// Proper resource handling will be done manually+#define _destroy(x)+KLIST_INIT(Watcher, Watcher, _destroy)+#undef _destroy++static klist_t(Watcher)* watchers_list = NULL;++KHASH_MAP_INIT_STR(EventTable, int)+khash_t(EventTable)* event_lookup = NULL;++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""os/fsnotification.c.generated.h""+#endif++typedef struct {+    buf_T* buffer;+    khiter_t lookup_iter;+    uv_fs_event_t* handle;+} EvtData;++static void check_callback(Event evt)+{+  EvtData* data = (EvtData*) evt.data;+  (void) buf_check_timestamp(data->buffer, false);++  if ((kh_value(event_lookup, data->lookup_iter) & UV_RENAME) &&+      os_file_exists(data->buffer->b_ffname)) {+    fsnotification_delete_buffer(data->buffer);+    fsnotification_add_buffer(data->buffer);+  }++  kh_value(event_lookup, data->lookup_iter) = 0;+  free(data);+}++static void fs_event_callback(uv_fs_event_t* handle,+                                    const char* filename,+                                    int events,+                                    int status)+{+  // we need to retrieve the full path for buflist_findname+  char path[1024];+  size_t size = 1023;+  uv_fs_event_getpath(handle, path, &size);+  path[++size] = '\0';++  khiter_t value = kh_get(EventTable, event_lookup, path);+  if (value == kh_end(event_lookup)+      || kh_value(event_lookup, value) == 0)+  {",This should be on the same line as `if` condition last parenthesis.,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/4449,56088356,2016-03-14T22:36:39Z,runtime/syntax/man.vim,"@@ -1,67 +1,34 @@-"" Vim syntax file-"" Language:	Man page-"" Maintainer:	SungHyun Nam <goweol@gmail.com>-"" Previous Maintainer:	Gautam H. Mudunuri <gmudunur@informatica.com>-"" Version Info:-"" Last Change:	2008 Sep 17--"" Additional highlighting by Johannes Tanzler <johannes.tanzler@aon.at>:-""	* manSubHeading-""	* manSynopsis (only for sections 2 and 3)--"" For version 5.x: Clear all syntax items-"" For version 6.x: Quit when a syntax file was already loaded-if version < 600-  syntax clear-elseif exists(""b:current_syntax"")+if exists(""b:current_syntax"")   finish endif -"" Get the CTRL-H syntax to handle backspaced text-if version >= 600-  runtime! syntax/ctrlh.vim-else-  source <sfile>:p:h/ctrlh.vim-endif","Its useless as far as I can tell. If you remove line 122 `execute ""silent! keepjumps %substitute,.\b,,g""` of `autoload/man.vim` you'll see what it does. Man outputs backspaced text but in order to display it properly, we need to remove all those backspaces. This syntax file highlights them, whereas the substitution removes them. Thus if the substitution removes them, there is no need for the syntax file to be highlighting them. No idea why it was there before, man used to be piped into `col -b` which does the same thing, but doesn't work with other languages.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4449,56089336,2016-03-14T22:45:24Z,runtime/plugin/man.vim,"@@ -1,6 +1,21 @@-if get(g:, 'loaded_man', 0)+if exists('g:loaded_man')   finish endif let g:loaded_man = 1 -command! -count=0 -nargs=+ Man call man#get_page(<count>, <f-args>)+if !exists(""g:find_man_window"")+  let g:find_man_window = 1+endif++if !exists('g:man_synopsis')+  let g:man_synopsis = 'SYNOPSIS'+endif++command! -bang -complete=customlist,man#Complete -nargs=* Man call+      \ man#get_page(<bang>0, 'edit', <f-args>)+command! -bang -complete=customlist,man#Complete -nargs=* Sman call+      \ man#get_page(<bang>0, 'split', <f-args>)+command! -bang -complete=customlist,man#Complete -nargs=* Vman call+      \ man#get_page(<bang>0, 'vsplit', <f-args>)+command! -bang -complete=customlist,man#Complete -nargs=* Tman call+      \ man#get_page(<bang>0, 'tabe', <f-args>)","Of all these commands only `:Man` is definitely needed. `:Sman` may be needed to avoid side-effects of running `:split` before `:Man` (AFAIK you will at least have a few *Win* autocommands with unexpected patterns), but others should be possible to emulate using modifiers like `:vertical` or `:tab`.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/4449,56091251,2016-03-14T23:03:53Z,runtime/ftplugin/man.vim,"@@ -1,37 +1,26 @@-"" Vim filetype plugin file-"" Language:	man-"" Maintainer:	SungHyun Nam <goweol@gmail.com>--if has('vim_starting') && &filetype !=# 'man'-  finish-endif--"" Only do this when not done yet for this buffer if exists('b:did_ftplugin')   finish endif let b:did_ftplugin = 1 -"" Ensure Vim is not recursively invoked (man-db does this)-"" when doing ctrl-[ on a man page reference.-if exists('$MANPAGER')-  let $MANPAGER = ''-endif--setlocal iskeyword+=\.,-,(,)--setlocal buftype=nofile noswapfile-setlocal nomodifiable readonly bufhidden=hide nobuflisted tabstop=8",@justinmk I find it much more readable the way I have it formatted as a nice list.,
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4449,56112528,2016-03-15T03:57:08Z,runtime/syntax/man.vim,"@@ -1,67 +1,39 @@-"" Vim syntax file-"" Language:	Man page-"" Maintainer:	SungHyun Nam <goweol@gmail.com>-"" Previous Maintainer:	Gautam H. Mudunuri <gmudunur@informatica.com>-"" Version Info:-"" Last Change:	2008 Sep 17--"" Additional highlighting by Johannes Tanzler <johannes.tanzler@aon.at>:-""	* manSubHeading-""	* manSynopsis (only for sections 2 and 3)--"" For version 5.x: Clear all syntax items-"" For version 6.x: Quit when a syntax file was already loaded-if version < 600-  syntax clear-elseif exists(""b:current_syntax"")+if exists(""b:current_syntax"")   finish endif -"" Get the CTRL-H syntax to handle backspaced text-if version >= 600-  runtime! syntax/ctrlh.vim-else-  source <sfile>:p:h/ctrlh.vim-endif--syn case ignore-syn match  manReference       ""\f\+([1-9][a-z]\=)""-syn match  manTitle	      ""^\f\+([0-9]\+[a-z]\=).*""-syn match  manSectionHeading  ""^[a-z][a-z ]*[a-z]$""-syn match  manSubHeading      ""^\s\{3\}[a-z][a-z ]*[a-z]$""-syn match  manOptionDesc      ""^\s*[+-][a-z0-9]\S*""-syn match  manLongOptionDesc  ""^\s*--[a-z0-9-]\S*""-"" syn match  manHistory		""^[a-z].*last change.*$""--if getline(1) =~ '^[a-zA-Z_]\+([23])'-  syntax include @cCode <sfile>:p:h/c.vim-  syn match manCFuncDefinition  display ""\<\h\w*\>\s*(""me=e-1 contained-  syn region manSynopsis start=""^SYNOPSIS""hs=s+8 end=""^\u\+\s*$""me=e-12 keepend contains=manSectionHeading,@cCode,manCFuncDefinition-endif---"" Define the default highlighting.-"" For version 5.7 and earlier: only when not done already-"" For version 5.8 and later: only when an item doesn't have highlighting yet-if version >= 508 || !exists(""did_man_syn_inits"")-  if version < 508-    let did_man_syn_inits = 1-    command -nargs=+ HiLink hi link <args>-  else-    command -nargs=+ HiLink hi def link <args>+syntax case  ignore+syntax match manReference       ""\f\+(\%([0-8][a-z]\=\|n\))""+syntax match manTitle           ""^\%1l\S\+\%((\%([0-8][a-z]\=\|n\))\)\=.*$""+syntax match manSubHeading      ""^\s\{3\}\%(\S.*\)\=\S$""+syntax match manOptionDesc      ""^\s\+[+-][a-z0-9]\S*""+syntax match manLongOptionDesc  ""^\s\+--[a-z0-9]\S*""+"" prevent manSectionHeading from matching last line+execute 'syntax match manSectionHeading  ""^\%(\%>1l\%<'.line('$').'l\)\%(\S.*\)\=\S$""'++highlight default link manTitle          Title+highlight default link manSectionHeading Statement+highlight default link manOptionDesc     Constant+highlight default link manLongOptionDesc Constant+highlight default link manReference      PreProc+highlight default link manSubHeading     Function++if getline(1) =~# '^\f\+([23][a-zA-Z]\=)'+  syntax include @cCode $VIMRUNTIME/syntax/c.vim+  "" skip first heading+  keepjumps call search('^\%(\S.*\)\=\S$')+  keepjumps call search('^\%(\S.*\)\=\S$')+  "" get second heading, aka the synopsis heading+  let s:l = escape(getline('.'), '\')+  "" why bsd...+  if s:l ==# 'LIBRARY'","I don't know what this is for. Can it wait in another PR? We need to keep the default plugins reliable and simple. I'd like to keep this PR focused on just fixing the major problems you noticed, in a cross-platform manner. New features like tab-complete which are a big win (without tons of code or bugs) are also welcome. But main objective is to address low-hanging fruit.",
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/4449,56112848,2016-03-15T04:03:51Z,runtime/syntax/man.vim,"@@ -1,67 +1,39 @@-"" Vim syntax file-"" Language:	Man page-"" Maintainer:	SungHyun Nam <goweol@gmail.com>-"" Previous Maintainer:	Gautam H. Mudunuri <gmudunur@informatica.com>-"" Version Info:-"" Last Change:	2008 Sep 17--"" Additional highlighting by Johannes Tanzler <johannes.tanzler@aon.at>:-""	* manSubHeading-""	* manSynopsis (only for sections 2 and 3)--"" For version 5.x: Clear all syntax items-"" For version 6.x: Quit when a syntax file was already loaded-if version < 600-  syntax clear-elseif exists(""b:current_syntax"")+if exists(""b:current_syntax"")   finish endif -"" Get the CTRL-H syntax to handle backspaced text-if version >= 600-  runtime! syntax/ctrlh.vim-else-  source <sfile>:p:h/ctrlh.vim-endif--syn case ignore-syn match  manReference       ""\f\+([1-9][a-z]\=)""-syn match  manTitle	      ""^\f\+([0-9]\+[a-z]\=).*""-syn match  manSectionHeading  ""^[a-z][a-z ]*[a-z]$""-syn match  manSubHeading      ""^\s\{3\}[a-z][a-z ]*[a-z]$""-syn match  manOptionDesc      ""^\s*[+-][a-z0-9]\S*""-syn match  manLongOptionDesc  ""^\s*--[a-z0-9-]\S*""-"" syn match  manHistory		""^[a-z].*last change.*$""--if getline(1) =~ '^[a-zA-Z_]\+([23])'-  syntax include @cCode <sfile>:p:h/c.vim-  syn match manCFuncDefinition  display ""\<\h\w*\>\s*(""me=e-1 contained-  syn region manSynopsis start=""^SYNOPSIS""hs=s+8 end=""^\u\+\s*$""me=e-12 keepend contains=manSectionHeading,@cCode,manCFuncDefinition-endif---"" Define the default highlighting.-"" For version 5.7 and earlier: only when not done already-"" For version 5.8 and later: only when an item doesn't have highlighting yet-if version >= 508 || !exists(""did_man_syn_inits"")-  if version < 508-    let did_man_syn_inits = 1-    command -nargs=+ HiLink hi link <args>-  else-    command -nargs=+ HiLink hi def link <args>+syntax case  ignore+syntax match manReference       ""\f\+(\%([0-8][a-z]\=\|n\))""+syntax match manTitle           ""^\%1l\S\+\%((\%([0-8][a-z]\=\|n\))\)\=.*$""+syntax match manSubHeading      ""^\s\{3\}\%(\S.*\)\=\S$""+syntax match manOptionDesc      ""^\s\+[+-][a-z0-9]\S*""+syntax match manLongOptionDesc  ""^\s\+--[a-z0-9]\S*""+"" prevent manSectionHeading from matching last line+execute 'syntax match manSectionHeading  ""^\%(\%>1l\%<'.line('$').'l\)\%(\S.*\)\=\S$""'++highlight default link manTitle          Title+highlight default link manSectionHeading Statement+highlight default link manOptionDesc     Constant+highlight default link manLongOptionDesc Constant+highlight default link manReference      PreProc+highlight default link manSubHeading     Function++if getline(1) =~# '^\f\+([23][a-zA-Z]\=)'+  syntax include @cCode $VIMRUNTIME/syntax/c.vim+  "" skip first heading+  keepjumps call search('^\%(\S.*\)\=\S$')+  keepjumps call search('^\%(\S.*\)\=\S$')+  "" get second heading, aka the synopsis heading+  let s:l = escape(getline('.'), '\')+  "" why bsd...+  if s:l ==# 'LIBRARY'","@justinmk for manpages with c code in them. e.g. https://www.freebsd.org/cgi/man.cgi?query=printf&apropos=0&sektion=3&manpath=FreeBSD+10.2-RELEASE&arch=default&format=htmlSee the synopsis section with the c code? The manpage plugin currently matches `SYNOPSIS` to start the c highlighting, except this obviously won't work in other languages. Thus above, I'm matching the second header in manpages of sections 2/3, which is usually `SYNOPSIS` but FreeBSD decided to make it `LIBRARY` and the third header `SYNOPSIS`.Above I've added a special case for FreeBSD but the second option is a user interface, a variable the user can use to define a regex for where the `SYNOPSIS` begins in their language.But its not a big issue, we can address it in a later P.R.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4449,56113339,2016-03-15T04:15:11Z,runtime/syntax/man.vim,"@@ -1,67 +1,39 @@-"" Vim syntax file-"" Language:	Man page-"" Maintainer:	SungHyun Nam <goweol@gmail.com>-"" Previous Maintainer:	Gautam H. Mudunuri <gmudunur@informatica.com>-"" Version Info:-"" Last Change:	2008 Sep 17--"" Additional highlighting by Johannes Tanzler <johannes.tanzler@aon.at>:-""	* manSubHeading-""	* manSynopsis (only for sections 2 and 3)--"" For version 5.x: Clear all syntax items-"" For version 6.x: Quit when a syntax file was already loaded-if version < 600-  syntax clear-elseif exists(""b:current_syntax"")+if exists(""b:current_syntax"")   finish endif -"" Get the CTRL-H syntax to handle backspaced text-if version >= 600-  runtime! syntax/ctrlh.vim-else-  source <sfile>:p:h/ctrlh.vim-endif--syn case ignore-syn match  manReference       ""\f\+([1-9][a-z]\=)""-syn match  manTitle	      ""^\f\+([0-9]\+[a-z]\=).*""-syn match  manSectionHeading  ""^[a-z][a-z ]*[a-z]$""-syn match  manSubHeading      ""^\s\{3\}[a-z][a-z ]*[a-z]$""-syn match  manOptionDesc      ""^\s*[+-][a-z0-9]\S*""-syn match  manLongOptionDesc  ""^\s*--[a-z0-9-]\S*""-"" syn match  manHistory		""^[a-z].*last change.*$""--if getline(1) =~ '^[a-zA-Z_]\+([23])'-  syntax include @cCode <sfile>:p:h/c.vim-  syn match manCFuncDefinition  display ""\<\h\w*\>\s*(""me=e-1 contained-  syn region manSynopsis start=""^SYNOPSIS""hs=s+8 end=""^\u\+\s*$""me=e-12 keepend contains=manSectionHeading,@cCode,manCFuncDefinition-endif---"" Define the default highlighting.-"" For version 5.7 and earlier: only when not done already-"" For version 5.8 and later: only when an item doesn't have highlighting yet-if version >= 508 || !exists(""did_man_syn_inits"")-  if version < 508-    let did_man_syn_inits = 1-    command -nargs=+ HiLink hi link <args>-  else-    command -nargs=+ HiLink hi def link <args>+syntax case  ignore+syntax match manReference       ""\f\+(\%([0-8][a-z]\=\|n\))""+syntax match manTitle           ""^\%1l\S\+\%((\%([0-8][a-z]\=\|n\))\)\=.*$""+syntax match manSubHeading      ""^\s\{3\}\%(\S.*\)\=\S$""+syntax match manOptionDesc      ""^\s\+[+-][a-z0-9]\S*""+syntax match manLongOptionDesc  ""^\s\+--[a-z0-9]\S*""+"" prevent manSectionHeading from matching last line+execute 'syntax match manSectionHeading  ""^\%(\%>1l\%<'.line('$').'l\)\%(\S.*\)\=\S$""'++highlight default link manTitle          Title+highlight default link manSectionHeading Statement+highlight default link manOptionDesc     Constant+highlight default link manLongOptionDesc Constant+highlight default link manReference      PreProc+highlight default link manSubHeading     Function++if getline(1) =~# '^\f\+([23][a-zA-Z]\=)'+  syntax include @cCode $VIMRUNTIME/syntax/c.vim+  "" skip first heading+  keepjumps call search('^\%(\S.*\)\=\S$')+  keepjumps call search('^\%(\S.*\)\=\S$')+  "" get second heading, aka the synopsis heading+  let s:l = escape(getline('.'), '\')+  "" why bsd...+  if s:l ==# 'LIBRARY'","Got it, thanks. The C highlighting seems to work well, in the current plugin (before this PR), on linux and OSX (which uses BSD manuals). As long as that doesn't regress, I suppose it wouldn't be bad to try to cover more cases... but separate PR would be best.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4448,56200559,2016-03-15T17:03:34Z,src/nvim/tui/input.c,"@@ -282,27 +283,45 @@ static bool handle_focus_event(TermInput *input)  static bool handle_bracketed_paste(TermInput *input) {-  if (rbuffer_size(input->read_stream.buffer) > 5 &&-      (!rbuffer_cmp(input->read_stream.buffer, ""\x1b[200~"", 6) ||-       !rbuffer_cmp(input->read_stream.buffer, ""\x1b[201~"", 6))) {-    bool enable = *rbuffer_get(input->read_stream.buffer, 4) == '0';-    // Advance past the sequence-    rbuffer_consumed(input->read_stream.buffer, 6);-    if (input->paste_enabled == enable) {+  RBuffer *rbuf = input->read_stream.buffer;++  if (rbuffer_size(rbuf) > 5+      && (!rbuffer_cmp(rbuf, ""\x1b[200~"", 6)+          || !rbuffer_cmp(rbuf, ""\x1b[201~"", 6))) {+    bool enable = *rbuffer_get(rbuf, 4) == '0';+    rbuffer_consumed(rbuf, 6);  // Advance past the sequence++    if (enable && input->paste_started) {+      // Bogus ""paste start""; forward it.+      enqueue_input(input, ""<C-v><Esc>200~"", sizeof(""<C-v><Esc>200~"") - 1);+      return true;+    } else if (!enable && !input->paste_started) {+      // Bogus ""paste stop""; ignore it.       return true;     }-    enqueue_input(input, PASTETOGGLE_KEY, sizeof(PASTETOGGLE_KEY) - 1);-    input->paste_enabled = enable;++    input->paste_started = enable;+    if (enable) {+      loop_schedule(&loop, event_create(1, apply_pastepre, 0));+    } else {+      flush_input(input, true);+      enqueue_input(input, PASTEPOST_KEY, sizeof(PASTEPOST_KEY) - 1);+    }     return true;   }   return false; } +static void apply_pastepre(void **argv)  // MAIN thread+{+  apply_autocmds(EVENT_PASTEPRE, NULL, NULL, false, curbuf);","When I asked about allowed I did not mean _technical_ reasons not to call `apply_autocmds`. I talked about architectural issues, even if you call `vim_doautocmd(STATIC_CSTR_AS_STRING(""PastePre""), STATIC_CSTR_AS_STRING("""") /* group */, STATIC_CSTR_AS_STRING("""") /* fname */, BOOLEAN_OBJ(false).data.boolean /* nomodeline */, &err)` (note I did not suggest using `vim_command` because I do not like the idea; also in any case every command functionality will eventually use API) this still needs to be in the main thread because here you are using a C function avoiding events dispatcher.",
221465,fmoralesc,https://api.github.com/repos/neovim/neovim/pulls/4446,56436076,2016-03-16T23:52:17Z,src/nvim/buffer.c,"@@ -143,10 +143,17 @@ open_buffer (    if (curbuf->b_ffname != NULL       ) {+    int old_msg_silent = msg_silent;+    if (shortmess(SHM_FILEINFO)) {+      msg_silent = 1;+    }+     retval = readfile(curbuf->b_ffname, curbuf->b_fname,-        (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,-        flags | READ_NEW);-    /* Help buffer is filtered. */+                      (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,+                      flags | READ_NEW);+    msg_silent = old_msg_silent;++    // Help buffer is filtered.     if (curbuf->b_help)",clint.py is complaining about the lack of braces in this conditional. :(,
10180857,nhooyr,https://api.github.com/repos/neovim/neovim/pulls/4449,56463676,2016-03-17T07:12:41Z,runtime/doc/filetype.txt,"@@ -512,30 +512,42 @@ Local mappings:  MAN							*ft-man-plugin* *:Man* -Displays a manual page in a nice way.  Also see the user manual-|find-manpage|.--To start using the "":Man"" command before any manual page was loaded, source-this script from your startup vimrc file: >--	runtime ftplugin/man.vim--Options:-'iskeyword'	the '.' character is added to be able to use CTRL-] on the-		manual page name.+View manpages from the comfort of vim. Features include syntax highlighting,+autocompletion, multilingual support, and manpage jumping.+Also see |find-manpage|.  Commands:-Man {name}	Display the manual page for {name} in a window.-Man {number} {name}-		Display the manual page for {name} in a section {number}.--Global mapping:-<Leader>K	Displays the manual page for the word under the cursor.+Man			Display the manual page for <cWORD> in a new tab.+Man {name}		Display the manual page for {name} in a new tab.+Man {sect} {name}	Same as above except specify the section.+Man {name}({sect})	Alternate syntax to above.","@justinmk Oh never mind, I was mistaken, it was fully intended. It lets you see which section the manpage is on. E.g. `:Nman print<TAB>` shows `:Nman printf(3)`. You know exactly which section you will be taken to. Its either like that or, it completes it like `:Nman 3 printf` which just looks weird when you have a long list of completions.",
322097,ZyX-I,https://api.github.com/repos/neovim/neovim/pulls/4131,56764902,2016-03-20T14:00:58Z,src/nvim/eval_defs.h,"@@ -16,39 +16,52 @@ typedef double float_T; typedef struct listvar_S list_T; typedef struct dictvar_S dict_T; -/*- * Structure to hold an internal variable without a name.- */+/// Special variable values+typedef enum {+  kSpecialVarFalse,  ///< v:false+  kSpecialVarTrue,   ///< v:true+  kSpecialVarNull,   ///< v:null+} SpecialVarValue;++/// Variable lock status for typval_T.v_lock+typedef enum {+  VAR_UNLOCKED = 0,  ///< Not locked.+  VAR_LOCKED,        ///< User lock, can be unlocked.+  VAR_FIXED,         ///< Locked forever.+} VarLockStatus;++/// VimL variable types, for use in typval_T.v_type+typedef enum {+  VAR_UNKNOWN = 0,  ///< Unknown (unspecified) value.+  VAR_NUMBER,       ///< Number, .v_number is used.+  VAR_STRING,       ///< String, .v_string is used.+  VAR_FUNC,         ///< Function referene, .v_string is used for function name.+  VAR_LIST,         ///< List, .v_list is used.+  VAR_DICT,         ///< Dictionary, .v_dict is used.+  VAR_FLOAT,        ///< Floating-point value, .v_float is used.+  VAR_SPECIAL,      ///< Special value (true, false, null, none), .v_special","20.03.2016, 16:22, ""oni-link"" notifications@github.com:In src/nvim/eval_defs.h:> +typedef enum {> -  VAR_UNLOCKED = 0,  ///< Not locked.> -  VAR_LOCKED,        ///< User lock, can be unlocked.> -  VAR_FIXED,         ///< Locked forever.>   +} VarLockStatus;>   +>   +/// VimL variable types, for use in typval_T.v_type>   +typedef enum {> -  VAR_UNKNOWN = 0,  ///< Unknown (unspecified) value.> -  VAR_NUMBER,       ///< Number, .v_number is used.> -  VAR_STRING,       ///< String, .v_string is used.> -  VAR_FUNC,         ///< Function referene, .v_string is used for function name.> -  VAR_LIST,         ///< List, .v_list is used.> -  VAR_DICT,         ///< Dictionary, .v_dict is used.> -  VAR_FLOAT,        ///< Floating-point value, .v_float is used.> -  VAR_SPECIAL,      ///< Special value (true, false, null, none), .v_special>   none does not seem to be a value of VAR_SPECIAL.��Fixed as a part of `eval: Remove v:none`.�����You are receiving this because you were mentioned.Reply to this email directly or view it on GitHub��",
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,56766859,2016-03-20T16:11:41Z,src/nvim/eval.c,"@@ -11558,6 +11570,529 @@ static void f_join(typval_T *argvars, typval_T *rettv)     rettv->vval.v_string = NULL; } +/// Helper function used for working with stack vectors used by JSON decoder+///+/// @param[in]  obj  New object.+/// @param[out]  stack  Object stack.+/// @param[out]  container_stack  Container objects stack.+/// @param[in]  p  Position in string which is currently being parsed.+///+/// @return OK in case of success, FAIL in case of error.+static inline int json_decoder_pop(typval_T obj, ValuesStack *const stack,+                                   ContainerStack *const container_stack,+                                   const char *const p)+  FUNC_ATTR_NONNULL_ALL+{+  if (kv_size(*container_stack) == 0) {+    kv_push(typval_T, *stack, obj);+    return OK;+  }+  ContainerStackItem last_container = kv_last(*container_stack);+  if (obj.v_type == last_container.container.v_type+      // vval.v_list and vval.v_dict should have the same size and offset+      && ((void *) obj.vval.v_list+          == (void *) last_container.container.vval.v_list)) {+    kv_pop(*container_stack);+    last_container = kv_last(*container_stack);+  }+  if (last_container.container.v_type == VAR_LIST) {+    listitem_T *obj_li = listitem_alloc();+    obj_li->li_tv = obj;+    list_append(last_container.container.vval.v_list, obj_li);+  } else if (last_container.stack_index == kv_size(*stack) - 2) {+    typval_T key = kv_pop(*stack);+    if (key.v_type != VAR_STRING) {+      assert(false);+    } else if (key.vval.v_string == NULL || *key.vval.v_string == NUL) {+      // TODO: fall back to special dict in case of empty key+      EMSG(_(""E474: Empty key""));+      clear_tv(&obj);+      return FAIL;+    }+    dictitem_T *obj_di = dictitem_alloc(key.vval.v_string);+    clear_tv(&key);+    if (dict_add(last_container.container.vval.v_dict, obj_di)+        == FAIL) {+      // TODO: fall back to special dict in case of duplicate keys+      EMSG(_(""E474: Duplicate key""));+      dictitem_free(obj_di);+      clear_tv(&obj);+      return FAIL;+    }+    obj_di->di_tv = obj;+  } else {+    // Object with key only+    if (obj.v_type != VAR_STRING) {+      EMSG2(_(""E474: Expected string key: %s""), p);+      clear_tv(&obj);+      return FAIL;+    }+    kv_push(typval_T, *stack, obj);+  }+  return OK;+}++/// Convert JSON string into VimL object+///+/// @param[in]  buf  String to convert. UTF-8 encoding is assumed.+/// @param[in]  len  Length of the string.+/// @param[out]  rettv  Location where to save results.+///+/// @return OK in case of success, FAIL otherwise.+static int json_decode_string(const char *const buf, const size_t len,+                              typval_T *rettv)+  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT+{+  vimconv_T conv;+  convert_setup(&conv, (char_u *) ""utf-8"", p_enc);+  conv.vc_fail = true;+  int ret = OK;+  ValuesStack stack;+  kv_init(stack);+  ContainerStack container_stack;+  kv_init(container_stack);+  rettv->v_type = VAR_UNKNOWN;+  const char *const e = buf + len;+  bool didcomma = false;+  bool didcolon = false;+#define POP(obj) \+  do { \+    if (json_decoder_pop(obj, &stack, &container_stack, p) == FAIL) { \+      goto json_decode_string_fail; \+    } \+  } while (0)+  const char *p = buf;+  for (; p < e; p++) {+    switch (*p) {+      case '}':+      case ']': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: No container to close: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (*p == '}' && last_container.container.v_type != VAR_DICT) {+          EMSG2(_(""E474: Closing list with figure brace: %s""), p);+          goto json_decode_string_fail;+        } else if (*p == ']' && last_container.container.v_type != VAR_LIST) {+          EMSG2(_(""E474: Closing dictionary with bracket: %s""), p);+          goto json_decode_string_fail;+        } else if (didcomma) {+          EMSG2(_(""E474: Trailing comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Expected value after colon: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.stack_index != kv_size(stack) - 1) {+          assert(last_container.stack_index < kv_size(stack) - 1);+          EMSG2(_(""E474: Expected value: %s""), p);+          goto json_decode_string_fail;+        }+        if (kv_size(stack) == 1) {+          p++;+          kv_pop(container_stack);+          goto json_decode_string_after_cycle;+        } else {+          typval_T obj = kv_pop(stack);+          POP(obj);+          break;+        }+      }+      case ',': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: Comma not inside container: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (didcomma) {+          EMSG2(_(""E474: Duplicate comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Comma after colon: %s""), p);+          goto json_decode_string_fail;+        } if (last_container.container.v_type == VAR_DICT+            && last_container.stack_index != kv_size(stack) - 1) {+          EMSG2(_(""E474: Using comma in place of colon: %s""), p);+          goto json_decode_string_fail;+        } else if ((last_container.container.v_type == VAR_DICT+                    && (last_container.container.vval.v_dict->dv_hashtab.ht_used+                        == 0))+                   || (last_container.container.v_type == VAR_LIST+                       && last_container.container.vval.v_list->lv_len == 0)) {+          EMSG2(_(""E474: Leading comma: %s""), p);+          goto json_decode_string_fail;+        }+        didcomma = true;+        continue;+      }+      case ':': {+        if (kv_size(container_stack) == 0) {+          EMSG2(_(""E474: Colon not inside container: %s""), p);+          goto json_decode_string_fail;+        }+        ContainerStackItem last_container = kv_last(container_stack);+        if (last_container.container.v_type != VAR_DICT) {+          EMSG2(_(""E474: Using colon not in dictionary: %s""), p);+          goto json_decode_string_fail;+        } else if (last_container.stack_index != kv_size(stack) - 2) {+          EMSG2(_(""E474: Unexpected colon: %s""), p);+          goto json_decode_string_fail;+        } else if (didcomma) {+          EMSG2(_(""E474: Colon after comma: %s""), p);+          goto json_decode_string_fail;+        } else if (didcolon) {+          EMSG2(_(""E474: Duplicate colon: %s""), p);+          goto json_decode_string_fail;+        }+        didcolon = true;+        continue;+      }+      case ' ':+      case TAB:+      case NL: {+        continue;+      }+      case 'n': {+        if (strncmp(p + 1, ""ull"", 3) != 0) {+          EMSG2(_(""E474: Expected null: %s""), p);+          goto json_decode_string_fail;+        }+        p += 3;+        POP(vimvars[VV_NULL].vv_di.di_tv);+        break;+      }+      case 't': {+        if (strncmp(p + 1, ""rue"", 3) != 0) {+          EMSG2(_(""E474: Expected true: %s""), p);+          goto json_decode_string_fail;+        }+        p += 3;+        POP(vimvars[VV_TRUE].vv_di.di_tv);+        break;+      }+      case 'f': {+        if (strncmp(p + 1, ""alse"", 4) != 0) {+          EMSG2(_(""E474: Expected false: %s""), p);+          goto json_decode_string_fail;+        }+        p += 4;+        POP(vimvars[VV_FALSE].vv_di.di_tv);+        break;+      }+      case '""': {+        size_t len = 0;+        const char *s;+        for (s = ++p; p < e && *p != '""'; p++) {+          if (*p == '\\') {+            p++;+            if (p == e) {+              EMSG2(_(""E474: Unfinished escape sequence: %s""), buf);+              goto json_decode_string_fail;+            }+            switch (*p) {+              case 'u': {+                if (p + 4 >= e) {+                  EMSG2(_(""E474: Unfinished unicode escape sequence: %s""), buf);+                  goto json_decode_string_fail;+                } else if (!ascii_isxdigit(p[1])+                           || !ascii_isxdigit(p[2])+                           || !ascii_isxdigit(p[3])+                           || !ascii_isxdigit(p[4])) {+                  EMSG2(_(""E474: Expected four hex digits after \\u: %s""),+                        p - 1);+                  goto json_decode_string_fail;+                }+                // One UTF-8 character below U+10000 can take up to 3 bytes+                len += 3;+                p += 4;+                break;+              }+              case '\\':+              case '/':+              case '""':+              case 't':+              case 'b':+              case 'n':+              case 'r':+              case 'f': {+                len++;+                break;+              }+              default: {+                EMSG2(_(""E474: Unknown escape sequence: %s""), p - 1);+                goto json_decode_string_fail;+              }+            }+          } else {+            len++;+          }+        }+        if (*p != '""') {+          EMSG2(_(""E474: Expected string end: %s""), buf);+          goto json_decode_string_fail;+        }+        char *str = xmalloc(len + 1);+        uint16_t fst_in_pair = 0;+        char *str_end = str;+        for (const char *t = s; t < p; t++) {+          if (t[0] != '\\' || t[1] != 'u') {+            if (fst_in_pair != 0) {+              str_end += utf_char2bytes((int) fst_in_pair, (char_u *) str_end);+              fst_in_pair = 0;+            }+          }+          if (*t == '\\') {+            t++;+            switch (*t) {+              case 'u': {+                char ubuf[] = { t[1], t[2], t[3], t[4], 0 };+                t += 4;+                unsigned long ch;+                vim_str2nr((char_u *) ubuf, NULL, NULL, 0, 0, 2, NULL, &ch);+                if (0xD800UL <= ch && ch <= 0xDB7FUL) {+                  fst_in_pair = (uint16_t) ch;+                } else if (0xDC00ULL <= ch && ch <= 0xDB7FUL) {+                  if (fst_in_pair != 0) {+                    int full_char = (+                        (int) (ch - 0xDC00UL)+                        + (((int) (fst_in_pair - 0xD800)) << 10)+                    );+                    str_end += utf_char2bytes(full_char, (char_u *) str_end);+                  }+                } else {+                  str_end += utf_char2bytes((int) ch, (char_u *) str_end);+                }+                break;+              }+              case '\\':+              case '/':+              case '""':+              case 't':+              case 'b':+              case 'n':+              case 'r':+              case 'f': {+                static const char escapes[] = {+                  ['\\'] = '\\',+                  ['/'] = '/',+                  ['""'] = '""',+                  ['t'] = TAB,+                  ['b'] = BS,+                  ['n'] = NL,+                  ['r'] = CAR,+                  ['f'] = FF,+                };+                *str_end++ = escapes[(int) *t];+                break;+              }+              default: {+                assert(false);+              }+            }+          } else {+            *str_end++ = *t;+          }+        }+        if (fst_in_pair != 0) {+          str_end += utf_char2bytes((int) fst_in_pair, (char_u *) str_end);+        }+        if (conv.vc_type != CONV_NONE) {+          size_t len = (str_end - str);+          char *const new_str = (char *) string_convert(&conv, (char_u *) str,+                                                        &len);+          if (new_str == NULL) {+            EMSG2(_(""E474: Failed to convert string \""%s\"" from UTF-8""), str);+            xfree(str);+            goto json_decode_string_fail;+          }+          xfree(str);+          str = new_str;+          str_end = new_str + len;+        }+        *str_end = NUL;+        // TODO: return special string in case of NUL bytes+        POP(((typval_T) {+          .v_type = VAR_STRING,+          .vval = { .v_string = (char_u *) str, },+        }));+        break;+      }+      case '-':+      case '0':+      case '1':+      case '2':+      case '3':+      case '4':+      case '5':+      case '6':+      case '7':+      case '8':+      case '9': {+        // a.bE[+-]exp+        const char *const s = p;+        const char *ints = NULL;+        const char *fracs = NULL;+        const char *exps = NULL;+        if (*p == '-') {+          p++;+        }+        ints = p;+        while (p < e && ascii_isdigit(*p)) {+          p++;+        }+        if (p < e && *p == '.') {+          p++;+          fracs = p;+          while (p < e && ascii_isdigit(*p)) {+            p++;+          }+          if (p < e && (*p == 'e' || *p == 'E')) {+            p++;+            if (p < e && (*p == '-' || *p == '+')) {+              p++;+            }+            exps = p;+            while (p < e && ascii_isdigit(*p)) {+              p++;+            }+          }+        }+        if (p == ints) {+          EMSG2(_(""E474: Missing number after minus sign: %s""), s);+          goto json_decode_string_fail;+        } else if (p == fracs) {+          EMSG2(_(""E474: Missing number after decimal dot: %s""), s);+          goto json_decode_string_fail;+        } else if (p == exps) {+          EMSG2(_(""E474: Missing exponent: %s""), s);+          goto json_decode_string_fail;+        }+        typval_T tv = {+          .v_type = VAR_NUMBER,+          .v_lock = VAR_UNLOCKED,+        };+        if (fracs) {+          // Convert floating-point number+          (void) string2float((char_u *) s, &tv.vval.v_float);+          tv.v_type = VAR_FLOAT;+        } else {+          // Convert integer+          long nr;+          vim_str2nr((char_u *) s, NULL, NULL, 0, 0, 0, &nr, NULL);+          tv.vval.v_number = (varnumber_T) nr;+        }+        POP(tv);+        p--;+        break;+      }+      case '[': {+        list_T *list = list_alloc();+        list->lv_refcount++;+        typval_T tv = {+          .v_type = VAR_LIST,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_list = list },+        };+        kv_push(ContainerStackItem, container_stack, ((ContainerStackItem) {+          .stack_index = kv_size(stack),+          .container = tv,+        }));+        kv_push(typval_T, stack, tv);+        break;+      }+      case '{': {+        dict_T *dict = dict_alloc();+        dict->dv_refcount++;+        typval_T tv = {+          .v_type = VAR_DICT,+          .v_lock = VAR_UNLOCKED,+          .vval = { .v_dict = dict },+        };+        kv_push(ContainerStackItem, container_stack, ((ContainerStackItem) {+          .stack_index = kv_size(stack),+          .container = tv,+        }));+        kv_push(typval_T, stack, tv);+        break;+      }+      default: {+        EMSG2(_(""E474: Unidentified byte: %s""), p);+        goto json_decode_string_fail;+      }+    }+    didcomma = false;+    didcolon = false;+    if (kv_size(container_stack) == 0) {+      p++;+      break;+    }+  }+#undef POP+json_decode_string_after_cycle:+  for (; p < e; p++) {+    switch (*p) {+      case NL:+      case ' ':+      case TAB: {+        break;+      }+      default: {+        EMSG2(_(""E474: Trailing characters: %s""), p);+        goto json_decode_string_fail;+      }+    }+  }+  if (kv_size(stack) > 1 || kv_size(container_stack)) {+    EMSG2(_(""E474: Unexpected end of input: %s""), buf);+    goto json_decode_string_fail;+  }+  goto json_decode_string_ret;+json_decode_string_fail:+  ret = FAIL;+  while (kv_size(stack)) {+    clear_tv(&kv_pop(stack));+  }+json_decode_string_ret:+  if (ret != FAIL) {+    assert(kv_size(stack) == 1);+    *rettv = kv_pop(stack);+  }+  kv_destroy(stack);+  kv_destroy(container_stack);+  return ret;+}++/// jsondecode() function+static void f_jsondecode(typval_T *argvars, typval_T *rettv)+{+  char numbuf[NUMBUFLEN];+  char *s = NULL;+  char *tofree = NULL;+  size_t len;+  if (argvars[0].v_type == VAR_LIST) {+    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &len, &s)) {","For input `[]` and `['']`, `json_decode_string()` returns `0` (valid JSON?).If input is `['','']` it crashes with``` c==13267==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200016ffb1 at pc 0x0000004726fe bp 0x7fff35630590 sp 0x7fff3562fd40READ of size 2 at 0x60200016ffb1 thread T0    #0 0x4726fd in __interceptor_strlen /home/oni-link/git/llvm/projects/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:213    #1 0x1642a6c in vim_vsnprintf /home/oni-link/git/neovim/src/nvim/message.c:3240:25    #2 0x164bb7d in emsgf /home/oni-link/git/neovim/src/nvim/message.c:574:3    #3 0xeed7a0 in f_json_decode /home/oni-link/git/neovim/src/nvim/eval.c:11621:5    #4 0xe01cd3 in call_func /home/oni-link/git/neovim/src/nvim/eval.c:7242:11    #5 0xe15c74 in get_func_tv /home/oni-link/git/neovim/src/nvim/eval.c:7091:11    #6 0xe9e03c in eval7 /home/oni-link/git/neovim/src/nvim/eval.c:4229:15    #7 0xe99aa5 in eval6 /home/oni-link/git/neovim/src/nvim/eval.c:3950:7    #8 0xe96c29 in eval5 /home/oni-link/git/neovim/src/nvim/eval.c:3802:7    #9 0xe91e06 in eval4 /home/oni-link/git/neovim/src/nvim/eval.c:3545:7    #10 0xe91373 in eval3 /home/oni-link/git/neovim/src/nvim/eval.c:3465:7    #11 0xe90913 in eval2 /home/oni-link/git/neovim/src/nvim/eval.c:3402:7    #12 0xdfa7d2 in eval1 /home/oni-link/git/neovim/src/nvim/eval.c:3335:7    #13 0xe1599f in get_func_tv /home/oni-link/git/neovim/src/nvim/eval.c:7077:9    #14 0xe9e03c in eval7 /home/oni-link/git/neovim/src/nvim/eval.c:4229:15    #15 0xe99aa5 in eval6 /home/oni-link/git/neovim/src/nvim/eval.c:3950:7    #16 0xe96c29 in eval5 /home/oni-link/git/neovim/src/nvim/eval.c:3802:7    #17 0xe91e06 in eval4 /home/oni-link/git/neovim/src/nvim/eval.c:3545:7    #18 0xe91373 in eval3 /home/oni-link/git/neovim/src/nvim/eval.c:3465:7    #19 0xe90913 in eval2 /home/oni-link/git/neovim/src/nvim/eval.c:3402:7    #20 0xdfa7d2 in eval1 /home/oni-link/git/neovim/src/nvim/eval.c:3335:7    #21 0xe50e9e in ex_echo /home/oni-link/git/neovim/src/nvim/eval.c:18349:9    #22 0x135eef0 in do_one_cmd /home/oni-link/git/neovim/src/nvim/ex_docmd.c:2191:5    #23 0x133d74d in do_cmdline /home/oni-link/git/neovim/src/nvim/ex_docmd.c:601:20    #24 0x1010a5b in nv_colon /home/oni-link/git/neovim/src/nvim/normal.c:4485:18    #25 0xff7fb3 in normal_execute /home/oni-link/git/neovim/src/nvim/normal.c:1147:3    #26 0x125c920 in state_enter /home/oni-link/git/neovim/src/nvim/state.c:55:26    #27 0xfac4c0 in normal_enter /home/oni-link/git/neovim/src/nvim/normal.c:464:3    #28 0xf77c06 in main /home/oni-link/git/neovim/src/nvim/main.c:538:3    #29 0x7ff4ab3bd72f in __libc_start_main (/lib64/libc.so.6+0x2072f)    #30 0x444408 in _start (/home/oni-link/git/neovim/build/bin/nvim+0x444408)0x60200016ffb1 is located 0 bytes to the right of 1-byte region [0x60200016ffb0,0x60200016ffb1)allocated by thread T0 here:    #0 0x4e5088 in malloc /home/oni-link/git/llvm/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52    #1 0xaf6124 in try_malloc /home/oni-link/git/neovim/src/nvim/memory.c:59:15    #2 0xaf62e4 in xmalloc /home/oni-link/git/neovim/src/nvim/memory.c:93:15    #3 0x177e6c8 in encode_vim_list_to_buf /home/oni-link/git/neovim/src/nvim/eval/encode.c:220:21    #4 0xeed426 in f_json_decode /home/oni-link/git/neovim/src/nvim/eval.c:11605:10    #5 0xe01cd3 in call_func /home/oni-link/git/neovim/src/nvim/eval.c:7242:11    #6 0xe15c74 in get_func_tv /home/oni-link/git/neovim/src/nvim/eval.c:7091:11    #7 0xe9e03c in eval7 /home/oni-link/git/neovim/src/nvim/eval.c:4229:15    #8 0xe99aa5 in eval6 /home/oni-link/git/neovim/src/nvim/eval.c:3950:7    #9 0xe96c29 in eval5 /home/oni-link/git/neovim/src/nvim/eval.c:3802:7    #10 0xe91e06 in eval4 /home/oni-link/git/neovim/src/nvim/eval.c:3545:7    #11 0xe91373 in eval3 /home/oni-link/git/neovim/src/nvim/eval.c:3465:7    #12 0xe90913 in eval2 /home/oni-link/git/neovim/src/nvim/eval.c:3402:7    #13 0xdfa7d2 in eval1 /home/oni-link/git/neovim/src/nvim/eval.c:3335:7    #14 0xe1599f in get_func_tv /home/oni-link/git/neovim/src/nvim/eval.c:7077:9    #15 0xe9e03c in eval7 /home/oni-link/git/neovim/src/nvim/eval.c:4229:15    #16 0xe99aa5 in eval6 /home/oni-link/git/neovim/src/nvim/eval.c:3950:7    #17 0xe96c29 in eval5 /home/oni-link/git/neovim/src/nvim/eval.c:3802:7    #18 0xe91e06 in eval4 /home/oni-link/git/neovim/src/nvim/eval.c:3545:7    #19 0xe91373 in eval3 /home/oni-link/git/neovim/src/nvim/eval.c:3465:7    #20 0xe90913 in eval2 /home/oni-link/git/neovim/src/nvim/eval.c:3402:7    #21 0xdfa7d2 in eval1 /home/oni-link/git/neovim/src/nvim/eval.c:3335:7    #22 0xe50e9e in ex_echo /home/oni-link/git/neovim/src/nvim/eval.c:18349:9    #23 0x135eef0 in do_one_cmd /home/oni-link/git/neovim/src/nvim/ex_docmd.c:2191:5    #24 0x133d74d in do_cmdline /home/oni-link/git/neovim/src/nvim/ex_docmd.c:601:20    #25 0x1010a5b in nv_colon /home/oni-link/git/neovim/src/nvim/normal.c:4485:18    #26 0xff7fb3 in normal_execute /home/oni-link/git/neovim/src/nvim/normal.c:1147:3    #27 0x125c920 in state_enter /home/oni-link/git/neovim/src/nvim/state.c:55:26    #28 0xfac4c0 in normal_enter /home/oni-link/git/neovim/src/nvim/normal.c:464:3    #29 0xf77c06 in main /home/oni-link/git/neovim/src/nvim/main.c:538:3SUMMARY: AddressSanitizer: heap-buffer-overflow /home/oni-link/git/llvm/projects/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:213 in __interceptor_strlen```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4477,56799763,2016-03-21T10:01:26Z,src/nvim/charset.c,"@@ -82,7 +82,7 @@ int buf_init_chartab(buf_T *buf, int global) {   int c;   int c2;-  char_u *p;+  unsigned char *p;",I suppose that eventually: all public functions in charset will take `char *` arguments. These will be converted to `uint_8 *`internally in functions doing unsigned operations. But this will be a larger refactor that requires changing all call sites. Leaving it `char_u *` is fine for this PR.,
1690608,phanimahesh,https://api.github.com/repos/neovim/neovim/pulls/4477,57331277,2016-03-24T15:08:24Z,src/nvim/charset.c,"@@ -84,13 +84,13 @@ int buf_init_chartab(buf_T *buf, int global)   int c2;",You changed the parameter `global` to boolean on line 72. Also change this definition to match.,
5625989,cjoach,https://api.github.com/repos/neovim/neovim/pulls/4477,57507144,2016-03-26T01:54:30Z,src/nvim/charset.c,"@@ -734,7 +734,7 @@ int vim_strnsize(char_u *s, int len) /// @return Number of characters. #define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \   if (*(p) == TAB && (!(wp)->w_p_list || lcs_tab1)) { \-    int ts; \+    long int ts; \",it is not a good idea to add `long` as per style guide.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,57519375,2016-03-26T20:52:27Z,src/nvim/fileio.c,"@@ -4876,35 +4874,39 @@ buf_check_timestamp (    if (mesg != NULL) {     path = home_replace_save(buf, buf->b_fname);-    if (!helpmesg)+    if (!helpmesg) {       mesg2 = """";-    tbuf = xmalloc(STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2);-    sprintf((char *)tbuf, mesg, path);-    /* Set warningmsg here, before the unimportant and output-specific-     * mesg2 has been appended. */+    }+    const size_t tbuf_len = STRLEN(path) + STRLEN(mesg) + STRLEN(mesg2) + 2;+    char *const tbuf = xmalloc(tbuf_len);+    snprintf(tbuf, tbuf_len, mesg, path);+    // Set warningmsg here, before the unimportant and output-specific+    // mesg2 has been appended.     set_vim_var_string(VV_WARNINGMSG, tbuf, -1);     if (can_reload) {       if (*mesg2 != NUL) {-        STRCAT(tbuf, ""\n"");-        STRCAT(tbuf, mesg2);+        strncat(tbuf, ""\n"", tbuf_len);","That looks like a wrong use of the length argument of `strncat`.  (`tbuf_len` was previously computed big enough with ""some"" strings in mind, so it should work none the less.)We use at most `tbuf_len` bytes from `src`, but if `strlen(tbuf) > 0` we could write over the end of `tbuf`. ",
207795,felipecrv,https://api.github.com/repos/neovim/neovim/pulls/4486,57671084,2016-03-29T04:34:38Z,src/nvim/memfile.c,"@@ -525,82 +472,6 @@ static void mf_rem_used(memfile_T *mfp, bhdr_T *hp)     mfp->mf_used_first = hp->bh_next;   else     hp->bh_prev->bh_next = hp->bh_next;--  mfp->mf_used_count -= hp->bh_page_count;-  total_mem_used -= hp->bh_page_count * mfp->mf_page_size;-}--/// Try to release the least recently used block from the used list if the-/// number of used memory blocks gets too big.-///-/// @return  The block header, when release needed and possible.-///              Resulting block header includes memory block, so it can be-///              reused.  Page count is checked to be right.-///          NULL, when release not needed, or not possible.-///              Not needed when number of blocks less than allowed maximum and-///              total memory used below 'maxmemtot'.-///              Not possible when:-///              - Called while closing file.-///              - Tried to create swap file but couldn't.-///              - All blocks are locked.-///              - Unlocked dirty block found, but flush failed.-static bhdr_T *mf_release(memfile_T *mfp, unsigned page_count)-{-  // don't release while in mf_close_file()-  if (mf_dont_release)",Ha! Removing `mf_dont_release` is in my ideas list. I will add the change to this PR.,
2077655,oni-link,https://api.github.com/repos/neovim/neovim/pulls/4131,58308191,2016-04-03T10:37:31Z,src/nvim/eval/encode.c,"@@ -0,0 +1,1291 @@+/// @file encode.c+///+/// File containing functions for encoding and decoding VimL values.+///+/// Split out from eval.c.++#include <msgpack.h>+#include <inttypes.h>+#include <assert.h>+#include <math.h>++#include ""nvim/eval/encode.h""+#include ""nvim/buffer_defs.h""  // vimconv_T+#include ""nvim/eval.h""+#include ""nvim/eval_defs.h""+#include ""nvim/garray.h""+#include ""nvim/mbyte.h""+#include ""nvim/message.h""+#include ""nvim/memory.h""+#include ""nvim/charset.h""  // vim_isprintc()+#include ""nvim/macros.h""+#include ""nvim/ascii.h""+#include ""nvim/vim.h""  // For _()+#include ""nvim/lib/kvec.h""++#define ga_concat(a, b) ga_concat(a, (char_u *)b)+#define utf_ptr2char(b) utf_ptr2char((char_u *)b)+#define utf_ptr2len(b) ((size_t)utf_ptr2len((char_u *)b))+#define utf_char2len(b) ((size_t)utf_char2len(b))+#define string_convert(a, b, c) \+      ((char *)string_convert((vimconv_T *)a, (char_u *)b, c))+#define convert_setup(vcp, from, to) \+    (convert_setup(vcp, (char_u *)from, (char_u *)to))++/// Structure representing current VimL to messagepack conversion state+typedef struct {+  enum {+    kMPConvDict,   ///< Convert dict_T *dictionary.+    kMPConvList,   ///< Convert list_T *list.+    kMPConvPairs,  ///< Convert mapping represented as a list_T* of pairs.+  } type;+  union {+    struct {+      dict_T *dict;    ///< Currently converted dictionary.+      hashitem_T *hi;  ///< Currently converted dictionary item.+      size_t todo;     ///< Amount of items left to process.+    } d;  ///< State of dictionary conversion.+    struct {+      list_T *list;    ///< Currently converted list.+      listitem_T *li;  ///< Currently converted list item.+    } l;  ///< State of list or generic mapping conversion.+  } data;  ///< Data to convert.+} MPConvStackVal;++/// Stack used to convert VimL values to messagepack.+typedef kvec_t(MPConvStackVal) MPConvStack;++const char *const encode_special_var_names[] = {+  [kSpecialVarNull] = ""null"",+  [kSpecialVarTrue] = ""true"",+  [kSpecialVarFalse] = ""false"",+};++#ifdef INCLUDE_GENERATED_DECLARATIONS+# include ""eval/encode.c.generated.h""+#endif++/// Msgpack callback for writing to readfile()-style list+int encode_list_write(void *data, const char *buf, size_t len)+{+  if (len == 0) {+    return 0;+  }+  list_T *const list = (list_T *) data;+  const char *const end = buf + len;+  const char *line_end = buf;+  listitem_T *li = list->lv_last;+  do {+    const char *line_start = line_end;+    line_end = xmemscan(line_start, NL, (size_t) (end - line_start));+    char *str = NULL;+    if (line_end != line_start) {+      const size_t line_length = (size_t) (line_end - line_start);+      if (li == NULL) {+        str = xmemdupz(line_start, line_length);+      } else {+        const size_t li_len = (li->li_tv.vval.v_string == NULL+                               ? 0+                               : STRLEN(li->li_tv.vval.v_string));+        li->li_tv.vval.v_string = xrealloc(li->li_tv.vval.v_string,+                                           li_len + line_length + 1);+        str = (char *) li->li_tv.vval.v_string + li_len;+        memcpy(str, line_start, line_length);+        str[line_length] = 0;+      }+      memchrsub(str, NUL, NL, line_length);+    }+    if (li == NULL) {+      list_append_allocated_string(list, str);+    } else {+      li = NULL;+    }+    if (line_end == end - 1) {+      list_append_allocated_string(list, NULL);+    }","This block could be moved out of the loop. We also could simplify the loop, if we continue the initial last list element before the loop. All other list elements do not need to be continued.``` diffdiff --git a/src/nvim/eval/encode.c b/src/nvim/eval/encode.cindex 0bde656..5f898ec 100644--- a/src/nvim/eval/encode.c+++ b/src/nvim/eval/encode.c@@ -75,36 +75,38 @@ int encode_list_write(void *data, const char *buf, size_t len)   const char *const end = buf + len;   const char *line_end = buf;   listitem_T *li = list->lv_last;-  do {++  // Continue the last list element+  if (li != NULL) {+    line_end = xmemscan(buf, NL, len);+    if (line_end != buf) {+      const size_t line_length = (size_t)(line_end - buf);+      char *str = (char *)li->li_tv.vval.v_string;+      const size_t li_len = (str == NULL ? 0 : strlen(str));+      li->li_tv.vval.v_string = xrealloc(str, li_len + line_length + 1);+      str = (char *)li->li_tv.vval.v_string + li_len;+      memcpy(str, buf, line_length);+      str[line_length] = 0;+      memchrsub(str, NUL, NL, line_length);+    }+    line_end++;+  }++  while (line_end < end) {     const char *line_start = line_end;     line_end = xmemscan(line_start, NL, (size_t) (end - line_start));     char *str = NULL;     if (line_end != line_start) {-      const size_t line_length = (size_t) (line_end - line_start);-      if (li == NULL) {-        str = xmemdupz(line_start, line_length);-      } else {-        const size_t li_len = (li->li_tv.vval.v_string == NULL-                               ? 0-                               : STRLEN(li->li_tv.vval.v_string));-        li->li_tv.vval.v_string = xrealloc(li->li_tv.vval.v_string,-                                           li_len + line_length + 1);-        str = (char *) li->li_tv.vval.v_string + li_len;-        memcpy(str, line_start, line_length);-        str[line_length] = 0;-      }+      const size_t line_length = (size_t)(line_end - line_start);+      str = xmemdupz(line_start, line_length);       memchrsub(str, NUL, NL, line_length);     }-    if (li == NULL) {-      list_append_allocated_string(list, str);-    } else {-      li = NULL;-    }-    if (line_end == end - 1) {-      list_append_allocated_string(list, NULL);-    }+    list_append_allocated_string(list, str);     line_end++;-  } while (line_end < end);+  }+  if (line_end == end) {+    list_append_allocated_string(list, NULL);+  }   return 0; }```",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4477,58311624,2016-04-03T15:02:49Z,src/nvim/charset.c,"@@ -32,16 +32,16 @@ #endif  -static int chartab_initialized = FALSE;+static bool chartab_initialized = false;  // b_chartab[] is an array of 32 bytes, each bit representing one of the","still technically true, but maybe ""array with 256 bits"" is more informative.",
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4477,58311950,2016-04-03T15:32:53Z,src/nvim/charset.c,"@@ -734,7 +734,7 @@ int vim_strnsize(char_u *s, int len) /// @return Number of characters. #define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \   if (*(p) == TAB && (!(wp)->w_p_list || lcs_tab1)) { \-    int ts; \+    int64_t ts; \","`long`, or cast `ts = (int)(buf)->b_p_ts` . Also join this with the next line.",
1359421,justinmk,https://api.github.com/repos/neovim/neovim/pulls/4269,58315044,2016-04-03T18:29:25Z,src/nvim/buffer.c,"@@ -2062,16 +2063,17 @@ void buflist_setfpos(buf_T *const buf, win_T *const win, }  -/*- * Return true when ""wip"" has 'diff' set and the diff is only for another tab- * page.  That's because a diff is local to a tab page.- */+/// Check that ""wip"" has 'diff' set and the diff is only for another tab page.+/// That's because a diff is local to a tab page.+///+/// @param  wip  window information","The param type is wininfo_T, so the docstring is useless.",
6946102,Antoine-H,https://api.github.com/repos/neovim/neovim/pulls/4477,58316262,2016-04-03T19:41:05Z,src/nvim/charset.c,"@@ -734,7 +734,7 @@ int vim_strnsize(char_u *s, int len) /// @return Number of characters. #define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \   if (*(p) == TAB && (!(wp)->w_p_list || lcs_tab1)) { \-    int ts; \+    int64_t ts; \",I thought I wasn't supposed to use `long` type as written in the [style guide](https://neovim.io/develop/style-guide.xml?showone=Integer_Types#Integer_Types).I added the cast `ts = (int)(buf)->b_p_ts` :),
1363104,bfredl,https://api.github.com/repos/neovim/neovim/pulls/4477,58316320,2016-04-03T19:44:57Z,src/nvim/charset.c,"@@ -734,7 +734,7 @@ int vim_strnsize(char_u *s, int len) /// @return Number of characters. #define RET_WIN_BUF_CHARTABSIZE(wp, buf, p, col) \   if (*(p) == TAB && (!(wp)->w_p_list || lcs_tab1)) { \-    int ts; \+    int64_t ts; \","Well, it is a save of an `long` variable (and would be changed along with it, well, because -Wconversion :), used in an `int` context, so it should be one of those two. But you're right `(int)` is better :)",