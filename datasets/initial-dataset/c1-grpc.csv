user_id,user_login,pull_request_url,comment_id,created_at,path,diff_hunk,content,code_smell
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/11,22910654,2015-01-14T01:23:43Z,src/core/support/log_posix.c,"@@ -31,21 +31,27 @@  *  */ -#define _POSIX_SOURCE++#ifndef _POSIX_C_SOURCE+#define _POSIX_C_SOURCE 200112L+#endif+ #define _GNU_SOURCE #include <grpc/support/port_platform.h>  #if defined(GPR_POSIX_LOG) +#include <grpc/support/alloc.h> #include <grpc/support/log.h> #include <grpc/support/time.h> #include <stdio.h> #include <stdarg.h> #include <string.h>+#include <stdio.h> #include <time.h> #include <pthread.h> -static long gettid() { return pthread_self(); }+static long gettid() { return (long)(gpr_intptr)pthread_self(); }","We could return gpr_intptr instead of long, and use %tu as a format string later.",X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/22,22974915,2015-01-14T22:11:28Z,src/core/channel/http_client_filter.c,"@@ -130,6 +131,19 @@ static void destroy_call_elem(grpc_call_element *elem) {   ignore_unused(channeld); } +static char *scheme_from_args(const grpc_channel_args *args) {+  int i;+  if (args != NULL) {+    for (i = 0; i < args->num_args; ++i) {+      if (args->args[i].type == GRPC_ARG_STRING &&+          strcmp(args->args[i].key, ""grpc.scheme"") == 0) {","Maybe in http_filter.h then?A macro somewhere would be nice.On Wed Jan 14 2015 at 2:04:04 PM David Klempner notifications@github.comwrote:> In src/core/channel/http_client_filter.c> https://github.com/google/grpc/pull/22#discussion-diff-22974314:> > > @@ -130,6 +131,19 @@ static void destroy_call_elem(grpc_call_> > element *elem) {> > >    ignore_unused(channeld);> >  }> > > > +static char *scheme_from_args(const grpc_channel_args *args) {> > -  int i;> > -  if (args != NULL) {> > -    for (i = 0; i < args->num_args; ++i) {> > -      if (args->args[i].type == GRPC_ARG_STRING &&> > -          strcmp(args->args[i].key, ""grpc.scheme"") == 0) {> > The one issue I have with a macro in grpc.h is that this really shouldn't> be set publicly, and grpc.h is generally public-ish API.> > —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/22/files#r22974314.",X
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/77,23065082,2015-01-16T06:25:27Z,src/core/security/security_context.c,"@@ -411,9 +411,9 @@ grpc_security_status grpc_ssl_server_security_context_create(   c->base.vtable = &ssl_server_vtable;   result = tsi_create_ssl_server_handshaker_factory(       (const unsigned char **)&config->pem_private_key,-      (const gpr_uint32 *)&config->pem_private_key_size,+      (const size_t *)&config->pem_private_key_size,",These two casts ought to be useless: the variables are already of type size_t.,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/141,23280832,2015-01-21T06:43:10Z,include/grpc/grpc_security.h,"@@ -54,22 +54,26 @@ void grpc_credentials_release(grpc_credentials *creds); /* Creates default credentials. */ grpc_credentials *grpc_default_credentials_create(void); +/* Object that holds a private key / certificate chain pair in PEM format. */+typedef struct {+  /* private_key is the NULL-terminated string containing the PEM encoding of+     the client's private key. */+  const char *private_key;++   /* cert_chain is the NULL-terminated string containing the PEM encoding of","I guesssudo apt-get install clang-format-3.5but it is having issues, see pull request #104.On Tue, Jan 20, 2015 at 10:36 PM, jboeuf notifications@github.com wrote:> In include/grpc/grpc_security.h> https://github.com/google/grpc/pull/141#discussion_r23280669:> > > @@ -54,22 +54,26 @@ void grpc_credentials_release(grpc_credentials _creds);> >  /_ Creates default credentials. */> >  grpc_credentials *grpc_default_credentials_create(void);> > > > +/\* Object that holds a private key / certificate chain pair in PEM format. */> > +typedef struct {> > -  /\* private_key is the NULL-terminated string containing the PEM encoding of> > -     the client's private key. */> > -  const char *private_key;> >   +> > -   /\* cert_chain is the NULL-terminated string containing the PEM encoding of> > I get this when running grpc/tools/clang-format/clang-format-all.sh:> > ++ not hash clang-format-3.5> ++ dirname tools/clang-format/clang-format-all.sh> - cd tools/clang-format/../..> - for dir in src test include> - find src -name '_.c' -or -name '_.cc' -or -name '*.h'> - xargs clang-format-3.5 -i>   xargs: clang-format-3.5: No such file or directory> > What am I missing?> > —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/141/files#r23280669.",X
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/141,23281264,2015-01-21T07:02:04Z,include/grpc/grpc_security.h,"@@ -54,22 +54,26 @@ void grpc_credentials_release(grpc_credentials *creds); /* Creates default credentials. */ grpc_credentials *grpc_default_credentials_create(void); +/* Object that holds a private key / certificate chain pair in PEM format. */+typedef struct {+  /* private_key is the NULL-terminated string containing the PEM encoding of+     the client's private key. */+  const char *private_key;++   /* cert_chain is the NULL-terminated string containing the PEM encoding of","I think I found the reason and will fix it soon.On Tue, Jan 20, 2015 at 10:46 PM, jboeuf notifications@github.com wrote:> In include/grpc/grpc_security.h> https://github.com/google/grpc/pull/141#discussion_r23280914:> > > @@ -54,22 +54,26 @@ void grpc_credentials_release(grpc_credentials _creds);> >  /_ Creates default credentials. */> >  grpc_credentials *grpc_default_credentials_create(void);> > > > +/\* Object that holds a private key / certificate chain pair in PEM format. */> > +typedef struct {> > -  /\* private_key is the NULL-terminated string containing the PEM encoding of> > -     the client's private key. */> > -  const char *private_key;> >   +> > -   /\* cert_chain is the NULL-terminated string containing the PEM encoding of> > OK, I will not install anything until it's fixed then.> > —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/141/files#r23280914.",X
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/141,23326795,2015-01-21T19:31:15Z,src/node/credentials.cc,"@@ -136,33 +136,29 @@ NAN_METHOD(Credentials::CreateDefault) {  NAN_METHOD(Credentials::CreateSsl) {   NanScope();-  char *root_certs;-  char *private_key = NULL;-  char *cert_chain = NULL;-  int root_certs_length, private_key_length = 0, cert_chain_length = 0;-  if (!Buffer::HasInstance(args[0])) {+  char *root_certs = NULL;+  grpc_ssl_pem_key_cert_pair key_cert_pair = {NULL, NULL};+  if (Buffer::HasInstance(args[0])) {+    root_certs = Buffer::Data(args[0]);+  } else if (!(args[0]->IsNull() || args[0]->IsUndefined())) {","The roots parameter is not going to be mandatory very soon as we will accept default roots from the environment. With that in mind, are you ok with the change?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/158,23355980,2015-01-22T05:17:05Z,examples/tips/messages.proto,"@@ -0,0 +1,94 @@+// Message definitions to be used by integration test service definitions.",Why duplicate this file again?,X
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/158,23355993,2015-01-22T05:17:38Z,examples/tips/test.proto,"@@ -0,0 +1,42 @@+// An integration test service that covers all the method signature permutations",Why duplicate this file?,X
6642281,chen-wang,https://api.github.com/repos/grpc/grpc/pulls/158,23415732,2015-01-22T22:22:23Z,examples/tips/empty.proto,"@@ -0,0 +1,19 @@+syntax = ""proto2"";","This file is added by mistake. I played with GitHub with some experimental files, which are accidentally added to this commit. This file, together with test.proto, and server.cc are removed.",X
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23424728,2015-01-23T00:56:08Z,src/core/json/json-reader-impl.h,"@@ -0,0 +1,630 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* the following need to be pre-defined:+ *    grpc_json_static_inline      // A macro to declare a static inline+ *                                 // function+ *    grpc_json_eof                // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *    grpc_json_eagain             // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *    grpc_json_error              // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *+ *    // A macro or a function that clears your internal scratchpad.+ *    grpc_json_reader_string_clear(struct grpc_json_reader_t*);+ *    // A macro or a function that adds a character to your internal+ *    // scratchpad.+ *    grpc_json_reader_string_add_char(struct grpc_json_reader_t*, int);+ *    // A macro or a function that adds a unicode character to your internal+ *    // scratchpad.+ *    grpc_json_reader_string_add_wchar(struct grpc_json_reader_t*,+ *                                      grpc_json_wchar_t);+ *+ *    // A macro or a function that returns the next character from the input.+ *    // It can return:+ *    //  . an actual character into an int - unicode, wchar_t, whatever, as+ *    //    long as it's going to work in a switch statement, and can be tested+ *    //    against typical json tokens, such as '{', '[', ',', '}', ']', digits+ *    //    and whitespaces.+ *    //  . grpc_json_eof, which means the end of the input has been reached.+ *    //  . grpc_json_eagain, which means the parser needs to yield before+ *    //    getting more input.+ *    //  . grpc_json_error, which means the parser needs to exit with an error.+ *    int grpc_json_reader_read_char(struct grpc_json_reader_t*);+ *+ *    // A macro or a function that will be called to signal the beginning of a+ *    // container.+ *    // The argument ""type"" can be either GRPC_JSON_OBJECT, or GRPC_JSON_ARRAY.+ *    void grpc_json_reader_container_begins(struct grpc_json_reader_t*,+ *                                           enum *grpc_json_type_t type)+ *    // A macro or a function that will be called to signal the end of the+ *    // current container. It must return GRPC_JSON_OBJECT or GRPC_JSON_ARRAY+ *    // to signal what is the new current container, or GRPC_JSON_NONE if the+ *    // stack of containers is now empty.+ *    enum grpc_json_type_t+ *      grpc_json_reader_container_ends(struct grpc_json_reader_t*);+ *+ *    // A macro or a function that will be called to signal that json->string+ *    // contains the string of a object's key that is being added.+ *    void grpc_json_reader_object_set_key(struct grpc_json_reader_t*);+ *+ *    // A set of macro or functions that will be called to signal that the+ *    // current container is getting a new value. set_string and set_number+ *    // are reading their value from your internal scratchpad. set_number+ *    // must return a boolean to signal if the number parsing succeeded or+ *    // not. There is little reason for it not to.+ *    void grpc_json_reader_container_set_string(struct grpc_json_reader_t*);+ *    int grpc_json_reader_container_set_number(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_true(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_false(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_null(struct grpc_json_reader_t*);+ */++/* Call this function to initialize the reader structure. */+grpc_json_static_inline void grpc_json_reader_init(","The point here is that we can implement different readers for different inputs.The logic of the reader works independently of the actual input, and independently of the output objects. The json-string.c file makes use of it by implementing a parser using strings, but the same code can be included again to define a parser using file descriptors instead.This is very akin to https://github.com/nothings/stb",X
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23424839,2015-01-23T00:58:27Z,src/core/json/json-string.c,"@@ -0,0 +1,378 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/json/json.h""++/* This json-writer will put everything in a big string.+ * The point is that we allocate that string in chunks of 256 bytes.+ */+typedef struct {+  char *output;+  size_t free_space, string_len, allocated;+} grpc_json_writer_opaque_t;++#include ""src/core/json/json-writer-defs.h""++/* The json-reader will construct a bunch of grpc_json objects and+ * link them all up together in a tree-like structure that will represent+ * the json data in memory.+ *+ * It also uses its own input as a scratchpad to store all of the decoded,+ * unescaped strings. So we need to keep track of all these pointers in+ * that opaque structure the reader will carry for us.+ *+ * Note that this works because the act of parsing json always reduces its+ * input size, and never expands it.+ */+typedef struct {+  grpc_json *top;+  grpc_json *current_container;+  grpc_json *current_value;+  char *input;+  char *key;+  char *string;+  char *string_ptr;+  size_t remaining_input;+} grpc_json_reader_opaque_t;++typedef unsigned grpc_json_wchar_t;++#include ""src/core/json/json-reader-defs.h""++/* Next up, the definitions needed for the implementation. */+#define grpc_json_static_inline static+#define grpc_json_eof -1+#define grpc_json_eagain -2+#define grpc_json_error -3++/* This functions checks if there's enough space left in the output buffer,+ * and will enlarge it if necessary. We're only allocating chunks of 256+ * bytes at a time (or multiples thereof).+ */+static void grpc_json_writer_output_check(struct grpc_json_writer_t *writer,+                                          size_t needed) {+  if (writer->opaque.free_space >= needed) return;+  needed = (needed - writer->opaque.free_space + 0xff) & ~0xff;+  writer->opaque.output = (char *)gpr_realloc(+      writer->opaque.output, writer->opaque.allocated + needed);+  writer->opaque.free_space += needed;+  writer->opaque.allocated += needed;+}++/* These are needed by the writer's implementation. */+static void grpc_json_writer_output_char(struct grpc_json_writer_t *writer,+                                         char c) {+  grpc_json_writer_output_check(writer, 1);+  writer->opaque.output[writer->opaque.string_len++] = c;+  writer->opaque.free_space--;+}++static void grpc_json_writer_output_string_with_len(+    struct grpc_json_writer_t *writer, const char *str, size_t len) {+  grpc_json_writer_output_check(writer, len);+  memcpy(writer->opaque.output + writer->opaque.string_len, str, len);+  writer->opaque.string_len += len;+  writer->opaque.free_space -= len;+}++static void grpc_json_writer_output_string(struct grpc_json_writer_t *writer,+                                           const char *str) {+  size_t len = strlen(str);+  grpc_json_writer_output_string_with_len(writer, str, len);+}++#include ""src/core/json/json-writer-impl.h""","That's not how this system actually works. CF my other comment above.Defining a parser that works on file descriptors, say json_fd.c, would go through the same list of includes, with different base definitions, to explain the reader / writer how to read or emit data.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/40,23429358,2015-01-23T03:02:03Z,tools/buildgen/plugins/generate_vsprojects.py,"@@ -0,0 +1,38 @@+""""""Buildgen vsprojects plugin.++This parses the list of libraries, and generates globals ""vsprojects""+and ""vsproject_dict"", to be used by the visual studio generators.++""""""+++import re+++def mako_plugin(dictionary):+  """"""The exported plugin code for generate_vsprojeccts++  We want to help the work of the visual studio generators.++  """"""++  libs = dictionary.get('libs', [])+  targets = dictionary.get('targets', [])++  for lib in libs:+    lib['is_library'] = True+  for target in targets:+    target['is_library'] = False++  projects = []+  projects.extend(libs)+  projects.extend(targets)+  projects = [project for project in projects if project.get('vs_project_guid', None)]","On Thu, Jan 22, 2015 at 5:25 PM, Nicolas Noble notifications@github.comwrote:> In tools/buildgen/plugins/generate_vsprojects.py> https://github.com/google/grpc/pull/40#discussion_r23426008:> > > -  We want to help the work of the visual studio generators.> >   +> > -  """"""> >   +> > -  libs = dictionary.get('libs', [])> > -  targets = dictionary.get('targets', [])> >   +> > -  for lib in libs:> > -    lib['is_library'] = True> > -  for target in targets:> > -    target['is_library'] = False> >   +> > -  projects = []> > -  projects.extend(libs)> > -  projects.extend(targets)> > -  projects = [project for project in projects if project.get('vs_project_guid', None)]> > Figured it out actually. Tests don't have a guid because we don't want to> create a project file for them.Oh, yes that's the point. Sorry I didn't react to this right away.> —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/40/files#r23426008.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23431912,2015-01-23T04:55:24Z,src/core/json/json-string.c,"@@ -0,0 +1,378 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/json/json.h""++/* This json-writer will put everything in a big string.+ * The point is that we allocate that string in chunks of 256 bytes.+ */+typedef struct {+  char *output;+  size_t free_space, string_len, allocated;+} grpc_json_writer_opaque_t;++#include ""src/core/json/json-writer-defs.h""++/* The json-reader will construct a bunch of grpc_json objects and+ * link them all up together in a tree-like structure that will represent+ * the json data in memory.+ *+ * It also uses its own input as a scratchpad to store all of the decoded,+ * unescaped strings. So we need to keep track of all these pointers in+ * that opaque structure the reader will carry for us.+ *+ * Note that this works because the act of parsing json always reduces its+ * input size, and never expands it.+ */+typedef struct {+  grpc_json *top;+  grpc_json *current_container;+  grpc_json *current_value;+  char *input;+  char *key;+  char *string;+  char *string_ptr;+  size_t remaining_input;+} grpc_json_reader_opaque_t;++typedef unsigned grpc_json_wchar_t;++#include ""src/core/json/json-reader-defs.h""++/* Next up, the definitions needed for the implementation. */+#define grpc_json_static_inline static+#define grpc_json_eof -1+#define grpc_json_eagain -2+#define grpc_json_error -3++/* This functions checks if there's enough space left in the output buffer,+ * and will enlarge it if necessary. We're only allocating chunks of 256+ * bytes at a time (or multiples thereof).+ */+static void grpc_json_writer_output_check(struct grpc_json_writer_t *writer,+                                          size_t needed) {+  if (writer->opaque.free_space >= needed) return;+  needed = (needed - writer->opaque.free_space + 0xff) & ~0xff;+  writer->opaque.output = (char *)gpr_realloc(+      writer->opaque.output, writer->opaque.allocated + needed);+  writer->opaque.free_space += needed;+  writer->opaque.allocated += needed;+}++/* These are needed by the writer's implementation. */+static void grpc_json_writer_output_char(struct grpc_json_writer_t *writer,+                                         char c) {+  grpc_json_writer_output_check(writer, 1);+  writer->opaque.output[writer->opaque.string_len++] = c;+  writer->opaque.free_space--;+}++static void grpc_json_writer_output_string_with_len(+    struct grpc_json_writer_t *writer, const char *str, size_t len) {+  grpc_json_writer_output_check(writer, len);+  memcpy(writer->opaque.output + writer->opaque.string_len, str, len);+  writer->opaque.string_len += len;+  writer->opaque.free_space -= len;+}++static void grpc_json_writer_output_string(struct grpc_json_writer_t *writer,+                                           const char *str) {+  size_t len = strlen(str);+  grpc_json_writer_output_string_with_len(writer, str, len);+}++#include ""src/core/json/json-writer-impl.h""","Again, it's complexity we don't need, and it does seem to be leading to confusion.",X
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23435069,2015-01-23T07:23:46Z,src/core/json/json-reader-impl.h,"@@ -0,0 +1,630 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* the following need to be pre-defined:+ *    grpc_json_static_inline      // A macro to declare a static inline+ *                                 // function+ *    grpc_json_eof                // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *    grpc_json_eagain             // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *    grpc_json_error              // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *+ *    // A macro or a function that clears your internal scratchpad.+ *    grpc_json_reader_string_clear(struct grpc_json_reader_t*);+ *    // A macro or a function that adds a character to your internal+ *    // scratchpad.+ *    grpc_json_reader_string_add_char(struct grpc_json_reader_t*, int);+ *    // A macro or a function that adds a unicode character to your internal+ *    // scratchpad.+ *    grpc_json_reader_string_add_wchar(struct grpc_json_reader_t*,+ *                                      grpc_json_wchar_t);+ *+ *    // A macro or a function that returns the next character from the input.+ *    // It can return:+ *    //  . an actual character into an int - unicode, wchar_t, whatever, as+ *    //    long as it's going to work in a switch statement, and can be tested+ *    //    against typical json tokens, such as '{', '[', ',', '}', ']', digits+ *    //    and whitespaces.+ *    //  . grpc_json_eof, which means the end of the input has been reached.+ *    //  . grpc_json_eagain, which means the parser needs to yield before+ *    //    getting more input.+ *    //  . grpc_json_error, which means the parser needs to exit with an error.+ *    int grpc_json_reader_read_char(struct grpc_json_reader_t*);+ *+ *    // A macro or a function that will be called to signal the beginning of a+ *    // container.+ *    // The argument ""type"" can be either GRPC_JSON_OBJECT, or GRPC_JSON_ARRAY.+ *    void grpc_json_reader_container_begins(struct grpc_json_reader_t*,+ *                                           enum *grpc_json_type_t type)+ *    // A macro or a function that will be called to signal the end of the+ *    // current container. It must return GRPC_JSON_OBJECT or GRPC_JSON_ARRAY+ *    // to signal what is the new current container, or GRPC_JSON_NONE if the+ *    // stack of containers is now empty.+ *    enum grpc_json_type_t+ *      grpc_json_reader_container_ends(struct grpc_json_reader_t*);+ *+ *    // A macro or a function that will be called to signal that json->string+ *    // contains the string of a object's key that is being added.+ *    void grpc_json_reader_object_set_key(struct grpc_json_reader_t*);+ *+ *    // A set of macro or functions that will be called to signal that the+ *    // current container is getting a new value. set_string and set_number+ *    // are reading their value from your internal scratchpad. set_number+ *    // must return a boolean to signal if the number parsing succeeded or+ *    // not. There is little reason for it not to.+ *    void grpc_json_reader_container_set_string(struct grpc_json_reader_t*);+ *    int grpc_json_reader_container_set_number(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_true(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_false(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_null(struct grpc_json_reader_t*);+ */++/* Call this function to initialize the reader structure. */+grpc_json_static_inline void grpc_json_reader_init(","_shrug_ I'm not married to it.However, I'd like to mention that implementing a json parser based off socket reading is but the next logical step for that code.In fact, if the http decoder can be hinted that what's coming next is actual json, then there's a pretty obvious optimization that consists in trying to decode that json upfront, without wasting memory and CPU going into copying buffers around.It of course depends on how much we're considering json to be a crucial part of grpc. If this is limited to a few auth tokens every now and then, then sure, who cares. If, however, javascript becomes a more important part of the system, and can send json-encoded data over it, the gain wouldn't be negligible.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23437866,2015-01-23T08:51:51Z,src/core/json/json-reader-impl.h,"@@ -0,0 +1,630 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* the following need to be pre-defined:+ *    grpc_json_static_inline      // A macro to declare a static inline+ *                                 // function+ *    grpc_json_eof                // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *    grpc_json_eagain             // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *    grpc_json_error              // A macro that can be used in a switch+ *                                 // statement, that grpc_json_read_char+ *                                 // can return+ *+ *    // A macro or a function that clears your internal scratchpad.+ *    grpc_json_reader_string_clear(struct grpc_json_reader_t*);+ *    // A macro or a function that adds a character to your internal+ *    // scratchpad.+ *    grpc_json_reader_string_add_char(struct grpc_json_reader_t*, int);+ *    // A macro or a function that adds a unicode character to your internal+ *    // scratchpad.+ *    grpc_json_reader_string_add_wchar(struct grpc_json_reader_t*,+ *                                      grpc_json_wchar_t);+ *+ *    // A macro or a function that returns the next character from the input.+ *    // It can return:+ *    //  . an actual character into an int - unicode, wchar_t, whatever, as+ *    //    long as it's going to work in a switch statement, and can be tested+ *    //    against typical json tokens, such as '{', '[', ',', '}', ']', digits+ *    //    and whitespaces.+ *    //  . grpc_json_eof, which means the end of the input has been reached.+ *    //  . grpc_json_eagain, which means the parser needs to yield before+ *    //    getting more input.+ *    //  . grpc_json_error, which means the parser needs to exit with an error.+ *    int grpc_json_reader_read_char(struct grpc_json_reader_t*);+ *+ *    // A macro or a function that will be called to signal the beginning of a+ *    // container.+ *    // The argument ""type"" can be either GRPC_JSON_OBJECT, or GRPC_JSON_ARRAY.+ *    void grpc_json_reader_container_begins(struct grpc_json_reader_t*,+ *                                           enum *grpc_json_type_t type)+ *    // A macro or a function that will be called to signal the end of the+ *    // current container. It must return GRPC_JSON_OBJECT or GRPC_JSON_ARRAY+ *    // to signal what is the new current container, or GRPC_JSON_NONE if the+ *    // stack of containers is now empty.+ *    enum grpc_json_type_t+ *      grpc_json_reader_container_ends(struct grpc_json_reader_t*);+ *+ *    // A macro or a function that will be called to signal that json->string+ *    // contains the string of a object's key that is being added.+ *    void grpc_json_reader_object_set_key(struct grpc_json_reader_t*);+ *+ *    // A set of macro or functions that will be called to signal that the+ *    // current container is getting a new value. set_string and set_number+ *    // are reading their value from your internal scratchpad. set_number+ *    // must return a boolean to signal if the number parsing succeeded or+ *    // not. There is little reason for it not to.+ *    void grpc_json_reader_container_set_string(struct grpc_json_reader_t*);+ *    int grpc_json_reader_container_set_number(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_true(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_false(struct grpc_json_reader_t*);+ *    void grpc_json_reader_container_set_null(struct grpc_json_reader_t*);+ */++/* Call this function to initialize the reader structure. */+grpc_json_static_inline void grpc_json_reader_init(+    struct grpc_json_reader_t* reader) {+  reader->depth = 0;+  reader->in_object = 0;+  reader->in_array = 0;+  grpc_json_reader_string_clear(reader);+  reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+}++/* Call this function to start parsing the input. It will return the following:+ *    . GRPC_JSON_DONE if the input got eof, and the parsing finished+ *      successfully.+ *    . GRPC_JSON_EAGAIN if the read_char function returned again. Call the+ *      parser again as needed. It is okay to call the parser in polling mode,+ *      although a bit dull.+ *    . GRPC_JSON_READ_ERROR if the read_char function returned an error. The+ *      state isn't broken however, and the function can be called again if the+ *      error has been corrected. But please use the EAGAIN feature instead for+ *      consistency.+ *    . GRPC_JSON_PARSE_ERROR if the input was somehow invalid.+ *    . GRPC_JSON_INTERNAL_ERROR if the parser somehow ended into an invalid+ *      internal state.+ */++grpc_json_static_inline grpc_json_reader_ret_t+grpc_json_reader_run(struct grpc_json_reader_t* reader) {+  int c, success;++  /* This state-machine is a strict implementation of http://json.org/ */+  for (;;) {+    c = grpc_json_reader_read_char(reader);+    switch (c) {+      /* Let's process the error cases first. */+      case grpc_json_error:+        return GRPC_JSON_READ_ERROR;++      case grpc_json_eagain:+        return GRPC_JSON_EAGAIN;++      case grpc_json_eof:+        if ((reader->depth == 0) &&+            ((reader->state == GRPC_JSON_STATE_END) ||+             (reader->state == GRPC_JSON_STATE_VALUE_END))) {+          return GRPC_JSON_DONE;+        } else {+          return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* Processing whitespaces. */+      case ' ':+      case '\t':+      case '\n':+      case '\r':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+          case GRPC_JSON_STATE_OBJECT_KEY_END:+          case GRPC_JSON_STATE_VALUE_BEGIN:+          case GRPC_JSON_STATE_VALUE_END:+          case GRPC_JSON_STATE_END:+            break;++          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+          case GRPC_JSON_STATE_VALUE_STRING:+            grpc_json_reader_string_add_char(reader, c);+            break;++          case GRPC_JSON_STATE_VALUE_NUMBER:+          case GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL:+          case GRPC_JSON_STATE_VALUE_NUMBER_ZERO:+          case GRPC_JSON_STATE_VALUE_NUMBER_EPM:+            success = grpc_json_reader_container_set_number(reader);+            if (!success) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_clear(reader);+            reader->state = GRPC_JSON_STATE_VALUE_END;+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* Value, object or array terminations. */+      case ',':+      case '}':+      case ']':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+          case GRPC_JSON_STATE_VALUE_STRING:+            grpc_json_reader_string_add_char(reader, c);+            break;++          case GRPC_JSON_STATE_VALUE_NUMBER:+          case GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL:+          case GRPC_JSON_STATE_VALUE_NUMBER_ZERO:+          case GRPC_JSON_STATE_VALUE_NUMBER_EPM:+            success = grpc_json_reader_container_set_number(reader);+            if (!success) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_clear(reader);+            reader->state = GRPC_JSON_STATE_VALUE_END;+          /* The missing break here is intentional. */++          case GRPC_JSON_STATE_VALUE_END:+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+          case GRPC_JSON_STATE_VALUE_BEGIN:+            if (c == ',') {+              if (reader->state != GRPC_JSON_STATE_VALUE_END) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if (reader->in_object) {+                reader->state = GRPC_JSON_STATE_OBJECT_KEY_BEGIN;+              } else {+                reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+              }+            } else {+              if (reader->depth-- == 0) return GRPC_JSON_PARSE_ERROR;+              if ((c == '}') && !reader->in_object) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if ((c == '}') &&+                  (reader->state == GRPC_JSON_STATE_OBJECT_KEY_BEGIN) &&+                  !reader->container_just_begun) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if ((c == ']') && !reader->in_array) return GRPC_JSON_PARSE_ERROR;+              if ((c == ']') &&+                  (reader->state == GRPC_JSON_STATE_VALUE_BEGIN) &&+                  !reader->container_just_begun) {+                return GRPC_JSON_PARSE_ERROR;+              }+              reader->state = GRPC_JSON_STATE_VALUE_END;+              switch (grpc_json_reader_container_ends(reader)) {+                case GRPC_JSON_OBJECT:+                  reader->in_object = 1;+                  reader->in_array = 0;+                  break;+                case GRPC_JSON_ARRAY:+                  reader->in_object = 0;+                  reader->in_array = 1;+                  break;+                case GRPC_JSON_NONE:+                  if (reader->depth != 0) return GRPC_JSON_INTERNAL_ERROR;+                  reader->in_object = 0;+                  reader->in_array = 0;+                  reader->state = GRPC_JSON_STATE_END;+                  break;+                default:+                  return GRPC_JSON_INTERNAL_ERROR;+              }+            }+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* In-string escaping. */+      case '\\':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+            reader->escaped_string_was_key = 1;+            reader->state = GRPC_JSON_STATE_STRING_ESCAPE;+            break;++          case GRPC_JSON_STATE_VALUE_STRING:+            reader->escaped_string_was_key = 0;+            reader->state = GRPC_JSON_STATE_STRING_ESCAPE;+            break;++          /* This is the \\ case. */+          case GRPC_JSON_STATE_STRING_ESCAPE:+            grpc_json_reader_string_add_char(reader, '\\');+            if (reader->escaped_string_was_key) {+              reader->state = GRPC_JSON_STATE_OBJECT_KEY_STRING;+            } else {+              reader->state = GRPC_JSON_STATE_VALUE_STRING;+            }+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      default:+        reader->container_just_begun = 0;+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+            if (c != '""') return GRPC_JSON_PARSE_ERROR;+            reader->state = GRPC_JSON_STATE_OBJECT_KEY_STRING;+            break;++          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+            if (c == '""') {+              reader->state = GRPC_JSON_STATE_OBJECT_KEY_END;+              grpc_json_reader_object_set_key(reader);+              grpc_json_reader_string_clear(reader);+            } else {+              grpc_json_reader_string_add_char(reader, c);+            }+            break;++          case GRPC_JSON_STATE_VALUE_STRING:+            if (c == '""') {+              reader->state = GRPC_JSON_STATE_VALUE_END;+              grpc_json_reader_container_set_string(reader);+              grpc_json_reader_string_clear(reader);+            } else {+              grpc_json_reader_string_add_char(reader, c);+            }+            break;++          case GRPC_JSON_STATE_OBJECT_KEY_END:+            if (c != ':') return GRPC_JSON_PARSE_ERROR;+            reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+            break;++          case GRPC_JSON_STATE_VALUE_BEGIN:+            switch (c) {+              case 't':+                reader->state = GRPC_JSON_STATE_VALUE_TRUE_R;+                break;++              case 'f':+                reader->state = GRPC_JSON_STATE_VALUE_FALSE_A;+                break;++              case 'n':+                reader->state = GRPC_JSON_STATE_VALUE_NULL_U;+                break;++              case '""':+                reader->state = GRPC_JSON_STATE_VALUE_STRING;+                break;++              case '0':+                reader->state = GRPC_JSON_STATE_VALUE_NUMBER_ZERO;+                break;++              case '1':+              case '2':+              case '3':+              case '4':+              case '5':+              case '6':+              case '7':+              case '8':+              case '9':+              case '-':+                grpc_json_reader_string_add_char(reader, c);+                reader->state = GRPC_JSON_STATE_VALUE_NUMBER;+                break;++              case '{':+                reader->container_just_begun = 1;+                grpc_json_reader_container_begins(reader, GRPC_JSON_OBJECT);+                reader->depth++;+                reader->state = GRPC_JSON_STATE_OBJECT_KEY_BEGIN;+                reader->in_object = 1;+                reader->in_array = 0;+                break;++              case '[':+                reader->container_just_begun = 1;+                grpc_json_reader_container_begins(reader, GRPC_JSON_ARRAY);+                reader->depth++;+                reader->in_object = 0;+                reader->in_array = 1;+                break;+            }+            break;++          case GRPC_JSON_STATE_STRING_ESCAPE:+            if (reader->escaped_string_was_key) {+              reader->state = GRPC_JSON_STATE_OBJECT_KEY_STRING;+            } else {+              reader->state = GRPC_JSON_STATE_VALUE_STRING;+            }+            switch (c) {+              case '""':+              case '/':+                grpc_json_reader_string_add_char(reader, c);+                break;+              case 'b':+                grpc_json_reader_string_add_char(reader, '\b');+                break;+              case 'f':+                grpc_json_reader_string_add_char(reader, '\f');+                break;+              case 'n':+                grpc_json_reader_string_add_char(reader, '\n');+                break;+              case 'r':+                grpc_json_reader_string_add_char(reader, '\r');+                break;+              case 't':+                grpc_json_reader_string_add_char(reader, '\t');+                break;+              case 'u':+                reader->state = GRPC_JSON_STATE_STRING_ESCAPE_U1;+                reader->unicode = 0;+                break;+              default:+                return GRPC_JSON_PARSE_ERROR;+            }+            break;++          case GRPC_JSON_STATE_STRING_ESCAPE_U1:+          case GRPC_JSON_STATE_STRING_ESCAPE_U2:+          case GRPC_JSON_STATE_STRING_ESCAPE_U3:+          case GRPC_JSON_STATE_STRING_ESCAPE_U4:+            if ((c >= '0') && (c <= '9')) {+              c -= '0';+            } else if ((c >= 'A') && (c <= 'F')) {+              c -= 'A' - 10;+            } else if ((c >= 'a') && (c <= 'f')) {+              c -= 'a' - 10;+            } else {+              return GRPC_JSON_PARSE_ERROR;+            }+            reader->unicode <<= 4;+            reader->unicode |= c;++            switch (reader->state) {+              case GRPC_JSON_STATE_STRING_ESCAPE_U1:+                reader->state = GRPC_JSON_STATE_STRING_ESCAPE_U2;+                break;+              case GRPC_JSON_STATE_STRING_ESCAPE_U2:+                reader->state = GRPC_JSON_STATE_STRING_ESCAPE_U3;+                break;+              case GRPC_JSON_STATE_STRING_ESCAPE_U3:+                reader->state = GRPC_JSON_STATE_STRING_ESCAPE_U4;+                break;+              case GRPC_JSON_STATE_STRING_ESCAPE_U4:+                grpc_json_reader_string_add_wchar(reader, reader->unicode);","So for the record, that part here is basically wrong. What the http://json.org/ page doesn't specify (but the actual ECMA-404 spec does), is that \uxxxx is in fact a UTF-16 encoded unicode character, and not just a unicode value.This is important because there's more unicode characters than 0xffff values. So in order to get a value that is above 0xffff using UTF-16, one needs to use a surrogate pair.Basically, instead of calling directly into add_wchar, that code needs to convert the value to UTF-32 first. More specifically, it needs to:-) check if this is a valid UTF-16 character-) check if this is a UTF-16 high surrogateIf it's a high surrogate, it needs to proceed to a new state that'll read another UTF-16 character, and compose the actual UTF-32 uint32 value out of it, before passing it to add_wchar.And in that case, this isn't a wchar any longer, but an actual uint32 - wchars are supposed to be 16 bits minimum, which isn't a guarantee sufficient enough given these new constraints.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23440193,2015-01-23T09:47:09Z,src/core/json/json-writer-impl.h,"@@ -0,0 +1,233 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+++/* The idea of the writer is basically symmetrical of the reader. While the+ * reader emits various calls to your code, the writer takes basically the+ * same calls and emit json out of it. It doesn't try to make any check on+ * the order of the calls you do on it.+ *+ * Also, unlike the reader, the writer expects UTF-8 encoded input strings.+ *+ * The following need to be defined:+ *+ * // Adds a character to the output stream.+ * void grpc_json_writer_output_char(struct grpc_json_writer_t *, char);+ * // Adds a zero-terminated string to the output stream.+ * void grpc_json_writer_output_string(+ *   struct grpc_json_writer_t *writer, const char *str);+ * // Adds a fixed-length string to the output stream.+ * void grpc_json_writer_output_string_with_len(+ *   struct grpc_json_writer_t *writer, const char *str, size_t len);++ */++/* Call this function to initialize the writer structure. */+grpc_json_static_inline void grpc_json_writer_init(+    struct grpc_json_writer_t* writer, int indent) {+  writer->depth = 0;+  writer->container_empty = 1;+  writer->got_key = 0;+  writer->indent = indent;+}++/* This function is fully private. */+grpc_json_static_inline void grpc_json_writer_output_indent(+    struct grpc_json_writer_t* writer) {+  static const char spacesstr[] =+      ""                ""+      ""                ""+      ""                ""+      ""                "";++  int spaces = writer->depth * writer->indent;++  if (writer->got_key) {+    grpc_json_writer_output_char(writer, ' ');+    return;+  }++  while (spaces >= (sizeof(spacesstr) - 1)) {+    grpc_json_writer_output_string_with_len(writer, spacesstr,+                                            sizeof(spacesstr) - 1);+    spaces -= (sizeof(spacesstr) - 1);+  }++  if (!spaces) return;++  grpc_json_writer_output_string_with_len(+      writer, spacesstr + sizeof(spacesstr) - 1 - spaces, spaces);+}++/* This function is fully private. */+grpc_json_static_inline void grpc_json_writer_value_end(+    struct grpc_json_writer_t* writer) {+  if (writer->container_empty) {+    writer->container_empty = 0;+    if (!writer->indent || !writer->depth) return;+    grpc_json_writer_output_char(writer, '\n');+  } else {+    grpc_json_writer_output_char(writer, ',');+    if (!writer->indent) return;+    grpc_json_writer_output_char(writer, '\n');+  }+}++/* This function is fully private. */+grpc_json_static_inline void grpc_json_writer_escape_string(+    struct grpc_json_writer_t* writer, const char* string) {+  static const char hex[] = ""0123456789abcdef"";+  grpc_json_writer_output_char(writer, '""');++  for (;;) {+    unsigned char c = (unsigned char)*string++;+    if (!c) {+      break;+    } else if ((c >= 32) && (c <= 127)) {+      if ((c == '\\') || (c == '""')) grpc_json_writer_output_char(writer, '\\');+      grpc_json_writer_output_char(writer, c);+    } else if (c < 32) {+      grpc_json_writer_output_char(writer, '\\');+      switch (c) {+        case '\b':+          grpc_json_writer_output_char(writer, 'b');+          break;+        case '\f':+          grpc_json_writer_output_char(writer, 'f');+          break;+        case '\n':+          grpc_json_writer_output_char(writer, 'n');+          break;+        case '\r':+          grpc_json_writer_output_char(writer, 'r');+          break;+        case '\t':+          grpc_json_writer_output_char(writer, 't');+          break;+        default:+          grpc_json_writer_output_string_with_len(writer, ""u00"", 3);+          grpc_json_writer_output_char(writer, c >= 16 ? '1' : '0');+          grpc_json_writer_output_char(writer, hex[c & 15]);+          break;+      }+    } else {+      unsigned unicode = 0;+      if ((c & 0xe0) == 0xc0) {+        unicode = c & 0x1f;+        unicode <<= 6;+        c = *string++;+        if ((c & 0xc0) != 0x80) break;+        unicode |= c & 0x3f;+      } else if ((c & 0xf0) == 0xe0) {+        unicode = c & 0x0f;+        unicode <<= 6;+        c = *string++;+        if ((c & 0xc0) != 0x80) break;+        unicode |= c & 0x3f;+        unicode <<= 6;+        c = *string++;+        if ((c & 0xc0) != 0x80) break;+        unicode |= c & 0x3f;+      } else {+        break;+      }+      grpc_json_writer_output_string_with_len(writer, ""\\u"", 2);+      grpc_json_writer_output_char(writer, hex[(unicode >> 12) & 0x0f]);+      grpc_json_writer_output_char(writer, hex[(unicode >> 8) & 0x0f]);+      grpc_json_writer_output_char(writer, hex[(unicode >> 4) & 0x0f]);+      grpc_json_writer_output_char(writer, hex[(unicode) & 0x0f]);","Similar to the parser, that piece of code is wrong too. It has to convert from UTF-8 to UTF-32, then to UTF-16 by potentially emitting a surrogate pair to encode a codepoint that is too large.",x
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/179,23473210,2015-01-23T19:28:29Z,include/grpc/support/string.h,"@@ -60,6 +60,13 @@ char *gpr_hexdump(const char *buf, size_t len, gpr_uint32 flags); int gpr_parse_bytes_to_uint32(const char *data, size_t length,                               gpr_uint32 *result); +/* Convert a long to a string in base 10; returns the length of the+   output string (or 0 on failure) */+int gpr_ltoa(long value, char *output);",I would prefer to have a parameter with the size of the output so that we're not vulnerable to buffer overflows.,x
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/179,23477775,2015-01-23T20:27:20Z,include/grpc/support/string.h,"@@ -60,6 +60,13 @@ char *gpr_hexdump(const char *buf, size_t len, gpr_uint32 flags); int gpr_parse_bytes_to_uint32(const char *data, size_t length,                               gpr_uint32 *result); +/* Convert a long to a string in base 10; returns the length of the+   output string (or 0 on failure) */+int gpr_ltoa(long value, char *output);",This is slightly better but definitely not as safe as passing the length. I thought about it some more and I really think that the functions exposed in our runtime should meet a high standard (even if that means having to pass another parameter). I would not have as strong an opinion if this were a private function.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/179,23482900,2015-01-23T21:47:19Z,src/core/support/string.h,"@@ -60,6 +60,16 @@ char *gpr_hexdump(const char *buf, size_t len, gpr_uint32 flags); int gpr_parse_bytes_to_uint32(const char *data, size_t length,","It's another discussion: we have internal-only gpr_ headers that are used by grpc currently. We need to think about what we actually want to export from this library, whether it should really be free-standing, and you know, that stuff.Lets setup some time to chat next week, but not hold up this PR on it.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/188,23487306,2015-01-23T23:06:20Z,src/core/support/string.h,"@@ -81,6 +81,27 @@ void gpr_reverse_bytes(char *str, int len);    the result is undefined. */ int gpr_asprintf(char **strp, const char *format, ...); +/* Join a set of strings, returning the resulting string.+   Total combined length (excluding null terminator) is returned in total_length+   if it is non-null. */+char *gpr_strjoin(const char **strs, size_t nstrs, size_t *total_length);++/* A vector of strings... for building up a final string one piece at a time */+typedef struct {+  char **strs;","I started thinking about it, but if we're going down that route, wouldn't it make sense to try adding a gpr_string kind of type, that'll work similar to std::string in the sense it also keeps track of its own length ?It feels to me that gpr_strjoin in that code would benefit greatly from this.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/188,23491969,2015-01-24T01:14:31Z,src/core/support/string.c,"@@ -152,3 +152,49 @@ int gpr_ltoa(long value, char *string) {   string[i] = 0;   return i; }++char *gpr_strjoin(const char **strs, size_t nstrs, size_t *final_length) {+  size_t out_length = 0;+  size_t i;+  char *out;+  for (i = 0; i < nstrs; i++) {+    out_length += strlen(strs[i]);+  }+  out_length += 1;  /* null terminator */+  out = gpr_malloc(out_length);+  out_length = 0;+  for (i = 0; i < nstrs; i++) {+    size_t slen = strlen(strs[i]);","On lines 159 and 161, wouldn't we want to do something along the lines of:size_t *str_lengths = alloc(sizeof(size_t) \* nstrs);str_lengths[i] = strlen(strs[i])so that on line 167 we don't have to call strlen again ?That'd cap nstrs to a reasonable value though, since we'd now need some stack space to store these lengths.",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/188,23494636,2015-01-24T06:48:23Z,test/core/security/credentials_test.c,"@@ -498,10 +498,8 @@ static void validate_service_account_http_request(   char *expected_body = NULL;   GPR_ASSERT(body != NULL);   GPR_ASSERT(body_size != 0);-  expected_body = gpr_malloc(strlen(expected_service_account_http_body_prefix) +-                             strlen(test_signed_jwt) + 1);-  sprintf(expected_body, ""%s%s"", expected_service_account_http_body_prefix,-          test_signed_jwt);+  gpr_asprintf(&expected_body, ""%s%s"",+               expected_service_account_http_body_prefix, test_signed_jwt);","Maybe, but then we'd need to stack allocate the array and this would no longer be a 1:1 conversion of the old code. Can try something if you feel strongly.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/157,23577096,2015-01-27T00:15:36Z,src/core/iomgr/pollset_kick.h,"@@ -34,18 +34,22 @@ #ifndef __GRPC_INTERNAL_IOMGR_POLLSET_KICK_H_ #define __GRPC_INTERNAL_IOMGR_POLLSET_KICK_H_ -#include <grpc/support/port_platform.h>+#include ""src/core/iomgr/wakeup_fd.h""","Once renamed, this is a _posix dependency in a platform neutral header: we'll need to fix it, and bring back pollset_kick_posix.h, pollset_kick_windows.h.",x
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/227,23581771,2015-01-27T01:48:07Z,src/ruby/spec/client_server_spec.rb,"@@ -63,27 +64,30 @@ def expect_next_event_on(queue, type, tag)     ev   end -  def server_receives_and_responds_with(reply_text)-    reply = ByteBuffer.new(reply_text)+  def server_allows_client_to_proceed     @server.request_call(@server_tag)-    ev = @server_queue.pluck(@server_tag, TimeConsts::INFINITE_FUTURE)+    ev = @server_queue.pluck(@server_tag, deadline)",Why use `deadline` with `pluck` here? You don't seem to do it in other cases.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23587007,2015-01-27T04:46:57Z,src/core/json/json_reader.h,"@@ -0,0 +1,158 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef __GRPC_SRC_CORE_JSON_JSON_READER_H__+#define __GRPC_SRC_CORE_JSON_JSON_READER_H__++#include <grpc/support/port_platform.h>+#include ""src/core/json/json_common.h""++typedef enum {+  GRPC_JSON_STATE_OBJECT_KEY_BEGIN,+  GRPC_JSON_STATE_OBJECT_KEY_STRING,+  GRPC_JSON_STATE_OBJECT_KEY_END,+  GRPC_JSON_STATE_VALUE_BEGIN,+  GRPC_JSON_STATE_VALUE_STRING,+  GRPC_JSON_STATE_STRING_ESCAPE,+  GRPC_JSON_STATE_STRING_ESCAPE_U1,+  GRPC_JSON_STATE_STRING_ESCAPE_U2,+  GRPC_JSON_STATE_STRING_ESCAPE_U3,+  GRPC_JSON_STATE_STRING_ESCAPE_U4,+  GRPC_JSON_STATE_VALUE_NUMBER,+  GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL,+  GRPC_JSON_STATE_VALUE_NUMBER_ZERO,+  GRPC_JSON_STATE_VALUE_NUMBER_DOT,+  GRPC_JSON_STATE_VALUE_NUMBER_E,+  GRPC_JSON_STATE_VALUE_NUMBER_EPM,+  GRPC_JSON_STATE_VALUE_TRUE_R,+  GRPC_JSON_STATE_VALUE_TRUE_U,+  GRPC_JSON_STATE_VALUE_TRUE_E,+  GRPC_JSON_STATE_VALUE_FALSE_A,+  GRPC_JSON_STATE_VALUE_FALSE_L,+  GRPC_JSON_STATE_VALUE_FALSE_S,+  GRPC_JSON_STATE_VALUE_FALSE_E,+  GRPC_JSON_STATE_VALUE_NULL_U,+  GRPC_JSON_STATE_VALUE_NULL_L1,+  GRPC_JSON_STATE_VALUE_NULL_L2,+  GRPC_JSON_STATE_VALUE_END,+  GRPC_JSON_STATE_END+} grpc_json_reader_state;++enum {+  /* The first non-unicode value is 0x110000. But let's pick+   * a value high enough to start our error codes from. These+   * values are safe to return from the read_char function.+   */+  GRPC_JSON_READ_CHAR_EOF = 0x7ffffff0,+  GRPC_JSON_READ_CHAR_EAGAIN,+  GRPC_JSON_READ_CHAR_ERROR+};++typedef struct grpc_json_reader {+  /* You are responsible for your own opaque userdata.+   * Among other things, it needs to hold a string scratchpad.+   */+  void* userdata;++  /* You also need to set up these callbacks. */++  /* Clears your internal string scratchpad. */+  void (*string_clear)(struct grpc_json_reader*);","Ok, let's set up vtables for this stuff.It lets us put the initialization into static const data and saves some initialization time.It also makes it a little easier to trigger a compile error when updating the list of callbacks (always add new callbacks in the middle somewhere).",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23587053,2015-01-27T04:49:12Z,src/core/json/json_writer.c,"@@ -0,0 +1,248 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>+#include ""src/core/json/json_writer.h""++static void grpc_json_writer_output_char(grpc_json_writer* writer, char c) {+  writer->output_char(writer, c);+}++static void grpc_json_writer_output_string(grpc_json_writer* writer, const char* str) {+  writer->output_string(writer, str);+}++static void grpc_json_writer_output_string_with_len(grpc_json_writer* writer, const char* str, size_t len) {+  writer->output_string_with_len(writer, str, len);+}++/* Call this function to initialize the writer structure. */+void grpc_json_writer_init(grpc_json_writer* writer, int indent) {+  writer->depth = 0;+  writer->container_empty = 1;+  writer->got_key = 0;+  writer->indent = indent;+}++static void grpc_json_writer_output_indent(+    grpc_json_writer* writer) {+  static const char spacesstr[] =+      ""                ""+      ""                ""+      ""                ""+      ""                "";++  int spaces = writer->depth * writer->indent;++  if (writer->got_key) {+    grpc_json_writer_output_char(writer, ' ');+    return;+  }++  while (spaces >= (sizeof(spacesstr) - 1)) {+    grpc_json_writer_output_string_with_len(writer, spacesstr,+                                            sizeof(spacesstr) - 1);+    spaces -= (sizeof(spacesstr) - 1);+  }++  if (!spaces) return;","Yeah, that's a bad habit of mine too.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23587117,2015-01-27T04:51:49Z,src/core/json/json_reader.c,"@@ -0,0 +1,640 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>+#include ""src/core/json/json_reader.h""++static void grpc_json_reader_string_clear(grpc_json_reader* reader) {+  reader->string_clear(reader);+}++static void grpc_json_reader_string_add_char(grpc_json_reader* reader,+                                             gpr_uint32 c) {+  reader->string_add_char(reader, c);+}++static void grpc_json_reader_string_add_utf32(grpc_json_reader* reader,+                                              gpr_uint32 utf32) {+  reader->string_add_utf32(reader, utf32);+}++static gpr_uint32+    grpc_json_reader_read_char(grpc_json_reader* reader) {+  return reader->read_char(reader);+}++static void grpc_json_reader_container_begins(grpc_json_reader* reader,+                                              grpc_json_type type) {+  reader->container_begins(reader, type);+}++static grpc_json_type+    grpc_json_reader_container_ends(grpc_json_reader* reader) {+  return reader->container_ends(reader);+}++static void grpc_json_reader_set_key(grpc_json_reader* reader) {+  reader->set_key(reader);+}++static void grpc_json_reader_set_string(grpc_json_reader* reader) {+  reader->set_string(reader);+}++static int grpc_json_reader_set_number(grpc_json_reader* reader) {+  return reader->set_number(reader);+}++static void grpc_json_reader_set_true(grpc_json_reader* reader) {+  reader->set_true(reader);+}++static void grpc_json_reader_set_false(grpc_json_reader* reader) {+  reader->set_false(reader);+}++static void grpc_json_reader_set_null(grpc_json_reader* reader) {+  reader->set_null(reader);+}++/* Call this function to initialize the reader structure. */+void grpc_json_reader_init(grpc_json_reader* reader) {+  reader->depth = 0;+  reader->in_object = 0;+  reader->in_array = 0;+  reader->unicode_high_surrogate = 0;+  grpc_json_reader_string_clear(reader);+  reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+}++int grpc_json_reader_is_complete(grpc_json_reader* reader) {+  return ((reader->depth == 0) && ((reader->state == GRPC_JSON_STATE_END) ||+          (reader->state == GRPC_JSON_STATE_VALUE_END)));+}++grpc_json_reader_ret grpc_json_reader_run(grpc_json_reader* reader) {+  gpr_uint32 c, success;++  /* This state-machine is a strict implementation of ECMA-404 */+  for (;;) {+    c = grpc_json_reader_read_char(reader);+    switch (c) {+      /* Let's process the error cases first. */+      case GRPC_JSON_READ_CHAR_ERROR:+        return GRPC_JSON_READ_ERROR;++      case GRPC_JSON_READ_CHAR_EAGAIN:+        return GRPC_JSON_EAGAIN;++      case GRPC_JSON_READ_CHAR_EOF:+        if (grpc_json_reader_is_complete(reader)) {+          return GRPC_JSON_DONE;+        } else {+          return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* Processing whitespaces. */+      case ' ':+      case '\t':+      case '\n':+      case '\r':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+          case GRPC_JSON_STATE_OBJECT_KEY_END:+          case GRPC_JSON_STATE_VALUE_BEGIN:+          case GRPC_JSON_STATE_VALUE_END:+          case GRPC_JSON_STATE_END:+            break;++          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+          case GRPC_JSON_STATE_VALUE_STRING:+            if (c != ' ') return GRPC_JSON_PARSE_ERROR;+            if (reader->unicode_high_surrogate) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_add_char(reader, c);+            break;++          case GRPC_JSON_STATE_VALUE_NUMBER:+          case GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL:+          case GRPC_JSON_STATE_VALUE_NUMBER_ZERO:+          case GRPC_JSON_STATE_VALUE_NUMBER_EPM:+            success = grpc_json_reader_set_number(reader);+            if (!success) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_clear(reader);+            reader->state = GRPC_JSON_STATE_VALUE_END;+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* Value, object or array terminations. */+      case ',':+      case '}':+      case ']':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+          case GRPC_JSON_STATE_VALUE_STRING:+            if (reader->unicode_high_surrogate) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_add_char(reader, c);+            break;++          case GRPC_JSON_STATE_VALUE_NUMBER:+          case GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL:+          case GRPC_JSON_STATE_VALUE_NUMBER_ZERO:+          case GRPC_JSON_STATE_VALUE_NUMBER_EPM:+            success = grpc_json_reader_set_number(reader);+            if (!success) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_clear(reader);+            reader->state = GRPC_JSON_STATE_VALUE_END;+          /* The missing break here is intentional. */++          case GRPC_JSON_STATE_VALUE_END:+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+          case GRPC_JSON_STATE_VALUE_BEGIN:+            if (c == ',') {+              if (reader->state != GRPC_JSON_STATE_VALUE_END) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if (reader->in_object) {+                reader->state = GRPC_JSON_STATE_OBJECT_KEY_BEGIN;+              } else {+                reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+              }+            } else {+              if (reader->depth-- == 0) return GRPC_JSON_PARSE_ERROR;+              if ((c == '}') && !reader->in_object) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if ((c == '}') &&+                  (reader->state == GRPC_JSON_STATE_OBJECT_KEY_BEGIN) &&+                  !reader->container_just_begun) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if ((c == ']') && !reader->in_array) return GRPC_JSON_PARSE_ERROR;+              if ((c == ']') &&+                  (reader->state == GRPC_JSON_STATE_VALUE_BEGIN) &&+                  !reader->container_just_begun) {+                return GRPC_JSON_PARSE_ERROR;+              }+              reader->state = GRPC_JSON_STATE_VALUE_END;+              switch (grpc_json_reader_container_ends(reader)) {+                case GRPC_JSON_OBJECT:+                  reader->in_object = 1;+                  reader->in_array = 0;+                  break;+                case GRPC_JSON_ARRAY:+                  reader->in_object = 0;+                  reader->in_array = 1;+                  break;+                case GRPC_JSON_TOP_LEVEL:+                  if (reader->depth != 0) return GRPC_JSON_INTERNAL_ERROR;+                  reader->in_object = 0;+                  reader->in_array = 0;+                  reader->state = GRPC_JSON_STATE_END;+                  break;+                default:+                  return GRPC_JSON_INTERNAL_ERROR;+              }+            }+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* In-string escaping. */+      case '\\':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+            reader->escaped_string_was_key = 1;+            reader->state = GRPC_JSON_STATE_STRING_ESCAPE;+            break;++          case GRPC_JSON_STATE_VALUE_STRING:+            reader->escaped_string_was_key = 0;+            reader->state = GRPC_JSON_STATE_STRING_ESCAPE;+            break;++          /* This is the \\ case. */+          case GRPC_JSON_STATE_STRING_ESCAPE:+            if (reader->unicode_high_surrogate) return GRPC_JSON_PARSE_ERROR;+            grpc_json_reader_string_add_char(reader, '\\');+            if (reader->escaped_string_was_key) {+              reader->state = GRPC_JSON_STATE_OBJECT_KEY_STRING;+            } else {+              reader->state = GRPC_JSON_STATE_VALUE_STRING;+            }+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      default:+        reader->container_just_begun = 0;+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+            if (c != '""') return GRPC_JSON_PARSE_ERROR;+            reader->state = GRPC_JSON_STATE_OBJECT_KEY_STRING;+            break;++          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+            if (reader->unicode_high_surrogate) return GRPC_JSON_PARSE_ERROR;+            if (c == '""') {+              reader->state = GRPC_JSON_STATE_OBJECT_KEY_END;+              grpc_json_reader_set_key(reader);+              grpc_json_reader_string_clear(reader);+            } else {+              if (c < 32) return GRPC_JSON_PARSE_ERROR;","The ECMA-404 spec says ""bad characters are between U+0000 and U+001F"". I'd be even tempted to write <= 0x1f to match what the spec says verbatim.",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23587122,2015-01-27T04:52:02Z,src/core/json/json_reader.h,"@@ -0,0 +1,158 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef __GRPC_SRC_CORE_JSON_JSON_READER_H__+#define __GRPC_SRC_CORE_JSON_JSON_READER_H__++#include <grpc/support/port_platform.h>+#include ""src/core/json/json_common.h""++typedef enum {+  GRPC_JSON_STATE_OBJECT_KEY_BEGIN,+  GRPC_JSON_STATE_OBJECT_KEY_STRING,+  GRPC_JSON_STATE_OBJECT_KEY_END,+  GRPC_JSON_STATE_VALUE_BEGIN,+  GRPC_JSON_STATE_VALUE_STRING,+  GRPC_JSON_STATE_STRING_ESCAPE,+  GRPC_JSON_STATE_STRING_ESCAPE_U1,+  GRPC_JSON_STATE_STRING_ESCAPE_U2,+  GRPC_JSON_STATE_STRING_ESCAPE_U3,+  GRPC_JSON_STATE_STRING_ESCAPE_U4,+  GRPC_JSON_STATE_VALUE_NUMBER,+  GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL,+  GRPC_JSON_STATE_VALUE_NUMBER_ZERO,+  GRPC_JSON_STATE_VALUE_NUMBER_DOT,+  GRPC_JSON_STATE_VALUE_NUMBER_E,+  GRPC_JSON_STATE_VALUE_NUMBER_EPM,+  GRPC_JSON_STATE_VALUE_TRUE_R,+  GRPC_JSON_STATE_VALUE_TRUE_U,+  GRPC_JSON_STATE_VALUE_TRUE_E,+  GRPC_JSON_STATE_VALUE_FALSE_A,+  GRPC_JSON_STATE_VALUE_FALSE_L,+  GRPC_JSON_STATE_VALUE_FALSE_S,+  GRPC_JSON_STATE_VALUE_FALSE_E,+  GRPC_JSON_STATE_VALUE_NULL_U,+  GRPC_JSON_STATE_VALUE_NULL_L1,+  GRPC_JSON_STATE_VALUE_NULL_L2,+  GRPC_JSON_STATE_VALUE_END,+  GRPC_JSON_STATE_END+} grpc_json_reader_state;++enum {+  /* The first non-unicode value is 0x110000. But let's pick+   * a value high enough to start our error codes from. These+   * values are safe to return from the read_char function.+   */+  GRPC_JSON_READ_CHAR_EOF = 0x7ffffff0,+  GRPC_JSON_READ_CHAR_EAGAIN,+  GRPC_JSON_READ_CHAR_ERROR+};++typedef struct grpc_json_reader {+  /* You are responsible for your own opaque userdata.+   * Among other things, it needs to hold a string scratchpad.+   */+  void* userdata;++  /* You also need to set up these callbacks. */++  /* Clears your internal string scratchpad. */+  void (*string_clear)(struct grpc_json_reader*);+  /* Adds a char to the string scratchpad. */+  void (*string_add_char)(struct grpc_json_reader*, gpr_uint32 c);+  /* Adds a utf32 char to the string scratchpad. */+  void (*string_add_utf32)(struct grpc_json_reader*, gpr_uint32 c);+  /* Reads a character from your input. May be utf-8, 16 or 32. */+  gpr_uint32 (*read_char)(struct grpc_json_reader*);+  /* Starts a container of type GRPC_JSON_ARRAY or GRPC_JSON_OBJECT. */+  void (*container_begins)(struct grpc_json_reader*, grpc_json_type type);+  /* Ends the current container. Must return the type of its parent. */+  grpc_json_type (*container_ends)(struct grpc_json_reader*);+  /* Your internal string scratchpad is an object's key. */+  void (*set_key)(struct grpc_json_reader*);+  /* Your internal string scratchpad is a string value. */+  void (*set_string)(struct grpc_json_reader*);+  /* Your internal string scratchpad is a numerical value. Return 1 if valid. */+  int (*set_number)(struct grpc_json_reader*);+  /* Sets the values true, false or null. */+  void (*set_true)(struct grpc_json_reader*);+  void (*set_false)(struct grpc_json_reader*);+  void (*set_null)(struct grpc_json_reader*);++  /* Everything down here is private,+     and initialized by grpc_json_reader_init. */+  int depth;+  int in_object;+  int in_array;+  int escaped_string_was_key;+  int container_just_begun;+  gpr_uint16 unicode_char, unicode_high_surrogate;+  grpc_json_reader_state state;+} grpc_json_reader;++/* The return type of the parser. */+typedef enum {+  GRPC_JSON_DONE,          /* The parser finished successfully. */+  GRPC_JSON_EAGAIN,        /* The parser yields to get more data. */+  GRPC_JSON_READ_ERROR,    /* The parser passes through a read error. */+  GRPC_JSON_PARSE_ERROR,   /* The parser found an error in the json stream. */+  GRPC_JSON_INTERNAL_ERROR /* The parser got an internal error. */+} grpc_json_reader_ret;++/* Call this function to start parsing the input. It will return the following:+ *    . GRPC_JSON_DONE if the input got eof, and the parsing finished+ *      successfully.+ *    . GRPC_JSON_EAGAIN if the read_char function returned again. Call the+ *      parser again as needed. It is okay to call the parser in polling mode,+ *      although a bit dull.+ *    . GRPC_JSON_READ_ERROR if the read_char function returned an error. The+ *      state isn't broken however, and the function can be called again if the+ *      error has been corrected. But please use the EAGAIN feature instead for+ *      consistency.+ *    . GRPC_JSON_PARSE_ERROR if the input was somehow invalid.+ *    . GRPC_JSON_INTERNAL_ERROR if the parser somehow ended into an invalid+ *      internal state.+ */+grpc_json_reader_ret grpc_json_reader_run(grpc_json_reader* reader);++/* Call this function to initialize the reader structure. */+void grpc_json_reader_init(grpc_json_reader* reader);","Prefer:grpc_json_reader_init(grpc_json_reader *reader, grpc_json_reader_vtable *vtable, void *user_data);Allows the user of the struct to not care about what's in it at all, instead of having a shared-ownership thing going on.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23587226,2015-01-27T04:55:45Z,test/core/security/json_token_test.c,"@@ -217,59 +218,84 @@ static cJSON *parse_json_part_from_jwt(const char *str, size_t len) {   strncpy(decoded, (const char *)GPR_SLICE_START_PTR(slice),           GPR_SLICE_LENGTH(slice));   decoded[GPR_SLICE_LENGTH(slice)] = '\0';-  json = cJSON_Parse(decoded);+  json = grpc_json_parse_string(decoded);   gpr_free(b64);-  gpr_free(decoded);+  *scratchpad = decoded;   gpr_slice_unref(slice);   return json; } -static void check_jwt_header(cJSON *header) {-  cJSON *child = cJSON_GetObjectItem(header, ""alg"");-  GPR_ASSERT(child != NULL);-  GPR_ASSERT(child->type == cJSON_String);-  GPR_ASSERT(!strcmp(child->valuestring, ""RS256""));--  child = cJSON_GetObjectItem(header, ""typ"");-  GPR_ASSERT(child != NULL);-  GPR_ASSERT(child->type == cJSON_String);-  GPR_ASSERT(!strcmp(child->valuestring, ""JWT""));+static void check_jwt_header(grpc_json *header) {+  grpc_json *ptr;+  grpc_json *alg = NULL;+  grpc_json *typ = NULL;++  for (ptr = header->child; ptr; ptr = ptr->next) {+    if (strcmp(ptr->key, ""alg"") == 0) {+      alg = ptr;+    } else if (strcmp(ptr->key, ""typ"") == 0) {+      typ = ptr;+    }+  }+  GPR_ASSERT(alg != NULL);+  GPR_ASSERT(alg->type == GRPC_JSON_STRING);+  GPR_ASSERT(!strcmp(alg->value, ""RS256""));++  GPR_ASSERT(typ != NULL);+  GPR_ASSERT(typ->type == GRPC_JSON_STRING);+  GPR_ASSERT(!strcmp(typ->value, ""JWT"")); } -static void check_jwt_claim(cJSON *claim) {-  gpr_timespec exp = {0, 0};+static void check_jwt_claim(grpc_json *claim) {+  gpr_timespec expiration = {0, 0};   gpr_timespec issue_time = {0, 0};   gpr_timespec parsed_lifetime;-  cJSON *child = cJSON_GetObjectItem(claim, ""iss"");-  GPR_ASSERT(child != NULL);-  GPR_ASSERT(child->type == cJSON_String);+  grpc_json *iss = NULL;+  grpc_json *scope = NULL;+  grpc_json *aud = NULL;+  grpc_json *exp = NULL;+  grpc_json *iat = NULL;+  grpc_json *ptr;++  for (ptr = claim->child; ptr; ptr = ptr->next) {+    if (strcmp(ptr->key, ""iss"") == 0) {",https://msdn.microsoft.com/en-us/library/aa432714(office.12).aspx,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23587819,2015-01-27T05:20:10Z,src/core/json/json_string.c,"@@ -0,0 +1,391 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>+#include <stdlib.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/json/json.h""+#include ""src/core/json/json_reader.h""+#include ""src/core/json/json_writer.h""++/* The json reader will construct a bunch of grpc_json objects and+ * link them all up together in a tree-like structure that will represent+ * the json data in memory.+ *+ * It also uses its own input as a scratchpad to store all of the decoded,+ * unescaped strings. So we need to keep track of all these pointers in+ * that opaque structure the reader will carry for us.+ *+ * Note that this works because the act of parsing json always reduces its+ * input size, and never expands it.+ */+typedef struct {+  grpc_json* top;+  grpc_json* current_container;+  grpc_json* current_value;+  char* input;+  char* key;+  char* string;+  char* string_ptr;+  size_t remaining_input;+} grpc_json_reader_opaque;++/* This json writer will put everything in a big string.+ * The point is that we allocate that string in chunks of 256 bytes.+ */+typedef struct {+  char* output;+  size_t free_space, string_len, allocated;+} grpc_json_writer_opaque;+++/* This function checks if there's enough space left in the output buffer,+ * and will enlarge it if necessary. We're only allocating chunks of 256+ * bytes at a time (or multiples thereof).+ */+static void grpc_json_writer_output_check(grpc_json_writer* writer,+                                          size_t needed) {+  grpc_json_writer_opaque* state = writer->userdata;+  if (state->free_space >= needed) return;+  needed -= state->free_space;+  /* Round up by 256 bytes. */+  needed = (needed + 0xff) & ~0xff;+  state->output = gpr_realloc(state->output, state->allocated + needed);+  state->free_space += needed;+  state->allocated += needed;+}++/* These are needed by the writer's implementation. */+static void grpc_json_writer_output_char(grpc_json_writer* writer,+                                         char c) {+  grpc_json_writer_opaque* state = writer->userdata;+  grpc_json_writer_output_check(writer, 1);+  state->output[state->string_len++] = c;+  state->free_space--;+}++static void grpc_json_writer_output_string_with_len(+    grpc_json_writer* writer, const char* str, size_t len) {+  grpc_json_writer_opaque* state = writer->userdata;+  grpc_json_writer_output_check(writer, len);+  memcpy(state->output + state->string_len, str, len);+  state->string_len += len;+  state->free_space -= len;+}++static void grpc_json_writer_output_string(grpc_json_writer* writer,+                                           const char* str) {+  size_t len = strlen(str);+  grpc_json_writer_output_string_with_len(writer, str, len);+}++/* The reader asks us to clear our scratchpad. In our case, we'll simply mark+ * the end of the current string, and advance our output pointer.+ */+static void grpc_json_reader_string_clear(grpc_json_reader* reader) {+  grpc_json_reader_opaque* state = reader->userdata;+  if (state->string) {+    GPR_ASSERT(state->string_ptr < state->input);+    *state->string_ptr++ = 0;+  }+  state->string = state->string_ptr;+}++static void grpc_json_reader_string_add_char(grpc_json_reader* reader, gpr_uint32 c) {+  grpc_json_reader_opaque* state = reader->userdata;+  GPR_ASSERT(state->string_ptr < state->input);+  GPR_ASSERT(c <= 0xff);+  *state->string_ptr++ = (char)c;+}++/* We are converting a UTF-32 character into UTF-8 here. */","Even dropping rfc3629 here and there would help. Save some googling :)On Mon, Jan 26, 2015, 21:16 Nicolas Noble notifications@github.com wrote:> In src/core/json/json_string.c> https://github.com/google/grpc/pull/168#discussion_r23587707:> > > -  grpc_json_reader_opaque\* state = reader->userdata;> > -  if (state->string) {> > -    GPR_ASSERT(state->string_ptr < state->input);> > -    *state->string_ptr++ = 0;> > -  }> > -  state->string = state->string_ptr;> >   +}> >   +> >   +static void grpc_json_reader_string_add_char(grpc_json_reader\* reader, gpr_uint32 c) {> > -  grpc_json_reader_opaque\* state = reader->userdata;> > -  GPR_ASSERT(state->string_ptr < state->input);> > -  GPR_ASSERT(c <= 0xff);> > -  _state->string_ptr++ = (char)c;> >   +}> >   +> >   +/_ We are converting a UTF-32 character into UTF-8 here. */> > http://tools.ietf.org/html/rfc3629 basically.> > —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/168/files#r23587707.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23587883,2015-01-27T05:22:28Z,src/core/json/json_string.c,"@@ -0,0 +1,391 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>+#include <stdlib.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/json/json.h""+#include ""src/core/json/json_reader.h""+#include ""src/core/json/json_writer.h""++/* The json reader will construct a bunch of grpc_json objects and+ * link them all up together in a tree-like structure that will represent+ * the json data in memory.+ *+ * It also uses its own input as a scratchpad to store all of the decoded,+ * unescaped strings. So we need to keep track of all these pointers in+ * that opaque structure the reader will carry for us.+ *+ * Note that this works because the act of parsing json always reduces its+ * input size, and never expands it.+ */+typedef struct {+  grpc_json* top;+  grpc_json* current_container;+  grpc_json* current_value;+  char* input;+  char* key;+  char* string;+  char* string_ptr;+  size_t remaining_input;+} grpc_json_reader_opaque;++/* This json writer will put everything in a big string.+ * The point is that we allocate that string in chunks of 256 bytes.+ */+typedef struct {+  char* output;+  size_t free_space, string_len, allocated;+} grpc_json_writer_opaque;+++/* This function checks if there's enough space left in the output buffer,+ * and will enlarge it if necessary. We're only allocating chunks of 256+ * bytes at a time (or multiples thereof).+ */+static void grpc_json_writer_output_check(grpc_json_writer* writer,+                                          size_t needed) {+  grpc_json_writer_opaque* state = writer->userdata;+  if (state->free_space >= needed) return;+  needed -= state->free_space;+  /* Round up by 256 bytes. */+  needed = (needed + 0xff) & ~0xff;+  state->output = gpr_realloc(state->output, state->allocated + needed);+  state->free_space += needed;+  state->allocated += needed;+}++/* These are needed by the writer's implementation. */+static void grpc_json_writer_output_char(grpc_json_writer* writer,+                                         char c) {+  grpc_json_writer_opaque* state = writer->userdata;+  grpc_json_writer_output_check(writer, 1);+  state->output[state->string_len++] = c;+  state->free_space--;+}++static void grpc_json_writer_output_string_with_len(+    grpc_json_writer* writer, const char* str, size_t len) {+  grpc_json_writer_opaque* state = writer->userdata;+  grpc_json_writer_output_check(writer, len);+  memcpy(state->output + state->string_len, str, len);+  state->string_len += len;+  state->free_space -= len;+}++static void grpc_json_writer_output_string(grpc_json_writer* writer,+                                           const char* str) {+  size_t len = strlen(str);+  grpc_json_writer_output_string_with_len(writer, str, len);+}++/* The reader asks us to clear our scratchpad. In our case, we'll simply mark+ * the end of the current string, and advance our output pointer.+ */+static void grpc_json_reader_string_clear(grpc_json_reader* reader) {+  grpc_json_reader_opaque* state = reader->userdata;+  if (state->string) {+    GPR_ASSERT(state->string_ptr < state->input);+    *state->string_ptr++ = 0;+  }+  state->string = state->string_ptr;+}++static void grpc_json_reader_string_add_char(grpc_json_reader* reader, gpr_uint32 c) {+  grpc_json_reader_opaque* state = reader->userdata;+  GPR_ASSERT(state->string_ptr < state->input);+  GPR_ASSERT(c <= 0xff);+  *state->string_ptr++ = (char)c;+}++/* We are converting a UTF-32 character into UTF-8 here. */","Grep for _vtable and you'll find a bunch of examples.On Mon, Jan 26, 2015, 21:18 Craig Tiller ctiller@google.com wrote:> Even dropping rfc3629 here and there would help. Save some googling :)> > On Mon, Jan 26, 2015, 21:16 Nicolas Noble notifications@github.com> wrote:> > > In src/core/json/json_string.c> > https://github.com/google/grpc/pull/168#discussion_r23587707:> > > > > -  grpc_json_reader_opaque\* state = reader->userdata;> > > -  if (state->string) {> > > -    GPR_ASSERT(state->string_ptr < state->input);> > > -    *state->string_ptr++ = 0;> > > -  }> > > -  state->string = state->string_ptr;> > >   +}> > >   +> > >   +static void grpc_json_reader_string_add_char(grpc_json_reader\* reader, gpr_uint32 c) {> > > -  grpc_json_reader_opaque\* state = reader->userdata;> > > -  GPR_ASSERT(state->string_ptr < state->input);> > > -  GPR_ASSERT(c <= 0xff);> > > -  _state->string_ptr++ = (char)c;> > >   +}> > >   +> > >   +/_ We are converting a UTF-32 character into UTF-8 here. */> > > > http://tools.ietf.org/html/rfc3629 basically.> > > > —> > Reply to this email directly or view it on GitHub> > https://github.com/google/grpc/pull/168/files#r23587707.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23588145,2015-01-27T05:31:57Z,src/core/security/json_token.c,"@@ -91,7 +94,8 @@ int grpc_auth_json_key_is_valid(const grpc_auth_json_key *json_key) { grpc_auth_json_key grpc_auth_json_key_create_from_string(     const char *json_string) {   grpc_auth_json_key result;-  cJSON *json = cJSON_Parse(json_string);+  char *scratchpad = gpr_strdup(json_string);","That one question makes me a tiny bit nervous.That's because that's how the reader works internally. It'll use its input by clobbering it in order to generate all of the key / value strings used in the output json tree. So since the input here is a const char *, I can't clobber that; I have to duplicate it first.This definitely calls for a later pass of optimization where we can provide clobberable buffers instead of always a const string. But that has more impactful ripples throughout the code. ",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23588332,2015-01-27T05:39:01Z,src/core/security/json_token.c,"@@ -91,7 +94,8 @@ int grpc_auth_json_key_is_valid(const grpc_auth_json_key *json_key) { grpc_auth_json_key grpc_auth_json_key_create_from_string(     const char *json_string) {   grpc_auth_json_key result;-  cJSON *json = cJSON_Parse(json_string);+  char *scratchpad = gpr_strdup(json_string);","Or using slice throughout, but that can wait six months.On Mon, Jan 26, 2015, 21:31 Nicolas Noble notifications@github.com wrote:> In src/core/security/json_token.c> https://github.com/google/grpc/pull/168#discussion_r23588145:> > > @@ -91,7 +94,8 @@ int grpc_auth_json_key_is_valid(const grpc_auth_json_key *json_key) {> >  grpc_auth_json_key grpc_auth_json_key_create_from_string(> >      const char *json_string) {> >    grpc_auth_json_key result;> > -  cJSON *json = cJSON_Parse(json_string);> > -  char *scratchpad = gpr_strdup(json_string);> > That one question makes me a tiny bit nervous.> > That's because that's how the reader works internally. It'll use its input> by clobbering it in order to generate all of the key / value strings used> in the output json tree. So since the input here is a const char *, I can't> clobber that; I have to duplicate it first.> > This definitely calls for a later pass of optimization where we can> provide clobberable buffers instead of always a const string. But that has> more impactful ripples throughout the code.> > —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/168/files#r23588145.",
6642281,chen-wang,https://api.github.com/repos/grpc/grpc/pulls/209,23630131,2015-01-27T18:30:11Z,test/cpp/interop/client.cc,"@@ -105,30 +149,58 @@ void DoEmpty(std::shared_ptr<ChannelInterface> channel) {   gpr_log(GPR_INFO, ""Empty rpc done.""); } -void DoLargeUnary(std::shared_ptr<ChannelInterface> channel) {-  gpr_log(GPR_INFO, ""Sending a large unary rpc..."");+void LargeUnaryShared(std::shared_ptr<ChannelInterface> channel,",I think we still need to follow the function naming convention by starting with Verb.,x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/168,23710601,2015-01-28T18:39:28Z,test/core/json/rewrite_test_input.json,"@@ -1,3 +1,86 @@+{","As far as possible I want to avoid us having anything that could be called a testing framework.We have binaries that return 0 on success, 1 on pass, and some utility libraries.The utility you need is probably:gpr_slice load_file(const char *filename);And _maybe_:void for_each_match(void _user_data, const char *globexpr, void (_cb)(void *user_data, const char *filename));",
10729293,kennetatgoogle,https://api.github.com/repos/grpc/grpc/pulls/247,23729974,2015-01-28T22:30:28Z,src/csharp/GrpcWrappers/WrappedNativeObject.cs,"@@ -0,0 +1,42 @@+using System;+using System.Runtime.InteropServices;+using System.Diagnostics.Contracts;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// Wraps a native resource referenced by a SafeHandle.+    /// </summary>+    public abstract class WrappedNativeObject<T> : IDisposable+        where T : SafeHandle+    {+        protected readonly T handle;++        protected WrappedNativeObject(T handle)+        {+            this.handle = handle;+        }++        public T Handle+        {+            get+            {+                return handle;+            }+        }++        public void Dispose()","This looks like an incorrect and partial implementation of the finalize-dispose pattern described here:https://msdn.microsoft.com/en-us/library/system.idisposable.aspxThe part that's incorrect is that you need a finalizer that invokes Dispose(false). That way, even if the consumer of this class fails to call Dispose, it will get called eventually.Just remember that the finalizer is not 100% guaranteed to be invoked (ever), and you have no idea what thread it will be called on, or what the managed system state will be.Freeing system resources in finalizers is usually a pretty safe thing to do.",x
10729293,kennetatgoogle,https://api.github.com/repos/grpc/grpc/pulls/247,23730177,2015-01-28T22:33:03Z,src/csharp/GrpcWrappers/Status.cs,"@@ -0,0 +1,37 @@+using System;+using System.Runtime.InteropServices;++namespace Google.GRPC.Wrappers+{+	// TODO: this should not be in Interop namespace.+	/// <summary>+	/// Represents RPC result.+	/// </summary>+	public class Status",Consider making this a struct instead of a class.It's a good candidate because it contains a small set of immutable fields and nothing else.The garbage collector will thank you.,x
10729293,kennetatgoogle,https://api.github.com/repos/grpc/grpc/pulls/247,23731793,2015-01-28T22:54:39Z,src/csharp/GrpcWrappers/Slice.cs,"@@ -0,0 +1,125 @@+using System;+using System.Runtime.InteropServices;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// gpr_slice from grpc/support/slice.h+    /// +    /// Working with slices is a bit tricky, because they need you to call Unref() when+    /// disposing them, but we can't implement safe disposal using SafeHandle, because+    /// gpr_slice is a struct rather than a simple pointer.+    /// Avoid working with Slice if possible (or make sure you understand the+    /// disposal logic).+    /// </summary>+	[StructLayout(LayoutKind.Sequential)]+	public struct Slice+	{+		[DllImport(""libgpr.so"")]+		static extern Slice gpr_empty_slice();++		[DllImport(""libgpr.so"")]+		static extern Slice gpr_slice_from_copied_string(string source);++		[DllImport(""libgpr.so"")]+		static extern Slice gpr_slice_from_copied_buffer(byte[] data, UIntPtr len);++        [DllImport(""libgpr.so"")]+        static extern Slice gpr_slice_unref(Slice slice);++		IntPtr refcount;",Please confirm that refcount's native counterpart is architecture-dependent in size.,x
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/247,23733286,2015-01-28T23:13:01Z,src/csharp/GrpcWrappers/Slice.cs,"@@ -0,0 +1,125 @@+using System;+using System.Runtime.InteropServices;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// gpr_slice from grpc/support/slice.h+    /// +    /// Working with slices is a bit tricky, because they need you to call Unref() when+    /// disposing them, but we can't implement safe disposal using SafeHandle, because+    /// gpr_slice is a struct rather than a simple pointer.+    /// Avoid working with Slice if possible (or make sure you understand the+    /// disposal logic).+    /// </summary>+	[StructLayout(LayoutKind.Sequential)]+	public struct Slice+	{+		[DllImport(""libgpr.so"")]+		static extern Slice gpr_empty_slice();++		[DllImport(""libgpr.so"")]+		static extern Slice gpr_slice_from_copied_string(string source);++		[DllImport(""libgpr.so"")]+		static extern Slice gpr_slice_from_copied_buffer(byte[] data, UIntPtr len);++        [DllImport(""libgpr.so"")]+        static extern Slice gpr_slice_unref(Slice slice);++		IntPtr refcount;","Actually, refcount is a pointer to a refcount object. So yes, it is IntPtr.Can you see the code in https://github.com/jtattermusch/grpc/blob/wrappers_review/include/grpc/support/slice.h? I am basically trying to mimic the layout of gpr_slice struct",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/247,23733894,2015-01-28T23:22:04Z,src/csharp/GrpcWrappers/Slice.cs,"@@ -0,0 +1,125 @@+using System;+using System.Runtime.InteropServices;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// gpr_slice from grpc/support/slice.h+    /// +    /// Working with slices is a bit tricky, because they need you to call Unref() when","The right approach might be to not wrap this type but instead wrap a different type that maps to a similar concept in C#.For example (one way):When receiving an array of bytes from C#, pin them in the gc, and construct a slice object (in C) who's refcount destroy function unpins the memory from the gc.",
10729293,kennetatgoogle,https://api.github.com/repos/grpc/grpc/pulls/247,23734340,2015-01-28T23:28:53Z,src/csharp/GrpcWrappers/Slice.cs,"@@ -0,0 +1,125 @@+using System;+using System.Runtime.InteropServices;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// gpr_slice from grpc/support/slice.h+    /// +    /// Working with slices is a bit tricky, because they need you to call Unref() when+    /// disposing them, but we can't implement safe disposal using SafeHandle, because+    /// gpr_slice is a struct rather than a simple pointer.+    /// Avoid working with Slice if possible (or make sure you understand the+    /// disposal logic).+    /// </summary>+	[StructLayout(LayoutKind.Sequential)]+	public struct Slice+	{+		[DllImport(""libgpr.so"")]+		static extern Slice gpr_empty_slice();++		[DllImport(""libgpr.so"")]+		static extern Slice gpr_slice_from_copied_string(string source);++		[DllImport(""libgpr.so"")]+		static extern Slice gpr_slice_from_copied_buffer(byte[] data, UIntPtr len);++        [DllImport(""libgpr.so"")]+        static extern Slice gpr_slice_unref(Slice slice);++		IntPtr refcount;+		Data data;++        /// <summary>+        /// Returns true if this slice is refcounted and therefore needs Unref() call+        /// when disposed.+        /// </summary>+        public bool IsRefcounted+        {+            get+            {+                return (refcount != IntPtr.Zero);+            }+        }++		public int Length+		{+			get+			{+				return (refcount != IntPtr.Zero) ? (int)data.refcounted.length : (int)data.inlined.length;+			}+		}++		public byte[] GetDataAsByteArray()+		{+			if (refcount != IntPtr.Zero)+			{+				int len = (int)data.refcounted.length;+				byte[] result = new byte[len];+				Marshal.Copy(data.refcounted.bytes, result, 0, len);+				return result;+			}+			else+			{+				int len = (int)data.inlined.length;+				byte[] result = new byte[len];+				Buffer.BlockCopy(data.inlined.bytes, 0, result, 0, len);+				return result;+			}+		}++		public static Slice CreateEmpty()+		{+			return gpr_empty_slice();+		}++        /// <summary>+        /// You need to call Unref() once done with the slice.+        /// </summary>+		public static Slice CreateFromString(string s)+		{+			return gpr_slice_from_copied_string(s);+		}++        /// <summary>+        /// You need to call Unref() once done with the slice.+        /// </summary>+		public static Slice CreateFromByteArray(byte[] data)+		{+			return gpr_slice_from_copied_buffer(data, new UIntPtr((ulong)data.Length));+		}++        public void Unref()+        {+            gpr_slice_unref(this);+        }++		[StructLayout(LayoutKind.Explicit)]+		public struct Data+		{+			[FieldOffset(0)]+			public RefcountedData refcounted;+			[FieldOffset(0)]+			public InlinedData inlined;+		}++		[StructLayout(LayoutKind.Sequential)]+		public struct RefcountedData+		{+			public IntPtr bytes;+			public UIntPtr length;+		}++		[StructLayout(LayoutKind.Sequential, Pack = 1)]+		public struct InlinedData+		{+			public byte length;+			// TODO: sizeconst depend on whether we are 32 bit or 64 bit!!!!+			[MarshalAs(+				UnmanagedType.ByValArray,+				SizeConst=15)]","To make it architecture independent, you'll likely need to use a custom marshaller.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/168,23735346,2015-01-28T23:45:56Z,src/core/json/json_reader.c,"@@ -0,0 +1,653 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>++#include <grpc/support/port_platform.h>++#include ""src/core/json/json_reader.h""++static void json_reader_string_clear(grpc_json_reader* reader) {+  reader->vtable->string_clear(reader->userdata);+}++static void json_reader_string_add_char(grpc_json_reader* reader,+                                             gpr_uint32 c) {+  reader->vtable->string_add_char(reader->userdata, c);+}++static void json_reader_string_add_utf32(grpc_json_reader* reader,+                                              gpr_uint32 utf32) {+  reader->vtable->string_add_utf32(reader->userdata, utf32);+}++static gpr_uint32+    grpc_json_reader_read_char(grpc_json_reader* reader) {+  return reader->vtable->read_char(reader->userdata);+}++static void json_reader_container_begins(grpc_json_reader* reader,+                                              grpc_json_type type) {+  reader->vtable->container_begins(reader->userdata, type);+}++static grpc_json_type+    grpc_json_reader_container_ends(grpc_json_reader* reader) {+  return reader->vtable->container_ends(reader->userdata);+}++static void json_reader_set_key(grpc_json_reader* reader) {+  reader->vtable->set_key(reader->userdata);+}++static void json_reader_set_string(grpc_json_reader* reader) {+  reader->vtable->set_string(reader->userdata);+}++static int json_reader_set_number(grpc_json_reader* reader) {+  return reader->vtable->set_number(reader->userdata);+}++static void json_reader_set_true(grpc_json_reader* reader) {+  reader->vtable->set_true(reader->userdata);+}++static void json_reader_set_false(grpc_json_reader* reader) {+  reader->vtable->set_false(reader->userdata);+}++static void json_reader_set_null(grpc_json_reader* reader) {+  reader->vtable->set_null(reader->userdata);+}++/* Call this function to initialize the reader structure. */+void grpc_json_reader_init(grpc_json_reader* reader,+                           grpc_json_reader_vtable* vtable, void* userdata) {+  memset(reader, 0, sizeof(grpc_json_reader));+  reader->vtable = vtable;+  reader->userdata = userdata;+  json_reader_string_clear(reader);+  reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+}++int grpc_json_reader_is_complete(grpc_json_reader* reader) {+  return ((reader->depth == 0) && ((reader->state == GRPC_JSON_STATE_END) ||+          (reader->state == GRPC_JSON_STATE_VALUE_END)));+}++grpc_json_reader_status grpc_json_reader_run(grpc_json_reader* reader) {+  gpr_uint32 c, success;++  /* This state-machine is a strict implementation of ECMA-404 */+  for (;;) {+    c = grpc_json_reader_read_char(reader);+    switch (c) {+      /* Let's process the error cases first. */+      case GRPC_JSON_READ_CHAR_ERROR:+        return GRPC_JSON_READ_ERROR;++      case GRPC_JSON_READ_CHAR_EAGAIN:+        return GRPC_JSON_EAGAIN;++      case GRPC_JSON_READ_CHAR_EOF:+        if (grpc_json_reader_is_complete(reader)) {+          return GRPC_JSON_DONE;+        } else {+          return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* Processing whitespaces. */+      case ' ':+      case '\t':+      case '\n':+      case '\r':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+          case GRPC_JSON_STATE_OBJECT_KEY_END:+          case GRPC_JSON_STATE_VALUE_BEGIN:+          case GRPC_JSON_STATE_VALUE_END:+          case GRPC_JSON_STATE_END:+            break;++          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+          case GRPC_JSON_STATE_VALUE_STRING:+            if (c != ' ') return GRPC_JSON_PARSE_ERROR;+            if (reader->unicode_high_surrogate != 0) return GRPC_JSON_PARSE_ERROR;+            json_reader_string_add_char(reader, c);+            break;++          case GRPC_JSON_STATE_VALUE_NUMBER:+          case GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL:+          case GRPC_JSON_STATE_VALUE_NUMBER_ZERO:+          case GRPC_JSON_STATE_VALUE_NUMBER_EPM:+            success = json_reader_set_number(reader);+            if (!success) return GRPC_JSON_PARSE_ERROR;+            json_reader_string_clear(reader);+            reader->state = GRPC_JSON_STATE_VALUE_END;+            break;++          default:+            return GRPC_JSON_PARSE_ERROR;+        }+        break;++      /* Value, object or array terminations. */+      case ',':+      case '}':+      case ']':+        switch (reader->state) {+          case GRPC_JSON_STATE_OBJECT_KEY_STRING:+          case GRPC_JSON_STATE_VALUE_STRING:+            if (reader->unicode_high_surrogate != 0) return GRPC_JSON_PARSE_ERROR;+            json_reader_string_add_char(reader, c);+            break;++          case GRPC_JSON_STATE_VALUE_NUMBER:+          case GRPC_JSON_STATE_VALUE_NUMBER_WITH_DECIMAL:+          case GRPC_JSON_STATE_VALUE_NUMBER_ZERO:+          case GRPC_JSON_STATE_VALUE_NUMBER_EPM:+            success = json_reader_set_number(reader);+            if (!success) return GRPC_JSON_PARSE_ERROR;+            json_reader_string_clear(reader);+            reader->state = GRPC_JSON_STATE_VALUE_END;+          /* The missing break here is intentional. */++          case GRPC_JSON_STATE_VALUE_END:+          case GRPC_JSON_STATE_OBJECT_KEY_BEGIN:+          case GRPC_JSON_STATE_VALUE_BEGIN:+            if (c == ',') {+              if (reader->state != GRPC_JSON_STATE_VALUE_END) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if (reader->in_object) {+                reader->state = GRPC_JSON_STATE_OBJECT_KEY_BEGIN;+              } else {+                reader->state = GRPC_JSON_STATE_VALUE_BEGIN;+              }+            } else {+              if (reader->depth-- == 0) return GRPC_JSON_PARSE_ERROR;+              if ((c == '}') && !reader->in_object) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if ((c == '}') &&+                  (reader->state == GRPC_JSON_STATE_OBJECT_KEY_BEGIN) &&+                  !reader->container_just_begun) {+                return GRPC_JSON_PARSE_ERROR;+              }+              if ((c == ']') && !reader->in_array) return GRPC_JSON_PARSE_ERROR;+              if ((c == ']') &&+                  (reader->state == GRPC_JSON_STATE_VALUE_BEGIN) &&+                  !reader->container_just_begun) {+                return GRPC_JSON_PARSE_ERROR;+              }+              reader->state = GRPC_JSON_STATE_VALUE_END;+              switch (grpc_json_reader_container_ends(reader)) {+                case GRPC_JSON_OBJECT:+                  reader->in_object = 1;+                  reader->in_array = 0;+                  break;+                case GRPC_JSON_ARRAY:+                  reader->in_object = 0;+                  reader->in_array = 1;+                  break;+                case GRPC_JSON_TOP_LEVEL:+                  if (reader->depth != 0) return GRPC_JSON_INTERNAL_ERROR;+                  reader->in_object = 0;+                  reader->in_array = 0;+                  reader->state = GRPC_JSON_STATE_END;+                  break;+                default:+                  return GRPC_JSON_INTERNAL_ERROR;","To trigger an internal error... ? Like, that default here is meant to be here only to shut off warnings, but it's technically unattainable code by the design of the state machine.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/247,23797991,2015-01-29T20:03:09Z,src/csharp/GrpcWrappers/ByteBuffer.cs,"@@ -0,0 +1,137 @@+using System;+using System.Runtime.InteropServices;+using System.IO;++namespace Google.GRPC.Wrappers+{+	public class ByteBuffer : WrappedNativeObject<ByteBufferSafeHandle>+	{+		[DllImport(""libgrpc.so"")]+		static extern ByteBufferSafeHandle grpc_byte_buffer_create(Slice[] slices, UIntPtr nslices);++		[DllImport(""libgrpc.so"")]+		static extern UIntPtr grpc_byte_buffer_length(ByteBufferSafeHandle byteBuffer);++		[DllImport(""libgrpc.so"")]+		static extern ByteBufferReaderSafeHandle grpc_byte_buffer_reader_create(IntPtr buffer);++		// TODO: what is the size of returned int?+		[DllImport(""libgrpc.so"")]+		static extern int grpc_byte_buffer_reader_next(ByteBufferReaderSafeHandle reader, IntPtr slice);++		public ByteBuffer(byte[] data) : base(CreateByteBufferSafeHandleFromByteArray(data))+		{+		}++		public UIntPtr Length+		{+			get+			{+				return grpc_byte_buffer_length(handle);+			}+		}++		private static ByteBufferSafeHandle CreateByteBufferSafeHandleFromByteArray(byte[] data)+		{+			Slice slice = default(Slice);+			try+			{+				slice = Slice.CreateFromByteArray(data);+				return grpc_byte_buffer_create(new Slice[] {slice}, new UIntPtr(1));++			} finally+			{+				if (slice.IsRefcounted) {",I am introducing a new C extension library that will wrap parts of gRPC C API that are hard to work with from C#. So the entire Slice class is going away.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/247,23798247,2015-01-29T20:06:15Z,src/csharp/GrpcWrappers/WrappedNativeObject.cs,"@@ -0,0 +1,42 @@+using System;+using System.Runtime.InteropServices;+using System.Diagnostics.Contracts;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// Wraps a native resource referenced by a SafeHandle.+    /// </summary>+    public abstract class WrappedNativeObject<T> : IDisposable+        where T : SafeHandle+    {+        protected readonly T handle;++        protected WrappedNativeObject(T handle)+        {+            this.handle = handle;+        }++        public T Handle+        {+            get+            {+                return handle;+            }+        }++        public void Dispose()","Well, reading the docs again, it seems this is the correct pattern for IDisposable base class that does not override Object.Finalize() (under section ""IDisposable and the inheritance hierarchy"").Also, the SafeHandle itself seems to implement proper finalizer logic to dispose the unmanaged object, so I am relying on it.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/247,23798565,2015-01-29T20:10:27Z,src/csharp/GrpcWrappers/Slice.cs,"@@ -0,0 +1,125 @@+using System;+using System.Runtime.InteropServices;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// gpr_slice from grpc/support/slice.h+    /// +    /// Working with slices is a bit tricky, because they need you to call Unref() when","ctiller, nice optimization trick! I might try it out in the future when performance becomes more of a concern. For now, simplicity rules.Btw, do you know how to unpin a pinned object from the C library? (it's easy to do that in C#, but I would need to introduce a callback for that and things start getting complicated).",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/305,23877066,2015-01-30T22:21:28Z,src/node/examples/stock.proto,"@@ -0,0 +1,33 @@+syntax = ""proto3"";","I added it to this file. But ""All files should have copyright notices"" is a substantial policy shift from what is currently implemented. Currently, we don't have copyright notices on any proto files or shell scripts, and possibly other files too.",
6642281,chen-wang,https://api.github.com/repos/grpc/grpc/pulls/341,24025915,2015-02-03T18:26:32Z,examples/tips/publisher.cc,"@@ -59,7 +65,7 @@ Status Client::CreateTopic(grpc::string topic) {   return stub_->CreateTopic(&context, request, &response); } -Status Client::ListTopics() {+Status Publisher::ListTopics() {   ListTopicsRequest request;   ListTopicsResponse response;",added std::vectorgrpc::string to return all listed topics.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/357,24054116,2015-02-04T00:38:18Z,src/core/surface/call.c,"@@ -45,162 +46,113 @@ #include <stdlib.h> #include <string.h> -#define INVALID_TAG ((void *)0xdeadbeef)+typedef struct legacy_state legacy_state;+static void destroy_legacy_state(legacy_state *ls); -/* Pending read queue+typedef enum { REQ_INITIAL = 0, REQ_READY, REQ_DONE } req_state; -   This data structure tracks reads that need to be presented to the completion-   queue but are waiting for the application to ask for them. */--#define INITIAL_PENDING_READ_COUNT 4+typedef enum {+  SEND_NOTHING,+  SEND_INITIAL_METADATA,+  SEND_MESSAGE,+  SEND_TRAILING_METADATA_AND_FINISH,+  SEND_FINISH+} send_action;  typedef struct {-  grpc_byte_buffer *byte_buffer;+  grpc_ioreq_completion_func on_complete;   void *user_data;-  void (*on_finish)(void *user_data, grpc_op_error error);-} pending_read;+  grpc_op_error status;+} completed_request; -/* TODO(ctiller): inline an element or two into this struct to avoid per-call-                  allocations */-typedef struct {-  pending_read *data;-  size_t count;-  size_t capacity;-} pending_read_array;+/* See request_set in grpc_call below for a description */",I just pushed some documentation on this data structure - it got lost at some point.,
10135909,dklempner,https://api.github.com/repos/grpc/grpc/pulls/375,24065142,2015-02-04T06:35:59Z,templates/Makefile.template,"@@ -137,7 +137,7 @@ CPPFLAGS += $(CPPFLAGS_$(CONFIG)) DEFINES += $(DEFINES_$(CONFIG)) LDFLAGS += $(LDFLAGS_$(CONFIG)) -CFLAGS += -std=c89 -pedantic+CFLAGS += -std=c89 -pedantic -D_POSIX_C_SOURCE=199309L","The damage within core is minimal. My only worry is if anything breaks that assumes that struct timespec is gpr_timespec, which we were previously documenting.The flip side of the defines: keep in mind that this is only necessary if you're doing -ansi or something similar that overrides your compiler's/libc's _POSIX_C_SOURCE.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/375,24065314,2015-02-04T06:41:45Z,templates/Makefile.template,"@@ -137,7 +137,7 @@ CPPFLAGS += $(CPPFLAGS_$(CONFIG)) DEFINES += $(DEFINES_$(CONFIG)) LDFLAGS += $(LDFLAGS_$(CONFIG)) -CFLAGS += -std=c89 -pedantic+CFLAGS += -std=c89 -pedantic -D_POSIX_C_SOURCE=199309L","We should minimally change the documentation now while we can :)""gpr_timespec may be something that kind of looks like a struct timespec ifyou're exceptionally lucky""On Tue Feb 03 2015 at 10:36:04 PM David Klempner notifications@github.comwrote:> In templates/Makefile.template> https://github.com/google/grpc/pull/375#discussion_r24065142:> > > @@ -137,7 +137,7 @@ CPPFLAGS += $(CPPFLAGS_$(CONFIG))> >  DEFINES += $(DEFINES_$(CONFIG))> >  LDFLAGS += $(LDFLAGS_$(CONFIG))> > > > -CFLAGS += -std=c89 -pedantic> > +CFLAGS += -std=c89 -pedantic -D_POSIX_C_SOURCE=199309L> > The damage within core is minimal. My only worry is if anything breaks> that assumes that struct timespec is gpr_timespec, which we were previously> documenting.> > The flip side of the defines: keep in mind that this is only necessary if> you're doing -ansi or something similar that overrides your> compiler's/libc's _POSIX_C_SOURCE.> > —> Reply to this email directly or view it on GitHub> https://github.com/google/grpc/pull/375/files#r24065142.",
4934394,taradinoc,https://api.github.com/repos/grpc/grpc/pulls/247,24136767,2015-02-05T01:24:03Z,src/csharp/GrpcWrappers/Call.cs,"@@ -0,0 +1,109 @@+using System;+using System.Runtime.InteropServices;+using System.Diagnostics;++namespace Google.GRPC.Wrappers+{+    /// <summary>+    /// Wrapper to work with native grpc_call.+    /// </summary>+	internal class Call : WrappedNativeObject<CallSafeHandle>+	{+		const UInt32 GRPC_WRITE_BUFFER_HINT = 1;++		[DllImport(""libgrpc.so"")]","I suggest moving all DllImport declarations into a NativeMethods class, as per https://msdn.microsoft.com/en-us/library/ms182161.aspx, instead of declaring the methods in each class that uses them.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/384,24178703,2015-02-05T17:04:55Z,src/core/surface/call.c,"@@ -497,12 +499,16 @@ static send_action choose_send_action(grpc_call *call) {     case WRITE_STATE_INITIAL:       if (is_op_live(call, GRPC_IOREQ_SEND_INITIAL_METADATA)) {         call->write_state = WRITE_STATE_STARTED;-        return SEND_INITIAL_METADATA;+        return is_op_live(call, GRPC_IOREQ_SEND_MESSAGE) ||","Ternary expressions inside return statements are confusing to read, especially when the condition itself is a compound operation.",x
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/411,24190667,2015-02-05T19:23:14Z,src/csharp/GrpcCore/Internal/ServerWritingObserver.cs,"@@ -0,0 +1,34 @@+using System;+using Google.GRPC.Core.Internal;++namespace Google.GRPC.Core.Internal+{+    internal class ServerWritingObserver<TWrite, TRead> : IObserver<TWrite>",Can you add a comment describing what this class does?,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/387,24192746,2015-02-05T19:46:05Z,src/core/statistics/census_tracing.c,"@@ -207,3 +191,45 @@ trace_obj* census_get_trace_obj_locked(census_op_id op_id) { const char* census_get_trace_method_name(const trace_obj* trace) {   return (const char*)trace->method; }++static annotation* dup_annotation_chain(annotation* from) {+  annotation* to = NULL;+  if (from != NULL) {+    to = gpr_malloc(sizeof(annotation));+    memcpy(to, from, sizeof(annotation));+    to->next = dup_annotation_chain(from->next);","Non-recursive version will be a couple of lines longer, but more efficient.",x
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/387,24209418,2015-02-05T23:13:14Z,src/core/statistics/census_tracing.c,"@@ -205,5 +189,54 @@ trace_obj* census_get_trace_obj_locked(census_op_id op_id) { }  const char* census_get_trace_method_name(const trace_obj* trace) {-  return (const char*)trace->method;+  return trace->method;+}++static trace_annotation* dup_annotation_chain(trace_annotation* from) {","I think the following is a bit cleaner:static trace_annotation\* dup_annotation_chain(trace_annotation\* from) {  trace_annotation _ret = NULL;  trace_annotation *_to = &ret;  for (; from != NULL; from = from->next) {    _to = gpr_malloc(sizeof(trace_annotation));    memcpy(_to, from, sizeof(trace_annotation));    to = &(*to)->next;  }  return ret;}",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/372,24216168,2015-02-06T01:14:40Z,src/core/iomgr/pollset_windows.h,"@@ -46,9 +48,20 @@ struct grpc_fd; typedef struct grpc_pollset {   gpr_mu mu;   gpr_cv cv;+  HANDLE iocp;","So, maybe I misunderstood how this works. Wouldn't we want a completion queue to call grpc_pollset_work and stall there ""forever"" (or until deadline passes) util the global poller kicks it ?",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/372,24216258,2015-02-06T01:16:21Z,src/core/iomgr/tcp_server_windows.c,"@@ -0,0 +1,372 @@+/*+ *+ * Copyright 2014, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>++#ifdef GPR_WINSOCK_SOCKET++#define _GNU_SOURCE+#include ""src/core/iomgr/sockaddr_utils.h""++#include ""src/core/iomgr/pollset_windows.h""+#include ""src/core/iomgr/socket_windows.h""+#include ""src/core/iomgr/tcp_server.h""+#include ""src/core/iomgr/tcp_windows.h""+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/log_win32.h>+#include <grpc/support/sync.h>+#include <grpc/support/time.h>++#define INIT_PORT_CAP 2+#define MIN_SAFE_ACCEPT_QUEUE_SIZE 100++static gpr_once s_init_max_accept_queue_size;+static int s_max_accept_queue_size;++/* one listening port */+typedef struct server_port {+  gpr_uint8 addresses[sizeof(struct sockaddr_in6) * 2 + 32];+  SOCKET new_socket;+  grpc_winsocket *socket;+  grpc_tcp_server *server;+  LPFN_ACCEPTEX AcceptEx;+} server_port;++/* the overall server */+struct grpc_tcp_server {+  grpc_tcp_server_cb cb;+  void *cb_arg;++  gpr_mu mu;+  gpr_cv cv;++  /* active port count: how many ports are actually still listening */+  int active_ports;++  /* all listening ports */+  server_port *ports;+  size_t nports;+  size_t port_capacity;+};++grpc_tcp_server *grpc_tcp_server_create(void) {+  grpc_tcp_server *s = gpr_malloc(sizeof(grpc_tcp_server));+  gpr_mu_init(&s->mu);+  gpr_cv_init(&s->cv);+  s->active_ports = 0;+  s->cb = NULL;+  s->cb_arg = NULL;+  s->ports = gpr_malloc(sizeof(server_port) * INIT_PORT_CAP);+  s->nports = 0;+  s->port_capacity = INIT_PORT_CAP;+  return s;+}++void grpc_tcp_server_destroy(grpc_tcp_server *s) {+  size_t i;+  gpr_mu_lock(&s->mu);+  /* shutdown all fd's */+  for (i = 0; i < s->nports; i++) {+    grpc_winsocket_shutdown(s->ports[i].socket);+  }+  /* wait while that happens */+  while (s->active_ports) {+    gpr_cv_wait(&s->cv, &s->mu, gpr_inf_future);+  }+  gpr_mu_unlock(&s->mu);++  /* delete ALL the things */+  for (i = 0; i < s->nports; i++) {+    server_port *sp = &s->ports[i];+    grpc_winsocket_orphan(sp->socket);+  }+  gpr_free(s->ports);+  gpr_free(s);+}++/* Prepare a recently-created socket for listening. */+static int prepare_socket(SOCKET sock,+                          const struct sockaddr *addr, int addr_len) {+  struct sockaddr_storage sockname_temp;+  socklen_t sockname_len;++  if (sock == INVALID_SOCKET) goto error;++  if (!grpc_tcp_prepare_socket(sock)) {+    char *utf8_message = gpr_format_message(WSAGetLastError());+    gpr_log(GPR_ERROR, ""Unable to prepare socket: %s"", utf8_message);+    gpr_free(utf8_message);+    goto error;+  }++  if (bind(sock, addr, addr_len) == SOCKET_ERROR) {+    char *addr_str;+    char *utf8_message = gpr_format_message(WSAGetLastError());+    grpc_sockaddr_to_string(&addr_str, addr, 0);+    gpr_log(GPR_ERROR, ""bind addr=%s: %s"", addr_str, utf8_message);+    gpr_free(utf8_message);+    gpr_free(addr_str);+    goto error;+  }++  if (listen(sock, SOMAXCONN) == SOCKET_ERROR) {+    char *utf8_message = gpr_format_message(WSAGetLastError());+    gpr_log(GPR_ERROR, ""listen: %s"", utf8_message);+    gpr_free(utf8_message);+    goto error;+  }++  sockname_len = sizeof(sockname_temp);+  if (getsockname(sock, (struct sockaddr *) &sockname_temp, &sockname_len)+        == SOCKET_ERROR) {+    char *utf8_message = gpr_format_message(WSAGetLastError());+    gpr_log(GPR_ERROR, ""getsockname: %s"", utf8_message);+    gpr_free(utf8_message);+    goto error;+  }++  return grpc_sockaddr_get_port((struct sockaddr *) &sockname_temp);++error:+  if (sock != INVALID_SOCKET) closesocket(sock);+  return -1;+}++static void on_accept(void *arg, int success);++static void start_accept(server_port *port) {+  SOCKET sock = INVALID_SOCKET;+  char *message;+  char *utf8_message;+  BOOL success;+  DWORD addrlen = sizeof(struct sockaddr_in6) + 16;+  DWORD bytes_received = 0;++  sock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, NULL, 0,+                   WSA_FLAG_OVERLAPPED);++  if (sock == INVALID_SOCKET) {+    message = ""Unable to create socket: %s"";+    goto failure;+  }++  if (!grpc_tcp_prepare_socket(sock)) {+    message = ""Unable to prepare socket: %s"";+    goto failure;+  }++  success = port->AcceptEx(port->socket->socket, sock, port->addresses, 0,+                           addrlen, addrlen, &bytes_received,+                           &port->socket->read_info.overlapped);++  if (success) {+    gpr_log(GPR_DEBUG, ""accepted immediately - but we still go to sleep"");+  } else {+    int error = WSAGetLastError();+    if (error != ERROR_IO_PENDING) {+      message = ""AcceptEx failed: %s"";+      goto failure;+    }+  }++  port->new_socket = sock;+  grpc_handle_notify_on_read(port->socket, on_accept, port);+  return;++failure:+  utf8_message = gpr_format_message(WSAGetLastError());+  gpr_log(GPR_ERROR, message, utf8_message);+  gpr_free(utf8_message);+  if (sock != INVALID_SOCKET) closesocket(sock);+}++/* event manager callback when reads are ready */+static void on_accept(void *arg, int success) {+  server_port *sp = arg;+  SOCKET sock = sp->new_socket;+  grpc_winsocket_callback_info *info = &sp->socket->read_info;+  grpc_endpoint *ep = NULL;++  if (success) {+    DWORD transfered_bytes = 0;+    DWORD flags;+    BOOL wsa_success = WSAGetOverlappedResult(sock, &info->overlapped,+                                              &transfered_bytes, FALSE,+                                              &flags);+    if (!wsa_success) {+      char *utf8_message = gpr_format_message(WSAGetLastError());+      gpr_log(GPR_ERROR, ""on_accept error: %s"", utf8_message);+      gpr_free(utf8_message);+      closesocket(sock);+    } else {+      gpr_log(GPR_DEBUG, ""on_accept: accepted connection"");+      ep = grpc_tcp_create(grpc_winsocket_create(sock));+    }+  } else {+    gpr_log(GPR_DEBUG, ""on_accept: shutting down"");+    closesocket(sock);+    gpr_mu_lock(&sp->server->mu);+    if (0 == --sp->server->active_ports) {+      gpr_cv_broadcast(&sp->server->cv);+    }+    gpr_mu_unlock(&sp->server->mu);+  }++  if (ep) sp->server->cb(sp->server->cb_arg, ep);+  start_accept(sp);+}++static int add_socket_to_server(grpc_tcp_server *s, SOCKET sock,+                                const struct sockaddr *addr, int addr_len) {+  server_port *sp;+  int port;+  int status;+  GUID guid = WSAID_ACCEPTEX;+  DWORD ioctl_num_bytes;+  LPFN_ACCEPTEX AcceptEx;++  if (sock == INVALID_SOCKET) return -1;++  status = WSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER,+                    &guid, sizeof(guid), &AcceptEx, sizeof(AcceptEx),+                    &ioctl_num_bytes, NULL, NULL);++  if (status != 0) {+    char *utf8_message = gpr_format_message(WSAGetLastError());+    gpr_log(GPR_ERROR, ""on_connect error: %s"", utf8_message);+    gpr_free(utf8_message);+    closesocket(sock);+    return -1;+  }++  port = prepare_socket(sock, addr, addr_len);+  if (port >= 0) {+    gpr_mu_lock(&s->mu);+    GPR_ASSERT(!s->cb && ""must add ports before starting server"");+    /* append it to the list under a lock */+    if (s->nports == s->port_capacity) {+      s->port_capacity *= 2;+      s->ports = gpr_realloc(s->ports, sizeof(server_port) * s->port_capacity);+    }+    sp = &s->ports[s->nports++];+    sp->server = s;+    sp->socket = grpc_winsocket_create(sock);+    sp->AcceptEx = AcceptEx;",No ? It may depends on the interface the port is listening to. Hence why we have to call WSAIoctl with SIO_GET_EXTENSION_FUNCTION_POINTER to grab the pointer of AcceptEx for that specific socket a few lines earlier.,
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/415,24269935,2015-02-06T20:35:09Z,src/csharp/GrpcApi/MathServiceImpl.cs,"@@ -0,0 +1,119 @@+using System;+using System.Threading;+using System.Threading.Tasks;+using System.Collections.Generic;+using System.Reactive.Linq;+using Google.GRPC.Core.Utils;++namespace math+{+    /// <summary>+    /// Implementation of MathService server+    /// </summary>+    public class MathServiceImpl : MathGrpc.IMathService+    {+        public void Div(DivArgs request, IObserver<DivReply> responseObserver)+        {+            var response = DivInternal(request);",Is it worth catching the potential [DivideByZeroException](https://msdn.microsoft.com/en-us/library/system.dividebyzeroexception%28v=vs.110%29.aspx) and calling responseObserver.OnError();Or is error handling something you plan to address later,x
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/423,24277377,2015-02-06T22:29:13Z,src/csharp/GrpcCore/Utils/RecordingQueue.cs,"@@ -0,0 +1,45 @@+using System;+using System.Threading.Tasks;+using System.Collections.Generic;+using System.Collections.Concurrent;++namespace Google.GRPC.Core.Utils+{+    public class RecordingQueue<T> : IObserver<T>",Please add a top-level doc describing what this class does.,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/381,24310838,2015-02-09T06:29:02Z,test/core/end2end/gen_build_json.py,"@@ -32,12 +32,39 @@     'ping_pong_streaming',     'request_response_with_binary_metadata_and_payload',     'request_response_with_metadata_and_payload',+    'request_response_with_metadata_and_payload',",duplicate line 35?,x
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/439,24365831,2015-02-09T21:13:25Z,src/ruby/spec/generic/rpc_desc_spec.rb,"@@ -94,7 +94,6 @@         expect(@call).to receive(:remote_read).once.and_return(req)         expect(@call).to receive(:remote_send).once.with(@ok_response)         expect(@call).to receive(:send_status).once.with(OK, 'OK')-        expect(@call).to receive(:finished).once",Why are we no longer expecting finished?,
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/439,24366319,2015-02-09T21:19:39Z,src/ruby/spec/generic/rpc_desc_spec.rb,"@@ -94,7 +94,6 @@         expect(@call).to receive(:remote_read).once.and_return(req)         expect(@call).to receive(:remote_send).once.with(@ok_response)         expect(@call).to receive(:send_status).once.with(OK, 'OK')-        expect(@call).to receive(:finished).once","- This is a test that use mock objects.  The ':finished' here refers to the fact that call.finished is not called any more.- That's consistent with the other changes in this commit, i.e, finished is no longer called on server calls  it fails.",
10470441,maxwell-demon,https://api.github.com/repos/grpc/grpc/pulls/437,24441292,2015-02-10T19:17:49Z,include/grpc/census.h,"@@ -0,0 +1,95 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef __GRPC_CENSUS_H__+#define __GRPC_CENSUS_H__++#ifdef __cplusplus+extern ""C"" {+#endif++/* A Census tag set is a collection of key:value string pairs; these form the+   basis against which Census resource measures will be recorded. */+typedef struct census_tag_set census_tag_set;++/* Add a new tag key/value to an existing tag set; if the tag key already exists+   in the tag set, then its value is overwritten with the new one. */+void census_tag_set_add(census_tag_set *tags, const char *key,+                        const char *value);++/* Empty an existing tag set; This *must* be called if any tags have been+   added to the tag set in order to avoid memory leaks. */+void census_tag_set_reset(census_tag_set *tags);++/* Census context contains tracking information on current tracing and+   resource measurement facilities. */+typedef struct census_context census_context;++/* Mark the logical start of a new Census operation, and resturns a new+   context. For tracing, this will generate a new span. The child context will+   be initialized using the contents of 'parent' and 'tags' (both of which can+   be NULL; if 'parent' is NULL, this is intended to be the root of a new+   trace). census_op_end() should be called when the operation completes.+*/+census_context *census_op_start(const census_context *parent,+                                const census_tag_set *tags);++/* Mark the end of a census context usage. The 'context' argument will be+   invalidated, and should not be used again. */+void census_end_op(census_context *context);++/* Insert a trace annotation. The string 's; is inserted into the trace+   record. */+void census_trace(const census_context *context, const char *s);++/* Record a metric (with given 'name' and 'value') against a 'context'. */+void census_record_metric(census_context *context, const char *name,+                          double value);++/* Serialize a census to a string buffer. This is intended for use by some RPC+   systems. The size of the buffer is passed as 'n'. The return value is the+   number of bytes consumed by the serialized context, or 0 if the buffer+   provided was too small. */+size_t census_context_serialize(const census_context *context, char *buffer,+                                size_t n);","consider renaming n to buff_size, then its meaning is self-documented.",x
10470441,maxwell-demon,https://api.github.com/repos/grpc/grpc/pulls/437,24441298,2015-02-10T19:17:52Z,include/grpc/census.h,"@@ -0,0 +1,95 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef __GRPC_CENSUS_H__+#define __GRPC_CENSUS_H__++#ifdef __cplusplus+extern ""C"" {+#endif++/* A Census tag set is a collection of key:value string pairs; these form the+   basis against which Census resource measures will be recorded. */+typedef struct census_tag_set census_tag_set;++/* Add a new tag key/value to an existing tag set; if the tag key already exists+   in the tag set, then its value is overwritten with the new one. */+void census_tag_set_add(census_tag_set *tags, const char *key,+                        const char *value);++/* Empty an existing tag set; This *must* be called if any tags have been+   added to the tag set in order to avoid memory leaks. */+void census_tag_set_reset(census_tag_set *tags);++/* Census context contains tracking information on current tracing and+   resource measurement facilities. */+typedef struct census_context census_context;++/* Mark the logical start of a new Census operation, and resturns a new+   context. For tracing, this will generate a new span. The child context will+   be initialized using the contents of 'parent' and 'tags' (both of which can+   be NULL; if 'parent' is NULL, this is intended to be the root of a new+   trace). census_op_end() should be called when the operation completes.+*/+census_context *census_op_start(const census_context *parent,+                                const census_tag_set *tags);++/* Mark the end of a census context usage. The 'context' argument will be+   invalidated, and should not be used again. */+void census_end_op(census_context *context);++/* Insert a trace annotation. The string 's; is inserted into the trace+   record. */+void census_trace(const census_context *context, const char *s);++/* Record a metric (with given 'name' and 'value') against a 'context'. */+void census_record_metric(census_context *context, const char *name,+                          double value);++/* Serialize a census to a string buffer. This is intended for use by some RPC+   systems. The size of the buffer is passed as 'n'. The return value is the+   number of bytes consumed by the serialized context, or 0 if the buffer+   provided was too small. */+size_t census_context_serialize(const census_context *context, char *buffer,+                                size_t n);++/* Deserialize into 'context' a buffer previously constructed from+ * census_context_serialize(). Existing contents of the context are+ * overwritten. */+void census_context_deserialize(census_context *context, const char *buffer);",Do we want to return status for deserialization failure or just assert when corrupted input data is encountered?,
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/470,24532627,2015-02-11T20:58:34Z,tools/dockerfile/grpc_java_base/Dockerfile,"@@ -22,11 +22,13 @@ ENV PATH $PATH:$JAVA_HOME/bin:$M2_HOME/bin ENV LD_LIBRARY_PATH /usr/local/lib  # Get the protobuf source from GitHub and install it-RUN wget -O - https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.bz2 | \-  tar xj && \-  cd protobuf-2.6.1 && \+RUN wget -O - https://github.com/google/protobuf/archive/master.tar.gz | \+  tar xz && \+  cd protobuf-master && \+  ./autogen.sh && \   ./configure --prefix=/usr && \   make -j12 && make check && make install && \+  cd java && mvn install && cd .. && \",That is the protobuf library. It is using Maven and I'm not aware of it swapping to Gradle. grpc-java is already Gradle-only.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/504,24687233,2015-02-13T18:59:48Z,src/node/ext/call.cc,"@@ -168,119 +513,74 @@ NAN_METHOD(Call::New) {   } } -NAN_METHOD(Call::AddMetadata) {+NAN_METHOD(Call::StartBatch) {   NanScope();   if (!HasInstance(args.This())) {-    return NanThrowTypeError(""addMetadata can only be called on Call objects"");+    return NanThrowTypeError(""startBatch can only be called on Call objects"");   }-  Call *call = ObjectWrap::Unwrap<Call>(args.This());   if (!args[0]->IsObject()) {-    return NanThrowTypeError(""addMetadata's first argument must be an object"");-  }-  Handle<Object> metadata = args[0]->ToObject();-  Handle<Array> keys(metadata->GetOwnPropertyNames());-  for (unsigned int i = 0; i < keys->Length(); i++) {-    Handle<String> current_key(keys->Get(i)->ToString());-    if (!metadata->Get(current_key)->IsArray()) {-      return NanThrowTypeError(-          ""addMetadata's first argument's values must be arrays"");-    }-    NanUtf8String utf8_key(current_key);-    Handle<Array> values = Local<Array>::Cast(metadata->Get(current_key));-    for (unsigned int j = 0; j < values->Length(); j++) {-      Handle<Value> value = values->Get(j);-      grpc_metadata metadata;-      grpc_call_error error;-      metadata.key = *utf8_key;-      if (Buffer::HasInstance(value)) {-        metadata.value = Buffer::Data(value);-        metadata.value_length = Buffer::Length(value);-        error = grpc_call_add_metadata_old(call->wrapped_call, &metadata, 0);-      } else if (value->IsString()) {-        Handle<String> string_value = value->ToString();-        NanUtf8String utf8_value(string_value);-        metadata.value = *utf8_value;-        metadata.value_length = string_value->Length();-        gpr_log(GPR_DEBUG, ""adding metadata: %s, %s, %d"", metadata.key,-                metadata.value, metadata.value_length);-        error = grpc_call_add_metadata_old(call->wrapped_call, &metadata, 0);-      } else {-        return NanThrowTypeError(-            ""addMetadata values must be strings or buffers"");-      }-      if (error != GRPC_CALL_OK) {-        return NanThrowError(""addMetadata failed"", error);-      }-    }-  }-  NanReturnUndefined();-}--NAN_METHOD(Call::Invoke) {-  NanScope();-  if (!HasInstance(args.This())) {-    return NanThrowTypeError(""invoke can only be called on Call objects"");-  }-  if (!args[0]->IsFunction()) {-    return NanThrowTypeError(""invoke's first argument must be a function"");+    return NanThrowError(""startBatch's first argument must be an object"");   }   if (!args[1]->IsFunction()) {-    return NanThrowTypeError(""invoke's second argument must be a function"");-  }-  if (!args[2]->IsUint32()) {-    return NanThrowTypeError(""invoke's third argument must be integer flags"");-  }-  Call *call = ObjectWrap::Unwrap<Call>(args.This());-  unsigned int flags = args[3]->Uint32Value();-  grpc_call_error error = grpc_call_invoke_old(-      call->wrapped_call, CompletionQueueAsyncWorker::GetQueue(),-      CreateTag(args[0], args.This()), CreateTag(args[1], args.This()), flags);-  if (error == GRPC_CALL_OK) {-    CompletionQueueAsyncWorker::Next();-    CompletionQueueAsyncWorker::Next();-  } else {-    return NanThrowError(""invoke failed"", error);-  }-  NanReturnUndefined();-}--NAN_METHOD(Call::ServerAccept) {-  NanScope();-  if (!HasInstance(args.This())) {-    return NanThrowTypeError(""accept can only be called on Call objects"");-  }-  if (!args[0]->IsFunction()) {-    return NanThrowTypeError(""accept's first argument must be a function"");+    return NanThrowError(""startBatch's second argument must be a callback"");   }+  Handle<Function> callback_func = args[1].As<Function>();   Call *call = ObjectWrap::Unwrap<Call>(args.This());-  grpc_call_error error = grpc_call_server_accept_old(-      call->wrapped_call, CompletionQueueAsyncWorker::GetQueue(),-      CreateTag(args[0], args.This()));-  if (error == GRPC_CALL_OK) {-    CompletionQueueAsyncWorker::Next();-  } else {-    return NanThrowError(""serverAccept failed"", error);-  }-  NanReturnUndefined();-}--NAN_METHOD(Call::ServerEndInitialMetadata) {-  NanScope();-  if (!HasInstance(args.This())) {-    return NanThrowTypeError(-        ""serverEndInitialMetadata can only be called on Call objects"");-  }-  if (!args[0]->IsUint32()) {-    return NanThrowTypeError(-        ""serverEndInitialMetadata's second argument must be integer flags"");+  shared_ptr<Resources> resources(new Resources);+  Handle<Object> obj = args[0]->ToObject();+  Handle<Array> keys = obj->GetOwnPropertyNames();+  size_t nops = keys->Length();+  std::vector<grpc_op> ops(nops);+  std::vector<unique_ptr<Op> > *op_vector = new std::vector<unique_ptr<Op> >();","Sorry, bad first suggestion.How about:``` cunique_ptr<vector<unique_ptr<Op>>> op_vector(new vector<unique_ptr<Op>>);...start_batch(..., op_vector.release(), ...);```",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/501,24857808,2015-02-17T21:51:40Z,include/grpc++/completion_queue.h,"@@ -34,52 +34,78 @@ #ifndef __GRPCPP_COMPLETION_QUEUE_H__ #define __GRPCPP_COMPLETION_QUEUE_H__ +#include <grpc++/impl/client_unary_call.h>+ struct grpc_completion_queue;  namespace grpc { +template <class R>+class ClientReader;+template <class W>+class ClientWriter;+template <class R, class W>+class ClientReaderWriter;+template <class R>+class ServerReader;+template <class W>+class ServerWriter;+template <class R, class W>+class ServerReaderWriter;++class CompletionQueue;+class Server;++class CompletionQueueTag {+ public:+  virtual ~CompletionQueueTag() {}+  // Called prior to returning from Next(), return value+  // is the status of the operation (return status is the default thing+  // to do)+  virtual void FinalizeResult(void **tag, bool *status) = 0;+};+ // grpc_completion_queue wrapper class class CompletionQueue {  public:   CompletionQueue();+  explicit CompletionQueue(grpc_completion_queue *take);   ~CompletionQueue(); -  enum CompletionType {-    QUEUE_CLOSED = 0,       // Shutting down.-    RPC_END = 1,            // An RPC finished. Either at client or server.-    CLIENT_READ_OK = 2,     // A client-side read has finished successfully.-    CLIENT_READ_ERROR = 3,  // A client-side read has finished with error.-    CLIENT_WRITE_OK = 4,-    CLIENT_WRITE_ERROR = 5,-    SERVER_RPC_NEW = 6,     // A new RPC just arrived at the server.-    SERVER_READ_OK = 7,     // A server-side read has finished successfully.-    SERVER_READ_ERROR = 8,  // A server-side read has finished with error.-    SERVER_WRITE_OK = 9,-    SERVER_WRITE_ERROR = 10,-    // Client or server has sent half close successfully.-    HALFCLOSE_OK = 11,-    // New CompletionTypes may be added in the future, so user code should-    // always-    // handle the default case of a CompletionType that appears after such code-    // was-    // written.-    DO_NOT_USE = 20,-  };-   // Blocking read from queue.-  // For QUEUE_CLOSED, *tag is not changed.-  // For SERVER_RPC_NEW, *tag will be a newly allocated AsyncServerContext.-  // For others, *tag will be the AsyncServerContext of this rpc.-  CompletionType Next(void** tag);+  // Returns true if an event was received, false if the queue is ready+  // for destruction.+  bool Next(void **tag, bool *ok);    // Shutdown has to be called, and the CompletionQueue can only be-  // destructed when the QUEUE_CLOSED message has been read with Next().+  // destructed when false is returned from Next().   void Shutdown(); -  grpc_completion_queue* cq() { return cq_; }+  grpc_completion_queue *cq() { return cq_; }   private:-  grpc_completion_queue* cq_;  // owned+  template <class R>+  friend class ::grpc::ClientReader;","Can I get the motivation for using friend classes and functions in this class? I'm just concerned about linguistic purity and the possibility of bad things emerging (e.g., maintenance problems down the line).",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/501,24863752,2015-02-17T23:01:11Z,include/grpc++/completion_queue.h,"@@ -34,52 +34,78 @@ #ifndef __GRPCPP_COMPLETION_QUEUE_H__ #define __GRPCPP_COMPLETION_QUEUE_H__ +#include <grpc++/impl/client_unary_call.h>+ struct grpc_completion_queue;  namespace grpc { +template <class R>+class ClientReader;+template <class W>+class ClientWriter;+template <class R, class W>+class ClientReaderWriter;+template <class R>+class ServerReader;+template <class W>+class ServerWriter;+template <class R, class W>+class ServerReaderWriter;++class CompletionQueue;+class Server;++class CompletionQueueTag {+ public:+  virtual ~CompletionQueueTag() {}+  // Called prior to returning from Next(), return value+  // is the status of the operation (return status is the default thing+  // to do)+  virtual void FinalizeResult(void **tag, bool *status) = 0;+};+ // grpc_completion_queue wrapper class class CompletionQueue {  public:   CompletionQueue();+  explicit CompletionQueue(grpc_completion_queue *take);   ~CompletionQueue(); -  enum CompletionType {-    QUEUE_CLOSED = 0,       // Shutting down.-    RPC_END = 1,            // An RPC finished. Either at client or server.-    CLIENT_READ_OK = 2,     // A client-side read has finished successfully.-    CLIENT_READ_ERROR = 3,  // A client-side read has finished with error.-    CLIENT_WRITE_OK = 4,-    CLIENT_WRITE_ERROR = 5,-    SERVER_RPC_NEW = 6,     // A new RPC just arrived at the server.-    SERVER_READ_OK = 7,     // A server-side read has finished successfully.-    SERVER_READ_ERROR = 8,  // A server-side read has finished with error.-    SERVER_WRITE_OK = 9,-    SERVER_WRITE_ERROR = 10,-    // Client or server has sent half close successfully.-    HALFCLOSE_OK = 11,-    // New CompletionTypes may be added in the future, so user code should-    // always-    // handle the default case of a CompletionType that appears after such code-    // was-    // written.-    DO_NOT_USE = 20,-  };-   // Blocking read from queue.-  // For QUEUE_CLOSED, *tag is not changed.-  // For SERVER_RPC_NEW, *tag will be a newly allocated AsyncServerContext.-  // For others, *tag will be the AsyncServerContext of this rpc.-  CompletionType Next(void** tag);+  // Returns true if an event was received, false if the queue is ready+  // for destruction.+  bool Next(void **tag, bool *ok);    // Shutdown has to be called, and the CompletionQueue can only be-  // destructed when the QUEUE_CLOSED message has been read with Next().+  // destructed when false is returned from Next().   void Shutdown(); -  grpc_completion_queue* cq() { return cq_; }+  grpc_completion_queue *cq() { return cq_; }   private:-  grpc_completion_queue* cq_;  // owned+  template <class R>+  friend class ::grpc::ClientReader;",Added some documentation along these lines.,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/601,25003806,2015-02-19T16:55:00Z,src/node/examples/route_guide_server.js,"@@ -0,0 +1,186 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++var _ = require('underscore');+var grpc = require('..');+var examples = grpc.load(__dirname + '/route_guide.proto').examples;++var Server = grpc.buildServer([examples.RouteGuide.service]);++var COORD_FACTOR = 1e7;++var feature_list = [];++function randomWord(length) {+  var alphabet = 'abcdefghijklmnopqrstuvwxyz';+  var word = '';+  for (var i = 0; i < length; i++) {+    word += alphabet[_.random(0, alphabet.length - 1)];+  }+  return word;+}++function checkFeature(point) {+  var feature;+  for (var i = 0; i < feature_list.length; i++) {+    feature = feature_list[i];+    if (feature.point.latitude === point.latitude &&+        feature.point.longitude === point.longitude) {+      return feature;+    }+  }+  var name;+  if (_.random(0,1) === 0) {+    name = '';+  } else {+    name = randomWord(5);+  }+  feature = {+    name: name,+    location: point+  };+  feature_list.push(feature);+  return feature;+}++function getFeature(call, callback) {+  callback(null, checkFeature(call.request));","Note that there are 3 states here: A feature with an empty name indicates no feature at a location, a feature with a non-empty name indicates that there _is_ a feature at the location, and a feature not found in the list, by my interpretation, is a point not yet checked. The idea is that it is lazily ""discovering"" features whenever a new point comes in.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/601,25003888,2015-02-19T16:56:00Z,src/node/examples/route_guide_server.js,"@@ -0,0 +1,186 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++var _ = require('underscore');+var grpc = require('..');+var examples = grpc.load(__dirname + '/route_guide.proto').examples;++var Server = grpc.buildServer([examples.RouteGuide.service]);++var COORD_FACTOR = 1e7;++var feature_list = [];","That could work, though a serialized proto string would actually be a pain for my library to interpret. I really just chose this implementation because it was simpler.",
6493296,nmittler,https://api.github.com/repos/grpc/grpc/pulls/601,25004281,2015-02-19T17:00:34Z,src/node/examples/route_guide_server.js,"@@ -0,0 +1,186 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++var _ = require('underscore');+var grpc = require('..');+var examples = grpc.load(__dirname + '/route_guide.proto').examples;++var Server = grpc.buildServer([examples.RouteGuide.service]);++var COORD_FACTOR = 1e7;++var feature_list = [];++function randomWord(length) {+  var alphabet = 'abcdefghijklmnopqrstuvwxyz';+  var word = '';+  for (var i = 0; i < length; i++) {+    word += alphabet[_.random(0, alphabet.length - 1)];+  }+  return word;+}++function checkFeature(point) {+  var feature;+  for (var i = 0; i < feature_list.length; i++) {+    feature = feature_list[i];+    if (feature.point.latitude === point.latitude &&+        feature.point.longitude === point.longitude) {+      return feature;+    }+  }+  var name;+  if (_.random(0,1) === 0) {+    name = '';+  } else {+    name = randomWord(5);+  }+  feature = {+    name: name,+    location: point+  };+  feature_list.push(feature);+  return feature;+}++function getFeature(call, callback) {+  callback(null, checkFeature(call.request));","I'm fine with the first 2 states, it's the lazy creation that I don't think is appropriate here.  This seems out of spec with the description of the method (and the fact that it's named getXXX and not getOrCreateXXX).",x
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/615,25008305,2015-02-19T17:48:48Z,src/ruby/README.md,"@@ -10,29 +10,30 @@ INSTALLATION PREREQUISITES This requires Ruby 2.x, as the rpc api surface uses keyword args.  -INSTALLING-----------+QUICK - INSTALL+--------------- -- Install the gRPC core library-  TODO: describe this, once the core distribution mechanism is defined.+- Clone this repository.+- Follow the instructions in the [INSTALL](../../INSTALL) to install grpc C core library.","try to unify occurences of ""grpc C core library"" ""gRPC core""",
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/601,25025795,2015-02-19T21:10:13Z,src/node/examples/route_guide_server.js,"@@ -0,0 +1,186 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++var _ = require('underscore');+var grpc = require('..');+var examples = grpc.load(__dirname + '/route_guide.proto').examples;++var Server = grpc.buildServer([examples.RouteGuide.service]);++var COORD_FACTOR = 1e7;++var feature_list = [];","How about this- The server is initialized via simple database of features in a JSON file- The server script takes the path to the JSON file as it only arg- The JSON file a list of json-serialized FeaturesI,e the server does not need to create and cache new features.That should work; and we can use similar files to drive the client when protos are being streamed to the serverDoes that make sense?",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/646,25051635,2015-02-20T06:45:38Z,include/grpc/grpc_security.h,"@@ -73,8 +73,11 @@ typedef struct {  /* Creates an SSL credentials object.    - pem_roots_cert is the NULL-terminated string containing the PEM encoding-     of the server root certificates. If this parameter is NULL, the default-     roots will be used.+     of the server root certificates. If this parameter is NULL, the+     implementation will first try to dereference the file pointed by the+     GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment variable, and if that fails,","Yes we use that in the interop test in gce.On Thu, Feb 19, 2015 at 10:43 PM, Nicolas Noble notifications@github.comwrote:> In include/grpc/grpc_security.h> https://github.com/grpc/grpc/pull/646#discussion_r25051599:> > > @@ -73,8 +73,11 @@ typedef struct {> > > >  /\* Creates an SSL credentials object.> >     - pem_roots_cert is the NULL-terminated string containing the PEM encoding> > -     of the server root certificates. If this parameter is NULL, the default> > -     roots will be used.> > -     of the server root certificates. If this parameter is NULL, the> > -     implementation will first try to dereference the file pointed by the> > -     GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment variable, and if that fails,> > Do we actually use that GRPC_DEFAULT_SSL_ROOTS_FILE_PATH yet ?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/646/files#r25051599.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/657,25090674,2015-02-20T18:28:03Z,src/python/src/grpc/framework/base/packets/_termination.py,"@@ -86,11 +86,15 @@ def __init__(     self._action = action     self._local_failure = local_failure     self._has_locally_failed = False+    self._expiration_manager = None      self._outstanding_requirements = set(requirements)     self._kind = None     self._callbacks = [] +  def set_expiration_manager(self, expiration_manager):",These are peer objects; property to me conveys too much of a sense of one belonging to another rather than equal partners all around.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/668,25105796,2015-02-20T21:45:42Z,src/python/src/grpc/framework/assembly/implementations.py,"@@ -0,0 +1,299 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Implementations for assembling RPC framework values.""""""++import threading++from grpc.framework.assembly import interfaces+from grpc.framework.base import util as base_utilities+from grpc.framework.base.packets import implementations as tickets_implementations+from grpc.framework.base.packets import interfaces as tickets_interfaces+from grpc.framework.common import cardinality+from grpc.framework.common import style+from grpc.framework.face import implementations as face_implementations+from grpc.framework.face import interfaces as face_interfaces+from grpc.framework.face import utilities as face_utilities+from grpc.framework.foundation import activated+from grpc.framework.foundation import logging_pool++_ONE_DAY_IN_SECONDS = 60 * 60 * 24+_THREAD_POOL_SIZE = 100+++class _FaceStub(object):++  def __init__(self, rear_link):+    self._rear_link = rear_link+    self._lock = threading.Lock()+    self._pool = None+    self._front = None+    self._under_stub = None++  def __enter__(self):+    with self._lock:+      self._pool = logging_pool.pool(_THREAD_POOL_SIZE)+      self._front = tickets_implementations.front(+          self._pool, self._pool, self._pool)+      self._rear_link.start()+      self._rear_link.join_fore_link(self._front)+      self._front.join_rear_link(self._rear_link)+      self._under_stub = face_implementations.stub(self._front, self._pool)++  def __exit__(self, exc_type, exc_val, exc_tb):+    with self._lock:+      self._under_stub = None+      self._rear_link.stop()+      base_utilities.wait_for_idle(self._front)+      self._front = None+      self._pool.shutdown(wait=True)+      self._pool = None+    return False++  def __getattr__(self, attr):+    with self._lock:+      if self._under_stub is None:+        raise ValueError('Called out of context!')+      else:+        return getattr(self._under_stub, attr)+++def _behaviors(implementations, front, pool):+  behaviors = {}+  stub = face_implementations.stub(front, pool)+  for name, implementation in implementations.iteritems():+    if implementation.cardinality is cardinality.Cardinality.UNARY_UNARY:+      behaviors[name] = stub.unary_unary_sync_async(name)+    elif implementation.cardinality is cardinality.Cardinality.UNARY_STREAM:+      behaviors[name] = lambda request, context, bound_name=name: (+          stub.inline_value_in_stream_out(bound_name, request, context))+    elif implementation.cardinality is cardinality.Cardinality.STREAM_UNARY:+      behaviors[name] = stub.stream_unary_sync_async(name)+    elif implementation.cardinality is cardinality.Cardinality.STREAM_STREAM:+      behaviors[name] = lambda request_iterator, context, bound_name=name: (+          stub.inline_stream_in_stream_out(+              bound_name, request_iterator, context))+  return behaviors+++class _DynamicInlineStub(object):++  def __init__(self, implementations, rear_link):+    self._implementations = implementations+    self._rear_link = rear_link+    self._lock = threading.Lock()+    self._pool = None+    self._front = None+    self._behaviors = None++  def __enter__(self):+    with self._lock:+      self._pool = logging_pool.pool(_THREAD_POOL_SIZE)+      self._front = tickets_implementations.front(+          self._pool, self._pool, self._pool)+      self._rear_link.start()+      self._rear_link.join_fore_link(self._front)+      self._front.join_rear_link(self._rear_link)+      self._behaviors = _behaviors(+          self._implementations, self._front, self._pool)+      return self++  def __exit__(self, exc_type, exc_val, exc_tb):+    with self._lock:+      self._behaviors = None+      self._rear_link.stop()+      base_utilities.wait_for_idle(self._front)+      self._front = None+      self._pool.shutdown(wait=True)+      self._pool = None+    return False++  def __getattr__(self, attr):+    with self._lock:+      behavior = self._behaviors.get(attr)+      if behavior is None:+        raise AttributeError(attr)+      else:+        return behavior+++def _servicer(implementations, pool):+  inline_value_in_value_out_methods = {}+  inline_value_in_stream_out_methods = {}+  inline_stream_in_value_out_methods = {}+  inline_stream_in_stream_out_methods = {}+  event_value_in_value_out_methods = {}+  event_value_in_stream_out_methods = {}+  event_stream_in_value_out_methods = {}+  event_stream_in_stream_out_methods = {}++  for name, implementation in implementations.iteritems():+    if implementation.cardinality is cardinality.Cardinality.UNARY_UNARY:+      if implementation.style is style.Service.INLINE:+        inline_value_in_value_out_methods[name] = (+            face_utilities.inline_unary_unary_method(implementation.unary_unary_inline))",Do we care about long lines yet?,x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/668,25106251,2015-02-20T21:52:06Z,src/python/src/grpc/framework/assembly/interfaces.py,"@@ -0,0 +1,91 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# TODO(nathaniel): The assembly layer only exists to smooth out wrinkles in+# the face layer. The two should be squashed together as soon as manageable.+""""""Interfaces for assembling RPC Framework values.""""""++import abc++# cardinality, style, and stream are referenced from specification in this+# module.","This is the exact text used to indicate imports-used-only-in-docs throughout src/python, so if it were to change I'd like it to be done in one large cleanup change separately.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/668,25106812,2015-02-20T21:59:59Z,src/python/src/grpc/framework/assembly/implementations.py,"@@ -0,0 +1,299 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Implementations for assembling RPC framework values.""""""++import threading++from grpc.framework.assembly import interfaces+from grpc.framework.base import util as base_utilities+from grpc.framework.base.packets import implementations as tickets_implementations+from grpc.framework.base.packets import interfaces as tickets_interfaces","When I get around to renaming the package, I will drop the ess (""packets -> ticket""). In some places I'm diligent about anticipating that and in some places I'm not. Can't wait to finally get around to doing it though. :-)",x
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/669,25107443,2015-02-20T22:09:04Z,examples/pubsub/pubsub.proto,"@@ -467,7 +462,7 @@ message Subscription {   // If <code>query</code> is non-empty, only messages on the subscriber's   // topic whose labels match the query will be returned. Otherwise all   // messages on the topic will be returned.-  // (-- The query syntax is described in tech/label/proto/label_query.proto --)+  // (-- The query syntax is described in label_query.proto --)","Do you think we should just delete the line? I think this is the best way to preserve information and when label_query goes public, users can find them. But this file is temporary anyway, so either way is fine to me.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/668,25108322,2015-02-20T22:21:46Z,src/python/src/grpc/framework/assembly/implementations.py,"@@ -0,0 +1,299 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Implementations for assembling RPC framework values.""""""++import threading++from grpc.framework.assembly import interfaces+from grpc.framework.base import util as base_utilities+from grpc.framework.base.packets import implementations as tickets_implementations+from grpc.framework.base.packets import interfaces as tickets_interfaces+from grpc.framework.common import cardinality+from grpc.framework.common import style+from grpc.framework.face import implementations as face_implementations+from grpc.framework.face import interfaces as face_interfaces+from grpc.framework.face import utilities as face_utilities+from grpc.framework.foundation import activated+from grpc.framework.foundation import logging_pool++_ONE_DAY_IN_SECONDS = 60 * 60 * 24+_THREAD_POOL_SIZE = 100+++class _FaceStub(object):++  def __init__(self, rear_link):+    self._rear_link = rear_link+    self._lock = threading.Lock()+    self._pool = None+    self._front = None+    self._under_stub = None++  def __enter__(self):+    with self._lock:+      self._pool = logging_pool.pool(_THREAD_POOL_SIZE)+      self._front = tickets_implementations.front(+          self._pool, self._pool, self._pool)+      self._rear_link.start()+      self._rear_link.join_fore_link(self._front)+      self._front.join_rear_link(self._rear_link)+      self._under_stub = face_implementations.stub(self._front, self._pool)++  def __exit__(self, exc_type, exc_val, exc_tb):+    with self._lock:+      self._under_stub = None+      self._rear_link.stop()+      base_utilities.wait_for_idle(self._front)+      self._front = None+      self._pool.shutdown(wait=True)+      self._pool = None+    return False++  def __getattr__(self, attr):+    with self._lock:+      if self._under_stub is None:+        raise ValueError('Called out of context!')+      else:+        return getattr(self._under_stub, attr)+++def _behaviors(implementations, front, pool):+  behaviors = {}+  stub = face_implementations.stub(front, pool)+  for name, implementation in implementations.iteritems():+    if implementation.cardinality is cardinality.Cardinality.UNARY_UNARY:+      behaviors[name] = stub.unary_unary_sync_async(name)+    elif implementation.cardinality is cardinality.Cardinality.UNARY_STREAM:+      behaviors[name] = lambda request, context, bound_name=name: (+          stub.inline_value_in_stream_out(bound_name, request, context))+    elif implementation.cardinality is cardinality.Cardinality.STREAM_UNARY:+      behaviors[name] = stub.stream_unary_sync_async(name)+    elif implementation.cardinality is cardinality.Cardinality.STREAM_STREAM:+      behaviors[name] = lambda request_iterator, context, bound_name=name: (+          stub.inline_stream_in_stream_out(+              bound_name, request_iterator, context))+  return behaviors+++class _DynamicInlineStub(object):++  def __init__(self, implementations, rear_link):+    self._implementations = implementations+    self._rear_link = rear_link+    self._lock = threading.Lock()+    self._pool = None+    self._front = None+    self._behaviors = None++  def __enter__(self):+    with self._lock:+      self._pool = logging_pool.pool(_THREAD_POOL_SIZE)+      self._front = tickets_implementations.front(+          self._pool, self._pool, self._pool)+      self._rear_link.start()+      self._rear_link.join_fore_link(self._front)+      self._front.join_rear_link(self._rear_link)+      self._behaviors = _behaviors(+          self._implementations, self._front, self._pool)+      return self++  def __exit__(self, exc_type, exc_val, exc_tb):+    with self._lock:+      self._behaviors = None+      self._rear_link.stop()+      base_utilities.wait_for_idle(self._front)+      self._front = None+      self._pool.shutdown(wait=True)+      self._pool = None+    return False++  def __getattr__(self, attr):+    with self._lock:+      behavior = self._behaviors.get(attr)+      if behavior is None:+        raise AttributeError(attr)+      else:+        return behavior+++def _servicer(implementations, pool):+  inline_value_in_value_out_methods = {}+  inline_value_in_stream_out_methods = {}+  inline_stream_in_value_out_methods = {}+  inline_stream_in_stream_out_methods = {}+  event_value_in_value_out_methods = {}+  event_value_in_stream_out_methods = {}+  event_stream_in_value_out_methods = {}+  event_stream_in_stream_out_methods = {}++  for name, implementation in implementations.iteritems():+    if implementation.cardinality is cardinality.Cardinality.UNARY_UNARY:+      if implementation.style is style.Service.INLINE:+        inline_value_in_value_out_methods[name] = (+            face_utilities.inline_unary_unary_method(implementation.unary_unary_inline))+      elif implementation.style is style.Service.EVENT:+        event_value_in_value_out_methods[name] = (+            face_utilities.event_unary_unary_method(implementation.unary_unary_event))+    elif implementation.cardinality is cardinality.Cardinality.UNARY_STREAM:+      if implementation.style is style.Service.INLINE:+        inline_value_in_stream_out_methods[name] = (+            face_utilities.inline_unary_stream_method(implementation.unary_stream_inline))+      elif implementation.style is style.Service.EVENT:+        event_value_in_stream_out_methods[name] = (+            face_utilities.event_unary_stream_method(implementation.unary_stream_event))+    if implementation.cardinality is cardinality.Cardinality.STREAM_UNARY:+      if implementation.style is style.Service.INLINE:+        inline_stream_in_value_out_methods[name] = (+            face_utilities.inline_stream_unary_method(implementation.stream_unary_inline))+      elif implementation.style is style.Service.EVENT:+        event_stream_in_value_out_methods[name] = (+            face_utilities.event_stream_unary_method(implementation.stream_unary_event))+    elif implementation.cardinality is cardinality.Cardinality.STREAM_STREAM:+      if implementation.style is style.Service.INLINE:+        inline_stream_in_stream_out_methods[name] = (+            face_utilities.inline_stream_stream_method(implementation.stream_stream_inline))+      elif implementation.style is style.Service.EVENT:+        event_stream_in_stream_out_methods[name] = (+            face_utilities.event_stream_stream_method(implementation.stream_stream_event))++  return face_implementations.servicer(+      pool,+      inline_value_in_value_out_methods=inline_value_in_value_out_methods,+      inline_value_in_stream_out_methods=inline_value_in_stream_out_methods,+      inline_stream_in_value_out_methods=inline_stream_in_value_out_methods,+      inline_stream_in_stream_out_methods=inline_stream_in_stream_out_methods,+      event_value_in_value_out_methods=event_value_in_value_out_methods,+      event_value_in_stream_out_methods=event_value_in_stream_out_methods,+      event_stream_in_value_out_methods=event_stream_in_value_out_methods,+      event_stream_in_stream_out_methods=event_stream_in_stream_out_methods)+++class _ServiceAssembly(activated.Activated):++  def __init__(self, implementations, fore_link):+    self._implementations = implementations+    self._fore_link = fore_link+    self._lock = threading.Lock()+    self._pool = None+    self._back = None++  def _start(self):+    with self._lock:+      self._pool = logging_pool.pool(_THREAD_POOL_SIZE)+      servicer = _servicer(self._implementations, self._pool)+      self._back = tickets_implementations.back(+          servicer, self._pool, self._pool, self._pool, _ONE_DAY_IN_SECONDS,+          _ONE_DAY_IN_SECONDS)+      self._fore_link.start()+      self._fore_link.join_rear_link(self._back)+      self._back.join_fore_link(self._fore_link)++  def _stop(self):+    with self._lock:+      self._fore_link.stop()+      base_utilities.wait_for_idle(self._back)+      self._back = None+      self._pool.shutdown(wait=True)+      self._pool = None++  def __enter__(self):+    self._start()+    return self++  def __exit__(self, exc_type, exc_val, exc_tb):+    self._stop()+    return False++  def start(self):+    return self._start()++  def stop(self):+    self._stop()+++def assemble_face_stub(rear_link):+  """"""Assembles a face_interfaces.Stub.++  The returned object is a context manager and may only be used in context to+  invoke RPCs.++  Args:+    rear_link: A tickets_interfaces.RearLink-activated.Activated object.",The and was intended. I've clarified the comments and added the proper (though by happenstance uncalled) **enter** and **exit** to the test pipe class.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/692,25118261,2015-02-21T02:29:24Z,test/compiler/python_plugin_test.py,"@@ -0,0 +1,451 @@+import argparse+import contextlib+import errno+import itertools+import os+from os import path","Import only modules, not functions, classes, or other elements of modules. In this case you've already imported os, so just change your code to access this function as os.path.",x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/692,25118314,2015-02-21T02:32:35Z,test/compiler/python_plugin_test.py,"@@ -0,0 +1,451 @@+import argparse+import contextlib+import errno+import itertools+import os+from os import path+import subprocess+import sys+import time+import unittest++from grpc.framework.face import exceptions+from grpc.framework.foundation import future++# Assigned if __main__.+_build_mode = None+++def CreateService(test_pb2, delay=0, timeout=1):+  """"""Provides a servicer backend and a stub.++  The servicer is just the implementation+  of the actual servicer passed to the face player of the python RPC+  implementation; the two are detached.++  Non-zero delay puts a delay on each call to the servicer, representative of+  communication latency. Timeout is the default timeout for the stub while+  waiting for the service.++  Args:+    test_pb2: the test_pb2 module generated by this test+    delay: delay in seconds per response from the servicer+    timeout: how long the stub will wait for the servicer by default.+  Returns:+    A two-tuple (servicer, stub), where the servicer is the back-end of the+      service bound to the stub.+  """"""++  class ServicerMethods(object):","Why is this class nested inside this function? Before answering, review the first two rules of Code Review Club: (0) Is-Only-Ever-Used-From Does Not Imply Should-Be-Syntactically-Nested-Inside, and (1)  Is-Only-Ever-Used-From Does Not Imply Should-Be-Syntactically-Nested-Inside.",x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/692,25118344,2015-02-21T02:35:32Z,test/compiler/python_plugin_test.py,"@@ -0,0 +1,451 @@+import argparse+import contextlib+import errno+import itertools+import os+from os import path+import subprocess+import sys+import time+import unittest++from grpc.framework.face import exceptions+from grpc.framework.foundation import future++# Assigned if __main__.+_build_mode = None+++def CreateService(test_pb2, delay=0, timeout=1):+  """"""Provides a servicer backend and a stub.++  The servicer is just the implementation+  of the actual servicer passed to the face player of the python RPC+  implementation; the two are detached.++  Non-zero delay puts a delay on each call to the servicer, representative of+  communication latency. Timeout is the default timeout for the stub while+  waiting for the service.++  Args:+    test_pb2: the test_pb2 module generated by this test+    delay: delay in seconds per response from the servicer+    timeout: how long the stub will wait for the servicer by default.+  Returns:+    A two-tuple (servicer, stub), where the servicer is the back-end of the+      service bound to the stub.+  """"""++  class ServicerMethods(object):++    def __init__(self):+      self._paused = False+      self._failed = False++    @contextlib.contextmanager+    def pause(self):  # pylint: disable=invalid-name+      self._paused = True+      yield+      self._paused = False++    @contextlib.contextmanager+    def fail(self):  # pylint: disable=invalid-name+      self._failed = True+      yield+      self._failed = False++    def _control(self):  # pylint: disable=invalid-name+      if self._failed:+        raise ValueError()+      time.sleep(delay)+      while self._paused:+        time.sleep(0)++    def UnaryCall(self, request):+      response = test_pb2.SimpleResponse()+      response.payload.payload_type = test_pb2.COMPRESSABLE+      response.payload.payload_compressable = 'a' * request.response_size+      self._control()+      return response++    def StreamingOutputCall(self, request):+      for parameter in request.response_parameters:+        response = test_pb2.StreamingOutputCallResponse()+        response.payload.payload_type = test_pb2.COMPRESSABLE+        response.payload.payload_compressable = 'a' * parameter.size+        self._control()+        yield response++    def StreamingInputCall(self, request_iter):+      response = test_pb2.StreamingInputCallResponse()+      aggregated_payload_size = 0+      for request in request_iter:+        aggregated_payload_size += len(request.payload.payload_compressable)+      response.aggregated_payload_size = aggregated_payload_size+      self._control()+      return response++    def FullDuplexCall(self, request_iter):+      for request in request_iter:+        for parameter in request.response_parameters:+          response = test_pb2.StreamingOutputCallResponse()+          response.payload.payload_type = test_pb2.COMPRESSABLE+          response.payload.payload_compressable = 'a' * parameter.size+          self._control()+          yield response++    def HalfDuplexCall(self, request_iter):+      responses = []+      for request in request_iter:+        for parameter in request.response_parameters:+          response = test_pb2.StreamingOutputCallResponse()+          response.payload.payload_type = test_pb2.COMPRESSABLE+          response.payload.payload_compressable = 'a' * parameter.size+          self._control()+          responses.append(response)+      for response in responses:+        yield response++  servicer_methods = ServicerMethods()++  class Servicer(test_pb2.TestServiceServicer):",Another class better factored out for the low-low price of one construction parameter and one instance field.,x
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/709,25136486,2015-02-22T21:07:57Z,src/python/src/grpc/_adapter/fore.py,"@@ -353,3 +356,90 @@ def accept_back_to_front_ticket(self, ticket):         self._complete(ticket.operation_id, ticket.payload)       else:         self._cancel(ticket.operation_id)+++class _ActivatedForeLink(ticket_interfaces.ForeLink, activated.Activated):++  def __init__(+      self, port, request_deserializers, response_serializers,+      root_certificates, key_chain_pairs):+    self._port = port+    self._request_deserializers = request_deserializers+    self._response_serializers = response_serializers+    self._root_certificates = root_certificates+    self._key_chain_pairs = key_chain_pairs++    self._lock = threading.Lock()+    self._pool = None+    self._fore_link = None+    self._rear_link = null.NULL_REAR_LINK++  def join_rear_link(self, rear_link):+    with self._lock:+      self._rear_link = null.NULL_REAR_LINK if rear_link is None else rear_link+      if self._fore_link is not None:+        self._fore_link.join_rear_link(rear_link)++  def _start(self):+    with self._lock:+      self._pool = logging_pool.pool(_THREAD_POOL_SIZE)+      self._fore_link = ForeLink(+          self._pool, self._request_deserializers, self._response_serializers,+          self._root_certificates, self._key_chain_pairs, port=self._port)+      self._fore_link.join_rear_link(self._rear_link)+      self._fore_link.start()+      return self++  def _stop(self):+    with self._lock:+      self._fore_link.stop()+      self._fore_link = None+      self._pool.shutdown(wait=True)+      self._pool = None++  def __enter__(self):+    return self._start()++  def __exit__(self, exc_type, exc_val, exc_tb):+    self._stop()+    return False++  def start(self):+    return self._start()++  def stop(self):+    self._stop()++  def port(self):+    with self._lock:+      return None if self._fore_link is None else self._fore_link.port()++  def accept_back_to_front_ticket(self, ticket):+    with self._lock:+      if self._fore_link is not None:+        self._fore_link.accept_back_to_front_ticket(ticket)+++def activated_fore_link(","When we were discussing the arguments to the imminent-future-modified code-generated `create_*_server` function, there was only one `sec` (security) argument at the tail end of the signature. How should I extract `root_certificates` and `key_chain_pairs` from that argument to acquire the activated fore link to pass to `assembly.implementations.assemble_service`?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/711,25183137,2015-02-23T17:33:13Z,src/cpp/client/channel.h,"@@ -51,10 +51,7 @@ class StreamContextInterface;  class Channel final : public ChannelInterface {  public:-  Channel(const grpc::string &target, const ChannelArguments &args);-  Channel(const grpc::string &target, const std::unique_ptr<Credentials> &creds,-          const ChannelArguments &args);-+  Channel(const grpc::string &target, grpc_channel *c_channel);",I should put a big TODO on formatting this stuff :),x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/739,25262222,2015-02-24T15:49:10Z,src/compiler/python_generator.cc,"@@ -164,147 +186,169 @@ void PrintStub(const ServiceDescriptor* service,   } } -void PrintStubImpl(const ServiceDescriptor* service,-                   Printer* out) {+void PrintServerFactory(const ServiceDescriptor* service, Printer* out) {   map<string, string> dict = ListToDict({         ""Service"", service->name(),       });-  out->Print(dict, ""class _$Service$Stub($Service$Stub):\n"");+  out->Print(dict, ""def early_adopter_create_$Service$_server(servicer, port, ""+             ""root_certificates, key_chain_pairs):\n"");   {-    IndentScope raii_class_indent(out);-    out->Print(""def __init__(self, face_stub, default_timeout):\n"");-    {-      IndentScope raii_method_indent(out);-      out->Print(""self._face_stub = face_stub\n""-                 ""self._default_timeout = default_timeout\n""-                 ""stub_self = self\n"");--      for (int i = 0; i < service->method_count(); ++i) {-        const MethodDescriptor* meth = service->method(i);-        bool server_streaming = meth->server_streaming();-        bool client_streaming = meth->client_streaming();-        std::string blocking_call, future_call;-        if (server_streaming) {-          if (client_streaming) {-            blocking_call = ""stub_self._face_stub.inline_stream_in_stream_out"";-            future_call = blocking_call;-          } else {-            blocking_call = ""stub_self._face_stub.inline_value_in_stream_out"";-            future_call = blocking_call;-          }-        } else {-          if (client_streaming) {-            blocking_call = ""stub_self._face_stub.blocking_stream_in_value_out"";-            future_call = ""stub_self._face_stub.future_stream_in_value_out"";-          } else {-            blocking_call = ""stub_self._face_stub.blocking_value_in_value_out"";-            future_call = ""stub_self._face_stub.future_value_in_value_out"";-          }-        }-        // TODO(atash): use the solution described at-        // http://stackoverflow.com/a/2982 to bind 'async' attribute-        // functions to def'd functions instead of using callable attributes.-        auto methdict = ListToDict({-          ""Method"", meth->name(),-          ""BlockingCall"", blocking_call,-          ""FutureCall"", future_call-        });-        out->Print(methdict, ""class $Method$(object):\n"");-        {-          IndentScope raii_callable_indent(out);-          out->Print(""def __call__(self, arg):\n"");-          {-            IndentScope raii_callable_call_indent(out);-            out->Print(methdict,-                       ""return $BlockingCall$(\""$Method$\"", arg, ""-                       ""stub_self._default_timeout)\n"");-          }-          out->Print(""def async(self, arg):\n"");-          {-            IndentScope raii_callable_async_indent(out);-            out->Print(methdict,-                       ""return $FutureCall$(\""$Method$\"", arg, ""-                       ""stub_self._default_timeout)\n"");-          }-        }-        out->Print(methdict, ""self.$Method$ = $Method$()\n"");+    IndentScope raii_create_server_indent(out);+    map<string, pair<string, string>> method_to_module_and_message;+    out->Print(""method_implementations = {\n"");+    for (int i = 0; i < service->method_count(); ++i) {+      IndentScope raii_implementations_indent(out);+      const MethodDescriptor* meth = service->method(i);+      string meth_type =+          string(meth->client_streaming() ? ""stream"" : ""unary"") ++          string(meth->server_streaming() ? ""_stream"" : ""_unary"") + ""_inline"";+      map<string, string> methdict = ListToDict({+            ""Method"", meth->name(),+            ""Type"", meth_type+          });+      out->Print(methdict,+                 ""\""$Method$\"": utilities.$Type$(servicer.$Method$),\n"");+      // Maintain information on the input type of the service method for later+      // use in constructing the service assembly's activated fore link.+      const Descriptor* input_type = meth->input_type();+      const Descriptor* path_elem_type = input_type;+      vector<const Descriptor*> message_path;+      do {+        message_path.push_back(path_elem_type);+      } while ((path_elem_type = path_elem_type->containing_type()) != nullptr);+      string file_name = input_type->file()->name();+      string module_name;+      static const int proto_suffix_length = 6;  // length of "".proto""+      assert(file_name.size() > static_cast<size_t>(proto_suffix_length) &&+          file_name.find_last_of("".proto"") == file_name.size() - 1);+        module_name = file_name.substr(+            0, file_name.size() - proto_suffix_length) + ""_pb2"";+      string package = input_type->file()->package();+      string module = (package.empty() ? """" : package + ""."") ++          module_name;+      string message_type;+      for (auto path_iter = message_path.rbegin();+           path_iter != message_path.rend(); ++path_iter) {+        message_type += (*path_iter)->name() + ""."";       }+      message_type.pop_back();+      method_to_module_and_message.emplace(meth->name(),+                                           make_pair(module, message_type));+    }+    out->Print(""}\n"");+    // Ensure that we've imported all of the relevant messages.+    for (auto& meth_vals : method_to_module_and_message) {+      out->Print(""import $Module$\n"", ""Module"", meth_vals.second.first);+    }+    out->Print(""request_deserializers = {\n"");+    for (auto& meth_vals : method_to_module_and_message) {+      IndentScope raii_serializers_indent(out);+      string full_input_type_path = meth_vals.second.first + ""."" ++          meth_vals.second.second;+      out->Print(""\""$Method$\"": $Type$.FromString,\n"",+                 ""Method"", meth_vals.first,+                 ""Type"", full_input_type_path);     }+    out->Print(""}\n"");+    out->Print(""response_serializers = {\n"");+    for (auto& meth_vals : method_to_module_and_message) {+      IndentScope raii_serializers_indent(out);+      out->Print(""\""$Method$\"": lambda x: x.SerializeToString(),\n"",+                 ""Method"", meth_vals.first);+    }+    out->Print(""}\n"");+    out->Print(""link = fore.activated_fore_link(port, request_deserializers, ""+               ""response_serializers, root_certificates, key_chain_pairs)\n"");+    out->Print(""return implementations.assemble_service(""+               ""method_implementations, link)\n"");   } } -void PrintStubGenerators(const ServiceDescriptor* service, Printer* out) {+void PrintStubFactory(const ServiceDescriptor* service, Printer* out) {   map<string, string> dict = ListToDict({         ""Service"", service->name(),       });-  // Write out a generator of linked pairs of Server/Stub-  out->Print(dict, ""def mock_$Service$(servicer, default_timeout):\n"");+  out->Print(dict, ""def early_adopter_create_$Service$_stub(host, port):\n"");   {-    IndentScope raii_mock_indent(out);-    out->Print(""value_in_value_out = {}\n""-               ""value_in_stream_out = {}\n""-               ""stream_in_value_out = {}\n""-               ""stream_in_stream_out = {}\n"");+    IndentScope raii_create_server_indent(out);+    map<string, pair<string, string>> method_to_module_and_message;+    out->Print(""method_implementations = {\n"");     for (int i = 0; i < service->method_count(); ++i) {+      IndentScope raii_implementations_indent(out);       const MethodDescriptor* meth = service->method(i);-      std::string super_interface, meth_dict;-      bool server_streaming = meth->server_streaming();-      bool client_streaming = meth->client_streaming();-      if (server_streaming) {-        if (client_streaming) {-          super_interface = ""InlineStreamInStreamOutMethod"";-          meth_dict = ""stream_in_stream_out"";-        } else {-          super_interface = ""InlineValueInStreamOutMethod"";-          meth_dict = ""value_in_stream_out"";-        }-      } else {-        if (client_streaming) {-          super_interface = ""InlineStreamInValueOutMethod"";-          meth_dict = ""stream_in_value_out"";-        } else {-          super_interface = ""InlineValueInValueOutMethod"";-          meth_dict = ""value_in_value_out"";-        }-      }+      string meth_type =+          string(meth->client_streaming() ? ""stream"" : ""unary"") ++          string(meth->server_streaming() ? ""_stream"" : ""_unary"") + ""_inline"";       map<string, string> methdict = ListToDict({             ""Method"", meth->name(),-            ""SuperInterface"", super_interface,-            ""MethodDict"", meth_dict+            ""Type"", meth_type           });-      out->Print(-          methdict, ""class $Method$(_face_interfaces.$SuperInterface$):\n"");-      {-        IndentScope raii_inline_class_indent(out);-        out->Print(""def service(self, request, context):\n"");-        {-          IndentScope raii_inline_class_fn_indent(out);-          out->Print(methdict, ""return servicer.$Method$(request)\n"");-        }+      // TODO(atash): once the expected input to assemble_dynamic_inline_stub is+      // cleaned up, change this to the expected argument's dictionary values.+      out->Print(methdict, ""\""$Method$\"": utilities.$Type$(None),\n"");+      // Maintain information on the input type of the service method for later+      // use in constructing the service assembly's activated fore link.+      const Descriptor* output_type = meth->output_type();+      const Descriptor* path_elem_type = output_type;+      vector<const Descriptor*> message_path;+      do {",Much of this seems to be identical to the previous function: are there opportunities to factor out commonalities? (it's relatively complex code),x
6653712,anthmgoogle,https://api.github.com/repos/grpc/grpc/pulls/710,25289288,2015-02-24T20:28:55Z,include/grpc++/credentials.h,"@@ -86,17 +86,23 @@ struct SslCredentialsOptions { // fail on it. class CredentialsFactory {  public:-  // Builds credentials with reasonable defaults.-  static std::unique_ptr<Credentials> DefaultCredentials();+  // Builds google credentials with reasonable defaults.+  // WARNING: Do NOT use this credentials to connect to a non-google service as+  // this could result in an oauth2 token leak.+  static std::unique_ptr<Credentials> GoogleDefaultCredentials();","We should call this Application Default Credentials to match the feature docs, Search Engine Optimzation etc. Perhaps GoogleApplicationDefaultCredentials is best fitting with the pattern here. This is a bit long, and I think someone else suggested that these methods don't look like factories, so perhaps you could avoid repeating by naming this CredentialsFactory::getGoogleApplicationDefault(). The method name is also consist with the ""auth kit"" name for this (GoogleCredentials::getApplicationDefault).",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/758,25301585,2015-02-24T22:48:56Z,tools/run_tests/jobset.py,"@@ -42,6 +43,9 @@ _DEFAULT_MAX_JOBS = 16 * multiprocessing.cpu_count()  +signal.signal(signal.SIGCHLD, lambda a, b: None)","Replace ""a, b"" with ""unused_<real name>, unused_<other real name>"".",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/758,25301760,2015-02-24T22:51:05Z,tools/run_tests/jobset.py,"@@ -42,6 +43,9 @@ _DEFAULT_MAX_JOBS = 16 * multiprocessing.cpu_count()  +signal.signal(signal.SIGCHLD, lambda a, b: None)","That should have been ""unused_(helpful name), unused_(other helpful name)"" but GitHub ate my angle brackets.",x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/758,25301974,2015-02-24T22:53:43Z,tools/run_tests/jobset.py,"@@ -232,7 +238,7 @@ def reap(self):       if dead: return       message('WAITING', '%d jobs running, %d complete, %d failed' % (           len(self._running), self._completed, self._failures))-      time.sleep(0.1)+      signal.pause()","""Not on windows"" - is that okay? https://docs.python.org/2/library/signal.html#signal.pause",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/758,25302023,2015-02-24T22:54:22Z,tools/run_tests/jobset.py,"@@ -232,7 +238,7 @@ def reap(self):       if dead: return       message('WAITING', '%d jobs running, %d complete, %d failed' % (           len(self._running), self._completed, self._failures))-      time.sleep(0.1)+      signal.pause()","Ok for now... I'll do an 'if windows' at some point I expectOn Tue, Feb 24, 2015 at 2:53 PM Nathaniel Manista notifications@github.comwrote:> In tools/run_tests/jobset.py> https://github.com/grpc/grpc/pull/758#discussion_r25301974:> > > @@ -232,7 +238,7 @@ def reap(self):> >        if dead: return> >        message('WAITING', '%d jobs running, %d complete, %d failed' % (> >            len(self._running), self._completed, self._failures))> > -      time.sleep(0.1)> > -      signal.pause()> > ""Not on windows"" - is that okay?> https://docs.python.org/2/library/signal.html#signal.pause> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/758/files#r25301974.",x
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/739,25309090,2015-02-25T00:47:29Z,src/compiler/python_generator.cc,"@@ -164,147 +186,169 @@ void PrintStub(const ServiceDescriptor* service,   } } -void PrintStubImpl(const ServiceDescriptor* service,-                   Printer* out) {+void PrintServerFactory(const ServiceDescriptor* service, Printer* out) {   map<string, string> dict = ListToDict({         ""Service"", service->name(),       });-  out->Print(dict, ""class _$Service$Stub($Service$Stub):\n"");+  out->Print(dict, ""def early_adopter_create_$Service$_server(servicer, port, ""+             ""root_certificates, key_chain_pairs):\n"");   {-    IndentScope raii_class_indent(out);-    out->Print(""def __init__(self, face_stub, default_timeout):\n"");-    {-      IndentScope raii_method_indent(out);-      out->Print(""self._face_stub = face_stub\n""-                 ""self._default_timeout = default_timeout\n""-                 ""stub_self = self\n"");--      for (int i = 0; i < service->method_count(); ++i) {-        const MethodDescriptor* meth = service->method(i);-        bool server_streaming = meth->server_streaming();-        bool client_streaming = meth->client_streaming();-        std::string blocking_call, future_call;-        if (server_streaming) {-          if (client_streaming) {-            blocking_call = ""stub_self._face_stub.inline_stream_in_stream_out"";-            future_call = blocking_call;-          } else {-            blocking_call = ""stub_self._face_stub.inline_value_in_stream_out"";-            future_call = blocking_call;-          }-        } else {-          if (client_streaming) {-            blocking_call = ""stub_self._face_stub.blocking_stream_in_value_out"";-            future_call = ""stub_self._face_stub.future_stream_in_value_out"";-          } else {-            blocking_call = ""stub_self._face_stub.blocking_value_in_value_out"";-            future_call = ""stub_self._face_stub.future_value_in_value_out"";-          }-        }-        // TODO(atash): use the solution described at-        // http://stackoverflow.com/a/2982 to bind 'async' attribute-        // functions to def'd functions instead of using callable attributes.-        auto methdict = ListToDict({-          ""Method"", meth->name(),-          ""BlockingCall"", blocking_call,-          ""FutureCall"", future_call-        });-        out->Print(methdict, ""class $Method$(object):\n"");-        {-          IndentScope raii_callable_indent(out);-          out->Print(""def __call__(self, arg):\n"");-          {-            IndentScope raii_callable_call_indent(out);-            out->Print(methdict,-                       ""return $BlockingCall$(\""$Method$\"", arg, ""-                       ""stub_self._default_timeout)\n"");-          }-          out->Print(""def async(self, arg):\n"");-          {-            IndentScope raii_callable_async_indent(out);-            out->Print(methdict,-                       ""return $FutureCall$(\""$Method$\"", arg, ""-                       ""stub_self._default_timeout)\n"");-          }-        }-        out->Print(methdict, ""self.$Method$ = $Method$()\n"");+    IndentScope raii_create_server_indent(out);+    map<string, pair<string, string>> method_to_module_and_message;+    out->Print(""method_implementations = {\n"");+    for (int i = 0; i < service->method_count(); ++i) {+      IndentScope raii_implementations_indent(out);+      const MethodDescriptor* meth = service->method(i);+      string meth_type =+          string(meth->client_streaming() ? ""stream"" : ""unary"") ++          string(meth->server_streaming() ? ""_stream"" : ""_unary"") + ""_inline"";+      map<string, string> methdict = ListToDict({+            ""Method"", meth->name(),+            ""Type"", meth_type+          });+      out->Print(methdict,+                 ""\""$Method$\"": utilities.$Type$(servicer.$Method$),\n"");+      // Maintain information on the input type of the service method for later+      // use in constructing the service assembly's activated fore link.+      const Descriptor* input_type = meth->input_type();+      const Descriptor* path_elem_type = input_type;+      vector<const Descriptor*> message_path;+      do {+        message_path.push_back(path_elem_type);+      } while ((path_elem_type = path_elem_type->containing_type()) != nullptr);+      string file_name = input_type->file()->name();+      string module_name;+      static const int proto_suffix_length = 6;  // length of "".proto""+      assert(file_name.size() > static_cast<size_t>(proto_suffix_length) &&",Ah - nevermind. Status must be communicated up the call chain.,
1487399,sleevi,https://api.github.com/repos/grpc/grpc/pulls/735,25309918,2015-02-25T01:04:02Z,src/core/tsi/ssl_transport_security.c,"@@ -180,6 +180,28 @@ static void ssl_info_callback(const SSL* ssl, int where, int ret) {   ssl_log_where_info(ssl, where, SSL_CB_HANDSHAKE_DONE, ""HANDSHAKE DONE""); } +/* Returns 1 if name looks like an IP address, 0 otherwise. */+static int looks_like_ip_address(const char *name) {","May be worth documenting the semi-incompleteness of this.The following are treated as ""valid"" IP addresses by browsers:0300.0250.00.010xC0.0Xa8.0x0.0x10000300520000010xc0.052000001(Incidentally, these are all 192.168.0.1)Note this also doesn't handle IPv6 at all. Which also gets messy, with things like [::eeee:192.168.0.1] or [::ffff:0xC0.0Xa8.0x0.0x1]As a rough heuristic though, it seems fine.",x
1487399,sleevi,https://api.github.com/repos/grpc/grpc/pulls/735,25310386,2015-02-25T01:12:10Z,src/core/tsi/ssl_transport_security.c,"@@ -1053,14 +1096,23 @@ static int does_entry_match_name(const char* entry, size_t entry_length,   name_subdomain++; /* Starts after the dot. */   entry += 2;       /* Remove *. */   entry_length -= 2;-  return (!strncmp(entry, name_subdomain, entry_length) &&-          (strlen(name_subdomain) == entry_length));+  name_subdomain_length = strlen(name_subdomain);",Just worth noting this is the second time you call strlen(name_subdomain) (line 1095 being the other place). Perhaps move this to before line 1095 and reuse the variable in the condition?,x
1487399,sleevi,https://api.github.com/repos/grpc/grpc/pulls/776,25317696,2015-02-25T04:40:52Z,src/core/security/security_context.c,"@@ -52,20 +52,33 @@  /* -- Constants. -- */ -/* Defines the cipher suites that we accept. All these cipher suites are-   compliant with TLS 1.2 and use an RSA public key. We prefer GCM over CBC-   and ECDHE-RSA over just RSA. */-#define GRPC_SSL_CIPHER_SUITES                                                 \-  ""ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:AES128-GCM-SHA256:"" \-  ""AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:AES128-""  \-  ""SHA256:AES256-SHA256""- #ifndef INSTALL_PREFIX static const char *installed_roots_path = ""/usr/share/grpc/roots.pem""; #else static const char *installed_roots_path = INSTALL_PREFIX ""/share/grpc/roots.pem""; #endif +/* -- Cipher suites. -- */++/* Defines the cipher suites that we accept by default. All these cipher suites+   are compliant with HTTP2. */+#define GRPC_SSL_CIPHER_SUITES                                                 \+  ""ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:AES128-GCM-SHA256:"" \",Note: there are no plans at present to support AES256-GCM in Chrome/Firefox. The performance vs security tradeoff have led us to conclude it's additional computational complexity for questionable gains.Note that the two non-ECDHE AES-GCMs are also non-compliant with 9.2.2 (see TLS_RSA_WITH_AES_256_GCM_SHA384 and friends as listed in the Appendix A),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/748,25432915,2015-02-26T15:06:54Z,include/grpc++/anonymous_service.h,"@@ -0,0 +1,72 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef __GRPCPP_ANONYMOUS_SERVICE_H_+#define __GRPCPP_ANONYMOUS_SERVICE_H_++#include <grpc++/stream.h>++namespace grpc {++typedef ServerReaderWriter<ByteBuffer, ByteBuffer> GenericServerReaderWriter;++class AnonymousServerContext : public ServerContext {+ public:+  const grpc::string& method() const { return method_; }+  const grpc::string& host() const { return host_; }++ private:+  grpc::string method_;+  grpc::string host_;+};++// Anonymous stubs provide a type-unsafe interface to call gRPC methods+// by name.+class AnonymousService {+ public:+  explicit AnonymousService(CompletionQueue* cq) : cq_(cq) {}++  struct CallDetails {","They are provided via client/server contexts at relevant times. I figureconsistency is a good thing here.On Wed, Feb 25, 2015, 17:18 Feng Li notifications@github.com wrote:> In include/grpc++/anonymous_service.h> https://github.com/grpc/grpc/pull/748#discussion_r25397283:> > > - public:> > -  const grpc::string& method() const { return method_; }> > -  const grpc::string& host() const { return host_; }> >   +> > - private:> > -  grpc::string method_;> > -  grpc::string host_;> >   +};> >   +> >   +// Anonymous stubs provide a type-unsafe interface to call gRPC methods> >   +// by name.> >   +class AnonymousService {> > - public:> > -  explicit AnonymousService(CompletionQueue\* cq) : cq_(cq) {}> >   +> > -  struct CallDetails {> > We also need to access other request headers.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/748/files#r25397283.",
1270,haberman,https://api.github.com/repos/grpc/grpc/pulls/841,25458189,2015-02-26T19:50:04Z,src/compiler/python_generator.cc,"@@ -200,17 +202,16 @@ bool GetModuleAndMessagePath(const Descriptor* type,     path_elem_type = path_elem_type->containing_type();   } while (path_elem_type != nullptr);   string file_name = type->file()->name();-  string module_name;   static const int proto_suffix_length = strlen("".proto"");   if (!(file_name.size() > static_cast<size_t>(proto_suffix_length) &&         file_name.find_last_of("".proto"") == file_name.size() - 1)) {     return false;   }-  module_name = file_name.substr(+  string module = file_name.substr(","Ideally this could call ModuleName() directly instead of re-implementing it:https://github.com/google/protobuf/blob/v3.0.0-alpha-1/src/google/protobuf/compiler/python/python_generator.cc#L87But if that's not possible, it seems better to copy that function verbatim to this file, so it's easier to verify that both contain the same logic.",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/846,25470043,2015-02-26T22:10:40Z,examples/pubsub/publisher_test.cc,"@@ -61,28 +61,28 @@ class PublisherServiceImpl : public tech::pubsub::PublisherService::Service {  public:   Status CreateTopic(::grpc::ServerContext* context,                      const ::tech::pubsub::Topic* request,-                     ::tech::pubsub::Topic* response) override {+                     ::tech::pubsub::Topic* response) GRPC_OVERRIDE {","I think GRPC_... we don't have a GPR in C++ land.On Thu, Feb 26, 2015 at 2:10 PM Nicolas Noble notifications@github.comwrote:> In examples/pubsub/publisher_test.cc> https://github.com/grpc/grpc/pull/846#discussion_r25470001:> > > @@ -61,28 +61,28 @@ class PublisherServiceImpl : public tech::pubsub::PublisherService::Service {> >   public:> >    Status CreateTopic(::grpc::ServerContext\* context,> >                       const ::tech::pubsub::Topic\* request,> > -                     ::tech::pubsub::Topic\* response) override {> > -                     ::tech::pubsub::Topic\* response) GRPC_OVERRIDE {> > Same as above: GRPC_ or GPR_ ?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/846/files#r25470001.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/856,25519284,2015-02-27T16:44:01Z,test/cpp/qps/client_async.cc,"@@ -0,0 +1,337 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <cassert>+#include <functional>+#include <memory>+#include <string>+#include <thread>+#include <vector>+#include <sstream>++#include <grpc/grpc.h>+#include <grpc/support/histogram.h>+#include <grpc/support/log.h>+#include <gflags/gflags.h>+#include <grpc++/async_unary_call.h>+#include <grpc++/client_context.h>+#include <grpc++/status.h>+#include ""test/core/util/grpc_profiler.h""+#include ""test/cpp/util/create_test_channel.h""+#include ""test/cpp/qps/qpstest.pb.h""++DEFINE_bool(enable_ssl, false, ""Whether to use ssl/tls."");+DEFINE_int32(server_port, 0, ""Server port."");+DEFINE_string(server_host, ""127.0.0.1"", ""Server host."");+DEFINE_int32(client_threads, 4, ""Number of client threads."");++// We have a configurable number of channels for sending RPCs.+// RPCs are sent round-robin on the available channels by the+// various threads. Interesting cases are 1 global channel or+// 1 per-thread channel, but we can support any number.+// The channels are assigned round-robin on an RPC by RPC basis+// rather than just at initialization time in order to also measure the+// impact of cache thrashing caused by channel changes. This is an issue+// if you are not in one of the above ""interesting cases""+DEFINE_int32(client_channels, 4, ""Number of client channels."");++DEFINE_int32(num_rpcs, 1000, ""Number of RPCs per thread."");+DEFINE_int32(payload_size, 1, ""Payload size in bytes"");++// Alternatively, specify parameters for test as a workload so that multiple+// tests are initiated back-to-back. This is convenient for keeping a borg+// allocation consistent. This is a space-separated list of+// [threads channels num_rpcs payload_size ]*+DEFINE_string(workload, """", ""Workload parameters"");++using grpc::ChannelInterface;+using grpc::CreateTestChannel;+using grpc::testing::ServerStats;+using grpc::testing::SimpleRequest;+using grpc::testing::SimpleResponse;+using grpc::testing::StatsRequest;+using grpc::testing::TestService;++// In some distros, gflags is in the namespace google, and in some others,+// in gflags. This hack is enabling us to find both.+namespace google {}+namespace gflags {}+using namespace google;+using namespace gflags;++static double now() {+  gpr_timespec tv = gpr_now();+  return 1e9 * tv.tv_sec + tv.tv_nsec;+}++class ClientRpcContext {+ public:+  ClientRpcContext() {}+  virtual ~ClientRpcContext() {}+  virtual bool operator()() = 0;  // do next state, return false if steps done+  static void *tag(ClientRpcContext *c) { return reinterpret_cast<void *>(c); }+  static ClientRpcContext *detag(void *t) {+    return reinterpret_cast<ClientRpcContext *>(t);+  }+  virtual void report_stats(gpr_histogram *hist) = 0;+};+template <class RequestType, class ResponseType>+class ClientRpcContextUnaryImpl : public ClientRpcContext {+ public:+  ClientRpcContextUnaryImpl(+      const RequestType &req,+      std::function<+          std::unique_ptr<grpc::ClientAsyncResponseReader<ResponseType>>(+              grpc::ClientContext *, const RequestType &, void *)> start_req,+      std::function<void(grpc::Status, ResponseType *)> on_done)+      : context_(),+        req_(req),+        response_(),+        next_state_(&ClientRpcContextUnaryImpl::ReqSent),+        callback_(on_done),+        start_(now()),+        response_reader_(+            start_req(&context_, req_, ClientRpcContext::tag(this))) {}+  ~ClientRpcContextUnaryImpl() GRPC_OVERRIDE {}+  bool operator()() GRPC_OVERRIDE { return (this->*next_state_)(); }+  void report_stats(gpr_histogram *hist) GRPC_OVERRIDE {+    gpr_histogram_add(hist, now() - start_);+  }++ private:+  bool ReqSent() {+    next_state_ = &ClientRpcContextUnaryImpl::RespDone;+    response_reader_->Finish(&response_, &status_, ClientRpcContext::tag(this));+    return true;+  }+  bool RespDone() {+    next_state_ = &ClientRpcContextUnaryImpl::DoCallBack;+    return false;+  }+  bool DoCallBack() {+    callback_(status_, &response_);+    return false;+  }+  grpc::ClientContext context_;+  RequestType req_;+  ResponseType response_;+  bool (ClientRpcContextUnaryImpl::*next_state_)();+  std::function<void(grpc::Status, ResponseType *)> callback_;+  grpc::Status status_;+  double start_;+  std::unique_ptr<grpc::ClientAsyncResponseReader<ResponseType>>+      response_reader_;+};++static void RunTest(const int client_threads, const int client_channels,+                    const int num_rpcs, const int payload_size) {+  gpr_log(GPR_INFO,+          ""QPS test with parameters\n""+          ""enable_ssl = %d\n""+          ""client_channels = %d\n""+          ""client_threads = %d\n""+          ""num_rpcs = %d\n""+          ""payload_size = %d\n""+          ""server_host:server_port = %s:%d\n\n"",+          FLAGS_enable_ssl, client_channels, client_threads, num_rpcs,+          payload_size, FLAGS_server_host.c_str(), FLAGS_server_port);++  std::ostringstream oss;+  oss << FLAGS_server_host << "":"" << FLAGS_server_port;++  class ClientChannelInfo {+   public:+    explicit ClientChannelInfo(const grpc::string &server)+        : channel_(CreateTestChannel(server, FLAGS_enable_ssl)),+          stub_(TestService::NewStub(channel_)) {}+    ChannelInterface *get_channel() { return channel_.get(); }+    TestService::Stub *get_stub() { return stub_.get(); }++   private:+    std::shared_ptr<ChannelInterface> channel_;+    std::unique_ptr<TestService::Stub> stub_;+  };++  std::vector<ClientChannelInfo> channels;+  for (int i = 0; i < client_channels; i++) {+    channels.push_back(ClientChannelInfo(oss.str()));+  }++  std::vector<std::thread> threads;  // Will add threads when ready to execute+  std::vector< ::gpr_histogram *> thread_stats(client_threads);++  TestService::Stub *stub_stats = channels[0].get_stub();+  grpc::ClientContext context_stats_begin;+  StatsRequest stats_request;+  ServerStats server_stats_begin;+  stats_request.set_test_num(0);+  grpc::Status status_beg = stub_stats->CollectServerStats(+      &context_stats_begin, stats_request, &server_stats_begin);++  grpc_profiler_start(""qps_client_async.prof"");++  auto CheckDone = [=](grpc::Status s, SimpleResponse *response) {+    GPR_ASSERT(s.IsOk() && (response->payload().type() ==+                            grpc::testing::PayloadType::COMPRESSABLE) &&+               (response->payload().body().length() ==+                static_cast<size_t>(payload_size)));+  };++  for (int i = 0; i < client_threads; i++) {+    gpr_histogram *hist = gpr_histogram_create(0.01, 60e9);+    GPR_ASSERT(hist != NULL);+    thread_stats[i] = hist;++    threads.push_back(std::thread(+        [hist, client_threads, client_channels, num_rpcs, payload_size,+         &channels, &CheckDone](int channel_num) {+          using namespace std::placeholders;+          SimpleRequest request;+          request.set_response_type(grpc::testing::PayloadType::COMPRESSABLE);+          request.set_response_size(payload_size);++          grpc::CompletionQueue cli_cq;++          int rpcs_sent = 0;+          while (rpcs_sent < num_rpcs) {+            rpcs_sent++;+            TestService::Stub *stub = channels[channel_num].get_stub();+            grpc::ClientContext context;+            auto start_req = std::bind(&TestService::Stub::AsyncUnaryCall, stub,","Right now the bind captures stub, which changes on each iteration of the main loop. I could change the constructor instead to make stub an argument; I had tried to avoid that, but maybe it's not a big deal. This PR or the next?",x
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/908,25614248,2015-03-02T16:52:54Z,src/core/surface/init_secure.c,"@@ -0,0 +1,42 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/surface/init.h""+#include ""src/core/debug/trace.h""+#include ""src/core/security/secure_endpoint.h""+#include ""src/core/tsi/transport_security_interface.h""++void grpc_security_pre_init(void) {+  grpc_register_tracer(""secure_endpoint"", &grpc_trace_secure_endpoint);+  grpc_register_tracer(""ssl"", &tsi_tracing_enabled);","I'm a little concerned about the name ""ssl"". It could be more general than that as we may have other implementations for transport security. How about ""transport_security"" (I know, it's longer to type...).",x
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/885,25620224,2015-03-02T17:53:20Z,tools/gce_setup/launch_servers.sh,"@@ -0,0 +1,45 @@+#!/bin/bash+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+++main() {+  # restart builder vm and wait for images to sync to it+  source grpc_docker.sh++  # build images for all languages+  languages=(cxx java go ruby node python)+  for lan in ""${languages[@]}""","this loop is unnecessary, this could just be grpc_launch_servers grpc-docker-server[grpc_launch_servers](https://github.com/grpc/grpc/blob/master/tools/gce_setup/grpc_docker.sh#L665) assumes that every arg after the first args is language; and if there are none it assumes it should launch all known languages.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/912,25625030,2015-03-02T18:46:10Z,src/core/transport/chttp2_transport.c,"@@ -516,13 +517,23 @@ static void init_transport(transport *t, grpc_transport_setup_callback setup, static void destroy_transport(grpc_transport *gt) {   transport *t = (transport *)gt; -  gpr_mu_lock(&t->mu);+  lock(t);   t->destroying = 1;-  while (t->calling_back) {+  /* Wait for pending stuff to finish.+     We need to be not calling back to ensure that closed() gets a chance to+     trigger if needed during unlock() before we die.+     We need to be not writing as cancellation finalization may produce some+     callbacks that NEED to be made to close out some streams when t->writing+     becomes 0. */+  while (t->calling_back || t->writing) {     gpr_cv_wait(&t->cv, &t->mu, gpr_inf_future);   }-  t->cb = NULL;-  gpr_mu_unlock(&t->mu);+  drop_connection(t);+  unlock(t);++  lock(t);+  GPR_ASSERT(!t->cb);",Why do we have to drop the lock and re-lock to do that assert ? Can't we do it in the same blob above ? Or is the assert about testing if the callback isn't lost between the locks ?,x
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/909,25625791,2015-03-02T18:54:04Z,src/compiler/python_generator.cc,"@@ -237,54 +237,70 @@ bool PrintServerFactory(const ServiceDescriptor* service, Printer* out) {              ""Service"", service->name());   {     IndentScope raii_create_server_indent(out);-    map<string, pair<string, string>> method_to_module_and_message;-    out->Print(""method_implementations = {\n"");+    map<string, string> method_description_constructors;+    map<string, pair<string, string>> input_message_modules_and_classes;+    map<string, pair<string, string>> output_message_modules_and_classes;     for (int i = 0; i < service->method_count(); ++i) {-      IndentScope raii_implementations_indent(out);-      const MethodDescriptor* meth = service->method(i);-      string meth_type =-          string(meth->client_streaming() ? ""stream"" : ""unary"") +-          string(meth->server_streaming() ? ""_stream"" : ""_unary"") + ""_inline"";-      out->Print(""\""$Method$\"": utilities.$Type$(servicer.$Method$),\n"",-                 ""Method"", meth->name(),-                 ""Type"", meth_type);-      // Maintain information on the input type of the service method for later-      // use in constructing the service assembly's activated fore link.-      const Descriptor* input_type = meth->input_type();-      pair<string, string> module_and_message;-      if (!GetModuleAndMessagePath(input_type, &module_and_message)) {+      const MethodDescriptor* method = service->method(i);+      const string method_description_constructor =+          string(method->client_streaming() ? ""stream_"" : ""unary_"") ++          string(method->server_streaming() ? ""stream_"" : ""unary_"") ++          ""service_description"";+      pair<string, string> input_message_module_and_class;+      if (!GetModuleAndMessagePath(method->input_type(),+                                   &input_message_module_and_class)) {         return false;       }-      method_to_module_and_message.insert(-          make_pair(meth->name(), module_and_message));-    }-    out->Print(""}\n"");-    // Ensure that we've imported all of the relevant messages.-    for (auto& meth_vals : method_to_module_and_message) {-      out->Print(""import $Module$\n"",-                 ""Module"", meth_vals.second.first);-    }-    out->Print(""request_deserializers = {\n"");-    for (auto& meth_vals : method_to_module_and_message) {-      IndentScope raii_serializers_indent(out);-      string full_input_type_path = meth_vals.second.first + ""."" +-          meth_vals.second.second;-      out->Print(""\""$Method$\"": $Type$.FromString,\n"",-                 ""Method"", meth_vals.first,-                 ""Type"", full_input_type_path);+      pair<string, string> output_message_module_and_class;+      if (!GetModuleAndMessagePath(method->output_type(),+                                   &output_message_module_and_class)) {+        return false;+      }+      // Import the modules that define the messages used in RPCs.+      out->Print(""import $Module$\n"", ""Module"",+                 input_message_module_and_class.first);+      out->Print(""import $Module$\n"", ""Module"",+                 output_message_module_and_class.first);+      method_description_constructors.insert(+          make_pair(method->name(), method_description_constructor));+      input_message_modules_and_classes.insert(+          make_pair(method->name(), input_message_module_and_class));+      output_message_modules_and_classes.insert(+          make_pair(method->name(), output_message_module_and_class));     }-    out->Print(""}\n"");-    out->Print(""response_serializers = {\n"");-    for (auto& meth_vals : method_to_module_and_message) {-      IndentScope raii_serializers_indent(out);-      out->Print(""\""$Method$\"": lambda x: x.SerializeToString(),\n"",-                 ""Method"", meth_vals.first);+    out->Print(""method_service_descriptions = {\n"");+    for (auto& name_and_description_constructor :+         method_description_constructors) {+      IndentScope raii_descriptions_indent(out);+      const string method_name = name_and_description_constructor.first;+      auto input_message_module_and_class =+          input_message_modules_and_classes.find(method_name);+      auto output_message_module_and_class =+          output_message_modules_and_classes.find(method_name);+      out->Print(""\""$Method$\"": utilities.$Constructor$(\n"", ""Method"",+                 method_name, ""Constructor"",+                 name_and_description_constructor.second);+      {+        IndentScope raii_description_arguments_indent(out);+        out->Print(""servicer.$Method$,\n"", ""Method"", method_name);+        out->Print(+            ""$InputTypeModule$.$InputTypeClass$.FromString,\n"",+            ""InputTypeModule"", input_message_module_and_class->second.first,+            ""InputTypeClass"", input_message_module_and_class->second.second);+        out->Print(+            ""$OutputTypeModule$.$OutputTypeClass$.SerializeToString,\n"",","This is fine to me either way, but why do we care that the SerializeToString method is coming from a specific class? Is there some manner of error checking attached to serialization?",x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/909,25627848,2015-03-02T19:14:17Z,src/compiler/python_generator.cc,"@@ -237,54 +237,70 @@ bool PrintServerFactory(const ServiceDescriptor* service, Printer* out) {              ""Service"", service->name());   {     IndentScope raii_create_server_indent(out);-    map<string, pair<string, string>> method_to_module_and_message;-    out->Print(""method_implementations = {\n"");+    map<string, string> method_description_constructors;+    map<string, pair<string, string>> input_message_modules_and_classes;+    map<string, pair<string, string>> output_message_modules_and_classes;     for (int i = 0; i < service->method_count(); ++i) {-      IndentScope raii_implementations_indent(out);-      const MethodDescriptor* meth = service->method(i);-      string meth_type =-          string(meth->client_streaming() ? ""stream"" : ""unary"") +-          string(meth->server_streaming() ? ""_stream"" : ""_unary"") + ""_inline"";-      out->Print(""\""$Method$\"": utilities.$Type$(servicer.$Method$),\n"",-                 ""Method"", meth->name(),-                 ""Type"", meth_type);-      // Maintain information on the input type of the service method for later-      // use in constructing the service assembly's activated fore link.-      const Descriptor* input_type = meth->input_type();-      pair<string, string> module_and_message;-      if (!GetModuleAndMessagePath(input_type, &module_and_message)) {+      const MethodDescriptor* method = service->method(i);+      const string method_description_constructor =+          string(method->client_streaming() ? ""stream_"" : ""unary_"") ++          string(method->server_streaming() ? ""stream_"" : ""unary_"") ++          ""service_description"";+      pair<string, string> input_message_module_and_class;+      if (!GetModuleAndMessagePath(method->input_type(),+                                   &input_message_module_and_class)) {         return false;       }-      method_to_module_and_message.insert(-          make_pair(meth->name(), module_and_message));-    }-    out->Print(""}\n"");-    // Ensure that we've imported all of the relevant messages.-    for (auto& meth_vals : method_to_module_and_message) {-      out->Print(""import $Module$\n"",-                 ""Module"", meth_vals.second.first);-    }-    out->Print(""request_deserializers = {\n"");-    for (auto& meth_vals : method_to_module_and_message) {-      IndentScope raii_serializers_indent(out);-      string full_input_type_path = meth_vals.second.first + ""."" +-          meth_vals.second.second;-      out->Print(""\""$Method$\"": $Type$.FromString,\n"",-                 ""Method"", meth_vals.first,-                 ""Type"", full_input_type_path);+      pair<string, string> output_message_module_and_class;+      if (!GetModuleAndMessagePath(method->output_type(),+                                   &output_message_module_and_class)) {+        return false;+      }+      // Import the modules that define the messages used in RPCs.+      out->Print(""import $Module$\n"", ""Module"",+                 input_message_module_and_class.first);+      out->Print(""import $Module$\n"", ""Module"",+                 output_message_module_and_class.first);+      method_description_constructors.insert(+          make_pair(method->name(), method_description_constructor));+      input_message_modules_and_classes.insert(+          make_pair(method->name(), input_message_module_and_class));+      output_message_modules_and_classes.insert(+          make_pair(method->name(), output_message_module_and_class));     }-    out->Print(""}\n"");-    out->Print(""response_serializers = {\n"");-    for (auto& meth_vals : method_to_module_and_message) {-      IndentScope raii_serializers_indent(out);-      out->Print(""\""$Method$\"": lambda x: x.SerializeToString(),\n"",-                 ""Method"", meth_vals.first);+    out->Print(""method_service_descriptions = {\n"");+    for (auto& name_and_description_constructor :+         method_description_constructors) {+      IndentScope raii_descriptions_indent(out);+      const string method_name = name_and_description_constructor.first;+      auto input_message_module_and_class =+          input_message_modules_and_classes.find(method_name);+      auto output_message_module_and_class =+          output_message_modules_and_classes.find(method_name);+      out->Print(""\""$Method$\"": utilities.$Constructor$(\n"", ""Method"",+                 method_name, ""Constructor"",+                 name_and_description_constructor.second);+      {+        IndentScope raii_description_arguments_indent(out);+        out->Print(""servicer.$Method$,\n"", ""Method"", method_name);+        out->Print(+            ""$InputTypeModule$.$InputTypeClass$.FromString,\n"",+            ""InputTypeModule"", input_message_module_and_class->second.first,+            ""InputTypeClass"", input_message_module_and_class->second.second);+        out->Print(+            ""$OutputTypeModule$.$OutputTypeClass$.SerializeToString,\n"",",We care because we believe that developers are going to be looking at the generated code for an understanding of how it works and using the class method anchored to the specific message class is going to be more helpful to them than using an instance method for which they'd have to look up the method resolution order and whatnot.So far as I'm aware they behave exactly the same. If there's some better error checking or something that would be a bonus.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/920,25666262,2015-03-03T06:48:19Z,src/cpp/server/server.cc,"@@ -287,12 +287,14 @@ void Server::Wait() { }  void Server::PerformOpsOnCall(CallOpBuffer* buf, Call* call) {-  static const size_t MAX_OPS = 8;-  size_t nops = MAX_OPS;-  grpc_op ops[MAX_OPS];-  buf->FillOps(ops, &nops);-  GPR_ASSERT(GRPC_CALL_OK ==-             grpc_call_start_batch(call->call(), ops, nops, buf));+  if (call->call()) {","Under what conditions can we get here?This seems very dangerous: we'll have someone waiting on a completion that will never arrive, transforming a crash into a stuck thread.",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/837,25817847,2015-03-04T21:51:16Z,test/cpp/qps/client.h,"@@ -0,0 +1,176 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef TEST_QPS_CLIENT_H+#define TEST_QPS_CLIENT_H++#include ""test/cpp/qps/histogram.h""+#include ""test/cpp/qps/timer.h""+#include ""test/cpp/qps/qpstest.pb.h""++#include <condition_variable>+#include <mutex>++namespace grpc {+namespace testing {++class Client {+ public:+  explicit Client(const ClientConfig& config) : timer_(new Timer) {+    for (int i = 0; i < config.client_channels(); i++) {+      channels_.push_back(ClientChannelInfo(+          config.server_targets(i % config.server_targets_size()), config));+    }+    request_.set_response_type(grpc::testing::PayloadType::COMPRESSABLE);+    request_.set_response_size(config.payload_size());+  }+  virtual ~Client() {}++  ClientStats Mark() {+    Histogram latencies;+    std::vector<Histogram> to_merge(threads_.size());+    for (size_t i = 0; i < threads_.size(); i++) {+      threads_[i]->BeginSwap(&to_merge[i]);+    }+    std::unique_ptr<Timer> timer(new Timer);+    timer_.swap(timer);+    for (size_t i = 0; i < threads_.size(); i++) {+      threads_[i]->EndSwap();+      latencies.Merge(&to_merge[i]);+    }++    auto timer_result = timer->Mark();++    ClientStats stats;+    latencies.FillProto(stats.mutable_latencies());+    stats.set_time_elapsed(timer_result.wall);+    stats.set_time_system(timer_result.system);+    stats.set_time_user(timer_result.user);+    return stats;+  }++ protected:+  SimpleRequest request_;++  class ClientChannelInfo {+   public:+    explicit ClientChannelInfo(const grpc::string& target,+                               const ClientConfig& config)","Keyword ""explicit"" is no longer relevant here since there are now 2 arguments.",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/837,25821066,2015-03-04T22:27:22Z,test/cpp/qps/server_async.cc,"@@ -51,104 +51,38 @@ #include ""src/cpp/server/thread_pool.h"" #include ""test/core/util/grpc_profiler.h"" #include ""test/cpp/qps/qpstest.pb.h""+#include ""test/cpp/qps/server.h""  #include <grpc/grpc.h> #include <grpc/support/log.h> -DEFINE_bool(enable_ssl, false, ""Whether to use ssl/tls."");-DEFINE_int32(port, 0, ""Server port."");-DEFINE_int32(server_threads, 4, ""Number of server threads."");+namespace grpc {+namespace testing { -using grpc::CompletionQueue;-using grpc::Server;-using grpc::ServerBuilder;-using grpc::ServerContext;-using grpc::ThreadPool;-using grpc::testing::Payload;-using grpc::testing::PayloadType;-using grpc::testing::ServerStats;-using grpc::testing::SimpleRequest;-using grpc::testing::SimpleResponse;-using grpc::testing::StatsRequest;-using grpc::testing::TestService;-using grpc::Status;--// In some distros, gflags is in the namespace google, and in some others,-// in gflags. This hack is enabling us to find both.-namespace google {}-namespace gflags {}-using namespace google;-using namespace gflags;--static bool got_sigint = false;--static void sigint_handler(int x) { got_sigint = 1; }--static double time_double(struct timeval *tv) {-  return tv->tv_sec + 1e-6 * tv->tv_usec;-}--static bool SetPayload(PayloadType type, int size, Payload *payload) {-  PayloadType response_type = type;-  // TODO(yangg): Support UNCOMPRESSABLE payload.-  if (type != PayloadType::COMPRESSABLE) {-    return false;-  }-  payload->set_type(response_type);-  std::unique_ptr<char[]> body(new char[size]());-  payload->set_body(body.get(), size);-  return true;-}--namespace {--class AsyncQpsServerTest {+class AsyncQpsServerTest : public Server {  public:-  AsyncQpsServerTest() : srv_cq_(), async_service_(&srv_cq_), server_(nullptr) {+  AsyncQpsServerTest(const ServerConfig &config, int port)+      : srv_cq_(), async_service_(&srv_cq_), server_(nullptr) {     char *server_address = NULL;-    gpr_join_host_port(&server_address, ""::"", FLAGS_port);+    gpr_join_host_port(&server_address, ""::"", port);      ServerBuilder builder;     builder.AddPort(server_address);+    gpr_free(server_address);      builder.RegisterAsyncService(&async_service_);      server_ = builder.BuildAndStart();-    gpr_log(GPR_INFO, ""Server listening on %s\n"", server_address);-    gpr_free(server_address);      using namespace std::placeholders;     request_unary_ = std::bind(&TestService::AsyncService::RequestUnaryCall,                                &async_service_, _1, _2, _3, &srv_cq_, _4);-    request_stats_ =-        std::bind(&TestService::AsyncService::RequestCollectServerStats,-                  &async_service_, _1, _2, _3, &srv_cq_, _4);     for (int i = 0; i < 100; i++) {","We should probably make this 100 into a configurable backlog parameter. If not now, then later.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/837,25821725,2015-03-04T22:35:16Z,test/cpp/qps/client_async.cc,"@@ -151,191 +118,84 @@ class ClientRpcContextUnaryImpl : public ClientRpcContext {   ResponseType response_;   bool (ClientRpcContextUnaryImpl::*next_state_)();   std::function<void(grpc::Status, ResponseType *)> callback_;+  std::function<std::unique_ptr<grpc::ClientAsyncResponseReader<ResponseType>>(+      TestService::Stub *, grpc::ClientContext *, const RequestType &, void *)>+      start_req_;   grpc::Status status_;   double start_;   std::unique_ptr<grpc::ClientAsyncResponseReader<ResponseType>>       response_reader_; }; -static void RunTest(const int client_threads, const int client_channels,-                    const int num_rpcs, const int payload_size) {-  gpr_log(GPR_INFO,-          ""QPS test with parameters\n""-          ""enable_ssl = %d\n""-          ""client_channels = %d\n""-          ""client_threads = %d\n""-          ""num_rpcs = %d\n""-          ""payload_size = %d\n""-          ""server_host:server_port = %s:%d\n\n"",-          FLAGS_enable_ssl, client_channels, client_threads, num_rpcs,-          payload_size, FLAGS_server_host.c_str(), FLAGS_server_port);--  std::ostringstream oss;-  oss << FLAGS_server_host << "":"" << FLAGS_server_port;--  class ClientChannelInfo {-   public:-    explicit ClientChannelInfo(const grpc::string &server)-        : channel_(CreateTestChannel(server, FLAGS_enable_ssl)),-          stub_(TestService::NewStub(channel_)) {}-    ChannelInterface *get_channel() { return channel_.get(); }-    TestService::Stub *get_stub() { return stub_.get(); }+class AsyncClient GRPC_FINAL : public Client {+ public:+  explicit AsyncClient(const ClientConfig &config) : Client(config) {+    for (int i = 0; i < config.async_client_threads(); i++) {+      cli_cqs_.emplace_back(new CompletionQueue);+    } -   private:-    std::shared_ptr<ChannelInterface> channel_;-    std::unique_ptr<TestService::Stub> stub_;-  };+    auto payload_size = config.payload_size();+    auto check_done = [payload_size](grpc::Status s, SimpleResponse *response) {+      GPR_ASSERT(s.IsOk() && (response->payload().type() ==+                              grpc::testing::PayloadType::COMPRESSABLE) &&+                 (response->payload().body().length() ==+                  static_cast<size_t>(payload_size)));+    };++    int t = 0;+    for (int i = 0; i < config.outstanding_rpcs_per_channel(); i++) {+      for (auto &channel : channels_) {+        auto *cq = cli_cqs_[t].get();+        t = (t + 1) % cli_cqs_.size();+        auto start_req = [cq](TestService::Stub *stub, grpc::ClientContext *ctx,+                              const SimpleRequest &request, void *tag) {+          return stub->AsyncUnaryCall(ctx, request, cq, tag);+        };+","Ok, makes sense since these just get cloned over and over to account for the number of desired rpcs, as opposed to actually getting a new lambda capture for each RPC.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/968,25971105,2015-03-06T19:35:44Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -0,0 +1,407 @@+#region Copyright notice and license++// Copyright 2015, Google Inc.+// All rights reserved.+// +// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+// +//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+// +// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++#endregion++using System;+using System.Diagnostics;+using System.Runtime.CompilerServices;+using System.Runtime.InteropServices;+using System.Threading;+using System.Threading.Tasks;+using Grpc.Core.Internal;+using Grpc.Core.Utils;++namespace Grpc.Core.Internal+{+    /// <summary>+    /// Base for handling both client side and server side calls.+    /// Handles native call lifecycle and provides convenience methods.+    /// </summary>+    internal abstract class AsyncCallBase<TWrite, TRead>+    {+        readonly Func<TWrite, byte[]> serializer;+        readonly Func<byte[], TRead> deserializer;++        protected readonly CompletionCallbackDelegate sendFinishedHandler;+        protected readonly CompletionCallbackDelegate readFinishedHandler;+        protected readonly CompletionCallbackDelegate halfclosedHandler;++        protected readonly object myLock = new object();++        protected GCHandle gchandle;+        protected CallSafeHandle call;+        protected bool disposed;++        protected bool started;+        protected bool errorOccured;+        protected bool cancelRequested;++        protected AsyncCompletionDelegate sendCompletionDelegate;  // Completion of a pending send or sendclose if not null.+        protected bool readPending;  // True if there is a read in progress.+        protected bool readingDone;+        protected bool halfcloseRequested;+        protected bool halfclosed;+        protected bool finished;  // True if close has been received from the peer.++        // Streaming reads will be delivered to this observer. For a call that only does unary read it may remain null.+        protected IObserver<TRead> readObserver;++        public AsyncCallBase(Func<TWrite, byte[]> serializer, Func<byte[], TRead> deserializer)+        {+            this.serializer = Preconditions.CheckNotNull(serializer);+            this.deserializer = Preconditions.CheckNotNull(deserializer);+  +            this.sendFinishedHandler = CreateBatchCompletionCallback(HandleSendFinished);+            this.readFinishedHandler = CreateBatchCompletionCallback(HandleReadFinished);+            this.halfclosedHandler = CreateBatchCompletionCallback(HandleHalfclosed);+        }++        /// <summary>+        /// Requests cancelling the call.+        /// </summary>+        public void Cancel()+        {+            lock (myLock)","Yes, it might not be. grpc_call_cancel should be threadsafe, but I am basically locking here to make sure that I can check the state of this class consistently.",x
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/968,25972881,2015-03-06T19:56:04Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -0,0 +1,407 @@+#region Copyright notice and license++// Copyright 2015, Google Inc.+// All rights reserved.+// +// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+// +//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+// +// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++#endregion++using System;+using System.Diagnostics;+using System.Runtime.CompilerServices;+using System.Runtime.InteropServices;+using System.Threading;+using System.Threading.Tasks;+using Grpc.Core.Internal;+using Grpc.Core.Utils;++namespace Grpc.Core.Internal+{+    /// <summary>+    /// Base for handling both client side and server side calls.+    /// Handles native call lifecycle and provides convenience methods.+    /// </summary>+    internal abstract class AsyncCallBase<TWrite, TRead>+    {+        readonly Func<TWrite, byte[]> serializer;+        readonly Func<byte[], TRead> deserializer;++        protected readonly CompletionCallbackDelegate sendFinishedHandler;+        protected readonly CompletionCallbackDelegate readFinishedHandler;+        protected readonly CompletionCallbackDelegate halfclosedHandler;++        protected readonly object myLock = new object();++        protected GCHandle gchandle;+        protected CallSafeHandle call;+        protected bool disposed;++        protected bool started;+        protected bool errorOccured;+        protected bool cancelRequested;++        protected AsyncCompletionDelegate sendCompletionDelegate;  // Completion of a pending send or sendclose if not null.+        protected bool readPending;  // True if there is a read in progress.+        protected bool readingDone;+        protected bool halfcloseRequested;+        protected bool halfclosed;+        protected bool finished;  // True if close has been received from the peer.++        // Streaming reads will be delivered to this observer. For a call that only does unary read it may remain null.+        protected IObserver<TRead> readObserver;++        public AsyncCallBase(Func<TWrite, byte[]> serializer, Func<byte[], TRead> deserializer)+        {+            this.serializer = Preconditions.CheckNotNull(serializer);+            this.deserializer = Preconditions.CheckNotNull(deserializer);+  +            this.sendFinishedHandler = CreateBatchCompletionCallback(HandleSendFinished);+            this.readFinishedHandler = CreateBatchCompletionCallback(HandleReadFinished);+            this.halfclosedHandler = CreateBatchCompletionCallback(HandleHalfclosed);+        }++        /// <summary>+        /// Requests cancelling the call.+        /// </summary>+        public void Cancel()+        {+            lock (myLock)+            {+                Preconditions.CheckState(started);+                cancelRequested = true;++                if (!disposed)+                {+                    call.Cancel();+                }+            }+        }++        /// <summary>+        /// Requests cancelling the call with given status.+        /// </summary>+        public void CancelWithStatus(Status status)+        {+            lock (myLock)+            {+                Preconditions.CheckState(started);+                cancelRequested = true;++                if (!disposed)+                {+                    call.CancelWithStatus(status);+                }+            }+        }++        protected void InitializeInternal(CallSafeHandle call)+        {+            lock (myLock)+            {+                // Make sure this object and the delegated held by it will not be garbage collected+                // before we release this handle.+                gchandle = GCHandle.Alloc(this);+                this.call = call;+            }+        }++        /// <summary>+        /// Initiates sending a message. Only once send operation can be active at a time.+        /// completionDelegate is invoked upon completion.+        /// </summary>+        protected void StartSendMessageInternal(TWrite msg, AsyncCompletionDelegate completionDelegate)+        {+            byte[] payload = UnsafeSerialize(msg);++            lock (myLock)+            {+                Preconditions.CheckNotNull(completionDelegate, ""Completion delegate cannot be null"");+                CheckSendingAllowed();++                call.StartSendMessage(payload, sendFinishedHandler);+                sendCompletionDelegate = completionDelegate;+            }+        }++        /// <summary>+        /// Requests receiving a next message.+        /// </summary>+        protected void StartReceiveMessage()+        {+            lock (myLock)+            {+                Preconditions.CheckState(started);+                Preconditions.CheckState(!disposed);+                Preconditions.CheckState(!errorOccured);++                Preconditions.CheckState(!readingDone);+                Preconditions.CheckState(!readPending);++                call.StartReceiveMessage(readFinishedHandler);+                readPending = true;+            }+        }++        /// <summary>+        /// Default behavior just completes the read observer, but more sofisticated behavior might be required+        /// by subclasses.+        /// </summary>+        protected virtual void CompleteReadObserver()+        {+            FireReadObserverOnCompleted();+        }++        /// <summary>+        /// If there are no more pending actions and no new actions can be started, releases+        /// the underlying native resources.+        /// </summary>+        protected bool ReleaseResourcesIfPossible()+        {+            if (!disposed && call != null)+            {+                if (halfclosed && readingDone && finished)+                {+                    ReleaseResources();+                    return true;+                }+            }+            return false;+        }++        private void ReleaseResources()","Because cannot release native resources in a destructor.What you normally do for objects that own unmanaged resources is you make them implement IDisposable https://msdn.microsoft.com/en-us/library/system.idisposable%28v=vs.110%29.aspxBut AsyncCall has to manage its own lifetime anyway (basically waiting for completion callbacks to be delivered), so implementing IDisposable doesn't really help me much here (I had that before and realized it's not helpful).",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/1003,26264134,2015-03-11T22:49:14Z,include/grpc++/anonymous_service.h,"@@ -0,0 +1,75 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_ANONYMOUS_SERVICE_H+#define GRPCXX_ANONYMOUS_SERVICE_H++#include <grpc++/byte_buffer.h>+#include <grpc++/stream.h>++struct grpc_server;++namespace grpc {++typedef ServerAsyncReaderWriter<ByteBuffer, ByteBuffer> GenericServerReaderWriter;++class AnonymousServerContext : public ServerContext {+ public:+  const grpc::string& method() const { return method_; }+  const grpc::string& host() const { return host_; }++ private:+  friend class Server;++  grpc::string method_;+  grpc::string host_;+};++class AnonymousService {+ public:+  // TODO(yangg) Once we can add multiple completion queues to the server+  // in c core, add a CompletionQueue* argument to the ctor here.+  AnonymousService() : server_(nullptr) {}","When it is registering with the server, server_ is set through friend class.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/1003,26264165,2015-03-11T22:49:45Z,include/grpc++/anonymous_service.h,"@@ -0,0 +1,75 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_ANONYMOUS_SERVICE_H+#define GRPCXX_ANONYMOUS_SERVICE_H++#include <grpc++/byte_buffer.h>+#include <grpc++/stream.h>++struct grpc_server;++namespace grpc {++typedef ServerAsyncReaderWriter<ByteBuffer, ByteBuffer> GenericServerReaderWriter;++class AnonymousServerContext : public ServerContext {+ public:+  const grpc::string& method() const { return method_; }+  const grpc::string& host() const { return host_; }",We need to talk about this. Most of the headers should be in request_metadata in ServerContext.,x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1003,26323819,2015-03-12T17:23:42Z,include/grpc++/generic_service.h,"@@ -0,0 +1,75 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_GENERIC_SERVICE_H+#define GRPCXX_GENERIC_SERVICE_H++#include <grpc++/byte_buffer.h>+#include <grpc++/stream.h>++struct grpc_server;++namespace grpc {++typedef ServerAsyncReaderWriter<ByteBuffer, ByteBuffer> GenericServerReaderWriter;++class GenericServerContext : public ServerContext {","Would you want this class to be GRPC_FINAL , or do we expect anyone to inherit from it?",x
10985246,fengli-google,https://api.github.com/repos/grpc/grpc/pulls/1003,26404809,2015-03-13T17:20:50Z,include/grpc++/slice.h,"@@ -0,0 +1,74 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_SLICE_H+#define GRPCXX_SLICE_H++#include <grpc/support/slice.h>+#include <grpc++/config.h>++namespace grpc {++class Slice GRPC_FINAL {+ public:+  // construct empty slice+  Slice();+  // destructor - drops one ref+  ~Slice();+  // construct slice from grpc slice, adding a ref+  enum AddRef { ADD_REF };+  Slice(gpr_slice slice, AddRef);+  // construct slice from grpc slice, stealing a ref+  enum StealRef { STEAL_REF };+  Slice(gpr_slice slice, StealRef);+  // copy constructor - adds a ref+  Slice(const Slice& other);",Add comment to clarify the ref behavior for this method since it doesn't indicate in the arg list.,x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1023,26454117,2015-03-15T23:45:10Z,include/grpc++/completion_queue.h,"@@ -75,10 +76,18 @@ class CompletionQueue {   explicit CompletionQueue(grpc_completion_queue *take);   ~CompletionQueue(); -  // Blocking read from queue.-  // Returns true if an event was received, false if the queue is ready-  // for destruction.-  bool Next(void **tag, bool *ok);+  // Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT+  enum NextStatus {SHUTDOWN, GOT_EVENT, TIMEOUT};++  // Nonblocking (until deadline) read from queue.+  // Cannot rely on result of tag or ok if return is TIMEOUT+  NextStatus AsyncNext(void **tag, bool *ok, gpr_timespec deadline);","https://msdn.microsoft.com/en-us/library/hh874757.aspx confirms that this is a VS12+ thing. If our C++11 standard is based on VS10, then it's a no-go. I realize that that decision would affect some tests, as some tests are already using std::chrono.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1023,26458867,2015-03-16T04:05:44Z,include/grpc++/completion_queue.h,"@@ -75,10 +76,18 @@ class CompletionQueue {   explicit CompletionQueue(grpc_completion_queue *take);   ~CompletionQueue(); -  // Blocking read from queue.-  // Returns true if an event was received, false if the queue is ready-  // for destruction.-  bool Next(void **tag, bool *ok);+  // Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT+  enum NextStatus {SHUTDOWN, GOT_EVENT, TIMEOUT};++  // Nonblocking (until deadline) read from queue.+  // Cannot rely on result of tag or ok if return is TIMEOUT+  NextStatus AsyncNext(void **tag, bool *ok, gpr_timespec deadline);","We've already got code using std::chrono elsewhere - which is why I madethe suggestion. I realize it's out for 2010, but the solution we choosethere will be pretty much a copy/paste when we choose it. My main point wasthat it should _not_ be gpr_timespec - we've got good hygiene presently atnot exposing grpc/ headers in grpc++/, and I think that's worthwhilesticking to.Suggest using std::chrono now, and when we do 2010, defining some minimalcompatible C++ type for use there.On Sun, Mar 15, 2015 at 4:45 PM Vijay Pai notifications@github.com wrote:> In include/grpc++/completion_queue.h> https://github.com/grpc/grpc/pull/1023#discussion_r26454117:> > > @@ -75,10 +76,18 @@ class CompletionQueue {> >    explicit CompletionQueue(grpc_completion_queue *take);> >    ~CompletionQueue();> > -  // Blocking read from queue.> > -  // Returns true if an event was received, false if the queue is ready> > -  // for destruction.> > -  bool Next(void **tag, bool *ok);> > -  // Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT> > -  enum NextStatus {SHUTDOWN, GOT_EVENT, TIMEOUT};> >   +> > -  // Nonblocking (until deadline) read from queue.> > -  // Cannot rely on result of tag or ok if return is TIMEOUT> > -  NextStatus AsyncNext(void **tag, bool *ok, gpr_timespec deadline);> > https://msdn.microsoft.com/en-us/library/hh874757.aspx confirms that this> is a VS12+ thing. If our C++11 standard is based on VS10, then it's a> no-go. I realize that that decision would affect some tests, as some tests> are already using std::chrono.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/1023/files#r26454117.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/1031,26534160,2015-03-16T22:31:06Z,src/compiler/python_generator.cc,"@@ -229,7 +229,8 @@ bool GetModuleAndMessagePath(const Descriptor* type,   return true; } -bool PrintServerFactory(const ServiceDescriptor* service, Printer* out) {+bool PrintServerFactory(const std::string package_qualified_service_name,","I believe the stylistically consistent signature is `const std::string&` rather than `const std::string` here; there's no particularly meaningful semantic difference in this case, but, y'know, consistency.(Edit: aand the other instances of this)",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1081,26791715,2015-03-19T20:00:21Z,build.json,"@@ -492,6 +492,19 @@       ""secure"": ""no""     },     {+      ""name"": ""grpc_python_plugin_support"",",Why did you want to split that to a separate library ?,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/1081,26792008,2015-03-19T20:03:44Z,build.json,"@@ -492,6 +492,19 @@       ""secure"": ""no""     },     {+      ""name"": ""grpc_python_plugin_support"",",To be able to target that library internally.,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1101,26813064,2015-03-20T01:25:49Z,src/compiler/config.h,"@@ -54,10 +54,12 @@ #ifndef GRPC_CUSTOM_PRINTER #include <google/protobuf/io/coded_stream.h> #include <google/protobuf/io/printer.h>+#include <google/protobuf/io/zero_copy_stream.h> #include <google/protobuf/io/zero_copy_stream_impl_lite.h> #define GRPC_CUSTOM_PRINTER ::google::protobuf::io::Printer #define GRPC_CUSTOM_CODEDOUTPUTSTREAM ::google::protobuf::io::CodedOutputStream #define GRPC_CUSTOM_STRINGOUTPUTSTREAM ::google::protobuf::io::StringOutputStream+#define GRPC_CUSTOM_ZEROCOPYOUTPUTSTREAM ::google::protobuf::io::ZeroCopyOutputStream",Interesting that you don't get a symbol collision. This one is already defined:https://github.com/grpc/grpc/blob/master/include/grpc%2B%2B/config.h#L63,x
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1147,27335654,2015-03-27T22:28:11Z,src/php/lib/Grpc/AbstractCall.php,"@@ -33,7 +33,7 @@  */ namespace Grpc; -require_once realpath(dirname(__FILE__) . '/../autoload.php');+require_once realpath(dirname(__FILE__) . '/../../vendor/autoload.php');","I guess it can be removed, but not because of anything special composer does. Composer just generates the `autoload.php` file that I refer to there. If we assume that these library files will only be loaded using that autoload file, then the `require_once` line is redundant. That probably is a safe assumption, so I'll remove it from files in `lib/Grpc`.",x
3949752,Yhg1s,https://api.github.com/repos/grpc/grpc/pulls/1154,27467966,2015-03-31T10:30:15Z,tools/distrib/python/submit.py,"@@ -0,0 +1,27 @@+#!/usr/bin/env python++import argparse+import os+import shutil+import subprocess+import tempfile++parser = argparse.ArgumentParser(+    description='Submit the package to a PyPI repository.')+parser.add_argument(+    '--repository', metavar='r', type=str, default='pypi',+    help='The repository to push the package to. '+         'Ensure the value appears in your .pypirc file. '+         'Defaults to ""pypi"".'+)+args = parser.parse_args()++# Move to the directory of this file.+os.chdir(os.path.dirname(os.path.abspath(__file__)))++# Move to the root directory of Python GRPC.+os.chdir('../../../src/python/src')++# Make the push.+cmd = 'python setup.py sdist upload -r %s' % args.repository+subprocess.call(cmd, shell=True)","No reason to use shell here, it just makes it more painful if the repository starts containing shell metacharacters (you end up having to escape it twice.) Never use shell=True, just make 'cmd' a list.",x
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/1154,27500983,2015-03-31T17:19:28Z,tools/distrib/python/submit.py,"@@ -0,0 +1,27 @@+#!/usr/bin/env python++import argparse+import os+import shutil+import subprocess+import tempfile++parser = argparse.ArgumentParser(+    description='Submit the package to a PyPI repository.')+parser.add_argument(+    '--repository', metavar='r', type=str, default='pypi',+    help='The repository to push the package to. '+         'Ensure the value appears in your .pypirc file. '+         'Defaults to ""pypi"".'+)+args = parser.parse_args()++# Move to the directory of this file.+os.chdir(os.path.dirname(os.path.abspath(__file__)))","IMO, that breaks from the pattern of having executables under the tools folder be agnostic to where we are and having them always Do The Right Thing™.",x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1163,27601857,2015-04-01T19:18:59Z,src/python/src/grpc/_adapter/_low_test.py,"@@ -115,6 +115,10 @@ def tearDown(self):   def _perform_echo_test(self, test_data):     method = 'test method'     details = 'test details'+    server_metadata_key = 'my_server_key'","In the server->client direction there is both ""leading"" metadata (""headers"") and ""trailing"" metadata (""trailers"") - please exercise both kinds in this test (so, along with client->server metadata, three separate metadata values in total).",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1163,27607972,2015-04-01T20:27:52Z,src/python/src/grpc/_adapter/_low_test.py,"@@ -115,6 +115,12 @@ def tearDown(self):   def _perform_echo_test(self, test_data):     method = 'test method'     details = 'test details'+    server_leading_metadata_key = 'my_server_leading_key'+    server_leading_metadata_value = 'my_server_leading_value'",Let's use binary values containing internal null bytes for all three metadata values.,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1163,27608338,2015-04-01T20:31:47Z,src/python/src/grpc/_adapter/_low_test.py,"@@ -115,6 +115,12 @@ def tearDown(self):   def _perform_echo_test(self, test_data):     method = 'test method'     details = 'test details'+    server_leading_metadata_key = 'my_server_leading_key'+    server_leading_metadata_value = 'my_server_leading_value'",I'm pretty sure you aren't supposed to have binary metadata values unless the metadata key ends with `'-bin'`.,x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1163,27608830,2015-04-01T20:36:53Z,src/python/src/grpc/_adapter/_call.c,"@@ -236,6 +250,9 @@ static PyMethodDef methods[] = {     {""complete"", (PyCFunction)pygrpc_call_complete, METH_O,      ""Complete writes to this call.""},     {""accept"", (PyCFunction)pygrpc_call_accept, METH_VARARGS, ""Accept an RPC.""},+    {""add_metadata"", (PyCFunction)pygrpc_call_add_metadata, METH_VARARGS,+     ""Add metadata to the call. May not be called after invoke or ""+     ""premetadata.""},","The ""or premetadata"" smells stale here, given that calling add_metadata after premetadata is how terminal metadata gets added, right?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1163,27608899,2015-04-01T20:37:46Z,src/python/src/grpc/_adapter/_call.c,"@@ -160,8 +160,22 @@ static const PyObject *pygrpc_call_accept(Call *self, PyObject *args) {   return result; } +static const PyObject *pygrpc_call_add_metadata(Call *self, PyObject *args) {+  const char* key = NULL;+  const char* value = NULL;+  int value_length = 0;+  if (!PyArg_ParseTuple(args, ""ss#"", &key, &value, &value_length)) {+    return NULL;+  }+  grpc_metadata metadata;+  metadata.key = key;+  metadata.value = value;+  metadata.value_length = value_length;+  return pygrpc_translate_call_error(+      grpc_call_add_metadata_old(self->c_call, &metadata, 0));+}+ static const PyObject *pygrpc_call_premetadata(Call *self) {","Feel perfectly free to rename the ""premetadata"" function(s). Actively working with this code now is there a name that occurs to you as more appropriate?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/1163,27609893,2015-04-01T20:48:11Z,src/python/src/grpc/_adapter/_call.c,"@@ -160,8 +160,22 @@ static const PyObject *pygrpc_call_accept(Call *self, PyObject *args) {   return result; } +static const PyObject *pygrpc_call_add_metadata(Call *self, PyObject *args) {+  const char* key = NULL;+  const char* value = NULL;+  int value_length = 0;+  if (!PyArg_ParseTuple(args, ""ss#"", &key, &value, &value_length)) {+    return NULL;+  }+  grpc_metadata metadata;+  metadata.key = key;+  metadata.value = value;+  metadata.value_length = value_length;+  return pygrpc_translate_call_error(+      grpc_call_add_metadata_old(self->c_call, &metadata, 0));+}+ static const PyObject *pygrpc_call_premetadata(Call *self) {","The only obvious naming schemes that come to mind end up also changing the names of all the other functions to have 'client' and 'server' variants, s.t. it becomes clearer that sending the initial metadata is explicitly a server-only thing by not having a client variant. Alternatively, more literally wrapping the C API s.t. the names on the Python type reflect those of the C type.But, really, I'm ambivalent; this is all getting hidden from the public API anyway, and clarifying information would probably be better served in the doc string without making larger scale changes to nomenclature.",x
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/1163,27610201,2015-04-01T20:51:13Z,src/python/src/grpc/_adapter/_low_test.py,"@@ -115,6 +115,12 @@ def tearDown(self):   def _perform_echo_test(self, test_data):     method = 'test method'     details = 'test details'+    server_leading_metadata_key = 'my_server_leading_key'+    server_leading_metadata_value = 'my_server_leading_value'","This contradicts what I've heard offline; ostensibly metadata values have to both have a length value and be null-terminated. Yes, it's redundant, but that was my impression from offline conversations. This sounds like it needs a clarifying issue to me.EDIT: Although, the core implementation appears to Do The Right Thing™ and use the length as far as I can tell.",x
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1163,27610582,2015-04-01T20:55:00Z,src/python/src/grpc/_adapter/_low_test.py,"@@ -115,6 +115,12 @@ def tearDown(self):   def _perform_echo_test(self, test_data):     method = 'test method'     details = 'test details'+    server_leading_metadata_key = 'my_server_leading_key'+    server_leading_metadata_value = 'my_server_leading_value'","I don't know if it's documented, but it's true: https://github.com/grpc/grpc/blob/2e165e34010e44f20c6ecea63b20a6996810313f/src/core/transport/chttp2/bin_encoder.c#L276",
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/1140,27748798,2015-04-03T19:06:21Z,src/node/test/surface_test.js,"@@ -126,6 +126,167 @@ describe('Generic client and server', function() {     });   }); });+describe('Trailing metadata', function() {+  var client;+  var server;+  before(function() {+    var test_proto = ProtoBuf.loadProtoFile(__dirname + '/test_service.proto');+    var test_service = test_proto.lookup('TestService');+    var Server = grpc.buildServer([test_service]);+    server = new Server({+      TestService: {+        unary: function(call, cb) {+          var req = call.request;+          if (req.error) {+            cb(new Error('Requested error'), null, {metadata: ['yes']});+          } else {+            cb(null, {count: 1}, {metadata: ['yes']});+          }+        },+        clientStream: function(stream, cb){+          var count = 0;+          var errored;+          stream.on('data', function(data) {+            if (data.error) {+              errored = true;+              cb(new Error('Requested error'), null, {metadata: ['yes']});+            } else {+              count += 1;+            }+          });+          stream.on('end', function() {+            if (!errored) {+              cb(null, {count: count}, {metadata: ['yes']});+            }+          });+        },+        serverStream: function(stream) {+          var req = stream.request;+          if (req.error) {+            var err = new Error('Requested error');+            err.metadata = {metadata: ['yes']};+            stream.emit('error', err);+          } else {+            for (var i = 0; i < 5; i++) {+              stream.write({count: i});+            }+            stream.end({metadata: ['yes']});+          }+        },+        bidiStream: function(stream) {+          var count = 0;+          stream.on('data', function(data) {+            if (data.error) {+              var err = new Error('Requested error');+              err.metadata = {+                metadata: ['yes'],+                count: ['' + count]+              };+              stream.emit('error', err);+            } else {+              stream.write({count: count});+              count += 1;+            }+          });+          stream.on('end', function() {+            stream.end({metadata: ['yes']});+          });+        }+      }+    });+    var port = server.bind('localhost:0');+    var Client = surface_client.makeProtobufClientConstructor(test_service);+    client = new Client('localhost:' + port);+    server.listen();+  });+  after(function() {+    server.shutdown();+  });+  it('when a unary call succeeds', function(done) {","nitpick: the idea here is for the it and the text of the test label to read like a sentence.E.g,it ('should be present when a unary call succeeds')So that the test output for the tests reads like a spec of the behaviourTrailing Metadata:  it should be present when a unary call succeedsPlease fix here and in the other test labels.  E.g,",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1191,27761800,2015-04-03T23:03:07Z,include/grpc/support/thd.h,"@@ -66,9 +65,25 @@ int gpr_thd_new(gpr_thd_id *t, void (*thd_body)(void *arg), void *arg, /* Return a gpr_thd_options struct with all fields set to defaults. */ gpr_thd_options gpr_thd_options_default(void); +/* Set the thread to become detached on startup - this is the default. */+void gpr_thd_options_set_detached(gpr_thd_options *options);","No, I didn't realize that was the case; I've been mostly just using std::thread and not the gpr functions. So, I'm ok with this behavior as long as the default for the C++ wrapper class has joinable as a default.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/1188,27820677,2015-04-06T19:05:41Z,src/ruby/ext/grpc/rb_call.c,"@@ -299,147 +181,397 @@ static VALUE grpc_rb_call_set_metadata(VALUE self, VALUE metadata) {   return rb_ivar_set(self, id_metadata, metadata); } -/*-  call-seq:-     call.start_write(byte_buffer, tag, flags=nil)--   Queue a byte buffer for writing.-   flags is a bit-field combination of the write flags defined above.-   A write with byte_buffer null is allowed, and will not send any bytes on the-   wire. If this is performed without GRPC_WRITE_BUFFER_HINT flag it provides-   a mechanism to flush any previously buffered writes to outgoing flow control.-   REQUIRES: No other writes are pending on the call. It is only safe to-             start the next write after the corresponding write_accepted event-             is received.-             GRPC_INVOKE_ACCEPTED must have been received by the application-             prior to calling this on the client. On the server,-             grpc_call_accept must have been called successfully.-   Produces a GRPC_WRITE_ACCEPTED event. */-static VALUE grpc_rb_call_start_write(int argc, VALUE *argv, VALUE self) {-  VALUE byte_buffer = Qnil;-  VALUE tag = Qnil;-  VALUE flags = Qnil;-  grpc_call *call = NULL;-  grpc_byte_buffer *bfr = NULL;-  grpc_call_error err;+/* grpc_rb_md_ary_fill_hash_cb is the hash iteration callback used+   to fill grpc_metadata_array.++   it's capacity should have been computed via a prior call to+   grpc_rb_md_ary_fill_hash_cb+*/+int grpc_rb_md_ary_fill_hash_cb(VALUE key, VALUE val, VALUE md_ary_obj) {+  grpc_metadata_array *md_ary = NULL;+  int array_length;+  int i;++  /* Construct a metadata object from key and value and add it */+  Data_Get_Struct(md_ary_obj, grpc_metadata_array, md_ary); -  /* ""21"" == 2 mandatory args, 1 (flags) is optional */-  rb_scan_args(argc, argv, ""21"", &byte_buffer, &tag, &flags);-  if (NIL_P(flags)) {-    flags = UINT2NUM(0); /* Default to no flags */+  if (TYPE(val) == T_ARRAY) {+    /* If the value is an array, add capacity for each value in the array */+    array_length = RARRAY_LEN(val);+    for (i = 0; i < array_length; i++) {+      if (TYPE(key) == T_SYMBOL) {+        md_ary->metadata[md_ary->count].key = (char *)rb_id2name(SYM2ID(key));+      } else { /* StringValueCStr does all other type exclusions for us */+        md_ary->metadata[md_ary->count].key = StringValueCStr(key);+      }+      md_ary->metadata[md_ary->count].value = RSTRING_PTR(rb_ary_entry(val, i));+      md_ary->metadata[md_ary->count].value_length =+        RSTRING_LEN(rb_ary_entry(val, i));+      md_ary->count += 1;+    }+  } else {+    if (TYPE(key) == T_SYMBOL) {+      md_ary->metadata[md_ary->count].key = (char *)rb_id2name(SYM2ID(key));+    } else { /* StringValueCStr does all other type exclusions for us */+      md_ary->metadata[md_ary->count].key = StringValueCStr(key);+    }+    md_ary->metadata[md_ary->count].value = RSTRING_PTR(val);+    md_ary->metadata[md_ary->count].value_length = RSTRING_LEN(val);+    md_ary->count += 1;   }-  bfr = grpc_rb_get_wrapped_byte_buffer(byte_buffer);-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_start_write_old(call, bfr, ROBJECT(tag), NUM2UINT(flags));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""start write failed: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);++  return ST_CONTINUE;+}++/* grpc_rb_md_ary_capacity_hash_cb is the hash iteration callback used+   to pre-compute the capacity a grpc_metadata_array.+*/+int grpc_rb_md_ary_capacity_hash_cb(VALUE key, VALUE val, VALUE md_ary_obj) {+  grpc_metadata_array *md_ary = NULL;++  /* Construct a metadata object from key and value and add it */+  Data_Get_Struct(md_ary_obj, grpc_metadata_array, md_ary);++  if (TYPE(val) == T_ARRAY) {+    /* If the value is an array, add capacity for each value in the array */+    md_ary->capacity += RARRAY_LEN(val);+  } else {+    md_ary->capacity += 1;+  }+  return ST_CONTINUE;+}++/* grpc_rb_md_ary_convert converts a ruby metadata hash into+   a grpc_metadata_array.+*/+void grpc_rb_md_ary_convert(VALUE md_ary_hash, grpc_metadata_array *md_ary) {+  VALUE md_ary_obj = Qnil;+  if (md_ary_hash == Qnil) {+    return;  /* Do nothing if the expected has value is nil */+  }+  if (TYPE(md_ary_hash) != T_HASH) {+    rb_raise(rb_eTypeError, ""md_ary_convert: got <%s>, want <Hash>"",+             rb_obj_classname(md_ary_hash));+    return;   } -  return Qnil;+  /* Initialize the array, compute it's capacity, then fill it. */+  grpc_metadata_array_init(md_ary);+  md_ary_obj = Data_Wrap_Struct(rb_cMdAry, GC_NOT_MARKED, GC_DONT_FREE, md_ary);+  rb_hash_foreach(md_ary_hash, grpc_rb_md_ary_capacity_hash_cb, md_ary_obj);+  md_ary->metadata = gpr_malloc(md_ary->capacity * sizeof(grpc_metadata));+  rb_hash_foreach(md_ary_hash, grpc_rb_md_ary_fill_hash_cb, md_ary_obj); } -/* Queue a status for writing.--   call-seq:-      tag = Object.new-      call.write_status(200, ""OK"", tag)--   REQUIRES: No other writes are pending on the call. It is only safe to-   start the next write after the corresponding write_accepted event-   is received.-   GRPC_INVOKE_ACCEPTED must have been received by the application-   prior to calling this.-   Only callable on the server.-   Produces a GRPC_FINISHED event when the status is sent and the stream is-   fully closed */-static VALUE grpc_rb_call_start_write_status(VALUE self, VALUE code,-                                             VALUE status, VALUE tag) {-  grpc_call *call = NULL;-  grpc_call_error err;-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_start_write_status_old(call, NUM2UINT(code),-                                         StringValueCStr(status), ROBJECT(tag));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""start write status: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);+/* Converts a metadata array to a hash. */+VALUE grpc_rb_md_ary_to_h(grpc_metadata_array *md_ary) {+  VALUE key = Qnil;+  VALUE new_ary = Qnil;+  VALUE value = Qnil;+  VALUE result = rb_hash_new();+  size_t i;++  for (i = 0; i < md_ary->count; i++) {+    key = rb_str_new2(md_ary->metadata[i].key);+    value = rb_hash_aref(result, key);+    if (value == Qnil) {+      value = rb_str_new(md_ary->metadata[i].value,+                         md_ary->metadata[i].value_length);+      rb_hash_aset(result, key, value);+    } else if (TYPE(value) == T_ARRAY) {+      /* Add the string to the returned array */+      rb_ary_push(value,+                  rb_str_new(md_ary->metadata[i].value,+                             md_ary->metadata[i].value_length));+    } else {+      /* Add the current value with this key and the new one to an array */+      new_ary = rb_ary_new();+      rb_ary_push(new_ary, value);+      rb_ary_push(new_ary,+                  rb_str_new(md_ary->metadata[i].value,+                             md_ary->metadata[i].value_length));+      rb_hash_aset(result, key, new_ary);+    }   }+  return result;+} -  return Qnil;+/* grpc_rb_call_check_op_keys_hash_cb is a hash iteration func that checks+   each key of an ops hash is valid.+*/+int grpc_rb_call_check_op_keys_hash_cb(VALUE key, VALUE val, VALUE ops_ary) {+  /* Update the capacity; the value is an array, add capacity for each value in+   * the array */+  if (TYPE(key) != T_FIXNUM) {+    rb_raise(rb_eTypeError, ""invalid operation : got <%s>, want <Fixnum>"",+             rb_obj_classname(key));+    return ST_STOP;+  }+  switch(NUM2INT(key)) {+    case GRPC_OP_SEND_INITIAL_METADATA:+    case GRPC_OP_SEND_MESSAGE:+    case GRPC_OP_SEND_CLOSE_FROM_CLIENT:+    case GRPC_OP_SEND_STATUS_FROM_SERVER:+    case GRPC_OP_RECV_INITIAL_METADATA:+    case GRPC_OP_RECV_MESSAGE:+    case GRPC_OP_RECV_STATUS_ON_CLIENT:+    case GRPC_OP_RECV_CLOSE_ON_SERVER:+      rb_ary_push(ops_ary, key);+      return ST_CONTINUE;+    default:+      rb_raise(rb_eTypeError, ""invalid operation : bad value %d"",+               NUM2INT(key));+  };+  return ST_STOP; } -/* No more messages to send.-   REQUIRES: No other writes are pending on the call. */-static VALUE grpc_rb_call_writes_done(VALUE self, VALUE tag) {-  grpc_call *call = NULL;-  grpc_call_error err;-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_writes_done_old(call, ROBJECT(tag));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""writes done: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);+/* grpc_rb_op_update_status_from_server adds the values in a ruby status+   struct to the 'send_status_from_server' portion of an op.+*/+void grpc_rb_op_update_status_from_server(grpc_op *op,+                                          grpc_metadata_array* md_ary,+                                          VALUE status) {+  VALUE code = rb_struct_aref(status, sym_code);+  VALUE details = rb_struct_aref(status, sym_details);+  VALUE metadata_hash = rb_struct_aref(status, sym_metadata);++  /* TODO: add check to ensure status is the correct struct type */+  if (TYPE(code) != T_FIXNUM) {+    rb_raise(rb_eTypeError, ""invalid code : got <%s>, want <Fixnum>"",+             rb_obj_classname(code));+    return;+  }+  if (TYPE(details) != T_STRING) {+    rb_raise(rb_eTypeError, ""invalid details : got <%s>, want <String>"",+             rb_obj_classname(code));+    return;   }+  op->data.send_status_from_server.status = NUM2INT(code);+  op->data.send_status_from_server.status_details = StringValueCStr(details);+  grpc_rb_md_ary_convert(metadata_hash, md_ary);+  op->data.send_status_from_server.trailing_metadata_count = md_ary->count;+  op->data.send_status_from_server.trailing_metadata = md_ary->metadata;+} -  return Qnil;+/* run_batch_stack holds various values used by the+ * grpc_rb_call_run_batch function */+typedef struct run_batch_stack {+  /* The batch ops */+  grpc_op ops[8];  /* 8 is the maximum number of operations */+  size_t op_num;   /* tracks the last added operation */++  /* Data being sent */+  grpc_metadata_array send_metadata;+  grpc_metadata_array send_trailing_metadata;++  /* Data being received */+  grpc_byte_buffer *recv_message;+  grpc_metadata_array recv_metadata;+  grpc_metadata_array recv_trailing_metadata;+  int recv_cancelled;+  grpc_status_code recv_status;+  char *recv_status_details;+  size_t recv_status_details_capacity;+} run_batch_stack;++/* grpc_run_batch_stack_init ensures the run_batch_stack is properly+ * initialized */+static void grpc_run_batch_stack_init(run_batch_stack* st) {+  MEMZERO(st, run_batch_stack, 1);+  grpc_metadata_array_init(&st->send_metadata);+  grpc_metadata_array_init(&st->send_trailing_metadata);+  grpc_metadata_array_init(&st->recv_metadata);+  grpc_metadata_array_init(&st->recv_trailing_metadata);+  st->op_num = 0; } -/* call-seq:-     call.server_end_initial_metadata(flag)--   Only to be called on servers, before sending messages.-   flags is a bit-field combination of the write flags defined above.--   REQUIRES: Can be called at most once per call.-             Can only be called on the server, must be called after-             grpc_call_server_accept-   Produces no events */-static VALUE grpc_rb_call_server_end_initial_metadata(int argc, VALUE *argv,-                                                      VALUE self) {-  VALUE flags = Qnil;-  grpc_call *call = NULL;-  grpc_call_error err;+/* grpc_run_batch_stack_cleanup ensures the run_batch_stack is properly+ * cleaned up */+static void grpc_run_batch_stack_cleanup(run_batch_stack* st) {+  grpc_metadata_array_destroy(&st->send_metadata);","Depending on the use case of metadata(e.g. sendMetadata vs recvMetadata), you need to also delete the keys and values of the metadata, so having the same handling for send_metadata and recv_metadata here looks suspicious.. Perhaps you are already doing the right cleanup that somewhere else, but please make sure you free everything that needs to be freed.",x
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/1188,27822307,2015-04-06T19:27:16Z,src/ruby/ext/grpc/rb_call.c,"@@ -299,147 +181,397 @@ static VALUE grpc_rb_call_set_metadata(VALUE self, VALUE metadata) {   return rb_ivar_set(self, id_metadata, metadata); } -/*-  call-seq:-     call.start_write(byte_buffer, tag, flags=nil)--   Queue a byte buffer for writing.-   flags is a bit-field combination of the write flags defined above.-   A write with byte_buffer null is allowed, and will not send any bytes on the-   wire. If this is performed without GRPC_WRITE_BUFFER_HINT flag it provides-   a mechanism to flush any previously buffered writes to outgoing flow control.-   REQUIRES: No other writes are pending on the call. It is only safe to-             start the next write after the corresponding write_accepted event-             is received.-             GRPC_INVOKE_ACCEPTED must have been received by the application-             prior to calling this on the client. On the server,-             grpc_call_accept must have been called successfully.-   Produces a GRPC_WRITE_ACCEPTED event. */-static VALUE grpc_rb_call_start_write(int argc, VALUE *argv, VALUE self) {-  VALUE byte_buffer = Qnil;-  VALUE tag = Qnil;-  VALUE flags = Qnil;-  grpc_call *call = NULL;-  grpc_byte_buffer *bfr = NULL;-  grpc_call_error err;+/* grpc_rb_md_ary_fill_hash_cb is the hash iteration callback used+   to fill grpc_metadata_array.++   it's capacity should have been computed via a prior call to+   grpc_rb_md_ary_fill_hash_cb+*/+int grpc_rb_md_ary_fill_hash_cb(VALUE key, VALUE val, VALUE md_ary_obj) {+  grpc_metadata_array *md_ary = NULL;+  int array_length;+  int i;++  /* Construct a metadata object from key and value and add it */+  Data_Get_Struct(md_ary_obj, grpc_metadata_array, md_ary); -  /* ""21"" == 2 mandatory args, 1 (flags) is optional */-  rb_scan_args(argc, argv, ""21"", &byte_buffer, &tag, &flags);-  if (NIL_P(flags)) {-    flags = UINT2NUM(0); /* Default to no flags */+  if (TYPE(val) == T_ARRAY) {+    /* If the value is an array, add capacity for each value in the array */+    array_length = RARRAY_LEN(val);+    for (i = 0; i < array_length; i++) {+      if (TYPE(key) == T_SYMBOL) {+        md_ary->metadata[md_ary->count].key = (char *)rb_id2name(SYM2ID(key));+      } else { /* StringValueCStr does all other type exclusions for us */+        md_ary->metadata[md_ary->count].key = StringValueCStr(key);+      }+      md_ary->metadata[md_ary->count].value = RSTRING_PTR(rb_ary_entry(val, i));+      md_ary->metadata[md_ary->count].value_length =+        RSTRING_LEN(rb_ary_entry(val, i));+      md_ary->count += 1;+    }+  } else {+    if (TYPE(key) == T_SYMBOL) {+      md_ary->metadata[md_ary->count].key = (char *)rb_id2name(SYM2ID(key));+    } else { /* StringValueCStr does all other type exclusions for us */+      md_ary->metadata[md_ary->count].key = StringValueCStr(key);+    }+    md_ary->metadata[md_ary->count].value = RSTRING_PTR(val);+    md_ary->metadata[md_ary->count].value_length = RSTRING_LEN(val);+    md_ary->count += 1;   }-  bfr = grpc_rb_get_wrapped_byte_buffer(byte_buffer);-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_start_write_old(call, bfr, ROBJECT(tag), NUM2UINT(flags));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""start write failed: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);++  return ST_CONTINUE;+}++/* grpc_rb_md_ary_capacity_hash_cb is the hash iteration callback used+   to pre-compute the capacity a grpc_metadata_array.+*/+int grpc_rb_md_ary_capacity_hash_cb(VALUE key, VALUE val, VALUE md_ary_obj) {+  grpc_metadata_array *md_ary = NULL;++  /* Construct a metadata object from key and value and add it */+  Data_Get_Struct(md_ary_obj, grpc_metadata_array, md_ary);++  if (TYPE(val) == T_ARRAY) {+    /* If the value is an array, add capacity for each value in the array */+    md_ary->capacity += RARRAY_LEN(val);+  } else {+    md_ary->capacity += 1;+  }+  return ST_CONTINUE;+}++/* grpc_rb_md_ary_convert converts a ruby metadata hash into+   a grpc_metadata_array.+*/+void grpc_rb_md_ary_convert(VALUE md_ary_hash, grpc_metadata_array *md_ary) {+  VALUE md_ary_obj = Qnil;+  if (md_ary_hash == Qnil) {+    return;  /* Do nothing if the expected has value is nil */+  }+  if (TYPE(md_ary_hash) != T_HASH) {+    rb_raise(rb_eTypeError, ""md_ary_convert: got <%s>, want <Hash>"",+             rb_obj_classname(md_ary_hash));+    return;   } -  return Qnil;+  /* Initialize the array, compute it's capacity, then fill it. */+  grpc_metadata_array_init(md_ary);+  md_ary_obj = Data_Wrap_Struct(rb_cMdAry, GC_NOT_MARKED, GC_DONT_FREE, md_ary);+  rb_hash_foreach(md_ary_hash, grpc_rb_md_ary_capacity_hash_cb, md_ary_obj);+  md_ary->metadata = gpr_malloc(md_ary->capacity * sizeof(grpc_metadata));+  rb_hash_foreach(md_ary_hash, grpc_rb_md_ary_fill_hash_cb, md_ary_obj); } -/* Queue a status for writing.--   call-seq:-      tag = Object.new-      call.write_status(200, ""OK"", tag)--   REQUIRES: No other writes are pending on the call. It is only safe to-   start the next write after the corresponding write_accepted event-   is received.-   GRPC_INVOKE_ACCEPTED must have been received by the application-   prior to calling this.-   Only callable on the server.-   Produces a GRPC_FINISHED event when the status is sent and the stream is-   fully closed */-static VALUE grpc_rb_call_start_write_status(VALUE self, VALUE code,-                                             VALUE status, VALUE tag) {-  grpc_call *call = NULL;-  grpc_call_error err;-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_start_write_status_old(call, NUM2UINT(code),-                                         StringValueCStr(status), ROBJECT(tag));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""start write status: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);+/* Converts a metadata array to a hash. */+VALUE grpc_rb_md_ary_to_h(grpc_metadata_array *md_ary) {+  VALUE key = Qnil;+  VALUE new_ary = Qnil;+  VALUE value = Qnil;+  VALUE result = rb_hash_new();+  size_t i;++  for (i = 0; i < md_ary->count; i++) {+    key = rb_str_new2(md_ary->metadata[i].key);+    value = rb_hash_aref(result, key);+    if (value == Qnil) {+      value = rb_str_new(md_ary->metadata[i].value,+                         md_ary->metadata[i].value_length);+      rb_hash_aset(result, key, value);+    } else if (TYPE(value) == T_ARRAY) {+      /* Add the string to the returned array */+      rb_ary_push(value,+                  rb_str_new(md_ary->metadata[i].value,+                             md_ary->metadata[i].value_length));+    } else {+      /* Add the current value with this key and the new one to an array */+      new_ary = rb_ary_new();+      rb_ary_push(new_ary, value);+      rb_ary_push(new_ary,+                  rb_str_new(md_ary->metadata[i].value,+                             md_ary->metadata[i].value_length));+      rb_hash_aset(result, key, new_ary);+    }   }+  return result;+} -  return Qnil;+/* grpc_rb_call_check_op_keys_hash_cb is a hash iteration func that checks+   each key of an ops hash is valid.+*/+int grpc_rb_call_check_op_keys_hash_cb(VALUE key, VALUE val, VALUE ops_ary) {+  /* Update the capacity; the value is an array, add capacity for each value in+   * the array */+  if (TYPE(key) != T_FIXNUM) {+    rb_raise(rb_eTypeError, ""invalid operation : got <%s>, want <Fixnum>"",+             rb_obj_classname(key));+    return ST_STOP;+  }+  switch(NUM2INT(key)) {+    case GRPC_OP_SEND_INITIAL_METADATA:+    case GRPC_OP_SEND_MESSAGE:+    case GRPC_OP_SEND_CLOSE_FROM_CLIENT:+    case GRPC_OP_SEND_STATUS_FROM_SERVER:+    case GRPC_OP_RECV_INITIAL_METADATA:+    case GRPC_OP_RECV_MESSAGE:+    case GRPC_OP_RECV_STATUS_ON_CLIENT:+    case GRPC_OP_RECV_CLOSE_ON_SERVER:+      rb_ary_push(ops_ary, key);+      return ST_CONTINUE;+    default:+      rb_raise(rb_eTypeError, ""invalid operation : bad value %d"",+               NUM2INT(key));+  };+  return ST_STOP; } -/* No more messages to send.-   REQUIRES: No other writes are pending on the call. */-static VALUE grpc_rb_call_writes_done(VALUE self, VALUE tag) {-  grpc_call *call = NULL;-  grpc_call_error err;-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_writes_done_old(call, ROBJECT(tag));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""writes done: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);+/* grpc_rb_op_update_status_from_server adds the values in a ruby status+   struct to the 'send_status_from_server' portion of an op.+*/+void grpc_rb_op_update_status_from_server(grpc_op *op,+                                          grpc_metadata_array* md_ary,+                                          VALUE status) {+  VALUE code = rb_struct_aref(status, sym_code);+  VALUE details = rb_struct_aref(status, sym_details);+  VALUE metadata_hash = rb_struct_aref(status, sym_metadata);++  /* TODO: add check to ensure status is the correct struct type */+  if (TYPE(code) != T_FIXNUM) {+    rb_raise(rb_eTypeError, ""invalid code : got <%s>, want <Fixnum>"",+             rb_obj_classname(code));+    return;+  }+  if (TYPE(details) != T_STRING) {+    rb_raise(rb_eTypeError, ""invalid details : got <%s>, want <String>"",+             rb_obj_classname(code));+    return;   }+  op->data.send_status_from_server.status = NUM2INT(code);+  op->data.send_status_from_server.status_details = StringValueCStr(details);+  grpc_rb_md_ary_convert(metadata_hash, md_ary);+  op->data.send_status_from_server.trailing_metadata_count = md_ary->count;+  op->data.send_status_from_server.trailing_metadata = md_ary->metadata;+} -  return Qnil;+/* run_batch_stack holds various values used by the+ * grpc_rb_call_run_batch function */+typedef struct run_batch_stack {+  /* The batch ops */+  grpc_op ops[8];  /* 8 is the maximum number of operations */+  size_t op_num;   /* tracks the last added operation */++  /* Data being sent */+  grpc_metadata_array send_metadata;+  grpc_metadata_array send_trailing_metadata;++  /* Data being received */+  grpc_byte_buffer *recv_message;+  grpc_metadata_array recv_metadata;+  grpc_metadata_array recv_trailing_metadata;+  int recv_cancelled;+  grpc_status_code recv_status;+  char *recv_status_details;+  size_t recv_status_details_capacity;+} run_batch_stack;++/* grpc_run_batch_stack_init ensures the run_batch_stack is properly+ * initialized */+static void grpc_run_batch_stack_init(run_batch_stack* st) {+  MEMZERO(st, run_batch_stack, 1);+  grpc_metadata_array_init(&st->send_metadata);+  grpc_metadata_array_init(&st->send_trailing_metadata);+  grpc_metadata_array_init(&st->recv_metadata);+  grpc_metadata_array_init(&st->recv_trailing_metadata);+  st->op_num = 0; } -/* call-seq:-     call.server_end_initial_metadata(flag)--   Only to be called on servers, before sending messages.-   flags is a bit-field combination of the write flags defined above.--   REQUIRES: Can be called at most once per call.-             Can only be called on the server, must be called after-             grpc_call_server_accept-   Produces no events */-static VALUE grpc_rb_call_server_end_initial_metadata(int argc, VALUE *argv,-                                                      VALUE self) {-  VALUE flags = Qnil;-  grpc_call *call = NULL;-  grpc_call_error err;+/* grpc_run_batch_stack_cleanup ensures the run_batch_stack is properly+ * cleaned up */+static void grpc_run_batch_stack_cleanup(run_batch_stack* st) {+  grpc_metadata_array_destroy(&st->send_metadata);",Here's an example of what C# does.https://github.com/grpc/grpc/blob/master/src/csharp/ext/grpc_csharp_ext.c#L194,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1185,27834861,2015-04-06T21:59:14Z,include/grpc++/impl/sync_no_cxx11.h,"@@ -0,0 +1,98 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_SYNC_NO_CXX11_H+#define GRPCXX_IMPL_SYNC_NO_CXX11_H++#include <grpc/support/sync.h>++namespace grpc {++template<class mutex>+class lock_guard;+class condition_variable;++class mutex {+ public:+  mutex() { gpr_mu_init(&mu_); }+  ~mutex() { gpr_mu_destroy(&mu_); }+ private:+  ::gpr_mu mu_;+  template <class mutex>+  friend class lock_guard;+  friend class condition_variable;+};++template <class mutex>+class lock_guard {+ public:+   lock_guard(mutex &mu) : mu_(mu), locked(true) { gpr_mu_lock(&mu.mu_); }+   ~lock_guard() { unlock(); }+  void lock() {+    if (!locked) gpr_mu_lock(&mu_.mu_);+    locked = true;+  }+  void unlock() {+    if (locked) gpr_mu_unlock(&mu_.mu_);+    locked = false;+  }+ private:+  mutex &mu_;+  bool locked;+  friend class condition_variable;+};++template <class mutex>+class unique_lock : public lock_guard<mutex> {+ public:+   unique_lock(mutex &mu) : lock_guard(mu) { }+};+",Similar to my above comment. I am concerned about creating inheritance relationships in the no-C++11 build that aren't present in the actual C++11 build. Composition seems like a safer path than inheritance to reduce the likelihood that some programmer somewhere actually confounds the two in a piece of code that we have to sort out later.,x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1185,27840406,2015-04-06T23:27:58Z,include/grpc++/impl/sync_no_cxx11.h,"@@ -0,0 +1,98 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_SYNC_NO_CXX11_H+#define GRPCXX_IMPL_SYNC_NO_CXX11_H++#include <grpc/support/sync.h>++namespace grpc {++template<class mutex>+class lock_guard;+class condition_variable;++class mutex {+ public:+  mutex() { gpr_mu_init(&mu_); }+  ~mutex() { gpr_mu_destroy(&mu_); }+ private:+  ::gpr_mu mu_;+  template <class mutex>+  friend class lock_guard;+  friend class condition_variable;+};++template <class mutex>+class lock_guard {+ public:","So, how about the new change I'm proposing. I still have the inheritance of unique_lock over lock_guard, but that's really to try to maintain a single codepath for basically doing the same thing. I hate having two different codepaths for doing the same thing: it just calls for errors when fixing a problem with one, and forgetting the other one.This time however I made lock / unlock be protected, and made available from unique_lock. This way we get the lock / unlock semantic available only in the unique_lock version.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1217,27904341,2015-04-07T18:10:44Z,tools/distrib/python/submit.py,"@@ -40,7 +40,7 @@  # Make the push. cmd = ['python', 'setup.py', 'sdist']-subprocess.call(cmd)+subprocess.call(cmd, cwd=pkgdir)","This content change is not mentioned in the commit log message - is it intended or is it stray?If it is intended, please split this commit into two separate commits. Substantive-content-changes and version-bumb-changes should be isolated from one another.Also if the content change is intended and separated out into its commit, be sure to include in the commit log message something like ""this change was accidentally omitted from (citation to earlier pull request or commit)"" if that text does indeed reflect the reality.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/1244,28153792,2015-04-10T15:25:20Z,build.json,"@@ -532,6 +532,36 @@       ""secure"": ""no""     },     {+      ""name"": ""interop_client_lib"",+      ""build"": ""private"",+      ""language"": ""c++"",+      ""src"": [+        ""test/cpp/interop/empty.proto"",+        ""test/cpp/interop/messages.proto"",+        ""test/cpp/interop/test.proto"",+        ""test/cpp/interop/client_helper.cc"",+        ""test/cpp/interop/interop_client.cc""+      ],+      ""deps"": [+        ""grpc_test_util"",+        ""grpc++"",+        ""grpc"",+        ""gpr_test_util"",+        ""gpr""+      ]+    },+    {+      ""name"": ""interop_server_lib"",+      ""build"": ""private"",+      ""language"": ""c++"",+      ""src"": [+        ""test/cpp/interop/server_helper.cc""+      ],+      ""deps"": [+        ""grpc++""",I changed it a bit to reflect what I use. Does it even matter? What is the general guideline to put things in deps of a library?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1240,28153996,2015-04-10T15:27:37Z,test/cpp/qps/smoke_test.cc,"@@ -0,0 +1,179 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/log.h>++#include ""test/cpp/qps/driver.h""+#include ""test/cpp/qps/stats.h""++namespace grpc {+namespace testing {++static const int WARMUP = 5;+static const int BENCHMARK = 10;++static void RunSynchronousUnaryPingPong() {+  gpr_log(GPR_INFO, ""Running Synchronous Unary Ping Pong"");++  ClientConfig client_config;+  client_config.set_client_type(SYNCHRONOUS_CLIENT);+  client_config.set_enable_ssl(false);+  client_config.set_outstanding_rpcs_per_channel(1);+  client_config.set_client_channels(1);+  client_config.set_payload_size(1);+  client_config.set_rpc_type(UNARY);++  ServerConfig server_config;+  server_config.set_server_type(SYNCHRONOUS_SERVER);+  server_config.set_enable_ssl(false);+  server_config.set_threads(1);++  auto result = RunScenario(client_config, 1, server_config, 1, WARMUP, BENCHMARK);++  gpr_log(GPR_INFO, ""QPS: %.1f"",+          result.latencies.Count() /+              average(result.client_resources,+                      [](ResourceUsage u) { return u.wall_time; }));+  gpr_log(GPR_INFO, ""Latencies (50/95/99/99.9%%-ile): %.1f/%.1f/%.1f/%.1f us"",+          result.latencies.Percentile(50) / 1000,+          result.latencies.Percentile(95) / 1000,+          result.latencies.Percentile(99) / 1000,+          result.latencies.Percentile(99.9) / 1000);+}++static void RunSynchronousStreamingPingPong() {+  gpr_log(GPR_INFO, ""Running Synchronous Streaming Ping Pong"");++  ClientConfig client_config;+  client_config.set_client_type(SYNCHRONOUS_CLIENT);+  client_config.set_enable_ssl(false);+  client_config.set_outstanding_rpcs_per_channel(1);+  client_config.set_client_channels(1);+  client_config.set_payload_size(1);+  client_config.set_rpc_type(STREAMING);++  ServerConfig server_config;+  server_config.set_server_type(SYNCHRONOUS_SERVER);+  server_config.set_enable_ssl(false);+  server_config.set_threads(1);++  auto result = RunScenario(client_config, 1, server_config, 1, WARMUP, BENCHMARK);++  gpr_log(GPR_INFO, ""QPS: %.1f"",+          result.latencies.Count() /+              average(result.client_resources,+                      [](ResourceUsage u) { return u.wall_time; }));+  gpr_log(GPR_INFO, ""Latencies (50/95/99/99.9%%-ile): %.1f/%.1f/%.1f/%.1f us"",+          result.latencies.Percentile(50) / 1000,+          result.latencies.Percentile(95) / 1000,+          result.latencies.Percentile(99) / 1000,+          result.latencies.Percentile(99.9) / 1000);+}++static void RunAsyncUnaryPingPong() {+  gpr_log(GPR_INFO, ""Running Async Unary Ping Pong"");++  ClientConfig client_config;+  client_config.set_client_type(ASYNC_CLIENT);+  client_config.set_enable_ssl(false);+  client_config.set_outstanding_rpcs_per_channel(1);+  client_config.set_client_channels(1);+  client_config.set_payload_size(1);+  client_config.set_async_client_threads(1);+  client_config.set_rpc_type(UNARY);++  ServerConfig server_config;+  server_config.set_server_type(ASYNC_SERVER);+  server_config.set_enable_ssl(false);+  server_config.set_threads(1);++  auto result = RunScenario(client_config, 1, server_config, 1, WARMUP, BENCHMARK);++  gpr_log(GPR_INFO, ""QPS: %.1f"",+          result.latencies.Count() /+              average(result.client_resources,+                      [](ResourceUsage u) { return u.wall_time; }));+  gpr_log(GPR_INFO, ""Latencies (50/95/99/99.9%%-ile): %.1f/%.1f/%.1f/%.1f us"",+          result.latencies.Percentile(50) / 1000,+          result.latencies.Percentile(95) / 1000,+          result.latencies.Percentile(99) / 1000,+          result.latencies.Percentile(99.9) / 1000);+}++static void RunQPS() {+  gpr_log(GPR_INFO, ""Running QPS test"");++  ClientConfig client_config;+  client_config.set_client_type(ASYNC_CLIENT);+  client_config.set_enable_ssl(false);+  client_config.set_outstanding_rpcs_per_channel(1000);+  client_config.set_client_channels(8);+  client_config.set_payload_size(1);+  client_config.set_async_client_threads(8);+  client_config.set_rpc_type(UNARY);++  ServerConfig server_config;+  server_config.set_server_type(ASYNC_SERVER);+  server_config.set_enable_ssl(false);+  server_config.set_threads(4);++  auto result = RunScenario(client_config, 1, server_config, 1, WARMUP, BENCHMARK);++  auto qps = +      result.latencies.Count() /+      average(result.client_resources,+          [](ResourceUsage u) { return u.wall_time; });++  gpr_log(GPR_INFO, ""QPS: %.1f (%.1f/core)"", qps, qps/client_config.client_channels());+  gpr_log(GPR_INFO, ""Latencies (50/95/99/99.9%%-ile): %.1f/%.1f/%.1f/%.1f us"",+          result.latencies.Percentile(50) / 1000,+          result.latencies.Percentile(95) / 1000,+          result.latencies.Percentile(99) / 1000,+          result.latencies.Percentile(99.9) / 1000);+}++}  // namespace testing+}  // namespace grpc+",Added a small library to capture this.,
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/1188,28172638,2015-04-10T19:18:27Z,src/ruby/ext/grpc/rb_call.c,"@@ -299,147 +181,397 @@ static VALUE grpc_rb_call_set_metadata(VALUE self, VALUE metadata) {   return rb_ivar_set(self, id_metadata, metadata); } -/*-  call-seq:-     call.start_write(byte_buffer, tag, flags=nil)--   Queue a byte buffer for writing.-   flags is a bit-field combination of the write flags defined above.-   A write with byte_buffer null is allowed, and will not send any bytes on the-   wire. If this is performed without GRPC_WRITE_BUFFER_HINT flag it provides-   a mechanism to flush any previously buffered writes to outgoing flow control.-   REQUIRES: No other writes are pending on the call. It is only safe to-             start the next write after the corresponding write_accepted event-             is received.-             GRPC_INVOKE_ACCEPTED must have been received by the application-             prior to calling this on the client. On the server,-             grpc_call_accept must have been called successfully.-   Produces a GRPC_WRITE_ACCEPTED event. */-static VALUE grpc_rb_call_start_write(int argc, VALUE *argv, VALUE self) {-  VALUE byte_buffer = Qnil;-  VALUE tag = Qnil;-  VALUE flags = Qnil;-  grpc_call *call = NULL;-  grpc_byte_buffer *bfr = NULL;-  grpc_call_error err;+/* grpc_rb_md_ary_fill_hash_cb is the hash iteration callback used+   to fill grpc_metadata_array.++   it's capacity should have been computed via a prior call to+   grpc_rb_md_ary_fill_hash_cb+*/+int grpc_rb_md_ary_fill_hash_cb(VALUE key, VALUE val, VALUE md_ary_obj) {+  grpc_metadata_array *md_ary = NULL;+  int array_length;+  int i;++  /* Construct a metadata object from key and value and add it */+  Data_Get_Struct(md_ary_obj, grpc_metadata_array, md_ary); -  /* ""21"" == 2 mandatory args, 1 (flags) is optional */-  rb_scan_args(argc, argv, ""21"", &byte_buffer, &tag, &flags);-  if (NIL_P(flags)) {-    flags = UINT2NUM(0); /* Default to no flags */+  if (TYPE(val) == T_ARRAY) {+    /* If the value is an array, add capacity for each value in the array */+    array_length = RARRAY_LEN(val);+    for (i = 0; i < array_length; i++) {+      if (TYPE(key) == T_SYMBOL) {+        md_ary->metadata[md_ary->count].key = (char *)rb_id2name(SYM2ID(key));+      } else { /* StringValueCStr does all other type exclusions for us */+        md_ary->metadata[md_ary->count].key = StringValueCStr(key);+      }+      md_ary->metadata[md_ary->count].value = RSTRING_PTR(rb_ary_entry(val, i));+      md_ary->metadata[md_ary->count].value_length =+        RSTRING_LEN(rb_ary_entry(val, i));+      md_ary->count += 1;+    }+  } else {+    if (TYPE(key) == T_SYMBOL) {+      md_ary->metadata[md_ary->count].key = (char *)rb_id2name(SYM2ID(key));+    } else { /* StringValueCStr does all other type exclusions for us */+      md_ary->metadata[md_ary->count].key = StringValueCStr(key);+    }+    md_ary->metadata[md_ary->count].value = RSTRING_PTR(val);+    md_ary->metadata[md_ary->count].value_length = RSTRING_LEN(val);+    md_ary->count += 1;   }-  bfr = grpc_rb_get_wrapped_byte_buffer(byte_buffer);-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_start_write_old(call, bfr, ROBJECT(tag), NUM2UINT(flags));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""start write failed: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);++  return ST_CONTINUE;+}++/* grpc_rb_md_ary_capacity_hash_cb is the hash iteration callback used+   to pre-compute the capacity a grpc_metadata_array.+*/+int grpc_rb_md_ary_capacity_hash_cb(VALUE key, VALUE val, VALUE md_ary_obj) {+  grpc_metadata_array *md_ary = NULL;++  /* Construct a metadata object from key and value and add it */+  Data_Get_Struct(md_ary_obj, grpc_metadata_array, md_ary);++  if (TYPE(val) == T_ARRAY) {+    /* If the value is an array, add capacity for each value in the array */+    md_ary->capacity += RARRAY_LEN(val);+  } else {+    md_ary->capacity += 1;+  }+  return ST_CONTINUE;+}++/* grpc_rb_md_ary_convert converts a ruby metadata hash into+   a grpc_metadata_array.+*/+void grpc_rb_md_ary_convert(VALUE md_ary_hash, grpc_metadata_array *md_ary) {+  VALUE md_ary_obj = Qnil;+  if (md_ary_hash == Qnil) {+    return;  /* Do nothing if the expected has value is nil */+  }+  if (TYPE(md_ary_hash) != T_HASH) {+    rb_raise(rb_eTypeError, ""md_ary_convert: got <%s>, want <Hash>"",+             rb_obj_classname(md_ary_hash));+    return;   } -  return Qnil;+  /* Initialize the array, compute it's capacity, then fill it. */+  grpc_metadata_array_init(md_ary);+  md_ary_obj = Data_Wrap_Struct(rb_cMdAry, GC_NOT_MARKED, GC_DONT_FREE, md_ary);+  rb_hash_foreach(md_ary_hash, grpc_rb_md_ary_capacity_hash_cb, md_ary_obj);+  md_ary->metadata = gpr_malloc(md_ary->capacity * sizeof(grpc_metadata));+  rb_hash_foreach(md_ary_hash, grpc_rb_md_ary_fill_hash_cb, md_ary_obj); } -/* Queue a status for writing.--   call-seq:-      tag = Object.new-      call.write_status(200, ""OK"", tag)--   REQUIRES: No other writes are pending on the call. It is only safe to-   start the next write after the corresponding write_accepted event-   is received.-   GRPC_INVOKE_ACCEPTED must have been received by the application-   prior to calling this.-   Only callable on the server.-   Produces a GRPC_FINISHED event when the status is sent and the stream is-   fully closed */-static VALUE grpc_rb_call_start_write_status(VALUE self, VALUE code,-                                             VALUE status, VALUE tag) {-  grpc_call *call = NULL;-  grpc_call_error err;-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_start_write_status_old(call, NUM2UINT(code),-                                         StringValueCStr(status), ROBJECT(tag));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""start write status: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);+/* Converts a metadata array to a hash. */+VALUE grpc_rb_md_ary_to_h(grpc_metadata_array *md_ary) {+  VALUE key = Qnil;+  VALUE new_ary = Qnil;+  VALUE value = Qnil;+  VALUE result = rb_hash_new();+  size_t i;++  for (i = 0; i < md_ary->count; i++) {+    key = rb_str_new2(md_ary->metadata[i].key);+    value = rb_hash_aref(result, key);+    if (value == Qnil) {+      value = rb_str_new(md_ary->metadata[i].value,+                         md_ary->metadata[i].value_length);+      rb_hash_aset(result, key, value);+    } else if (TYPE(value) == T_ARRAY) {+      /* Add the string to the returned array */+      rb_ary_push(value,+                  rb_str_new(md_ary->metadata[i].value,+                             md_ary->metadata[i].value_length));+    } else {+      /* Add the current value with this key and the new one to an array */+      new_ary = rb_ary_new();+      rb_ary_push(new_ary, value);+      rb_ary_push(new_ary,+                  rb_str_new(md_ary->metadata[i].value,+                             md_ary->metadata[i].value_length));+      rb_hash_aset(result, key, new_ary);+    }   }+  return result;+} -  return Qnil;+/* grpc_rb_call_check_op_keys_hash_cb is a hash iteration func that checks+   each key of an ops hash is valid.+*/+int grpc_rb_call_check_op_keys_hash_cb(VALUE key, VALUE val, VALUE ops_ary) {+  /* Update the capacity; the value is an array, add capacity for each value in+   * the array */+  if (TYPE(key) != T_FIXNUM) {+    rb_raise(rb_eTypeError, ""invalid operation : got <%s>, want <Fixnum>"",+             rb_obj_classname(key));+    return ST_STOP;+  }+  switch(NUM2INT(key)) {+    case GRPC_OP_SEND_INITIAL_METADATA:+    case GRPC_OP_SEND_MESSAGE:+    case GRPC_OP_SEND_CLOSE_FROM_CLIENT:+    case GRPC_OP_SEND_STATUS_FROM_SERVER:+    case GRPC_OP_RECV_INITIAL_METADATA:+    case GRPC_OP_RECV_MESSAGE:+    case GRPC_OP_RECV_STATUS_ON_CLIENT:+    case GRPC_OP_RECV_CLOSE_ON_SERVER:+      rb_ary_push(ops_ary, key);+      return ST_CONTINUE;+    default:+      rb_raise(rb_eTypeError, ""invalid operation : bad value %d"",+               NUM2INT(key));+  };+  return ST_STOP; } -/* No more messages to send.-   REQUIRES: No other writes are pending on the call. */-static VALUE grpc_rb_call_writes_done(VALUE self, VALUE tag) {-  grpc_call *call = NULL;-  grpc_call_error err;-  Data_Get_Struct(self, grpc_call, call);-  err = grpc_call_writes_done_old(call, ROBJECT(tag));-  if (err != GRPC_CALL_OK) {-    rb_raise(rb_eCallError, ""writes done: %s (code=%d)"",-             grpc_call_error_detail_of(err), err);+/* grpc_rb_op_update_status_from_server adds the values in a ruby status+   struct to the 'send_status_from_server' portion of an op.+*/+void grpc_rb_op_update_status_from_server(grpc_op *op,+                                          grpc_metadata_array* md_ary,+                                          VALUE status) {+  VALUE code = rb_struct_aref(status, sym_code);+  VALUE details = rb_struct_aref(status, sym_details);+  VALUE metadata_hash = rb_struct_aref(status, sym_metadata);++  /* TODO: add check to ensure status is the correct struct type */+  if (TYPE(code) != T_FIXNUM) {+    rb_raise(rb_eTypeError, ""invalid code : got <%s>, want <Fixnum>"",+             rb_obj_classname(code));+    return;+  }+  if (TYPE(details) != T_STRING) {+    rb_raise(rb_eTypeError, ""invalid details : got <%s>, want <String>"",+             rb_obj_classname(code));+    return;   }+  op->data.send_status_from_server.status = NUM2INT(code);+  op->data.send_status_from_server.status_details = StringValueCStr(details);+  grpc_rb_md_ary_convert(metadata_hash, md_ary);+  op->data.send_status_from_server.trailing_metadata_count = md_ary->count;+  op->data.send_status_from_server.trailing_metadata = md_ary->metadata;+} -  return Qnil;+/* run_batch_stack holds various values used by the+ * grpc_rb_call_run_batch function */+typedef struct run_batch_stack {+  /* The batch ops */+  grpc_op ops[8];  /* 8 is the maximum number of operations */+  size_t op_num;   /* tracks the last added operation */++  /* Data being sent */+  grpc_metadata_array send_metadata;+  grpc_metadata_array send_trailing_metadata;++  /* Data being received */+  grpc_byte_buffer *recv_message;+  grpc_metadata_array recv_metadata;+  grpc_metadata_array recv_trailing_metadata;+  int recv_cancelled;+  grpc_status_code recv_status;+  char *recv_status_details;+  size_t recv_status_details_capacity;+} run_batch_stack;++/* grpc_run_batch_stack_init ensures the run_batch_stack is properly+ * initialized */+static void grpc_run_batch_stack_init(run_batch_stack* st) {+  MEMZERO(st, run_batch_stack, 1);+  grpc_metadata_array_init(&st->send_metadata);+  grpc_metadata_array_init(&st->send_trailing_metadata);+  grpc_metadata_array_init(&st->recv_metadata);+  grpc_metadata_array_init(&st->recv_trailing_metadata);+  st->op_num = 0; } -/* call-seq:-     call.server_end_initial_metadata(flag)--   Only to be called on servers, before sending messages.-   flags is a bit-field combination of the write flags defined above.--   REQUIRES: Can be called at most once per call.-             Can only be called on the server, must be called after-             grpc_call_server_accept-   Produces no events */-static VALUE grpc_rb_call_server_end_initial_metadata(int argc, VALUE *argv,-                                                      VALUE self) {-  VALUE flags = Qnil;-  grpc_call *call = NULL;-  grpc_call_error err;+/* grpc_run_batch_stack_cleanup ensures the run_batch_stack is properly+ * cleaned up */+static void grpc_run_batch_stack_cleanup(run_batch_stack* st) {+  grpc_metadata_array_destroy(&st->send_metadata);","I looked into this, and I'm sure this is OK, at least its consistent with the C# exampleOn sending, the keys and values pointers to data that's already in ruby objects, and these will be cleaned up once those objects are garbage collected, so it's only necessary to cleanup the metadata.On receiving, it's only necessary to clean up the metadata as the underlying c-layer will take care of cleaning the keys and values.  Ruby makes copies of them which it manages.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1267,28258362,2015-04-13T17:22:54Z,src/core/statistics/timers.c,"@@ -0,0 +1,162 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""timers.h""++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpc/support/sync.h>+#include <stdio.h>++typedef struct grpc_timer_entry {+#ifdef GRPC_TIMERS_RDTSC+#error Rdtsc timers not supported yet","I'd suggest moving this to port_platform.h somehow, to avoid any #ifdef in the middle of a struct.",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1277,28392908,2015-04-15T04:40:05Z,src/core/transport/chttp2/stream_encoder.c,"@@ -601,4 +608,15 @@ void grpc_chttp2_encode(grpc_stream_op *ops, size_t ops_count, int eof,     begin_frame(&st, DATA);   }   finish_frame(&st, 1, eof);++  if (need_unref) {+    grpc_mdctx_lock(mdctx);+    for (unref_op = 0; unref_op < curop; unref_op++) {+      op = &ops[unref_op];+      if (op->type != GRPC_OP_METADATA) continue;+      if (!op->data.metadata) continue;+      grpc_mdctx_locked_mdelem_unref(mdctx, op->data.metadata);+    }+    grpc_mdctx_unlock(mdctx);+  }","Overall, this is very nice, and will help reduce locks dramatically. Is there a potential tail latency issue under contention because of holding the lock for longer? I don't expect it (I would actually expect an improvement because of a reduction in lock contention), but it is something that we ought to have a way to benchmark. Not now; just wanted to put my thought about it in writing.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/1311,28636440,2015-04-17T23:01:06Z,doc/interop-test-descriptions.md,"@@ -293,16 +297,14 @@ Procedure:  Asserts: * call was successful-* received SimpleResponse.username equals FLAGS_default_service_account-* received SimpleResponse.oauth_scope is in FLAGS_oauth_scope+* received SimpleResponse.username equals --default_service_account+* received SimpleResponse.oauth_scope is in --oauth_scope","What does ""is in"" mean? Why isn't it just equals? If `--oauth_scope` is a list, then it needs to be given a format (such as comma-separated).",x
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/1311,28636590,2015-04-17T23:05:14Z,doc/interop-test-descriptions.md,"@@ -678,8 +677,12 @@ canonical form of the authenticated source. The canonical form is dependent on the authentication method, but is likely to be a base 10 integer identifier or an email address. +If a SimpleRequest has fill_oauth_scope=true and that request was successfully authenticated via OAuth, then the SimpleResponse should have oauth_scope filled with the scope of the method being invoked.",This section is a partial duplicate of the paragraph above (that I said to split out). The text from both should be combined.,x
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/1311,28636603,2015-04-17T23:05:51Z,doc/interop-test-descriptions.md,"@@ -678,8 +677,12 @@ canonical form of the authenticated source. The canonical form is dependent on the authentication method, but is likely to be a base 10 integer identifier or an email address. +If a SimpleRequest has fill_oauth_scope=true and that request was successfully authenticated via OAuth, then the SimpleResponse should have oauth_scope filled with the scope of the method being invoked.",Please wrap long lines.,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/1312,28664642,2015-04-20T05:25:19Z,include/grpc/grpc.h,"@@ -186,6 +186,13 @@ typedef struct grpc_metadata {   const char *key;   const char *value;   size_t value_length;++  /* The following fields are reserved for grpc internal use.+     There is no need to initialize them, and they will be set to garbage during+     calls to grpc. */+  struct {+    void *some_random_pointers[3];","I don't really like ""random"" here. How about:``` cstruct {  void *obfuscated[3];} internal_data;```?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1312,28701917,2015-04-20T16:00:31Z,src/core/channel/census_filter.c,"@@ -62,11 +62,13 @@ static void init_rpc_stats(census_rpc_stats* stats) {  static void extract_and_annotate_method_tag(grpc_call_op* op, call_data* calld,                                             channel_data* chand) {-  if (op->data.metadata->key == chand->path_str) {-    gpr_log(GPR_DEBUG,-            (const char*)GPR_SLICE_START_PTR(op->data.metadata->value->slice));-    census_add_method_tag(calld->op_id, (const char*)GPR_SLICE_START_PTR(-                                            op->data.metadata->value->slice));+  grpc_linked_mdelem* m;+  for (m = op->data.metadata.list.head; m; m = m->next) {+    if (m->md->key == chand->path_str) {+      gpr_log(GPR_DEBUG, (const char*)GPR_SLICE_START_PTR(m->md->value->slice));",The metadata stuff does some work to guarantee null termination.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1319,28741040,2015-04-21T00:15:25Z,test/cpp/qps/stats.h,"@@ -43,7 +43,7 @@ namespace testing { template <class T, class F> double sum(const T& container, F functor) {   double r = 0;-  for (auto v = container.begin(); v != container.end(); v++) {+  for (auto v = container.begin(); v != container.end(); ++v) {",So... it was to make it consistent within the file with changes I decided not to make... I'll revert it... it was only accidentally pulled in.,x
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/1312,28803956,2015-04-21T17:51:21Z,src/core/surface/call.h,"@@ -86,7 +85,10 @@ typedef void (*grpc_ioreq_completion_func)(grpc_call *call,                                            void *user_data);  grpc_call *grpc_call_create(grpc_channel *channel, grpc_completion_queue *cq,-                            const void *server_transport_data);+                            const void *server_transport_data,+                            grpc_mdelem **add_initial_metadata,",Could this be `initial_metadata_to_add` or just `initial_metadata`? I would prefer to not have an array name that looks like a function.,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/1312,28807274,2015-04-21T18:24:41Z,src/core/transport/stream_op.c,"@@ -164,10 +173,161 @@ void grpc_sopb_append(grpc_stream_op_buffer *sopb, grpc_stream_op *ops,   size_t orig_nops = sopb->nops;   size_t new_nops = orig_nops + nops; +  assert_contained_metadata_ok(ops, nops);+  assert_contained_metadata_ok(sopb->ops, sopb->nops);   if (new_nops > sopb->capacity) {     expandto(sopb, GPR_MAX(GROW(sopb->capacity), new_nops));   }    memcpy(sopb->ops + orig_nops, ops, sizeof(grpc_stream_op) * nops);   sopb->nops = new_nops;+  assert_contained_metadata_ok(sopb->ops, sopb->nops);+}++static void assert_valid_list(grpc_mdelem_list *list) {+#ifndef NDEBUG+  grpc_linked_mdelem *l;++  GPR_ASSERT((list->head == NULL) == (list->tail == NULL));+  if (!list->head) return;+  GPR_ASSERT(list->head->prev == NULL);+  GPR_ASSERT(list->tail->next == NULL);+  GPR_ASSERT((list->head == list->tail) == (list->head->next == NULL));++  for (l = list->head; l; l = l->next) {+    GPR_ASSERT(l->md);+    GPR_ASSERT((l->prev == NULL) == (l == list->head));+    GPR_ASSERT((l->next == NULL) == (l == list->tail));+    if (l->next) GPR_ASSERT(l->next->prev == l);+    if (l->prev) GPR_ASSERT(l->prev->next == l);+  }+#endif+}++#ifndef NDEBUG+void grpc_metadata_batch_assert_ok(grpc_metadata_batch *comd) {+  assert_valid_list(&comd->list);+  assert_valid_list(&comd->garbage);+}+#endif++void grpc_metadata_batch_init(grpc_metadata_batch *comd) {+  comd->list.head = comd->list.tail = comd->garbage.head = comd->garbage.tail =+      NULL;+  comd->deadline = gpr_inf_future;+}++void grpc_metadata_batch_destroy(grpc_metadata_batch *comd) {+  grpc_linked_mdelem *l;+  for (l = comd->list.head; l; l = l->next) {+    grpc_mdelem_unref(l->md);+  }+  for (l = comd->garbage.head; l; l = l->next) {+    grpc_mdelem_unref(l->md);+  }+}++void grpc_metadata_batch_add_head(grpc_metadata_batch *comd,+                                  grpc_linked_mdelem *storage,+                                  grpc_mdelem *elem_to_add) {+  GPR_ASSERT(elem_to_add);+  storage->md = elem_to_add;+  grpc_metadata_batch_link_head(comd, storage);+}++static void link_head(grpc_mdelem_list *list, grpc_linked_mdelem *storage) {",Looks like all these functions are generic and could be factored out in some kind of `gpr_list`. Hopefully in another PR...,x
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/1312,28812594,2015-04-21T19:20:04Z,src/core/security/auth.c,"@@ -159,6 +144,7 @@ static void on_host_checked(void *user_data, grpc_security_status status) {     gpr_asprintf(&error_msg, ""Invalid host %s set in :authority metadata."",                  grpc_mdstr_as_c_string(calld->host));     bubbleup_error(elem, error_msg);+    grpc_metadata_batch_destroy(&calld->op.data.metadata);","Of course.On Tue, Apr 21, 2015 at 11:59 AM, Craig Tiller notifications@github.comwrote:> In src/core/security/auth.c> https://github.com/grpc/grpc/pull/1312#discussion_r28810880:> > > @@ -159,6 +144,7 @@ static void on_host_checked(void *user_data, grpc_security_status status) {> >      gpr_asprintf(&error_msg, ""Invalid host %s set in :authority metadata."",> >                   grpc_mdstr_as_c_string(calld->host));> >      bubbleup_error(elem, error_msg);> > -    grpc_metadata_batch_destroy(&calld->op.data.metadata);> > If I promise to remove the need for it in the next PR in this series, can> we leave it?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/1312/files#r28810880.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1333,28831832,2015-04-21T23:14:22Z,src/core/iomgr/tcp_windows.c,"@@ -266,7 +266,6 @@ static grpc_endpoint_write_status win_write(grpc_endpoint *ep,   WSABUF *buffers = local_buffers;    GPR_ASSERT(nslices != 0);-  GPR_ASSERT(GPR_SLICE_LENGTH(slices[0]) != 0);","I feel this is a leftover from former, depreciated Posix port. I can't find the equivalent in the posix code anymore, meaning this is indeed no longer relevant anymore. I feel we also want to remove the assert above on nslices != 0 since it doesn't exist in posix either.",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1317,28908780,2015-04-22T19:57:57Z,tools/gce_setup/private_build_and_test.sh,"@@ -0,0 +1,54 @@+#!/bin/bash++# This script has to be run from the same directory as grpc_docker.sh and after grpc_docker.sh is sourced+#+# Sample Usage:+# ===============================+# ./private_build_and_test.sh [language] [environment: interop|cloud] [test case]+#                              [git base directory] [server name in interop environment] +# sh private_build_and_test.sh java interop large_unary /usr/local/google/home/donnadionne/grpc-git grpc-docker-server1+# sh private_build_and_test.sh java cloud large_unary /usr/local/google/home/donnadionne/grpc-git+# =============================== ++# Arguments+LANGUAGE=$1+ENV=$2+TEST=$3+GIT=$4+SERVER=${5:-""grpc-docker-server""}++sudo docker run --name=""private_images"" -v $4:/var/local/git-clone grpc/$1 /var/local/git-clone/grpc/tools/dockerfile/grpc_$1/build.sh++sudo docker commit -m ""private image"" -a ""donnadionne"" private_images grpc/private_images++sudo docker tag -f grpc/private_images 0.0.0.0:5000/grpc/private_images++sudo docker push 0.0.0.0:5000/grpc/private_images++sudo docker rmi -f grpc/private_images++sudo docker rm private_images++gcloud compute --project ""stoked-keyword-656"" ssh --zone ""asia-east1-a"" ""grpc-docker-testclients1"" --command ""sudo docker pull 0.0.0.0:5000/grpc/private_images""","Let's parameterize the project name to start with at least -- $PROJECT_NAMEperhaps, from a command line arg?On Wed, Apr 22, 2015 at 12:55 PM donnadionne notifications@github.comwrote:> In tools/gce_setup/private_build_and_test.sh> https://github.com/grpc/grpc/pull/1317#discussion_r28908530:> > > +GIT=$4> > +SERVER=${5:-""grpc-docker-server""}> > +> > +sudo docker run --name=""private_images"" -v $4:/var/local/git-clone grpc/$1 /var/local/git-clone/grpc/tools/dockerfile/grpc_$1/build.sh> > +> > +sudo docker commit -m ""private image"" -a ""donnadionne"" private_images grpc/private_images> > +> > +sudo docker tag -f grpc/private_images 0.0.0.0:5000/grpc/private_images> > +> > +sudo docker push 0.0.0.0:5000/grpc/private_images> > +> > +sudo docker rmi -f grpc/private_images> > +> > +sudo docker rm private_images> > +> > +gcloud compute --project ""stoked-keyword-656"" ssh --zone ""asia-east1-a"" ""grpc-docker-testclients1"" --command ""sudo docker pull 0.0.0.0:5000/grpc/private_images""> > I see.> > No people who are not a part of our project will not be able to use the> script.> > For them the plan is provide a recipe. For example, include instructions> like they would need a cloud environment where they have vms, some sort of> a storage system, etc... and then they can take the script, make some> modifications or pass in some arguments to make it work.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/1317/files#r28908530.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1352,28974290,2015-04-23T15:37:58Z,include/grpc/support/time.h,"@@ -47,7 +47,11 @@ extern ""C"" {  typedef struct gpr_timespec {     time_t tv_sec;+#if defined(GPR_WIN32) && defined(GPR_ARCH_64)","I don't understand the reason for this: tv_nsec by definition won't get bigger than 1 billion, which will fit into an int on 64bit Windows.It (might) be better if we use gpr_int32 here instead for some 16 bit platforms, but I don't think that's what this pull request is trying to support.",
5418049,zeliard,https://api.github.com/repos/grpc/grpc/pulls/1352,29009935,2015-04-23T22:29:02Z,src/core/support/slice_buffer.c,"@@ -117,7 +117,7 @@ void gpr_slice_buffer_add(gpr_slice_buffer *sb, gpr_slice s) {                s.data.inlined.bytes, s.data.inlined.length);         back->data.inlined.length += s.data.inlined.length;       } else {-        size_t cp1 = GPR_SLICE_INLINED_SIZE - back->data.inlined.length;+		gpr_uint32 cp1 = GPR_SLICE_INLINED_SIZE - back->data.inlined.length;","there are type casting problems on Win64 when using both size_t and 32bit int on am expression.I think that cp1 will not bigger than INT_MAX. So, I changed it.If there are something better solutions in this case, could you let me know?",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1352,29009937,2015-04-23T22:29:03Z,include/grpc/support/time.h,"@@ -47,7 +47,11 @@ extern ""C"" {  typedef struct gpr_timespec {     time_t tv_sec;+#if defined(GPR_WIN32) && defined(GPR_ARCH_64)","But while the typecastings should raise a warning, they shouldn't be erroneous, because mathematically, we know that the data fits.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29077792,2015-04-24T19:22:14Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -193,14 +191,17 @@ - (void)startNextRead {   }   __weak GRPCCall *weakSelf = self;   __weak GRPCDelegateWrapper *weakWriteable = _responseWriteable;-+     dispatch_async(_callQueue, ^{-    [weakSelf startReadWithHandler:^(grpc_event *event) {-      if (!event->data.read) {-        // No more responses from the server.+    [weakSelf startReadWithHandler:^(NSDictionary *event) {+      NSData *data = event[[NSNumber numberWithInt:GRPC_OP_RECV_MESSAGE]];+      if (data == [NSNull null]) {","if (!data || data == [NSNull null]), returnBut then, why do we put [NSNull null] there?",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29078018,2015-04-24T19:25:17Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -225,35 +226,11 @@ - (void)startNextRead {  #pragma mark Send headers -- (void)addHeaderWithName:(NSString *)name binaryValue:(NSData *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.bytes;-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}--- (void)addHeaderWithName:(NSString *)name ASCIIValue:(NSString *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.UTF8String;-  // The trailing \0 isn't encoded in HTTP2.-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}--// TODO(jcanizales): Rename to commitHeaders. - (void)sendHeaders:(NSDictionary *)metadata {-  for (NSString *name in metadata) {-    id value = metadata[name];-    if ([value isKindOfClass:[NSData class]]) {-      [self addHeaderWithName:name binaryValue:value];-    } else if ([value isKindOfClass:[NSString class]]) {-      [self addHeaderWithName:name ASCIIValue:value];-    }+  if (metadata == nil) {","Remove this if and change the use of ""metadata"" in the startBatch call below for ""metadata ?: @{}""",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29079316,2015-04-24T19:42:52Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.h,"@@ -0,0 +1,51 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef Pods_GRPCWrappedCall_h+#define Pods_GRPCWrappedCall_h++#import <Foundation/Foundation.h>+#import ""GRPCChannel.h""++typedef void(^GRPCCompletionHandler)(NSDictionary *);++@interface GRPCWrappedCall:NSObject;++- (instancetype)initWithChannel:(GRPCChannel *)channel method:(NSString *)method host:(NSString *)host;++- (void)startBatch:(NSDictionary *)ops handleCompletion:(GRPCCompletionHandler)handleCompletion;","Check https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-BCIGIJJF for method naming conventions.Maybe -startBatchWithOperations:(NSDictionary *)operations completionHandler:(GRPCCompletionHandler)completionHandler;But that still has the problem of not describing why ""operations"" is a dictionary instead of an array. Why is it?",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29079995,2015-04-24T19:52:33Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,193 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import <Foundation/Foundation.h>+#import ""GRPCWrappedCall.h""+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>","We're following this for formatting imports and includes: http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Names_and_Order_of_IncludesSo:wrappedcall.hfoundationgrpc/...""stuff from this library""",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1363,29080003,2015-04-24T19:52:38Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -332,32 +295,28 @@ - (void)didFinishWithError:(NSError *)errorOrNil { // after this. // The first one (metadataHandler), when the response headers are received. // The second one (completionHandler), whenever the RPC finishes for any reason.-- (void)invokeCallWithMetadataHandler:(GRPCEventHandler)metadataHandler-                    completionHandler:(GRPCEventHandler)completionHandler {-  AssertNoErrorInCall(grpc_call_invoke_old(_gRPCCall,-                                           _completionQueue.unmanagedQueue,-                                           (__bridge_retained void *)metadataHandler,-                                           (__bridge_retained void *)completionHandler,-                                           0));+- (void)invokeCallWithMetadataHandler:(GRPCCompletionHandler)metadataHandler+                    completionHandler:(GRPCCompletionHandler)completionHandler {+  [_wrappedCall startBatch:@{@(GRPC_OP_RECV_INITIAL_METADATA): @YES} handleCompletion:metadataHandler];+  [_wrappedCall startBatch:@{@(GRPC_OP_RECV_STATUS_ON_CLIENT): @YES} handleCompletion:completionHandler];","The plan is that after this pull request is merged, we will split Call into 4 classes, for each type of streaming. Then we will be able to have batches with multiple operations. But the current Call class represents bidi streaming, which requires more separation of operations in different batches.In this particular case, if we put both of those in the same batch, we won't have the initial metadata from the server until the call finishes and we also have the status.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1363,29080153,2015-04-24T19:54:48Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.h,"@@ -0,0 +1,51 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef Pods_GRPCWrappedCall_h+#define Pods_GRPCWrappedCall_h++#import <Foundation/Foundation.h>+#import ""GRPCChannel.h""++typedef void(^GRPCCompletionHandler)(NSDictionary *);++@interface GRPCWrappedCall:NSObject;++- (instancetype)initWithChannel:(GRPCChannel *)channel method:(NSString *)method host:(NSString *)host;++- (void)startBatch:(NSDictionary *)ops handleCompletion:(GRPCCompletionHandler)handleCompletion;","`ops` is basically a sparse array, where the value type depends on the key. I thought a map was a good data structure to represent that. If you think a different one would be better, I can change it.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29081980,2015-04-24T20:18:26Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,193 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import <Foundation/Foundation.h>+#import ""GRPCWrappedCall.h""+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>++@implementation GRPCWrappedCall{+  grpc_call *call;+  GRPCCompletionQueue *queue;+}++- (instancetype)init {+  return [self initWithChannel:nil method:nil host:nil];+}++- (instancetype)initWithChannel:(GRPCChannel *)channel method:(NSString *)method host:(NSString *)host {+  if (!channel || !method || !host) {+    [NSException raise:NSInvalidArgumentException format:@""channel, method, and host cannot be nil.""];+  }+  +  if (self = [super init]) {+    static dispatch_once_t initialization;+    dispatch_once(&initialization, ^{+      grpc_init();+    });+    +    const char *method_str = [method UTF8String];+    const char *host_str = [host UTF8String];+    queue = [GRPCCompletionQueue completionQueue];+    call = grpc_channel_create_call(channel.unmanagedChannel, queue.unmanagedQueue, method_str, host_str, gpr_inf_future);+    if (call == NULL) {+      return nil;+    }+  }+  return self;+}++- (void)startBatch:(NSDictionary *)ops handleCompletion:(GRPCCompletionHandler)handleCompletion {+  size_t nops = ops.count;+  grpc_op *ops_array = gpr_malloc(nops * sizeof(grpc_op));+  size_t index = 0;+  NSMutableDictionary * __block opProcessors = [NSMutableDictionary new];+  +  grpc_metadata *send_metadata = NULL;+  grpc_metadata_array *recv_initial_metadata;+  grpc_metadata_array *recv_trailing_metadata;+  grpc_byte_buffer *send_message;+  grpc_byte_buffer **recv_message = NULL;+  grpc_status_code *status_code;+  char **status_details;+  size_t *status_details_capacity;+  for (id key in ops) {+    id (^opBlock)(void);+    grpc_op *current = &ops_array[index];+    switch ([key intValue]) {+      case GRPC_OP_SEND_INITIAL_METADATA:+        current->data.send_initial_metadata.count = [ops[key] grpc_toMetadataArray:&send_metadata];+        current->data.send_initial_metadata.metadata = send_metadata;",Please add a // TODO(jcanizales): Name the type of current->send_initial_metadata in the C library so a pointer to it can be returned from methods.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29084229,2015-04-24T20:45:46Z,src/objective-c/GRPCClient/private/NSDictionary+GRPC.h,"@@ -32,9 +32,9 @@  */  #import <Foundation/Foundation.h>--struct grpc_metadata;+#include <grpc/grpc.h>  @interface NSDictionary (GRPC) + (instancetype)grpc_dictionaryFromMetadata:(struct grpc_metadata *)entries count:(size_t)count;+- (size_t)grpc_toMetadataArray:(grpc_metadata **)metadata;","Methods that return data indirectly via pointers provided by the caller are named getX:y:z: (check https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html )So this one should be:- grpc_getMetadataArray:(grpc_metadata **)metadata count:(size_t *)count;Although NSDictionary already has a count property, so returning it here seems redundant.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29084669,2015-04-24T20:51:34Z,src/objective-c/GRPCClient/private/NSDictionary+GRPC.m,"@@ -53,4 +54,24 @@ + (instancetype)grpc_dictionaryFromMetadata:(grpc_metadata *)entries count:(size   }   return metadata; }++- (size_t)grpc_toMetadataArray:(grpc_metadata **)metadata {+  size_t count = 0;+  size_t capacity = 0;+  for (id key in self) {+    capacity += [self[key] count];+  }+  *metadata = gpr_malloc(capacity * sizeof(grpc_metadata));+  for (id key in self) {+    id value_array = self[key];","Please check GRPCCall.h's documentation for the structure of the metadata dictionary. It's not an map NSString -> NSString[], but a map NSString -> (NSString | NSData). You can see how to properly handle it in the previous implementation of GRPCCall::sendHeaders (line 248).",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29086805,2015-04-24T21:19:31Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,193 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import <Foundation/Foundation.h>+#import ""GRPCWrappedCall.h""+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>++@implementation GRPCWrappedCall{+  grpc_call *call;+  GRPCCompletionQueue *queue;+}++- (instancetype)init {+  return [self initWithChannel:nil method:nil host:nil];+}++- (instancetype)initWithChannel:(GRPCChannel *)channel method:(NSString *)method host:(NSString *)host {+  if (!channel || !method || !host) {+    [NSException raise:NSInvalidArgumentException format:@""channel, method, and host cannot be nil.""];+  }+  +  if (self = [super init]) {+    static dispatch_once_t initialization;+    dispatch_once(&initialization, ^{+      grpc_init();+    });+    +    const char *method_str = [method UTF8String];+    const char *host_str = [host UTF8String];+    queue = [GRPCCompletionQueue completionQueue];+    call = grpc_channel_create_call(channel.unmanagedChannel, queue.unmanagedQueue, method_str, host_str, gpr_inf_future);+    if (call == NULL) {+      return nil;+    }+  }+  return self;+}++- (void)startBatch:(NSDictionary *)ops handleCompletion:(GRPCCompletionHandler)handleCompletion {+  size_t nops = ops.count;+  grpc_op *ops_array = gpr_malloc(nops * sizeof(grpc_op));+  size_t index = 0;+  NSMutableDictionary * __block opProcessors = [NSMutableDictionary new];+  +  grpc_metadata *send_metadata = NULL;+  grpc_metadata_array *recv_initial_metadata;+  grpc_metadata_array *recv_trailing_metadata;+  grpc_byte_buffer *send_message;+  grpc_byte_buffer **recv_message = NULL;+  grpc_status_code *status_code;+  char **status_details;+  size_t *status_details_capacity;+  for (id key in ops) {+    id (^opBlock)(void);+    grpc_op *current = &ops_array[index];+    switch ([key intValue]) {+      case GRPC_OP_SEND_INITIAL_METADATA:+        current->data.send_initial_metadata.count = [ops[key] grpc_toMetadataArray:&send_metadata];+        current->data.send_initial_metadata.metadata = send_metadata;+        opBlock = ^{+          gpr_free(send_metadata);+          return @YES;+        };+        break;+      case GRPC_OP_SEND_MESSAGE:+        send_message = [ops[key] grpc_byteBuffer];","Having the types of the elements of a container depend on a tag is a smell that polymorphism should be used instead.In this case, it seems you just want each object passed by the caller to:1. Fill in a grpc_op \* you pass it.2. Give you an opProcessor block that is to be called later on.So you can declare a @protocol with one or two methods to accomplish that, and 6 classes that conform to that protocol, one per allowed operation. Doing it will give us static typing of the parameters you're now putting in the Dictionary, separation of concerns (each operation class is only concerned about how to translate its Objective-C parameters to a grpc_op), and will make this method more readable by removing the 70-lines-long switch statement :)You don't have to create a different file for each of those classes if you prefer not to; you can declare them in GRPCWrappedCall.h and implement them in GRPCWrappedCall.m, as they are only used in the context of GRPCWrappedCall.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29090678,2015-04-24T22:20:07Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -332,32 +295,28 @@ - (void)didFinishWithError:(NSError *)errorOrNil { // after this. // The first one (metadataHandler), when the response headers are received. // The second one (completionHandler), whenever the RPC finishes for any reason.-- (void)invokeCallWithMetadataHandler:(GRPCEventHandler)metadataHandler-                    completionHandler:(GRPCEventHandler)completionHandler {-  AssertNoErrorInCall(grpc_call_invoke_old(_gRPCCall,-                                           _completionQueue.unmanagedQueue,-                                           (__bridge_retained void *)metadataHandler,-                                           (__bridge_retained void *)completionHandler,-                                           0));+- (void)invokeCallWithMetadataHandler:(GRPCCompletionHandler)metadataHandler+                    completionHandler:(GRPCCompletionHandler)completionHandler {+  [_wrappedCall startBatch:@{@(GRPC_OP_RECV_INITIAL_METADATA): @YES} handleCompletion:metadataHandler];+  [_wrappedCall startBatch:@{@(GRPC_OP_RECV_STATUS_ON_CLIENT): @YES} handleCompletion:completionHandler];","Ah, I see. That split is problematic, though, as this specific library is agnostic to Protocol Buffers, and thus unaware of the stream/non-stream distinction: The gRPC protocol defines calls as bidi streams. To complicate the library in such a way we should have a very compelling reason.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29172134,2015-04-27T17:56:49Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -225,35 +221,9 @@ - (void)startNextRead {  #pragma mark Send headers -- (void)addHeaderWithName:(NSString *)name binaryValue:(NSData *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.bytes;-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}--- (void)addHeaderWithName:(NSString *)name ASCIIValue:(NSString *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.UTF8String;-  // The trailing \0 isn't encoded in HTTP2.-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}- // TODO(jcanizales): Rename to commitHeaders. - (void)sendHeaders:(NSDictionary *)metadata {-  for (NSString *name in metadata) {-    id value = metadata[name];-    if ([value isKindOfClass:[NSData class]]) {-      [self addHeaderWithName:name binaryValue:value];-    } else if ([value isKindOfClass:[NSString class]]) {-      [self addHeaderWithName:name ASCIIValue:value];-    }-  }+  [_wrappedCall startBatchWithOperations:@[[[GRPCOpSendMetadata alloc] initWithMetadata:metadata?:@{} handler:nil]]];","nit: spaces around the elvis operator ?:If the handler is always nil for OpSendMetadata, let's just remove it from the initializer.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29172505,2015-04-27T17:59:56Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -225,35 +221,9 @@ - (void)startNextRead {  #pragma mark Send headers -- (void)addHeaderWithName:(NSString *)name binaryValue:(NSData *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.bytes;-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}--- (void)addHeaderWithName:(NSString *)name ASCIIValue:(NSString *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.UTF8String;-  // The trailing \0 isn't encoded in HTTP2.-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}- // TODO(jcanizales): Rename to commitHeaders. - (void)sendHeaders:(NSDictionary *)metadata {-  for (NSString *name in metadata) {-    id value = metadata[name];-    if ([value isKindOfClass:[NSData class]]) {-      [self addHeaderWithName:name binaryValue:value];-    } else if ([value isKindOfClass:[NSString class]]) {-      [self addHeaderWithName:name ASCIIValue:value];-    }-  }+  [_wrappedCall startBatchWithOperations:@[[[GRPCOpSendMetadata alloc] initWithMetadata:metadata?:@{} handler:nil]]];","Although if there's no metadata, do we really have to call the send_metadata operation in the C API?",x
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1363,29174096,2015-04-27T18:14:46Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -225,35 +221,9 @@ - (void)startNextRead {  #pragma mark Send headers -- (void)addHeaderWithName:(NSString *)name binaryValue:(NSData *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.bytes;-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}--- (void)addHeaderWithName:(NSString *)name ASCIIValue:(NSString *)value {-  grpc_metadata metadata;-  // Safe to discard const qualifiers; we're not going to modify the contents.-  metadata.key = (char *)name.UTF8String;-  metadata.value = (char *)value.UTF8String;-  // The trailing \0 isn't encoded in HTTP2.-  metadata.value_length = value.length;-  grpc_call_add_metadata_old(_gRPCCall, &metadata, 0);-}- // TODO(jcanizales): Rename to commitHeaders. - (void)sendHeaders:(NSDictionary *)metadata {-  for (NSString *name in metadata) {-    id value = metadata[name];-    if ([value isKindOfClass:[NSData class]]) {-      [self addHeaderWithName:name binaryValue:value];-    } else if ([value isKindOfClass:[NSString class]]) {-      [self addHeaderWithName:name ASCIIValue:value];-    }-  }+  [_wrappedCall startBatchWithOperations:@[[[GRPCOpSendMetadata alloc] initWithMetadata:metadata?:@{} handler:nil]]];",Fixed the spaces.We don't know that the handler will always be `nil`. We shouldn't write the `GRPCWrappedCall` API based on its usage in the current iteration of `GRPCCall`.We do have call the `send_metadata` operation in the C API to indicate that there is no metadata to send and that the call can proceed.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29185225,2015-04-27T20:06:37Z,src/objective-c/GRPCClient/private/GRPCCompletionQueue.m,"@@ -66,30 +66,17 @@ - (instancetype)init {       while (YES) {         // The following call blocks until an event is available.         grpc_event *event = grpc_completion_queue_next(unmanagedQueue, gpr_inf_future);+        GRPCQueueCompletionHandler handler;         switch (event->type) {-          case GRPC_WRITE_ACCEPTED:-          case GRPC_FINISH_ACCEPTED:-          case GRPC_CLIENT_METADATA_READ:-          case GRPC_READ:-          case GRPC_FINISHED:-            if (event->tag) {-              GRPCEventHandler handler = (__bridge_transfer GRPCEventHandler) event->tag;-              handler(event);-            }-            grpc_event_finish(event);-            continue;+          case GRPC_OP_COMPLETE:+            handler = (__bridge_transfer GRPCQueueCompletionHandler)event->tag;+            handler(event->data.op_complete);+            break;           case GRPC_QUEUE_SHUTDOWN:-            grpc_completion_queue_destroy(unmanagedQueue);-            grpc_event_finish(event);             return;-          case GRPC_SERVER_RPC_NEW:-            NSAssert(NO, @""C gRPC library produced a server-only event."");-            continue;+          default:+            [NSException raise:@""Unrecognized completion type"" format:@""""];","Just to confirm: the C library is guaranteeing us that it'll only ever send us events of the two types above, and anything else is a bug, correct?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29209895,2015-04-28T02:20:02Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -92,7 +93,7 @@ @interface GRPCCall () <GRXWriteable> @implementation GRPCCall {   dispatch_queue_t _callQueue;","Thanks. The comment is still confusing because it's explaining implementation choices based on things that don't happen in this class anymore. But it doesn't work to move it into GRPCWrappedCall as is: We'll have to move _callQueue and _callAlreadyInvoked there, making GRPCWrappedCall thread-safe. Let's do it in a separate PR though, to keep this one focused.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29210579,2015-04-28T02:42:40Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -167,9 +156,8 @@ - (void)cancel { }  - (void)dealloc {-  grpc_call *gRPCCall = _gRPCCall;   dispatch_async(_callQueue, ^{-    grpc_call_destroy(gRPCCall);+    _wrappedCall = nil;","To be able and set the ivar, the block retains a reference to `self` (this line is equivalent to `self->_wrappedCall = nil;`). We don't want this, because we're in the middle of deallocating self :) So when the block runs, anything could now be in the position in memory where we're writing `nil` (and sending `-release`!). What we want here is to retain only `_wrappedCall`. To do that, use the same pattern we had with `_gRPCCall`:``` objective-cGRPCWrappedCall *wrappedCall = _wrappedCall;dispatch_async(_callQueue, ^{  wrappedCall = nil;});```",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29210697,2015-04-28T02:47:07Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -195,12 +183,10 @@ - (void)startNextRead {   __weak GRPCDelegateWrapper *weakWriteable = _responseWriteable;    dispatch_async(_callQueue, ^{-    [weakSelf startReadWithHandler:^(grpc_event *event) {-      if (!event->data.read) {-        // No more responses from the server.+    [weakSelf startReadWithHandler:^(NSData *data) {+      if (data == nil) {","`data == nil` is the same as `!data` (3 lines below). We still want to distinguish the two cases: there are no more responses from the server, or there was one but we don't have enough memory to hold it.",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1380,29256151,2015-04-28T15:44:02Z,test/cpp/qps/client_sync.cc,"@@ -64,17 +66,70 @@ namespace testing {  class SynchronousClient : public Client {  public:-  SynchronousClient(const ClientConfig& config) : Client(config) {+  SynchronousClient(const ClientConfig& config) : Client(config),+                                                  interarrival_timer_() {     num_threads_ =       config.outstanding_rpcs_per_channel() * config.client_channels();     responses_.resize(num_threads_);+","Sure, I can do that. Something similar is needed in async anyway (today's project)",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29304129,2015-04-29T01:12:32Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,341 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCWrappedCall.h""+#import <Foundation/Foundation.h>+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""++@implementation GRPCOpSendMetadata{+  void(^_handler)(void);+  grpc_metadata *_send_metadata;+  size_t _count;+}++- (instancetype)init {+  return [self initWithMetadata:nil handler:nil];+}++- (instancetype)initWithMetadata:(NSDictionary *)metadata handler:(void (^)(void))handler {+  if (self = [super init]) {+    if (metadata) {+      [metadata grpc_getMetadataArray:&_send_metadata];+      _count = metadata.count;+    } else {+      _send_metadata = NULL;+      _count = 0;+    }","ivars are initialized to `0`/`NULL`/`nil`, and messaging `nil` is a noop, so the `if` block doesn't add anything. Just have:``` objective-c[metadata grpc_getMetadataArray:&_send_metadata];_count = metadata.count;```Nit: As the `grpc_getMetadataArray` method gives a pointer to allocated memory, we can have it just return the pointer, for consistency with `NSData-grpc_byteBuffer`. Then the code here is:``` objective-c_send_metadata = metadata.grpc_metadataArray;_count = metadata.count;```",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29304246,2015-04-29T01:14:41Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,341 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCWrappedCall.h""+#import <Foundation/Foundation.h>+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""++@implementation GRPCOpSendMetadata{+  void(^_handler)(void);+  grpc_metadata *_send_metadata;+  size_t _count;+}++- (instancetype)init {+  return [self initWithMetadata:nil handler:nil];+}++- (instancetype)initWithMetadata:(NSDictionary *)metadata handler:(void (^)(void))handler {+  if (self = [super init]) {+    if (metadata) {+      [metadata grpc_getMetadataArray:&_send_metadata];+      _count = metadata.count;+    } else {+      _send_metadata = NULL;+      _count = 0;+    }+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = _count;",We aren't doing anything with `_send_metadata`.,x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29304275,2015-04-29T01:15:09Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,341 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCWrappedCall.h""+#import <Foundation/Foundation.h>+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""++@implementation GRPCOpSendMetadata{+  void(^_handler)(void);+  grpc_metadata *_send_metadata;",lower camel: `_sendMetadata` (same with the ivars of the other classes),
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29305387,2015-04-29T01:46:01Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,341 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCWrappedCall.h""+#import <Foundation/Foundation.h>+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""++@implementation GRPCOpSendMetadata{+  void(^_handler)(void);+  grpc_metadata *_send_metadata;+  size_t _count;+}++- (instancetype)init {+  return [self initWithMetadata:nil handler:nil];+}++- (instancetype)initWithMetadata:(NSDictionary *)metadata handler:(void (^)(void))handler {+  if (self = [super init]) {+    if (metadata) {+      [metadata grpc_getMetadataArray:&_send_metadata];+      _count = metadata.count;+    } else {+      _send_metadata = NULL;+      _count = 0;+    }+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = _count;+}++- (void (^)(void))opProcessor {+  return ^{+    gpr_free(_send_metadata);+    if (_handler) {+      _handler();+    }+  };+}++@end++@implementation GRPCOpSendMessage{+  void(^_handler)(void);+  grpc_byte_buffer *_byte_buffer;+}++- (instancetype)init {+  return [self initWithMessage:nil handler:nil];+}++- (instancetype)initWithMessage:(NSData *)message handler:(void (^)(void))handler {+  if (!message) {+    [NSException raise:NSInvalidArgumentException format:@""message cannot be null""];+  }+  if (self = [super init]) {+    _byte_buffer = [message grpc_byteBuffer];+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_MESSAGE;+  op->data.send_message = _byte_buffer;+}++- (void (^)(void))opProcessor {+  return ^{+    gpr_free(_byte_buffer);+    if (_handler) {+      _handler();+    }+  };+}++@end++@implementation GRPCOpSendClose{+  void(^_handler)(void);+}++- (instancetype)init {+  return [self initWithHandler:nil];+}++- (instancetype)initWithHandler:(void (^)(void))handler {+  if (self = [super init]) {+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+}++- (void (^)(void))opProcessor {+  return ^{+    if (_handler) {+      _handler();+    }+  };+}++@end++@implementation GRPCOpRecvMetadata{+  void(^_handler)(NSDictionary *);+  grpc_metadata_array *_recv_initial_metadata;",We can have this be just `grpc_metadata_array _recvInitialMetadata` and the runtime will do the allocation. The memory remains valid for as long as we need it because the block returned by `opProcessor` is retaining `self` via the reference to `_handler`.Same in `GRPCOpRecvMessage` with the `byte_buffer`.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29311423,2015-04-29T05:36:04Z,src/objective-c/GRPCClient/private/GRPCCompletionQueue.m,"@@ -66,30 +66,18 @@ - (instancetype)init {       while (YES) {         // The following call blocks until an event is available.         grpc_event *event = grpc_completion_queue_next(unmanagedQueue, gpr_inf_future);+        GRPCQueueCompletionHandler handler;         switch (event->type) {-          case GRPC_WRITE_ACCEPTED:-          case GRPC_FINISH_ACCEPTED:-          case GRPC_CLIENT_METADATA_READ:-          case GRPC_READ:-          case GRPC_FINISHED:-            if (event->tag) {-              GRPCEventHandler handler = (__bridge_transfer GRPCEventHandler) event->tag;-              handler(event);-            }-            grpc_event_finish(event);-            continue;+          case GRPC_OP_COMPLETE:+            handler = (__bridge_transfer GRPCQueueCompletionHandler)event->tag;+            handler(event->data.op_complete);",From the documentation of the C library it seems we still need to call `grpc_event_finish` after we're done with an event.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29311700,2015-04-29T05:45:18Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,341 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCWrappedCall.h""+#import <Foundation/Foundation.h>+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""++@implementation GRPCOpSendMetadata{+  void(^_handler)(void);+  grpc_metadata *_send_metadata;+  size_t _count;+}++- (instancetype)init {+  return [self initWithMetadata:nil handler:nil];+}++- (instancetype)initWithMetadata:(NSDictionary *)metadata handler:(void (^)(void))handler {+  if (self = [super init]) {+    if (metadata) {+      [metadata grpc_getMetadataArray:&_send_metadata];+      _count = metadata.count;+    } else {+      _send_metadata = NULL;+      _count = 0;+    }+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = _count;+}++- (void (^)(void))opProcessor {+  return ^{+    gpr_free(_send_metadata);+    if (_handler) {+      _handler();+    }+  };+}++@end++@implementation GRPCOpSendMessage{+  void(^_handler)(void);+  grpc_byte_buffer *_byte_buffer;+}++- (instancetype)init {+  return [self initWithMessage:nil handler:nil];+}++- (instancetype)initWithMessage:(NSData *)message handler:(void (^)(void))handler {+  if (!message) {+    [NSException raise:NSInvalidArgumentException format:@""message cannot be null""];+  }+  if (self = [super init]) {+    _byte_buffer = [message grpc_byteBuffer];+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_MESSAGE;+  op->data.send_message = _byte_buffer;+}++- (void (^)(void))opProcessor {+  return ^{+    gpr_free(_byte_buffer);+    if (_handler) {+      _handler();+    }+  };+}++@end++@implementation GRPCOpSendClose{+  void(^_handler)(void);+}++- (instancetype)init {+  return [self initWithHandler:nil];+}++- (instancetype)initWithHandler:(void (^)(void))handler {+  if (self = [super init]) {+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+}++- (void (^)(void))opProcessor {+  return ^{+    if (_handler) {+      _handler();+    }+  };+}++@end++@implementation GRPCOpRecvMetadata{+  void(^_handler)(NSDictionary *);+  grpc_metadata_array *_recv_initial_metadata;+}++- (instancetype) init {+  return [self initWithHandler:nil];+}++- (instancetype) initWithHandler:(void (^)(NSDictionary *))handler {+  if (self = [super init]) {+    _handler = handler;+    _recv_initial_metadata = gpr_malloc(sizeof(grpc_metadata_array));+    grpc_metadata_array_init(_recv_initial_metadata);+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = _recv_initial_metadata;+}++- (void (^)(void))opProcessor {+  return ^{+    NSDictionary *metadata = [NSDictionary+                              grpc_dictionaryFromMetadata:_recv_initial_metadata->metadata+                              count:_recv_initial_metadata->count];+    grpc_metadata_array_destroy(_recv_initial_metadata);+    if (_handler) {+      _handler(metadata);+    }+  };+}++@end++@implementation GRPCOpRecvMessage{+  void(^_handler)(grpc_byte_buffer *);+  grpc_byte_buffer **_recv_message;+}++- (instancetype)init {+  return [self initWithHandler:nil];+}++- (instancetype)initWithHandler:(void (^)(grpc_byte_buffer *))handler {+  if (self = [super init]) {+    _handler = handler;+    _recv_message = gpr_malloc(sizeof(grpc_byte_buffer*));+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_RECV_MESSAGE;+  op->data.recv_message = _recv_message;+}++- (void (^)(void))opProcessor {+  return ^{+    if (_handler) {+      _handler(*_recv_message);+      gpr_free(_recv_message);+    }+  };+}++@end++@implementation GRPCOpRecvStatus{+  void(^_handler)(NSError *);+  grpc_status_code *_code;+  char **_details;+  size_t *_details_capacity;+  grpc_metadata_array *_recv_trailing_metadata;+}++- (instancetype) init {+  return [self initWithHandler:nil];+}++- (instancetype) initWithHandler:(void (^)(NSError *))handler {+  if (self = [super init]) {+    _handler = handler;+    _code = gpr_malloc(sizeof(grpc_status_code));+    _details = gpr_malloc(sizeof(char*));+    _details_capacity = gpr_malloc(sizeof(size_t));+    *_details_capacity = 0;+    _recv_trailing_metadata = gpr_malloc(sizeof(grpc_metadata_array));+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.status = _code;+  op->data.recv_status_on_client.status_details = _details;+  op->data.recv_status_on_client.status_details_capacity = _details_capacity;+  op->data.recv_status_on_client.trailing_metadata = _recv_trailing_metadata;+}++- (void (^)(void))opProcessor {+  return ^{+    grpc_status status;+    status.status = *_code;+    status.details = *_details;+    status.metadata = _recv_trailing_metadata;+    gpr_free(_code);+    gpr_free(_details);+    gpr_free(_details_capacity);+    if (_handler) {+      _handler([NSError grpc_errorFromStatus:&status]);+    }+  };+}++@end++@implementation GRPCWrappedCall{+  grpc_call *_call;+  GRPCCompletionQueue *_queue;+}++- (instancetype)init {+  return [self initWithChannel:nil method:nil host:nil];+}++- (instancetype)initWithChannel:(GRPCChannel *)channel+                         method:(NSString *)method+                           host:(NSString *)host {+  if (!channel || !method || !host) {+    [NSException raise:NSInvalidArgumentException+                format:@""channel, method, and host cannot be nil.""];+  }+  +  if (self = [super init]) {+    static dispatch_once_t initialization;+    dispatch_once(&initialization, ^{+      grpc_init();+    });+    +    _queue = [GRPCCompletionQueue completionQueue];+    _call = grpc_channel_create_call(channel.unmanagedChannel, _queue.unmanagedQueue,+                                     method.UTF8String, host.UTF8String, gpr_inf_future);+    if (_call == NULL) {+      return nil;+    }+  }+  return self;+}++- (void)startBatchWithOperations:(NSArray *)operations {+  [self startBatchWithOperations:operations errorHandler:nil];+}++- (void)startBatchWithOperations:(NSArray *)operations errorHandler:(void (^)())errorHandler {+  NSMutableArray *opProcessors = [NSMutableArray array];+  size_t nops = operations.count;+  grpc_op *ops_array = gpr_malloc(nops * sizeof(grpc_op));+  size_t i = 0;+  for (id op in operations) {+    [op getOp:&ops_array[i]];+    [opProcessors addObject:[op opProcessor]];+  }+  grpc_call_error error = grpc_call_start_batch(_call, ops_array, nops,+                                                (__bridge_retained void *)(^(grpc_op_error error){+    if (error != GRPC_OP_OK) {+      if (errorHandler) {+        errorHandler();+      } else {+        [NSException raise:@""Operation Exception"" format:@""The batch failed with an unknown error""];+      }+    }+    for (void(^processor)(void) in opProcessors) {+      processor();+    }+  }));+  +  if (error != GRPC_CALL_OK) {+    [NSException raise:NSInvalidArgumentException format:@""The batch did not start successfully""];","s/NSInvalidArgumentException/NSInternalInconsistencyExceptionThe message can explain it ""A precondition for calling grpc_call_start_batch wasn't met.""",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29311835,2015-04-29T05:51:20Z,src/objective-c/GRPCClient/private/NSDictionary+GRPC.h,"@@ -32,9 +32,9 @@  */  #import <Foundation/Foundation.h>--struct grpc_metadata;+#include <grpc/grpc.h>",In case grpc_metadata stops being a struct? :),
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1363,29354230,2015-04-29T16:37:47Z,src/objective-c/GRPCClient/private/NSDictionary+GRPC.h,"@@ -32,9 +32,9 @@  */  #import <Foundation/Foundation.h>--struct grpc_metadata;+#include <grpc/grpc.h>","Including the header just seems simpler than redeclaring the things in it. Plus, it results in shorter code (`grpc_metadata` vs `struct grpc_metadata`).",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29358104,2015-04-29T17:19:03Z,src/objective-c/GRPCClient/private/NSDictionary+GRPC.h,"@@ -32,9 +32,9 @@  */  #import <Foundation/Foundation.h>--struct grpc_metadata;+#include <grpc/grpc.h>","It's simpler indeed. The downside is it makes compilation slower, and in some dependency cases inclusion doesn't work and forward declaration is needed. But as we're layering on top of that library, inclusion might be better.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29360303,2015-04-29T17:41:19Z,src/objective-c/GRPCClient/private/NSDictionary+GRPC.h,"@@ -32,9 +32,9 @@  */  #import <Foundation/Foundation.h>--struct grpc_metadata;+#include <grpc/grpc.h>  @interface NSDictionary (GRPC) + (instancetype)grpc_dictionaryFromMetadata:(struct grpc_metadata *)entries count:(size_t)count;+- (grpc_metadata *)grpc_getMetadataArray;","`grpc_metadataArray` now, without the ""get"" (BTW, just in case, remember to use XCode's refactoring for these renamings, it's much easier)",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29363337,2015-04-29T18:09:48Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -0,0 +1,326 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCWrappedCall.h""+#import <Foundation/Foundation.h>+#include <grpc/grpc.h>+#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#import ""GRPCCompletionQueue.h""+#import ""NSDictionary+GRPC.h""+#import ""NSData+GRPC.h""+#import ""NSError+GRPC.h""++@implementation GRPCOpSendMetadata{+  void(^_handler)(void);+  grpc_metadata *_send_metadata;+  size_t _count;+}++- (instancetype)init {+  return [self initWithMetadata:nil handler:nil];+}++- (instancetype)initWithMetadata:(NSDictionary *)metadata handler:(void (^)(void))handler {+  if (self = [super init]) {+    _send_metadata = [metadata grpc_metadataArray];+    _count = metadata.count;+    _handler = handler;+  }+  return self;+}++- (void)getOp:(grpc_op *)op {+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = _count;+  op->data.send_initial_metadata.metadata = _send_metadata;+}++- (void (^)(void))opProcessor {+  return ^{+    gpr_free(_send_metadata);","The processor block isn't called upon some recoverable errors, meaning we'll leak here. Instead, let's move `free`'s and `destroy`'s to the `-dealloc` method of each of these classes. They make more sense there anyway, because we're always creating and alloc'ing in the initializers.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1421,29462331,2015-04-30T19:34:40Z,src/core/support/cpu_windows.c,"@@ -34,19 +34,17 @@ #include <grpc/support/port_platform.h>  #ifdef GPR_WIN32-+#include <Windows.h> #include <grpc/support/log.h>  unsigned gpr_cpu_num_cores(void) {-  /* TODO(jtattermusch): implement */-  gpr_log(GPR_ERROR, ""Cannot determine number of CPUs: assuming 1"");-  return 1;+  SYSTEM_INFO si;+  GetSystemInfo(&si);+  return si.dwNumberOfProcessors; }  unsigned gpr_cpu_current_cpu(void) {-  /* TODO(jtattermusch): implement */-  gpr_log(GPR_ERROR, ""Cannot determine current CPU"");-  return 0;+  return GetCurrentProcessorNumber();","This is supported by Vista+ only, meaning it wouldn't work under Windows XP, but it looks like that ship has sailed already a long time ago :-) So that's fine.",
5418049,zeliard,https://api.github.com/repos/grpc/grpc/pulls/1421,29483579,2015-05-01T00:43:21Z,src/core/support/cpu_windows.c,"@@ -34,19 +34,17 @@ #include <grpc/support/port_platform.h>  #ifdef GPR_WIN32-+#include <Windows.h> #include <grpc/support/log.h>  unsigned gpr_cpu_num_cores(void) {-  /* TODO(jtattermusch): implement */-  gpr_log(GPR_ERROR, ""Cannot determine number of CPUs: assuming 1"");-  return 1;+  SYSTEM_INFO si;+  GetSystemInfo(&si);+  return si.dwNumberOfProcessors; }  unsigned gpr_cpu_current_cpu(void) {-  /* TODO(jtattermusch): implement */-  gpr_log(GPR_ERROR, ""Cannot determine current CPU"");-  return 0;+  return GetCurrentProcessorNumber();","Yes, that's right. I just thought WinXP is practically deprecated :)",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1363,29523671,2015-05-01T18:43:51Z,src/objective-c/GRPCClient/private/NSError+GRPC.h,"@@ -58,14 +58,12 @@ typedef NS_ENUM(NSInteger, GRPCErrorCode) {  // TODO(jcanizales): This is conflating trailing metadata with Status details. Fix it once there's // a decision on how to codify Status.-#include <grpc/status.h>-struct grpc_metadata;-struct grpc_status {+#include <grpc/grpc.h>+typedef struct grpc_status {     grpc_status_code status;     const char *details;",nit: Remove const here to silence a warning (the C library expects non-const).,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1449,29539524,2015-05-01T22:52:55Z,src/core/profiling/timers_preciseclock.h,"@@ -34,14 +34,48 @@ #ifndef GRPC_CORE_PROFILING_TIMERS_PRECISECLOCK_H #define GRPC_CORE_PROFILING_TIMERS_PRECISECLOCK_H +#include <grpc/support/sync.h> #include <grpc/support/time.h> #include <stdio.h> -typedef struct grpc_precise_clock grpc_precise_clock;- #ifdef GRPC_TIMERS_RDTSC-#error RDTSC timers not currently supported+typedef long long int grpc_precise_clock;+#if defined(__i386__)+static void grpc_precise_clock_now(grpc_precise_clock *clk) {+  grpc_precise_clock ret;+  __asm__ volatile(""rdtsc"" : ""=A"" (ret) );+  *clk = ret;+}++// ----------------------------------------------------------------+#elif defined(__x86_64__) || defined(__amd64__)+static void grpc_precise_clock_now(grpc_precise_clock *clk) {+  unsigned long long low, high;+  __asm__ volatile(""rdtsc"" : ""=a"" (low), ""=d"" (high));+  *clk = (high << 32) | low;+}+#endif+static gpr_once precise_clock_init = GPR_ONCE_INIT;+static double cycles_per_second = 0.0;+static void grpc_precise_clock_init() {+  time_t start = time(NULL);+  grpc_precise_clock start_time;+  grpc_precise_clock end_time;+  while (time(NULL) == start);+  grpc_precise_clock_now(&start_time);+  while (time(NULL) == start+1);+  grpc_precise_clock_now(&end_time);+  cycles_per_second = end_time - start_time;+}","Am a little concerned that this will not quite be accurate, but the likelihood of a substantial error over a full second is quite low, so this is fine.",x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1452,29609813,2015-05-04T18:31:39Z,tools/profile_analyzer/profile_analyzer.py,"@@ -0,0 +1,82 @@+#!/usr/bin/env python+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# read GRPC basic profiles, analyze the data++# usage:+#   bins/basicprof/qps_smoke_test > log+#   cat log | tools/profile_analyzer/profile_analyzer.py++import re+import sys++re_line = re.compile(r'GRPC_LAT_PROF ' +",This is complex enough that I think a comment describing the value is warranted.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1452,29610074,2015-05-04T18:34:18Z,tools/profile_analyzer/profile_analyzer.py,"@@ -0,0 +1,82 @@+#!/usr/bin/env python+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# read GRPC basic profiles, analyze the data++# usage:+#   bins/basicprof/qps_smoke_test > log+#   cat log | tools/profile_analyzer/profile_analyzer.py++import re+import sys++re_line = re.compile(r'GRPC_LAT_PROF ' ++                     r'([0-9]+\.[0-9]+) 0x([0-9a-f]+) ([{}.]) ([0-9]+) ' + +                     r'0x([0-9a-f]+) ([^ ]+) ([0-9]+)')++class Entry(object):",Why not use collections.namedtuple to define this plain-data-object class?,x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1452,29692714,2015-05-05T17:36:56Z,tools/profile_analyzer/profile_analyzer.py,"@@ -0,0 +1,85 @@+#!/usr/bin/env python+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# read GRPC basic profiles, analyze the data++# usage:+#   bins/basicprof/qps_smoke_test > log+#   cat log | tools/profile_analyzer/profile_analyzer.py++import collections+import re+import sys++# Create a regex to parse output of the C core basic profiler,+# as defined in src/core/profiling/basic_timers.c.+_RE_LINE = re.compile(r'GRPC_LAT_PROF ' ++                      r'([0-9]+\.[0-9]+) 0x([0-9a-f]+) ([{}.]) ([0-9]+) ' ++                      r'([^ ]+) ([^ ]+) ([0-9]+)')++Entry = collections.namedtuple(+    'Entry',+    ['time', 'thread', 'type', 'tag', 'id', 'file', 'line'])++def entries():+  for line in sys.stdin:+    m = _RE_LINE.match(line)+    if not m: continue+    yield Entry(time=float(m.group(1)),+                thread=m.group(2),+                type=m.group(3),+                tag=int(m.group(4)),+                id=m.group(5),+                file=m.group(6),+                line=m.group(7))++threads = collections.defaultdict(+    lambda: collections.defaultdict(lambda: []))","Is ""list"" an acceptable substitute for ""lambda: []""?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/1395,29725328,2015-05-05T23:51:37Z,src/core/support/slice_buffer.c,"@@ -162,14 +163,30 @@ void gpr_slice_buffer_reset_and_unref(gpr_slice_buffer *sb) { }  void gpr_slice_buffer_swap(gpr_slice_buffer *a, gpr_slice_buffer *b) {-  gpr_slice_buffer temp = *a;-  *a = *b;-  *b = temp;--  if (a->slices == b->inlined) {+  GPR_SWAP(size_t, a->count, b->count);+  GPR_SWAP(size_t, a->capacity, b->capacity);+  GPR_SWAP(size_t, a->length, b->length);++  if (a->slices == a->inlined) {","It's a sort of big endian vs little endian/bikeshed color kind of thing.LGTM, merging.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1485,29731028,2015-05-06T02:38:11Z,templates/vsprojects/Grpc.mak.template,"@@ -33,10 +33,19 @@ <%def name=""to_windows_path(path)"">${path.replace('/','\\')}</%def>\ <%   disallowed_dependencies = set(['end2end_certs'])-  buildable_targets = [ target for target in targets-                        if not disallowed_dependencies.intersection(target.deps) and+  do_not_build = set(['gpr',",This list needs a brief explanation as to why,x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1499,29837357,2015-05-07T09:38:05Z,src/core/transport/chttp2_transport.c,"@@ -823,24 +823,26 @@ static void unlock(transport *t) {   finish_reads(t);    /* gather any callbacks that need to be made */-  if (!t->calling_back && cb) {+  if (!t->calling_back) {     perform_callbacks = prepare_callbacks(t);     if (perform_callbacks) {       t->calling_back = 1;     }-    if (t->error_state == ERROR_STATE_SEEN && !t->writing) {-      call_closed = 1;-      t->calling_back = 1;-      t->cb = NULL; /* no more callbacks */-      t->error_state = ERROR_STATE_NOTIFIED;-    }-    if (t->num_pending_goaways) {-      goaways = t->pending_goaways;-      num_goaways = t->num_pending_goaways;-      t->pending_goaways = NULL;-      t->num_pending_goaways = 0;-      t->cap_pending_goaways = 0;-      t->calling_back = 1;+    if (cb) {+      if (t->error_state == ERROR_STATE_SEEN && !t->writing && !t->calling_back) {",Ah my bad. I made this change at Jan's machine. The extra t->calling_back check here is spurious. The right thing to do is remove it again.,x
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/1504,29839409,2015-05-07T10:11:15Z,src/csharp/Grpc.Core/Server.cs,"@@ -89,29 +94,25 @@ public void AddServiceDefinition(ServerServiceDefinition serviceDefinition)         /// Add a non-secure port on which server should listen.         /// Only call this before Start().         /// </summary>-        public int AddListeningPort(string addr)+        /// <returns>The port on which server will be listening.</returns>+        /// <param name=""host"">the host</param>+        /// <param name=""port"">the port. If zero, an unused port is chosen automatically.</param>+        public int AddListeningPort(string host, int port)","Given that we're using optional parameters elsewhere, perhaps use them here for ServerCredentials, and just have one overload?",x
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/1504,29859068,2015-05-07T14:49:43Z,src/csharp/Grpc.Core/Server.cs,"@@ -89,29 +94,25 @@ public void AddServiceDefinition(ServerServiceDefinition serviceDefinition)         /// Add a non-secure port on which server should listen.         /// Only call this before Start().         /// </summary>-        public int AddListeningPort(string addr)+        /// <returns>The port on which server will be listening.</returns>+        /// <param name=""host"">the host</param>+        /// <param name=""port"">the port. If zero, an unused port is chosen automatically.</param>+        public int AddListeningPort(string host, int port)","I left two separate overloads to allow differentiation between secure and unsecure version of the method (because they are a very different sort of thing conceptually - and something you totally want to do right). If you like it otherwise, I can just use optional parameter.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/1504,29859767,2015-05-07T14:55:47Z,src/csharp/Grpc.Core/Server.cs,"@@ -89,29 +94,25 @@ public void AddServiceDefinition(ServerServiceDefinition serviceDefinition)         /// Add a non-secure port on which server should listen.         /// Only call this before Start().         /// </summary>-        public int AddListeningPort(string addr)+        /// <returns>The port on which server will be listening.</returns>+        /// <param name=""host"">the host</param>+        /// <param name=""port"">the port. If zero, an unused port is chosen automatically.</param>+        public int AddListeningPort(string host, int port)","If they're different conceptually, I'd make the difference even _bigger_ with different names, e.g. AddInsecureListener vs AddSecureListener. But I don't have enough context at the moment to know how much I care :)",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1506,29941815,2015-05-08T14:04:24Z,build.json,"@@ -405,6 +405,7 @@         ""src/core/httpcli/parser.h"",         ""src/core/security/auth.h"",         ""src/core/security/base64.h"",+        ""src/core/security/context.h"",",happy with a renaming pull later,x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1472,30062970,2015-05-11T17:45:21Z,include/grpc/grpc.h,"@@ -201,22 +193,15 @@ typedef struct grpc_metadata { } grpc_metadata;  typedef enum grpc_completion_type {-  GRPC_QUEUE_SHUTDOWN,       /* Shutting down */-  GRPC_OP_COMPLETE,          /* operation completion */-  GRPC_SERVER_SHUTDOWN,      /* The server has finished shutting down */","Done.On Mon, May 11, 2015 at 10:34 AM Masood Malekghassemi <notifications@github.com> wrote:> In include/grpc/grpc.h> https://github.com/grpc/grpc/pull/1472#discussion_r30061804:> > > @@ -201,22 +193,15 @@ typedef struct grpc_metadata {> >  } grpc_metadata;> > > >  typedef enum grpc_completion_type {> > -  GRPC_QUEUE_SHUTDOWN,       /\* Shutting down */> > -  GRPC_OP_COMPLETE,          /\* operation completion */> > -  GRPC_SERVER_SHUTDOWN,      /\* The server has finished shutting down */> > Cold you please update the doc-comment for grpc_server_shutdown_and_notify,> then (line 505 in the original file, 485 in the edited)?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/1472/files#r30061804.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1558,30180798,2015-05-12T21:09:16Z,tools/run_tests/build_python.sh,"@@ -38,5 +38,5 @@ rm -rf python2.7_virtual_environment virtualenv -p /usr/bin/python2.7 python2.7_virtual_environment source python2.7_virtual_environment/bin/activate pip install enum34==1.0.4 futures==2.2.0 protobuf==3.0.0-alpha-1-CFLAGS=-I$root/include LDFLAGS=-L$root/libs/$CONFIG pip install src/python/src+CFLAGS=""-I$root/include"" LDFLAGS=""-L$root/libs/$CONFIG"" pip install src/python/src",The change on this line smells entirely independent of the whole rest of this commit. May this be made in a separate pull request?,x
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/1599,30368175,2015-05-14T22:02:47Z,doc/interop-test-descriptions.md,"@@ -517,6 +517,34 @@ Procedure: Asserts: * Call completed with status CANCELLED +### timeout_on_sleeping_server++This test verifies that an RPC request whose lifetime exceeds its configured timeout value will end with the DeadlineExceeded status.++Server features:+* [FullDuplexCall][]+* [Compressable Payload][]+* [Observe ResponseParameters.interval_us][]++Procedure:+ 1. Client calls FullDuplexCall with the following request and sets its timeout to 1ms.++    ```+    {+      response_type: COMPRESSABLE+      response_parameters:{+        interval_us: 3000+      }+      payload:{+        body: 27182 bytes of zeros+      }+    }+    ```+2. Server will sleep for the configured interval_us and client waits for the status.++Asserts:+* Call completed with status DeadlineExceeded.","Let's call it DEADLINE_EXCEEDED, since that is the formatting in most languages (and in the proto that everyone copied from). Not a big deal though.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/1634,30475842,2015-05-17T22:52:02Z,test/cpp/qps/qps_driver.cc,"@@ -68,49 +82,124 @@ using grpc::testing::ServerType; using grpc::testing::RpcType; using grpc::testing::ResourceUsage; +using std::vector;+using std::string;++vector<string> ParseCommaSeparatedIntList(string list) {+  // Pass by value because strtok consumes its input.+  vector<string> result;+  char *p = strtok((char*)list.c_str(), "","");+  while (p) {+    result.push_back(p);+    p = strtok(NULL, "","");+  }+  return result;+}++vector<ClientConfig> GetClientConfigsFromFlags() {+  vector<ClientConfig> configs;+  const auto rpc_types = ParseCommaSeparatedIntList(FLAGS_rpc_types);+  const auto outstanding_rpcs_per_channel =+      ParseCommaSeparatedIntList(FLAGS_outstanding_rpcs_per_channel);+  const auto client_channels =+      ParseCommaSeparatedIntList(FLAGS_client_channels);+  const auto payload_sizes = ParseCommaSeparatedIntList(FLAGS_payload_sizes);+  const auto client_types = ParseCommaSeparatedIntList(FLAGS_client_types);+  const auto async_client_threads =+      ParseCommaSeparatedIntList(FLAGS_async_client_threads);++  ClientConfig cc;+  cc.set_enable_ssl(FLAGS_enable_ssl);++  for (const auto& rpc_type_str : rpc_types) {","Yes, agreed. This code is hacky, motivated out of wanting to have something up and running asap. I'd definitely like to do things more cleanly as well. @vjpai , what's your take? ",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1634,30524535,2015-05-18T16:38:12Z,test/cpp/qps/qps_driver.cc,"@@ -68,49 +82,124 @@ using grpc::testing::ServerType; using grpc::testing::RpcType; using grpc::testing::ResourceUsage; +using std::vector;+using std::string;++vector<string> ParseCommaSeparatedIntList(string list) {+  // Pass by value because strtok consumes its input.+  vector<string> result;+  char *p = strtok((char*)list.c_str(), "","");+  while (p) {+    result.push_back(p);+    p = strtok(NULL, "","");+  }+  return result;+}++vector<ClientConfig> GetClientConfigsFromFlags() {+  vector<ClientConfig> configs;+  const auto rpc_types = ParseCommaSeparatedIntList(FLAGS_rpc_types);+  const auto outstanding_rpcs_per_channel =+      ParseCommaSeparatedIntList(FLAGS_outstanding_rpcs_per_channel);+  const auto client_channels =+      ParseCommaSeparatedIntList(FLAGS_client_channels);+  const auto payload_sizes = ParseCommaSeparatedIntList(FLAGS_payload_sizes);+  const auto client_types = ParseCommaSeparatedIntList(FLAGS_client_types);+  const auto async_client_threads =+      ParseCommaSeparatedIntList(FLAGS_async_client_threads);++  ClientConfig cc;+  cc.set_enable_ssl(FLAGS_enable_ssl);++  for (const auto& rpc_type_str : rpc_types) {","Now on to Craig's comment. I agree wholeheartedly. I really shudder at the idea of a 6-nested for-loop that creates protobufs, and it will only get worse as we add other parameters to the list of things to watch for. I would really like to suggest going back to a one-off runner as it has been but control the running options separately in a shell-script, as is done in a simple-form in the heavily underused qps-sweep.sh that lives in this same directory . I understand that that's more moving parts, but the shell is particularly well-suited for the sort of work that you're doing here (supporting range-based for, tokenization, etc since the 1970s). It's trivial to understand that code and add in a new flag as needed. The grpc module should provide the mechanisms and examples but does not need to directly include every use case under the sun, IMO.",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1608,30526200,2015-05-18T16:57:56Z,src/core/iomgr/fd_posix.c,"@@ -290,29 +301,61 @@ void grpc_fd_notify_on_write(grpc_fd *fd, grpc_iomgr_closure *closure) { gpr_uint32 grpc_fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,                               gpr_uint32 read_mask, gpr_uint32 write_mask,                               grpc_fd_watcher *watcher) {+  gpr_uint32 mask = 0;   /* keep track of pollers that have requested our events, in case they change    */   grpc_fd_ref(fd);    gpr_mu_lock(&fd->watcher_mu);-  watcher->next = &fd->watcher_root;-  watcher->prev = watcher->next->prev;-  watcher->next->prev = watcher->prev->next = watcher;+  /* if there is nobody polling for read, but we need to, then start doing so */+  if (!fd->read_watcher && gpr_atm_acq_load(&fd->readst) > READY) {+    fd->read_watcher = watcher;+    mask |= read_mask;+  }+  /* if there is nobody polling for write, but we need to, then start doing so */+  if (!fd->write_watcher && gpr_atm_acq_load(&fd->writest) > READY) {+    fd->write_watcher = watcher;+    mask |= write_mask;+  }+  /* if not polling, remember this watcher in case we need someone to later */+  if (mask == 0) {+    watcher->next = &fd->watcher_root;+    watcher->prev = watcher->next->prev;+    watcher->next->prev = watcher->prev->next = watcher;+  }   watcher->pollset = pollset;   watcher->fd = fd;   gpr_mu_unlock(&fd->watcher_mu); -  return (gpr_atm_acq_load(&fd->readst) != READY ? read_mask : 0) |-         (gpr_atm_acq_load(&fd->writest) != READY ? write_mask : 0);+  return mask; } -void grpc_fd_end_poll(grpc_fd_watcher *watcher) {-  gpr_mu_lock(&watcher->fd->watcher_mu);-  watcher->next->prev = watcher->prev;-  watcher->prev->next = watcher->next;-  gpr_mu_unlock(&watcher->fd->watcher_mu);+void grpc_fd_end_poll(grpc_fd_watcher *watcher, int got_read, int got_write) {+  int was_polling = 0;+  int kick = 0;+  grpc_fd *fd = watcher->fd;++  gpr_mu_lock(&fd->watcher_mu);+  if (watcher == fd->read_watcher) {+    was_polling = 1;+    kick |= !got_read;+    fd->read_watcher = NULL;+  }+  if (watcher == fd->write_watcher) {+    was_polling = 1;+    kick |= !got_write;+    fd->write_watcher = NULL;+  }+  if (!was_polling) {+    watcher->next->prev = watcher->prev;+    watcher->prev->next = watcher->next;+  }","I was following the flow up until here. I'm just a little concerned here and would greatly benefit from comments about the invariants being assumed in the watcher list. Up above, an entry is added to the watcher list under certain circumstances but an entry is removed from the watcher list under circumstances that differ. I would like to see it committed to comments that the watcher list is maintained well and what it actually represents.",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1608,30526293,2015-05-18T16:59:13Z,src/core/iomgr/fd_posix.c,"@@ -290,29 +301,61 @@ void grpc_fd_notify_on_write(grpc_fd *fd, grpc_iomgr_closure *closure) { gpr_uint32 grpc_fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,                               gpr_uint32 read_mask, gpr_uint32 write_mask,                               grpc_fd_watcher *watcher) {+  gpr_uint32 mask = 0;   /* keep track of pollers that have requested our events, in case they change    */   grpc_fd_ref(fd);    gpr_mu_lock(&fd->watcher_mu);-  watcher->next = &fd->watcher_root;-  watcher->prev = watcher->next->prev;-  watcher->next->prev = watcher->prev->next = watcher;+  /* if there is nobody polling for read, but we need to, then start doing so */+  if (!fd->read_watcher && gpr_atm_acq_load(&fd->readst) > READY) {+    fd->read_watcher = watcher;+    mask |= read_mask;+  }+  /* if there is nobody polling for write, but we need to, then start doing so */+  if (!fd->write_watcher && gpr_atm_acq_load(&fd->writest) > READY) {+    fd->write_watcher = watcher;+    mask |= write_mask;+  }+  /* if not polling, remember this watcher in case we need someone to later */+  if (mask == 0) {+    watcher->next = &fd->watcher_root;+    watcher->prev = watcher->next->prev;+    watcher->next->prev = watcher->prev->next = watcher;+  }   watcher->pollset = pollset;   watcher->fd = fd;   gpr_mu_unlock(&fd->watcher_mu); -  return (gpr_atm_acq_load(&fd->readst) != READY ? read_mask : 0) |-         (gpr_atm_acq_load(&fd->writest) != READY ? write_mask : 0);+  return mask; } -void grpc_fd_end_poll(grpc_fd_watcher *watcher) {-  gpr_mu_lock(&watcher->fd->watcher_mu);-  watcher->next->prev = watcher->prev;-  watcher->prev->next = watcher->next;-  gpr_mu_unlock(&watcher->fd->watcher_mu);+void grpc_fd_end_poll(grpc_fd_watcher *watcher, int got_read, int got_write) {+  int was_polling = 0;+  int kick = 0;+  grpc_fd *fd = watcher->fd;++  gpr_mu_lock(&fd->watcher_mu);+  if (watcher == fd->read_watcher) {+    was_polling = 1;+    kick |= !got_read;","Stylistically, I would recommend ||= in this case since kick is essentially being used as a boolean concept (and so is the RHS here), not a bitmask.",x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1608,30527919,2015-05-18T17:19:19Z,src/core/iomgr/fd_posix.c,"@@ -290,29 +301,61 @@ void grpc_fd_notify_on_write(grpc_fd *fd, grpc_iomgr_closure *closure) { gpr_uint32 grpc_fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,                               gpr_uint32 read_mask, gpr_uint32 write_mask,                               grpc_fd_watcher *watcher) {+  gpr_uint32 mask = 0;   /* keep track of pollers that have requested our events, in case they change    */   grpc_fd_ref(fd);    gpr_mu_lock(&fd->watcher_mu);-  watcher->next = &fd->watcher_root;-  watcher->prev = watcher->next->prev;-  watcher->next->prev = watcher->prev->next = watcher;+  /* if there is nobody polling for read, but we need to, then start doing so */+  if (!fd->read_watcher && gpr_atm_acq_load(&fd->readst) > READY) {+    fd->read_watcher = watcher;+    mask |= read_mask;+  }+  /* if there is nobody polling for write, but we need to, then start doing so */+  if (!fd->write_watcher && gpr_atm_acq_load(&fd->writest) > READY) {+    fd->write_watcher = watcher;+    mask |= write_mask;+  }+  /* if not polling, remember this watcher in case we need someone to later */+  if (mask == 0) {+    watcher->next = &fd->watcher_root;+    watcher->prev = watcher->next->prev;+    watcher->next->prev = watcher->prev->next = watcher;+  }   watcher->pollset = pollset;   watcher->fd = fd;   gpr_mu_unlock(&fd->watcher_mu); -  return (gpr_atm_acq_load(&fd->readst) != READY ? read_mask : 0) |-         (gpr_atm_acq_load(&fd->writest) != READY ? write_mask : 0);+  return mask; } -void grpc_fd_end_poll(grpc_fd_watcher *watcher) {-  gpr_mu_lock(&watcher->fd->watcher_mu);-  watcher->next->prev = watcher->prev;-  watcher->prev->next = watcher->next;-  gpr_mu_unlock(&watcher->fd->watcher_mu);+void grpc_fd_end_poll(grpc_fd_watcher *watcher, int got_read, int got_write) {+  int was_polling = 0;+  int kick = 0;+  grpc_fd *fd = watcher->fd;++  gpr_mu_lock(&fd->watcher_mu);+  if (watcher == fd->read_watcher) {+    was_polling = 1;+    kick |= !got_read;+    fd->read_watcher = NULL;+  }+  if (watcher == fd->write_watcher) {+    was_polling = 1;+    kick |= !got_write;+    fd->write_watcher = NULL;+  }+  if (!was_polling) {+    watcher->next->prev = watcher->prev;+    watcher->prev->next = watcher->next;+  }",Added a big comment in fd_posix.h on what the fields mean in the watcher list.Updated some code based upon those comments.,x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1558,30633045,2015-05-19T18:51:03Z,src/python/src/grpc/_adapter/_types.py,"@@ -0,0 +1,365 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import abc+import collections+import enum++# TODO(atash): decide whether or not to move these enums to the _c module to+# force build errors with upstream changes.++class GrpcChannelArgumentKeys(enum.Enum):+  """"""Mirrors keys used in grpc_channel_args for GRPC-specific arguments.""""""+  SSL_TARGET_NAME_OVERRIDE = 'grpc.ssl_target_name_override'++@enum.unique+class CallError(enum.IntEnum):+  """"""Mirrors grpc_call_error in the C core.""""""+  OK                        = 0+  ERROR                     = 1+  ERROR_NOT_ON_SERVER       = 2+  ERROR_NOT_ON_CLIENT       = 3+  ERROR_ALREADY_ACCEPTED    = 4+  ERROR_ALREADY_INVOKED     = 5+  ERROR_NOT_INVOKED         = 6+  ERROR_ALREADY_FINISHED    = 7+  ERROR_TOO_MANY_OPERATIONS = 8+  ERROR_INVALID_FLAGS       = 9+  ERROR_INVALID_METADATA    = 10++@enum.unique+class StatusCode(enum.IntEnum):+  """"""Mirrors grpc_status_code in the C core.""""""+  OK                  = 0+  CANCELLED           = 1+  UNKNOWN             = 2+  INVALID_ARGUMENT    = 3+  DEADLINE_EXCEEDED   = 4+  NOT_FOUND           = 5+  ALREADY_EXISTS      = 6+  PERMISSION_DENIED   = 7+  RESOURCE_EXHAUSTED  = 8+  FAILED_PRECONDITION = 9+  ABORTED             = 10+  OUT_OF_RANGE        = 11+  UNIMPLEMENTED       = 12+  INTERNAL            = 13+  UNAVAILABLE         = 14+  DATA_LOSS           = 15+  UNAUTHENTICATED     = 16++@enum.unique+class OpType(enum.IntEnum):+  """"""Mirrors grpc_op_type in the C core.""""""+  SEND_INITIAL_METADATA   = 0+  SEND_MESSAGE            = 1+  SEND_CLOSE_FROM_CLIENT  = 2+  SEND_STATUS_FROM_SERVER = 3+  RECV_INITIAL_METADATA   = 4+  RECV_MESSAGE            = 5+  RECV_STATUS_ON_CLIENT   = 6+  RECV_CLOSE_ON_SERVER    = 7++@enum.unique+class EventType(enum.IntEnum):+  """"""Mirrors grpc_completion_type in the C core.""""""+  QUEUE_SHUTDOWN  = 0+  QUEUE_TIMEOUT   = 1  # if seen on the Python side, something went horridly wrong+  OP_COMPLETE     = 2++class Status(collections.namedtuple(+    'Status', [+        'code',+        'details',+    ])):+  """"""The end status of a GRPC call.++  Attributes:+    code (StatusCode): ...+    details (str): ...+  """"""++class CallDetails(collections.namedtuple(+    'CallDetails', [+        'method',+        'host',+        'deadline',+    ])):+  """"""Provides information to the server about the client's call.++  Attributes:+    method (str): ...+    host (str): ...+    deadline (float): ...+  """"""++class OpArgs(collections.namedtuple(+    'OpArgs', [+        'type',+        'initial_metadata',+        'trailing_metadata',+        'message',+        'status',+    ])):+  """"""Arguments passed into a GRPC operation.++  Attributes:+    type (OpType): ...+    initial_metadata (sequence of 2-sequence of str): Only valid if type ==+      OpType.SEND_INITIAL_METADATA, else is None.+    trailing_metadata (sequence of 2-sequence of str): Only valid if type ==+      OpType.SEND_STATUS_FROM_SERVER, else is None.+    message (bytes): Only valid if type == OpType.SEND_MESSAGE, else is None.+    status (Status): Only valid if type == OpType.SEND_STATUS_FROM_SERVER, else+      is None.+  """"""++  @staticmethod+  def send_initial_metadata(init_md):","Avoid abbreviations unless you have a really good reason. Why shouldn't this method's parameter just be ""initial_metadata""?",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1696,30853962,2015-05-21T22:19:29Z,debian/control,"@@ -0,0 +1,26 @@+Source: grpc+Priority: optional+Maintainer: Andrew Pollock <apollock@debian.org>+Build-Depends: debhelper (>= 9), zlib1g-dev, libssl-dev, libprotobuf-dev, protobuf-compiler, libgflags-dev, autoconf, automake, libtool, libgtest-dev, libgoogle-perftools-dev",We technically don't depend on autoconf / automake / libtool for the grpc package directly. This is for building protobuf.,
6906046,andrewpollock,https://api.github.com/repos/grpc/grpc/pulls/1696,30860602,2015-05-22T00:07:32Z,debian/control,"@@ -0,0 +1,26 @@+Source: grpc+Priority: optional+Maintainer: Andrew Pollock <apollock@debian.org>+Build-Depends: debhelper (>= 9), zlib1g-dev, libssl-dev, libprotobuf-dev, protobuf-compiler, libgflags-dev, autoconf, automake, libtool, libgtest-dev, libgoogle-perftools-dev",> We technically don't depend on autoconf / automake / libtool for the grpc package directly. This is for building protobuf.Okay I'll take them back out. I would have put them in when I was trying to build extra bits from third_party,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1728,30935403,2015-05-22T22:27:40Z,src/python/src/grpc/_adapter/fore.py,"@@ -41,7 +41,7 @@ from grpc.framework.foundation import activated from grpc.framework.foundation import logging_pool -_THREAD_POOL_SIZE = 100",This constant is unused; please delete it (and sorry for the red herring in today's investigation!).,x
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1728,30935421,2015-05-22T22:27:56Z,src/python/src/grpc/_adapter/rear.py,"@@ -41,7 +41,7 @@ from grpc.framework.foundation import activated from grpc.framework.foundation import logging_pool -_THREAD_POOL_SIZE = 100",This constant is unused; please delete it (and sorry for the red herring in today's investigation!).,x
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1735,30941084,2015-05-23T02:25:01Z,src/ruby/lib/grpc/generic/rpc_server.rb,"@@ -407,7 +413,13 @@ def loop_handle_server_calls       request_call_tag = Object.new       until stopped?         deadline = from_relative_time(@poll_period)-        an_rpc = @server.request_call(@cq, request_call_tag, deadline)+        begin+          an_rpc = @server.request_call(@cq, request_call_tag, deadline)+        rescue Core::CallError, RuntimeError => e+          # can happen during server shutdown","The server will report success == 0 for any requested calls at shutdowntime.The relevant core test is here:https://github.com/grpc/grpc/blob/master/test/core/end2end/tests/early_server_shutdown_finishes_tags.cOn Fri, May 22, 2015, 5:08 PM Tim Emiola notifications@github.com wrote:> In src/ruby/lib/grpc/generic/rpc_server.rb> https://github.com/grpc/grpc/pull/1735#discussion_r30939122:> > > @@ -407,7 +413,13 @@ def loop_handle_server_calls> >        request_call_tag = Object.new> >        until stopped?> >          deadline = from_relative_time(@poll_period)> > -        an_rpc = @server.request_call(@cq, request_call_tag, deadline)> > -        begin> > -          an_rpc = @server.request_call(@cq, request_call_tag, deadline)> > -        rescue Core::CallError, RuntimeError => e> > -          # can happen during server shutdown> > odd - this block is there because that's what I've observed. Are you sure> that success=true and call=null occur for shutdown even when the server is> shutdown from a separate thread ?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/1735/files#r30939122.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/1737,30952851,2015-05-24T14:34:54Z,tools/run_tests/antagonist.py,"@@ -0,0 +1,32 @@+#!/usr/bin/env python+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++while True:","Please add a module doc string describing this script's behavior... and while I'm usually against documenting ""X is used by Y for Z purpose"" in X's documentation (it inverts the nature of the dependency), I think this code is surprising enough that it might be wise to document its reason for existence right here too.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1758,31135668,2015-05-27T14:00:32Z,src/core/iomgr/iomgr.h,"@@ -37,11 +37,22 @@ /* gRPC Callback definition */ typedef void (*grpc_iomgr_cb_func)(void *arg, int success); +typedef struct grpc_iomgr_cb {","Let's rename this grpc_iomgr_closure, and remove that type from fd_posix.h.They both represent a callback paired with a parameter.This makes the notify_on case in fd_posix.c actually trivial, and removes a use of is_ext_managed.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1772,31190894,2015-05-27T23:25:04Z,src/compiler/objective_c_generator.cc,"@@ -176,65 +176,71 @@ void PrintMethodImplementations(Printer *printer,  string GetHeader(const ServiceDescriptor *service, const string prefix) {   string output;-  grpc::protobuf::io::StringOutputStream output_stream(&output);-  Printer printer(&output_stream, '$');+  {+    // Scope the output stream so it closes and finalizes output to the string.","Let's make clear that we know that's what's _supposed_ to happen when the function returns anyway, but we've found it's not always the case. Or just:``` cpp// The extra scope is needed due to gRPC issue #1769```Whichever way to word it you prefer, as long as it's specific so someone doesn't find this in a year and removes an apparently-unnecessary scope.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1772,31193271,2015-05-28T00:07:16Z,src/compiler/objective_c_generator.cc,"@@ -176,65 +176,71 @@ void PrintMethodImplementations(Printer *printer,  string GetHeader(const ServiceDescriptor *service, const string prefix) {   string output;-  grpc::protobuf::io::StringOutputStream output_stream(&output);-  Printer printer(&output_stream, '$');+  {+    // Scope the output stream so it closes and finalizes output to the string.","Note that this isn't a grpc issue per-se. I'm 94.3% certain we could file that as a compiler bug. There's no way moving the string before calling the local destructors is an acceptable behavior. The bad part we're exhibiting here (and I just realized that) is that we're taking addresses of temporaries, which is supposed to be a compiler warning.If you want to be more specific in that comment, I'd rather suggest saying this is to solve a Visual Studio problem with the destruction ordering of temporaries vs the move operation.",x
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1772,31193341,2015-05-28T00:09:02Z,src/compiler/objective_c_generator.cc,"@@ -176,65 +176,71 @@ void PrintMethodImplementations(Printer *printer,  string GetHeader(const ServiceDescriptor *service, const string prefix) {   string output;-  grpc::protobuf::io::StringOutputStream output_stream(&output);-  Printer printer(&output_stream, '$');+  {+    // Scope the output stream so it closes and finalizes output to the string.","Also, I'd be surprised if that isn't affecting more protoc code. I am fairly certain they have the same code pattern in there.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1772,31194946,2015-05-28T00:44:29Z,src/compiler/objective_c_generator.cc,"@@ -176,65 +176,71 @@ void PrintMethodImplementations(Printer *printer,  string GetHeader(const ServiceDescriptor *service, const string prefix) {   string output;-  grpc::protobuf::io::StringOutputStream output_stream(&output);-  Printer printer(&output_stream, '$');+  {+    // Scope the output stream so it closes and finalizes output to the string.","The point that this _might_ be behavior allowed by the standard remains, per [the conversation Jan found](http://programmers.stackexchange.com/questions/258238/move-semantics-in-c-move-return-of-local-variables).",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/1772,31195050,2015-05-28T00:47:15Z,src/compiler/objective_c_generator.cc,"@@ -176,65 +176,71 @@ void PrintMethodImplementations(Printer *printer,  string GetHeader(const ServiceDescriptor *service, const string prefix) {   string output;-  grpc::protobuf::io::StringOutputStream output_stream(&output);-  Printer printer(&output_stream, '$');+  {+    // Scope the output stream so it closes and finalizes output to the string.","Yes, so. If you do:```A a;B * b = new B(&a);```then the constructor of B is taking the address of a temporary. That is supposed to be a warning. I guess it doesn't happen here because we're doing everything on the stack. But still.For the destruction order, yes, it is determined. The problem here is that the destruction occurs AFTER the move operator is being called to move the variable `output`. While technically a move operation isn't a destruction, it is supposed to leave the object in a destructed state. Meaning that the actual destruction of `output` happens before the actual destruction of `output_stream` and `printer`, which is against the spec.",x
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/1772,31196010,2015-05-28T01:10:51Z,src/compiler/objective_c_generator.cc,"@@ -176,65 +176,71 @@ void PrintMethodImplementations(Printer *printer,  string GetHeader(const ServiceDescriptor *service, const string prefix) {   string output;-  grpc::protobuf::io::StringOutputStream output_stream(&output);-  Printer printer(&output_stream, '$');+  {+    // Scope the output stream so it closes and finalizes output to the string.","> That is supposed to be a warning.I don't think that's true; taking the address of an automatic variable is a perfectly acceptable thing to do. A very common use case of it is to pass the address of a local variable to a function call (e.g. `&error`), as ""output parameters."" I'd think passing it to a constructor is as fine.> which is against the specAre we sure of that? The conversation in StackOverflow seems to me to imply the spec authors decided to allow it. Without that, there's no way to move on return, or you'd destruct your object before moving it.In any case, back to this PR: let's make clear in the comment that without the scope, the string might get moved before the printer flushes _which results in a crash_ (even if it ends up being some compiler's bug).",x
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1608,31233179,2015-05-28T13:38:05Z,src/core/iomgr/fd_posix.h,"@@ -66,8 +66,32 @@ struct grpc_fd {   gpr_mu set_state_mu;   gpr_atm shutdown; +  /* The watcher list.+     +     The following watcher related fields are protected by watcher_mu.+     +     An fd_watcher is an ephemeral object created when an fd wants to+     begin polling, and destroyed after the poll.+     +     It denotes the fd's interest in whether to read poll or write poll+     or both or neither on this fd.++     If a watcher is asked to poll for reads or writes, the read_watcher+     or write_watcher fields are set respectively. A watcher may be asked+     to poll for both, in which case both fields will be set.++     read_watcher and write_watcher may be NULL if no watcher has been+     asked to poll for reads or writes.++     If an fd_watcher is not asked to poll for reads or writes, it's added+     to a linked list of inactive watchers, rooted at inactive_watcher_root.+     If at a later time there becomes need of a poller to poll, one of+     the inactive pollers may be kicked out of their poll loops to take+     that responsibility. */",Thanks for the detailed comment and for renaming watcher_root to inactive_watcher_root ; it makes everything much more clear.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1758,31248165,2015-05-28T15:53:18Z,src/core/surface/server.c,"@@ -415,20 +419,29 @@ static void server_on_recv(void *ptr, int success) {     case GRPC_STREAM_RECV_CLOSED:       gpr_mu_lock(&chand->server->mu);       if (calld->state == NOT_STARTED) {+        grpc_iomgr_closure *kill_zombie_closure =+            gpr_malloc(sizeof(grpc_iomgr_closure));         calld->state = ZOMBIED;-        grpc_iomgr_add_callback(kill_zombie, elem);+        grpc_iomgr_managed_closure_init(kill_zombie_closure, kill_zombie, elem);+        grpc_iomgr_add_callback(kill_zombie_closure);       }       gpr_mu_unlock(&chand->server->mu);       break;     case GRPC_STREAM_CLOSED:       gpr_mu_lock(&chand->server->mu);       if (calld->state == NOT_STARTED) {+        grpc_iomgr_closure *kill_zombie_closure =","We can guarantee that there's at most one kill_zombie outstanding at once - meaning we can probably squeeze this onto call_data.It's probably going to be bad for memory usage, as this mechanism is used rarely. However: it lets us get rid of managed closures entirely, and when we get to memory usage optimization, maybe something presents itself as the obvious thing to do.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/1827,31368632,2015-05-29T22:01:00Z,tools/gce_setup/grpc_docker.sh,"@@ -1274,8 +1274,7 @@ grpc_cloud_prod_gen_go_cmd() { #   cmd=$($grpc_gen_test_cmd $flags) grpc_interop_gen_java_cmd() {     local cmd_prefix=""sudo docker run grpc/java"";-    local test_script=""/var/local/git/grpc-java/run-test-client.sh"";-    local test_script+="" --use_test_ca=true --use_tls=true""+    local test_script=""/var/local/git/grpc-java/run-test-client.sh --use_test_ca=true --use_tls=true"";",Why this change and the similar one below?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/1823,31374453,2015-05-30T00:09:31Z,src/csharp/Grpc.nuspec,"@@ -5,7 +5,7 @@     <title>gRPC C#</title>     <summary>C# implementation of gRPC - an RPC library and framework</summary>     <description>C# implementation of gRPC - an RPC library and framework. See project site for more info.</description>-    <version>0.5.0</version>+    <version>0.5.0.1</version>","But C# is 0.5.0 and I think it's not being consistent within a specific language is crazy. (I don't wanna have 0.5.1 version for some C# packages and 0.5.0 for some other C# packages). If the format inconsistency bothers you, the 0.5.0.1 can be marked as hidden on nuget once we publish the next version. So it's just a temporary thing.",
10470441,maxwell-demon,https://api.github.com/repos/grpc/grpc/pulls/1818,31375603,2015-05-30T00:52:49Z,src/core/surface/init.c,"@@ -64,7 +64,7 @@ void grpc_init(void) {     grpc_security_pre_init();     grpc_iomgr_init();     grpc_tracer_init(""GRPC_TRACE"");-    census_init();+    census_initialize(CENSUS_NONE);",Looks like other components' init functions are all named xxx_init() instead of xxx_initialize().,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/1818,31444526,2015-06-01T16:46:17Z,src/core/census/context.c,"@@ -0,0 +1,59 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""context.h""++#include <string.h>+#include <grpc/census.h>+#include <grpc/support/alloc.h>++/* Placeholder implementation only. */++size_t census_context_serialize(const census_context *context, char *buffer,+                                size_t buf_size) {+  /* TODO(aveitch): implement serialization */+  return 0;+}++census_context *census_context_deserialize(char *buffer) {+  census_context *ret;+  if (buffer != NULL) {+    /* TODO(aveitch): implement deserialization */+    return NULL;+  }+  ret = gpr_malloc(sizeof(census_context));+  memset(ret, 0, sizeof(census_context));+  return ret;+}++void census_context_destroy(census_context *context) { gpr_free(context); }","Shouldn't be necessary, should it: adds a condition, where it's not needed (gpr_free handles NULL). ",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/1818,31445164,2015-06-01T16:53:30Z,src/core/surface/init.c,"@@ -64,7 +64,7 @@ void grpc_init(void) {     grpc_security_pre_init();     grpc_iomgr_init();     grpc_tracer_init(""GRPC_TRACE"");-    census_init();+    census_initialize(CENSUS_NONE);","Originally this was pragmatic while I was moving old->new files/API. Now, I'd rather keep the full name; since census is supposed to be (mostly) independent, think it should be OK. Will change if people feel strongly.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1818,31448359,2015-06-01T17:26:17Z,include/grpc/census.h,"@@ -0,0 +1,91 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* RPC-internal Census API's. These are designed to be generic enough that+ * they can (ultimately) be used in many different RPC systems (with differing+ * implementations). */++#ifndef CENSUS_CENSUS_H+#define CENSUS_CENSUS_H++#include <grpc/grpc.h>+#include <grpc/support/slice_buffer.h>++/* Identify census functionality that can be enabled via census_initialize(). */+enum census_functions {+  CENSUS_NONE = 0,    /* Do not enable census. */+  CENSUS_TRACING = 1, /* Enable census tracing. */+  CENSUS_STATS = 2,   /* Enable Census stats collection. */+  CENSUS_CPU = 4,     /* Enable Census CPU usage collection. */+  CENSUS_ALL = CENSUS_TRACING | CENSUS_STATS | CENSUS_CPU+};++/* Shutdown and startup census subsystem. The 'functions' argument should be+ * the OR (|) of census_functions values. If census fails to initialize, then+ * census_initialize() will return a non-zero value. */+int census_initialize(int functions);","Just to flesh out this thought:grpc_init/shutdown currently work as a ref-counting pair, with initialization only happening on the 0->1 edge, and shutdown only occurring on the 1->0 edge.It's given us some great benefits:- we can completely hide the API calls for many wrappers (because there's no choices)- it's eased wrapping as there's no concern about different libraries or wrappings-in-the-same-binary conflicting",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1866,31492587,2015-06-02T04:46:15Z,include/grpc/grpc.h,"@@ -170,14 +170,15 @@ void grpc_byte_buffer_destroy(grpc_byte_buffer *byte_buffer); struct grpc_byte_buffer_reader; typedef struct grpc_byte_buffer_reader grpc_byte_buffer_reader; -grpc_byte_buffer_reader *grpc_byte_buffer_reader_create(-    grpc_byte_buffer *buffer);+/** Initialize \a reader to read over \a buffer */+void grpc_byte_buffer_reader_init(grpc_byte_buffer_reader *reader,+                                  grpc_byte_buffer *buffer);+ /* At the end of the stream, returns 0. Otherwise, returns 1 and sets slice to    be the returned slice. Caller is responsible for calling gpr_slice_unref on    the result. */ int grpc_byte_buffer_reader_next(grpc_byte_buffer_reader *reader,                                  gpr_slice *slice);-void grpc_byte_buffer_reader_destroy(grpc_byte_buffer_reader *reader);","It might be worth keeping this API, even as a no-op for now.What happens if we need to allocate some memory in order to read the byte buffer?(for instance: decompressing it into a temporary slice buffer?)",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/1876,31579627,2015-06-02T22:51:56Z,gRPC.podspec,"@@ -25,16 +24,13 @@ Pod::Spec.new do |s|    s.subspec 'C-Core' do |cs|     cs.summary  = 'Core cross-platform gRPC library, written in C.'-    cs.authors = { 'Craig Tiller'   => 'ctiller@google.com',-                   'David Klempner' => 'klempner@google.com',-                   'Nicolas Noble'  => 'nnoble@google.com',-                   'Vijay Pai'      => 'vpai@google.com',-                   'Yang Gao'       => 'yangg@google.com' }      cs.source_files = 'src/core/**/*.{h,c}', 'include/grpc/*.h', 'include/grpc/**/*.h'     cs.private_header_files = 'src/core/**/*.h'     cs.header_mappings_dir = '.'-    cs.xcconfig = { 'HEADER_SEARCH_PATHS' => '""$(PODS_ROOT)/Headers/Build/gRPC"" ""$(PODS_ROOT)/Headers/Build/gRPC/include""' }+    cs.xcconfig = { 'HEADER_SEARCH_PATHS' => '""$(PODS_ROOT)/Headers/Build/gRPC"" '+                                             '""$(PODS_ROOT)/Headers/Build/gRPC/include""' }+    cs.compiler_flags = '-GCC_WARN_INHIBIT_ALL_WARNINGS', '-w'",This kind of seems like a bad idea. Why are we suppressing warnings now?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1948,31817179,2015-06-05T14:33:34Z,test/cpp/qps/client_async.cc,"@@ -159,30 +206,126 @@ class AsyncClient : public Client {                   size_t thread_idx) GRPC_OVERRIDE GRPC_FINAL {     void* got_tag;     bool ok;-    switch (cli_cqs_[thread_idx]->AsyncNext(-        &got_tag, &ok,-        std::chrono::system_clock::now() + std::chrono::seconds(1))) {+    grpc_time deadline, short_deadline;+    if (closed_loop_) {+      deadline = grpc_time_source::now() + std::chrono::seconds(1);+      short_deadline = deadline;+    } else {+      if (rpc_deadlines_[thread_idx].empty()) {+        deadline = grpc_time_source::now() + std::chrono::seconds(1);+      } else {+        deadline = *(rpc_deadlines_[thread_idx].begin());+      }+      short_deadline =+          issue_allowed_[thread_idx] ? next_issue_[thread_idx] : deadline;+    }++    bool got_event;++    switch (cli_cqs_[thread_idx]->AsyncNext(&got_tag, &ok, short_deadline)) {       case CompletionQueue::SHUTDOWN:         return false;       case CompletionQueue::TIMEOUT:-        return true;+        got_event = false;+        break;       case CompletionQueue::GOT_EVENT:+        got_event = true;+        break;+      default:+        GPR_ASSERT(false);         break;     }--    ClientRpcContext* ctx = ClientRpcContext::detag(got_tag);-    if (ctx->RunNextState(ok, histogram) == false) {-      // call the callback and then delete it-      ctx->RunNextState(ok, histogram);-      ctx->StartNewClone();-      delete ctx;+    if ((closed_loop_ || !rpc_deadlines_[thread_idx].empty()) &&+        grpc_time_source::now() > deadline) {+      // we have missed some 1-second deadline, which is too much+      gpr_log(GPR_INFO, ""Missed an RPC deadline, giving up"");+      return false;+    }+    if (got_event) {+      ClientRpcContext* ctx = ClientRpcContext::detag(got_tag);+      if (ctx->RunNextState(ok, histogram) == false) {+        // call the callback and then clone the ctx+        ctx->RunNextState(ok, histogram);+        ClientRpcContext* clone_ctx = ctx->StartNewClone();+        if (closed_loop_) {+          clone_ctx->Start(cli_cqs_[thread_idx].get());+        } else {+          // Remove the entry from the rpc deadlines list+          rpc_deadlines_[thread_idx].erase(ctx->deadline_posn());+          // Put the clone_ctx in the list of idle contexts for this channel+          // Under lock+          int ch = clone_ctx->channel_id();+          std::lock_guard<std::mutex> g(channel_lock_[ch]);+          contexts_[ch].push_front(clone_ctx);+        }+        // delete the old version+        delete ctx;+      }+      if (!closed_loop_)+        issue_allowed_[thread_idx] =+            true;  // may be ok now even if it hadn't been+    }+    if (!closed_loop_ && issue_allowed_[thread_idx] &&+        grpc_time_source::now() >= next_issue_[thread_idx]) {",The complexity of this versus the sync version makes me think we're missing an abstraction in the API.Would an alarm that's composable within a completion queue ease this implementation?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1948,31818249,2015-06-05T14:44:59Z,test/cpp/qps/interarrival.h,"@@ -0,0 +1,155 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef TEST_QPS_INTERARRIVAL_H+#define TEST_QPS_INTERARRIVAL_H++#include <chrono>+#include <cmath>+#include <random>++#include <grpc++/config.h>++namespace grpc {+namespace testing {++// First create classes that define a random distribution+// Note that this code does not include C++-specific random distribution+// features supported in std::random. Although this would make this code easier,+// this code is required to serve as the template code for other language+// stacks. Thus, this code only uses a uniform distribution of doubles [0,1)+// and then provides the distribution functions itself.++class RandomDist {+ public:+  RandomDist() {}+  virtual ~RandomDist() = 0;+  // Argument to operator() is a uniform double in the range [0,1)+  virtual double operator()(double uni) const = 0;+};++inline RandomDist::~RandomDist() {}++class UniformDist GRPC_FINAL : public RandomDist {+ public:+  UniformDist(double lo, double hi) : lo_(lo), range_(hi - lo) {}+  ~UniformDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE {+    return uni * range_ + lo_;+  }++ private:+  double lo_;+  double range_;+};++class ExpDist GRPC_FINAL : public RandomDist {+ public:+  explicit ExpDist(double lambda) : lambda_recip_(1.0 / lambda) {}+  ~ExpDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE {+    // Note: Use 1.0-uni above to avoid NaN if uni is 0+    return lambda_recip_ * (-log(1.0 - uni));+  }++ private:+  double lambda_recip_;+};++class DetDist GRPC_FINAL : public RandomDist {+ public:+  explicit DetDist(double val) : val_(val) {}+  ~DetDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE { return val_; }++ private:+  double val_;+};++class ParetoDist GRPC_FINAL : public RandomDist {+ public:+  ParetoDist(double base, double alpha)+      : base_(base), alpha_recip_(1.0 / alpha) {}+  ~ParetoDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE {+    // Note: Use 1.0-uni above to avoid div by zero if uni is 0+    return base_ / pow(1.0 - uni, alpha_recip_);+  }++ private:+  double base_;+  double alpha_recip_;+};++// A class library for generating pseudo-random interarrival times+// in an efficient re-entrant way. The random table is built at construction+// time, and each call must include the thread id of the invoker++typedef std::default_random_engine qps_random_engine;++class InterarrivalTimer {+ public:+  InterarrivalTimer() {}+  InterarrivalTimer(const RandomDist& r, int threads, int entries = 1000000) {+    init(r, threads, entries);+  }+  void init(const RandomDist& r, int threads, int entries = 1000000) {","Oops - I should deprecate this. This was a planned feature at some point to be able to resize or restart the distribution (for example, to dynamically change the thread count), but I never ended up using it. I will pull it.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1948,31818566,2015-06-05T14:48:03Z,test/cpp/qps/client_async.cc,"@@ -159,30 +206,126 @@ class AsyncClient : public Client {                   size_t thread_idx) GRPC_OVERRIDE GRPC_FINAL {     void* got_tag;     bool ok;-    switch (cli_cqs_[thread_idx]->AsyncNext(-        &got_tag, &ok,-        std::chrono::system_clock::now() + std::chrono::seconds(1))) {+    grpc_time deadline, short_deadline;+    if (closed_loop_) {+      deadline = grpc_time_source::now() + std::chrono::seconds(1);+      short_deadline = deadline;+    } else {+      if (rpc_deadlines_[thread_idx].empty()) {+        deadline = grpc_time_source::now() + std::chrono::seconds(1);+      } else {+        deadline = *(rpc_deadlines_[thread_idx].begin());+      }+      short_deadline =+          issue_allowed_[thread_idx] ? next_issue_[thread_idx] : deadline;+    }++    bool got_event;++    switch (cli_cqs_[thread_idx]->AsyncNext(&got_tag, &ok, short_deadline)) {       case CompletionQueue::SHUTDOWN:         return false;       case CompletionQueue::TIMEOUT:-        return true;+        got_event = false;+        break;       case CompletionQueue::GOT_EVENT:+        got_event = true;+        break;+      default:+        GPR_ASSERT(false);         break;     }--    ClientRpcContext* ctx = ClientRpcContext::detag(got_tag);-    if (ctx->RunNextState(ok, histogram) == false) {-      // call the callback and then delete it-      ctx->RunNextState(ok, histogram);-      ctx->StartNewClone();-      delete ctx;+    if ((closed_loop_ || !rpc_deadlines_[thread_idx].empty()) &&+        grpc_time_source::now() > deadline) {+      // we have missed some 1-second deadline, which is too much+      gpr_log(GPR_INFO, ""Missed an RPC deadline, giving up"");+      return false;+    }+    if (got_event) {+      ClientRpcContext* ctx = ClientRpcContext::detag(got_tag);+      if (ctx->RunNextState(ok, histogram) == false) {+        // call the callback and then clone the ctx+        ctx->RunNextState(ok, histogram);+        ClientRpcContext* clone_ctx = ctx->StartNewClone();+        if (closed_loop_) {+          clone_ctx->Start(cli_cqs_[thread_idx].get());+        } else {+          // Remove the entry from the rpc deadlines list+          rpc_deadlines_[thread_idx].erase(ctx->deadline_posn());+          // Put the clone_ctx in the list of idle contexts for this channel+          // Under lock+          int ch = clone_ctx->channel_id();+          std::lock_guard<std::mutex> g(channel_lock_[ch]);+          contexts_[ch].push_front(clone_ctx);+        }+        // delete the old version+        delete ctx;+      }+      if (!closed_loop_)+        issue_allowed_[thread_idx] =+            true;  // may be ok now even if it hadn't been+    }+    if (!closed_loop_ && issue_allowed_[thread_idx] &&+        grpc_time_source::now() >= next_issue_[thread_idx]) {","Yes, definitely. We can talk about this. It would certainly have been nice to insert alarms to indicate rpc-specific timeouts and for knowing when to next issue, rather than having that big mess of checks at the beginning to perfectly set the AsyncNext parameter.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1948,31818998,2015-06-05T14:52:24Z,test/cpp/qps/client_async.cc,"@@ -159,30 +206,126 @@ class AsyncClient : public Client {                   size_t thread_idx) GRPC_OVERRIDE GRPC_FINAL {     void* got_tag;     bool ok;-    switch (cli_cqs_[thread_idx]->AsyncNext(-        &got_tag, &ok,-        std::chrono::system_clock::now() + std::chrono::seconds(1))) {+    grpc_time deadline, short_deadline;+    if (closed_loop_) {+      deadline = grpc_time_source::now() + std::chrono::seconds(1);+      short_deadline = deadline;+    } else {+      if (rpc_deadlines_[thread_idx].empty()) {+        deadline = grpc_time_source::now() + std::chrono::seconds(1);+      } else {+        deadline = *(rpc_deadlines_[thread_idx].begin());+      }+      short_deadline =+          issue_allowed_[thread_idx] ? next_issue_[thread_idx] : deadline;+    }++    bool got_event;++    switch (cli_cqs_[thread_idx]->AsyncNext(&got_tag, &ok, short_deadline)) {       case CompletionQueue::SHUTDOWN:         return false;       case CompletionQueue::TIMEOUT:-        return true;+        got_event = false;+        break;       case CompletionQueue::GOT_EVENT:+        got_event = true;+        break;+      default:+        GPR_ASSERT(false);         break;     }--    ClientRpcContext* ctx = ClientRpcContext::detag(got_tag);-    if (ctx->RunNextState(ok, histogram) == false) {-      // call the callback and then delete it-      ctx->RunNextState(ok, histogram);-      ctx->StartNewClone();-      delete ctx;+    if ((closed_loop_ || !rpc_deadlines_[thread_idx].empty()) &&+        grpc_time_source::now() > deadline) {+      // we have missed some 1-second deadline, which is too much+      gpr_log(GPR_INFO, ""Missed an RPC deadline, giving up"");+      return false;+    }+    if (got_event) {+      ClientRpcContext* ctx = ClientRpcContext::detag(got_tag);+      if (ctx->RunNextState(ok, histogram) == false) {+        // call the callback and then clone the ctx+        ctx->RunNextState(ok, histogram);+        ClientRpcContext* clone_ctx = ctx->StartNewClone();+        if (closed_loop_) {+          clone_ctx->Start(cli_cqs_[thread_idx].get());+        } else {+          // Remove the entry from the rpc deadlines list+          rpc_deadlines_[thread_idx].erase(ctx->deadline_posn());+          // Put the clone_ctx in the list of idle contexts for this channel+          // Under lock+          int ch = clone_ctx->channel_id();+          std::lock_guard<std::mutex> g(channel_lock_[ch]);+          contexts_[ch].push_front(clone_ctx);+        }+        // delete the old version+        delete ctx;+      }+      if (!closed_loop_)+        issue_allowed_[thread_idx] =+            true;  // may be ok now even if it hadn't been+    }+    if (!closed_loop_ && issue_allowed_[thread_idx] &&+        grpc_time_source::now() >= next_issue_[thread_idx]) {","One other feature that might reduce complexity and improve performance in the common case would be to actually have separate per-thread per-channel state. Right now there's separate per-thread state and separate per-channel state, but nothing that is per-thread per-channel. Doing that might make sense for the idle contexts structure to avoid locking. The idea right now is that each thread has a preferred subset of the channels but will attempt to use others if those are full. An alternative would be to have each thread freely use each channel (though that just moves the possible mutex contention a layer lower). But this was all the big source of complexity in getting this debugged. Synchronization is hard.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1948,31837048,2015-06-05T18:12:26Z,test/cpp/qps/interarrival.h,"@@ -0,0 +1,155 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef TEST_QPS_INTERARRIVAL_H+#define TEST_QPS_INTERARRIVAL_H++#include <chrono>+#include <cmath>+#include <random>++#include <grpc++/config.h>++namespace grpc {+namespace testing {++// First create classes that define a random distribution+// Note that this code does not include C++-specific random distribution+// features supported in std::random. Although this would make this code easier,+// this code is required to serve as the template code for other language+// stacks. Thus, this code only uses a uniform distribution of doubles [0,1)+// and then provides the distribution functions itself.++class RandomDist {+ public:+  RandomDist() {}+  virtual ~RandomDist() = 0;+  // Argument to operator() is a uniform double in the range [0,1)+  virtual double operator()(double uni) const = 0;+};++inline RandomDist::~RandomDist() {}++class UniformDist GRPC_FINAL : public RandomDist {+ public:+  UniformDist(double lo, double hi) : lo_(lo), range_(hi - lo) {}+  ~UniformDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE {+    return uni * range_ + lo_;+  }++ private:+  double lo_;+  double range_;+};++class ExpDist GRPC_FINAL : public RandomDist {+ public:+  explicit ExpDist(double lambda) : lambda_recip_(1.0 / lambda) {}+  ~ExpDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE {+    // Note: Use 1.0-uni above to avoid NaN if uni is 0+    return lambda_recip_ * (-log(1.0 - uni));+  }++ private:+  double lambda_recip_;+};++class DetDist GRPC_FINAL : public RandomDist {+ public:+  explicit DetDist(double val) : val_(val) {}+  ~DetDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE { return val_; }++ private:+  double val_;+};++class ParetoDist GRPC_FINAL : public RandomDist {+ public:+  ParetoDist(double base, double alpha)+      : base_(base), alpha_recip_(1.0 / alpha) {}+  ~ParetoDist() GRPC_OVERRIDE {}+  double operator()(double uni) const GRPC_OVERRIDE {+    // Note: Use 1.0-uni above to avoid div by zero if uni is 0+    return base_ / pow(1.0 - uni, alpha_recip_);+  }++ private:+  double base_;+  double alpha_recip_;+};++// A class library for generating pseudo-random interarrival times+// in an efficient re-entrant way. The random table is built at construction+// time, and each call must include the thread id of the invoker++typedef std::default_random_engine qps_random_engine;++class InterarrivalTimer {+ public:+  InterarrivalTimer() {}+  InterarrivalTimer(const RandomDist& r, int threads, int entries = 1000000) {+    init(r, threads, entries);+  }+  void init(const RandomDist& r, int threads, int entries = 1000000) {","So, I acted the other way. I removed the parameterized constructor. I kept the init function. The reason is that we don't know right away what the useful parameters are for the random distribution until we've already parsed the proto in Client, not right when we construct Client.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/1948,31837273,2015-06-05T18:15:02Z,src/cpp/util/time.cc,"@@ -59,6 +60,20 @@ void Timepoint2Timespec(const system_clock::time_point& from,   to->tv_nsec = nsecs.count(); } +void TimepointHR2Timespec(const high_resolution_clock::time_point& from,+                          gpr_timespec* to) {+  high_resolution_clock::duration deadline = from.time_since_epoch();",What should be const? deadline? Do we care? I essentially copied the existing Timepoint2Timespec code.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1963,31869730,2015-06-06T17:12:05Z,include/grpc/byte_buffer.h,"@@ -34,10 +34,17 @@ #ifndef GRPC_BYTE_BUFFER_H #define GRPC_BYTE_BUFFER_H -#include <grpc/grpc.h> #include <grpc/support/slice_buffer.h> -typedef enum { GRPC_BB_SLICE_BUFFER } grpc_byte_buffer_type;+typedef enum {+  GRPC_BB_SLICE_BUFFER,++  /* Keep the GRPC_BB_COMPRESSED_* entries in the same order as the+   * grpc_compression_algorithm enum entries. */+  GRPC_BB_COMPRESSED_NONE, /* for overriding otherwise compressed channels */+  GRPC_BB_COMPRESSED_DEFLATE,","I wonder about splitting these out into an orthogonal property. Something like:``` ctypedef enum {  GRPC_BB_RAW,  /* in the future I expect GRPC_BB_PROTOBUF or similar */} grpc_byte_buffer_type;struct grpc_byte_buffer {  grpc_byte_buffer_type type;  union {    struct {      grpc_compression_algorithm compression;      grpc_slice_buffer slice_buffer;    } raw;  };};```Pros:- it's a little easier to interpret 'type'- it keeps some competing concerns separated  - it's easier to extend compression_type and byte_buffer_type independently- it'll be easier to add a GRPC_BB_PROTOBUF when we need toCons:- it's a larger change- the structure of byte_buffer is slightly more complex",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/1963,31879450,2015-06-07T18:55:25Z,include/grpc/byte_buffer.h,"@@ -34,10 +34,17 @@ #ifndef GRPC_BYTE_BUFFER_H #define GRPC_BYTE_BUFFER_H -#include <grpc/grpc.h> #include <grpc/support/slice_buffer.h> -typedef enum { GRPC_BB_SLICE_BUFFER } grpc_byte_buffer_type;+typedef enum {+  GRPC_BB_SLICE_BUFFER,++  /* Keep the GRPC_BB_COMPRESSED_* entries in the same order as the+   * grpc_compression_algorithm enum entries. */+  GRPC_BB_COMPRESSED_NONE, /* for overriding otherwise compressed channels */","The meaning behind the comment was that a channel compressed by default would, when instructed, not compress certain messages, resulting in said messages having this BB_COMPRESSED_NONE type. This would signal that the message indeed came from a compressing source but that in this instance, the data isn't compressed. I wonder if this distinction is useful though.Given your proposed change below, the redundancy between BB_SLICE_BUFFER and COMPRESSED_NONE is removed anyway.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2026,32091592,2015-06-10T06:38:13Z,src/core/channel/client_setup.c,"@@ -126,11 +126,9 @@ static void setup_cancel(grpc_transport_setup *sp) {   if (s->in_alarm) {     cancel_alarm = 1;   }+  gpr_mu_unlock(&s->mu);   if (--s->refs == 0) {","I realize this is closed, but just to note:The point of the duplication here is that it needs to be executed _after_ the --s->refs, otherwise we have a race condition. It also needs to be executed _before_ destroy_setup, or we destroy the mutex that we have locked.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/2072,32564787,2015-06-16T20:08:49Z,test/core/json/json_rewrite_test.c,"@@ -64,6 +64,11 @@ typedef struct json_reader_userdata { static void json_writer_output_char(void* userdata, char c) {   json_writer_userdata* state = userdata;   int cmp = fgetc(state->cmp);++  /* treat CRLF as LF */+  if (cmp == '\r' && c == '\n') {+	  cmp = fgetc(state->cmp);",There's a bad indentation here :-),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1577,32734923,2015-06-18T14:24:20Z,src/core/channel/client_setup.c,"@@ -148,7 +180,8 @@ int grpc_client_setup_cb_begin(grpc_client_setup_request *r) {   return 1; } -void grpc_client_setup_cb_end(grpc_client_setup_request *r) {+void grpc_client_setup_cb_end(grpc_client_setup_request *r,+                              const char *reason) {","It was there for some debugging getting everything up. Might be useful for debugging in the future. Then again, this module is scheduled for a rewrite next week to support the naming/load balancing efforts. Ok with leaving it til then?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/1577,32738498,2015-06-18T14:53:45Z,src/core/iomgr/pollset_multipoller_with_epoll.c,"@@ -100,8 +100,9 @@ static int multipoll_with_epoll_pollset_maybe_work(   if (gpr_time_cmp(deadline, gpr_inf_future) == 0) {     timeout_ms = -1;   } else {-    timeout_ms = gpr_time_to_millis(gpr_time_sub(deadline, now));-    if (timeout_ms <= 0) {+    timeout_ms = gpr_time_to_millis(+        gpr_time_add(gpr_time_sub(deadline, now), gpr_time_from_micros(500)));","Moved into a separate function, clarified necessary semantics, made it better",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/2131,32788289,2015-06-18T23:07:41Z,doc/interop-test-descriptions.md,"@@ -418,21 +420,31 @@ Procedure:       }     }     ```+The client attaches custom metadat with the following keys:",s/metadat/metadata/,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2134,32851526,2015-06-19T17:41:52Z,src/python/src/grpc/_adapter/_c/__init__.pyx,"@@ -0,0 +1,992 @@+# vim: expandtab:ts=2:sw=2:sts=2++cimport grpc+cimport cpython++import time++# There are a lot of nested structures in GRPC C core. We wrap all of them in+# Cython extension classes and nest them in parallel in their C and Python+# representations. Because they memory is synchronized between them, we can+# forego a lot of the manual memory management that would be handled by using+# the CPython API alone. Furthermore, we don't need to handle as many GC issues+# (any GC issues at all?) because of this interlocking between C and Python+# memory.++#+# Global state","I'm generally against ""section headings"" in source files as they indicate both knowledge that a file is too large and knowledge of where to break it up. Is there a Cython reason for having all this code together?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2134,32864944,2015-06-19T20:13:04Z,src/python/src/grpc/_adapter/_c/__init__.pyx,"@@ -0,0 +1,992 @@+# vim: expandtab:ts=2:sw=2:sts=2++cimport grpc+cimport cpython++import time++# There are a lot of nested structures in GRPC C core. We wrap all of them in+# Cython extension classes and nest them in parallel in their C and Python+# representations. Because they memory is synchronized between them, we can+# forego a lot of the manual memory management that would be handled by using+# the CPython API alone. Furthermore, we don't need to handle as many GC issues+# (any GC issues at all?) because of this interlocking between C and Python+# memory.++#+# Global state+#++cdef class _ModuleState:++  def __cinit__(self):+    grpc.grpc_init()++  def __dealloc__(self):+    grpc.grpc_shutdown()++_module_state = _ModuleState()+++#+# Enum exports+#++class StatusCode:+  ok = grpc.GRPC_STATUS_OK+  cancelled = grpc.GRPC_STATUS_CANCELLED+  unknown = grpc.GRPC_STATUS_UNKNOWN+  invalid_argument = grpc.GRPC_STATUS_INVALID_ARGUMENT+  deadline_exceeded = grpc.GRPC_STATUS_DEADLINE_EXCEEDED+  not_found = grpc.GRPC_STATUS_NOT_FOUND+  already_exists = grpc.GRPC_STATUS_ALREADY_EXISTS+  permission_denied = grpc.GRPC_STATUS_PERMISSION_DENIED+  unauthenticated = grpc.GRPC_STATUS_UNAUTHENTICATED+  resource_exhausted = grpc.GRPC_STATUS_RESOURCE_EXHAUSTED+  failed_precondition = grpc.GRPC_STATUS_FAILED_PRECONDITION+  aborted = grpc.GRPC_STATUS_ABORTED+  out_of_range = grpc.GRPC_STATUS_OUT_OF_RANGE+  unimplemented = grpc.GRPC_STATUS_UNIMPLEMENTED+  internal = grpc.GRPC_STATUS_INTERNAL+  unavailable = grpc.GRPC_STATUS_UNAVAILABLE+  data_loss = grpc.GRPC_STATUS_DATA_LOSS+++class CallError:+  ok = GRPC_CALL_OK+  error = GRPC_CALL_ERROR+  not_on_server = GRPC_CALL_ERROR_NOT_ON_SERVER+  not_on_client = GRPC_CALL_ERROR_NOT_ON_CLIENT+  already_accepted = GRPC_CALL_ERROR_ALREADY_ACCEPTED+  already_invoked = GRPC_CALL_ERROR_ALREADY_INVOKED+  not_invoked = GRPC_CALL_ERROR_NOT_INVOKED+  already_finished = GRPC_CALL_ERROR_ALREADY_FINISHED+  too_many_operations = GRPC_CALL_ERROR_TOO_MANY_OPERATIONS+  invalid_flags = GRPC_CALL_ERROR_INVALID_FLAGS+  invalid_metadata = GRPC_CALL_ERROR_INVALID_METADATA+++#+# Utility classes+#++cdef class Timespec:+  cdef grpc.gpr_timespec c_time+  def __cinit__(self, time):+    if time is None:+      self.c_time = grpc.gpr_now()+    elif isinstance(time, float):+      if time == float(""+inf""):+        self.c_time = grpc.gpr_inf_future+      elif time == float(""-inf""):+        self.c_time = grpc.gpr_inf_past+      else:+        self.c_time.seconds = time+        self.c_time.nanoseconds = (time - float(self.c_time.seconds)) * 1e9+    else:+      raise TypeError(""expected time to be float"")++  @property+  def seconds(self):+    return self.c_time.seconds++  @property+  def nanoseconds(self):+    return self.c_time.nanoseconds+++cdef class CallDetails:+  cdef grpc.grpc_call_details c_details+  def __cinit__(self):+    grpc.grpc_call_details_init(&self.c_details)++  def __dealloc__(self):+    grpc.grpc_call_details_destroy(&self.c_details)++  @property+  def method(self):+    if self.c_details.method != NULL:+      return <bytes>self.c_details.method+    else:+      return None++  @property+  def host(self):+    if self.c_details.host != NULL:+      return <bytes>self.c_details.host+    else:+      return None+++# TODO(atash): make this a private class...+cdef class OperationTag:+  cdef object user_tag+  cdef list references+  # This allows CompletionQueue to notify the Python Server object that the+  # underlying GRPC core server has shutdown+  cdef Server shutting_down_server+  cdef Call call+  cdef CallDetails request_call_details+  cdef Metadata request_metadata+  cdef Operations batch_operations+  def __cinit__(self, user_tag):+    self.user_tag = user_tag+    self.references = []+++cdef class Event:+  cdef readonly grpc.grpc_completion_type type+  cdef readonly bint success+  cdef readonly object tag++  # For operations with calls+  cdef readonly Call call++  # For Server.request_call+  cdef readonly CallDetails request_call_details+  cdef readonly Metadata request_metadata++  # For Call.start_batch+  cdef readonly Operations batch_operations++  def __cinit__(self, grpc.grpc_completion_type type, bint success,+                OperationTag tag, Call call,+                CallDetails request_call_details,+                Metadata request_metadata,+                Operations batch_operations):+    self.type = type+    self.success = success+    if tag is not None:+      self.tag = tag.user_tag+    self.call = call+    self.request_call_details = request_call_details+    self.request_metadata = request_metadata+    self.batch_operations = batch_operations+++cdef class ByteBuffer:+  cdef grpc.grpc_byte_buffer *c_byte_buffer+  def __cinit__(self, data):+    if data is None:+      self.c_byte_buffer = NULL+      return+    if isinstance(data, bytes):+      pass+    elif isinstance(data, basestring):+      data = data.encode()+    else:+      raise TypeError(""expected value to be of type str or bytes"")++    cdef char *c_data = data+    data_slice = grpc.gpr_slice_from_copied_buffer(c_data, len(data))+    self.c_byte_buffer = grpc.grpc_raw_byte_buffer_create(+        &data_slice, 1)+    grpc.gpr_slice_unref(data_slice)++  def bytes(self):+    cdef grpc.grpc_byte_buffer_reader reader+    cdef grpc.gpr_slice data_slice+    cdef size_t data_slice_length+    cdef void *data_slice_pointer+    if self.c_byte_buffer != NULL:+      grpc.grpc_byte_buffer_reader_init(&reader, self.c_byte_buffer)+      result = b""""+      while grpc.grpc_byte_buffer_reader_next(&reader, &data_slice):+        data_slice_pointer = grpc.gpr_slice_start_ptr(data_slice)+        data_slice_length = grpc.gpr_slice_length(data_slice)+        result += (<char *>data_slice_pointer)[:data_slice_length]+      grpc.grpc_byte_buffer_reader_destroy(&reader)+      return result+    else:+      return None++  def __len__(self):+    if self.c_byte_buffer != NULL:+      return grpc.grpc_byte_buffer_length(self.c_byte_buffer)+    else:+      return 0++  def __str__(self):+    return self.bytes()++  def __dealloc__(self):+    if self.c_byte_buffer != NULL:+      grpc.grpc_byte_buffer_destroy(self.c_byte_buffer)+++cdef class ChannelArg:+  cdef grpc.grpc_arg c_arg+  cdef readonly object key, value+  def __cinit__(self, key, value):+    if isinstance(key, bytes):+      self.key = key+    elif isinstance(key, basestring):+      self.key = key.encode()+    else:+      raise TypeError(""expected key to be of type str or bytes"")+    if isinstance(value, bytes):+      self.value = value+      self.c_arg.type = grpc.GRPC_ARG_STRING+      self.c_arg.value.string = self.value+    elif isinstance(value, basestring):+      self.value = value.encode()+      self.c_arg.type = grpc.GRPC_ARG_STRING+      self.c_arg.value.string = self.value+    elif isinstance(value, int):+      self.value = int(value)+      self.c_arg.type = grpc.GRPC_ARG_INTEGER+      self.c_arg.value.integer = self.value+    else:+      raise TypeError(""expected value to be of type str or bytes or int"")+++cdef class ChannelArgs:+  cdef grpc.grpc_channel_args c_args+  cdef list args+  def __cinit__(self, args):+    self.args = list(args)+    for arg in self.args:+      if not isinstance(arg, ChannelArg):+        raise TypeError(""expected list of ChannelArg"")+    self.c_args.arguments_length = len(self.args)+    self.c_args.arguments = <grpc.grpc_arg *>grpc.gpr_malloc(+        self.c_args.arguments_length*sizeof(grpc.grpc_arg)+    )+    for i in range(self.c_args.arguments_length):+      self.c_args.arguments[i] = (<ChannelArg>self.args[i]).c_arg++  def __dealloc__(self):+    grpc.gpr_free(self.c_args.arguments)++  def __len__(self):+    # self.args is never stale; it's only updated from this file+    return len(self.args)++  def __getitem__(self, size_t i):+    # self.args is never stale; it's only updated from this file+    return self.args[i]+++cdef class Metadatum:+  cdef grpc.grpc_metadata c_metadata+  cdef object _key, _value+  def __cinit__(self, key, value):+    if isinstance(key, bytes):+      self._key = key+    elif isinstance(key, basestring):+      self._key = key.encode()+    else:+      raise TypeError(""expected key to be of type str or bytes"")+    if isinstance(value, bytes):+      self._value = value+    elif isinstance(value, basestring):+      self._value = value.encode()+    else:+      raise TypeError(""expected value to be of type str or bytes"")+    self.c_metadata.key = self._key+    self.c_metadata.value = self._value+    self.c_metadata.value_length = len(self._value)++  @property+  def key(self):+    return <bytes>self.c_metadata.key++  @property+  def value(self):+    return <bytes>self.c_metadata.value[:self.c_metadata.value_length]+++cdef class Metadata:+  cdef grpc.grpc_metadata_array c_metadata_array+  cdef object metadata+  def __cinit__(self, metadata):+    self.metadata = list(metadata)+    for metadatum in metadata:+      if not isinstance(metadatum, Metadatum):+        raise TypeError(""expected list of Metadatum"")+    grpc.grpc_metadata_array_init(&self.c_metadata_array)+    self.c_metadata_array.count = len(self.metadata)+    self.c_metadata_array.capacity = len(self.metadata)+    self.c_metadata_array.metadata = <grpc.grpc_metadata *>grpc.gpr_malloc(+        self.c_metadata_array.count*sizeof(grpc.grpc_metadata)+    )+    for i in range(self.c_metadata_array.count):+      self.c_metadata_array.metadata[i] = \+          (<Metadatum>self.metadata[i]).c_metadata++  def __dealloc__(self):+    # this frees the allocated memory for the grpc_metadata_array (although+    # it'd be nice if that were documented somewhere...) TODO(atash): document+    # this in the C core+    grpc.grpc_metadata_array_destroy(&self.c_metadata_array)++  def __len__(self):+    return self.c_metadata_array.count++  def __getitem__(self, size_t i):+    return Metadatum(+        key=<bytes>self.c_metadata_array.metadata[i].key,+        value=<bytes>self.c_metadata_array.metadata[i].value[+            :self.c_metadata_array.metadata[i].value_length])++#+# User-facing/bookkeeping classes+#++cdef class Operation:+  cdef grpc.grpc_op c_op+  cdef ByteBuffer _received_message+  cdef Metadata _received_metadata+  cdef grpc.grpc_status_code _received_status_code+  cdef char *_received_status_details+  cdef size_t _received_status_details_capacity+  cdef int _received_cancelled+  cdef readonly bint is_valid+  cdef object references+  def __cinit__(self):+    self.references = []+    self._received_status_details = NULL+    self._received_status_details_capacity = 0+    self.is_valid = False++  @property+  def received_message(self):+    if self.c_op.type != grpc.GRPC_OP_RECV_MESSAGE:+      raise TypeError(""self must be an operation receiving a message"")+    return self._received_message++  @property+  def received_metadata(self):+    if self.c_op.type != grpc.GRPC_OP_RECV_INITIAL_METADATA and \+        self.c_op.type != grpc.GRPC_OP_RECV_STATUS_ON_CLIENT:+      raise TypeError(""self must be an operation receiving metadata"")+    return self._received_metadata++  @property+  def received_status_code(self):+    if self.c_op.type != grpc.GRPC_OP_RECV_STATUS_ON_CLIENT:+      raise TypeError(""self must be an operation receiving a status code"")+    return self._received_status_code++  @property+  def received_status_details(self):+    if self.c_op.type != grpc.GRPC_OP_RECV_STATUS_ON_CLIENT:+      raise TypeError(""self must be an operation receiving status details"")+    if self._received_status_details:+      return self._received_status_details+    else:+      return None++  @property+  def received_cancelled(self):+    if self.c_op.type != grpc.GRPC_OP_RECV_CLOSE_ON_SERVER:+      raise TypeError(""self must be an operation receiving cancellation information"")+    return False if self._received_cancelled == 0 else True+++  @staticmethod+  def send_initial_metadata(Metadata metadata):+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_SEND_INITIAL_METADATA+    op.c_op.data.send_initial_metadata.count = metadata.c_metadata_array.count+    op.c_op.data.send_initial_metadata.metadata = \+        metadata.c_metadata_array.metadata+    op.references.append(metadata)+    op.is_valid = True+    return op++  @staticmethod+  def send_message(data):+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_SEND_MESSAGE+    byte_buffer = ByteBuffer(data)+    op.c_op.data.send_message = byte_buffer.c_byte_buffer+    op.references.append(byte_buffer)+    op.is_valid = True+    return op++  @staticmethod+  def send_close_from_client():+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_SEND_CLOSE_FROM_CLIENT+    op.is_valid = True+    return op++  @staticmethod+  def send_status_from_server(Metadata metadata, grpc.grpc_status_code code,+                              details):+    if isinstance(details, bytes):+      pass+    elif isinstance(details, basestring):+      details = details.encode()+    else:+      raise TypeError(""expected a str or bytes object for details"")+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_SEND_STATUS_FROM_SERVER+    op.c_op.data.send_status_from_server.trailing_metadata_count = \+        metadata.c_metadata_array.count+    op.c_op.data.send_status_from_server.trailing_metadata = \+        metadata.c_metadata_array.metadata+    op.c_op.data.send_status_from_server.status = code+    op.c_op.data.send_status_from_server.status_details = details+    op.references.append(metadata)+    op.references.append(details)+    op.is_valid = True+    return op++  @staticmethod+  def receive_initial_metadata():+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_RECV_INITIAL_METADATA+    op._received_metadata = Metadata()+    op.c_op.data.receive_initial_metadata = \+        &op._received_metadata.c_metadata_array+    op.is_valid = True+    return op++  @staticmethod+  def receive_message():+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_RECV_MESSAGE+    op._received_message = ByteBuffer(None)+    # n.b. the c_op.data.receive_message field needs to be deleted by us,+    # anyway, so we just let that be handled by the ByteBuffer() we allocated+    # the line before.+    op.c_op.data.receive_message = &op._received_message.c_byte_buffer+    op.is_valid = True+    return op++  @staticmethod+  def receive_status_on_client():+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_RECV_STATUS_ON_CLIENT+    op._received_metadata = Metadata()+    op.c_op.data.receive_status_on_client.trailing_metadata = \+        &op._received_metadata.c_metadata_array+    op.c_op.data.receive_status_on_client.status = \+        &op._received_status_code+    op.c_op.data.receive_status_on_client.status_details = \+        &op._received_status_details+    op.c_op.data.receive_status_on_client.status_details_capacity = \+        &op._received_status_details_capacity+    op.is_valid = True+    return op++  @staticmethod+  def receive_close_on_server():+    op = Operation()+    op.c_op.type = grpc.GRPC_OP_RECV_CLOSE_ON_SERVER+    op.c_op.data.receive_close_on_server.cancelled = &op._received_cancelled+    op.is_valid = True+    return op++  def __dealloc__(self):+    # We *almost* don't need to do anything; most of the objects are handled by+    # Python. The remaining ones are primitive fields filled in by GRPC core.+    # This means that we need to clean up after receive_status_on_client.+    if self.c_op.type == grpc.GRPC_OP_RECV_STATUS_ON_CLIENT:+      grpc.gpr_free(self._received_status_details)+++cdef class Operations:+  cdef grpc.grpc_op *c_ops+  cdef size_t c_nops+  cdef list operations+  def __cinit__(self, operations):+    self.operations = list(operations)  # normalize iterable+    self.c_ops = NULL+    self.c_nops = 0+    for operation in self.operations:+      if not isinstance(operation, Operation):+        raise TypeError(""expected operations to be iterable of Operation"")+    self.c_nops = len(self.operations)+    cdef grpc.grpc_op *c_ops = <grpc.grpc_op *>grpc.gpr_malloc(+        sizeof(grpc.grpc_op)*self.c_nops)+    for i in range(self.c_nops):+      c_ops[i] = (<Operation>(self.operations[i])).c_op++  def __len__(self):+    return self.c_nops++  def __getitem__(self, size_t i):+    # self.operations is never stale; it's only updated from this file+    return self.operations[i]++  def __dealloc__(self):+    grpc.gpr_free(self.c_ops)+++#+# User-facing classes+#++cdef class ClientCredentials:+  cdef grpc.grpc_credentials *c_credentials+  cdef grpc.grpc_ssl_pem_key_cert_pair ssl_pem_key_cert_pair+  cdef list references+  def __cinit__(self):+    self.c_credentials = NULL+    self.ssl_pem_key_cert_pair.private_key = NULL+    self.ssl_pem_key_cert_pair.certificate_chain = NULL+    self.references = []++  @property+  def is_valid(self):+    return self.c_credentials != NULL++  @staticmethod+  def google_default():+    credentials = ClientCredentials();+    credentials.c_credentials = grpc.grpc_google_default_credentials_create()+    return credentials++  @staticmethod+  def ssl(pem_root_certificates, private_key, certificate_chain):+    if pem_root_certificates is None:+      pass+    elif isinstance(pem_root_certificates, bytes):+      pass+    elif isinstance(pem_root_certificates, basestring):+      pem_root_certificates = pem_root_certificates.encode()+    else:+      raise TypeError(""expected str or bytes for pem_root_certificates"")+    if private_key is None:+      pass+    elif isinstance(private_key, bytes):+      pass+    elif isinstance(private_key, basestring):+      private_key = private_key.encode()+    else:+      raise TypeError(""expected str or bytes for private_key"")+    if certificate_chain is None:+      pass+    elif isinstance(certificate_chain, bytes):+      pass+    elif isinstance(certificate_chain, basestring):+      certificate_chain = certificate_chain.encode()+    else:+      raise TypeError(""expected str or bytes for certificate chain"")+    if (private_key is not None) != (certificate_chain is not None):+      raise ValueError(""if private_key is specified, so must certificate_chain (and vice-versa)"")+    credentials = ClientCredentials()+    cdef const char *c_pem_root_certificates = NULL+    if pem_root_certificates is not None:+      c_pem_root_certificates = pem_root_certificates+      credentials.references.append(pem_root_certificates)+    has_pem_key_cert_pair = \+        private_key is not None and certificate_chain is not None+    if has_pem_key_cert_pair:+      credentials.ssl_pem_key_cert_pair.private_key = private_key+      credentials.ssl_pem_key_cert_pair.certificate_chain = certificate_chain+      credentials.c_credentials = grpc.grpc_ssl_credentials_create(+          c_pem_root_certificates, &credentials.ssl_pem_key_cert_pair+      )+      credentials.references.append(private_key)+      credentials.references.append(certificate_chain)+    else:+      credentials.c_credentials = grpc.grpc_ssl_credentials_create(+        c_pem_root_certificates, NULL+      )++  @staticmethod+  def composite_credentials(ClientCredentials credentials_1 not None,+                            ClientCredentials credentials_2 not None):+    if not credentials_1.is_valid or not credentials_2.is_valid:+      raise ValueError(""passed credentials must both be valid"")+    credentials = ClientCredentials()+    credentials.c_credentials = grpc.grpc_composite_credentials_create(+        credentials_1.c_credentials, credentials_2.c_credentials)+    credentials.references.append(credentials_1)+    credentials.references.append(credentials_2)+    return credentials++  @staticmethod+  def compute_engine():+    credentials = ClientCredentials()+    credentials.c_credentials = grpc.grpc_compute_engine_credentials_create()+    return credentials++  @staticmethod+  def jwt(json_key, Timespec token_lifetime not None):+    if isinstance(json_key, bytes):+      pass+    elif isinstance(json_key, basestring):+      json_key = json_key.encode()+    else:+      raise TypeError(""expected json_key to be str or bytes"")+    credentials = ClientCredentials()+    credentials.c_credentials = grpc.grpc_jwt_credentials_create(+        json_key, token_lifetime.c_time)+    credentials.references.append(json_key)+    return credentials++  @staticmethod+  def refresh_token(json_refresh_token):+    if isinstance(json_refresh_token, bytes):+      pass+    elif isinstance(json_refresh_token, basestring):+      json_refresh_token = json_refresh_token.encode()+    else:+      raise TypeError(""expected json_refresh_token to be str or bytes"")+    credentials = ClientCredentials()+    credentials.c_credentials = grpc.grpc_refresh_token_credentials_create(+        json_refresh_token)+    credentials.references.append(json_refresh_token)+    return credentials++  @staticmethod+  def fake_transport_security():+    credentials = ClientCredentials()+    credentials.c_credentials = \+        grpc.grpc_fake_transport_security_credentials_create()+    return credentials++  @staticmethod+  def iam(authorization_token, authority_selector):+    if isinstance(authorization_token, bytes):+      pass+    elif isinstance(authorization_token, basestring):+      authorization_token = authorization_token.encode()+    else:+      raise TypeError(""expected authorization_token to be str or bytes"")+    if isinstance(authority_selector, bytes):+      pass+    elif isinstance(authority_selector, basestring):+      authority_selector = authority_selector.encode()+    else:+      raise TypeError(""expected authority_selector to be str or bytes"")+    credentials = ClientCredentials()+    credentials.c_credentials = grpc.grpc_iam_credentials_create(+        authorization_token, authority_selector)+    credentials.references.append(authorization_token)+    credentials.references.append(authority_selector)+    return credentials++  def __dealloc__(self):+    if self.c_credentials != NULL:+      grpc.grpc_credentials_release(self.c_credentials)+++cdef class ServerCredentials:+  cdef grpc.grpc_server_credentials *c_credentials+  cdef list references+  def __cinit__(self):+    self.c_credentials = NULL++  @staticmethod+  def ssl(pem_root_certs, pem_key_cert_pairs):+    if pem_root_certs is None:+      pass+    elif isinstance(pem_root_certs, bytes):+      pass+    elif isinstance(pem_root_certs, basestring):+      pem_root_certs = pem_root_certs.encode()+    else:+      raise TypeError(""expected pem_root_certs to be str or bytes"")+    pairs = []+    for pair in pem_key_cert_pairs:+      pass+    raise NotImplementedError(""fuuuuuuuu"")++  #grpc_server_credentials *grpc_ssl_server_credentials_create(+  #    const char *pem_root_certs,+  #    grpc_ssl_pem_key_cert_pair *pem_key_cert_pairs,+  #    size_t num_key_cert_pairs);++  @staticmethod+  def fake_transport_security():+    credentials = ServerCredentials()+    credentials.c_credentials = \+        grpc.grpc_fake_transport_security_server_credentials_create()+    return credentials++  def __dealloc__(self):+    if self.c_credentials != NULL:+      grpc.grpc_server_credentials_release(self.c_credentials)+++cdef class CompletionQueue:+  # MUST: all tags pushed onto this completion queue are Python objects or+  # NULL.+  # HIGHLY RECOMMENDED: all tags pushed onto this completion queue are+  # OperationTag.+  # TODO(atash) thread safety!+  cdef grpc.grpc_completion_queue *c_completion_queue+  # because shutdown isn't yet idempotent...+  cdef bint is_shutting_down+  cdef bint is_shutdown++  def __cinit__(self):+    self.c_completion_queue = grpc.grpc_completion_queue_create()+    self.is_shutting_down = False+    self.is_shutdown = False++  def poll(self, Timespec deadline = None):","I'unno. From what I've seen of code styles In the C family, the default arguments of typed parameters have spaces, but then again this is syntactically Python, so, pick your poison. If you want more-Python-less-C, I'd drop the spaces.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2047,32876128,2015-06-19T22:53:14Z,include/grpc/grpc.h,"@@ -387,7 +386,8 @@ grpc_call *grpc_channel_create_registered_call(    completion of type 'tag' to the completion queue bound to the call.    The order of ops specified in the batch has no significance.    Only one operation of each type can be active at once in any given-   batch. */+   batch. +   THREAD SAFETY: grpc_call_start_batch is thread-compatible */","There's a more complicated story here.I think what we end up wanting is:At most one thread can be starting a batch with GRPC_OP_SEND_\* operations, and at most one thread can be starting a batch with GRPC_OP_RECV_\* operations.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2151,32951317,2015-06-22T16:04:57Z,test/cpp/qps/run_perf_db_test.py,"@@ -0,0 +1,289 @@+#!/usr/bin/python","I believe that this file does not belong in the grpc repository at all. This should be in grpc-tools, as it introduces far too many dependences (IMO) to be used well in grpc. You need to have netperf, etc., for this to be used sensibly. Truth be told, I would just as well see all the support infrastructure (PerfDBReporter class, etc) moved out of grpc and into grpc-tools. but that is less critical as it's still somewhat consistent with the overall repository.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2134,32964478,2015-06-22T18:07:03Z,src/python/src/grpc/_adapter/_c/__init__.pyx,"@@ -0,0 +1,992 @@+# vim: expandtab:ts=2:sw=2:sts=2++cimport grpc+cimport cpython++import time++# There are a lot of nested structures in GRPC C core. We wrap all of them in+# Cython extension classes and nest them in parallel in their C and Python+# representations. Because they memory is synchronized between them, we can+# forego a lot of the manual memory management that would be handled by using+# the CPython API alone. Furthermore, we don't need to handle as many GC issues+# (any GC issues at all?) because of this interlocking between C and Python+# memory.++#+# Global state","That was actually a note to myself, but I was still intending on having a section header. There's no Cython-specific reason, but there is a memory-management-awareness reason. There's at least one instance of cross-cutting (via `OperationTag` between `CompletionQueue`, `Server`, `Call`), and even if the file were broken up I'd still prefer to have those classes together (because memory management is pretty much the only important thing in the wrapping layer). They weren't together before in CPython because the file length would've been long enough that one could not easily skim through it in text editors without block folding (at least, that was one of my additional justifications after ya asked :-P ).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2047,32970876,2015-06-22T19:02:54Z,include/grpc/grpc.h,"@@ -387,7 +386,8 @@ grpc_call *grpc_channel_create_registered_call(    completion of type 'tag' to the completion queue bound to the call.    The order of ops specified in the batch has no significance.    Only one operation of each type can be active at once in any given-   batch. */+   batch. +   THREAD SAFETY: grpc_call_start_batch is thread-compatible */","Ah, thanks for clarification. So what you meant is:1. access call_start_batch needs to be synchronized if used from multiple threads 2. rule 1 is valid for all batch operations with the exception of  read and write operations, that can be synchronized separately (as an optimization allowing fully independent reading vs writing)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2047,32972373,2015-06-22T19:17:11Z,include/grpc/grpc.h,"@@ -387,7 +386,8 @@ grpc_call *grpc_channel_create_registered_call(    completion of type 'tag' to the completion queue bound to the call.    The order of ops specified in the batch has no significance.    Only one operation of each type can be active at once in any given-   batch. */+   batch. +   THREAD SAFETY: grpc_call_start_batch is thread-compatible */","RightOn Mon, Jun 22, 2015, 12:03 PM Jan Tattermusch notifications@github.comwrote:> In include/grpc/grpc.h> https://github.com/grpc/grpc/pull/2047#discussion_r32970876:> > > @@ -387,7 +386,8 @@ grpc_call *grpc_channel_create_registered_call(> >     completion of type 'tag' to the completion queue bound to the call.> >     The order of ops specified in the batch has no significance.> >     Only one operation of each type can be active at once in any given> > -   batch. */> > -   batch.> > -   THREAD SAFETY: grpc_call_start_batch is thread-compatible */> > Ah, thanks for clarification. So what you meant is:> 1. access call_start_batch needs to be synchronized if used from multiple> threads> 2. rule 1 is valid for all batch operations with the exception of read and> write operations, that can be synchronized separately (as an optimization> allowing fully independent reading vs writing)> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2047/files#r32970876.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2170,32995571,2015-06-22T23:24:04Z,src/core/transport/stream_op.h,"@@ -85,29 +85,62 @@ typedef struct grpc_mdelem_list { } grpc_mdelem_list;  typedef struct grpc_metadata_batch {+  /** Metadata elements in this batch */   grpc_mdelem_list list;+  /** Elements that have been removed from the batch, but have+      not yet been unreffed - used to allow collecting garbage+      under a single metadata context lock */   grpc_mdelem_list garbage;+  /** Used to calculate grpc-timeout at the point of sending,+      or gpr_inf_future if this batch does not need to send a+      grpc-timeout */   gpr_timespec deadline; } grpc_metadata_batch; -void grpc_metadata_batch_init(grpc_metadata_batch *comd);-void grpc_metadata_batch_destroy(grpc_metadata_batch *comd);+void grpc_metadata_batch_init(grpc_metadata_batch *batch);+void grpc_metadata_batch_destroy(grpc_metadata_batch *batch); void grpc_metadata_batch_merge(grpc_metadata_batch *target,                                grpc_metadata_batch *add); -void grpc_metadata_batch_link_head(grpc_metadata_batch *comd,+/** Add \a storage to the beginning of \a batch. storage->md is+    assumed to be valid. +    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call. */+void grpc_metadata_batch_link_head(grpc_metadata_batch *batch,                                    grpc_linked_mdelem *storage);-void grpc_metadata_batch_link_tail(grpc_metadata_batch *comd,+/** Add \a storage to the end of \a batch. storage->md is+    assumed to be valid.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call. */+void grpc_metadata_batch_link_tail(grpc_metadata_batch *batch,                                    grpc_linked_mdelem *storage); -void grpc_metadata_batch_add_head(grpc_metadata_batch *comd,+/** Add \a elem_to_add as the first element in \a batch, using+    \a storage as backing storage for the linked list element.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call.+    Takes ownership of \a elem_to_add */+void grpc_metadata_batch_add_head(grpc_metadata_batch *batch,                                   grpc_linked_mdelem *storage,                                   grpc_mdelem *elem_to_add);-void grpc_metadata_batch_add_tail(grpc_metadata_batch *comd,+/** Add \a elem_to_add as the last element in \a batch, using+    \a storage as backing storage for the linked list element.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call.+    Takes ownership of \a elem_to_add */+void grpc_metadata_batch_add_tail(grpc_metadata_batch *batch,                                   grpc_linked_mdelem *storage,                                   grpc_mdelem *elem_to_add); -void grpc_metadata_batch_filter(grpc_metadata_batch *comd,+/** For each element in \a batch, execute \a filter.+    The return value from \a filter will be substituted for the+    grpc_mdelem passed to \a filter. If \a filter returns NULL,+    the element will be moved to the garbage list. */+void grpc_metadata_batch_filter(grpc_metadata_batch *batch,","What role does the ""user_data"" arg. play? (the 3rd arg to grpc_metadata_batch_filter one). I mean, ""user_data"" should also be mentioned in the docstring. I see it's used as an input/output arg.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2170,32997271,2015-06-22T23:47:43Z,src/core/transport/stream_op.h,"@@ -85,29 +85,62 @@ typedef struct grpc_mdelem_list { } grpc_mdelem_list;  typedef struct grpc_metadata_batch {+  /** Metadata elements in this batch */   grpc_mdelem_list list;+  /** Elements that have been removed from the batch, but have+      not yet been unreffed - used to allow collecting garbage+      under a single metadata context lock */   grpc_mdelem_list garbage;+  /** Used to calculate grpc-timeout at the point of sending,+      or gpr_inf_future if this batch does not need to send a+      grpc-timeout */   gpr_timespec deadline; } grpc_metadata_batch; -void grpc_metadata_batch_init(grpc_metadata_batch *comd);-void grpc_metadata_batch_destroy(grpc_metadata_batch *comd);+void grpc_metadata_batch_init(grpc_metadata_batch *batch);+void grpc_metadata_batch_destroy(grpc_metadata_batch *batch); void grpc_metadata_batch_merge(grpc_metadata_batch *target,                                grpc_metadata_batch *add); -void grpc_metadata_batch_link_head(grpc_metadata_batch *comd,+/** Add \a storage to the beginning of \a batch. storage->md is+    assumed to be valid. +    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call. */+void grpc_metadata_batch_link_head(grpc_metadata_batch *batch,                                    grpc_linked_mdelem *storage);-void grpc_metadata_batch_link_tail(grpc_metadata_batch *comd,+/** Add \a storage to the end of \a batch. storage->md is+    assumed to be valid.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call. */+void grpc_metadata_batch_link_tail(grpc_metadata_batch *batch,                                    grpc_linked_mdelem *storage); -void grpc_metadata_batch_add_head(grpc_metadata_batch *comd,+/** Add \a elem_to_add as the first element in \a batch, using+    \a storage as backing storage for the linked list element.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call.+    Takes ownership of \a elem_to_add */+void grpc_metadata_batch_add_head(grpc_metadata_batch *batch,                                   grpc_linked_mdelem *storage,                                   grpc_mdelem *elem_to_add);-void grpc_metadata_batch_add_tail(grpc_metadata_batch *comd,+/** Add \a elem_to_add as the last element in \a batch, using+    \a storage as backing storage for the linked list element.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call.+    Takes ownership of \a elem_to_add */+void grpc_metadata_batch_add_tail(grpc_metadata_batch *batch,                                   grpc_linked_mdelem *storage,                                   grpc_mdelem *elem_to_add); -void grpc_metadata_batch_filter(grpc_metadata_batch *comd,+/** For each element in \a batch, execute \a filter.+    The return value from \a filter will be substituted for the+    grpc_mdelem passed to \a filter. If \a filter returns NULL,+    the element will be moved to the garbage list. */+void grpc_metadata_batch_filter(grpc_metadata_batch *batch,","It's literally a pointer that's passed right through, which is a useful C thing to do to provide context for whatever a callback is doing. In C++11 we'd do a lambda capture; in C++98 we'd pass down an abstract base class with a single method Run().",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2170,32997783,2015-06-22T23:55:59Z,src/core/transport/stream_op.h,"@@ -85,29 +85,62 @@ typedef struct grpc_mdelem_list { } grpc_mdelem_list;  typedef struct grpc_metadata_batch {+  /** Metadata elements in this batch */   grpc_mdelem_list list;+  /** Elements that have been removed from the batch, but have+      not yet been unreffed - used to allow collecting garbage+      under a single metadata context lock */   grpc_mdelem_list garbage;+  /** Used to calculate grpc-timeout at the point of sending,+      or gpr_inf_future if this batch does not need to send a+      grpc-timeout */   gpr_timespec deadline; } grpc_metadata_batch; -void grpc_metadata_batch_init(grpc_metadata_batch *comd);-void grpc_metadata_batch_destroy(grpc_metadata_batch *comd);+void grpc_metadata_batch_init(grpc_metadata_batch *batch);+void grpc_metadata_batch_destroy(grpc_metadata_batch *batch); void grpc_metadata_batch_merge(grpc_metadata_batch *target,                                grpc_metadata_batch *add); -void grpc_metadata_batch_link_head(grpc_metadata_batch *comd,+/** Add \a storage to the beginning of \a batch. storage->md is+    assumed to be valid. +    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call. */+void grpc_metadata_batch_link_head(grpc_metadata_batch *batch,                                    grpc_linked_mdelem *storage);-void grpc_metadata_batch_link_tail(grpc_metadata_batch *comd,+/** Add \a storage to the end of \a batch. storage->md is+    assumed to be valid.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call. */+void grpc_metadata_batch_link_tail(grpc_metadata_batch *batch,                                    grpc_linked_mdelem *storage); -void grpc_metadata_batch_add_head(grpc_metadata_batch *comd,+/** Add \a elem_to_add as the first element in \a batch, using+    \a storage as backing storage for the linked list element.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call.+    Takes ownership of \a elem_to_add */+void grpc_metadata_batch_add_head(grpc_metadata_batch *batch,                                   grpc_linked_mdelem *storage,                                   grpc_mdelem *elem_to_add);-void grpc_metadata_batch_add_tail(grpc_metadata_batch *comd,+/** Add \a elem_to_add as the last element in \a batch, using+    \a storage as backing storage for the linked list element.+    \a storage is owned by the caller and must survive for the+    lifetime of batch. This usually means it should be around+    for the lifetime of the call.+    Takes ownership of \a elem_to_add */+void grpc_metadata_batch_add_tail(grpc_metadata_batch *batch,                                   grpc_linked_mdelem *storage,                                   grpc_mdelem *elem_to_add); -void grpc_metadata_batch_filter(grpc_metadata_batch *comd,+/** For each element in \a batch, execute \a filter.+    The return value from \a filter will be substituted for the+    grpc_mdelem passed to \a filter. If \a filter returns NULL,+    the element will be moved to the garbage list. */+void grpc_metadata_batch_filter(grpc_metadata_batch *batch,","I see. Got confused by the overloading of the ""user_data"" name :)",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2180,33086096,2015-06-23T20:12:48Z,tools/doxygen/Doxyfile.c++,"@@ -26,7 +26,7 @@ # for the list of possible encodings. # The default value is: UTF-8. -DOXYFILE_ENCODING      = UTF-8+DOXYFILE_ENCODING = UTF - 8","clang-format was too eager to help! Fixed.On Tue, Jun 23, 2015 at 1:09 PM, Craig Tiller notifications@github.comwrote:> In tools/doxygen/Doxyfile.c++> https://github.com/grpc/grpc/pull/2180#discussion_r33085553:> > > @@ -26,7 +26,7 @@> >  # for the list of possible encodings.> >  # The default value is: UTF-8.> > > > -DOXYFILE_ENCODING      = UTF-8> > +DOXYFILE_ENCODING = UTF - 8> > Something went horribly wrong here> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2180/files#r33085553.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2149,33201796,2015-06-24T21:57:52Z,src/core/transport/chttp2/incoming_metadata.c,"@@ -0,0 +1,207 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/transport/chttp2/incoming_metadata.h""++#include <string.h>++#include ""src/core/transport/chttp2/internal.h""++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++void grpc_chttp2_incoming_metadata_buffer_init(+    grpc_chttp2_incoming_metadata_buffer *buffer) {+  buffer->deadline = gpr_inf_future;+}++void grpc_chttp2_incoming_metadata_buffer_destroy(+    grpc_chttp2_incoming_metadata_buffer *buffer) {+  gpr_free(buffer->elems);+}++void grpc_chttp2_incoming_metadata_buffer_add(+    grpc_chttp2_incoming_metadata_buffer *buffer, grpc_mdelem *elem) {+  if (buffer->capacity == buffer->count) {+    buffer->capacity = GPR_MAX(8, 2 * buffer->capacity);+    buffer->elems =+        gpr_realloc(buffer->elems, sizeof(*buffer->elems) * buffer->capacity);+  }+  buffer->elems[buffer->count++].md = elem;+}++void grpc_chttp2_incoming_metadata_buffer_set_deadline(+    grpc_chttp2_incoming_metadata_buffer *buffer, gpr_timespec deadline) {+  buffer->deadline = deadline;+}++void grpc_chttp2_incoming_metadata_live_op_buffer_end(+    grpc_chttp2_incoming_metadata_live_op_buffer *buffer) {+  gpr_free(buffer->elems);+  buffer->elems = NULL;+}++void grpc_chttp2_incoming_metadata_buffer_place_metadata_batch_into(+    grpc_chttp2_incoming_metadata_buffer *buffer, grpc_stream_op_buffer *sopb) {+  grpc_metadata_batch b;++  b.list.head = NULL;+  /* Store away the last element of the list, so that in patch_metadata_ops+     we can reconstitute the list.+     We can't do list building here as later incoming metadata may reallocate+     the underlying array. */+  b.list.tail = (void *)(gpr_intptr)buffer->count;+  b.garbage.head = b.garbage.tail = NULL;+  b.deadline = buffer->deadline;+  buffer->deadline = gpr_inf_future;++  grpc_sopb_add_metadata(sopb, b);+}++void grpc_chttp2_incoming_metadata_buffer_swap(+    grpc_chttp2_incoming_metadata_buffer *a,+    grpc_chttp2_incoming_metadata_buffer *b) {+  GPR_SWAP(grpc_chttp2_incoming_metadata_buffer, *a, *b);+}++void grpc_incoming_metadata_buffer_move_to_referencing_sopb(+    grpc_chttp2_incoming_metadata_buffer *src,+    grpc_chttp2_incoming_metadata_buffer *dst, grpc_stream_op_buffer *sopb) {+  size_t delta;+  size_t i;+  if (gpr_time_cmp(dst->deadline, gpr_inf_future) == 0) {+    dst->deadline = src->deadline;+  } else if (gpr_time_cmp(src->deadline, gpr_inf_future) != 0) {+    dst->deadline = gpr_time_min(src->deadline, dst->deadline);+  }+","So why isn't the above block always dst->deadline = gpr_time_min(src->deadline, dst->deadline) ?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2149,33214373,2015-06-25T01:09:19Z,src/core/transport/chttp2/incoming_metadata.c,"@@ -0,0 +1,207 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/transport/chttp2/incoming_metadata.h""++#include <string.h>++#include ""src/core/transport/chttp2/internal.h""++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++void grpc_chttp2_incoming_metadata_buffer_init(+    grpc_chttp2_incoming_metadata_buffer *buffer) {+  buffer->deadline = gpr_inf_future;+}++void grpc_chttp2_incoming_metadata_buffer_destroy(+    grpc_chttp2_incoming_metadata_buffer *buffer) {+  gpr_free(buffer->elems);+}++void grpc_chttp2_incoming_metadata_buffer_add(+    grpc_chttp2_incoming_metadata_buffer *buffer, grpc_mdelem *elem) {+  if (buffer->capacity == buffer->count) {+    buffer->capacity = GPR_MAX(8, 2 * buffer->capacity);+    buffer->elems =+        gpr_realloc(buffer->elems, sizeof(*buffer->elems) * buffer->capacity);+  }+  buffer->elems[buffer->count++].md = elem;+}++void grpc_chttp2_incoming_metadata_buffer_set_deadline(+    grpc_chttp2_incoming_metadata_buffer *buffer, gpr_timespec deadline) {+  buffer->deadline = deadline;+}++void grpc_chttp2_incoming_metadata_live_op_buffer_end(+    grpc_chttp2_incoming_metadata_live_op_buffer *buffer) {+  gpr_free(buffer->elems);+  buffer->elems = NULL;+}++void grpc_chttp2_incoming_metadata_buffer_place_metadata_batch_into(+    grpc_chttp2_incoming_metadata_buffer *buffer, grpc_stream_op_buffer *sopb) {+  grpc_metadata_batch b;++  b.list.head = NULL;+  /* Store away the last element of the list, so that in patch_metadata_ops+     we can reconstitute the list.+     We can't do list building here as later incoming metadata may reallocate+     the underlying array. */+  b.list.tail = (void *)(gpr_intptr)buffer->count;+  b.garbage.head = b.garbage.tail = NULL;+  b.deadline = buffer->deadline;+  buffer->deadline = gpr_inf_future;++  grpc_sopb_add_metadata(sopb, b);+}++void grpc_chttp2_incoming_metadata_buffer_swap(+    grpc_chttp2_incoming_metadata_buffer *a,+    grpc_chttp2_incoming_metadata_buffer *b) {+  GPR_SWAP(grpc_chttp2_incoming_metadata_buffer, *a, *b);+}++void grpc_incoming_metadata_buffer_move_to_referencing_sopb(+    grpc_chttp2_incoming_metadata_buffer *src,+    grpc_chttp2_incoming_metadata_buffer *dst, grpc_stream_op_buffer *sopb) {+  size_t delta;+  size_t i;+  if (gpr_time_cmp(dst->deadline, gpr_inf_future) == 0) {+    dst->deadline = src->deadline;+  } else if (gpr_time_cmp(src->deadline, gpr_inf_future) != 0) {+    dst->deadline = gpr_time_min(src->deadline, dst->deadline);+  }++  if (src->count == 0) {+    return;+  }+  if (dst->count == 0) {+    grpc_chttp2_incoming_metadata_buffer_swap(src, dst);+    return;+  }+  delta = dst->count;+  if (dst->capacity < src->count + dst->count) {+    dst->capacity = GPR_MAX(dst->capacity * 2, src->count + dst->count);+    dst->elems = gpr_realloc(dst->elems, dst->capacity * sizeof(*dst->elems));+  }+  memcpy(dst->elems + dst->count, src->elems, src->count * sizeof(*src->elems));+  dst->count += src->count;+  for (i = 0; i < sopb->nops; i++) {+    if (sopb->ops[i].type != GRPC_OP_METADATA) continue;+    sopb->ops[i].data.metadata.list.tail =+        (void *)(delta + (gpr_intptr)sopb->ops[i].data.metadata.list.tail);+  }+}++void grpc_chttp2_incoming_metadata_buffer_postprocess_sopb_and_begin_live_op(+    grpc_chttp2_incoming_metadata_buffer *buffer, grpc_stream_op_buffer *sopb,+    grpc_chttp2_incoming_metadata_live_op_buffer *live_op_buffer) {+  grpc_stream_op *ops = sopb->ops;+  size_t nops = sopb->nops;+  size_t i;+  size_t j;+  size_t mdidx = 0;+  size_t last_mdidx;+  int found_metadata = 0;++  /* rework the array of metadata into a linked list, making use+     of the breadcrumbs we left in metadata batches during+     add_metadata_batch */+  for (i = 0; i < nops; i++) {+    grpc_stream_op *op = &ops[i];+    if (op->type != GRPC_OP_METADATA) continue;+    found_metadata = 1;+    /* we left a breadcrumb indicating where the end of this list is,+       and since we add sequentially, we know from the end of the last+       segment where this segment begins */+    last_mdidx = (size_t)(gpr_intptr)(op->data.metadata.list.tail);+    GPR_ASSERT(last_mdidx > mdidx);+    GPR_ASSERT(last_mdidx <= buffer->count);+    /* turn the array into a doubly linked list */+    op->data.metadata.list.head = &buffer->elems[mdidx];+    op->data.metadata.list.tail = &buffer->elems[last_mdidx - 1];+    for (j = mdidx + 1; j < last_mdidx; j++) {+      buffer->elems[j].prev = &buffer->elems[j - 1];+      buffer->elems[j - 1].next = &buffer->elems[j];+    }+    buffer->elems[mdidx].prev = NULL;+    buffer->elems[last_mdidx - 1].next = NULL;+    /* track where we're up to */+    mdidx = last_mdidx;+  }+  if (found_metadata) {+    live_op_buffer->elems = buffer->elems;+    if (mdidx != buffer->count) {+      /* we have a partially read metadata batch still in incoming_metadata */+      size_t new_count = buffer->count - mdidx;+      size_t copy_bytes = sizeof(*buffer->elems) * new_count;+      GPR_ASSERT(mdidx < buffer->count);+      buffer->elems = gpr_malloc(copy_bytes);+      memcpy(live_op_buffer->elems + mdidx, buffer->elems, copy_bytes);+      buffer->count = buffer->capacity = new_count;+    } else {+      buffer->elems = NULL;+      buffer->count = 0;+      buffer->capacity = 0;+    }+  }+}++#if 0+void grpc_chttp2_parsing_add_metadata_batch(+    grpc_chttp2_transport_parsing *transport_parsing,+    grpc_chttp2_stream_parsing *stream_parsing) {+  grpc_metadata_batch b;++  b.list.head = NULL;+  /* Store away the last element of the list, so that in patch_metadata_ops+     we can reconstitute the list.+     We can't do list building here as later incoming metadata may reallocate+     the underlying array. */+  b.list.tail = (void *)(gpr_intptr)stream_parsing->incoming_metadata_count;+  b.garbage.head = b.garbage.tail = NULL;+  b.deadline = stream_parsing->incoming_deadline;+  stream_parsing->incoming_deadline = gpr_inf_future;++  grpc_sopb_add_metadata(&stream_parsing->data_parser.incoming_sopb, b);+}+#endif++#if 0+static void patch_metadata_ops(grpc_chttp2_stream_global *stream_global,+                               grpc_chttp2_stream_parsing *stream_parsing) {+}+#endif","I'll delete.On Wed, Jun 24, 2015, 3:00 PM Vijay Pai notifications@github.com wrote:> In src/core/transport/chttp2/incoming_metadata.c> https://github.com/grpc/grpc/pull/2149#discussion_r33202004:> > > -     We can't do list building here as later incoming metadata may reallocate> > -     the underlying array. */> > -  b.list.tail = (void *)(gpr_intptr)stream_parsing->incoming_metadata_count;> > -  b.garbage.head = b.garbage.tail = NULL;> > -  b.deadline = stream_parsing->incoming_deadline;> > -  stream_parsing->incoming_deadline = gpr_inf_future;> >   +> > -  grpc_sopb_add_metadata(&stream_parsing->data_parser.incoming_sopb, b);> >   +}> >   +#endif> >   +> >   +#if 0> >   +static void patch_metadata_ops(grpc_chttp2_stream_global *stream_global,> > -                               grpc_chttp2_stream_parsing *stream_parsing) {> >   +}> >   +#endif> > Would you like me to review the ""#if 0"" code, or would you rather just> delete it? If it is intended to be used later, I can review it, but if it> is a vestige, please delete.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2149/files#r33202004.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2134,33252703,2015-06-25T13:14:33Z,src/python/src/setup.py,"@@ -56,15 +78,47 @@ if not ""darwin"" in sys.platform:     _EXTENSION_LIBRARIES += ('rt',) -_EXTENSION_MODULE = _core.Extension(-    'grpc._adapter._c', sources=list(_EXTENSION_SOURCES),++_C_EXTENSION_MODULE = _core.Extension(+    'grpc._adapter._c', sources=list(_C_EXTENSION_SOURCES),     include_dirs=list(_EXTENSION_INCLUDE_DIRECTORIES),     libraries=list(_EXTENSION_LIBRARIES),-    )+)+_C_EXTENSION_MODULES = [_C_EXTENSION_MODULE]+++def cython_extensions(package_names, module_names, include_dirs, libraries,+                      build_with_cython=False):+  file_extension = 'pyx' if build_with_cython else 'c'+  package_files = [name.replace('.', '/') + '/__init__.' + file_extension+                   for name in package_names]+  module_files = [name.replace('.', '/') + '.' + file_extension+                  for name in module_names]+  extensions = [+      _extension.Extension(+          name=module_names[i], sources=[module_files[i]],+          include_dirs=include_dirs, libraries=libraries+      ) for i in range(len(module_names))","""for module_name, module_file in zip(module_names, module_files)"" is an option here. Otherwise since you don't use module_files except inside this list comprehension, consider eliminating it and just using an expression in the ""sources="" part of this?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2149,33279531,2015-06-25T17:13:11Z,src/core/transport/chttp2/internal.h,"@@ -0,0 +1,652 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CORE_CHTTP2_INTERNAL_H+#define GRPC_INTERNAL_CORE_CHTTP2_INTERNAL_H++#include ""src/core/transport/transport_impl.h""+#include ""src/core/iomgr/endpoint.h""+#include ""src/core/transport/chttp2/frame.h""+#include ""src/core/transport/chttp2/frame_data.h""+#include ""src/core/transport/chttp2/frame_goaway.h""+#include ""src/core/transport/chttp2/frame_ping.h""+#include ""src/core/transport/chttp2/frame_rst_stream.h""+#include ""src/core/transport/chttp2/frame_settings.h""+#include ""src/core/transport/chttp2/frame_window_update.h""+#include ""src/core/transport/chttp2/hpack_parser.h""+#include ""src/core/transport/chttp2/incoming_metadata.h""+#include ""src/core/transport/chttp2/stream_encoder.h""+#include ""src/core/transport/chttp2/stream_map.h""++typedef struct grpc_chttp2_transport grpc_chttp2_transport;+typedef struct grpc_chttp2_stream grpc_chttp2_stream;++/* streams are kept in various linked lists depending on what things need to+   happen to them... this enum labels each list */+typedef enum {+  GRPC_CHTTP2_LIST_ALL_STREAMS,+  GRPC_CHTTP2_LIST_READ_WRITE_STATE_CHANGED,+  GRPC_CHTTP2_LIST_WRITABLE,+  GRPC_CHTTP2_LIST_WRITING,+  GRPC_CHTTP2_LIST_WRITTEN,+  GRPC_CHTTP2_LIST_WRITABLE_WINDOW_UPDATE,+  GRPC_CHTTP2_LIST_PARSING_SEEN,+  GRPC_CHTTP2_LIST_CLOSED_WAITING_FOR_PARSING,+  GRPC_CHTTP2_LIST_INCOMING_WINDOW_UPDATED,+  /** streams that are waiting to start because there are too many concurrent+      streams on the connection */+  GRPC_CHTTP2_LIST_WAITING_FOR_CONCURRENCY,+  STREAM_LIST_COUNT /* must be last */+} grpc_chttp2_stream_list_id;++/* deframer state for the overall http2 stream of bytes */+typedef enum {+  /* prefix: one entry per http2 connection prefix byte */+  DTS_CLIENT_PREFIX_0 = 0,+  DTS_CLIENT_PREFIX_1,+  DTS_CLIENT_PREFIX_2,+  DTS_CLIENT_PREFIX_3,+  DTS_CLIENT_PREFIX_4,+  DTS_CLIENT_PREFIX_5,+  DTS_CLIENT_PREFIX_6,+  DTS_CLIENT_PREFIX_7,+  DTS_CLIENT_PREFIX_8,+  DTS_CLIENT_PREFIX_9,+  DTS_CLIENT_PREFIX_10,+  DTS_CLIENT_PREFIX_11,+  DTS_CLIENT_PREFIX_12,+  DTS_CLIENT_PREFIX_13,+  DTS_CLIENT_PREFIX_14,+  DTS_CLIENT_PREFIX_15,+  DTS_CLIENT_PREFIX_16,+  DTS_CLIENT_PREFIX_17,+  DTS_CLIENT_PREFIX_18,+  DTS_CLIENT_PREFIX_19,+  DTS_CLIENT_PREFIX_20,+  DTS_CLIENT_PREFIX_21,+  DTS_CLIENT_PREFIX_22,+  DTS_CLIENT_PREFIX_23,+  /* frame header byte 0... */+  /* must follow from the prefix states */+  DTS_FH_0,+  DTS_FH_1,+  DTS_FH_2,+  DTS_FH_3,+  DTS_FH_4,+  DTS_FH_5,+  DTS_FH_6,+  DTS_FH_7,+  /* ... frame header byte 8 */+  DTS_FH_8,+  /* inside a http2 frame */+  DTS_FRAME+} grpc_chttp2_deframe_transport_state;++typedef enum {+  WRITE_STATE_OPEN,+  WRITE_STATE_QUEUED_CLOSE,+  WRITE_STATE_SENT_CLOSE+} grpc_chttp2_write_state;++typedef enum {+  DONT_SEND_CLOSED = 0,+  SEND_CLOSED,+  SEND_CLOSED_WITH_RST_STREAM+} grpc_chttp2_send_closed;++typedef struct {+  grpc_chttp2_stream *head;+  grpc_chttp2_stream *tail;+} grpc_chttp2_stream_list;++typedef struct {+  grpc_chttp2_stream *next;+  grpc_chttp2_stream *prev;+} grpc_chttp2_stream_link;++typedef enum {+  GRPC_CHTTP2_ERROR_STATE_NONE,+  GRPC_CHTTP2_ERROR_STATE_SEEN,+  GRPC_CHTTP2_ERROR_STATE_NOTIFIED+} grpc_chttp2_error_state;++/* We keep several sets of connection wide parameters */+typedef enum {+  /* The settings our peer has asked for (and we have acked) */+  PEER_SETTINGS = 0,+  /* The settings we'd like to have */+  LOCAL_SETTINGS,+  /* The settings we've published to our peer */+  SENT_SETTINGS,+  /* The settings the peer has acked */+  ACKED_SETTINGS,+  NUM_SETTING_SETS+} grpc_chttp2_setting_set;++/* Outstanding ping request data */+typedef struct grpc_chttp2_outstanding_ping {+  gpr_uint8 id[8];+  grpc_iomgr_closure *on_recv;+  struct grpc_chttp2_outstanding_ping *next;+  struct grpc_chttp2_outstanding_ping *prev;+} grpc_chttp2_outstanding_ping;++typedef struct {+  /** data to write next write */+  gpr_slice_buffer qbuf;+  /** queued callbacks */+  grpc_iomgr_closure *pending_closures;++  /** window available for us to send to peer */+  gpr_uint32 outgoing_window;+  /** window available for peer to send to us - updated after parse */+  gpr_uint32 incoming_window;+  /** how much window would we like to have for incoming_window */+  gpr_uint32 connection_window_target;++  /** is this transport a client? */+  gpr_uint8 is_client;+  /** are the local settings dirty and need to be sent? */+  gpr_uint8 dirtied_local_settings;+  /** have local settings been sent? */+  gpr_uint8 sent_local_settings;+  /** bitmask of setting indexes to send out */+  gpr_uint32 force_send_settings;+  /** settings values */+  gpr_uint32 settings[NUM_SETTING_SETS][GRPC_CHTTP2_NUM_SETTINGS];++  /** has there been a connection level error, and have we notified+      anyone about it? */+  grpc_chttp2_error_state error_state;++  /** what is the next stream id to be allocated by this peer?+      copied to next_stream_id in parsing when parsing commences */+  gpr_uint32 next_stream_id;++  /** last received stream id */+  gpr_uint32 last_incoming_stream_id;++  /** pings awaiting responses */+  grpc_chttp2_outstanding_ping pings;+  /** next payload for an outgoing ping */+  gpr_uint64 ping_counter;++  /** concurrent stream count: updated when not parsing,+      so this is a strict over-estimation on the client */+  gpr_uint32 concurrent_stream_count;++  /** is there a goaway available? (boolean) */+  grpc_chttp2_error_state goaway_state;+  /** what is the debug text of the goaway? */+  gpr_slice goaway_text;+  /** what is the status code of the goaway? */+  grpc_status_code goaway_error;+} grpc_chttp2_transport_global;++typedef struct {+  /** data to write now */+  gpr_slice_buffer outbuf;+  /** hpack encoding */+  grpc_chttp2_hpack_compressor hpack_compressor;+  /** is this a client? */+  gpr_uint8 is_client;+} grpc_chttp2_transport_writing;++struct grpc_chttp2_transport_parsing {+  /** is this transport a client? (boolean) */+  gpr_uint8 is_client;++  /** were settings updated? */+  gpr_uint8 settings_updated;+  /** was a settings ack received? */+  gpr_uint8 settings_ack_received;+  /** was a goaway frame received? */+  gpr_uint8 goaway_received;++  /** initial window change */+  gpr_int64 initial_window_update;++  /** data to write later - after parsing */+  gpr_slice_buffer qbuf;+  /* metadata object cache */+  grpc_mdstr *str_grpc_timeout;+  /** parser for headers */+  grpc_chttp2_hpack_parser hpack_parser;+  /** simple one shot parsers */+  union {+    grpc_chttp2_window_update_parser window_update;+    grpc_chttp2_settings_parser settings;+    grpc_chttp2_ping_parser ping;+    grpc_chttp2_rst_stream_parser rst_stream;+  } simple;+  /** parser for goaway frames */+  grpc_chttp2_goaway_parser goaway_parser;++  /** window available for peer to send to us */+  gpr_uint32 incoming_window;+  gpr_uint32 incoming_window_delta;++  /** next stream id available at the time of beginning parsing */+  gpr_uint32 next_stream_id;+  gpr_uint32 last_incoming_stream_id;++  /* deframing */+  grpc_chttp2_deframe_transport_state deframe_state;+  gpr_uint8 incoming_frame_type;+  gpr_uint8 incoming_frame_flags;+  gpr_uint8 header_eof;+  gpr_uint32 expect_continuation_stream_id;+  gpr_uint32 incoming_frame_size;+  gpr_uint32 incoming_stream_id;++  /* active parser */+  void *parser_data;+  grpc_chttp2_stream_parsing *incoming_stream;+  grpc_chttp2_parse_error (*parser)(+      void *parser_user_data, grpc_chttp2_transport_parsing *transport_parsing,+      grpc_chttp2_stream_parsing *stream_parsing, gpr_slice slice, int is_last);++  /* received settings */+  gpr_uint32 settings[GRPC_CHTTP2_NUM_SETTINGS];++  /* goaway data */+  grpc_status_code goaway_error;+  gpr_uint32 goaway_last_stream_index;+  gpr_slice goaway_text;++  gpr_uint64 outgoing_window_update;++  /** pings awaiting responses */+  grpc_chttp2_outstanding_ping pings;+};++struct grpc_chttp2_transport {+  grpc_transport base; /* must be first */+  grpc_endpoint *ep;+  grpc_mdctx *metadata_context;+  gpr_refcount refs;++  gpr_mu mu;++  /** is the transport destroying itself? */+  gpr_uint8 destroying;+  /** has the upper layer closed the transport? */+  gpr_uint8 closed;++  /** is a thread currently writing */+  gpr_uint8 writing_active;+  /** is a thread currently parsing */+  gpr_uint8 parsing_active;++  /** is there a read request to the endpoint outstanding? */+  gpr_uint8 endpoint_reading;++  /** various lists of streams */+  grpc_chttp2_stream_list lists[STREAM_LIST_COUNT];++  /** global state for reading/writing */+  grpc_chttp2_transport_global global;+  /** state only accessible by the chain of execution that+      set writing_active=1 */+  grpc_chttp2_transport_writing writing;+  /** state only accessible by the chain of execution that+      set parsing_active=1 */+  grpc_chttp2_transport_parsing parsing;++  /** maps stream id to grpc_chttp2_stream objects;+      owned by the parsing thread when parsing */+  grpc_chttp2_stream_map parsing_stream_map;++  /** streams created by the client (possibly during parsing);+      merged with parsing_stream_map during unlock when no+      parsing is occurring */+  grpc_chttp2_stream_map new_stream_map;++  /** closure to execute writing */+  grpc_iomgr_closure writing_action;+  /** closure to start reading from the endpoint */+  grpc_iomgr_closure reading_action;++  /** address to place a newly accepted stream - set and unset by+      grpc_chttp2_parsing_accept_stream; used by init_stream to+      publish the accepted server stream */+  grpc_chttp2_stream **accepting_stream;++  struct {+    /** is a thread currently performing channel callbacks */+    gpr_uint8 executing;+    /** transport channel-level callback */+    const grpc_transport_callbacks *cb;+    /** user data for cb calls */+    void *cb_user_data;+    /** closure for notifying transport closure */+    grpc_iomgr_closure notify_closed;+  } channel_callback;++#if 0+  /* basic state management - what are we doing at the moment? */+  gpr_uint8 reading;+  /** are we calling back any grpc_transport_op completion events */+  gpr_uint8 calling_back_ops;+  gpr_uint8 destroying;+  gpr_uint8 closed;++  /* stream indexing */+  gpr_uint32 next_stream_id;++  /* window management */+  gpr_uint32 outgoing_window_update;++  /* state for a stream that's not yet been created */+  grpc_stream_op_buffer new_stream_sopb;++  /* stream ops that need to be destroyed, but outside of the lock */+  grpc_stream_op_buffer nuke_later_sopb;++  /* pings */+  gpr_int64 ping_counter;+++  grpc_chttp2_stream **accepting_stream;++#endif+};++typedef struct {+  /** HTTP2 stream id for this stream, or zero if one has not been assigned */+  gpr_uint32 id;++  grpc_iomgr_closure *send_done_closure;+  grpc_iomgr_closure *recv_done_closure;++  /** window available for us to send to peer */+  gpr_int64 outgoing_window;+  /** window available for peer to send to us - updated after parse */+  gpr_uint32 incoming_window;+  /** stream ops the transport user would like to send */+  grpc_stream_op_buffer *outgoing_sopb;+  /** when the application requests writes be closed, the write_closed is+      'queued'; when the close is flow controlled into the send path, we are+      'sending' it; when the write has been performed it is 'sent' */+  grpc_chttp2_write_state write_state;+  /** is this stream closed (boolean) */+  gpr_uint8 read_closed;+  /** has this stream been cancelled? (boolean) */+  gpr_uint8 cancelled;+  grpc_status_code cancelled_status;+  /** have we told the upper layer that this stream is cancelled? */+  gpr_uint8 published_cancelled;+  /** is this stream in the stream map? (boolean) */+  gpr_uint8 in_stream_map;++  /** stream state already published to the upper layer */+  grpc_stream_state published_state;+  /** address to publish next stream state to */+  grpc_stream_state *publish_state;+  /** pointer to sop buffer to fill in with new stream ops */+  grpc_stream_op_buffer *publish_sopb;+  grpc_stream_op_buffer incoming_sopb;++  /** incoming metadata */+  grpc_chttp2_incoming_metadata_buffer incoming_metadata;+  grpc_chttp2_incoming_metadata_live_op_buffer outstanding_metadata;+} grpc_chttp2_stream_global;++typedef struct {+  /** HTTP2 stream id for this stream, or zero if one has not been assigned */+  gpr_uint32 id;+  /** sops that have passed flow control to be written */+  grpc_stream_op_buffer sopb;+  /** how strongly should we indicate closure with the next write */+  grpc_chttp2_send_closed send_closed;+} grpc_chttp2_stream_writing;++struct grpc_chttp2_stream_parsing {+  /** HTTP2 stream id for this stream, or zero if one has not been assigned */+  gpr_uint32 id;+  /** has this stream received a close */+  gpr_uint8 received_close;+  /** saw a rst_stream */+  gpr_uint8 saw_rst_stream;+  /** incoming_window has been reduced by this much during parsing */+  gpr_uint32 incoming_window_delta;+  /** window available for peer to send to us */+  gpr_uint32 incoming_window;+  /** parsing state for data frames */+  grpc_chttp2_data_parser data_parser;+  /** reason give to rst_stream */+  gpr_uint32 rst_stream_reason;+  /* amount of window given */+  gpr_uint64 outgoing_window_update;++  /** incoming metadata */+  grpc_chttp2_incoming_metadata_buffer incoming_metadata;++  /*+    grpc_linked_mdelem *incoming_metadata;+    size_t incoming_metadata_count;+    size_t incoming_metadata_capacity;+    grpc_linked_mdelem *old_incoming_metadata;+    gpr_timespec incoming_deadline;+  */+};++struct grpc_chttp2_stream {+  grpc_chttp2_stream_global global;+  grpc_chttp2_stream_writing writing;+  grpc_chttp2_stream_parsing parsing;++  grpc_chttp2_stream_link links[STREAM_LIST_COUNT];+  gpr_uint8 included[STREAM_LIST_COUNT];++#if 0+  gpr_uint32 outgoing_window_update;+  gpr_uint8 cancelled;++  grpc_stream_state callback_state;+  grpc_stream_op_buffer callback_sopb;+#endif+};",Is the above #if 0 content deprecated or not yet ready?,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/2219,33298298,2015-06-25T20:03:56Z,src/core/iomgr/pollset_windows.c,"@@ -55,11 +55,15 @@ void grpc_pollset_init(grpc_pollset *pollset) { void grpc_pollset_shutdown(grpc_pollset *pollset,                            void (*shutdown_done)(void *arg),                            void *shutdown_done_arg) {-  grpc_pollset_kick(pollset);+  gpr_mu_lock(&pollset->mu);+  pollset->shutting_down = 1;+  gpr_mu_unlock(&pollset->mu);+  gpr_cv_broadcast(&pollset->cv);   shutdown_done(shutdown_done_arg); }  void grpc_pollset_destroy(grpc_pollset *pollset) {+  memset(pollset, 0, sizeof(*pollset));",Tired. This belongs to init.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2230,33396038,2015-06-26T21:07:14Z,src/core/surface/call.c,"@@ -40,6 +40,7 @@ #include ""src/core/surface/byte_buffer_queue.h"" #include ""src/core/surface/channel.h"" #include ""src/core/surface/completion_queue.h""+#include <grpc/census.h>",We can't include census related code directly in this one. It creates a physical dependency and I want to be able to disable census completely without recompiling.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2243,33487594,2015-06-29T17:15:14Z,src/python/src/grpc/_cython/_cygrpc/credentials.pyx,"@@ -0,0 +1,203 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from grpc._cython._cygrpc cimport records+++cdef class ClientCredentials:++  def __cinit__(self):+    self.c_credentials = NULL+    self.c_ssl_pem_key_cert_pair.private_key = NULL+    self.c_ssl_pem_key_cert_pair.certificate_chain = NULL+    self.references = []++  @property+  def is_valid(self):+    return self.c_credentials != NULL++  @staticmethod",I think all the static methods on both classes in this module should instead be module-scope functions. Classes shouldn't be used as namespaces; only place behaviors inside classes when they must be placed there in order to function as they need to function.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2243,33488608,2015-06-29T17:25:01Z,tools/run_tests/run_tests.py,"@@ -191,19 +191,25 @@ def __init__(self):       self._tests = json.load(f)    def test_specs(self, config, travis):-    modules = [config.job_spec(['tools/run_tests/run_python.sh', '-m',","How much of these build-related configuration changes can be split out into a different changelist? Can we change the building and tooling code first and then add the code in a later change which makes a much small (something like ""adding a single value to an array"") tool change?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2243,33490437,2015-06-29T17:42:20Z,tools/run_tests/run_tests.py,"@@ -191,19 +191,25 @@ def __init__(self):       self._tests = json.load(f)    def test_specs(self, config, travis):-    modules = [config.job_spec(['tools/run_tests/run_python.sh', '-m',",I don't believe that the tooling changes are particularly large and don't think we'd be gaining much from separating them out into more commits (n.b. https://github.com/grpc/grpc/commit/06e259a2ff4ca9844312a893cf515bdaa6ab5be5).,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/2255,33656236,2015-07-01T08:01:53Z,src/core/tsi/ssl_transport_security.c,"@@ -49,6 +49,8 @@ #include <openssl/x509.h> #include <openssl/x509v3.h> +#include ""src/core/support/env.h""","First off, thanks for this patch. I'm aware of the issue and I appreciate you taking a stab at it (I've been a bit overloaded lately...).However this introduces a dependency on a non-public include. I'd really like to keep TSI (transport security interface) free of any GRPC deps, GPR (Google Portable Runtime) public includes are OK since I think GPR will eventually ship solo but I'm trying hard not to depend on anything else. Also, an environment variable is not necessarily a good way to configure the need for a client cert on the server side. You may have 2 different ports in your application, one that needs mutual auth, and the other that does not (or 2 services running on the same process).I have thought about this and the right way to do this is to either.- Add an `enforce_mutual_auth` parameter in `grpc_ssl_server_credentials_create` (https://github.com/grpc/grpc/blob/master/include/grpc/grpc_security.h#L171) and plumb it through TSI basically reusing some code that you have here. This would cause an API breakage but I think that it's OK as we have not frozen the APIs yet.- use the brand new `grpc_call_auth_context` API and fail if the client is not authenticated. @yang-g is working on the C++ wrapping of this interface.Let me know what you think and thanks again.",
13110866,gcondra,https://api.github.com/repos/grpc/grpc/pulls/2255,33658095,2015-07-01T08:32:24Z,src/core/tsi/ssl_transport_security.c,"@@ -49,6 +49,8 @@ #include <openssl/x509.h> #include <openssl/x509v3.h> +#include ""src/core/support/env.h""","Agree that an env variable is suboptimal, and with the concern about being overloaded ;).I don't have a good understanding of all of the constraints that are on this code, but I can take a stab at the enforce_mutual_auth approach. No promises, per the above comment.Regarding the proposed approach, it won't scale to other kinds of change to the underlying TLS connection- not sure if you consider that a plus or a minus. I prefer it over the alternative simply because it seems to be something that could be implemented and in on a short timescale.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/2255,33660069,2015-07-01T08:58:24Z,src/core/tsi/ssl_transport_security.c,"@@ -49,6 +49,8 @@ #include <openssl/x509.h> #include <openssl/x509v3.h> +#include ""src/core/support/env.h""",Re:ciphersuites. Do you mean the use of an environment variable here?https://github.com/grpc/grpc/blob/master/src/core/security/security_connector.c#L74,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2208,33693574,2015-07-01T15:59:06Z,src/core/surface/secure_channel_create.c,"@@ -31,177 +31,144 @@  *  */ -#include ""src/core/iomgr/sockaddr.h""- #include <grpc/grpc.h>  #include <stdlib.h> #include <string.h> -#include ""src/core/channel/census_filter.h""+#include <grpc/support/alloc.h>+ #include ""src/core/channel/channel_args.h"" #include ""src/core/channel/client_channel.h""-#include ""src/core/channel/client_setup.h""-#include ""src/core/channel/connected_channel.h"" #include ""src/core/channel/http_client_filter.h""-#include ""src/core/iomgr/resolve_address.h""+#include ""src/core/client_config/resolver_registry.h"" #include ""src/core/iomgr/tcp_client.h"" #include ""src/core/security/auth_filters.h"" #include ""src/core/security/credentials.h"" #include ""src/core/security/secure_transport_setup.h""-#include ""src/core/support/string.h"" #include ""src/core/surface/channel.h""-#include ""src/core/surface/client.h"" #include ""src/core/transport/chttp2_transport.h""-#include <grpc/grpc_security.h>-#include <grpc/support/alloc.h>-#include <grpc/support/log.h>-#include <grpc/support/string_util.h>-#include <grpc/support/sync.h>-#include <grpc/support/useful.h> #include ""src/core/tsi/transport_security_interface.h"" -typedef struct setup setup;--/* A single setup request (started via initiate) */ typedef struct {-  grpc_client_setup_request *cs_request;-  setup *setup;-  /* Resolved addresses, or null if resolution not yet completed. */-  grpc_resolved_addresses *resolved;-  /* which address in resolved should we pick for the next connection attempt */-  size_t resolved_index;-} request;+  grpc_connector base;+  gpr_refcount refs; -struct setup {   grpc_channel_security_connector *security_connector;-  const char *target;-  grpc_transport_setup_callback setup_callback;-  void *setup_user_data;-}; -static int maybe_try_next_resolved(request *r);+  grpc_iomgr_closure *notify;+  grpc_connect_in_args args;+  grpc_connect_out_args *result;+} connector; -static void done(request *r, int was_successful) {-  grpc_client_setup_request_finish(r->cs_request, was_successful);-  if (r->resolved) {-    grpc_resolved_addresses_destroy(r->resolved);+static void connector_ref(grpc_connector *con) {+  connector *c = (connector *)con;+  gpr_ref(&c->refs);+}++static void connector_unref(grpc_connector *con) {+  connector *c = (connector *)con;+  if (gpr_unref(&c->refs)) {+    gpr_free(c);   }-  gpr_free(r); } -static void on_secure_transport_setup_done(void *rp,+static void on_secure_transport_setup_done(void *arg,                                            grpc_security_status status,                                            grpc_endpoint *secure_endpoint) {-  request *r = rp;+  connector *c = arg;+  grpc_iomgr_closure *notify;   if (status != GRPC_SECURITY_OK) {     gpr_log(GPR_ERROR, ""Secure transport setup failed with error %d."", status);-    done(r, 0);-  } else if (grpc_client_setup_cb_begin(r->cs_request,-                                        ""on_secure_transport_setup_done"")) {-    grpc_create_chttp2_transport(-        r->setup->setup_callback, r->setup->setup_user_data,-        grpc_client_setup_get_channel_args(r->cs_request), secure_endpoint,-        NULL, 0, grpc_client_setup_get_mdctx(r->cs_request), 1);-    grpc_client_setup_cb_end(r->cs_request, ""on_secure_transport_setup_done"");-    done(r, 1);+    memset(c->result, 0, sizeof(*c->result));   } else {-    done(r, 0);+    c->result->transport =+        grpc_create_chttp2_transport(c->args.channel_args, secure_endpoint,+                                     NULL, 0, c->args.metadata_context, 1);+    c->result->filters = gpr_malloc(sizeof(grpc_channel_filter *) * 2);+    c->result->filters[0] = &grpc_client_auth_filter;+    c->result->filters[1] = &grpc_http_client_filter;+    c->result->num_filters = 2;   }+  notify = c->notify;+  c->notify = NULL;+  grpc_iomgr_add_callback(notify); } -/* connection callback: tcp is either valid, or null on error */-static void on_connect(void *rp, grpc_endpoint *tcp) {-  request *r = rp;--  if (!grpc_client_setup_request_should_continue(r->cs_request,-                                                 ""on_connect.secure"")) {-    if (tcp) {-      grpc_endpoint_shutdown(tcp);-      grpc_endpoint_destroy(tcp);-    }-    done(r, 0);-    return;-  }--  if (!tcp) {-    if (!maybe_try_next_resolved(r)) {-      done(r, 0);-      return;-    } else {-      return;-    }+static void connected(void *arg, grpc_endpoint *tcp) {+  connector *c = arg;+  grpc_iomgr_closure *notify;+  if (tcp != NULL) {+    grpc_setup_secure_transport(&c->security_connector->base, tcp,+                                on_secure_transport_setup_done, c);   } else {-    grpc_setup_secure_transport(&r->setup->security_connector->base, tcp,-                                on_secure_transport_setup_done, r);+    memset(c->result, 0, sizeof(*c->result));+    notify = c->notify;+    c->notify = NULL;+    grpc_iomgr_add_callback(notify);   } } -/* attempt to connect to the next available resolved address */-static int maybe_try_next_resolved(request *r) {-  grpc_resolved_address *addr;-  if (!r->resolved) return 0;-  if (r->resolved_index == r->resolved->naddrs) return 0;-  addr = &r->resolved->addrs[r->resolved_index++];-  grpc_tcp_client_connect(-      on_connect, r, grpc_client_setup_get_interested_parties(r->cs_request),-      (struct sockaddr *)&addr->addr, addr->len,-      grpc_client_setup_request_deadline(r->cs_request));-  return 1;+static void connector_connect(grpc_connector *con,+                              const grpc_connect_in_args *args,+                              grpc_connect_out_args *result,+                              grpc_iomgr_closure *notify) {+  connector *c = (connector *)con;+  GPR_ASSERT(c->notify == NULL);+  GPR_ASSERT(notify->cb);+  c->notify = notify;+  c->args = *args;+  c->result = result;+  grpc_tcp_client_connect(connected, c, args->interested_parties, args->addr,+                          args->addr_len, args->deadline); } -/* callback for when our target address has been resolved */-static void on_resolved(void *rp, grpc_resolved_addresses *resolved) {-  request *r = rp;+static const grpc_connector_vtable connector_vtable = {+    connector_ref, connector_unref, connector_connect}; -  /* if we're not still the active request, abort */-  if (!grpc_client_setup_request_should_continue(r->cs_request,-                                                 ""on_resolved.secure"")) {-    if (resolved) {-      grpc_resolved_addresses_destroy(resolved);-    }-    done(r, 0);-    return;-  }+typedef struct {+  grpc_subchannel_factory base;+  gpr_refcount refs;+  grpc_mdctx *mdctx;+  grpc_channel_args *merge_args;+  grpc_channel_security_connector *security_connector;+} subchannel_factory; -  if (!resolved) {-    done(r, 0);-    return;-  } else {-    r->resolved = resolved;-    r->resolved_index = 0;-    if (!maybe_try_next_resolved(r)) {-      done(r, 0);-    }-  }+static void subchannel_factory_ref(grpc_subchannel_factory *scf) {+  subchannel_factory *f = (subchannel_factory *)scf;+  gpr_ref(&f->refs); } -static void initiate_setup(void *sp, grpc_client_setup_request *cs_request) {-  request *r = gpr_malloc(sizeof(request));-  r->setup = sp;-  r->cs_request = cs_request;-  r->resolved = NULL;-  r->resolved_index = 0;-  /* TODO(klempner): Make grpc_resolve_address respect deadline */-  grpc_resolve_address(r->setup->target, ""https"", on_resolved, r);+static void subchannel_factory_unref(grpc_subchannel_factory *scf) {+  subchannel_factory *f = (subchannel_factory *)scf;+  if (gpr_unref(&f->refs)) {+    grpc_mdctx_unref(f->mdctx);+    gpr_free(f);+  } } -static void done_setup(void *sp) {-  setup *s = sp;-  gpr_free((void *)s->target);-  grpc_security_connector_unref(&s->security_connector->base);-  gpr_free(s);+static grpc_subchannel *subchannel_factory_create_subchannel(+    grpc_subchannel_factory *scf, grpc_subchannel_args *args) {+  subchannel_factory *f = (subchannel_factory *)scf;+  connector *c = gpr_malloc(sizeof(*c));+  grpc_channel_args *final_args =+      grpc_channel_args_merge(args->args, f->merge_args);+  grpc_subchannel *s;+  memset(c, 0, sizeof(*c));+  c->base.vtable = &connector_vtable;+  c->security_connector = f->security_connector;","Added the refcount.The target name is guaranteed to be the same - this factory will be invoked with different resolutions of that name (different IP addresses for example). If that needs to change, we'll likely be back here making changes (other, more substantial changes).",
13110866,gcondra,https://api.github.com/repos/grpc/grpc/pulls/2255,33708624,2015-07-01T18:29:44Z,src/core/tsi/ssl_transport_security.c,"@@ -49,6 +49,8 @@ #include <openssl/x509.h> #include <openssl/x509v3.h> +#include ""src/core/support/env.h""","YepOn Wed, Jul 1, 2015 at 1:58 AM, jboeuf notifications@github.com wrote:> In src/core/tsi/ssl_transport_security.c> https://github.com/grpc/grpc/pull/2255#discussion_r33660069:> > > @@ -49,6 +49,8 @@> >  #include <openssl/x509.h>> >  #include <openssl/x509v3.h>> > > > +#include ""src/core/support/env.h""> > Re:ciphersuites. Do you mean the use of an environment variable here?> > https://github.com/grpc/grpc/blob/master/src/core/security/security_connector.c#L74> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2255/files#r33660069.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2208,33726507,2015-07-01T21:25:31Z,src/core/channel/client_channel.c,"@@ -183,192 +138,373 @@ static void handle_op_after_cancellation(grpc_call_element *elem,   } } -static void cc_start_transport_op(grpc_call_element *elem,-                                  grpc_transport_op *op) {+typedef struct {+  grpc_iomgr_closure closure;+  grpc_call_element *elem;+} waiting_call;++static void perform_transport_stream_op(grpc_call_element *elem,+                                        grpc_transport_stream_op *op,+                                        int continuation);++static void continue_with_pick(void *arg, int iomgr_success) {+  waiting_call *wc = arg;+  call_data *calld = wc->elem->call_data;+  perform_transport_stream_op(wc->elem, &calld->waiting_op, 1);+  gpr_free(wc);+}++static void add_to_lb_policy_wait_queue_locked_state_config(+    grpc_call_element *elem) {+  channel_data *chand = elem->channel_data;+  waiting_call *wc = gpr_malloc(sizeof(*wc));+  grpc_iomgr_closure_init(&wc->closure, continue_with_pick, wc);+  wc->elem = elem;+  wc->closure.next = chand->waiting_for_config_closures;+  chand->waiting_for_config_closures = &wc->closure;+}++static int is_empty(void *p, int len) {+  char *ptr = p;+  int i;+  for (i = 0; i < len; i++) {+    if (ptr[i] != 0) return 0;+  }+  return 1;+}++static void started_call(void *arg, int iomgr_success) {+  call_data *calld = arg;+  grpc_transport_stream_op op;+  int have_waiting;++  gpr_mu_lock(&calld->mu_state);+  if (calld->state == CALL_CANCELLED && calld->subchannel_call != NULL) {+    memset(&op, 0, sizeof(op));+    op.cancel_with_status = GRPC_STATUS_CANCELLED;+    gpr_mu_unlock(&calld->mu_state);+    grpc_subchannel_call_process_op(calld->subchannel_call, &op);+  } else if (calld->state == CALL_WAITING_FOR_CALL) {+    have_waiting = !is_empty(&calld->waiting_op, sizeof(calld->waiting_op));+    if (calld->subchannel_call != NULL) {+      calld->state = CALL_ACTIVE;+      gpr_mu_unlock(&calld->mu_state);+      if (have_waiting) {+        grpc_subchannel_call_process_op(calld->subchannel_call,+                                        &calld->waiting_op);+      }+    } else {+      calld->state = CALL_CANCELLED;+      gpr_mu_unlock(&calld->mu_state);+      if (have_waiting) {+        handle_op_after_cancellation(calld->elem, &calld->waiting_op);+      }+    }+  } else {+    GPR_ASSERT(calld->state == CALL_CANCELLED);+  }+}++static void picked_target(void *arg, int iomgr_success) {+  call_data *calld = arg;+  grpc_pollset *pollset;++  if (calld->picked_channel == NULL) {+    /* treat this like a cancellation */+    calld->waiting_op.cancel_with_status = GRPC_STATUS_UNAVAILABLE;+    perform_transport_stream_op(calld->elem, &calld->waiting_op, 1);+  } else {+    gpr_mu_lock(&calld->mu_state);+    if (calld->state == CALL_CANCELLED) {+      gpr_mu_unlock(&calld->mu_state);+      handle_op_after_cancellation(calld->elem, &calld->waiting_op);+    } else {+      GPR_ASSERT(calld->state == CALL_WAITING_FOR_PICK);+      calld->state = CALL_WAITING_FOR_CALL;+      pollset = calld->waiting_op.bind_pollset;+      gpr_mu_unlock(&calld->mu_state);+      grpc_iomgr_closure_init(&calld->async_setup_task, started_call, calld);+      grpc_subchannel_create_call(calld->picked_channel, pollset,+                                  &calld->subchannel_call,+                                  &calld->async_setup_task);+    }+  }+}++static void pick_target(grpc_lb_policy *lb_policy, call_data *calld) {+  grpc_metadata_batch *initial_metadata;+  grpc_transport_stream_op *op = &calld->waiting_op;++  GPR_ASSERT(op->bind_pollset);+  GPR_ASSERT(op->send_ops);+  GPR_ASSERT(op->send_ops->nops >= 1);+  GPR_ASSERT(op->send_ops->ops[0].type == GRPC_OP_METADATA);+  initial_metadata = &op->send_ops->ops[0].data.metadata;++  grpc_iomgr_closure_init(&calld->async_setup_task, picked_target, calld);+  grpc_lb_policy_pick(lb_policy, op->bind_pollset, initial_metadata,+                      &calld->picked_channel, &calld->async_setup_task);+}++static grpc_iomgr_closure *merge_into_waiting_op(+    grpc_call_element *elem, grpc_transport_stream_op *new_op) {+  call_data *calld = elem->call_data;+  grpc_iomgr_closure *consumed_op = NULL;+  grpc_transport_stream_op *waiting_op = &calld->waiting_op;+  GPR_ASSERT((waiting_op->send_ops == NULL) != (new_op->send_ops == NULL) ||+             waiting_op->send_ops == NULL);+  GPR_ASSERT((waiting_op->recv_ops == NULL) != (new_op->recv_ops == NULL) ||+             waiting_op->recv_ops == NULL);+  if (new_op->send_ops != NULL) {+    waiting_op->send_ops = new_op->send_ops;+    waiting_op->is_last_send = new_op->is_last_send;+    waiting_op->on_done_send = new_op->on_done_send;+  }+  if (new_op->recv_ops != NULL) {+    waiting_op->recv_ops = new_op->recv_ops;+    waiting_op->recv_state = new_op->recv_state;+    waiting_op->on_done_recv = new_op->on_done_recv;+  }+  if (new_op->on_consumed != NULL) {+    if (waiting_op->on_consumed != NULL) {+      consumed_op = waiting_op->on_consumed;+    }+    waiting_op->on_consumed = new_op->on_consumed;+  }+  if (new_op->cancel_with_status != GRPC_STATUS_OK) {+    waiting_op->cancel_with_status = new_op->cancel_with_status;+  }+  return consumed_op;+}++static void perform_transport_stream_op(grpc_call_element *elem,+                                        grpc_transport_stream_op *op,+                                        int continuation) {   call_data *calld = elem->call_data;   channel_data *chand = elem->channel_data;-  grpc_call_element *child_elem;-  grpc_transport_op waiting_op;+  grpc_subchannel_call *subchannel_call;+  grpc_lb_policy *lb_policy;+  grpc_transport_stream_op op2;+  grpc_iomgr_closure *consumed_op = NULL;   GPR_ASSERT(elem->filter == &grpc_client_channel_filter);   GRPC_CALL_LOG_OP(GPR_INFO, elem, op); -  gpr_mu_lock(&chand->mu);+  gpr_mu_lock(&calld->mu_state);   switch (calld->state) {     case CALL_ACTIVE:-      child_elem = grpc_child_call_get_top_element(calld->s.active.child_call);-      gpr_mu_unlock(&chand->mu);-      child_elem->filter->start_transport_op(child_elem, op);+      GPR_ASSERT(!continuation);+      subchannel_call = calld->subchannel_call;+      gpr_mu_unlock(&calld->mu_state);+      grpc_subchannel_call_process_op(subchannel_call, op);       break;-    case CALL_CREATED:-      if (op->cancel_with_status != GRPC_STATUS_OK) {-        calld->state = CALL_CANCELLED;-        gpr_mu_unlock(&chand->mu);-        handle_op_after_cancellation(elem, op);-      } else {-        calld->state = CALL_WAITING;-        calld->s.waiting_op.bind_pollset = NULL;-        if (chand->active_child) {-          /* channel is connected - use the connected stack */-          if (prepare_activate(elem, chand->active_child)) {-            gpr_mu_unlock(&chand->mu);-            /* activate the request (pass it down) outside the lock */-            complete_activate(elem, op);-          } else {-            gpr_mu_unlock(&chand->mu);+    case CALL_CANCELLED:+      gpr_mu_unlock(&calld->mu_state);+      handle_op_after_cancellation(elem, op);+      break;+    case CALL_WAITING_FOR_SEND:+      GPR_ASSERT(!continuation);+      consumed_op = merge_into_waiting_op(elem, op);+      if (!calld->waiting_op.send_ops &&+          calld->waiting_op.cancel_with_status == GRPC_STATUS_OK) {+        gpr_mu_unlock(&calld->mu_state);+        break;+      }+      *op = calld->waiting_op;+      memset(&calld->waiting_op, 0, sizeof(calld->waiting_op));+      continuation = 1;+    /* fall through */+    case CALL_WAITING_FOR_CONFIG:+    case CALL_WAITING_FOR_PICK:+    case CALL_WAITING_FOR_CALL:+      if (!continuation) {+        if (op->cancel_with_status != GRPC_STATUS_OK) {+          calld->state = CALL_CANCELLED;+          op2 = calld->waiting_op;+          memset(&calld->waiting_op, 0, sizeof(calld->waiting_op));+          if (op->on_consumed) {+            calld->waiting_op.on_consumed = op->on_consumed;+            op->on_consumed = NULL;+          } else if (op2.on_consumed) {+            calld->waiting_op.on_consumed = op2.on_consumed;+            op2.on_consumed = NULL;           }+          gpr_mu_unlock(&calld->mu_state);+          handle_op_after_cancellation(elem, op);+          handle_op_after_cancellation(elem, &op2);         } else {-          /* check to see if we should initiate a connection (if we're not-             already),-             but don't do so until outside the lock to avoid re-entrancy-             problems if-             the callback is immediate */-          int initiate_transport_setup = 0;-          if (!chand->transport_setup_initiated) {-            chand->transport_setup_initiated = 1;-            initiate_transport_setup = 1;-          }-          /* add this call to the waiting set to be resumed once we have a child-             channel stack, growing the waiting set if needed */-          if (chand->waiting_child_count == chand->waiting_child_capacity) {-            chand->waiting_child_capacity =-                GPR_MAX(chand->waiting_child_capacity * 2, 8);-            chand->waiting_children = gpr_realloc(-                chand->waiting_children,-                chand->waiting_child_capacity * sizeof(call_data *));-          }-          calld->s.waiting_op = *op;-          chand->waiting_children[chand->waiting_child_count++] = calld;-          grpc_transport_setup_add_interested_party(chand->transport_setup,-                                                    op->bind_pollset);-          gpr_mu_unlock(&chand->mu);--          /* finally initiate transport setup if needed */-          if (initiate_transport_setup) {-            grpc_transport_setup_initiate(chand->transport_setup);-          }+          consumed_op = merge_into_waiting_op(elem, op);+          gpr_mu_unlock(&calld->mu_state);         }+        break;       }-      break;-    case CALL_WAITING:+    /* fall through */+    case CALL_CREATED:       if (op->cancel_with_status != GRPC_STATUS_OK) {-        waiting_op = calld->s.waiting_op;-        remove_waiting_child(chand, calld);         calld->state = CALL_CANCELLED;-        gpr_mu_unlock(&chand->mu);-        handle_op_after_cancellation(elem, &waiting_op);+        gpr_mu_unlock(&calld->mu_state);         handle_op_after_cancellation(elem, op);       } else {-        GPR_ASSERT((calld->s.waiting_op.send_ops == NULL) !=-                   (op->send_ops == NULL));-        GPR_ASSERT((calld->s.waiting_op.recv_ops == NULL) !=-                   (op->recv_ops == NULL));-        if (op->send_ops) {-          calld->s.waiting_op.send_ops = op->send_ops;-          calld->s.waiting_op.is_last_send = op->is_last_send;-          calld->s.waiting_op.on_done_send = op->on_done_send;-        }-        if (op->recv_ops) {-          calld->s.waiting_op.recv_ops = op->recv_ops;-          calld->s.waiting_op.recv_state = op->recv_state;-          calld->s.waiting_op.on_done_recv = op->on_done_recv;-        }-        gpr_mu_unlock(&chand->mu);-        if (op->on_consumed) {-          op->on_consumed->cb(op->on_consumed->cb_arg, 0);+        calld->waiting_op = *op;++        if (op->send_ops == NULL) {+          /* need to have some send ops before we can select the+             lb target */+          calld->state = CALL_WAITING_FOR_SEND;+          gpr_mu_unlock(&calld->mu_state);+        } else {+          gpr_mu_lock(&chand->mu_config);+          lb_policy = chand->lb_policy;+          if (lb_policy) {+            GRPC_LB_POLICY_REF(lb_policy, ""pick"");+            gpr_mu_unlock(&chand->mu_config);+            calld->state = CALL_WAITING_FOR_PICK;+            gpr_mu_unlock(&calld->mu_state);++            pick_target(lb_policy, calld);++            GRPC_LB_POLICY_UNREF(lb_policy, ""pick"");+          } else if (chand->resolver != NULL) {+            calld->state = CALL_WAITING_FOR_CONFIG;+            add_to_lb_policy_wait_queue_locked_state_config(elem);+            gpr_mu_unlock(&chand->mu_config);+            gpr_mu_unlock(&calld->mu_state);+          } else {+            calld->state = CALL_CANCELLED;+            gpr_mu_unlock(&chand->mu_config);+            gpr_mu_unlock(&calld->mu_state);+            handle_op_after_cancellation(elem, op);+          }         }       }       break;-    case CALL_CANCELLED:-      gpr_mu_unlock(&chand->mu);-      handle_op_after_cancellation(elem, op);-      break;   }++  if (consumed_op != NULL) {+    consumed_op->cb(consumed_op->cb_arg, 1);+  }+}++static void cc_start_transport_stream_op(grpc_call_element *elem,+                                         grpc_transport_stream_op *op) {+  perform_transport_stream_op(elem, op, 0);+}++static void cc_on_config_changed(void *arg, int iomgr_success) {+  channel_data *chand = arg;+  grpc_lb_policy *lb_policy = NULL;+  grpc_lb_policy *old_lb_policy;+  grpc_resolver *old_resolver;+  grpc_iomgr_closure *wakeup_closures = NULL;++  if (chand->incoming_configuration != NULL) {+    lb_policy = grpc_client_config_get_lb_policy(chand->incoming_configuration);+    GRPC_LB_POLICY_REF(lb_policy, ""channel"");++    grpc_client_config_unref(chand->incoming_configuration);+  }++  chand->incoming_configuration = NULL;++  gpr_mu_lock(&chand->mu_config);+  old_lb_policy = chand->lb_policy;+  chand->lb_policy = lb_policy;+  if (lb_policy != NULL || chand->resolver == NULL /* disconnected */) {+    wakeup_closures = chand->waiting_for_config_closures;+    chand->waiting_for_config_closures = NULL;+  }+  gpr_mu_unlock(&chand->mu_config);++  if (old_lb_policy) {+    GRPC_LB_POLICY_UNREF(old_lb_policy, ""channel"");+  }++  gpr_mu_lock(&chand->mu_config);",Added some explanation in channel_data,
13110866,gcondra,https://api.github.com/repos/grpc/grpc/pulls/2255,33728067,2015-07-01T21:43:29Z,src/core/tsi/ssl_transport_security.c,"@@ -49,6 +49,8 @@ #include <openssl/x509.h> #include <openssl/x509v3.h> +#include ""src/core/support/env.h""","Is there any reason not to use the pem_root_certs here as the flag? Ascurrently documented:""""""- pem_roots_cert is the NULL-terminated string containing the PEM  encoding of   the client root certificates. This parameter may be NULL if the server  does   not want the client to be authenticated with SSL.  """"""Thus, if the pem_roots_cert is non-NULL, the user wishes clients to beauthenticated with SSL, and we should force verification.On Wed, Jul 1, 2015 at 11:29 AM, Geremy Condra gcondra@google.com wrote:> Yep> > On Wed, Jul 1, 2015 at 1:58 AM, jboeuf notifications@github.com wrote:> > > In src/core/tsi/ssl_transport_security.c> > https://github.com/grpc/grpc/pull/2255#discussion_r33660069:> > > > > @@ -49,6 +49,8 @@> > >  #include <openssl/x509.h>> > >  #include <openssl/x509v3.h>> > > > > > +#include ""src/core/support/env.h""> > > > Re:ciphersuites. Do you mean the use of an environment variable here?> > > > https://github.com/grpc/grpc/blob/master/src/core/security/security_connector.c#L74> > > > —> > Reply to this email directly or view it on GitHub> > https://github.com/grpc/grpc/pull/2255/files#r33660069.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2283,33731277,2015-07-01T22:24:40Z,test/cpp/qps/server_async.cc,"@@ -316,8 +316,25 @@ class AsyncQpsServerTest : public Server {   TestService::AsyncService async_service_;   std::forward_list<ServerRpcContext *> contexts_; -  std::mutex shutdown_mutex_;-  bool shutdown_;+  class PerThreadShutdownState {+   public:+    PerThreadShutdownState() : shutdown_(false) {}++    bool shutdown() const {+      std::lock_guard<std::mutex> lock(mutex_);+      return shutdown_;+    }++    void set_shutdown() {+      std::lock_guard<std::mutex> lock(mutex_);+      shutdown_ = true;+    }++   private:+    mutable std::mutex mutex_;",I am ready to accept this use of const/mutable as long as we are generally very conservative in using this pattern.,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/2313,34086819,2015-07-07T20:33:30Z,src/core/security/client_auth_filter.c,"@@ -199,8 +200,28 @@ static void auth_start_transport_op(grpc_call_element *elem,   channel_data *chand = elem->channel_data;   grpc_linked_mdelem *l;   size_t i;+  grpc_client_security_context* sec_ctx = NULL; -  /* TODO(jboeuf): write the call auth context. */+  if (calld->security_context_set == 0) {+    calld->security_context_set = 1;+    GPR_ASSERT(op->context);+    if (op->context[GRPC_CONTEXT_SECURITY].value == NULL) {+      op->context[GRPC_CONTEXT_SECURITY].value =+          grpc_client_security_context_create();+      op->context[GRPC_CONTEXT_SECURITY].destroy =+          grpc_client_security_context_destroy;+    }+    sec_ctx = op->context[GRPC_CONTEXT_SECURITY].value;+    if (sec_ctx->auth_context == NULL) {+      sec_ctx->auth_context =+          GRPC_AUTH_CONTEXT_REF(chand->security_connector->base.auth_context,+                                ""client_auth_filter"");+    } else {+      sec_ctx->auth_context->chained =",`chained` is an internal member of the auth_context. You should not have to ref it here.,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/2313,34091307,2015-07-07T21:12:18Z,src/cpp/common/insecure_auth_context.h,"@@ -0,0 +1,59 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CPP_COMMON_INSECURE_AUTH_CONTEXT_H+#define GRPC_INTERNAL_CPP_COMMON_INSECURE_AUTH_CONTEXT_H++#include <grpc++/auth_context.h>++namespace grpc {++class InsecureAuthContext : public AuthContext {","I think that renaming this to `EmptyAuthContext` would be better. Also, you may actually get rid of this class entirely if you had the insecure `CreateAuthContext` function return you an empty `shared_ptr`... Your choice.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2319,34116104,2015-07-08T05:02:17Z,src/core/support/string.c,"@@ -174,6 +188,27 @@ char *gpr_strjoin(const char **strs, size_t nstrs, size_t *final_length) {   return out; } +static void do_nothing(void *ignored) {}+gpr_slice_buffer *gpr_strsplit(const char *str, const char *sep) {","what about:``` cvoid gpr_strsplit(const char *str, const char *sep, gpr_slice_buffer *dst);```or maybe one better:``` cvoid gpr_slice_split(gpr_slice str, gpr_slice sep, gpr_slice_buffer *dst);```... the latter could do this without any allocations whatsoever, and given that metadata comes in the form of slices...",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2320,34156573,2015-07-08T14:54:20Z,include/grpc++/server_builder.h,"@@ -98,9 +111,18 @@ class ServerBuilder {     int* selected_port;   }; +  typedef std::unique_ptr<grpc::string> HostString;+  template <class T> struct NamedService {+    explicit NamedService(T* s) : service(s) {}+    explicit NamedService(const grpc::string& h, T *s)","Updated based on feedbackOn Tue, Jul 7, 2015 at 10:44 PM Yang Gao notifications@github.com wrote:> In include/grpc++/server_builder.h> https://github.com/grpc/grpc/pull/2320#discussion_r34117367:> > > @@ -98,9 +111,18 @@ class ServerBuilder {> >      int\* selected_port;> >    };> > -  typedef std::unique_ptrgrpc::string HostString;> > -  template <class T> struct NamedService {> > -    explicit NamedService(T\* s) : service(s) {}> > -    explicit NamedService(const grpc::string& h, T *s)> > This does not need explicit?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2320/files#r34117367.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/2313,34214139,2015-07-09T00:37:36Z,src/core/security/client_auth_filter.c,"@@ -199,8 +200,28 @@ static void auth_start_transport_op(grpc_call_element *elem,   channel_data *chand = elem->channel_data;   grpc_linked_mdelem *l;   size_t i;+  grpc_client_security_context* sec_ctx = NULL; -  /* TODO(jboeuf): write the call auth context. */+  if (calld->security_context_set == 0) {+    calld->security_context_set = 1;+    GPR_ASSERT(op->context);+    if (op->context[GRPC_CONTEXT_SECURITY].value == NULL) {+      op->context[GRPC_CONTEXT_SECURITY].value =+          grpc_client_security_context_create();+      op->context[GRPC_CONTEXT_SECURITY].destroy =+          grpc_client_security_context_destroy;+    }+    sec_ctx = op->context[GRPC_CONTEXT_SECURITY].value;+    if (sec_ctx->auth_context == NULL) {+      sec_ctx->auth_context =+          GRPC_AUTH_CONTEXT_REF(chand->security_connector->base.auth_context,+                                ""client_auth_filter"");+    } else {+      sec_ctx->auth_context->chained =","OK I understand now. Sorry about that... In this case, on the client side, the auth_context that will always be the one from the connector (i.e. transport security). We have chained contexts in general for a context issued from metadata processing containing a (chained) context from transport security which happens on the server side. So I would simplify the code here to (starting line 214):```sec_ctx = op->context[GRPC_CONTEXT_SECURITY].value;GRPC_AUTH_CONTEXT_UNREF(sec_ctx->auth_context, ""client auth filter"");sec_ctx->auth_context = GRPC_AUTH_CONTEXT_REF(chand->security_connector->base.auth_context, ""client_auth_filter"");```Does that make sense? BTW, thanks much for tackling this part of the implementation that I should have done.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2347,34378720,2015-07-10T17:54:46Z,src/core/surface/completion_queue.h,"@@ -39,6 +39,17 @@ #include ""src/core/iomgr/pollset.h"" #include <grpc/grpc.h> +typedef struct grpc_cq_completion {+  /** user supplied tag */+  void *tag;+  /** done callback - called when this queue element is no longer+      needed by the completion queue */+  void (*done)(void *done_arg, struct grpc_cq_completion *c);+  void *done_arg;+  /** next pointer; low bit is used to indicate success or not */","It's possibly a little premature, but generally:- we need to keep these things pre-allocated on grpc_call- grpc_call is way too big- let's get the obvious stuff done as we're doing workI expect some future work to get ride of the done() member here at some point also.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2367,34404828,2015-07-10T23:30:57Z,tools/jenkins/run_linuxbrew.sh,"@@ -0,0 +1,55 @@+#!/bin/bash+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#+# This script is invoked by Jenkins and triggers a test run of+# linuxbrew installation of a selected language+set -ex++sha1=$(sha1sum tools/jenkins/grpc_linuxbrew/Dockerfile | cut -f1 -d\ )+DOCKER_IMAGE_NAME=grpc_linuxbrew_$sha1++docker build -t $DOCKER_IMAGE_NAME tools/jenkins/grpc_linuxbrew++supported=""python nodejs ruby php""","list of what's supported will be determined by a condition in jenkins job settings, so there's probably not need to check explicitly here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2460,34725082,2015-07-15T20:29:32Z,BUILD,"@@ -703,6 +702,7 @@ cc_library(     ""include/grpc++/status.h"",     ""include/grpc++/status_code_enum.h"",     ""include/grpc++/stream.h"",+    ""include/grpc++/thread_pool.h"",","AgreeOn Wed, Jul 15, 2015 at 1:11 PM Vijay Pai notifications@github.com wrote:> In BUILD https://github.com/grpc/grpc/pull/2460#discussion_r34723063:> > > @@ -703,6 +702,7 @@ cc_library(> >      ""include/grpc++/status.h"",> >      ""include/grpc++/status_code_enum.h"",> >      ""include/grpc++/stream.h"",> > -    ""include/grpc++/thread_pool.h"",> > I will do so, because I think it's a good idea to maintain consistency.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2460/files#r34723063.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2413,34733204,2015-07-15T21:42:11Z,test/cpp/interop/server_helper.h,"@@ -43,6 +44,16 @@ namespace testing {  std::shared_ptr<ServerCredentials> CreateInteropServerCredentials(); +class InteropContextInspector {+ public:+  InteropContextInspector (const ::grpc::ServerContext& context);","I'll ensure the merge window is short :)On Wed, Jul 15, 2015 at 2:12 PM David G. Quintas notifications@github.comwrote:> In test/cpp/interop/server_helper.h> https://github.com/grpc/grpc/pull/2413#discussion_r34729917:> > > @@ -43,6 +44,16 @@ namespace testing {> > > >  std::shared_ptr<ServerCredentials> CreateInteropServerCredentials();> > > > +class InteropContextInspector {> > - public:> > -  InteropContextInspector (const ::grpc::ServerContext& context);> > Done. Note that msan complains about context_ not being used. It'll be> used alright in a following PR.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2413/files#r34729917.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2413,34733975,2015-07-15T21:50:29Z,test/cpp/interop/server_helper.h,"@@ -43,6 +44,16 @@ namespace testing {  std::shared_ptr<ServerCredentials> CreateInteropServerCredentials(); +class InteropContextInspector {+ public:+  InteropContextInspector (const ::grpc::ServerContext& context);","Actually, lemme introduce a placeholder method to be removed once an actually useful one takes its place to appease the gods of msan.",
10135698,a11r,https://api.github.com/repos/grpc/grpc/pulls/1888,34739984,2015-07-15T23:03:48Z,src/core/transport/transport.h,"@@ -72,6 +72,12 @@ typedef struct grpc_transport_stream_op {    grpc_stream_op_buffer *recv_ops;   grpc_stream_state *recv_state;+  /** The number of bytes this peer is currently prepared to receive.++      Bytes offered are used to replenish per-stream flow control windows.+      Offers are not retractable: if 5 bytes are offered and no bytes are read,+        a later offer of 3 bytes still implies that 5 have been offered. */","This comment seems to address an implied API to update the max_recv_bytes rather than the semantics of this state variable. Here is my proposed rephrasing:The number of bytes this peer is currently prepared to receive.These bytes will be eventually used to replenish per-stream flow control windows. Alternately, you can reuse the corresponding comment from src/core/transport/chttp2/internal.h",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2473,34843471,2015-07-16T22:07:03Z,src/core/client_config/uri_parser.c,"@@ -99,7 +99,7 @@ grpc_uri *grpc_uri_parse(const char *uri_text, int suppress_errors) {   if (uri_text[scheme_end + 1] == '/' && uri_text[scheme_end + 2] == '/') {     authority_begin = scheme_end + 3;     for (i = authority_begin; uri_text[i] != 0; i++) {-      if (uri_text[i] == '/') {+      if (uri_text[i] == '/' && authority_end == -1) {","Wouldn't it be better to put the `&& authority_end == -1` clause in the for loop, to make its termination condition `uri_text[i] != 0 && authority_end == -1`?",
10135698,a11r,https://api.github.com/repos/grpc/grpc/pulls/2460,34855565,2015-07-17T01:24:50Z,include/grpc++/fixed_size_thread_pool.h,"@@ -45,10 +45,10 @@  namespace grpc { -class ThreadPool GRPC_FINAL : public ThreadPoolInterface {+class FixedSizeThreadPool GRPC_FINAL : public ThreadPoolInterface {  public:-  explicit ThreadPool(int num_threads);-  ~ThreadPool();+  explicit FixedSizeThreadPool(int num_threads);+  ~FixedSizeThreadPool();    void ScheduleCallback(const std::function<void()>& callback) GRPC_OVERRIDE;","What do you think of renaming ScheduleCallback() to Add(), to be consistent with other threadpools at google?I know this is not touched in this PR, but now that we are making this into a public API, it might be a good time to clean up names ..",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2460,34859078,2015-07-17T03:01:55Z,include/grpc++/fixed_size_thread_pool.h,"@@ -45,10 +45,10 @@  namespace grpc { -class ThreadPool GRPC_FINAL : public ThreadPoolInterface {+class FixedSizeThreadPool GRPC_FINAL : public ThreadPoolInterface {  public:-  explicit ThreadPool(int num_threads);-  ~ThreadPool();+  explicit FixedSizeThreadPool(int num_threads);+  ~FixedSizeThreadPool();    void ScheduleCallback(const std::function<void()>& callback) GRPC_OVERRIDE;","I'm good with itOn Thu, Jul 16, 2015, 6:25 PM Abhishek Kumar notifications@github.comwrote:> In include/grpc++/fixed_size_thread_pool.h> https://github.com/grpc/grpc/pull/2460#discussion_r34855565:> > >   public:> > -  explicit ThreadPool(int num_threads);> > -  ~ThreadPool();> > -  explicit FixedSizeThreadPool(int num_threads);> > -  ~FixedSizeThreadPool();> >   > >   void ScheduleCallback(const std::function<void()>& callback) GRPC_OVERRIDE;> > What do you think of renaming ScheduleCallback() to Add(), to be> consistent with other threadpools at google?> I know this is not touched in this PR, but now that we are making this> into a public API, it might be a good time to clean up names ..> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2460/files#r34855565.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2135,34917433,2015-07-17T18:26:09Z,src/core/channel/compress_filter.c,"@@ -0,0 +1,317 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <assert.h>+#include <string.h>++#include <grpc/compression.h>+#include <grpc/support/log.h>+#include <grpc/support/slice_buffer.h>++#include ""src/core/channel/compress_filter.h""+#include ""src/core/channel/channel_args.h""+#include ""src/core/compression/message_compress.h""++typedef struct call_data {+  gpr_slice_buffer slices;",Can you add some doc strings for the fields in this struct and in channel_data,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2370,34948384,2015-07-18T14:55:20Z,src/python/src/grpc/_links/_transmission_test.py,"@@ -94,7 +94,12 @@ def create_service_completion(self):     return _intermediary_low.Code.OK, 'An exuberant test ""details"" message!'    def assertMetadataEqual(self, original_metadata, transmitted_metadata):","The ""equal"" part of this method name is now a falsehood and will have to be changed. How about ""assertMetadataTransmitted""?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2370,34948501,2015-07-18T15:06:46Z,src/python/src/grpc/_links/_transmission_test.py,"@@ -94,7 +94,12 @@ def create_service_completion(self):     return _intermediary_low.Code.OK, 'An exuberant test ""details"" message!'    def assertMetadataEqual(self, original_metadata, transmitted_metadata):-    self.assertSequenceEqual(original_metadata, transmitted_metadata)+    # we need to filter out any additional metadata added in transmitted_metadata+    # since implementations are allowed to add to what is sent (in any position)+    keys, _ = zip(*original_metadata)","I'm not yet convinced that this check is correct. Consider the application supplying metadata""a"": ""1""""b"": ""2""and the runtime adding additional metadata""b"": ""3"".Won't the assertSequenceEqual call raise an exception in that case? Shouldn't this method instead return without raising an exception?Am I right in thinking that the logic for this method should be ""verify that the key-value pairs in original_metadata are a subset of the key-value pairs in transmitted_metadata and that they appear in the same order relative to one another notwithstanding any other pairs inserted among them""?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2370,34954361,2015-07-19T03:43:36Z,src/python/src/grpc/_links/_transmission_test.py,"@@ -94,7 +94,12 @@ def create_service_completion(self):     return _intermediary_low.Code.OK, 'An exuberant test ""details"" message!'    def assertMetadataEqual(self, original_metadata, transmitted_metadata):-    self.assertSequenceEqual(original_metadata, transmitted_metadata)+    # we need to filter out any additional metadata added in transmitted_metadata+    # since implementations are allowed to add to what is sent (in any position)+    keys, _ = zip(*original_metadata)",Yeah you're likely right... the check here is slightly off.I was trying for something roughly Pythonic that would give a nice failure message should invariants not hold (since I seem to remember a conversation some time ago that that was a worthy thing for Python tests).Is there a nice idiomatic way of writing such a comparison? Or should I open-code it? Or do we add a comment that the test is slightly flawed but should do the right thing under reasonably expected conditions?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2530,34972508,2015-07-20T07:30:46Z,include/grpc++/channel_arguments.h,"@@ -57,11 +57,10 @@ class ChannelArguments {   // grpc specific channel argument setters   // Set target name override for SSL host name checking.   void SetSslTargetNameOverride(const grpc::string& name);-  // TODO(yangg) add flow control options+  // TODO(yangg) add flow control optionsc",accidental edit?,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/2555,35116745,2015-07-21T15:36:29Z,tools/jenkins/run_distribution.sh,"@@ -66,26 +66,77 @@ if [ ""$platform"" == ""linux"" ]; then elif [ ""$platform"" == ""macos"" ]; then    if [ ""$dist_channel"" == ""homebrew"" ]; then-    which brew # TODO: for debug, can be removed later-    brew list -l-    dir=/tmp/homebrew-test-$language-    rm -rf $dir-    mkdir -p $dir-    git clone https://github.com/Homebrew/homebrew.git $dir-    cd $dir-    # TODO: Uncomment these when the general structure of the script is verified-    # PATH=$dir/bin:$PATH brew tap homebrew/dupes-    # PATH=$dir/bin:$PATH brew install zlib-    # PATH=$dir/bin:$PATH brew install openssl-    # PATH=$dir/bin:$PATH brew tap grpc/grpc-    # PATH=$dir/bin:$PATH brew install --without-python google-protobuf-    # PATH=$dir/bin:$PATH brew install grpc-    PATH=$dir/bin:$PATH brew list -l+    # system installed homebrew, don't interfere     brew list -l++    # Set up temp directories for test installation of homebrew+    brew_root=/tmp/homebrew-test-$language+    rm -rf $brew_root+    mkdir -p $brew_root+    git clone https://github.com/Homebrew/homebrew.git $brew_root++    # Install grpc via homebrew+    #+    # The temp $PATH env variable makes sure we are operating at the right copy of+    # temp homebrew installation, and do not interfere with the system's main brew+    # installation.+    #+    # It's a bit non-ideal as we duplicate most of homebrew-grpc/script/install+    # logic here but as the Jenkins macos instance has some different user/root+    # privileges so spelling things out here might be cleaner.+    cd $brew_root+    PATH=$brew_root/bin:$PATH brew tap homebrew/dupes+    PATH=$brew_root/bin:$PATH brew install zlib+    PATH=$brew_root/bin:$PATH brew install openssl+    PATH=$brew_root/bin:$PATH brew tap grpc/grpc+    PATH=$brew_root/bin:$PATH brew install --without-python google-protobuf+    PATH=$brew_root/bin:$PATH brew install grpc+    PATH=$brew_root/bin:$PATH brew list -l++    # Install per-language modules/extensions on top of core grpc+    #+    # If a command below needs root access, the binary had been added to+    # /etc/sudoers. This step needs to be repeated if we add more mac instances+    # to our jenkins project.+    #+    # Examples (lines that needed to be added to /etc/sudoers):+    # + Defaults        env_keep += ""CFLAGS CXXFLAGS LDFLAGS enable_grpc""+    # + jenkinsnode1 ALL=(ALL) NOPASSWD: /usr/bin/pecl, /usr/local/bin/pip,+    # +   /usr/local/bin/npm+    case $language in+      *core*) ;;+      *python*)+        sudo CFLAGS=-I$brew_root/include LDFLAGS=-L$brew_root/lib pip install grpcio+        pip list | grep grpc+        echo 'y' | sudo pip uninstall grpcio+        ;;+      *nodejs*)+        sudo CXXFLAGS=-I$brew_root/include LDFLAGS=-L$brew_root/lib npm install --global grpc","npm should work without the `CXXFLAGS` and `LDFLAGS` now, as long as you use the `PATH` setting like above.",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/2555,35120263,2015-07-21T16:04:15Z,tools/jenkins/run_distribution.sh,"@@ -66,26 +66,77 @@ if [ ""$platform"" == ""linux"" ]; then elif [ ""$platform"" == ""macos"" ]; then    if [ ""$dist_channel"" == ""homebrew"" ]; then-    which brew # TODO: for debug, can be removed later-    brew list -l-    dir=/tmp/homebrew-test-$language-    rm -rf $dir-    mkdir -p $dir-    git clone https://github.com/Homebrew/homebrew.git $dir-    cd $dir-    # TODO: Uncomment these when the general structure of the script is verified-    # PATH=$dir/bin:$PATH brew tap homebrew/dupes-    # PATH=$dir/bin:$PATH brew install zlib-    # PATH=$dir/bin:$PATH brew install openssl-    # PATH=$dir/bin:$PATH brew tap grpc/grpc-    # PATH=$dir/bin:$PATH brew install --without-python google-protobuf-    # PATH=$dir/bin:$PATH brew install grpc-    PATH=$dir/bin:$PATH brew list -l+    # system installed homebrew, don't interfere     brew list -l++    # Set up temp directories for test installation of homebrew+    brew_root=/tmp/homebrew-test-$language+    rm -rf $brew_root+    mkdir -p $brew_root+    git clone https://github.com/Homebrew/homebrew.git $brew_root++    # Install grpc via homebrew+    #+    # The temp $PATH env variable makes sure we are operating at the right copy of+    # temp homebrew installation, and do not interfere with the system's main brew+    # installation.+    #+    # It's a bit non-ideal as we duplicate most of homebrew-grpc/script/install+    # logic here but as the Jenkins macos instance has some different user/root+    # privileges so spelling things out here might be cleaner.+    cd $brew_root+    PATH=$brew_root/bin:$PATH brew tap homebrew/dupes+    PATH=$brew_root/bin:$PATH brew install zlib+    PATH=$brew_root/bin:$PATH brew install openssl+    PATH=$brew_root/bin:$PATH brew tap grpc/grpc+    PATH=$brew_root/bin:$PATH brew install --without-python google-protobuf+    PATH=$brew_root/bin:$PATH brew install grpc+    PATH=$brew_root/bin:$PATH brew list -l++    # Install per-language modules/extensions on top of core grpc+    #+    # If a command below needs root access, the binary had been added to+    # /etc/sudoers. This step needs to be repeated if we add more mac instances+    # to our jenkins project.+    #+    # Examples (lines that needed to be added to /etc/sudoers):+    # + Defaults        env_keep += ""CFLAGS CXXFLAGS LDFLAGS enable_grpc""+    # + jenkinsnode1 ALL=(ALL) NOPASSWD: /usr/bin/pecl, /usr/local/bin/pip,+    # +   /usr/local/bin/npm+    case $language in+      *core*) ;;+      *python*)+        sudo CFLAGS=-I$brew_root/include LDFLAGS=-L$brew_root/lib pip install grpcio+        pip list | grep grpc+        echo 'y' | sudo pip uninstall grpcio+        ;;+      *nodejs*)+        sudo CXXFLAGS=-I$brew_root/include LDFLAGS=-L$brew_root/lib npm install --global grpc","It still doesn't work, same error. There is indeed `pkg-config` under the `$brew_root/bin` directory.```Jenkinss-Mac-mini:~ jenkinsnode1$ echo $brew_root/tmp/homebrew-test-tempJenkinss-Mac-mini:~ jenkinsnode1$ sudo PATH=$brew_root/bin:$PATH npm install grpc-> grpc@0.10.0 install /Users/jenkinsnode1/node_modules/grpc> node-gyp rebuild  CXX(target) Release/obj.target/grpc/ext/byte_buffer.o../ext/byte_buffer.cc:38:10: fatal error: 'grpc/grpc.h' file not found#include ""grpc/grpc.h""         ^1 error generated.make: *** [Release/obj.target/grpc/ext/byte_buffer.o] Error 1```Also tried `export PATH=$brew_root/bin:$PATH` first.Perhaps the `grpc.pc` file has some problem?```Jenkinss-Mac-mini:~ jenkinsnode1$ pkg-config --list-allprotobuf-lite         Protocol Buffers - Google's Data Interchange Formatlibpng16              libpng - Loads and saves PNG filesgio-unix-2.0          GIO unix specific APIs - unix specific headers for glib I/O librarygio-2.0               GIO - glib I/O librarylibpcreposix          libpcreposix - PCREPosix - Posix compatible interface to libpcreprotobuf              Protocol Buffers - Google's Data Interchange FormatVariable 'prefix' not defined in '/private/tmp/homebrew-test-temp/lib/pkgconfig/grpc.pc'```",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/2560,35128986,2015-07-21T17:23:13Z,doc/naming.md,"@@ -0,0 +1,50 @@+#gRPC Naming and Discovery Support++## Overview++gRPC supports DNS as the default name-system. A number of alternative name-systems are used in various deployments. We propose an API that is general enough to support a range of name-systems and the corresponding syntax for names. The gRPC client library in various languages will provide a plugin mechanism so resolvers for different name-systems can be plugged in.++## Detailed Proposal++ A fully qualified, self contained name used for gRPC channel construction uses the syntax:++```scheme://authority/endpoint_name+```++Here, scheme indicates the name-system to be used. Example schemes to be supported include: ++* `dns`++* `zookeeper`++* `etcd`++Authority indicates some scheme-specific bootstrap information, e.g., for DNS, the authority may include the IP[:port] of the DNS server to use. Often, a DNS name may used as the authority, since the ability to resolve DNS names is already built into all gRPC client libraries.++Finally, the  endpoint_name indicates a concrete name to be looked up in a given name-system identified by the scheme and the authority. The syntax of endpoint name is dictated by the scheme in use.++### Plugins++The gRPC client library will switch on the scheme to pick the right resolver plugin and pass it the fully qualified name string.++Resolvers should be able to contact the authority and get a resolution that they return back to the gRPC client library. The returned contents include a list of IP:port, an optional config and optional auth config data to be used for channel authentication. The plugin API allows the resolvers to continuously watch an endpoint_name and return updated resolutions as needed. ++## Zookeeper++Apache [ZooKeeper](https://zookeeper.apache.org/) is a popular solution for building name-systems. Curator is a service discovery system built on to of ZooKeeper. We propose to organize names hierarchically as `/path/service/instance similar` to Apache Curator.","move ""similar"" out of the backticks",
10135698,a11r,https://api.github.com/repos/grpc/grpc/pulls/2131,35130268,2015-07-21T17:35:18Z,doc/interop-test-descriptions.md,"@@ -418,21 +420,32 @@ Procedure:       }     }     ```+The client attaches custom metadata with the following keys:+    ```+    ""x-grpc-test-echo-initial""+    or","The two keys refer to two different cases. In the first case the client is asking for initial metadata in the response stream , in the second case the client is asking for trailing metadata.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/2131,35228249,2015-07-22T15:49:07Z,doc/interop-test-descriptions.md,"@@ -509,21 +508,29 @@ Procedure:       }     }     ```+The client attaches custom metadata with the following keys and values:+    ```+    key: ""x-grpc-test-echo-initial"", value: ""test_initial_metadata_value""+    key: ""x-grpc-test-echo-trailing"", value: 0xababab",`0xababab` isn't ASCII and so isn't valid for that key. Were you wanting it to be a binary key?,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/2608,35256753,2015-07-22T20:02:34Z,tools/jenkins/run_distribution.sh,"@@ -134,12 +124,11 @@ elif [ ""$platform"" == ""macos"" ]; then         ;;     esac -    # clean up-    cd ~/ +    # Clean up     rm -rf $brew_root      # Make sure the system brew installation is still unaffected-    export PATH=$OLD_PATH+    export PATH=$ORIGINAL_PATH",I wanted to run `brew list -l` on the original brew installation at the end of this script just to make sure the system homebrew is still fine. So I need to reset my `$PATH` so that I find the original `brew` command.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2608,35257318,2015-07-22T20:07:57Z,tools/jenkins/run_distribution.sh,"@@ -134,12 +124,11 @@ elif [ ""$platform"" == ""macos"" ]; then         ;;     esac -    # clean up-    cd ~/ +    # Clean up     rm -rf $brew_root      # Make sure the system brew installation is still unaffected-    export PATH=$OLD_PATH+    export PATH=$ORIGINAL_PATH","ah, get it, makes sense. But you actually don't do any check, you just list the installed packages, so perhaps you should clarify the comment.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2549,35272690,2015-07-22T22:36:30Z,src/core/client_config/resolvers/zookeeper_resolver.c,"@@ -0,0 +1,452 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/client_config/resolvers/zookeeper_resolver.h""++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/string_util.h>++#include <grpc/grpc_zookeeper.h>+#include <zookeeper/zookeeper.h>++#include ""src/core/client_config/lb_policies/pick_first.h""+#include ""src/core/client_config/resolver_registry.h""+#include ""src/core/iomgr/resolve_address.h""+#include ""src/core/support/string.h""+#include ""src/core/json/json.h""++#define GRPC_MAX_ZOOKEEPER_BUFFER_SIZE 1024+#define GRPC_ZOOKEEPER_TIMEOUT 15000+#define GRPC_ZOOKEEPER_WATCH 0++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;+  /** name to resolve */+  char *name;+  /** subchannel factory */+  grpc_subchannel_factory *subchannel_factory;+  /** load balancing policy factory */+  grpc_lb_policy *(*lb_policy_factory)(grpc_subchannel **subchannels,+                                       size_t num_subchannels);++  /** mutex guarding the rest of the state */+  gpr_mu mu;+  /** are we currently resolving? */+  int resolving;+  /** which version of resolved_config have we published? */+  int published_version;+  /** which version of resolved_config is current? */+  int resolved_version;+  /** pending next completion, or NULL */+  grpc_iomgr_closure *next_completion;+  /** target config address for next completion */+  grpc_client_config **target_config;+  /** current (fully resolved) config */+  grpc_client_config *resolved_config;++  /** zookeeper handle */+  zhandle_t *zookeeper_handle;+  /** zookeeper resolved addresses */+  grpc_resolved_addresses * resolved_addrs;+  /** total number of addresses to be resolved */+  int resolved_total;+  /** resolved number of addresses */+  int resolved_num;+} zookeeper_resolver;++static void zookeeper_destroy(grpc_resolver *r);++static void zookeeper_start_resolving_locked(zookeeper_resolver *r);+static void zookeeper_maybe_finish_next_locked(zookeeper_resolver *r);++static void zookeeper_shutdown(grpc_resolver *r);+static void zookeeper_channel_saw_error(grpc_resolver *r,+                                  struct sockaddr *failing_address,+                                  int failing_address_len);+static void zookeeper_next(grpc_resolver *r, grpc_client_config **target_config,+                     grpc_iomgr_closure *on_complete);++static const grpc_resolver_vtable zookeeper_resolver_vtable = {+    zookeeper_destroy, zookeeper_shutdown, zookeeper_channel_saw_error, zookeeper_next};++static void zookeeper_shutdown(grpc_resolver *resolver) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (r->next_completion != NULL) {+    *r->target_config = NULL;+    grpc_iomgr_add_callback(r->next_completion);+    r->next_completion = NULL;+  }+  zookeeper_close(r->zookeeper_handle);+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_channel_saw_error(grpc_resolver *resolver, struct sockaddr *sa,+                                  int len) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (!r->resolving) {+    zookeeper_start_resolving_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_next(grpc_resolver *resolver,+                     grpc_client_config **target_config,+                     grpc_iomgr_closure *on_complete) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(!r->next_completion);+  r->next_completion = on_complete;+  r->target_config = target_config;+  if (r->resolved_version == 0 && !r->resolving) {+    zookeeper_start_resolving_locked(r);+  } else {+    zookeeper_maybe_finish_next_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_on_resolved(void *arg, grpc_resolved_addresses *addresses) {+  zookeeper_resolver *r = arg;+  grpc_client_config *config = NULL;+  grpc_subchannel **subchannels;+  grpc_subchannel_args args;+  grpc_lb_policy *lb_policy;+  size_t i;+  if (addresses) {+    config = grpc_client_config_create();+    subchannels = gpr_malloc(sizeof(grpc_subchannel *) * addresses->naddrs);+    for (i = 0; i < addresses->naddrs; i++) {+      memset(&args, 0, sizeof(args));+      args.addr = (struct sockaddr *)(addresses->addrs[i].addr);+      args.addr_len = addresses->addrs[i].len;+      subchannels[i] = grpc_subchannel_factory_create_subchannel(+          r->subchannel_factory, &args);+    }+    lb_policy = r->lb_policy_factory(subchannels, addresses->naddrs);+    grpc_client_config_set_lb_policy(config, lb_policy);+    GRPC_LB_POLICY_UNREF(lb_policy, ""construction"");+    grpc_resolved_addresses_destroy(addresses);+    gpr_free(subchannels);+  }+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(r->resolving);+  r->resolving = 0;+  if (r->resolved_config) {+    grpc_client_config_unref(r->resolved_config);+  }+  r->resolved_config = config;+  r->resolved_version++;+  zookeeper_maybe_finish_next_locked(r);+  gpr_mu_unlock(&r->mu);++  GRPC_RESOLVER_UNREF(&r->base, ""zookeeper-resolving"");+}++/* Callback function for each DNS resolved address */+static void zookeeper_dns_resolved(void *arg, grpc_resolved_addresses *addresses) {+  size_t i;+  zookeeper_resolver *r = arg;+  gpr_mu_lock(&r->mu);+  r->resolved_num++;+  r->resolved_addrs->addrs = gpr_realloc(r->resolved_addrs->addrs, +                            sizeof(grpc_resolved_address) * (r->resolved_addrs->naddrs + addresses->naddrs));",line too long,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2612,35272691,2015-07-22T22:36:30Z,include/grpc/grpc.h,"@@ -343,6 +344,7 @@ typedef struct grpc_op {       int *cancelled;     } recv_close_on_server;   } data;+  void *reserved;","Let's move to before data, and add to the data union:struct {  void *reserved[8];} reserved;",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2549,35273091,2015-07-22T22:41:29Z,src/core/client_config/resolvers/zookeeper_resolver.c,"@@ -0,0 +1,452 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/client_config/resolvers/zookeeper_resolver.h""++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/string_util.h>++#include <grpc/grpc_zookeeper.h>+#include <zookeeper/zookeeper.h>++#include ""src/core/client_config/lb_policies/pick_first.h""+#include ""src/core/client_config/resolver_registry.h""+#include ""src/core/iomgr/resolve_address.h""+#include ""src/core/support/string.h""+#include ""src/core/json/json.h""++#define GRPC_MAX_ZOOKEEPER_BUFFER_SIZE 1024+#define GRPC_ZOOKEEPER_TIMEOUT 15000+#define GRPC_ZOOKEEPER_WATCH 0++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;+  /** name to resolve */+  char *name;+  /** subchannel factory */+  grpc_subchannel_factory *subchannel_factory;+  /** load balancing policy factory */+  grpc_lb_policy *(*lb_policy_factory)(grpc_subchannel **subchannels,+                                       size_t num_subchannels);++  /** mutex guarding the rest of the state */+  gpr_mu mu;+  /** are we currently resolving? */+  int resolving;+  /** which version of resolved_config have we published? */+  int published_version;+  /** which version of resolved_config is current? */+  int resolved_version;+  /** pending next completion, or NULL */+  grpc_iomgr_closure *next_completion;+  /** target config address for next completion */+  grpc_client_config **target_config;+  /** current (fully resolved) config */+  grpc_client_config *resolved_config;++  /** zookeeper handle */+  zhandle_t *zookeeper_handle;+  /** zookeeper resolved addresses */+  grpc_resolved_addresses * resolved_addrs;+  /** total number of addresses to be resolved */+  int resolved_total;+  /** resolved number of addresses */+  int resolved_num;+} zookeeper_resolver;++static void zookeeper_destroy(grpc_resolver *r);++static void zookeeper_start_resolving_locked(zookeeper_resolver *r);+static void zookeeper_maybe_finish_next_locked(zookeeper_resolver *r);++static void zookeeper_shutdown(grpc_resolver *r);+static void zookeeper_channel_saw_error(grpc_resolver *r,+                                  struct sockaddr *failing_address,+                                  int failing_address_len);+static void zookeeper_next(grpc_resolver *r, grpc_client_config **target_config,+                     grpc_iomgr_closure *on_complete);++static const grpc_resolver_vtable zookeeper_resolver_vtable = {+    zookeeper_destroy, zookeeper_shutdown, zookeeper_channel_saw_error, zookeeper_next};++static void zookeeper_shutdown(grpc_resolver *resolver) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (r->next_completion != NULL) {+    *r->target_config = NULL;+    grpc_iomgr_add_callback(r->next_completion);+    r->next_completion = NULL;+  }+  zookeeper_close(r->zookeeper_handle);+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_channel_saw_error(grpc_resolver *resolver, struct sockaddr *sa,+                                  int len) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (!r->resolving) {+    zookeeper_start_resolving_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_next(grpc_resolver *resolver,+                     grpc_client_config **target_config,+                     grpc_iomgr_closure *on_complete) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(!r->next_completion);+  r->next_completion = on_complete;+  r->target_config = target_config;+  if (r->resolved_version == 0 && !r->resolving) {+    zookeeper_start_resolving_locked(r);+  } else {+    zookeeper_maybe_finish_next_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_on_resolved(void *arg, grpc_resolved_addresses *addresses) {+  zookeeper_resolver *r = arg;+  grpc_client_config *config = NULL;+  grpc_subchannel **subchannels;+  grpc_subchannel_args args;+  grpc_lb_policy *lb_policy;+  size_t i;+  if (addresses) {+    config = grpc_client_config_create();+    subchannels = gpr_malloc(sizeof(grpc_subchannel *) * addresses->naddrs);+    for (i = 0; i < addresses->naddrs; i++) {+      memset(&args, 0, sizeof(args));+      args.addr = (struct sockaddr *)(addresses->addrs[i].addr);+      args.addr_len = addresses->addrs[i].len;+      subchannels[i] = grpc_subchannel_factory_create_subchannel(+          r->subchannel_factory, &args);+    }+    lb_policy = r->lb_policy_factory(subchannels, addresses->naddrs);+    grpc_client_config_set_lb_policy(config, lb_policy);+    GRPC_LB_POLICY_UNREF(lb_policy, ""construction"");+    grpc_resolved_addresses_destroy(addresses);+    gpr_free(subchannels);+  }+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(r->resolving);+  r->resolving = 0;+  if (r->resolved_config) {+    grpc_client_config_unref(r->resolved_config);+  }+  r->resolved_config = config;+  r->resolved_version++;+  zookeeper_maybe_finish_next_locked(r);+  gpr_mu_unlock(&r->mu);++  GRPC_RESOLVER_UNREF(&r->base, ""zookeeper-resolving"");+}++/* Callback function for each DNS resolved address */+static void zookeeper_dns_resolved(void *arg, grpc_resolved_addresses *addresses) {+  size_t i;+  zookeeper_resolver *r = arg;+  gpr_mu_lock(&r->mu);+  r->resolved_num++;+  r->resolved_addrs->addrs = gpr_realloc(r->resolved_addrs->addrs, +                            sizeof(grpc_resolved_address) * (r->resolved_addrs->naddrs + addresses->naddrs));+  for (i = 0; i < addresses->naddrs; i++) {+    memcpy(r->resolved_addrs->addrs[i + r->resolved_addrs->naddrs].addr, +          addresses->addrs[i].addr, addresses->addrs[i].len);+    r->resolved_addrs->addrs[i + r->resolved_addrs->naddrs].len = addresses->addrs[i].len;",line too long,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2549,35274385,2015-07-22T22:57:32Z,src/core/client_config/resolvers/zookeeper_resolver.c,"@@ -0,0 +1,452 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/client_config/resolvers/zookeeper_resolver.h""++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/string_util.h>++#include <grpc/grpc_zookeeper.h>+#include <zookeeper/zookeeper.h>++#include ""src/core/client_config/lb_policies/pick_first.h""+#include ""src/core/client_config/resolver_registry.h""+#include ""src/core/iomgr/resolve_address.h""+#include ""src/core/support/string.h""+#include ""src/core/json/json.h""++#define GRPC_MAX_ZOOKEEPER_BUFFER_SIZE 1024+#define GRPC_ZOOKEEPER_TIMEOUT 15000+#define GRPC_ZOOKEEPER_WATCH 0++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;+  /** name to resolve */+  char *name;+  /** subchannel factory */+  grpc_subchannel_factory *subchannel_factory;+  /** load balancing policy factory */+  grpc_lb_policy *(*lb_policy_factory)(grpc_subchannel **subchannels,+                                       size_t num_subchannels);++  /** mutex guarding the rest of the state */+  gpr_mu mu;+  /** are we currently resolving? */+  int resolving;+  /** which version of resolved_config have we published? */+  int published_version;+  /** which version of resolved_config is current? */+  int resolved_version;+  /** pending next completion, or NULL */+  grpc_iomgr_closure *next_completion;+  /** target config address for next completion */+  grpc_client_config **target_config;+  /** current (fully resolved) config */+  grpc_client_config *resolved_config;++  /** zookeeper handle */+  zhandle_t *zookeeper_handle;+  /** zookeeper resolved addresses */+  grpc_resolved_addresses * resolved_addrs;+  /** total number of addresses to be resolved */+  int resolved_total;+  /** resolved number of addresses */+  int resolved_num;+} zookeeper_resolver;++static void zookeeper_destroy(grpc_resolver *r);++static void zookeeper_start_resolving_locked(zookeeper_resolver *r);+static void zookeeper_maybe_finish_next_locked(zookeeper_resolver *r);++static void zookeeper_shutdown(grpc_resolver *r);+static void zookeeper_channel_saw_error(grpc_resolver *r,+                                  struct sockaddr *failing_address,+                                  int failing_address_len);+static void zookeeper_next(grpc_resolver *r, grpc_client_config **target_config,+                     grpc_iomgr_closure *on_complete);++static const grpc_resolver_vtable zookeeper_resolver_vtable = {+    zookeeper_destroy, zookeeper_shutdown, zookeeper_channel_saw_error, zookeeper_next};++static void zookeeper_shutdown(grpc_resolver *resolver) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (r->next_completion != NULL) {+    *r->target_config = NULL;+    grpc_iomgr_add_callback(r->next_completion);+    r->next_completion = NULL;+  }+  zookeeper_close(r->zookeeper_handle);+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_channel_saw_error(grpc_resolver *resolver, struct sockaddr *sa,+                                  int len) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (!r->resolving) {+    zookeeper_start_resolving_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_next(grpc_resolver *resolver,+                     grpc_client_config **target_config,+                     grpc_iomgr_closure *on_complete) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(!r->next_completion);+  r->next_completion = on_complete;+  r->target_config = target_config;+  if (r->resolved_version == 0 && !r->resolving) {+    zookeeper_start_resolving_locked(r);+  } else {+    zookeeper_maybe_finish_next_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_on_resolved(void *arg, grpc_resolved_addresses *addresses) {+  zookeeper_resolver *r = arg;+  grpc_client_config *config = NULL;+  grpc_subchannel **subchannels;+  grpc_subchannel_args args;+  grpc_lb_policy *lb_policy;+  size_t i;+  if (addresses) {+    config = grpc_client_config_create();+    subchannels = gpr_malloc(sizeof(grpc_subchannel *) * addresses->naddrs);+    for (i = 0; i < addresses->naddrs; i++) {+      memset(&args, 0, sizeof(args));+      args.addr = (struct sockaddr *)(addresses->addrs[i].addr);+      args.addr_len = addresses->addrs[i].len;+      subchannels[i] = grpc_subchannel_factory_create_subchannel(+          r->subchannel_factory, &args);+    }+    lb_policy = r->lb_policy_factory(subchannels, addresses->naddrs);+    grpc_client_config_set_lb_policy(config, lb_policy);+    GRPC_LB_POLICY_UNREF(lb_policy, ""construction"");+    grpc_resolved_addresses_destroy(addresses);+    gpr_free(subchannels);+  }+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(r->resolving);+  r->resolving = 0;+  if (r->resolved_config) {+    grpc_client_config_unref(r->resolved_config);+  }+  r->resolved_config = config;+  r->resolved_version++;+  zookeeper_maybe_finish_next_locked(r);+  gpr_mu_unlock(&r->mu);++  GRPC_RESOLVER_UNREF(&r->base, ""zookeeper-resolving"");+}++/* Callback function for each DNS resolved address */+static void zookeeper_dns_resolved(void *arg, grpc_resolved_addresses *addresses) {+  size_t i;+  zookeeper_resolver *r = arg;+  gpr_mu_lock(&r->mu);+  r->resolved_num++;+  r->resolved_addrs->addrs = gpr_realloc(r->resolved_addrs->addrs, +                            sizeof(grpc_resolved_address) * (r->resolved_addrs->naddrs + addresses->naddrs));+  for (i = 0; i < addresses->naddrs; i++) {+    memcpy(r->resolved_addrs->addrs[i + r->resolved_addrs->naddrs].addr, +          addresses->addrs[i].addr, addresses->addrs[i].len);+    r->resolved_addrs->addrs[i + r->resolved_addrs->naddrs].len = addresses->addrs[i].len;+  }++  r->resolved_addrs->naddrs += addresses->naddrs;+  grpc_resolved_addresses_destroy(addresses);++  /* Wait for all addresses to be resolved */+  if (r->resolved_num == r->resolved_total) {+    gpr_mu_unlock(&r->mu);+    zookeeper_on_resolved(r, r->resolved_addrs);+  } else {+    gpr_mu_unlock(&r->mu);+  }+}++/* Parse json format address of a zookeeper node */+static char *zookeeper_parse_address(char *buffer, int buffer_len) {+  char *host;+  char *port;+  char *address;+  grpc_json *json;+  grpc_json *cur;  ++  address = NULL;+  json = grpc_json_parse_string_with_len(buffer, buffer_len);+  if (json != NULL) {+    host = NULL;+    port = NULL;+    for (cur = json->child; cur != NULL; cur = cur->next) {+      if (!strcmp(cur->key, ""host"")) {+        host = (char *)cur->value;+        if (port != NULL)+          break;+      }+      else if (!strcmp(cur->key, ""port"")) {+        port = (char *)cur->value;+        if (host != NULL)+          break;+      }+    }+    if (host != NULL && port != NULL) {+      address = gpr_malloc(GRPC_MAX_SOCKADDR_SIZE);+      memset(address, 0, GRPC_MAX_SOCKADDR_SIZE);+      strcat(address, host);+      strcat(address, "":"");+      strcat(address, port);+    }+    grpc_json_destroy(json);+  } ++  return address;+}++static void zookeeper_get_children_node_completion(int rc, const char *value, int value_len, +                                          const struct Stat *stat, const void *arg) {+  char *address = NULL;+  zookeeper_resolver *r = (zookeeper_resolver *)arg;++  if (rc) {+    gpr_log(GPR_ERROR, ""Error in getting a child node of %s"", r->name);+    return;+  }++  address = zookeeper_parse_address((char *)value, value_len);","Try to avoid using casting to remove const as much as possible: you are braking a promise you made on the function signature (namely, that the contents of ""value"" wouldn't be modified). In this case it's a ""private"" (static) function, but if this were a public function, that'd be potentially very bad.It's better to change the function signature to ...char\* value... to avoid lying about the constness.",
2645523,hongweiwang,https://api.github.com/repos/grpc/grpc/pulls/2549,35366970,2015-07-23T20:24:37Z,src/core/client_config/resolvers/zookeeper_resolver.h,"@@ -0,0 +1,42 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+","There is a naming design document #2560 , do I still need to write a description here, or just refer to it?",
2645523,hongweiwang,https://api.github.com/repos/grpc/grpc/pulls/2549,35377373,2015-07-23T22:05:47Z,test/build/zookeeper.c,"@@ -0,0 +1,43 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* This is just a compilation test, to see if we have Zookeeper C client +   library installed. */++#include <stdlib.h>+#include <zookeeper/zookeeper.h>+","Currently there is only a compilation test, to see if we have Zookeeper C client library installed. I am adding an end-to-end test now.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2492,35447566,2015-07-24T17:50:56Z,src/core/security/server_auth_filter.c,"@@ -31,20 +31,149 @@  *  */ +#include <string.h>+ #include ""src/core/security/auth_filters.h"" #include ""src/core/security/security_connector.h"" #include ""src/core/security/security_context.h"" +#include <grpc/support/alloc.h> #include <grpc/support/log.h>  typedef struct call_data {-  int unused; /* C89 requires at least one struct element */+  gpr_uint8 got_client_metadata;+  grpc_stream_op_buffer *recv_ops;+  /* Closure to call when finished with the auth_on_recv hook. */+  grpc_iomgr_closure *on_done_recv;+  /* Receive closures are chained: we inject this closure as the on_done_recv+     up-call on transport_op, and remember to call our on_done_recv member after+     handling it. */+  grpc_iomgr_closure auth_on_recv;+  grpc_transport_stream_op transport_op;+  const grpc_metadata *consumed_md;+  size_t num_consumed_md;+  grpc_stream_op *md_op;+  grpc_auth_context **call_auth_context;+  grpc_auth_ticket ticket; } call_data;  typedef struct channel_data {   grpc_security_connector *security_connector;+  grpc_mdctx *mdctx; } channel_data; +static grpc_metadata_array metadata_batch_to_md_array(+    const grpc_metadata_batch *batch) {+  grpc_linked_mdelem *l;+  grpc_metadata_array result;+  grpc_metadata_array_init(&result);+  for (l = batch->list.head; l != NULL; l = l->next) {+    grpc_metadata *usr_md = NULL;+    grpc_mdelem *md = l->md;+    grpc_mdstr *key = md->key;+    grpc_mdstr *value = md->value;+    if (result.count == result.capacity) {+      result.capacity = GPR_MAX(result.capacity + 8, result.capacity * 2);+      result.metadata =+          gpr_realloc(result.metadata, result.capacity * sizeof(grpc_metadata));+    }+    usr_md = &result.metadata[result.count++];+    usr_md->key = grpc_mdstr_as_c_string(key);+    usr_md->value = grpc_mdstr_as_c_string(value);+    usr_md->value_length = GPR_SLICE_LENGTH(value->slice);+  }+  return result;+}++static grpc_mdelem *remove_consumed_md(void *user_data, grpc_mdelem *md) {+  grpc_call_element *elem = user_data;+  call_data *calld = elem->call_data;+  size_t i;+  for (i = 0; i < calld->num_consumed_md; i++) {+    /* Maybe we could do a pointer comparison but we do not have any guarantee+       that the metadata processor used the same pointers for consumed_md in the+       callback. */+    if (memcmp(GPR_SLICE_START_PTR(md->key->slice), calld->consumed_md[i].key,+               GPR_SLICE_LENGTH(md->key->slice)) == 0 &&+        memcmp(GPR_SLICE_START_PTR(md->value->slice),+               calld->consumed_md[i].value,+               GPR_SLICE_LENGTH(md->value->slice)) == 0) {+      return NULL; /* Delete. */+    }+  }+  return md;+}++static void on_md_processing_done(void *user_data,+                                  const grpc_metadata *consumed_md,+                                  size_t num_consumed_md, int success,+                                  grpc_auth_context *result) {+  grpc_call_element *elem = user_data;+  call_data *calld = elem->call_data;+  channel_data *chand = elem->channel_data;++  if (success) {+    calld->consumed_md = consumed_md;+    calld->num_consumed_md = num_consumed_md;+    grpc_metadata_batch_filter(&calld->md_op->data.metadata, remove_consumed_md,+                               elem);+    GPR_ASSERT(calld->call_auth_context != NULL);+    GRPC_AUTH_CONTEXT_UNREF(*calld->call_auth_context,+                            ""releasing old context."");+    *calld->call_auth_context =+        GRPC_AUTH_CONTEXT_REF(result, ""refing new context."");+    calld->on_done_recv->cb(calld->on_done_recv->cb_arg, success);+  } else {+    grpc_transport_stream_op_add_cancellation(","That'd be goodOn Fri, Jul 24, 2015, 10:12 AM jboeuf notifications@github.com wrote:> In src/core/security/server_auth_filter.c> https://github.com/grpc/grpc/pull/2492#discussion_r35443504:> > > -  call_data *calld = elem->call_data;> > -  channel_data *chand = elem->channel_data;> >   +> > -  if (success) {> > -    calld->consumed_md = consumed_md;> > -    calld->num_consumed_md = num_consumed_md;> > -    grpc_metadata_batch_filter(&calld->md_op->data.metadata, remove_consumed_md,> > -                               elem);> > -    GPR_ASSERT(calld->call_auth_context != NULL);> > -    GRPC_AUTH_CONTEXT_UNREF(*calld->call_auth_context,> > -                            ""releasing old context."");> > -    *calld->call_auth_context => > -        GRPC_AUTH_CONTEXT_REF(result, ""refing new context."");> > -    calld->on_done_recv->cb(calld->on_done_recv->cb_arg, success);> > -  } else {> > -    grpc_transport_stream_op_add_cancellation(> > Thanks Craig. Let's wait for your fix and not introduce this new API> surface before we're sure that everything works well (I can still file an> issue though).> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2492/files#r35443504.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2682,35657393,2015-07-28T15:00:19Z,src/core/iomgr/iomgr_internal.h,"@@ -46,8 +46,19 @@ typedef struct grpc_iomgr_object { int grpc_maybe_call_delayed_callbacks(gpr_mu *drop_mu, int success); void grpc_iomgr_add_delayed_callback(grpc_iomgr_closure *iocb, int success); -void grpc_iomgr_register_object(grpc_iomgr_object *obj, const char *name);",Can we hide the entire mechanism behind an `#ifdef`?I'm trying to be a little wary of introducing inadvertent string bloat for our debug features.,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/2668,35675510,2015-07-28T17:32:17Z,include/grpc/census.h,"@@ -100,6 +101,150 @@ int census_context_deserialize(const char *buffer, census_context **context);  * future census calls will result in undefined behavior. */ void census_context_destroy(census_context *context); +/* Distributed traces can have a number of options. */+enum census_trace_mask_values {+  CENSUS_TRACE_MASK_NONE = 0,      /* Default, empty flags */+  CENSUS_TRACE_MASK_IS_SAMPLED = 1 /* RPC tracing enabled for this context. */+};++/** Get the current trace mask associated with this context. The value returned+    will be the logical or of census_trace_mask_values values. */+int census_trace_mask(const census_context *context);++/* The concept of ""operation"" is a fundamental concept for Census. An+   operation is a logical representation of a action in a RPC-using system. It+   is most typically used to represent a single RPC, or a significant sub-part+   thereof (e.g. a single logical ""read"" RPC to a distributed storage system+   might do several other actions in parallel, from looking up metadata+   indices to making requests of other services - each of these could be a+   sub-operation with the larger RPC operation. Census uses operations for the+   following:++   CPU accounting: If enabled, census will measure the thread CPU time+   consumed between operation start and end times.++   Active operations: Census will maintain information on all currently+   active operations.++   Distributed tracing: Each operation serves as a logical trace span.++   Stats collection: Stats are broken down operation (e.g. latency+   breakdown for each service/method combination).++   The following functions serve to delineate the start and stop points for+   each logical operation. */+/**+   Start a client rpc operation. This function will create a new context. If+   the context argument is non-null, then the new context will inherit all+   its properties, with the following changes:+   - create a new operation ID for the new context, marking it as a child of+     the previous operation.+   - use the new RPC service/method/peer information for tracing and stats+     collection purposes, rather than those from the original context+   - if trace_mask is non-zero, update the trace mask entries associated with+     the original context.++   If the context argument is NULL, then a new root context is created.  This+   is particularly important for tracing purposes (the trace spans generated+   will be unassociated with any other trace spans, except those+   downstream). Whatever it's value, the trace_mask will be used for tracing+   operations associated with the new context.++   @param context The base context. Can be NULL.+   @param service RPC service name. On some systems, may include other+   parts of RPC identification (e.g. host on gRPC systems).+   @param method RPC method name+   @param peer RPC peer+   @param trace_mask An or of census_trace_mask_values values+   @param start_time If NULL, the time of function call is used as the+   start time for the operation. If non-NULL, then the time should be in the+   past, when the operation was deemed to have started. This is used when+   the other information used as arguments is not yet available.++   @return A new census context.+ */+census_context *census_start_client_rpc_op(census_context *context,+                                           const char *service,+                                           const char *method, const char *peer,","Not sure I 100% understand what you're asking, but if it is essentially: can we have the API accept a single argument (where we now have service + method), which are then split later, then yes we can do that. The downside would be that we then have to make other RPC systems conform to whatever encoding we use for that separation (remember, in the long term, we want to have census be usable by other RPC systems). I'd much rather keep the interface here generic.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/2669,35703817,2015-07-28T21:30:47Z,include/grpc/census.h,"@@ -44,26 +44,30 @@ extern ""C"" { #endif -/* Identify census functionality that can be enabled via census_initialize(). */-enum census_functions {-  CENSUS_NONE = 0,    /* Do not enable census. */-  CENSUS_TRACING = 1, /* Enable census tracing. */-  CENSUS_STATS = 2,   /* Enable Census stats collection. */-  CENSUS_CPU = 4,     /* Enable Census CPU usage collection. */-  CENSUS_ALL = CENSUS_TRACING | CENSUS_STATS | CENSUS_CPU+/* Identify census features that can be enabled via census_initialize(). */+enum census_features {+  CENSUS_FEATURE_NONE = 0,    /* Do not enable census. */+  CENSUS_FEATURE_TRACING = 1, /* Enable census tracing. */+  CENSUS_FEATURE_STATS = 2,   /* Enable Census stats collection. */","The intent is that this will be all stats (in the long term - only RPC stats in short term of course), so think we can leave as is for now?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2697,35786135,2015-07-29T17:21:43Z,src/python/src/commands.py,"@@ -0,0 +1,75 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Provides distutils command classes for the GRPC Python setup process.""""""++import os+import os.path+import sys++import setuptools++class SphinxDocumentation(setuptools.Command):+  """"""Command to generate documentation via sphinx.""""""++  description = ''+  user_options = []++  def initialize_options(self):+    pass++  def finalize_options(self):+    pass++  def run(self):+    # We import here to ensure that setup.py has had a chance to install the+    # relevant package eggs first.+    import sphinx+    import sphinx.apidoc+    metadata = self.distribution.metadata+    print self.distribution.package_dir",This print smells like leftover debugging output but is it an actual part of the intended behavior of this method?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2697,35786376,2015-07-29T17:23:46Z,src/python/src/commands.py,"@@ -0,0 +1,75 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Provides distutils command classes for the GRPC Python setup process.""""""++import os+import os.path+import sys++import setuptools++class SphinxDocumentation(setuptools.Command):+  """"""Command to generate documentation via sphinx.""""""++  description = ''+  user_options = []++  def initialize_options(self):+    pass++  def finalize_options(self):+    pass++  def run(self):+    # We import here to ensure that setup.py has had a chance to install the+    # relevant package eggs first.+    import sphinx+    import sphinx.apidoc+    metadata = self.distribution.metadata+    print self.distribution.package_dir+    src_dir = os.path.join(+        os.getcwd(), self.distribution.package_dir['grpc'])+    sys.path.append(src_dir)+    sphinx.apidoc.main([+        '', '--force', '--full', '-H', metadata.name, '-A', metadata.author,+        '-V', metadata.version, '-R', metadata.version,+        '-o', os.path.join('doc', 'src'), src_dir])+    conf_filepath = os.path.join('doc', 'src', 'conf.py')+    with open(conf_filepath, 'a') as conf_file:+      conf_file.write(+""""""","Any reason why this large (-on-the-page) constant shouldn't be assigned a name at module-scope and then referenced symbolically here at its use site, as would be the right thing for any other kind of large-on-the-page literal value?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2697,35786808,2015-07-29T17:27:36Z,src/python/src/setup.py,"@@ -98,15 +104,23 @@     'grpc.framework': 'grpc/framework', } +_INSTALL_REQUIRES = (+    'enum34==1.0.4',+    'futures==2.2.0',+    'protobuf==3.0.0a3'+)+ setuptools.setup(     name='grpcio',     version='0.10.0a0',     ext_modules=_EXTENSION_MODULES,     packages=list(_PACKAGES),     package_dir=_PACKAGE_DIRECTORIES,-    install_requires=[-        'enum34==1.0.4',-        'futures==2.2.0',-        'protobuf==3.0.0a3'-    ]+    install_requires=_INSTALL_REQUIRES,+    setup_requires=(+        'sphinx>=1.3',+    ) + _INSTALL_REQUIRES,","Let's not do this algebra inside the setuptools.setup function call. How about_SETUP_REQUIRES = tuple(['sphinx>=1.3'] + list(_INSTALL_REQURES))at top-level andsetup_requires=list(_SETUP_REQUIRES),here?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2697,35786868,2015-07-29T17:28:08Z,src/python/src/setup.py,"@@ -98,15 +104,23 @@     'grpc.framework': 'grpc/framework', } +_INSTALL_REQUIRES = (+    'enum34==1.0.4',+    'futures==2.2.0',+    'protobuf==3.0.0a3'+)+ setuptools.setup(     name='grpcio',     version='0.10.0a0',     ext_modules=_EXTENSION_MODULES,     packages=list(_PACKAGES),     package_dir=_PACKAGE_DIRECTORIES,-    install_requires=[-        'enum34==1.0.4',-        'futures==2.2.0',-        'protobuf==3.0.0a3'-    ]+    install_requires=_INSTALL_REQUIRES,+    setup_requires=(+        'sphinx>=1.3',+    ) + _INSTALL_REQUIRES,+    cmdclass={","cmdclass=_COMMAND_CLASS,here, with the constant declared above?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2670,35795720,2015-07-29T18:37:58Z,include/grpc++/server_context.h,"@@ -116,6 +117,8 @@ class ServerContext {    std::shared_ptr<const AuthContext> auth_context() const; +  const census_context* get_census_context() const;","Without it we've got an inconsistent style, and I'd favor census_context()over get_census_context() because that's where the rest of the code is.Can you qualify the name better maybe? const ::census_context*census_context()... const struct census_context *census_context()...surely there's some way to coax even GCC into accepting C++ :)On Wed, Jul 29, 2015 at 10:51 AM Alistair Veitch notifications@github.comwrote:> In include/grpc++/server_context.h> https://github.com/grpc/grpc/pull/2670#discussion_r35789668:> > > @@ -116,6 +117,8 @@ class ServerContext {> > > >    std::shared_ptr<const AuthContext> auth_context() const;> > -  const census_context\* get_census_context() const;> > That results in errors like:> > In file included from include/grpc++/stream.h:40:0,> from include/grpc++/generic_stub.h:38,> from src/cpp/client/generic_stub.cc:34:> include/grpc++/server_context.h:120:42: error: declaration of ‘const> census_context\* grpc::ServerContext::census_context() const’ [-fpermissive]> const census_context\* census_context() const;> ^> In file included from include/grpc++/impl/call.h:38:0,> from include/grpc++/channel_interface.h:40,> from include/grpc++/stream.h:37,> from include/grpc++/generic_stub.h:38,> from src/cpp/client/generic_stub.cc:34:> include/grpc++/client_context.h:51:8: error: changes meaning of> ‘census_context’ from ‘struct census_context’ [-fpermissive]> struct census_context;> ^> make: **\* [objs/opt/src/cpp/client/generic_stub.o] Error 1> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2670/files#r35789668.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2697,35798782,2015-07-29T19:04:12Z,src/python/src/setup.py,"@@ -98,15 +104,23 @@     'grpc.framework': 'grpc/framework', } +_INSTALL_REQUIRES = (+    'enum34==1.0.4',+    'futures==2.2.0',+    'protobuf==3.0.0a3'+)+ setuptools.setup(     name='grpcio',     version='0.10.0a0',     ext_modules=_EXTENSION_MODULES,     packages=list(_PACKAGES),     package_dir=_PACKAGE_DIRECTORIES,-    install_requires=[-        'enum34==1.0.4',-        'futures==2.2.0',-        'protobuf==3.0.0a3'-    ]+    install_requires=_INSTALL_REQUIRES,+    setup_requires=(+        'sphinx>=1.3',+    ) + _INSTALL_REQUIRES,","Sure, though I fail to see the pertinence of casting things to `list`s.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2697,35801103,2015-07-29T19:26:11Z,src/python/src/setup.py,"@@ -98,15 +104,23 @@     'grpc.framework': 'grpc/framework', } +_INSTALL_REQUIRES = (+    'enum34==1.0.4',+    'futures==2.2.0',+    'protobuf==3.0.0a3'+)+ setuptools.setup(     name='grpcio',     version='0.10.0a0',     ext_modules=_EXTENSION_MODULES,     packages=list(_PACKAGES),     package_dir=_PACKAGE_DIRECTORIES,-    install_requires=[-        'enum34==1.0.4',-        'futures==2.2.0',-        'protobuf==3.0.0a3'-    ]+    install_requires=_INSTALL_REQUIRES,+    setup_requires=(+        'sphinx>=1.3',+    ) + _INSTALL_REQUIRES,","The reason it's done for ""packages"" is that setuptools.setup raises a TypeError if a non-list sequence type is passed for the value. My suggestion of passing lists constructed from the constant value was based on the assumption that a similar problem would arise for the other arguments to the call. If that's not the case, then yes, there would be no point to it.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2697,35801369,2015-07-29T19:29:04Z,src/python/src/setup.py,"@@ -98,15 +104,23 @@     'grpc.framework': 'grpc/framework', } +_INSTALL_REQUIRES = (+    'enum34==1.0.4',+    'futures==2.2.0',+    'protobuf==3.0.0a3'+)+ setuptools.setup(     name='grpcio',     version='0.10.0a0',     ext_modules=_EXTENSION_MODULES,     packages=list(_PACKAGES),     package_dir=_PACKAGE_DIRECTORIES,-    install_requires=[-        'enum34==1.0.4',-        'futures==2.2.0',-        'protobuf==3.0.0a3'-    ]+    install_requires=_INSTALL_REQUIRES,+    setup_requires=(+        'sphinx>=1.3',+    ) + _INSTALL_REQUIRES,","Also take another look at my suggestion of_SETUP_REQUIRES = tuple(['sphinx>=1.3'] + list(_INSTALL_REQURES)); I think it might fix theProcessing ./src/python/src    Complete output from command python setup.py egg_info:    Traceback (most recent call last):      File ""<string>"", line 20, in <module>      File ""/tmp/pip-YlhtI5-build/setup.py"", line 115, in <module>        ) + _INSTALL_REQUIRES    TypeError: cannot concatenate 'str' and 'tuple' objectsin the latest Travis run.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2709,35809286,2015-07-29T20:43:30Z,vsprojects/grpc_csharp_ext/grpc_csharp_ext.vcxproj,"@@ -80,6 +80,9 @@   <PropertyGroup Label=""UserMacros"" />   <PropertyGroup Condition=""'$(Configuration)|$(Platform)'=='Debug|Win32'"">     <TargetName>grpc_csharp_ext</TargetName>+    <Linkage-grpc_dependencies_zlib>static</Linkage-grpc_dependencies_zlib>",Does this mean we are planning to always link zlib statically and distribute it as a part of gRP?. This also means that we would need to drop the dependency on https://www.nuget.org/packages/grpc.dependencies.zlib/.,
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/2131,35898007,2015-07-30T17:43:18Z,doc/interop-test-descriptions.md,"@@ -509,21 +508,29 @@ Procedure:       }     }     ```+The client attaches custom metadata with the following keys and values:+    ```+    key: ""x-grpc-test-echo-initial"", value: ""test_initial_metadata_value""+    key: ""x-grpc-test-echo-trailing-bin"", value: 0xababab+    ```+ 2. Client repeats step 1. with FullDuplexCall instead of UnaryCall.  Asserts: * call was successful-* custom metadata is echoed back in the response header.-* custom metadata is echoed back in the response trailer.+* metadata with key `""x-grpc-test-echo-initial""` and value `""test_initial_metadata_value""`is received in the initial metadata.+* metadata with key `""x-grpc-test-echo-trailing-bin""` and value `0xababab` is received in the trailing metadata.","This won't work, because the server-side Echo Metadata feature echos x-grpc-test-echo-trailing, not x-grpc-test-echo-trailing-bin. The server feature needs to be updated in some way. For example, if it also echoed x-grpc-test-echo-trailing-bin and x-grpc-test-echo-trailing-bin then it would work.",
10135698,a11r,https://api.github.com/repos/grpc/grpc/pulls/2660,35898456,2015-07-30T17:47:17Z,doc/connection-backoff-interop-test-description.md,"@@ -0,0 +1,76 @@+Connection Backoff Interop Test Descriptions+===============================================++This test is to verify the client is reconnecting the server with correct+backoffs as specified in+[the spec](http://github.com/grpc/grpc/blob/master/doc/connection-backoff.md).+The test server has a port (control_port) running a rpc service for controlling+the server and another port (retry_port) to close any incoming tcp connections.+The test has the following flow:++1. The server starts listening on control_port.+2. The client calls Start rpc on server control_port.+3. The server starts listening on retry_port.+4. The client connects to server retry_port and retries with backoff for 540s,+which translates to about 13 retries.+5. The client calls Stop rpc on server control port.+6. The client checks the response to see whether the server thinks the backoffs+are conforming the spec or do its own check on the backoffs in the response.++Client and server use+[test.proto](https://github.com/grpc/grpc/blob/master/test/proto/test.proto).+Each language should implement its own client. The C++ server is shared among+languages.++Client+------++Clients should accept these arguments:+* --server_control_port=PORT+    * The server port to connect to for rpc. For example, ""8080""+* --server_retry_port=PORT+    * The server port to connect to for testing backoffs. For example, ""8080""","Suggest using different port numbers in your examples (being pedantic, but this avoids unnecessary confusion for unfamiliar readers). Also at the bottom of the file.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2686,35924725,2015-07-30T21:43:56Z,src/python/src/grpc/test_common.py,"@@ -0,0 +1,71 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Common code used throughout tests of gRPC.""""""++import collections+++def metadata_transmitted(original_metadata, transmitted_metadata):+  """"""Judges whether or not metadata was acceptably transmitted.++  gRPC is allowed to insert key-value pairs into the metadata values given by+  applications and to reorder key-value pairs with different keys but it is not+  allowed to alter existing key-value pairs or to reorder key-value pairs with+  the same key.++  Args:+    original_metadata: A metadata value used in a test of gRPC.+    transmitted_metadata: A metadata value corresponding to original_metadata+      after having been transmitted via gRPC.++  Returns:+     A boolean indicating whether transmitted_metadata accurately reflects+      original_metadata after having been transmitted via gRPC.+  """"""+  original = collections.defaultdict(list)+  for key, value in original_metadata:+    original[key].append(value)+  transmitted = collections.defaultdict(list)+  for key, value in transmitted_metadata:+    transmitted[key].append(value)++  for key, values in original.iteritems():+    transmitted_values = transmitted[key]+    transmitted_iterator = iter(transmitted_values)+    try:+      for value in values:+        while True:+          transmitted_value = next(transmitted_iterator)+          if value == transmitted_value:+            break+    except StopIteration:",I'm never a big fan of using exceptions during the normal flow of execution... it makes this code a little too magical.Is it possible to open code the checking loop?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2686,35926501,2015-07-30T22:02:41Z,src/python/src/grpc/test_common.py,"@@ -0,0 +1,71 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Common code used throughout tests of gRPC.""""""++import collections+++def metadata_transmitted(original_metadata, transmitted_metadata):+  """"""Judges whether or not metadata was acceptably transmitted.++  gRPC is allowed to insert key-value pairs into the metadata values given by+  applications and to reorder key-value pairs with different keys but it is not+  allowed to alter existing key-value pairs or to reorder key-value pairs with+  the same key.++  Args:+    original_metadata: A metadata value used in a test of gRPC.+    transmitted_metadata: A metadata value corresponding to original_metadata+      after having been transmitted via gRPC.++  Returns:+     A boolean indicating whether transmitted_metadata accurately reflects+      original_metadata after having been transmitted via gRPC.+  """"""+  original = collections.defaultdict(list)+  for key, value in original_metadata:+    original[key].append(value)+  transmitted = collections.defaultdict(list)+  for key, value in transmitted_metadata:+    transmitted[key].append(value)++  for key, values in original.iteritems():+    transmitted_values = transmitted[key]+    transmitted_iterator = iter(transmitted_values)+    try:+      for value in values:+        while True:+          transmitted_value = next(transmitted_iterator)+          if value == transmitted_value:+            break+    except StopIteration:","I agree with the sentiment but Python's iterator protocol (https://docs.python.org/2/library/stdtypes.html#iterator-types) defines raising StopIteration as the way that iterators indicate exhaustion - there's no ""has_next"" like in Java, for example. Unlike other exceptions, StopIteration indicates neither a programming defect nor an especially exceptional state of execution.I'm not familiar with the verb ""open code"", but are you thinking of something like maintaining two integer indexes and advancing them each explicitly? I think I like this expression of the algorithm more.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2696,35932769,2015-07-30T23:20:55Z,src/node/src/client.js,"@@ -551,6 +551,47 @@ exports.makeClientConstructor = function(methods, serviceName) {     this.updateMetadata = updateMetadata;   } +  /**+   * Wait for the client to be ready. The callback will be called when the+   * client has successfully connected to the server, and it will be called+   * with an error if the attempt to connect to the server has unrecoverablly+   * failed or if the deadline expires. This function does not automatically+   * attempt to initiate the connection, so the callback will not be called+   * unless you also start a method call or call $tryConnect.+   * @param {(Date|Number)} deadline When to stop waiting for a connection. Pass+   *     Infinity to wait forever.+   * @param {function(Error)} callback The callback to call when done attempting+   *     to connect.+   */+  Client.prototype.$waitForReady = function(deadline, callback) {+    var self = this;+    var checkState = function(err, result) {+      if (err) {+        callback(new Error('Failed to connect before the deadline'));+      }+      var new_state = result.new_state;+      console.log(result);+      if (new_state === grpc.connectivityState.READY) {+        callback();+      } else if (new_state === grpc.connectivityState.FATAL_FAILURE) {+        callback(new Error('Failed to connect to server'));+      } else {+        self.channel.watchConnectivityState(new_state, deadline, checkState);+      }+    };+    checkState(null, {new_state: this.channel.getConnectivityState()});","@a11r thoughts?This is something we probably should standardize.My vote would be that waitUntilReady implies I want a connection.On Thu, Jul 30, 2015, 4:16 PM Michael Lumish notifications@github.comwrote:> In src/node/src/client.js> https://github.com/grpc/grpc/pull/2696#discussion_r35932443:> > > -    var self = this;> > -    var checkState = function(err, result) {> > -      if (err) {> > -        callback(new Error('Failed to connect before the deadline'));> > -      }> > -      var new_state = result.new_state;> > -      console.log(result);> > -      if (new_state === grpc.connectivityState.READY) {> > -        callback();> > -      } else if (new_state === grpc.connectivityState.FATAL_FAILURE) {> > -        callback(new Error('Failed to connect to server'));> > -      } else {> > -        self.channel.watchConnectivityState(new_state, deadline, checkState);> > -      }> > -    };> > -    checkState(null, {new_state: this.channel.getConnectivityState()});> > I wasn't really sure whether it would be more intuitive to have it> initiate the connection or just alert when there is a connection.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2696/files#r35932443.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2735,35943597,2015-07-31T03:06:46Z,src/core/iomgr/tcp_server_windows.c,"@@ -242,6 +242,9 @@ static void start_accept(server_port *port) {  /* Event manager callback when reads are ready. */ static void on_accept(void *arg, int from_iocp) {+  DWORD transfered_bytes = 0;+  DWORD flags;+  BOOL wsa_success;","Ah, it looks like I've duplicated what was already done.c:\jenkins\workspace\grpc_pull_requests@2\config\dbg\language\csharp\platform\windows\src\core\iomgr\tcp_server_windows.c(256): error C2086: 'DWORD transfered_bytes' : redefinition ",
7341718,zayoo,https://api.github.com/repos/grpc/grpc/pulls/2680,35948595,2015-07-31T06:09:05Z,src/core/profiling/endoscope_backend.h,"@@ -0,0 +1,163 @@+#include <grpc/support/sync.h>+#include <grpc/support/time.h>+#include <stdlib.h>++#ifndef ENDOSCOPE_BACKEND_H_+#define ENDOSCOPE_BACKEND_H_++#ifdef __cplusplus+extern ""C"" {+#endif++/* Data types */++#define ENDO_MUTEX_TYPE gpr_mu","They were previously introduced for compatibility of different environments, but no longer needed. Those old macros are being replaced.",
7341718,zayoo,https://api.github.com/repos/grpc/grpc/pulls/2680,35948807,2015-07-31T06:15:17Z,src/core/profiling/endoscope_backend.h,"@@ -0,0 +1,163 @@+#include <grpc/support/sync.h>+#include <grpc/support/time.h>+#include <stdlib.h>++#ifndef ENDOSCOPE_BACKEND_H_+#define ENDOSCOPE_BACKEND_H_++#ifdef __cplusplus+extern ""C"" {+#endif++/* Data types */++#define ENDO_MUTEX_TYPE gpr_mu+#define ENDO_INT64 gpr_int64+#define ENDO_INDEX unsigned short+#define ENDO_EMPTY (ENDO_INDEX)(-1)++/* Public Macros */++#define ENDOSCOPE_INIT(base) endoscope_init(base)+#define ENDOSCOPE_DESTROY(base) endoscope_destroy(base)+#define ENDOSCOPE_BEGIN(base, name) \+        do { \+          ENDO_INT64* temp_ = endoscope_begin(base, name, \+              __FILE__, __LINE__, __PRETTY_FUNCTION__); \+          *temp_ = ENDO_CYCLENOW(); \+        } while (0)+#define ENDOSCOPE_END(base, name) endoscope_end(base, name, ENDO_CYCLENOW())+#define ENDOSCOPE_EVENT(base, name) endoscope_event(base, name, \+            __FILE__, __LINE__, __PRETTY_FUNCTION__, ENDO_CYCLENOW())+#define ENDOSCOPE_ERROR(base, name) endoscope_error(base, name, \+            __FILE__, __LINE__, __PRETTY_FUNCTION__, ENDO_CYCLENOW())++/* Private macros */++#define ENDO_CYCLENOW() endoscope_cyclenow()+#define ENDO_SYNCCLOCK(cycle, time) endoscope_syncclock(cycle, time)+#define ENDO_GETTID() endoscope_gettid()+#define ENDO_MUTEX_INIT(mu) \","I used malloc so that mutex can be stored and passed in a void \* pointer, and frontend (and the previous hack hole in the server class) doesn't need any implementation of mutex. This is no longer needed and is being removed.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2746,36018161,2015-07-31T21:26:25Z,src/python/grpcio/commands.py,"@@ -34,6 +34,7 @@ import sys  import setuptools+import setuptools.command.build_py as build_py","Because I happen to enjoy turning my brain off, it seems.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2746,36021128,2015-07-31T22:08:31Z,src/python/grpcio/commands.py,"@@ -74,3 +75,29 @@ def run(self):       conf_file.write(_CONF_PY_ADDENDUM)     sphinx.main(['', os.path.join('doc', 'src'), os.path.join('doc', 'build')]) ++class BuildProjectMetadata(setuptools.Command):+  """"""Command to generate project metadata in a module.""""""++  description = ''+  user_options = []++  def initialize_options(self):+    pass++  def finalize_options(self):+    pass++  def run(self):+    print os.getcwd()+    with open('grpc/_grpcio_metadata.py', 'w') as module_file:+      module_file.write('__version__ = """"""{}""""""'.format(",A vague notion of not wanting to ever parse quote escapes and laziness to look up something that implements quote escapes. In short: entirely arbitrary.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2750,36027144,2015-08-01T00:08:54Z,include/grpc/grpc.h,"@@ -427,6 +436,8 @@ void grpc_channel_watch_connectivity_state(     completions are sent to 'completion_queue'. 'method' and 'host' need only     live through the invocation of this function. */ grpc_call *grpc_channel_create_call(grpc_channel *channel,+                                    grpc_call *parent_call,+                                    gpr_uint32 inheritance_mask,",I'm not going to disallow it (I think)... provided GRPC_PROPAGATE_DEFAULTS as the 'recommended' set - will document as such shortly - so that you don't accidentally pick up additional things depending on which libgrpc.so is on a system.,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2738,36045310,2015-08-02T17:38:47Z,doc/connection-backoff.md,"@@ -32,11 +32,14 @@ ConnectWithBackoff()  With specific parameters of MIN_CONNECT_TIMEOUT = 20 seconds-INITIAL_BACKOFF = 1 second-MULTIPLIER = 1.6+INITIAL_BACKOFF = 1.170820393 seconds+MULTIPLIER = 1.618033989 MAX_BACKOFF = 120 seconds JITTER = 0.2 +These parameters make each successive delay equal to the sum of the two previous+delays (ignoring jitter and max backoff).+","Don't want to beat a dead horse, but not sure why the above paragraph is a good idea. If it is a good idea, though, the implementation should use integer addition rather than float addition/multiplication since it could be faster.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/2750,36049447,2015-08-02T23:16:55Z,include/grpc/grpc.h,"@@ -351,6 +351,19 @@ typedef struct grpc_op {   } data; } grpc_op; +/* Propagation bits: this can be bitwise or-ed to form propagation_mask for+ * grpc_call */+/** Propagate deadline */+#define GRPC_PROPAGATE_DEADLINE 1","This is a style/personal preference thing, but I think it is cleaner to put these in an enum, e.g./*\* Propagation bits: these can be bitwise or-ed to form a propagation_mask for grpc_call(). _/enum grpc_propagation_bits {  GRPC_PROPAGATION_NONE = 0 /_ Do not propagate _/  GRPC_PROPAGATION_DEADLINE = 1 /_ Propagate deadline */  ...};",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2750,36096695,2015-08-03T15:28:50Z,include/grpc/grpc.h,"@@ -351,6 +351,23 @@ typedef struct grpc_op {   } data; } grpc_op; +/* Propagation bits: this can be bitwise or-ed to form propagation_mask for+ * grpc_call */+/** Propagate deadline */+#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)+/** Propagate census context */+#define GRPC_PROPAGATE_CENSUS_CONTEXT ((gpr_uint32)2)",census_enabled is global. What if I want to make one RPC without tracing propagation (but perhaps with deadline propagation?),
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/2750,36101297,2015-08-03T16:14:13Z,include/grpc/grpc.h,"@@ -351,6 +351,23 @@ typedef struct grpc_op {   } data; } grpc_op; +/* Propagation bits: this can be bitwise or-ed to form propagation_mask for+ * grpc_call */+/** Propagate deadline */+#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)+/** Propagate census context */+#define GRPC_PROPAGATE_CENSUS_CONTEXT ((gpr_uint32)2)","You asked: What if I want to make one RPC without tracing propagation (but perhaps with deadline propagation?)Good question. This would seem to be the best way of doing this (via updating the trace_mask when we start the operation). It raises another issue though, in that we use the census context for more than just tracing - what if I want to disable tracing, but keep stats collection enabled for this request? There are probably a couple of options here:1. Use the GRPC_PROPAGATE_CENSUS_CONTEXT flag to {en/dis}able all features of census that require propagation.2. Explicitly state that the GRPC_PROPAGATE_CENSUS_CONTEXT flag can only be used to disable tracing (leaving other census features that require propagation untouched).3. Add GRPC_PROPAGATE_CENSUS_CONTEXT_X flags for the other census features (RPC stats + CPU accounting) that are done per-context. 3 would be my preference. ",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2750,36103158,2015-08-03T16:32:28Z,include/grpc/grpc.h,"@@ -351,6 +351,23 @@ typedef struct grpc_op {   } data; } grpc_op; +/* Propagation bits: this can be bitwise or-ed to form propagation_mask for+ * grpc_call */+/** Propagate deadline */+#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)+/** Propagate census context */+#define GRPC_PROPAGATE_CENSUS_CONTEXT ((gpr_uint32)2)","Could we find a half-way point perhaps?GRPC_PROPAGATE_STATSGRPC_PROPAGATE_TRACINGOn Mon, Aug 3, 2015 at 9:14 AM Alistair Veitch notifications@github.comwrote:> In include/grpc/grpc.h> https://github.com/grpc/grpc/pull/2750#discussion_r36101297:> > > @@ -351,6 +351,23 @@ typedef struct grpc_op {> >    } data;> >  } grpc_op;> > > > +/\* Propagation bits: this can be bitwise or-ed to form propagation_mask for> > - \* grpc_call _/> >   +/_\* Propagate deadline _/> >   +#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)> >   +/_\* Propagate census context */> >   +#define GRPC_PROPAGATE_CENSUS_CONTEXT ((gpr_uint32)2)> > You asked: What if I want to make one RPC without tracing propagation (but> perhaps with deadline propagation?)> > Good question. This would seem to be the best way of doing this (via> updating the trace_mask when we start the operation). It raises another> issue though, in that we use the census context for more than just tracing> - what if I want to disable tracing, but keep stats collection enabled for>   this request? There are probably a couple of options here:> - Use the GRPC_PROPAGATE_CENSUS_CONTEXT flag to {en/dis}able all features>   of census that require propagation.> - Explicitly state that the GRPC_PROPAGATE_CENSUS_CONTEXT flag can only>   be used to disable tracing (leaving other census features that require>   propagation untouched).> - Add GRPC_PROPAGATE_CENSUS_CONTEXT_X flags for the other census features>   (RPC stats + CPU accounting) that are done per-context.> > 3 would be my preference.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2750/files#r36101297.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2750,36103631,2015-08-03T16:37:19Z,include/grpc/grpc.h,"@@ -351,6 +351,23 @@ typedef struct grpc_op {   } data; } grpc_op; +/* Propagation bits: this can be bitwise or-ed to form propagation_mask for+ * grpc_call */+/** Propagate deadline */+#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)+/** Propagate census context */+#define GRPC_PROPAGATE_CENSUS_CONTEXT ((gpr_uint32)2)","I don't suppose you'd want to send me a PR against this one implementingit? :)On Mon, Aug 3, 2015 at 9:36 AM Alistair Veitch notifications@github.comwrote:> In include/grpc/grpc.h> https://github.com/grpc/grpc/pull/2750#discussion_r36103509:> > > @@ -351,6 +351,23 @@ typedef struct grpc_op {> >    } data;> >  } grpc_op;> > > > +/\* Propagation bits: this can be bitwise or-ed to form propagation_mask for> > - \* grpc_call _/> >   +/_\* Propagate deadline _/> >   +#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)> >   +/_\* Propagate census context */> >   +#define GRPC_PROPAGATE_CENSUS_CONTEXT ((gpr_uint32)2)> > SGTM.> > Could we find a half-way point perhaps?> > GRPC_PROPAGATE_STATS> GRPC_PROPAGATE_TRACING> > —> > Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2750/files#r36103509.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/2713,36126393,2015-08-03T20:18:29Z,src/core/iomgr/pollset_windows.c,"@@ -58,34 +91,66 @@ void grpc_pollset_shutdown(grpc_pollset *pollset,                            void *shutdown_done_arg) {   gpr_mu_lock(&pollset->mu);   pollset->shutting_down = 1;-  gpr_cv_broadcast(&pollset->cv);+  grpc_pollset_kick(pollset, GRPC_POLLSET_KICK_BROADCAST);   gpr_mu_unlock(&pollset->mu);   shutdown_done(shutdown_done_arg); }  void grpc_pollset_destroy(grpc_pollset *pollset) {   gpr_mu_destroy(&pollset->mu);-  gpr_cv_destroy(&pollset->cv); } -int grpc_pollset_work(grpc_pollset *pollset, gpr_timespec deadline) {+int grpc_pollset_work(grpc_pollset *pollset, grpc_pollset_worker *worker, gpr_timespec deadline) {   gpr_timespec now;+  int added_worker = 0;   now = gpr_now(GPR_CLOCK_MONOTONIC);   if (gpr_time_cmp(now, deadline) > 0) {     return 0 /* GPR_FALSE */;   }+  worker->next = worker->prev = NULL;+  gpr_cv_init(&worker->cv);   if (grpc_maybe_call_delayed_callbacks(&pollset->mu, 1 /* GPR_TRUE */)) {-    return 1 /* GPR_TRUE */;+    goto done;   }   if (grpc_alarm_check(&pollset->mu, now, &deadline)) {-    return 1 /* GPR_TRUE */;+    goto done;   }-  if (!pollset->shutting_down) {-    gpr_cv_wait(&pollset->cv, &pollset->mu, deadline);+  if (!pollset->kicked_without_pollers && !pollset->shutting_down) {+    push_front_worker(pollset, worker);+    added_worker = 1;+    gpr_cv_wait(&worker->cv, &pollset->mu, deadline);+  } else {+    pollset->kicked_without_pollers = 0;+  }+done:+  gpr_cv_destroy(&worker->cv);+  if (added_worker) {+    remove_worker(pollset, worker);   }   return 1 /* GPR_TRUE */; } -void grpc_pollset_kick(grpc_pollset *p) { gpr_cv_signal(&p->cv); }+void grpc_pollset_kick(grpc_pollset *p, grpc_pollset_worker *specific_worker) {+  if (specific_worker != NULL) {+    if (specific_worker == GRPC_POLLSET_KICK_BROADCAST) {+      for (specific_worker = p->root_worker.next;",Shouldn't we grab some form of mutex here in order to avoid getting corrupted by grpc_pollset_work that can add or remove elements of that list ?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2713,36133241,2015-08-03T21:20:40Z,src/core/iomgr/pollset_windows.h,"@@ -42,10 +42,17 @@    nature of the IO completion ports. A Windows ""pollset"" is merely a mutex    and a condition variable, used to synchronize with the IOCP. */","So the above comment should be updated to describe the new version of the Windows pollset, something like:A Windows ""pollset"" is merely a mutex used to synchronize with the IOCP, along with a queue of workers that each has its own condition variable.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2780,36151692,2015-08-04T02:02:26Z,src/python/grpcio_test/setup.py,"@@ -48,8 +48,13 @@  _PACKAGE_DATA = {     'grpc_interop': [",Can this be a tuple rather than a list?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2780,36151718,2015-08-04T02:02:47Z,src/python/grpcio_test/setup.py,"@@ -48,8 +48,13 @@  _PACKAGE_DATA = {     'grpc_interop': [-        'credentials/ca.pem', 'credentials/server1.key',-        'credentials/server1.pem',]+        'credentials/ca.pem',+        'credentials/server1.key',+        'credentials/server1.pem',+    ],+    'grpc_protoc_plugin': [",Can this be a tuple rather than a list?,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2775,36212354,2015-08-04T16:54:13Z,src/cpp/client/client_context.cc,"@@ -71,13 +63,26 @@ void ClientContext::AddMetadata(const grpc::string& meta_key,  void ClientContext::set_call(grpc_call* call,                              const std::shared_ptr<ChannelInterface>& channel) {+  {","The existing gpr assert will cause a crash, and I thought the bug is askingfor something nicer.On Aug 4, 2015 9:44 AM, ""Craig Tiller"" notifications@github.com wrote:> In src/cpp/client/client_context.cc> https://github.com/grpc/grpc/pull/2775#discussion_r36211239:> > > @@ -71,13 +63,26 @@ void ClientContext::AddMetadata(const grpc::string& meta_key,> > > >  void ClientContext::set_call(grpc_call\* call,> >                               const std::shared_ptr<ChannelInterface>& channel) {> > -  {> > Do we want to do this or just crash?> > (I'd be ok with crashing)> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2775/files#r36211239.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2775,36219422,2015-08-04T17:54:05Z,src/cpp/client/client_context.cc,"@@ -71,13 +63,26 @@ void ClientContext::AddMetadata(const grpc::string& meta_key,  void ClientContext::set_call(grpc_call* call,                              const std::shared_ptr<ChannelInterface>& channel) {+  {","I thought the bug was asking for the crash (and if it was already, we couldjust close it)... +Abhishek Kumar abhikumar@google.com any opinion?On Tue, Aug 4, 2015 at 9:54 AM Yang Gao notifications@github.com wrote:> In src/cpp/client/client_context.cc> https://github.com/grpc/grpc/pull/2775#discussion_r36212354:> > > @@ -71,13 +63,26 @@ void ClientContext::AddMetadata(const grpc::string& meta_key,> > > >  void ClientContext::set_call(grpc_call\* call,> >                               const std::shared_ptr<ChannelInterface>& channel) {> > -  {> > The existing gpr assert will cause a crash, and I thought the bug is> asking for something nicer.> … <#msg-f:1508593912641580746_>> On Aug 4, 2015 9:44 AM, ""Craig Tiller"" notifications@github.com wrote:> In src/cpp/client/client_context.cc <> https://github.com/grpc/grpc/pull/2775#discussion_r36211239>: > @@ -71,13> +63,26 @@ void ClientContext::AddMetadata(const grpc::string& meta_key, > >> void ClientContext::set_call(grpc_call\* call, > const> std::shared_ptr<ChannelInterface>& channel) { > + { Do we want to do this> or just crash? (I'd be ok with crashing) — Reply to this email directly or> view it on GitHub https://github.com/grpc/grpc/pull/2775/files#r36211239.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/2775/files#r36212354.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/2750,36349766,2015-08-05T20:26:44Z,include/grpc/grpc.h,"@@ -351,6 +353,25 @@ typedef struct grpc_op {   } data; } grpc_op; +/* Propagation bits: this can be bitwise or-ed to form propagation_mask for+ * grpc_call */+/** Propagate deadline */+#define GRPC_PROPAGATE_DEADLINE ((gpr_uint32)1)+/** Propagate census context */+#define GRPC_PROPAGATE_STATS_CONTEXT ((gpr_uint32)2)","Since we're using the census name everywhere else, does it make sense to rename these similar to GRPC_PROPAGATE_CENSUS_STATS_CONTEXT? (I don't mind either way myself, just think of future readers of the code)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2811,36351485,2015-08-05T20:41:21Z,include/grpc++/channel_interface.h,"@@ -57,6 +58,23 @@ class ChannelInterface : public CallHook,   virtual void* RegisterMethod(const char* method_name) = 0;   virtual Call CreateCall(const RpcMethod& method, ClientContext* context,                           CompletionQueue* cq) = 0;++  // Get the current channel state. If the channel is in IDLE and try_to_connect+  // is set to true, try to connect.+  virtual grpc_connectivity_state GetState(bool try_to_connect) = 0;++  // Return the tag on cq when the channel state is changed or deadline expires.+  // GetState needs to called to get the current state.+  template <typename T>+  virtual void NotifyOnStateChange(grpc_connectivity_state last_observed,+                                   const T& deadline,+                                   CompletionQueue* cq, void* tag) = 0;++  // Blocking wait for channel state change or deadline expires.+  // GetState needs to called to get the current state.+  template <typename T>+  virtual bool WaitForStateChange(grpc_connectivity_state last_observed,","I feel like it would be useful (as an addition) to have WaitForState(target_state, last_observed, deadline) - @a11r  thoughts?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2812,36354975,2015-08-05T21:14:27Z,src/python/grpcio_test/grpc_test/framework/face/testing/future_invocation_asynchronous_event_service_test_case.py,"@@ -306,9 +308,10 @@ def testParallelInvocations(self):         second_request = test_messages.request()          first_response_future = self.stub.future_value_in_value_out(-            name, first_request, _TIMEOUT)+            name, first_request, test_constants.SHORT_TIMEOUT)+        # TODO(bug 2039): use SHORT_TIMEOUT instead",I don't understand this - would working around #2039 mean wanting to use LONG_TIMEOUT but having to use SHORT_TIMEOUT instead?Is this something that failed when you ran it in draft with LONG_TIMEOUT in both places in this method body?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2811,36369143,2015-08-05T23:57:24Z,include/grpc++/channel_interface.h,"@@ -57,6 +58,39 @@ class ChannelInterface : public CallHook,   virtual void* RegisterMethod(const char* method_name) = 0;   virtual Call CreateCall(const RpcMethod& method, ClientContext* context,                           CompletionQueue* cq) = 0;++  // Get the current channel state. If the channel is in IDLE and try_to_connect+  // is set to true, try to connect.+  virtual grpc_connectivity_state GetState(bool try_to_connect) = 0;++  // Return the tag on cq when the channel state is changed or deadline expires.+  // GetState needs to called to get the current state.+  virtual void NotifyOnStateChange(grpc_connectivity_state last_observed,","what about:``` cpublic: template <class T> inline void NotifyOnStateChange(..., T deadline, ...) {    TimePoint<T> deadline_tp(deadline);    NotifyOnStateChangeImpl(..., deadline_tp.raw_time(), ...); }private: virtual void NotifyOnStateChangeImpl(..., gpr_timespec deadline, ...);```",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2780,36369270,2015-08-05T23:59:15Z,src/python/grpcio_test/setup.py,"@@ -48,8 +48,13 @@  _PACKAGE_DATA = {     'grpc_interop': [","From offline discussion: this was changed to a tuple earlier, but caused type assertion errors in setuptools. It remains a list thus.",
7341718,zayoo,https://api.github.com/repos/grpc/grpc/pulls/2680,36437508,2015-08-06T16:51:28Z,src/cpp/profiling/endoscope_frontend.cc,"@@ -0,0 +1,147 @@+#include ""src/cpp/profiling/endoscope_frontend.h""++#ifdef GRPC_ENDOSCOPE_PROFILER","Yes. Without it, the backend doesn't exist, and data structures in frontend are not defined.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/2680,36438348,2015-08-06T16:58:55Z,src/core/profiling/endoscope_backend.c,"@@ -0,0 +1,577 @@+#include ""src/core/profiling/endoscope_backend.h""++#include <grpc/support/time.h>+#include <stdio.h>+#include <string.h>+#include <sys/time.h>+#include <sys/syscall.h>+#include <unistd.h>++static gpr_int64 grpc_endo_invalid64 = 0;  /* value written here will be ignored */++static const char *grpc_endo_warning_str = ""MARKER Task Atom Thread "";+typedef enum grpc_endo_warning_enum {  /* values match positions */+  GRPC_ENDO_WARNING_MARKER = 0,+  GRPC_ENDO_WARNING_TASK = 7,+  GRPC_ENDO_WARNING_ATOM = 12,+  GRPC_ENDO_WARNING_THREAD = 17+} grpc_endo_warning_enum;++/* system related functions */++__inline gpr_int64 grpc_endo_cyclenow() {+#if defined(__i386__)+  gpr_int64 ret;+  __asm__ volatile(""rdtsc"" : ""=A""(ret));+  return ret;+#elif defined(__x86_64__) || defined(__amd64__)+  unsigned long long low, high;+  __asm__ volatile(""rdtsc"" : ""=a""(low), ""=d""(high));+  return (high << 32) | low;+#else+#warning ""Endoscope no rdtsc available.""+  static gpr_int64 counter = 0;+  return ++counter;+#endif+}++void grpc_endo_syncclock(gpr_int64 *cycle, double *time) {+  gpr_timespec tv = gpr_now(GPR_CLOCK_REALTIME);+  *cycle = grpc_endo_cyclenow();+  *time = tv.tv_sec + (double)tv.tv_nsec / GPR_NS_PER_SEC;+}++/* warning span and warning print */++static void grpc_endo_warning_span(grpc_endo_base *base, grpc_endo_warning_enum errortype) {+  /* display to client */+  /* deterministic, no thread-safe issue */+  gpr_uint8 i;+  for (i = (gpr_uint8)errortype; grpc_endo_warning_str[i] != ' '; i++) {+    base->warning_msg[i] = grpc_endo_warning_str[i];+  }+  if (base->marker_warning->name == NULL) {+    gpr_int64 cycle_error = grpc_endo_cyclenow();+    base->marker_warning->cycle_created = cycle_error;+    base->task_warning->cycle_begin = cycle_error;+    base->thread_warning->cycle_created = cycle_error;+    base->marker_warning->name = base->warning_msg;+  }+}++static void grpc_endo_warning_print(const char *str) { /* print onto stderr */+  printf(""### Endoscope grpc_endo_warning_print: %s\n"", str);+}++static void grpc_endo_warning_print2(const char *str, const char *s1, const char *s2) {+  printf(""### Endoscope grpc_endo_warning_print: %s (%s) (%s)\n"", str, s1, s2);+}++/* Init */++void grpc_endo_init(grpc_endo_base *base) {+  /* must initialize before any BEGIN/END/EVENT, OK to initialize twice */+  /* deterministic, no thread safety issue with self, but unsafe with others */+  GRPC_ENDO_INDEX i;++  /* mutex_init */+  gpr_mu_init(&(base->mutex));++  /* instance-global variables */+  base->marker_count = 0;+  base->task_stack = 0;+  base->task_history_head = GRPC_ENDO_EMPTY;+  base->task_history_tail = GRPC_ENDO_EMPTY;+  base->task_withatom_head = GRPC_ENDO_EMPTY;+  base->task_withatom_tail = GRPC_ENDO_EMPTY;+  base->task_count = 0;+  base->atom_stack = 0;+  base->thread_count = 0;+  base->marker_warning = &(base->marker_pool[GRPC_ENDO_MARKER_CAPACITY]);+  base->task_warning = &(base->task_pool[GRPC_ENDO_TASK_CAPACITY]);+  base->thread_warning = &(base->thread_pool[GRPC_ENDO_THREAD_CAPACITY]);+  for (i = 0; i < sizeof(base->warning_msg); i++) {+    base->warning_msg[i] = ' ';+  }+  base->warning_msg[sizeof(base->warning_msg) - 1] = '\0';++  /* sync clock */+  grpc_endo_syncclock(&(base->cycle_sync), &(base->time_sync));+  base->cycle_begin = base->cycle_sync;+  base->time_begin = base->time_sync;++  /* arrays */+  for (i = 0; i < GRPC_ENDO_HASHSIZE; i++) {+    base->marker_map[i] = GRPC_ENDO_EMPTY;+  }+  for (i = 0; i < GRPC_ENDO_MARKER_CAPACITY; i++) {+    base->marker_pool[i].name = NULL;  /* as new */+    base->marker_pool[i].timestamp = 0;  /* important */+  }+  for (i = 0; i < GRPC_ENDO_ATOM_CAPACITY; i++) {+    base->atom_pool[i].next_atom = i + 1;+  }+  base->atom_pool[GRPC_ENDO_ATOM_CAPACITY - 1].next_atom = GRPC_ENDO_EMPTY;+  for (i = 0; i < GRPC_ENDO_TASK_CAPACITY; i++) {+    base->task_pool[i].next_task = i + 1;+    base->task_pool[i].next_taskwithatom = GRPC_ENDO_EMPTY;+    base->task_pool[i].log_head = GRPC_ENDO_EMPTY;+  }+  base->task_pool[GRPC_ENDO_TASK_CAPACITY - 1].next_task = GRPC_ENDO_EMPTY;+  for (i = 0; i < GRPC_ENDO_THREAD_CAPACITY; i++) {+    base->thread_pool[i].cycle_created = 0;  /* as new */+    base->thread_pool[i].timestamp = 0;  /* important */+  }++  /* error span */+  base->marker_warning->name = NULL;+  base->marker_warning->type = 2;  /* EndoMarkerPB::TASK */+  base->marker_warning->file = ""ERROR"";+  base->marker_warning->line = 0;+  base->marker_warning->function_name = ""ERROR"";+  base->marker_warning->timestamp = -1;+  base->marker_warning->next_marker = GRPC_ENDO_EMPTY;++  base->task_warning->task_id = 0x00ffffff;+  base->task_warning->marker_id = GRPC_ENDO_MARKER_CAPACITY;+  base->task_warning->thread_index = GRPC_ENDO_THREAD_CAPACITY;+  base->task_warning->cycle_end = -1;+  base->task_warning->log_head = GRPC_ENDO_EMPTY;+  base->task_warning->log_tail = GRPC_ENDO_EMPTY;+  base->task_warning->scope_depth = 0;+  base->task_warning->next_task = GRPC_ENDO_EMPTY;+  base->task_warning->next_taskwithatom = GRPC_ENDO_EMPTY;++  base->thread_warning->thread_id = 0;+  base->thread_warning->task_active = GRPC_ENDO_TASK_CAPACITY;+  base->thread_warning->timestamp = -1;+}++void grpc_endo_destroy(grpc_endo_base *base) {+  /* only free dynamic data to prevent leakage */+#ifdef GRPC_ENDO_COPY_MARKER_NAME+  GRPC_ENDO_INDEX i;+  for (i = 0; i < GRPC_ENDO_MARKER_CAPACITY; i++) {+    free(base->marker_pool[i].name);+  }+#endif+  gpr_mu_destroy(&(base->mutex));+}++/* Get, Create, and Delete Elements */++static GRPC_ENDO_INDEX grpc_endo_create_marker(grpc_endo_base *base, GRPC_ENDO_INDEX next_index) {+  /* must be called inside mutex */+  if (base->marker_count >= GRPC_ENDO_MARKER_CAPACITY) {+    grpc_endo_warning_print(""grpc_endo_create_marker: no marker item available (reached capacity)"");+    grpc_endo_warning_span(base, GRPC_ENDO_WARNING_MARKER);+    return GRPC_ENDO_EMPTY;+  } else {+    GRPC_ENDO_INDEX marker_id = base->marker_count++;+    /* base->marker_pool[marker_id].name = NULL already initialized */+    base->marker_pool[marker_id].next_marker = next_index;+    return marker_id;+  }+}++static GRPC_ENDO_INDEX grpc_endo_get_or_create_marker(+    grpc_endo_base *base, gpr_int32 line, const char *name) {+  /* thread safe applied */+  GRPC_ENDO_INDEX *q;+  gpr_int16 fallback;+  /* begin hash function */+  gpr_uint32 hash = line;+  const char *c;+  for (c = name; *c != '\0'; c++) {+    hash += *c;+    hash += (hash << 10);+    hash ^= (hash >> 6);+  }+  hash += (hash << 3);+  hash ^= (hash >> 11);+  hash += (hash << 15);+  /* end hash function */+  q = &(base->marker_map[hash % GRPC_ENDO_HASHSIZE]);+  for (fallback = 100; fallback > 1; fallback--) {",A longer text explanation in a comment above this loop of what the algorithm does and when it's invoked would help tremendously.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2816,36448883,2015-08-06T18:33:23Z,src/python/grpcio_health_checking/grpc/health/v1alpha/health.py,"@@ -0,0 +1,73 @@+import abc+import enum+from grpc.health.v1alpha import health_pb2+++@enum.unique+class HealthStatus(enum.Enum):+  UNKNOWN = health_pb2.HealthCheckResponse.UNKNOWN+  SERVING = health_pb2.HealthCheckResponse.SERVING+  NOT_SERVING = health_pb2.HealthCheckResponse.NOT_SERVING+++class _HealthServicer(health_pb2.EarlyAdopterHealthServicer):++  def __init__(self):+    self._server_status = {}++  def Check(self, request, context):+    server_key = (request.host, request.service,)+    return health_pb2.HealthCheckResponse(+        status=self._server_status[server_key].value)++  def set(host, service, status):+    if not isinstance(status, HealthStatus):+      raise TypeError('expected grpc.health.v1alpha.health.HealthStatus')+    self._server_status[(host, service)] = status+++class HealthServer(EarlyAdopterHealthServer):",Missing module name before inherited class name?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2816,36465836,2015-08-06T21:07:39Z,src/python/grpcio_health_checking/grpc/health/v1alpha/health.py,"@@ -0,0 +1,124 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Reference implementation for health checking in gRPC Python.""""""++import abc+import enum+import threading++from grpc.health.v1alpha import health_pb2+++@enum.unique+class HealthStatus(enum.Enum):","Are we sure we want to define a new class that just reexports the values defined in the protocol buffer module? I'm pretty sure that we do, but not completely sure. Do the other languages do something like this?",
5148308,DavidPhillipOster,https://api.github.com/repos/grpc/grpc/pulls/2838,36518573,2015-08-07T13:34:37Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -78,6 +78,7 @@ - (instancetype)initWithAddress:(NSString *)address {     if (cachedHost) {       return cachedHost;     }+  }","This   @synchronized block isn't correct. @synchronized only works if both the only reader and the only writer of hostCache are inside the block.As written, the only writer, line ~86, is outside the @synchronized which leads to a non-thread-safe race condition",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/2838,36533182,2015-08-07T16:00:57Z,src/objective-c/GRPCClient/GRPCCall+OAuth2.h,"@@ -0,0 +1,49 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCCall.h""++// Helpers for setting and reading headers compatible with OAuth2.+@interface GRPCCall (OAuth2)++// Setting this property is equivalent to setting ""Bearer <passed token>"" as the value of the+// request header with key ""authorization"" (the authorization header). Setting it to nil removes the+// authorization header from the request.+// The value obtained by getting the property is the OAuth2 bearer token if the authorization header+// of the request has the form ""Bearer <token>"", or nil otherwise.+@property(atomic, copy) NSString *oauth2_accessToken;","The underscore was for the category prefix, but given that it's part of the library and not a category written by a 3rd party, camelcase seems more appropriate to me too.",
5148308,DavidPhillipOster,https://api.github.com/repos/grpc/grpc/pulls/2861,36581386,2015-08-08T20:17:47Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -139,8 +146,10 @@ - (void)finishWithError:(NSError *)errorOrNil {   _self = nil;","This _self = nil; is very peculiar, and doesn't do anything, since self must be of storage class unsafe_unretained or Objective-C could not work. If you want an object to retain itself while a call is in progress you can have an instance variable:GRPCCall *_retainSelf;and when you want to make sure it will not be dealloc'ed, do a _retainSelf = self;and in the finish, do:_retainSelf = nil;but there better be timeout error callbacks on the finish, or calls GRPCCalls that wait forever will never get dealloc'ed ",
5148308,DavidPhillipOster,https://api.github.com/repos/grpc/grpc/pulls/2861,36581421,2015-08-08T20:21:04Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -139,8 +146,10 @@ - (void)finishWithError:(NSError *)errorOrNil {   _self = nil;    // If there were still request messages coming, stop them.-  _requestWriter.state = GRXWriterStateFinished;-  _requestWriter = nil;+  @synchronized(_requestWriter) {",I'm surprised Xcode's 'Analyze' command didn't flag this: _requestWriter is sometimes nil (in fact it is set to nil inside the block) and you should never @synchronize(nil)did you mean:@synchronized(self) { ... } ?since you need to synchronize on an object with a lifetime longer than the @synchronized block,
5148308,DavidPhillipOster,https://api.github.com/repos/grpc/grpc/pulls/2861,36582723,2015-08-08T23:03:53Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -139,8 +146,10 @@ - (void)finishWithError:(NSError *)errorOrNil {   _self = nil;","I don't think it is possible to pick a single default value that will make sense in all circumstances - sufficiently long that calls that will eventually succeed aren't needlessly pruned (think space probes that are light-days away) yet sufficiently short that RAM doesn't fill up with calls that are uselessly old. Best to document that calls in-flight retain themselves until they either complete or are cancelled, or give up on the retain idea, and just add a dealloc that cancels if needed so that it's the client programmer's responsibility to keep references to calls-in-flight that the client cares about.Maybe set the default to 1 minute,  with a header comment documenting that the client programmer may need to change this.See http://www.ibiblio.org/harris/500milemail.html for more information.",
5148308,DavidPhillipOster,https://api.github.com/repos/grpc/grpc/pulls/2861,36582851,2015-08-08T23:25:05Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -139,8 +146,10 @@ - (void)finishWithError:(NSError *)errorOrNil {   _self = nil;    // If there were still request messages coming, stop them.-  _requestWriter.state = GRXWriterStateFinished;-  _requestWriter = nil;+  @synchronized(_requestWriter) {",> I was going by this: http://rykap.com/objective-c/2015/05/09/synchronized.html. Please don't depend on undocumented behavior. 'undocumented behavior' is defined as 'behavior that has not been documented by Apple'It looks like you  do want @synchronized(_requestWriter) {  _requestWriter.state = GRXWriterStateFinished;}_requestWriter = nil;as long as all objects that look at the same requestWriter @synchronize on that requestWriter - races are things like:if (_requestWriter.state != GRXWriterStateXXX) {   _requestWriter.state = GRXWriterStateYYY;}An if () {} like this would have to be inside a @synchronized(_requestWriter) { },
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/2861,36583146,2015-08-09T00:25:05Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -139,8 +146,10 @@ - (void)finishWithError:(NSError *)errorOrNil {   _self = nil;","> Maybe set the default to 1 minute, with a header comment documenting that the client programmer may need to change this.TVL is strongly against us documenting the very possibility of setting a timeout :) His experience is people tend to set timeouts like 30s that work fine in a Sillicon Valley office, but are unrealistically low for developing countries.I think the best option is indeed to document clearly that calls in-flight retain themselves, and that if it becomes too hard on memory for someone's use case, they can keep a reference to the call object and cancel it when they receive a memory warning.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/2806,36681268,2015-08-10T20:38:12Z,doc/health-checking.md,"@@ -0,0 +1,69 @@+GRPC Health Checking Protocol+================================++Health checks are used to probe whether the server is able to handle rpcs. The+client-to-server health checking can happen from point to point or via some+control system. A server may choose to reply “unhealthy” because it+is not ready to take requests, it is shutting down or some other reason.+The client can act accordingly if the response is not received within some time+window or the response says unhealthy in it.+++A GRPC service is used as the health checking mechanism for both simple+client-to-server scenario and other control systems such as load-balancing.+Being a high+level service provides some benefits. Firstly, since it is a GRPC service+itself, doing a health check is in the same format as a normal rpc. Secondly,+it has rich semantics such as per-service health status. Thirdly, as a GRPC+service, it is able reuse all the existing billing, quota infrastructure, etc,+and thus the server has full control over the access of the health checking+service.++## Service Definition++The server should export a service defined in the following proto:++```+syntax = ""proto3"";++package grpc.health.v1alpha;++message HealthCheckRequest {+  string service = 1;+}++message HealthCheckResponse {+  enum ServingStatus {+    UNKNOWN = 0;+    SERVING = 1;+    NOT_SERVING = 2;+  }+  ServingStatus status = 1;+}++service Health {+  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);+}+```++A client can query the server’s health status by calling the `Check` method, and+a deadline should be set on the rpc. The client can optionally set the service+name it wants to query for health status. The suggested format of service name+is `package_names.ServiceName`, such as `grpc.health.v1alpha.Health`.++The server should register all the services manually and set+the individual status, including an empty service name and its status. For each+request received, if the service name can be found in the registry,+a response must be sent back with an `OK` status and the status field should be+set to `SERVING` or `NOT_SERVING` accordingly. If the service name is not+registered, the server returns a `NOT_FOUND` GRPC status.++It is recommended that the server use an empty string as the key for server’s","This wishy-washy ""you can do whatever you want"" seems like it would be harmful, as it doesn't actually allow you to make a client that is compatible with all servers supporting this service (and thus, this spec would be useless). At the very least, we must clearly specify the meaning of empty-string.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2879,36696487,2015-08-10T23:20:00Z,src/cpp/client/secure_credentials.cc,"@@ -61,6 +62,7 @@ std::shared_ptr<Credentials> WrapCredentials(grpc_credentials* creds) { }  // namespace  std::shared_ptr<Credentials> GoogleDefaultCredentials() {+  GrpcLibrary init;  // To call grpc_init().","From https://github.com/grpc/grpc/blob/master/include/grpc/grpc.h#L378, it seems we should do it in the C++ layer. Maybe even add it to all the XXCredentials() functions just to be safe?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2878,36753455,2015-08-11T14:48:46Z,src/python/grpcio/grpc/_adapter/_types.py,"@@ -321,6 +354,28 @@ def create_call(self, completion_queue, method, host, deadline=float('+inf')):     """"""     return None +  @abc.abstractmethod+  def connectivity_state(self, try_to_connect=False):",Please avoid optional parameters on internal APIs. It's no trouble to us to always be explicit about passing the parameter all the time.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2878,36753540,2015-08-11T14:49:35Z,src/python/grpcio/grpc/_adapter/_types.py,"@@ -138,39 +161,40 @@ class OpArgs(collections.namedtuple(     message (bytes): Only valid if type == OpType.SEND_MESSAGE, else is None.     status (Status): Only valid if type == OpType.SEND_STATUS_FROM_SERVER, else       is None.+    write_flags (int): a bit OR'ing of 0 or more OpWriteFlags values.   """"""    @staticmethod   def send_initial_metadata(initial_metadata):-    return OpArgs(OpType.SEND_INITIAL_METADATA, initial_metadata, None, None, None)+    return OpArgs(OpType.SEND_INITIAL_METADATA, initial_metadata, None, None, None, 0)    @staticmethod-  def send_message(message):-    return OpArgs(OpType.SEND_MESSAGE, None, None, message, None)+  def send_message(message, flags=0):",I'm wary of optional parameters on internal APIs. Can this be required?,
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/2888,36813353,2015-08-11T23:45:26Z,src/ruby/ext/grpc/rb_channel.c,"@@ -203,7 +203,10 @@ static VALUE grpc_rb_channel_create_call(VALUE self, VALUE cqueue, VALUE method,   grpc_channel *ch = NULL;   grpc_completion_queue *cq = NULL;   char *method_chars = StringValueCStr(method);-  char *host_chars = StringValueCStr(host);+  char *host_chars = NULL;+  if (host != Qnil) {","- I opted for flexibility - still allowing the host can still be set, though none of the library code does so at the moment.   This should make it possible to support different hosts later with just ruby changes.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2771,36818489,2015-08-12T01:11:46Z,test/cpp/qps/client.h,"@@ -41,6 +41,8 @@  #include <condition_variable> #include <mutex>+#include <grpc++/config.h>+#include <grpc++/config.h>",duplicated line,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2771,36820789,2015-08-12T02:03:35Z,test/cpp/qps/client_async.cc,"@@ -316,23 +317,28 @@ class AsyncClient : public Client {   }   private:-  class boolean { // exists only to avoid data-race on vector<bool>+  class boolean {  // exists only to avoid data-race on vector<bool>","It'd be interested to know the back-story on this one... I'm aware of the template specialization that happens in the STL for vector<bool>, but which data-races was it causing?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2771,36820830,2015-08-12T02:04:43Z,test/cpp/qps/client_async.cc,"@@ -348,15 +354,17 @@ class AsyncUnaryClient GRPC_FINAL : public AsyncClient {   ~AsyncUnaryClient() GRPC_OVERRIDE { EndThreads(); }   private:+  static void CheckDone(grpc::Status s, SimpleResponse* response) {}+  static std::unique_ptr<grpc::ClientAsyncResponseReader<SimpleResponse>>","old compilers may dislike the use of "">>"". It used to be written as ""> >"" to break the ambiguity with the rightshift op",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2816,36904655,2015-08-12T19:45:13Z,src/python/grpcio_health_checking/grpc/health/v1alpha/health.proto,"@@ -0,0 +1,50 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++syntax = ""proto3"";++package grpc.health.v1alpha;++message HealthCheckRequest {+  string host = 1;",Could you take a look at https://github.com/grpc/grpc/blob/master/doc/health-checking.md and update the proto/cl accordingly? Sorry for the late spec change.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2549,36985911,2015-08-13T15:13:35Z,src/core/client_config/resolvers/zookeeper_resolver.c,"@@ -0,0 +1,495 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/client_config/resolvers/zookeeper_resolver.h""++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/string_util.h>++#include <grpc/grpc_zookeeper.h>+#include <zookeeper/zookeeper.h>++#include ""src/core/client_config/lb_policies/pick_first.h""+#include ""src/core/client_config/resolver_registry.h""+#include ""src/core/iomgr/resolve_address.h""+#include ""src/core/support/string.h""+#include ""src/core/json/json.h""++/** Zookeeper session expiration time in milliseconds */+#define GRPC_ZOOKEEPER_SESSION_TIMEOUT 15000++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;+  /** name to resolve */+  char *name;+  /** subchannel factory */+  grpc_subchannel_factory *subchannel_factory;+  /** load balancing policy factory */+  grpc_lb_policy *(*lb_policy_factory)(grpc_subchannel **subchannels,+                                       size_t num_subchannels);++  /** mutex guarding the rest of the state */+  gpr_mu mu;+  /** are we currently resolving? */+  int resolving;+  /** which version of resolved_config have we published? */+  int published_version;+  /** which version of resolved_config is current? */+  int resolved_version;+  /** pending next completion, or NULL */+  grpc_iomgr_closure *next_completion;+  /** target config address for next completion */+  grpc_client_config **target_config;+  /** current (fully resolved) config */+  grpc_client_config *resolved_config;++  /** zookeeper handle */+  zhandle_t *zookeeper_handle;+  /** zookeeper resolved addresses */+  grpc_resolved_addresses *resolved_addrs;+  /** total number of addresses to be resolved */+  int resolved_total;+  /** number of addresses resolved */+  int resolved_num;+} zookeeper_resolver;++static void zookeeper_destroy(grpc_resolver *r);++static void zookeeper_start_resolving_locked(zookeeper_resolver *r);+static void zookeeper_maybe_finish_next_locked(zookeeper_resolver *r);++static void zookeeper_shutdown(grpc_resolver *r);+static void zookeeper_channel_saw_error(grpc_resolver *r,+                                        struct sockaddr *failing_address,+                                        int failing_address_len);+static void zookeeper_next(grpc_resolver *r, grpc_client_config **target_config,+                           grpc_iomgr_closure *on_complete);++static const grpc_resolver_vtable zookeeper_resolver_vtable = {+    zookeeper_destroy, zookeeper_shutdown, zookeeper_channel_saw_error,+    zookeeper_next};++static void zookeeper_shutdown(grpc_resolver *resolver) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (r->next_completion != NULL) {+    *r->target_config = NULL;+    grpc_iomgr_add_callback(r->next_completion);+    r->next_completion = NULL;+  }+  zookeeper_close(r->zookeeper_handle);+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_channel_saw_error(grpc_resolver *resolver,+                                        struct sockaddr *sa, int len) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  if (r->resolving == 0) {+    zookeeper_start_resolving_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++static void zookeeper_next(grpc_resolver *resolver,+                           grpc_client_config **target_config,+                           grpc_iomgr_closure *on_complete) {+  zookeeper_resolver *r = (zookeeper_resolver *)resolver;+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(r->next_completion == NULL);+  r->next_completion = on_complete;+  r->target_config = target_config;+  if (r->resolved_version == 0 && r->resolving == 0) {+    zookeeper_start_resolving_locked(r);+  } else {+    zookeeper_maybe_finish_next_locked(r);+  }+  gpr_mu_unlock(&r->mu);+}++/** Zookeeper global watcher for connection management */+static void zookeeper_global_watcher(zhandle_t *zookeeper_handle, int type,+                                     int state, const char *path,+                                     void *watcher_ctx) {+  if (type == ZOO_SESSION_EVENT) {+    if (state == ZOO_EXPIRED_SESSION_STATE) {+      gpr_log(GPR_ERROR, ""Zookeeper session expired"");+    } else if (state == ZOO_AUTH_FAILED_STATE) {+      gpr_log(GPR_ERROR, ""Zookeeper authentication failed"");+    }+  }+}++/** Zookeeper watcher for handling updates to watched nodes */+static void zookeeper_watcher(zhandle_t *zookeeper_handle, int type, int state,+                              const char *path, void *watcher_ctx) {+  if (watcher_ctx != NULL) {+    zookeeper_resolver *r = (zookeeper_resolver *)watcher_ctx;+    if (state == ZOO_CONNECTED_STATE) {+      gpr_mu_lock(&r->mu);+      if (r->resolving == 0) {+        zookeeper_start_resolving_locked(r);+      }+      gpr_mu_unlock(&r->mu);+    }+  }+}++static void zookeeper_on_resolved(void *arg,+                                  grpc_resolved_addresses *addresses) {+  zookeeper_resolver *r = arg;+  grpc_client_config *config = NULL;+  grpc_subchannel **subchannels;+  grpc_subchannel_args args;+  grpc_lb_policy *lb_policy;+  size_t i;+  if (addresses != NULL) {+    config = grpc_client_config_create();+    subchannels = gpr_malloc(sizeof(grpc_subchannel *) * addresses->naddrs);+    for (i = 0; i < addresses->naddrs; i++) {+      memset(&args, 0, sizeof(args));+      args.addr = (struct sockaddr *)(addresses->addrs[i].addr);+      args.addr_len = addresses->addrs[i].len;+      subchannels[i] = grpc_subchannel_factory_create_subchannel(+          r->subchannel_factory, &args);+    }+    lb_policy = r->lb_policy_factory(subchannels, addresses->naddrs);+    grpc_client_config_set_lb_policy(config, lb_policy);+    GRPC_LB_POLICY_UNREF(lb_policy, ""construction"");+    grpc_resolved_addresses_destroy(addresses);+    gpr_free(subchannels);+  }+  gpr_mu_lock(&r->mu);+  GPR_ASSERT(r->resolving == 1);+  r->resolving = 0;+  if (r->resolved_config != NULL) {+    grpc_client_config_unref(r->resolved_config);+  }+  r->resolved_config = config;+  r->resolved_version++;+  zookeeper_maybe_finish_next_locked(r);+  gpr_mu_unlock(&r->mu);++  GRPC_RESOLVER_UNREF(&r->base, ""zookeeper-resolving"");+}++/** Callback function for each DNS resolved address */+static void zookeeper_dns_resolved(void *arg,+                                   grpc_resolved_addresses *addresses) {+  size_t i;+  zookeeper_resolver *r = arg;+  int resolve_done = 0;++  gpr_mu_lock(&r->mu);+  r->resolved_num++;+  r->resolved_addrs->addrs =+      gpr_realloc(r->resolved_addrs->addrs,+                  sizeof(grpc_resolved_address) *+                      (r->resolved_addrs->naddrs + addresses->naddrs));+  for (i = 0; i < addresses->naddrs; i++) {+    memcpy(r->resolved_addrs->addrs[i + r->resolved_addrs->naddrs].addr,+           addresses->addrs[i].addr, addresses->addrs[i].len);+    r->resolved_addrs->addrs[i + r->resolved_addrs->naddrs].len =+        addresses->addrs[i].len;+  }++  r->resolved_addrs->naddrs += addresses->naddrs;+  grpc_resolved_addresses_destroy(addresses);++  /** Wait for all addresses to be resolved */+  resolve_done = (r->resolved_num == r->resolved_total);+  gpr_mu_unlock(&r->mu);+  if (resolve_done) {+    zookeeper_on_resolved(r, r->resolved_addrs);+  }+}++/** Parse json format address of a zookeeper node */+static char *zookeeper_parse_address(char *buffer, int buffer_len) {+  const char *host;+  const char *port;+  char *address;+  grpc_json *json;+  grpc_json *cur;++  address = NULL;+  json = grpc_json_parse_string_with_len(buffer, buffer_len);+  if (json != NULL) {+    host = NULL;+    port = NULL;+    for (cur = json->child; cur != NULL; cur = cur->next) {+      if (!strcmp(cur->key, ""host"")) {+        host = cur->value;+        if (port != NULL) {+          break;+        }+      } else if (!strcmp(cur->key, ""port"")) {+        port = cur->value;+        if (host != NULL) {+          break;+        }+      }+    }+    if (host != NULL && port != NULL) {+      gpr_asprintf(&address, ""%s:%s"", host, port);+    }+    grpc_json_destroy(json);+  }++  return address;+}++static void zookeeper_get_children_node_completion(int rc, const char *value,+                                                   int value_len,+                                                   const struct Stat *stat,+                                                   const void *arg) {+  char *address = NULL;+  char *buffer = NULL;+  zookeeper_resolver *r = (zookeeper_resolver *)arg;+  int resolve_done = 0;++  if (rc != 0) {+    gpr_log(GPR_ERROR, ""Error in getting a child node of %s"", r->name);+    return;+  }++  buffer = gpr_malloc(value_len);+  memcpy(buffer, value, value_len);+  address = zookeeper_parse_address(buffer, value_len);+  gpr_free(buffer);+  if (address != NULL) {+    /** Further resolve address by DNS */+    grpc_resolve_address(address, NULL, zookeeper_dns_resolved, r);+    gpr_free(address);+  } else {+    gpr_log(GPR_ERROR, ""Error in resolving a child node of %s"", r->name);+    gpr_mu_lock(&r->mu);+    r->resolved_total--;+    resolve_done = (r->resolved_num == r->resolved_total);+    gpr_mu_unlock(&r->mu);+    if (resolve_done) {+      zookeeper_on_resolved(r, r->resolved_addrs);+    }+  }+}++static void zookeeper_get_children_completion(+    int rc, const struct String_vector *children, const void *arg) {+  char *path;+  int status;+  int i;+  zookeeper_resolver *r = (zookeeper_resolver *)arg;++  if (rc != 0) {+    gpr_log(GPR_ERROR, ""Error in getting zookeeper children of %s"", r->name);+    return;+  }++  if (children->count == 0) {+    gpr_log(GPR_ERROR, ""Error in resolving zookeeper address %s"", r->name);+    return;+  }++  r->resolved_addrs = gpr_malloc(sizeof(grpc_resolved_addresses));+  r->resolved_addrs->addrs = NULL;+  r->resolved_addrs->naddrs = 0;+  r->resolved_total = children->count;++  for (i = 0; i < children->count; i++) {+    gpr_asprintf(&path, ""%s/%s"", r->name, children->data[i]);","is there an upper bound to the length of r->name and children->data[i]? If there is, you could preallocate a char path[N] and construct ""path"" more efficiently, avoiding expensive heap allocations and deallocations inside a for loop.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/2877,37001952,2015-08-13T17:35:28Z,src/php/lib/Grpc/BaseStub.php,"@@ -75,6 +75,48 @@ public function getTarget() {   }    /**+   * @param $try_to_connect bool+   * @return int The grpc connectivity state+   */+  public function getConnectivityState($try_to_connect = false) {+    return $this->channel->getConnectivityState($try_to_connect);+  }++  /**+   * @param $timeout in microseconds+   * @return bool true if channel is ready+   */+  public function watchForReady($timeout) {+    $new_state = $this->getConnectivityState(true);+    if ($this->_checkConnectivityState($new_state)) {+      return true;+    }++    $now = Timeval::now();+    $delta = new Timeval($timeout);+    $deadline = $now->add($delta);",I'm not sure it's a good idea to have some methods that take deadline parameters and others that take timeout parameters.,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/2877,37002459,2015-08-13T17:40:22Z,src/php/lib/Grpc/BaseStub.php,"@@ -75,6 +75,48 @@ public function getTarget() {   }    /**+   * @param $try_to_connect bool+   * @return int The grpc connectivity state+   */+  public function getConnectivityState($try_to_connect = false) {+    return $this->channel->getConnectivityState($try_to_connect);+  }++  /**+   * @param $timeout in microseconds+   * @return bool true if channel is ready+   */+  public function watchForReady($timeout) {+    $new_state = $this->getConnectivityState(true);+    if ($this->_checkConnectivityState($new_state)) {+      return true;+    }++    $now = Timeval::now();+    $delta = new Timeval($timeout);+    $deadline = $now->add($delta);","Currently, all the exposed PHP level API takes `timeout`, which got translated to `deadline` when passed to the C layer. (actually there are only 2 places like this, one when initiating a `Call` object and the other here). Is that OK to keep this?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/2549,37030771,2015-08-13T21:58:59Z,include/grpc/grpc.h,"@@ -355,6 +355,20 @@ typedef struct grpc_op {   } data; } grpc_op; ++/** Registers a plugin to be initialized and deinitialized with the library.","1) change ""deinitialized"" to ""destroyed"". Same for the argument ""deinit"" -> ""destroy""2) Replace all but the intro line with the following:> The \a init and \a destroy functions will be invoked as part of \a grpc_init() and \a grpc_shutdown(), respectively. Note that these functions can be invoked an arbitrary number of times (and hence so will \a init and \a destroy). > It is safe to pass NULL to either argument. Plugins are destroyed in the reverse order they were initialized.The last line is only true if you implement Nico's comment to use an array instead of the current linked list to hold the registered plugins.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/2934,37045027,2015-08-14T02:14:13Z,src/ruby/bin/interop/interop_client.rb,"@@ -228,6 +228,26 @@ def compute_engine_creds     p 'OK: compute_engine_creds'   end +  def oauth2_auth_token+    auth_creds = Google::Auth.get_application_default(@args.oauth_scope)+    kw = auth_creds.updater_proc.call({})+    resp = perform_large_unary(fill_username: true,+                               fill_oauth_scope: true,+                               **kw)+    json_key = File.read(ENV[AUTH_ENV])+    wanted_email = MultiJson.load(json_key)['client_email']+    assert_equal(wanted_email, resp.username,+                ""#{__callee__}: incorrect username"")+    assert(@args.oauth_scope.include?(resp.oauth_scope),+           ""#{__callee__}: incorrect oauth_scope"")+    p ""OK: #{__callee__}""+  end++  # Due to the functional interface of the Credentials implementation used by+  # google-auth-library ruby, per_rpc_creds and oauth2_auth_token are+  # fundamentally the same test.","In my implementation, `oauth2_auth_token` uses a metadata updater function attached to the stub, and `per_rpc_creds` directly passes the metadata to the call. Why not do that?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2942,37112378,2015-08-14T19:45:46Z,src/node/ext/call.cc,"@@ -502,6 +502,22 @@ NAN_METHOD(Call::New) {         return NanThrowTypeError(             ""Call's third argument must be a date or a number"");       }+      // These arguments are at the end because they are optional+      grpc_call *parent_call = NULL;+      if (Call::HasInstance(args[4])) {+        Call *parent_obj = ObjectWrap::Unwrap<Call>(args[4]->ToObject());+        parent_call = parent_obj->wrapped_call;+      } else if (!(args[4]->IsUndefined() || args[4]->IsNull())) {+        return NanThrowTypeError(+            ""Call's fifth argument must be another call, if provided"");+      }+      gpr_uint32 propagate_flags = GRPC_PROPAGATE_DEFAULTS;+      if (args[5]->IsUint32()) {+        propagate_flags = args[5]->Uint32Value();+      } else if (!(args[5]->IsUndefined() || args[5]->IsNull())) {","Is there a way in Node to specify names of parameters when calling a function? If not, isn't 5 parameters for a call a bit too much?",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/2942,37113172,2015-08-14T19:55:05Z,src/node/ext/call.cc,"@@ -502,6 +502,22 @@ NAN_METHOD(Call::New) {         return NanThrowTypeError(             ""Call's third argument must be a date or a number"");       }+      // These arguments are at the end because they are optional+      grpc_call *parent_call = NULL;+      if (Call::HasInstance(args[4])) {+        Call *parent_obj = ObjectWrap::Unwrap<Call>(args[4]->ToObject());+        parent_call = parent_obj->wrapped_call;+      } else if (!(args[4]->IsUndefined() || args[4]->IsNull())) {+        return NanThrowTypeError(+            ""Call's fifth argument must be another call, if provided"");+      }+      gpr_uint32 propagate_flags = GRPC_PROPAGATE_DEFAULTS;+      if (args[5]->IsUint32()) {+        propagate_flags = args[5]->Uint32Value();+      } else if (!(args[5]->IsUndefined() || args[5]->IsNull())) {","No, Node does not have named parameters. And yes, 6 parameters is a lot. But this is wrapping a function that takes 8 parameters.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/2948,37125121,2015-08-14T22:23:51Z,src/core/iomgr/tcp_windows.c,"@@ -207,9 +219,12 @@ static void win_notify_on_read(grpc_endpoint *ep,    /* Did we get data immediately ? Yay. */   if (info->wsa_error != WSAEWOULDBLOCK) {+    /* To avoid recursing forever, let's delay the callback for now. */","if this a temporary workaround, please add TODO: so it's obvious.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/2948,37130358,2015-08-15T00:30:29Z,src/core/iomgr/tcp_windows.c,"@@ -207,9 +219,12 @@ static void win_notify_on_read(grpc_endpoint *ep,    /* Did we get data immediately ? Yay. */   if (info->wsa_error != WSAEWOULDBLOCK) {+    /* To avoid recursing forever, let's delay the callback for now. */","This is a temporary workaround in the sense that the endpoint refactoring will take care of that. The code will be completely refactored away anyway in a greater, broader change that'll affect all platforms, not just Windows.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2933,37221982,2015-08-17T18:44:25Z,include/grpc++/auth_metadata_processor.h,"@@ -0,0 +1,64 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_AUTH_METADATA_PROCESSOR_H_+#define GRPCXX_AUTH_METADATA_PROCESSOR_H_++#include <map>+#include <string>++#include <grpc++/auth_context.h>++namespace grpc {++class AuthMetadataProcessor {+ public:+  virtual ~AuthMetadataProcessor() {}++  // If this method returns true, the Process function will be scheduled in+  // a different thread as the one processing the call.+  virtual bool IsBlocking() const { return true; }++  // context is read/write: it contains the properties of the channel peer and+  // it is the job of the Process method to augment it with properties derived+  // from the passed-in auth_metadata.+  virtual bool Process(",Document return value and consumed_auth_metadata?,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2933,37222066,2015-08-17T18:45:10Z,include/grpc++/auth_context.h,"@@ -87,6 +87,11 @@ class AuthContext {   // Iteration over all the properties.   virtual AuthPropertyIterator begin() const = 0;   virtual AuthPropertyIterator end() const = 0;++  // Mutation functions: should only be used by an AuthMetadataProcessor.+  virtual void AddProperty(const grpc::string& key,",So there is no need of removing/replacing a metadata?,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/2933,37232168,2015-08-17T20:22:44Z,include/grpc++/auth_context.h,"@@ -87,6 +87,11 @@ class AuthContext {   // Iteration over all the properties.   virtual AuthPropertyIterator begin() const = 0;   virtual AuthPropertyIterator end() const = 0;++  // Mutation functions: should only be used by an AuthMetadataProcessor.+  virtual void AddProperty(const grpc::string& key,","You mean a property right?So, yes, this is the intention. You cannot remove/replace properties from the passed-in auth context (which basically comes from the channel and is chained at the lowest layer). This is Add only.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2963,37248704,2015-08-17T23:19:30Z,src/python/grpcio_test/grpc_test/framework/interfaces/base/_sequence.py,"@@ -0,0 +1,168 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Part of the tests of the base interface of RPC Framework.""""""++import collections+import enum++from grpc.framework.interfaces.base import base+from grpc_test.framework.common import test_constants+++class Invocation(+    collections.namedtuple(+        'Invocation', ('timeout', 'initial_metadata', 'payload', 'complete',))):+  """"""A recipe for operation invocation.++  Attributes:+    timeout: A duration in seconds to pass to the system under test as the+      operation's timeout value.+    initial_metadata: A boolean indicating whether or not to pass initial+      metadata when invoking the operation.+    payload: A boolean indicating whether or not to pass a payload when+      invoking the operation.+    complete: A boolean indicating whether or not to indicate completion of+      transmissions from the invoking side of the operation when invoking the+      operation.+  """"""+++class Transmission(+    collections.namedtuple(+        'Transmission', ('initial_metadata', 'payload', 'complete',))):+  """"""A recipe for a single transmission in an operation.++  Attributes:+    initial_metadata: A boolean indicating whether or not to pass initial+      metadata as part of the transmission.+    payload: A boolean indicating whether or not to pass a payload as part of+      the transmission.+    complete: A boolean indicating whether or not to indicate completion of+      transmission from the transmitting side of the operation as part of the+      transmission.+  """"""+++class Intertransmission(+    collections.namedtuple('Intertransmission', ('invocation', 'service',))):+  """"""A recipe for multiple transmissions in an operation.++  Attributes:+    invocation: An integer describing the number of payloads to send from the+      invocation side of the operation to the service side.+    service: An integer describing the number of payloads to send from the+      service side of the operation to the invocation side.+  """"""+++class Element(collections.namedtuple('Element', ('kind', 'transmission',))):+  """"""A sum type for steps to perform when testing an operation.++  Attributes:+    kind: A Kind value describing the kind of step to perform in the test.+    transmission: Only valid for kinds Kind.INVOCATION_TRANSMISSION and+      Kind.SERVICE_TRANSMISSION, a Transmission value describing the details of+      the transmission to be made.+  """"""++  @enum.unique+  class Kind(enum.Enum):+    INVOCATION_TRANSMISSION = 'invocation transmission'",Does this have to do with `class Invocation` above or is there something special about 'invocation _transmission_'s?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2969,37259956,2015-08-18T02:52:27Z,src/python/grpcio_test/grpc_test/_adapter/_low_test.py,"@@ -211,5 +211,76 @@ def testEcho(self):     del server_call  +class HangingServerShutdown(unittest.TestCase):++  def setUp(self):+    self.server_completion_queue = _low.CompletionQueue()+    self.server = _low.Server(self.server_completion_queue, [])+    self.port = self.server.add_http2_port('[::]:0')+    self.client_completion_queue = _low.CompletionQueue()+    self.client_channel = _low.Channel('localhost:%d'%self.port, [])++    self.server.start()++  def tearDown(self):+    del self.client_channel++    self.client_completion_queue.shutdown()+    while self.client_completion_queue.next().type != _types.EventType.QUEUE_SHUTDOWN:+      pass++    del self.client_completion_queue+    del self.server_completion_queue+    del self.server++  def testHangingServerCall(self):+    DEADLINE = time.time()+5+    DEADLINE_TOLERANCE = 0.25+    CANCEL_ALL_CALLS_TIME_TOLERANCE = 0.5+    REQUEST = 'in death a member of project mayhem has a name'+    METHOD = 'twinkies'+    HOST = 'hostess'+    server_request_tag = object()+    request_call_result = self.server.request_call(self.server_completion_queue, server_request_tag)",Blank line between test data (expressed as constants at the top of the test method; thank you for that) and the first statement of test behavior (actively interacting with the system under test).,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37368114,2015-08-19T00:03:32Z,src/python/grpcio/grpc/framework/core/_end.py,"@@ -0,0 +1,227 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Implementation of base.End.""""""++import abc+import enum+import threading+import uuid++from grpc.framework.core import _operation+from grpc.framework.core import _utilities+from grpc.framework.foundation import callable_util+from grpc.framework.foundation import logging_pool+from grpc.framework.interfaces.base import base+from grpc.framework.interfaces.links import links+from grpc.framework.interfaces.links import utilities++_IDLE_ACTION_EXCEPTION_LOG_MESSAGE = 'Exception calling idle action!'+++class End(base.End, links.Link):+  """"""A translation between base.End and links.Link.""""""","What does it mean for this to be a 'translation'...? After looking at `base.End` and `links.Link` and noting that this class is otherwise empty, I'm still unsure of what this is abstracting over.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37368912,2015-08-19T00:18:56Z,src/python/grpcio/grpc/framework/core/_expiration.py,"@@ -0,0 +1,152 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""State and behavior for operation expiration.""""""++import time++from grpc.framework.core import _interfaces+from grpc.framework.foundation import later+from grpc.framework.interfaces.base import base+++class _ExpirationManager(_interfaces.ExpirationManager):+  """"""An implementation of _interfaces.ExpirationManager.""""""++  def __init__(+      self, commencement, timeout, maximum_timeout, lock, termination_manager,+      transmission_manager):+    """"""Constructor.++    Args:+      commencement: The time in seconds since the epoch at which the operation+        began.+      timeout: A length of time in seconds to allow for the operation to run.","Just to clarify: is this a duration as opposed to an absolute deadline?EDIT: _looks at line 66_ okay, yes it is.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37369323,2015-08-19T00:26:04Z,src/python/grpcio/grpc/framework/core/_interfaces.py,"@@ -0,0 +1,303 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Package-internal interfaces.""""""++import abc++from grpc.framework.interfaces.base import base+++class TerminationManager(object):+  """"""An object responsible for handling the termination of an operation.++  Attributes:+    outcome: None if the operation is active or a base.Outcome value if it has+      terminated.+  """"""+  __metaclass__ = abc.ABCMeta++  @abc.abstractmethod+  def add_callback(self, callback):+    """"""Registers a callback to be called on operation termination.++    If the operation has already terminated the callback will not be called.++    Args:+      callback: A callable that will be passed an interfaces.Outcome value.++    Returns:+      None if the operation has not yet terminated and the passed callback will+        be called when it does, or a base.Outcome value describing the operation+        termination if the operation has terminated and the callback will not be+        called as a result of this method call.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def emission_complete(self):+    """"""Indicates that emissions from customer code have completed.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def transmission_complete(self):+    """"""Indicates that transmissions to the remote end are complete.++    Returns:+      True if the operation has terminated or False if the operation remains+        ongoing.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def reception_complete(self):+    """"""Indicates that reception from the other side is complete.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def ingestion_complete(self):+    """"""Indicates that customer code ingestion of received values is complete.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def expire(self):+    """"""Indicates that the operation must abort because it has taken too long.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def abort(self, outcome):+    """"""Indicates that the operation must abort for the indicated reason.++    Args:+      outcome: An interfaces.Outcome indicating operation abortion.+    """"""+    raise NotImplementedError()+++class TransmissionManager(object):+  """"""A manager responsible for transmitting to the other end of an operation.""""""+  __metaclass__ = abc.ABCMeta++  @abc.abstractmethod+  def kick_off(+      self, group, method, timeout, initial_metadata, payload, completion,+      allowance):+    """"""Transmits the values associated with operation invocation.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def inmit(self, initial_metadata, payload, completion, allowance):","Maybe `admit`, `accept`, `transmit`, `request_transmission`, or something to that extent? I'm still dizzy from letting 'destantiate' enter the gRPC lexicon. :-P",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37369994,2015-08-19T00:37:24Z,src/python/grpcio/grpc/framework/core/_emission.py,"@@ -0,0 +1,97 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""State and behavior for handling emitted values.""""""++from grpc.framework.core import _interfaces+from grpc.framework.interfaces.base import base+++class EmissionManager(_interfaces.EmissionManager):+  """"""An EmissionManager implementation.""""""++  def __init__(+      self, lock, termination_manager, transmission_manager,+      expiration_manager):+    """"""Constructor.++    Args:+      lock: The operation-wide lock.+      termination_manager: The _interfaces.TerminationManager for the operation.+      transmission_manager: The _interfaces.TransmissionManager for the+        operation.+      expiration_manager: The _interfaces.ExpirationManager for the operation.+    """"""+    self._lock = lock+    self._termination_manager = termination_manager+    self._transmission_manager = transmission_manager+    self._expiration_manager = expiration_manager+    self._ingestion_manager = None",What's special about the ingestion manager? From my cursory look-ahead in the code I didn't see a potential dependency cycle.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37370871,2015-08-19T00:55:40Z,src/python/grpcio/grpc/framework/core/_emission.py,"@@ -0,0 +1,97 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""State and behavior for handling emitted values.""""""++from grpc.framework.core import _interfaces+from grpc.framework.interfaces.base import base+++class EmissionManager(_interfaces.EmissionManager):+  """"""An EmissionManager implementation.""""""++  def __init__(+      self, lock, termination_manager, transmission_manager,+      expiration_manager):+    """"""Constructor.++    Args:+      lock: The operation-wide lock.","As far as I can tell, `Operation` refers to a class that's private, while on the public API side of things `operate` is just some method of `grpc.framework.interfaces.base.base.End`. On the private side this seems to refer to a concrete object, on the public side some ephemeral construct provided by a method returning `(OperationContext, Operator)`. Could we clarify in the comments which one we mean when we say 'operation' for each of the managers? It seems like the word 'operation' doesn't refer to either notion specifically, but some other unexplained notion, and that's a tad confusing.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/2977,37436925,2015-08-19T16:41:30Z,src/cpp/server/server.cc,"@@ -303,12 +323,21 @@ bool Server::Start() {   return true; } -void Server::Shutdown() {+void Server::ShutdownInternal(gpr_timespec deadline) {   grpc::unique_lock<grpc::mutex> lock(mu_);   if (started_ && !shutdown_) {     shutdown_ = true;     grpc_server_shutdown_and_notify(server_, cq_.cq(), new ShutdownRequest());     cq_.Shutdown();+    SyncRequest* request;+    bool ok;+    while (SyncRequest::AsyncWait(&cq_, &request, &ok, deadline)) {","I take it that it's ok to hold the lock during this period because nothing else should be legally happening at the class Server anyway, but could you add a comment to that effect? Otherwise it seems funny to have a lock around a timed while loop.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37469347,2015-08-19T21:17:19Z,src/python/grpcio_test/grpc_test/_core_over_links_base_interface_test.py,"@@ -0,0 +1,177 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests the RPC Framework Core's implementation of the Base interface.""""""++import collections+import logging+import random+import time+import unittest++from grpc._adapter import _intermediary_low+from grpc._links import invocation+from grpc._links import service+from grpc.framework.core import implementations+from grpc.framework.interfaces.base import utilities+from grpc_test import test_common as grpc_test_common+from grpc_test.framework.common import test_constants+from grpc_test.framework.interfaces.base import test_cases+from grpc_test.framework.interfaces.base import test_interfaces+from grpc_test.framework.interfaces.links import test_utilities++_INVOCATION_INITIAL_METADATA = ((b'0', b'abc'), (b'1', b'def'), (b'2', b'ghi'),)",Do we care about testing binary metadata? i.e. keys with suffix `'-bin'`.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37469638,2015-08-19T21:20:05Z,src/python/grpcio_test/grpc_test/_core_over_links_base_interface_test.py,"@@ -0,0 +1,177 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests the RPC Framework Core's implementation of the Base interface.""""""++import collections+import logging+import random+import time+import unittest++from grpc._adapter import _intermediary_low+from grpc._links import invocation+from grpc._links import service+from grpc.framework.core import implementations+from grpc.framework.interfaces.base import utilities+from grpc_test import test_common as grpc_test_common+from grpc_test.framework.common import test_constants+from grpc_test.framework.interfaces.base import test_cases+from grpc_test.framework.interfaces.base import test_interfaces+from grpc_test.framework.interfaces.links import test_utilities++_INVOCATION_INITIAL_METADATA = ((b'0', b'abc'), (b'1', b'def'), (b'2', b'ghi'),)+_SERVICE_INITIAL_METADATA = ((b'3', b'jkl'), (b'4', b'mno'), (b'5', b'pqr'),)","I've never seen an HTTP header with numbers or spaces or whatever, and according to [this](https://github.com/grpc/grpc-common/blob/master/PROTOCOL-HTTP2.md#requests) our metadata use lowercase names (do numbers count as lowercase?). I'm not sure if this is a thing we're _supposed_ to support or if it just happens to work when you run the tests. I'm also not sure if this is a thing requiring a spec clarification.EDIT: grpc/grpc-common#271 seems to indicate that we _intend_ on accepting just about everything the HTTP/2 spec allows (which harkens back to the [HTTP/1.1 spec](https://tools.ietf.org/html/rfc7230#section-3.2)), so, I guess this should be fine.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/2998,37474847,2015-08-19T22:06:55Z,src/php/ext/grpc/channel.c,"@@ -192,8 +174,8 @@ PHP_METHOD(Channel, __construct) {     }     efree(args.args);   }-  channel->target = ecalloc(override_len + 1, sizeof(char));-  memcpy(channel->target, override, override_len);+  channel->target = ecalloc(target_length + 1, sizeof(char));","Now that it is no longer being passed to calls, do you still need to store `channel->target`? If not, you can also remove that field from the struct in `channel.h`.",
520669,dhermes,https://api.github.com/repos/grpc/grpc/pulls/2990,37476055,2015-08-19T22:21:39Z,INSTALL,"@@ -9,6 +9,20 @@ wiki pages: * If you are in a hurry * ************************* +On Linux (Debian):++ Note: you will need to add the Debian 'unstable' distribution to your source",Is there not also a way to add a PPA? Which is preferred in the debian world? How long will it be until it ends up in stable?PS I am so excited about this.,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/2990,37476431,2015-08-19T22:26:10Z,INSTALL,"@@ -9,6 +9,20 @@ wiki pages: * If you are in a hurry * ************************* +On Linux (Debian):++ Note: you will need to add the Debian 'unstable' distribution to your source+ file first.++ Add the following line to your `/etc/apt/sources.list` file:++ deb http://ftp.us.debian.org/debian unstable main contrib non-free",technically this file is not a .md markdown file. I will try to incoporate your feedback.,
520669,dhermes,https://api.github.com/repos/grpc/grpc/pulls/2990,37476675,2015-08-19T22:29:07Z,INSTALL,"@@ -9,6 +9,20 @@ wiki pages: * If you are in a hurry * ************************* +On Linux (Debian):++ Note: you will need to add the Debian 'unstable' distribution to your source+ file first.++ Add the following line to your `/etc/apt/sources.list` file:++ deb http://ftp.us.debian.org/debian unstable main contrib non-free","Interesting. Ping me after the merge and I can do a formatting pass? (Including renaming to `INSTALL.md`, which might break links in the wild)",
520669,dhermes,https://api.github.com/repos/grpc/grpc/pulls/2990,37479095,2015-08-19T22:59:06Z,src/php/README.md,"@@ -28,10 +28,39 @@ $ curl -O http://pear.php.net/go-pear.phar $ sudo php -d detect_unicode=0 go-pear.phar ``` -## Build from Homebrew+## Quick Install -On Mac OS X, install [homebrew][]. On Linux, install [linuxbrew][]. Run the following command to-install gRPC.+**Linux (Debian):**++Add [debian unstable][] (sid) to your `sources.list` file. Example:","You could put it in https://github.com/grpc/grpc/blob/master/README.md or put it in `INSTALLATION` and link to a section (via an anchor, e.g. `https://github.com/grpc/grpc/blob/master/INSTALL#foo`).This may rely on converting INSTALL to valid markdown",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/2990,37482039,2015-08-19T23:41:40Z,src/php/README.md,"@@ -28,10 +28,39 @@ $ curl -O http://pear.php.net/go-pear.phar $ sudo php -d detect_unicode=0 go-pear.phar ``` -## Build from Homebrew+## Quick Install -On Mac OS X, install [homebrew][]. On Linux, install [linuxbrew][]. Run the following command to-install gRPC.+**Linux (Debian):**++Add [debian unstable][] (sid) to your `sources.list` file. Example:","Understood. I will leave them as is for now, as there are other copy-pasta similarly in those 5 files :) ",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37567508,2015-08-20T18:54:52Z,src/python/grpcio/grpc/framework/core/_end.py,"@@ -0,0 +1,227 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Implementation of base.End.""""""++import abc+import enum+import threading+import uuid++from grpc.framework.core import _operation+from grpc.framework.core import _utilities+from grpc.framework.foundation import callable_util+from grpc.framework.foundation import logging_pool+from grpc.framework.interfaces.base import base+from grpc.framework.interfaces.links import links+from grpc.framework.interfaces.links import utilities++_IDLE_ACTION_EXCEPTION_LOG_MESSAGE = 'Exception calling idle action!'+++class End(base.End, links.Link):+  """"""A translation between base.End and links.Link.""""""","Notice the subtle presence of ""**metaclass** = abc.ABCMeta"" - this indicates just that it is an interface that unifies two other interfaces. I've fleshed out the doc string a bit now.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/3012,37583829,2015-08-20T21:33:54Z,src/node/src/metadata.js,"@@ -0,0 +1,169 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/**+ * Metadata module+ * @module+ */++'use strict';++var _ = require('lodash');++/**+ * Class for storing metadata. Keys are normalized to lowercase ASCII.+ * @constructor+ */+function Metadata() {+  this._internal_repr = {};+}++function normalizeKey(key) {+  return _.deburr(key).toLowerCase();+}++function validate(key, value) {+  if (_.endsWith(key, '-bin')) {+    if (!(value instanceof Buffer)) {+      throw new Error('keys that end with \'-bin\' must have Buffer values');+    }+  } else {+    if (!_.isString(value)) {+      throw new Error(+          'keys that don\'t end with \'-bin\' must have String values');+    }+  }+}++/**+ * Sets the given value for the given key, replacing any other values associated+ * with that key. Normalizes the key.+ * @param {String} key The key to set+ * @param {String|Buffer} value The value to set. Must be a buffer if and only+ *     if the normalized key ends with '-bin'+ */+Metadata.prototype.set = function(key, value) {+  key = normalizeKey(key);+  validate(key, value);+  this._internal_repr[key] = [value];+};++/**+ * Adds the given value for the given key. Normalizes the key.+ * @param {String} key The key to add to.+ * @param {String|Buffer} value The value to add. Must be a buffer if and only+ *     if the normalized key ends with '-bin'+ */+Metadata.prototype.add = function(key, value) {+  key = normalizeKey(key);+  validate(key, value);+  if (!this._internal_repr[key]) {+    this._internal_repr[key] = [];+  }+  this._internal_repr[key].push(value);+};++/**+ * Remove the given key and any associated values.+ * @param {String} key The key to remove+ */+Metadata.prototype.remove = function(key) {","Why wouldn't `normalizeKey()` be applied to get and remove?This would seem weird:``` javascriptmetadata.add(""HELLO"", ""world"");metadata.remove(""HELLO"");// HELLO is still in metadata...```The same for get:``` javascriptmetadata.add(""HELLO"", ""world"");var hellos = metadata.get(""HELLO"");// hellos == []```",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/3012,37585417,2015-08-20T21:50:13Z,src/node/src/metadata.js,"@@ -0,0 +1,169 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/**+ * Metadata module+ * @module+ */++'use strict';++var _ = require('lodash');++/**+ * Class for storing metadata. Keys are normalized to lowercase ASCII.+ * @constructor+ */+function Metadata() {+  this._internal_repr = {};+}++function normalizeKey(key) {+  return _.deburr(key).toLowerCase();+}++function validate(key, value) {+  if (_.endsWith(key, '-bin')) {+    if (!(value instanceof Buffer)) {+      throw new Error('keys that end with \'-bin\' must have Buffer values');+    }+  } else {+    if (!_.isString(value)) {+      throw new Error(+          'keys that don\'t end with \'-bin\' must have String values');+    }+  }+}++/**+ * Sets the given value for the given key, replacing any other values associated+ * with that key. Normalizes the key.+ * @param {String} key The key to set+ * @param {String|Buffer} value The value to set. Must be a buffer if and only+ *     if the normalized key ends with '-bin'+ */+Metadata.prototype.set = function(key, value) {+  key = normalizeKey(key);+  validate(key, value);+  this._internal_repr[key] = [value];+};++/**+ * Adds the given value for the given key. Normalizes the key.+ * @param {String} key The key to add to.+ * @param {String|Buffer} value The value to add. Must be a buffer if and only+ *     if the normalized key ends with '-bin'+ */+Metadata.prototype.add = function(key, value) {+  key = normalizeKey(key);+  validate(key, value);+  if (!this._internal_repr[key]) {+    this._internal_repr[key] = [];+  }+  this._internal_repr[key].push(value);+};++/**+ * Remove the given key and any associated values.+ * @param {String} key The key to remove+ */+Metadata.prototype.remove = function(key) {","That's true. I was thinking in terms of reading unexpected keys I get from the core library, but I guess I can assume that those keys will also be lowercased. I'll change that.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/3012,37601384,2015-08-21T02:21:49Z,src/node/src/metadata.js,"@@ -0,0 +1,169 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/**+ * Metadata module+ * @module+ */++'use strict';++var _ = require('lodash');++/**+ * Class for storing metadata. Keys are normalized to lowercase ASCII.+ * @constructor+ */+function Metadata() {+  this._internal_repr = {};+}++function normalizeKey(key) {+  return _.deburr(key).toLowerCase();","You know what, after I read your comment I looked it up, but I misunderstood what I found and I thought `toLowerCase()` _was_ locale dependent. I'll revert that part of the change tomorrow.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37640088,2015-08-21T14:37:19Z,src/python/grpcio/grpc/framework/core/_expiration.py,"@@ -0,0 +1,152 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""State and behavior for operation expiration.""""""++import time++from grpc.framework.core import _interfaces+from grpc.framework.foundation import later+from grpc.framework.interfaces.base import base+++class _ExpirationManager(_interfaces.ExpirationManager):+  """"""An implementation of _interfaces.ExpirationManager.""""""++  def __init__(+      self, commencement, timeout, maximum_timeout, lock, termination_manager,+      transmission_manager):+    """"""Constructor.++    Args:+      commencement: The time in seconds since the epoch at which the operation+        began.+      timeout: A length of time in seconds to allow for the operation to run.","Yes. I've started using the word ""duration"" in parameter descriptions going forward but I don't know that I'll bother with a codebase-wide upgrade.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37645783,2015-08-21T15:30:26Z,src/python/grpcio/grpc/framework/core/_termination.py,"@@ -0,0 +1,212 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""State and behavior for operation termination.""""""++import abc++from grpc.framework.core import _constants+from grpc.framework.core import _interfaces+from grpc.framework.foundation import callable_util+from grpc.framework.interfaces.base import base+++def _invocation_completion_predicate(+    unused_emission_complete, unused_transmission_complete,+    unused_reception_complete, ingestion_complete):+  return ingestion_complete+++def _service_completion_predicate(+    unused_emission_complete, transmission_complete, unused_reception_complete,+    unused_ingestion_complete):+  return transmission_complete+++class TerminationManager(_interfaces.TerminationManager):+  """"""A _interfaces.TransmissionManager on which another manager may be set.""""""+  __metaclass__ = abc.ABCMeta++  @abc.abstractmethod+  def set_expiration_manager(self, expiration_manager):+    """"""Sets the expiration manager with which this manager will interact.++    Args:+      expiration_manager: The _interfaces.ExpirationManager associated with the+        current operation.+    """"""+    raise NotImplementedError()+++class _TerminationManager(TerminationManager):+  """"""An implementation of TerminationManager.""""""++  def __init__(self, predicate, action, pool):+    """"""Constructor.++    Args:+      predicate: One of _invocation_completion_predicate or+        _service_completion_predicate to be used to determine when the operation+        has completed.+      action: A behavior to pass the operation outcome on operation termination.+      pool: A thread pool.+    """"""+    self._predicate = predicate+    self._action = action+    self._pool = pool+    self._expiration_manager = None++    self.outcome = None+    self._callbacks = []++    self._emission_complete = False+    self._transmission_complete = False+    self._reception_complete = False+    self._ingestion_complete = False++  def set_expiration_manager(self, expiration_manager):+    self._expiration_manager = expiration_manager++  def _terminate_internal_only(self, outcome):+    """"""Terminates the operation.++    Args:+      outcome: A base.Outcome describing the outcome of the operation.+    """"""+    self.outcome = outcome+    callbacks = list(self._callbacks)+    self._callbacks = None++    act = callable_util.with_exceptions_logged(+        self._action, _constants.INTERNAL_ERROR_LOG_MESSAGE)++    if outcome is base.Outcome.LOCAL_FAILURE:+      self._pool.submit(act, outcome)+    else:+      def call_callbacks_and_act(callbacks, outcome):+        for callback in callbacks:+          callback_outcome = callable_util.call_logging_exceptions(+              callback, _constants.TERMINATION_CALLBACK_EXCEPTION_LOG_MESSAGE,+              outcome)+          if callback_outcome.exception is not None:+            outcome = base.Outcome.LOCAL_FAILURE+            break+        act(outcome)++      self._pool.submit(+          callable_util.with_exceptions_logged(+              call_callbacks_and_act, _constants.INTERNAL_ERROR_LOG_MESSAGE),+          callbacks, outcome)++  def _terminate_and_notify(self, outcome):","There's a pattern package-wide that _terminate_and_notify methods notify other managers and _terminate_internal_only methods do the manager-internal work associated with termination and do not notify other managers. In this case, this manager's internal work associated with termination is to schedule the operation's termination callbacks to be called.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37646274,2015-08-21T15:34:58Z,src/python/grpcio_test/grpc_test/_core_over_links_base_interface_test.py,"@@ -0,0 +1,177 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests the RPC Framework Core's implementation of the Base interface.""""""++import collections+import logging+import random+import time+import unittest++from grpc._adapter import _intermediary_low+from grpc._links import invocation+from grpc._links import service+from grpc.framework.core import implementations+from grpc.framework.interfaces.base import utilities+from grpc_test import test_common as grpc_test_common+from grpc_test.framework.common import test_constants+from grpc_test.framework.interfaces.base import test_cases+from grpc_test.framework.interfaces.base import test_interfaces+from grpc_test.framework.interfaces.links import test_utilities++_INVOCATION_INITIAL_METADATA = ((b'0', b'abc'), (b'1', b'def'), (b'2', b'ghi'),)","Maybe in a future commit in which I write just one test utility method for generating all the metadata appropriate for use in grpc-on-the-wire tests, but... it's not a priority for this commit.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37646786,2015-08-21T15:40:00Z,src/python/grpcio_test/grpc_test/_core_over_links_base_interface_test.py,"@@ -0,0 +1,177 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests the RPC Framework Core's implementation of the Base interface.""""""++import collections+import logging+import random+import time+import unittest++from grpc._adapter import _intermediary_low+from grpc._links import invocation+from grpc._links import service+from grpc.framework.core import implementations+from grpc.framework.interfaces.base import utilities+from grpc_test import test_common as grpc_test_common+from grpc_test.framework.common import test_constants+from grpc_test.framework.interfaces.base import test_cases+from grpc_test.framework.interfaces.base import test_interfaces+from grpc_test.framework.interfaces.links import test_utilities++_INVOCATION_INITIAL_METADATA = ((b'0', b'abc'), (b'1', b'def'), (b'2', b'ghi'),)+_SERVICE_INITIAL_METADATA = ((b'3', b'jkl'), (b'4', b'mno'), (b'5', b'pqr'),)",These keys are (for the moment) legal; if they become illegal we can change them. They're just test data.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37646909,2015-08-21T15:41:14Z,src/python/grpcio_test/grpc_test/framework/interfaces/links/test_utilities.py,"@@ -29,9 +29,26 @@  """"""State and behavior appropriate for use in tests."""""" +import logging import threading+import time  from grpc.framework.interfaces.links import links+from grpc.framework.interfaces.links import utilities+++def _safe_ticket(ticket):",It's safeguarding against logging huge quantities of binary payload data.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/2968,37659293,2015-08-21T17:51:07Z,src/python/grpcio_test/grpc_test/framework/interfaces/links/test_utilities.py,"@@ -29,9 +29,26 @@  """"""State and behavior appropriate for use in tests."""""" +import logging import threading+import time  from grpc.framework.interfaces.links import links+from grpc.framework.interfaces.links import utilities+++def _safe_ticket(ticket):","Coming from a world of memory-corruption and data-races and whatnot, the word 'safe' is meant for something that's aloft of really actually horrible bad things that unsafe things don't avoid. Mind adding a comment?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/2968,37663540,2015-08-21T18:30:06Z,src/python/grpcio/grpc/framework/core/_constants.py,"@@ -0,0 +1,59 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Private constants for the package.""""""++from grpc.framework.interfaces.base import base+from grpc.framework.interfaces.links import links++TICKET_SUBSCRIPTION_FOR_BASE_SUBSCRIPTION_KIND = {+    base.Subscription.Kind.NONE: links.Ticket.Subscription.NONE,+    base.Subscription.Kind.TERMINATION_ONLY:+        links.Ticket.Subscription.TERMINATION,+    base.Subscription.Kind.FULL: links.Ticket.Subscription.FULL,+    }++ABORTION_OUTCOME_TO_TICKET_TERMINATION = {+    base.Outcome.CANCELLED: links.Ticket.Termination.CANCELLATION,+    base.Outcome.EXPIRED: links.Ticket.Termination.EXPIRATION,+    base.Outcome.LOCAL_SHUTDOWN: links.Ticket.Termination.SHUTDOWN,+    base.Outcome.REMOTE_SHUTDOWN: None,+    base.Outcome.RECEPTION_FAILURE: links.Ticket.Termination.RECEPTION_FAILURE,+    base.Outcome.TRANSMISSION_FAILURE: None,+    base.Outcome.LOCAL_FAILURE: links.Ticket.Termination.LOCAL_FAILURE,+    base.Outcome.REMOTE_FAILURE: links.Ticket.Termination.REMOTE_FAILURE,+}++ABORTION_TICKET_TERMINATION_TO_OUTCOME = {+    ticket_termination: outcome for outcome, ticket_termination in","Hmm, you're right about key overlap and the constant is unused. Delorted.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/3046,37825478,2015-08-25T01:47:35Z,src/python/grpcio_test/grpc_test/framework/common/test_control.py,"@@ -34,6 +34,10 @@ import threading  +class Defect(Exception):+  """"""Simulates a programming defect in a system under test.""""""","Is this done specifically to make the raised error class a non-standard one? If so, mind adding the relevant tidbits of the commit message to this comment?",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/3074,37942534,2015-08-26T02:59:16Z,include/grpc++/credentials.h,"@@ -65,78 +73,78 @@ class Credentials : public GrpcLibrary {       const grpc::string& target, const ChannelArguments& args) = 0; }; -// Options used to build SslCredentials-// pem_roots_cert is the buffer containing the PEM encoding of the server root-// certificates. If this parameter is empty, the default roots will be used.-// pem_private_key is the buffer containing the PEM encoding of the client's-// private key. This parameter can be empty if the client does not have a-// private key.-// pem_cert_chain is the buffer containing the PEM encoding of the client's-// certificate chain. This parameter can be empty if the client does not have-// a certificate chain.+/// Options used to build SslCredentials.+///+/// pem_roots_cert is the buffer containing the PEM encoding of the server root+/// certificates. If this parameter is empty, the default roots will be used.",Maybe we could add here.``` cpp/// The default roots can be overridden using the GRPC_DEFAULT_SSL_ROOTS_FILE_PATH /// environment variable pointing to a file on the file system containing the roots.```or something along the same lines.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3074,37993356,2015-08-26T15:08:37Z,include/grpc++/client_context.h,"@@ -130,24 +148,57 @@ class ClientContext {   ClientContext();   ~ClientContext(); -  /// Create a new ClientContext that propagates some or all of its attributes+  /// Create a new \a ClientContext according to \a options (\see+  /// PropagationOptions).+  ///+  /// \param server_context The source server context to use as the basis for+  /// constructing the client context.+  /// \param options The options controlling what to copy from the \a+  /// server_context.+  ///+  /// \return A newly constructed \a ClientContext instance based on \a+  /// server_context, with traits propagated (copied) according to \a options.   static std::unique_ptr<ClientContext> FromServerContext(       const ServerContext& server_context,       PropagationOptions options = PropagationOptions()); +  /// Add the (\a meta_key, \a meta_value) pair to the metadata associated with+  /// a client call. These are made available at the server side by the \a+  /// grpc::ServerContext::client_metadata() method.+  ///+  /// \param meta_key The metadata key. If \a meta_value is binary data, it must+  /// end in ""-bin"".+  /// \param meta_value The metadata value. If its value is binary, it must be+  /// base64-encoding (see https://tools.ietf.org/html/rfc4648#section-4) and \a+  /// meta_key must end in ""-bin"".   void AddMetadata(const grpc::string& meta_key,                    const grpc::string& meta_value); +  /// Return a collection of initial metadata key-value pairs. Note that keys+  /// may happen more than once (ie, a \a std::multimap is returned).+  ///+  /// This should only be called upon a successful reply from the server.",we may want to be more nuanced here...after initial metadata has been receivedfor streams there's a call to wait for this (for instance),
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3074,37993606,2015-08-26T15:10:35Z,include/grpc++/completion_queue.h,"@@ -67,53 +70,74 @@ class UnknownMethodHandler;  class Channel; class ClientContext;+class CompletionQueueTag; class CompletionQueue; class RpcMethod; class Server; class ServerBuilder; class ServerContext; -class CompletionQueueTag {- public:-  virtual ~CompletionQueueTag() {}-  // Called prior to returning from Next(), return value-  // is the status of the operation (return status is the default thing-  // to do)-  // If this function returns false, the tag is dropped and not returned-  // from the completion queue-  virtual bool FinalizeResult(void** tag, bool* status) = 0;-};--// grpc_completion_queue wrapper class+// This class is a thin wrapper around \a grpc_completion_queue (see+// \a src/core/surface/completion_queue.h).  class CompletionQueue : public GrpcLibrary {  public:+  /// Default constructor. Implicitly creates a \a grpc_completion_queue+  /// instance.   CompletionQueue();++  /// Wrap \a take, taking ownership of the instance.+  /// +  /// \param take The completion queue instance to wrap. Ownership is taken.   explicit CompletionQueue(grpc_completion_queue* take);++  /// Destructor. Destroys the owned wrapped completion queue / instance.   ~CompletionQueue() GRPC_OVERRIDE; -  // Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT+  /// Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT.","member documentation:SHUTDOWN - the completion queue has been shutdownGOT_EVENT - got a new event; tag, ok are filled in corresponding to which one and its successTIMEOUT - deadline was reached",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3074,37993651,2015-08-26T15:10:56Z,include/grpc++/completion_queue.h,"@@ -67,53 +70,74 @@ class UnknownMethodHandler;  class Channel; class ClientContext;+class CompletionQueueTag; class CompletionQueue; class RpcMethod; class Server; class ServerBuilder; class ServerContext; -class CompletionQueueTag {- public:-  virtual ~CompletionQueueTag() {}-  // Called prior to returning from Next(), return value-  // is the status of the operation (return status is the default thing-  // to do)-  // If this function returns false, the tag is dropped and not returned-  // from the completion queue-  virtual bool FinalizeResult(void** tag, bool* status) = 0;-};--// grpc_completion_queue wrapper class+// This class is a thin wrapper around \a grpc_completion_queue (see+// \a src/core/surface/completion_queue.h).  class CompletionQueue : public GrpcLibrary {  public:+  /// Default constructor. Implicitly creates a \a grpc_completion_queue+  /// instance.   CompletionQueue();++  /// Wrap \a take, taking ownership of the instance.+  /// +  /// \param take The completion queue instance to wrap. Ownership is taken.   explicit CompletionQueue(grpc_completion_queue* take);++  /// Destructor. Destroys the owned wrapped completion queue / instance.   ~CompletionQueue() GRPC_OVERRIDE; -  // Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT+  /// Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT.",what do people think about renaming TIMEOUT to DEADLINE_EXPIRED?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3074,37994545,2015-08-26T15:17:31Z,src/core/surface/completion_queue.h,"@@ -34,7 +34,7 @@ #ifndef GRPC_INTERNAL_CORE_SURFACE_COMPLETION_QUEUE_H #define GRPC_INTERNAL_CORE_SURFACE_COMPLETION_QUEUE_H -/* Internal API for completion channels */+/* Internal API for completion queues */",oh man... completion channels... now that's a name i haven't heard in a very long time,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/3074,38004534,2015-08-26T16:43:39Z,include/grpc++/completion_queue.h,"@@ -67,53 +70,74 @@ class UnknownMethodHandler;  class Channel; class ClientContext;+class CompletionQueueTag; class CompletionQueue; class RpcMethod; class Server; class ServerBuilder; class ServerContext; -class CompletionQueueTag {- public:-  virtual ~CompletionQueueTag() {}-  // Called prior to returning from Next(), return value-  // is the status of the operation (return status is the default thing-  // to do)-  // If this function returns false, the tag is dropped and not returned-  // from the completion queue-  virtual bool FinalizeResult(void** tag, bool* status) = 0;-};--// grpc_completion_queue wrapper class+// This class is a thin wrapper around \a grpc_completion_queue (see+// \a src/core/surface/completion_queue.h).  class CompletionQueue : public GrpcLibrary {  public:+  /// Default constructor. Implicitly creates a \a grpc_completion_queue+  /// instance.   CompletionQueue();++  /// Wrap \a take, taking ownership of the instance.+  /// +  /// \param take The completion queue instance to wrap. Ownership is taken.   explicit CompletionQueue(grpc_completion_queue* take);++  /// Destructor. Destroys the owned wrapped completion queue / instance.   ~CompletionQueue() GRPC_OVERRIDE; -  // Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT+  /// Tri-state return for AsyncNext: SHUTDOWN, GOT_EVENT, TIMEOUT.",I like DEADLINE_EXPIRED for being less ambiguous/self explanatory.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/3074,38007345,2015-08-26T17:07:05Z,include/grpc++/server.h,"@@ -57,24 +61,27 @@ class ServerAsyncStreamingInterface; class ServerCredentials; class ThreadPoolInterface; -// Currently it only supports handling rpcs in a single thread. class Server GRPC_FINAL : public GrpcLibrary, private CallHook {","There was one above, at the file level. Moving it here closer to the class.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3074,38008531,2015-08-26T17:17:23Z,include/grpc++/credentials.h,"@@ -44,9 +44,17 @@ class ChannelArguments; class Channel; class SecureCredentials; +/// A credentials object encapsulates all the state needed by a client to+/// authenticate with a server and make various assertions, e.g., about the+/// client’s identity, role, or whether it is authorized to make a particular+/// call.+///+/// \see https://github.com/grpc/grpc-common/blob/master/grpc-auth-support.md","Oh. I missed the repo. Aren't we deprecating grpc-common anyway?On Wed, Aug 26, 2015 at 9:54 AM David G. Quintas notifications@github.comwrote:> In include/grpc++/credentials.h> https://github.com/grpc/grpc/pull/3074#discussion_r38005820:> > > @@ -44,9 +44,17 @@ class ChannelArguments;> >  class Channel;> >  class SecureCredentials;> > > > +/// A credentials object encapsulates all the state needed by a client to> > +/// authenticate with a server and make various assertions, e.g., about the> > +/// client’s identity, role, or whether it is authorized to make a particular> > +/// call.> > +///> > +/// \see https://github.com/grpc/grpc-common/blob/master/grpc-auth-support.md> > that'd be great. Is it able to do that even if the file lives in a> different repo?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/3074/files#r38005820.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/3065,38041022,2015-08-26T22:05:38Z,include/grpc++/support/string_ref.h,"@@ -50,22 +50,22 @@ class string_ref {   typedef std::reverse_iterator<const_iterator> const_reverse_iterator;    // constants-  static constexpr size_t npos = size_t(-1);+  const static size_t npos = size_t(-1);",Maybe add some language that we're deviating from the proposed standard because of old compilers here (see what I did for `compare` for example. This could be a class comment too (as opposed to individual functions.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3093,38062103,2015-08-27T04:55:01Z,src/python/grpcio/grpc/_adapter/_c/types/channel.c,"@@ -164,7 +164,7 @@ PyObject *pygrpc_Channel_watch_connectivity_state(   int last_observed_state;   CompletionQueue *completion_queue;   char *keywords[] = {""last_observed_state"", ""deadline"",-                      ""completion_queue"", ""tag""};+                      ""completion_queue"", ""tag"", NULL};","Okay, I am able to reproduce it, and it seems to be nondeterministic in my primary development environment and deterministically hanging in my secondary development environment. What do you make of ""RuntimeError: More keyword list entries (9) than format specifiers (4)"" and its relation to the addition of NULL at the end of this array?",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/3075,38156109,2015-08-27T22:56:24Z,test/cpp/interop/client_helper.cc,"@@ -107,14 +97,10 @@ std::shared_ptr<Channel> CreateChannelForTestCase(   snprintf(host_port, host_port_buf_size, ""%s:%d"", FLAGS_server_host.c_str(),            FLAGS_server_port); -  if (test_case == ""service_account_creds"") {","https://github.com/grpc/grpc/blob/master/test/cpp/interop/client.cc#L71 andthe following references to service_account_creds also need to be removed :)On Thu, Aug 27, 2015 at 3:52 PM, jboeuf notifications@github.com wrote:> In test/cpp/interop/client_helper.cc> https://github.com/grpc/grpc/pull/3075#discussion_r38155823:> > > @@ -107,14 +97,10 @@ std::shared_ptr<Channel> CreateChannelForTestCase(> >    snprintf(host_port, host_port_buf_size, ""%s:%d"", FLAGS_server_host.c_str(),> >             FLAGS_server_port);> > -  if (test_case == ""service_account_creds"") {> > Done.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/3075/files#r38155823.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/3062,38156218,2015-08-27T22:58:01Z,doc/interop-test-descriptions.md,"@@ -825,6 +1012,21 @@ When the client requests COMPRESSABLE payload, the response includes a payload of the size requested containing all zeros and the payload type is COMPRESSABLE. +### Uncompressable Payload+[Uncompressable Payload]: #uncompressable-payload++When the client requests UNCOMPRESSABLE payload, the response includes a payload+of the size requested containing uncompressable data and the payload type is","It isn't clear that the ""uncompressable data"" _MUST_ be taken from rnd.dat.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/3074,38173340,2015-08-28T06:10:35Z,include/grpc++/support/auth_context.h,"@@ -72,20 +72,26 @@ class AuthPropertyIterator   const char* name_; }; +/// Class encapsulating the Authentication Information.+/// +/// It includes the secure identity of the peer, the type of secure transport+/// used as well as any other properties required by the authorization layer.","Actually, nevermind, done in this one. Please take a look. There was the option of having them as functions outside of classes but I made them static methods of AuthContext to have them inside the class' namespace.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/2668,38247382,2015-08-28T21:43:42Z,third_party/openssl,@@ -1 +1 @@-Subproject commit 33dd08320648ac71d7d9d732be774ed3818dccc5,"I don't know whether this is considered fixed or not, but at least I no longer see this in my git status.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/2933,38250500,2015-08-28T22:26:00Z,include/grpc++/auth_metadata_processor.h,"@@ -0,0 +1,74 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_AUTH_METADATA_PROCESSOR_H_+#define GRPCXX_AUTH_METADATA_PROCESSOR_H_",This seems to belong to support/ ?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3134,38266977,2015-08-29T23:25:11Z,src/python/grpcio/grpc/beta/beta.py,"@@ -111,4 +154,330 @@ def create_insecure_channel(host, port):   Returns:     A Channel to the remote host through which RPCs may be conducted.   """"""-  return Channel(_low.Channel('%s:%d' % (host, port), ()))+  intermediary_low_channel = _intermediary_low.Channel(+      '%s:%d' % (host, port), None)+  return Channel(intermediary_low_channel._internal, intermediary_low_channel)  # pylint: disable=protected-access+++def create_secure_channel(host, port, client_credentials):+  """"""Creates a secure Channel to a remote host.++  Args:+    host: The name of the remote host to which to connect.+    port: The port of the remote host to which to connect.+    client_credentials: A ClientCredentials.++  Returns:+    A secure Channel to the remote host through which RPCs may be conducted.+  """"""+  intermediary_low_channel = _intermediary_low.Channel(+      '%s:%d' % (host, port), client_credentials.intermediary_low_credentials)+  return Channel(intermediary_low_channel._internal, intermediary_low_channel)  # pylint: disable=protected-access+++class StubOptions(object):+  """"""A value encapsulating the various options for creation of a Stub.++  This class and its instances have no supported interface - it exists to define+  the type of its instances and its instances exist to be passed to other+  functions.+  """"""++  def __init__(+      self, host, request_serializers, response_deserializers,+      metadata_transformer, thread_pool, thread_pool_size):+    self.host = host+    self.request_serializers = request_serializers+    self.response_deserializers = response_deserializers+    self.metadata_transformer = metadata_transformer+    self.thread_pool = thread_pool+    self.thread_pool_size = thread_pool_size+++def stub_options(+    host=None, request_serializers=None, response_deserializers=None,+    metadata_transformer=None, thread_pool=None, thread_pool_size=None):+  """"""Creates a StubOptions value to be passed at stub creation.++  All parameters are optional and should always be passed by keyword.","Not sure to the former, yes to the latter. I think there may be a chicken-and-egg problem in which maintainers are reluctant to add new keyword parameters to a callable anywhere but at the end of the parameters list because they are afraid that somewhere out there someone is calling their callable and passing parameters positionally. I'd like to push back against that, at least for now and with this.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3134,38266993,2015-08-29T23:28:56Z,src/python/grpcio_test/grpc_test/beta/_face_interface_test.py,"@@ -0,0 +1,137 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests Face interface compliance of the gRPC Python Beta API.""""""++import collections+import unittest++from grpc._adapter import _intermediary_low+from grpc.beta import beta+from grpc_test import resources+from grpc_test import test_common as grpc_test_common+from grpc_test.beta import _test_beta+from grpc_test.framework.common import test_constants+from grpc_test.framework.interfaces.face import test_cases+from grpc_test.framework.interfaces.face import test_interfaces++_SERVER_HOST_OVERRIDE = 'foo.test.google.fr'+++class _SerializationBehaviors(+    collections.namedtuple(+        '_SerializationBehaviors',+        ('request_serializers', 'request_deserializers', 'response_serializers',+         'response_deserializers',))):+  pass+++def _serialization_behaviors_from_test_methods(test_methods):+  request_serializers = {}+  request_deserializers = {}+  response_serializers = {}+  response_deserializers = {}+  for (group, method), test_method in test_methods.iteritems():+    request_serializers[group, method] = test_method.serialize_request+    request_deserializers[group, method] = test_method.deserialize_request+    response_serializers[group, method] = test_method.serialize_response+    response_deserializers[group, method] = test_method.deserialize_response+  return _SerializationBehaviors(+      request_serializers, request_deserializers, response_serializers,+      response_deserializers)+++class _Implementation(test_interfaces.Implementation):++  def instantiate(+      self, methods, method_implementations, multi_method_implementation):+    serialization_behaviors = _serialization_behaviors_from_test_methods(+        methods)+    # TODO(nathaniel): Add a ""groups"" attribute to _digest.TestServiceDigest.+    service = next(iter(methods))[0]+    # TODO(nathaniel): Add a ""cardinalities_by_group"" attribute to+    # _digest.TestServiceDigest.+    cardinalities = {+        method: method_object.cardinality()+        for (group, method), method_object in methods.iteritems()}++    server_options = beta.server_options(+        request_deserializers=serialization_behaviors.request_deserializers,",The line is fine. Are you looking at it on a small screen? When I do GitHub code reviews on my laptop long lines look weird because I can't actually get eighty characters' width for each of the two columns on the page.,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/3107,38348066,2015-08-31T19:15:12Z,include/grpc/census.h,"@@ -379,16 +379,131 @@ int census_tag_set_next(census_tag_set_iterator *it, census_tag_const *tag);    invalidated, and should not be used once close is called. */ void census_tag_set_close(census_tag_set_iterator *it); -/* A census statistic to be recorded comprises two parts: an ID for the- * particular statistic and the value to be recorded against it. */+/* Core stats collection API's. The following concepts are used:+   * Aggregation: A collection of values. Census supports the following+       aggregation types:+         Scalar - a single scalar value. Typically used for keeping (e.g.)+           counts of events.+         Distribution - statistical distribution information, used for+           recording average, standard deviation etc.+         Histogram - a histogram of measurements falling in defined bucket+           boundaries.+         Window - a count of events that happen in reolling time window.+     New aggregation types can be added by the user, if desired (see+     census_register_aggregation()).+   * Metric: Each measurement is for a single metric. Examples include RPC+     latency, CPU seconds consumed, and bytes transmitted.+   * View: A view is a combination of a metric, a tag set (in which the tag+     values are regular expressions) and a set of aggregations. When a+     measurement for a metric matches the view tags, it is recorded (for each+     unique set of tags) against each aggregation. Each metric can have an+     arbitrary number of views by which it will be broken down.+*/++/* A single value to be recorded comprises two parts: an ID for the particular+ * metric and the value to be recorded against it. */ typedef struct {-  int id;+  gpr_uint32 metric_id;   double value;-} census_stat;+} census_value;++/* Record new usage values against the given context. */+void census_record_values(census_context *context, census_value *values,+                          size_t nvalues);++/** Structure used to describe an aggregation type. */+typedef struct {+  /* Create a new aggregation. The pointer returned can be used in future calls+     to clone(), free(), record(), data() and reset(). */+  void *(*create)(const void *create_arg);+  /* Make a copy of an aggregation created by create() */+  void *(*clone)(const void *aggregation);","Yes, it is needed internally when we want to create a new aggregation. We either have to clone/zero an existing one, or keep a copy of the initialization argument (which implies that we need more functions in census_aggregation_ops to clone and free that initialization argument). Adding the single clone function is cleaner/easier.",
10470441,maxwell-demon,https://api.github.com/repos/grpc/grpc/pulls/3107,38360677,2015-08-31T21:17:09Z,src/core/census/rpc_metric_id.h,"@@ -31,16 +31,21 @@  *  */ -#ifndef CENSUS_RPC_STAT_ID_H-#define CENSUS_RPC_STAT_ID_H+#ifndef CENSUS_RPC_METRIC_ID_H+#define CENSUS_RPC_METRIC_ID_H -/* Stats ID's used for RPC measurements. */-#define CENSUS_INVALID_STAT_ID 0     /* ID 0 is always invalid */-#define CENSUS_RPC_CLIENT_REQUESTS 1 /* Count of client requests sent. */-#define CENSUS_RPC_SERVER_REQUESTS 2 /* Count of server requests sent. */-#define CENSUS_RPC_CLIENT_ERRORS 3   /* Client error counts. */-#define CENSUS_RPC_SERVER_ERRORS 4   /* Server error counts. */-#define CENSUS_RPC_CLIENT_LATENCY 5  /* Client side request latency. */-#define CENSUS_RPC_SERVER_LATENCY 6  /* Server side request latency. */+/* Metric ID's used for RPC measurements. */+/* Count of client requests sent. */","Just like the default/stale handle, one use case is to answer the query ""how many record_stats() calls have invalid metric id across different processes?"", we can use it as a measure of the quality of stats.There are various scenarios that two processes (P_A and P_B) may see different metric id definitions (e.g. They are running different versions of binaries, or, there's a long latency to get updated metric ids from a centralized server). Having an common INVALID_METRIC_ID can allow us to globally collect and aggregate the stats of ""record against invalid metric id"".",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/3074,38388018,2015-09-01T06:07:13Z,examples/cpp/helloworld/greeter_async_server.cc,"@@ -67,56 +69,101 @@ class ServerImpl final {     std::string server_address(""0.0.0.0:50051"");      ServerBuilder builder;+    // Listen on the given address without any authentication mechanism.     builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());+    // Register ""service_"" as the instance through which we'll communicate with+    // clients. In this case it corresponds to an *asynchronous* service.     builder.RegisterAsyncService(&service_);+    // Get hold of the completion queue used for the asynchronous communication+    // with the gRPC runtime.     cq_ = builder.AddCompletionQueue();+    // Finally assemble the server.     server_ = builder.BuildAndStart();     std::cout << ""Server listening on "" << server_address << std::endl; +    // Proceed to the server's main loop.     HandleRpcs();   }   private:+  // Class encompasing the state and logic needed to serve a request.   class CallData {    public:+    // Take in the ""service"" instance (in this case representing an asynchronous+    // server) and the completion queue ""cq"" used for asynchronous communication+    // with the gRPC runtime.     CallData(Greeter::AsyncService* service, ServerCompletionQueue* cq)         : service_(service), cq_(cq), responder_(&ctx_), status_(CREATE) {+      // Invoke the serving logic right away.       Proceed();     }      void Proceed() {       if (status_ == CREATE) {+        // As part of the initial CREATE state, we *request* that the system+        // start processing SayHello requests. In this request, ""this"" acts are+        // the tag uniquely identifying the request (so that different CallData+        // instances can serve different requests concurrently), in this case+        // the memory address of this CallData instance.         service_->RequestSayHello(&ctx_, &request_, &responder_, cq_, cq_,                                   this);+        // Make this instance progress to the PROCESS state.         status_ = PROCESS;       } else if (status_ == PROCESS) {+        // Spawn a new CallData instance to serve new clients while we process+        // the one for this CallData. The instance will deallocate itself as+        // part of its FINISH state.         new CallData(service_, cq_);++        // The actual processing.         std::string prefix(""Hello "");         reply_.set_message(prefix + request_.name());++        // And we are done! Let the gRPC runtime now we've finished, using the+        // memory address of this instance as the uniquely identifying tag for+        // the event.         responder_.Finish(reply_, Status::OK, this);         status_ = FINISH;       } else {+        GPR_ASSERT(status_ == FINISH);+        // Once in the FINISH state, deallocate ourselves (CallData).         delete this;       }     }     private:+    // The means of communication with the gRPC runtime for an asynchronous+    // server.     Greeter::AsyncService* service_;+    // The producer-consumer queue where for asynchronous server notifications.     ServerCompletionQueue* cq_;+    // Context for the server, allowing to tweak aspects of it such as the use","This is more like context for the rpc than for the server, and it mostly presents rpc related information. It can also be used to send metadata.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/3074,38388378,2015-09-01T06:16:40Z,include/grpc++/client_context.h,"@@ -158,40 +216,65 @@ class ClientContext {   }  #ifndef GRPC_CXX0X_NO_CHRONO+  /// Return the deadline for the client call.   std::chrono::system_clock::time_point deadline() {     return Timespec2Timepoint(deadline_);   } #endif  // !GRPC_CXX0X_NO_CHRONO +  /// Return a \a gpr_timespec representation of the client call's deadline.   gpr_timespec raw_deadline() { return deadline_; } +  /// Set the per call authority header (see+  /// https://tools.ietf.org/html/rfc7540#section-8.1.2.3).   void set_authority(const grpc::string& authority) { authority_ = authority; } -  // Set credentials for the rpc.+  /// Return the authentication context for this client call.+  ///+  /// \see grpc::AuthContext.+  std::shared_ptr<const AuthContext> auth_context() const;++  /// Set credentials for the client call.+  ///+  /// A credentials object encapsulates all the state needed by a client to+  /// authenticate with a server and make various assertions, e.g., about the+  /// client’s identity, role, or whether it is authorized to make a particular+  /// call.+  ///+  /// \see https://github.com/grpc/grpc-common/blob/master/grpc-auth-support.md",Link is now: https://github.com/grpc/grpc/blob/master/doc/grpc-auth-support.md,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/3074,38489498,2015-09-02T00:41:56Z,include/grpc++/support/sync_stream.h,"@@ -151,17 +165,21 @@ class ClientReader GRPC_FINAL : public ClientReaderInterface<R> {   Call call_; }; +/// Client-side interface for streaming writes of message of type \a W. template <class W> class ClientWriterInterface : public ClientStreamingInterface,                               public WriterInterface<W> {  public:+  /// Block until writes are completed.","Looking at https://github.com/grpc/grpc/blob/master/include/grpc%2B%2B/support/sync_stream.h#L187, wouldn't the call to Pluck block if the cq is empty?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3195,38562087,2015-09-02T17:46:20Z,tools/jenkins/run_jenkins.sh,"@@ -117,6 +117,12 @@ elif [ ""$platform"" == ""macos"" ] then   echo ""building $language on MacOS"" +  # in some jenkins macos machine, somehow the PHP build script can't find libgrpc.dylib+  if [ ""$language"" == ""php"" ]+  then+    export DYLD_LIBRARY_PATH=$(pwd)/libs/$config","I think rather than here, this should be set in tools/run_tests/build_php.sh   and/or src/php/bin/run_tests.sh.see https://github.com/grpc/grpc/blob/debian/sid/tools/run_tests/run_csharp.sh",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/3205,38579988,2015-09-02T20:27:49Z,src/python/grpcio/grpc/beta/interfaces.py,"@@ -0,0 +1,54 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Constants and interfaces of the Beta API of gRPC Python.""""""++import enum+++@enum.unique+class StatusCode(enum.Enum):",Is there no more elegant way to indicate this Enum is coming from an IntEnum [elsewhere](https://github.com/grpc/grpc/blob/master/src/python/grpcio/grpc/_adapter/_types.py#L57)?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/3074,38599098,2015-09-02T23:42:47Z,include/grpc++/support/sync_stream.h,"@@ -151,17 +165,21 @@ class ClientReader GRPC_FINAL : public ClientReaderInterface<R> {   Call call_; }; +/// Client-side interface for streaming writes of message of type \a W. template <class W> class ClientWriterInterface : public ClientStreamingInterface,                               public WriterInterface<W> {  public:+  /// Block until writes are completed.","@ctiller , could you clarify under which conditions could this call block? ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3176,38607596,2015-09-03T02:13:32Z,include/grpc/grpc_security.h,"@@ -131,6 +131,32 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Callback function to be called by the metadata credentials plugin+   implementation when the metadata is ready. */+typedef void (*grpc_credentials_plugin_metadata_cb)(+    void *user_data, const grpc_metadata *creds_md, size_t num_creds_md,+    grpc_status_code status, const char *error_details);++typedef struct {+  /* The implementation of this method has to be non-blocking.+     - service_url is the fully qualified URL that the client stack is+       connecting to.+     - cb is the callback that needs to be called when the metadata is ready.+     - user_data needs to be passed as the first parameter of the callback. */","the ""user_data"" is basically a context object. Given it's unclear who's the ""user"" here (C core being ""user"" is a bit confusing), wouldn't it be better to call the param just ""context"" or ""opaque""?",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/3176,38609033,2015-09-03T02:51:06Z,include/grpc/grpc_security.h,"@@ -131,6 +131,32 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Callback function to be called by the metadata credentials plugin+   implementation when the metadata is ready. */+typedef void (*grpc_credentials_plugin_metadata_cb)(+    void *user_data, const grpc_metadata *creds_md, size_t num_creds_md,+    grpc_status_code status, const char *error_details);++typedef struct {+  /* The implementation of this method has to be non-blocking.+     - service_url is the fully qualified URL that the client stack is+       connecting to.+     - cb is the callback that needs to be called when the metadata is ready.+     - user_data needs to be passed as the first parameter of the callback. */",The naming is consistent with the rest of the code. We _could_ change it to `context` but I think that would be quite a big renaming change throughout the code.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3217,38665780,2015-09-03T16:27:49Z,include/grpc/grpc_security.h,"@@ -131,6 +131,34 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Function to be called by the metadata credentials plugin implementation when+   the metadata is ready. */+void grpc_credentials_plugin_metadata_notify(",naming seems inconsistent with grpc_metadata_credentials_plugin and grpc_metadata_credentials_create_from_plugin. Would any of these be better?grpc_metadata_credentials_notify()grpc_metadata_credentials_plugin_notify()  /\* that's my favorite */grpc_metadata_credentials_metadata_notify(),
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3217,38666414,2015-09-03T16:34:48Z,include/grpc/grpc_security.h,"@@ -131,6 +131,34 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Function to be called by the metadata credentials plugin implementation when+   the metadata is ready. */+void grpc_credentials_plugin_metadata_notify(+    void *core_context, const grpc_metadata *creds_md, size_t num_creds_md,","By calling this, core becomes the owner of metadata keys and values and caller owns the grpc_metadata array?",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/3217,38683403,2015-09-03T19:00:11Z,include/grpc/grpc_security.h,"@@ -131,6 +131,34 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Function to be called by the metadata credentials plugin implementation when+   the metadata is ready. */+void grpc_credentials_plugin_metadata_notify(",The problem with `grpc_metadata_credentials_plugin_notify` is that this implies that this is a method of the `grpc_metadata_credentials_plugin` (you would expect a pointer to this type as the first param).Howe about `grpc_metadata_credentials_notify_from_plugin`,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3217,38685408,2015-09-03T19:19:18Z,include/grpc/grpc_security.h,"@@ -131,6 +131,34 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Function to be called by the metadata credentials plugin implementation when+   the metadata is ready. */+void grpc_credentials_plugin_metadata_notify(",Sg. I mostly care about the prefixes being the same so that it's obvious that these things belong together.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3248,39080185,2015-09-09T18:41:03Z,src/core/client_config/lb_policy_factory.h,"@@ -0,0 +1,70 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CORE_CLIENT_CONFIG_LB_POLICY_FACTORY_H+#define GRPC_INTERNAL_CORE_CLIENT_CONFIG_LB_POLICY_FACTORY_H++#include ""src/core/client_config/lb_policy.h""+#include ""src/core/client_config/subchannel.h""++typedef struct grpc_lb_policy_factory grpc_lb_policy_factory;+typedef struct grpc_lb_policy_factory_vtable grpc_lb_policy_factory_vtable;++/** grpc_lb_policy provides grpc_client_config objects to grpc_channel+    objects */+struct grpc_lb_policy_factory {+  const grpc_lb_policy_factory_vtable *vtable;+};++struct grpc_lb_policy_factory_vtable {+  void (*ref)(grpc_lb_policy_factory *factory);+  void (*unref)(grpc_lb_policy_factory *factory);++  /** Implementation of grpc_lb_policy_factory_create_lb_policy */+  grpc_lb_policy *(*create_lb_policy)(grpc_lb_policy_factory *factory,+                                      grpc_subchannel **subchannels,+                                      size_t num_subchannels);","Can we remove these two arguments (subchannels, num_subchannels), and replace them with a grpc_lb_policy_args *args... where:```struct grpc_lb_policy_args {  grpc_lb_policy_factory *factory;  grpc_subchannel **subchannels;};```Rationale: it'll make extending this argument list so much easier in the future",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/3176,39578751,2015-09-15T23:28:33Z,include/grpc/grpc_security.h,"@@ -131,6 +131,32 @@ grpc_credentials *grpc_google_iam_credentials_create(     const char *authorization_token, const char *authority_selector,     void *reserved); +/* Callback function to be called by the metadata credentials plugin+   implementation when the metadata is ready. */+typedef void (*grpc_credentials_plugin_metadata_cb)(+    void *user_data, const grpc_metadata *creds_md, size_t num_creds_md,+    grpc_status_code status, const char *error_details);++typedef struct {+  /* The implementation of this method has to be non-blocking.+     - service_url is the fully qualified URL that the client stack is+       connecting to.+     - cb is the callback that needs to be called when the metadata is ready.+     - user_data needs to be passed as the first parameter of the callback. */",Added more documentation so that the use of these parameters is clearer.,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/3176,39804898,2015-09-17T22:04:43Z,include/grpc++/security/credentials.h,"@@ -165,6 +168,24 @@ std::shared_ptr<Credentials> CompositeCredentials( /// Credentials for an unencrypted, unauthenticated channel std::shared_ptr<Credentials> InsecureCredentials(); +// User defined metadata credentials.+class MetadataCredentialsPlugin {+ public:+  virtual ~MetadataCredentialsPlugin() {}++  // If this method returns true, the Process function will be scheduled in+  // a different thread from the one processing the call.+  virtual bool IsBlocking() const { return true; }++  // Gets the auth metatada produced by this plugin. */","Should it say ""Sets the auth metadata ..."" instead? The `*/` at the end of line is redundant.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/3176,39912125,2015-09-19T00:01:00Z,include/grpc++/security/credentials.h,"@@ -165,6 +168,24 @@ std::shared_ptr<Credentials> CompositeCredentials( /// Credentials for an unencrypted, unauthenticated channel std::shared_ptr<Credentials> InsecureCredentials(); +// User defined metadata credentials.+class MetadataCredentialsPlugin {+ public:+  virtual ~MetadataCredentialsPlugin() {}++  // If this method returns true, the Process function will be scheduled in+  // a different thread from the one processing the call.+  virtual bool IsBlocking() const { return true; }++  // Gets the auth metatada produced by this plugin. */","Removed the `*/`, thanks!I don't think that it should be ""Sets the auth metadata..."". We're getting the metadata here by giving the address of a map that will be populated by the plugin.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3367,40003309,2015-09-21T17:59:49Z,src/python/grpcio_test/grpc_test/_adapter/_low_test.py,"@@ -193,13 +193,13 @@ def testEcho(self):       self.assertNotIn(client_result.type, found_client_op_types)       found_client_op_types.add(client_result.type)       if client_result.type == _types.OpType.RECV_INITIAL_METADATA:-        self.assertEqual(dict(server_initial_metadata),-                         dict(client_result.initial_metadata))+        self.assertLessEqual(set(server_initial_metadata),",Let's reduce the number of definitions of metadata transmission that we have running around the codebase and delegate this judgement to grpc_test.test_common.metadata_transmitted?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3400,40107070,2015-09-22T16:16:26Z,tools/run_tests/run_tests.py,"@@ -501,6 +565,11 @@ def make_jobspec(cfg, targets): make_targets = list(set(itertools.chain.from_iterable(                                          l.make_targets() for l in languages))) build_steps = []+build_steps.extend(set(",Replace```<name> = []<name>.extend(<set expression>)```with```<name> = list(<set expression>)```.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3188,40131610,2015-09-22T19:21:54Z,tools/dockerfile/grpc_python/Dockerfile,"@@ -40,28 +40,13 @@ RUN make install_c -j12 -C /var/local/git/grpc  # Build Python GRPC RUN cd /var/local/git/grpc \-  && pip install src/python/src \-  && pip install src/python/interop+  && pip install src/python/grpcio \+  && pip install src/python/grpcio_test  # Run Python GRPC's tests # TODO(nathaniel): It would be nice for these to be auto-discoverable?",This TODO smells out-of-date and like it should be removed in this change.,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/3446,40271670,2015-09-23T23:36:24Z,examples/node/README.md,"@@ -55,6 +45,5 @@ TUTORIAL You can find a more detailed tutorial in [gRPC Basics: Node.js][]  [homebrew]:http://brew.sh-[linuxbrew]:https://github.com/Homebrew/linuxbrew#installation-[gRPC install script]:https://raw.githubusercontent.com/grpc/homebrew-grpc/master/scripts/install-[gRPC Basics: Node.js]:https://github.com/grpc/grpc/blob/master/examples/node/route_guide/README.md+[Install gRPC Core]:../../INSTALL","You don't need to install the Node.js library specifically. As long as you have core on your system, you can do `npm install` with a package that depends on grpc (like this examples package), and everything will be installed properly.",
9272342,tbetbetbe,https://api.github.com/repos/grpc/grpc/pulls/3446,40382314,2015-09-24T22:40:54Z,examples/node/README.md,"@@ -5,21 +5,11 @@ PREREQUISITES -------------  - `node`: This requires Node 10.x or greater.-- [homebrew][] on Mac OS X, [linuxbrew][] on Linux.  These simplify the installation of the gRPC C core.+- [homebrew][] on Mac OS X.  This simplifies the.",this sentence is incomplete,
10121772,iamqizhao,https://api.github.com/repos/grpc/grpc/pulls/3631,41189507,2015-10-05T19:59:18Z,tools/jenkins/grpc_interop_go/build_interop.sh,"@@ -0,0 +1,48 @@+#!/bin/bash+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#+# Builds Go interop server and client in a base image.+set -e++# Clone just the grpc-go source code without any dependencies.+# We are cloning from a local git repo that contains the right revision+# to test instead of using ""go get"" to download from Github directly.+git clone --recursive /var/local/jenkins/grpc-go src/gooogle.golang.org/grpc++# Get dependencies from GitHub","Add a note that if the dependency of grpc-go is changed, this section needs to be updated correspondingly.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/3643,41273535,2015-10-06T14:47:25Z,src/core/channel/client_uchannel.c,"@@ -0,0 +1,573 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/channel/client_uchannel.h""++#include <string.h>++#include ""src/core/census/grpc_filter.h""+#include ""src/core/channel/channel_args.h""+#include ""src/core/channel/client_channel.h""+#include ""src/core/channel/compress_filter.h""+#include ""src/core/iomgr/iomgr.h""+#include ""src/core/support/string.h""+#include ""src/core/surface/channel.h""+#include ""src/core/transport/connectivity_state.h""++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/useful.h>++/** Microchannel (uchannel) implementation: a lightweight channel without any",Let's sit together and discuss today - but I think there's two possible approaches to getting there:- factor out some shared parts of client_channel & uchannel- factor the waiting for connect logic into subchannel (the model where subchannel_call_create returns immediately).I think seeing this all together I'm leaning towards moving things into subchannel - as it'll drastically collapse the complexity of this module. Need to think through how to remove some locking overheads though.,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3610,41291637,2015-10-06T17:00:32Z,src/core/iomgr/pollset_posix.h,"@@ -111,6 +112,15 @@ void grpc_kick_drain(grpc_pollset *p); int grpc_poll_deadline_to_millis_timeout(gpr_timespec deadline,                                          gpr_timespec now); +/* Allow kick to wakeup the currently polling worker */+#define GRPC_POLLSET_CAN_KICK_SELF 1+/* Force the wakee to repoll when awoken */+#define GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP 2+/* As per grpc_pollset_kick, with an extended set of flags (defined above)+   -- mostly for fd_posix's use. */+void grpc_pollset_kick_ex(grpc_pollset *p, grpc_pollset_worker *specific_worker,","The suffix _ex is a little confusing; suggest something different like _ext. _ex makes me think exclusive, as though it should be a kick exclusive of one of the parameters.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3638,41296365,2015-10-06T17:38:43Z,tools/run_tests/build_python.sh,"@@ -39,6 +39,46 @@ GRPCIO=$ROOT/src/python/grpcio GRPCIO_TEST=$ROOT/src/python/grpcio_test GRPCIO_HEALTH_CHECKING=$ROOT/src/python/grpcio_health_checking +#",In languages that aren't Bash when I see stanza-delineating comments like these I suggest to the author that the file has gotten too large and should be broken up. Is that the case here? This stanza is just two functions; why bother with the comments anyway?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3610,41302768,2015-10-06T18:27:27Z,src/core/iomgr/fd_posix.c,"@@ -391,24 +364,39 @@ void grpc_fd_end_poll(grpc_exec_ctx *exec_ctx, grpc_fd_watcher *watcher,     return;   } -  gpr_mu_lock(&fd->watcher_mu);+  gpr_mu_lock(&fd->mu);+   if (watcher == fd->read_watcher) {     /* remove read watcher, kick if we still need a read */     was_polling = 1;-    kick = kick || !got_read;+    if (!got_read) {+      kick = 1;+    }",Just curious about the reason for this style of change; aren't they semantically equivalent? Maybe this is easier to read?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3610,41303586,2015-10-06T18:33:29Z,src/core/iomgr/pollset_posix.c,"@@ -218,29 +251,42 @@ void grpc_pollset_work(grpc_exec_ctx *exec_ctx, grpc_pollset *pollset,     locked = 0;     goto done;   }-  if (!pollset->kicked_without_pollers) {-    push_front_worker(pollset, worker);-    added_worker = 1;-    gpr_tls_set(&g_current_thread_poller, (gpr_intptr)pollset);-    gpr_tls_set(&g_current_thread_worker, (gpr_intptr)worker);-    pollset->vtable->maybe_work_and_unlock(exec_ctx, pollset, worker, deadline,-                                           now);-    locked = 0;-    gpr_tls_set(&g_current_thread_poller, 0);-    gpr_tls_set(&g_current_thread_worker, 0);-  } else {-    pollset->kicked_without_pollers = 0;-  }-done:-  if (!locked) {-    grpc_exec_ctx_flush(exec_ctx);-    gpr_mu_lock(&pollset->mu);-    locked = 1;+  for (;;) {",The complexity of this code has gone up substantially as a result of this PR; can we get some comments?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3792,41691861,2015-10-10T02:27:22Z,tools/run_tests/jobset.py,"@@ -210,7 +210,7 @@ def state(self, update_cache):       # TODO: looks like jenkins master is slow because parsing the junit results XMLs is not","how about we update the comment to say that it's not the main cause of slowness but we still want to make sure we don't store overly huge logs.Btw, do you think that an average stacktrace would be about 2KB in size? My very rough guess would be that it's a bit bigger. Let's try 4-10KB?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3811,41891848,2015-10-13T16:41:25Z,tools/jenkins/run_interop.sh,"@@ -0,0 +1,37 @@+#!/usr/bin/env bash+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#+# This script is invoked by Jenkins and runs interop test suite.+set -ex++# Enter the gRPC repo root+cd `dirname $0`/../..",Did that along with some more improvements.,
150108,hsaliak,https://api.github.com/repos/grpc/grpc/pulls/3822,42173130,2015-10-15T20:05:58Z,src/python/README.md,"@@ -8,7 +8,7 @@ Beta : Core behavior well-used and proven; bugs lurk off the beaten path.  PREREQUISITES --------------- Python 2.7, virtualenv, pip+- virtualenv, pip, python-dev, python3-dev",are both needed? or is it an or condition?python-dev or python3-dev?,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/3854,42189323,2015-10-15T22:30:17Z,src/php/tests/interop/interop_client.php,"@@ -36,6 +36,9 @@ require 'message_set.php'; require 'messages.php'; require 'test.php';+use Google\Auth\CredentialsLoader;+use Google\Auth\ApplicationDefaultCredentials;+use GuzzleHttp\ClientInterface;",So that when I use the class I don't need to fully qualify the class with the namespace each time. Just to save a few characters on long lines,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/3854,42189705,2015-10-15T22:33:38Z,src/php/tests/interop/interop_client.php,"@@ -36,6 +36,9 @@ require 'message_set.php'; require 'messages.php'; require 'test.php';+use Google\Auth\CredentialsLoader;+use Google\Auth\ApplicationDefaultCredentials;+use GuzzleHttp\ClientInterface;","As for the class itself, I need it to match the signature of the auth library `update_metadata` function.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/3822,42302579,2015-10-17T00:32:00Z,src/python/README.md,"@@ -8,7 +8,7 @@ Beta : Core behavior well-used and proven; bugs lurk off the beaten path.  PREREQUISITES --------------- Python 2.7, virtualenv, pip+- virtualenv, pip, python-dev, python3-dev","I was under the impression that it'd be one or the other after a certain point. I'd be more comfortable with it just saying `python-dev` for now.Also, I assume we're using package names? If so, s/`virtualenv`/`python-virtualenv` and s/`pip`/`python-pip`. `pip` also has a `python3-*` variant, so if we're listing Python 3 as a prereq we should probably mention `python3-pip`.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/3868,42431825,2015-10-19T22:01:47Z,test/cpp/interop/interop_client.cc,"@@ -83,7 +83,7 @@ CompressionType GetInteropCompressionTypeFromCompressionAlgorithm( }  // namespace  InteropClient::InteropClient(std::shared_ptr<Channel> channel)-    : channel_(channel) {}+    : channel_(channel), stub_(TestService::NewStub(channel)) {}","This is cleaner, but are we sure it doesn't change the semantics? Prior, the stub was re-created per testcase. This way, the same stub is reused.",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/3868,42438914,2015-10-19T23:25:15Z,test/cpp/interop/stress_interop_client.h,"@@ -0,0 +1,103 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *is % allowed in string+ */++#ifndef GRPC_TEST_CPP_STRESS_INTEROP_CLIENT_H+#define GRPC_TEST_CPP_STRESS_INTEROP_CLIENT_H++#include <memory>+#include <string>+#include <vector>++#include <grpc++/create_channel.h>++#include ""test/cpp/interop/interop_client.h""++namespace grpc {+namespace testing {++using std::pair;+using std::string;+using std::vector;++// TODO(sreek): Add more test cases here in future+enum TestCaseType {+  UNKNOWN_TEST = -1,+  EMPTY_UNARY = 0,+  LARGE_UNARY = 1,+  LARGE_COMPRESSED_UNARY = 2,+  CLIENT_STREAMING = 3,+  SERVER_STREAMING = 4,+  EMPTY_STREAM = 5+};++const vector<pair<TestCaseType, string>> kTestCaseList = {+    {EMPTY_UNARY, ""empty_unary""},+    {LARGE_UNARY, ""large_unary""},+    {LARGE_COMPRESSED_UNARY, ""large_compressed_unary""},+    {CLIENT_STREAMING, ""client_streaming""},+    {SERVER_STREAMING, ""server_streaming""},+    {EMPTY_STREAM, ""empty_stream""}};++class TestSelector {+ public:+  TestSelector(const vector<pair<TestCaseType, int>>& tests);+  TestCaseType GetNextTest() const;++ private:+  const vector<pair<TestCaseType, int>> tests_;+  int total_weight_;",Renamed the class to WeightedRandomTestSelector and added a comment on what it does.,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/3868,42438951,2015-10-19T23:25:51Z,test/cpp/interop/stress_test.cc,"@@ -0,0 +1,221 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *is % allowed in string+ */++#include <memory>+#include <string>+#include <thread>+#include <utility>+#include <vector>++#include <gflags/gflags.h>+#include <grpc/support/time.h>+#include <grpc++/create_channel.h>+#include <grpc++/grpc++.h>++#include ""test/cpp/interop/interop_client.h""+#include ""test/cpp/interop/stress_interop_client.h""+#include ""test/cpp/util/test_config.h""++DEFINE_int32(sleep_duration_ms, 0,+             ""The duration (in millisec) between two""+             "" consecutive test calls (per server) issued by the server."");++DEFINE_int32(test_duration_secs, -1,+             ""The length of time (in seconds) to run""+             "" the test. Enter -1 if the test should run continuously until""+             "" forcefully terminated."");++DEFINE_string(server_addresses, ""localhost:8080"",+              ""The list of server""+              "" addresses in the format:\n""+              "" \""<name_1>:<port_1>,<name_2>:<port_1>...<name_N>:<port_N>\""\n""+              "" Note: <name> can be servername or IP address."");++// TODO(sreek): Add more test cases here in future+DEFINE_string(test_cases, """",+              ""List of test cases to call along with the""+              "" relative weights in the following format:\n""+              "" \""<testcase_1:w_1>,<testcase_2:w_2>...<testcase_n:w_n>\""\n""+              "" The following testcases are currently supported:\n""+              ""   empty_unary\n""+              ""   large_unary\n""+              ""   large_compressed_unary\n""+              ""   client_streaming\n""+              ""   server_streaming\n""+              ""   empty_stream\n""+              "" Example: \""empty_unary:20,large_unary:10,empty_stream:70\""\n""+              "" The above will execute 'empty_unary', 20% of the time,""+              "" 'large_unary', 10% of the time and 'empty_stream' the remaining""+              "" 70% of the time"");++using std::make_pair;+using std::pair;+using std::string;+using std::thread;+using std::vector;++using grpc::testing::kTestCaseList;+using grpc::testing::StressTestInteropClient;+using grpc::testing::TestCaseType;+using grpc::testing::TestSelector;+using grpc::testing::UNKNOWN_TEST;++TestCaseType get_test_type_from_name(const string& test_name) {+  TestCaseType test_case = UNKNOWN_TEST;++  for (auto it = kTestCaseList.begin(); it != kTestCaseList.end(); it++) {+    if (test_name == it->second) {+      test_case = it->first;+      break;+    }+  }++  return test_case;+}++bool ParseCommaDelimitedString(const string& comma_delimited_str,+                               vector<string>& tokens) {+  size_t bpos = 0;+  size_t epos = string::npos;++  while ((epos = comma_delimited_str.find(',', bpos)) != string::npos) {+    tokens.emplace_back(comma_delimited_str.substr(bpos, epos - bpos));+    bpos = epos + 1;+  }++  tokens.emplace_back(comma_delimited_str.substr(bpos));  // Last token+  return true;+}++// Input: Test case string ""<testcase_name:weight>,<testcase_name:weight>....""+// Output:+//   - Whether parsing was successful (return value)+//   - Vector of (test_type_enum, weight) pairs+bool ParseTestCasesString(const string& test_cases,+                          vector<pair<TestCaseType, int>>& tests) {+  bool is_success = true;++  vector<string> tokens;+  ParseCommaDelimitedString(test_cases, tokens);++  for (auto it = tokens.begin(); it != tokens.end(); it++) {+    // Token is in the form <test_name>:<test_weight>+    size_t colon_pos = it->find(':');+    if (colon_pos == string::npos) {+      gpr_log(GPR_ERROR, ""Error in parsing test case string: %s"", it->c_str());+      is_success = false;+      break;+    }++    string test_name = it->substr(0, colon_pos);",This is the output parameter that holds the parsed test case values.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3871,42529049,2015-10-20T17:48:22Z,tools/run_tests/jobset.py,"@@ -211,6 +223,8 @@ def state(self, update_cache):       # implemented efficiently. This is an experiment to workaround the issue by making sure       # results.xml file is small enough.       filtered_stdout = filtered_stdout[-128:]+      self.result.message = filtered_stdout+      self.result.elapsed_time = elapsed       if self._xml_test is not None:","After this change, there will be two independent ways to report the test result: using the JobResult class you've created and using the _xml_test element.I think that's fine for now, but eventually, we should probably refactor the code so that the report.xml file is built from the JobResult class instances (I am not a big fan of the way we currently build the xml report directly from Job class' method). What do you think?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,42674040,2015-10-21T19:59:35Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;","Not all the languages support sync vs async client and server. Do we want to provide a default option? Also, because of proto3 default value semantics, SYNCHRONOUS_CLIENT is the default value for this field here, which is wrong for languages that actually don't support a sync client (or server).Also, I is there going to be some more language specific options? (I can easily imagine some setting for server or client can can influence the performance drastically so we would want to test with and without it and we have no notion of specifying per-language options right now.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,42675192,2015-10-21T20:08:58Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;",looks like the LoadType enum basically duplicates the implicit oneof case enum here.  Would it be worth adding CloseLoopParams closeLoop and get rid of LoadType enum entirely?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,42675715,2015-10-21T20:13:21Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;+  int32 outstanding_rpcs_per_channel = 4;+  int32 client_channels = 5;+  int32 payload_size = 6;+  // only for async client:+  int32 async_client_threads = 7;+  RpcType rpc_type = 8;+  string host = 9;+  LoadType load_type = 10;+  LoadParams load_params = 11;+}++message ClientStatus {+  ClientStats stats = 1;+}++// Request current stats+message Mark {+}++message ClientArgs {+  oneof argtype {+    ClientConfig setup = 1;+    Mark mark = 2;+  }+}++message ServerConfig {+  ServerType server_type = 1;+  int32 threads = 2;+  bool enable_ssl = 3;+  string host = 4;+}++message ServerArgs {+  oneof argtype {+    ServerConfig setup = 1;+    Mark mark = 2;+  }+}++message ServerStatus {+  ServerStats stats = 1;+  int32 port = 2;+}++service TestService {+  // One request followed by one response.+  // The server returns the client payload as-is.+  rpc UnaryCall(SimpleRequest) returns (SimpleResponse);++  // One request followed by one response.+  // The server returns the client payload as-is.+  rpc StreamingCall(stream SimpleRequest) returns (stream SimpleResponse);+}++service Worker {",I think the naming convention requires the Service suffix. rename to WorkerService or PerfWorkerService?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,42675873,2015-10-21T20:14:32Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;+  int32 outstanding_rpcs_per_channel = 4;+  int32 client_channels = 5;+  int32 payload_size = 6;+  // only for async client:+  int32 async_client_threads = 7;+  RpcType rpc_type = 8;+  string host = 9;+  LoadType load_type = 10;+  LoadParams load_params = 11;+}++message ClientStatus {+  ClientStats stats = 1;+}++// Request current stats+message Mark {+}++message ClientArgs {+  oneof argtype {+    ClientConfig setup = 1;+    Mark mark = 2;+  }+}++message ServerConfig {+  ServerType server_type = 1;+  int32 threads = 2;+  bool enable_ssl = 3;+  string host = 4;+}++message ServerArgs {+  oneof argtype {+    ServerConfig setup = 1;+    Mark mark = 2;+  }+}++message ServerStatus {+  ServerStats stats = 1;+  int32 port = 2;+}++service TestService {+  // One request followed by one response.+  // The server returns the client payload as-is.+  rpc UnaryCall(SimpleRequest) returns (SimpleResponse);++  // One request followed by one response.+  // The server returns the client payload as-is.+  rpc StreamingCall(stream SimpleRequest) returns (stream SimpleResponse);+}++service Worker {","Excellent comments, will address soon.On Wed, Oct 21, 2015 at 1:13 PM Jan Tattermusch notifications@github.comwrote:> In test/proto/perf_control.proto> https://github.com/grpc/grpc/pull/3905#discussion_r42675715:> > > +message ServerStatus {> > -  ServerStats stats = 1;> > -  int32 port = 2;> >   +}> >   +> >   +service TestService {> > -  // One request followed by one response.> > -  // The server returns the client payload as-is.> > -  rpc UnaryCall(SimpleRequest) returns (SimpleResponse);> >   +> > -  // One request followed by one response.> > -  // The server returns the client payload as-is.> > -  rpc StreamingCall(stream SimpleRequest) returns (stream SimpleResponse);> >   +}> >   +> >   +service Worker {> > I think the naming convention requires the Service suffix.> rename to WorkerService or PerfWorkerService?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/3905/files#r42675715.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,42828611,2015-10-23T02:38:55Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;","Because there's no use_test_ca parameter, I assume all the clients will always use a test CA? That's fine if we don't plan to test against  prod servers.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,42829046,2015-10-23T02:50:59Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;+  int32 outstanding_rpcs_per_channel = 4;+  int32 client_channels = 5;+  int32 payload_size = 6;+  // only for async client:+  int32 async_client_threads = 7;+  RpcType rpc_type = 8;+  string host = 9;+  LoadType load_type = 10;+  LoadParams load_params = 11;+}++message ClientStatus {+  ClientStats stats = 1;+}++// Request current stats+message Mark {+}++message ClientArgs {+  oneof argtype {+    ClientConfig setup = 1;+    Mark mark = 2;+  }+}++message ServerConfig {+  ServerType server_type = 1;+  int32 threads = 2;+  bool enable_ssl = 3;+  string host = 4;+}++message ServerArgs {+  oneof argtype {+    ServerConfig setup = 1;+    Mark mark = 2;+  }+}++message ServerStatus {+  ServerStats stats = 1;+  int32 port = 2;+}++service TestService {+  // One request followed by one response.+  // The server returns the client payload as-is.+  rpc UnaryCall(SimpleRequest) returns (SimpleResponse);++  // One request followed by one response.+  // The server returns the client payload as-is.+  rpc StreamingCall(stream SimpleRequest) returns (stream SimpleResponse);+}++service Worker {+  // Start server with specified workload+  rpc RunServer(stream ServerArgs) returns (stream ServerStatus);","What is the semantics for shutting down the client/ server? It it that once the request stream is closed, the worker will shutdown the client/server?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,42914985,2015-10-23T21:13:20Z,test/proto/perf_stats.proto,"@@ -0,0 +1,62 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++package grpc.testing;++message ServerStats {+  // wall clock time+  double time_elapsed = 1;++  // user time used by the server process and threads+  double time_user = 2;++  // server time used by the server process and all threads+  double time_system = 3;+}++message HistogramData {+  repeated uint32 bucket = 1;",We will add the parameter defining the bucket boundaries to this proto. We will also need to add a comment explaining how the buckets are set,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3961,43034499,2015-10-26T18:39:35Z,src/objective-c/change-comments.py,"@@ -0,0 +1,102 @@+#!/usr/bin/python++import re+import sys+++if len(sys.argv) < 2:+  print(""Please provide at least one source file name as argument."")+  quit()++for file_name in sys.argv[1:]:++  print(""Modifying format of {file} comments in place..."".format(+      file = file_name,+  ))+++  # Input++  lines = []",The value assigned to `lines` on this line cannot possibly be used before `lines` is reassigned to a different value. Isn't this dead code?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/3961,43058843,2015-10-26T21:53:10Z,src/objective-c/change-comments.py,"@@ -0,0 +1,102 @@+#!/usr/bin/python++import re+import sys+++if len(sys.argv) < 2:+  print(""Please provide at least one source file name as argument."")+  quit()","Wow. Okay, I'd never before ever heard of `quit`, but it looks like it's documented at https://docs.python.org/2/library/constants.html#quit. Wow.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/3968,43059337,2015-10-26T21:57:31Z,examples/objective-c/route_guide/Podfile,"@@ -2,6 +2,8 @@ source 'https://github.com/CocoaPods/Specs.git' platform :ios, '8.0'  target 'RouteGuideClient' do+  pod 'Protobuf', :path => ""../../../third_party/protobuf""","Remember, this means that people will be required to clone submodules before using the examples. Are you sure we want to do that?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,43231548,2015-10-28T09:16:48Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;","BTW, thank you for looking over this whole file. I know how this materialized - we built a lot of this up in proto2 and then switched to proto3 which has proper oneof support, etc., and this was all added and reviewed incrementally. I had lost track of the big picture and never revisited to see if we could do it better. ",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,43288230,2015-10-28T17:21:49Z,test/proto/perf_stats.proto,"@@ -0,0 +1,62 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++package grpc.testing;++message ServerStats {+  // wall clock time+  double time_elapsed = 1;++  // user time used by the server process and threads+  double time_user = 2;","We should keep in mind that these are not necessarily be available for wrapped languages  and will not be available on Windows (or might have a slightly different semantics).If not supported, they should be reported as zero here?",
14932100,adelez,https://api.github.com/repos/grpc/grpc/pulls/4008,43529838,2015-10-30T17:33:24Z,tools/run_tests/jobset.py,"@@ -229,15 +226,12 @@ def state(self, update_cache):       self._tempfile.seek(0)       stdout = self._tempfile.read()       filtered_stdout = _filter_stdout(stdout)","I'm afraid without truncating, the resultset object may be unnecessarily too big to hold in memory if you run all the tests many times.How about I move the escaping part, but leave the truncating part here.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,43770837,2015-11-03T16:33:43Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;","Ok, if the issue of test CA vs real CA affects performance, then it is worth including just like the interop tests. Question: we probably should be benchmarking connection time, right? Something like QPS of just connects, though I suppose that this is not valid for lazy connections. Also latency of connectivity state change.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,43772252,2015-11-03T16:43:28Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;","One more note for future reference: I am not including any support for compression in these tests as that would then also require real data. This might become a thing later, but not this day....",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/3905,43795865,2015-11-03T19:35:52Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;","The problem with not including use_test_ca field here is that if we later reintroduce it, it will have a default value of false (bcuz proto3), which is in conflict with our current test semantics (where we are testing with use_test_ca = true by default).Besides this point, I don't feel strongly.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,43799000,2015-11-03T19:59:02Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;","I will add the field now. This is a different situation from compress wherea default value of false is ok if we decide to add it later.On Tue, Nov 3, 2015 at 11:36 AM Jan Tattermusch notifications@github.comwrote:> In test/proto/perf_control.proto> https://github.com/grpc/grpc/pull/3905#discussion_r43795865:> > > -  double alpha = 2;> >   +}> >   +> >   +message LoadParams {> > -  oneof load {> > -    PoissonParams poisson = 1;> > -    UniformParams uniform = 2;> > -    DeterministicParams determ = 3;> > -    ParetoParams pareto = 4;> > -  };> >   +}> >   +> >   +message ClientConfig {> > -  repeated string server_targets = 1;> > -  ClientType client_type = 2;> > -  bool enable_ssl = 3;> > The problem with not including use_test_ca field here is that if we later> reintroduce it, it will have a default value of false (bcuz proto3), which> is in conflict with our current test semantics (where we are testing with> use_test_ca = true by default).> > Besides this point, I don't feel strongly.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/3905/files#r43795865.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/3905,43799049,2015-11-03T19:59:24Z,test/proto/perf_control.proto,"@@ -0,0 +1,154 @@+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++import ""test/proto/messages.proto"";+import ""test/proto/perf_stats.proto"";++package grpc.testing;++enum ClientType {+  SYNCHRONOUS_CLIENT = 0;+  ASYNC_CLIENT = 1;+}++enum ServerType {+  SYNCHRONOUS_SERVER = 0;+  ASYNC_SERVER = 1;+}++enum RpcType {+  UNARY = 0;+  STREAMING = 1;+}++enum LoadType {+  CLOSED_LOOP = 0;+  POISSON = 1;+  UNIFORM = 2;+  DETERMINISTIC = 3;+  PARETO = 4;+}++message PoissonParams {+  double offered_load = 1;+}++message UniformParams {+  double interarrival_lo = 1;+  double interarrival_hi = 2;+}++message DeterministicParams {+  double offered_load = 1;+}++message ParetoParams {+  double interarrival_base = 1;+  double alpha = 2;+}++message LoadParams {+  oneof load {+    PoissonParams poisson = 1;+    UniformParams uniform = 2;+    DeterministicParams determ = 3;+    ParetoParams pareto = 4;+  };+}++message ClientConfig {+  repeated string server_targets = 1;+  ClientType client_type = 2;+  bool enable_ssl = 3;","or we can just use negative-logic booleans , ha ha ha.On Tue, Nov 3, 2015 at 11:58 AM Vijay Pai vpai@google.com wrote:> I will add the field now. This is a different situation from compress> where a default value of false is ok if we decide to add it later.> > On Tue, Nov 3, 2015 at 11:36 AM Jan Tattermusch notifications@github.com> wrote:> > > In test/proto/perf_control.proto> > https://github.com/grpc/grpc/pull/3905#discussion_r43795865:> > > > > -  double alpha = 2;> > >   +}> > >   +> > >   +message LoadParams {> > > -  oneof load {> > > -    PoissonParams poisson = 1;> > > -    UniformParams uniform = 2;> > > -    DeterministicParams determ = 3;> > > -    ParetoParams pareto = 4;> > > -  };> > >   +}> > >   +> > >   +message ClientConfig {> > > -  repeated string server_targets = 1;> > > -  ClientType client_type = 2;> > > -  bool enable_ssl = 3;> > > > The problem with not including use_test_ca field here is that if we later> > reintroduce it, it will have a default value of false (bcuz proto3), which> > is in conflict with our current test semantics (where we are testing with> > use_test_ca = true by default).> > > > Besides this point, I don't feel strongly.> > > > —> > Reply to this email directly or view it on GitHub> > https://github.com/grpc/grpc/pull/3905/files#r43795865.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/4035,44050835,2015-11-05T18:44:09Z,test/proto/metrics.proto,"@@ -0,0 +1,51 @@++// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++package grpc.testing;++message GaugeResponse {+  string name = 1;+  int64 value = 2;","Since it is appropriate to have some value metrics be float and some be int, I would suggest making a oneof that allows either int or float value. That will help to avoid some awkward behavior like having qps be a long in other parts of the code.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4046,44059713,2015-11-05T19:47:55Z,tools/run_tests/jobset.py,"@@ -203,12 +203,23 @@ def start(self):     env.update(self._spec.environ)     env.update(self._add_env)     self._start = time.time()-    self._process = subprocess.Popen(args=self._spec.cmdline,-                                     stderr=subprocess.STDOUT,-                                     stdout=self._tempfile,-                                     cwd=self._spec.cwd,-                                     shell=self._spec.shell,-                                     env=env)+    try_start = lambda: subprocess.Popen(args=self._spec.cmdline,+                                         stderr=subprocess.STDOUT,+                                         stdout=self._tempfile,+                                         cwd=self._spec.cwd,+                                         shell=self._spec.shell,+                                         env=env)+    delay = 0.3+    for i in range(0, 4):+      try:+        self._process = try_start()+        break+      except OSError:+        message('WARNING', 'Failed to start %s, retrying in %f seconds' % (self._spec.shortname, delay))+        time.sleep(delay)+        delay *= 2+    else:+      self._process = try_start()     self._state = _RUNNING ","If we fail to start a binary, we'll throw an unhandled exception and the run will be aborted.I think this is sufficient (if we try to start an invalid binary, that's a bug in the calling code).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4046,44059771,2015-11-05T19:48:16Z,tools/run_tests/jobset.py,"@@ -203,12 +203,23 @@ def start(self):     env.update(self._spec.environ)     env.update(self._add_env)     self._start = time.time()-    self._process = subprocess.Popen(args=self._spec.cmdline,-                                     stderr=subprocess.STDOUT,-                                     stdout=self._tempfile,-                                     cwd=self._spec.cwd,-                                     shell=self._spec.shell,-                                     env=env)+    try_start = lambda: subprocess.Popen(args=self._spec.cmdline,+                                         stderr=subprocess.STDOUT,+                                         stdout=self._tempfile,+                                         cwd=self._spec.cwd,+                                         shell=self._spec.shell,+                                         env=env)+    delay = 0.3+    for i in range(0, 4):+      try:+        self._process = try_start()+        break+      except OSError:+        message('WARNING', 'Failed to start %s, retrying in %f seconds' % (self._spec.shortname, delay))+        time.sleep(delay)+        delay *= 2+    else:+      self._process = try_start()",This guarantees that we'll raise an exception that's not covered by an except,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/4061,44069707,2015-11-05T21:11:44Z,tools/jenkins/build_docker_and_run_tests.sh,"@@ -63,6 +63,7 @@ docker run \   -e ""arch=$arch"" \   -e CCACHE_DIR=/tmp/ccache \   -e XDG_CACHE_HOME=/tmp/xdg-cache-home \+  -e THIS_IS_REALLY_NEEDED='                           ' \",Suggest renaming to DOCKER_IS_BAD_AND_YOU_SHOULD_FEEL_BAD,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4062,44094339,2015-11-06T01:29:35Z,tools/run_tests/report_utils.py,"@@ -29,6 +29,8 @@  """"""Generate XML and HTML test reports."""""" +from mako.runtime import Context","Once you move the mako import inside the render_html_report function, run_tests.py will no longer fail.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4062,44094536,2015-11-06T01:33:02Z,templates/html_report.template,"@@ -0,0 +1,109 @@+<!DOCTYPE html>","Maybe we should make it clear that this is template for interop tests by renaming this file to ""interop_html_report.template"" or sth like that?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4062,44094727,2015-11-06T01:35:53Z,tools/run_tests/report_utils.py,"@@ -69,121 +71,27 @@ def render_xml_report(resultset, xml_report):   tree.write(xml_report, encoding='UTF-8')  -# TODO(adelez): Use mako template.-def fill_one_test_result(shortname, resultset, html_str):-  if shortname in resultset:-    # Because interop tests does not have runs_per_test flag, each test is run-    # once. So there should only be one element for each result.-    result = resultset[shortname][0] -    if result.state == 'PASSED':-      html_str = '%s<td bgcolor=\""green\"">PASS</td>\n' % html_str-    else:-      tooltip = ''-      if result.returncode > 0 or result.message:-        if result.returncode > 0:-          tooltip = 'returncode: %d ' % result.returncode-        if result.message:-          escaped_msg = _filter_msg(result.message, 'HTML')-          tooltip = '%smessage: %s' % (tooltip, escaped_msg)       -      if result.state == 'FAILED':-        html_str = '%s<td bgcolor=\""red\"">' % html_str-        if tooltip:  -          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">FAIL</a></td>\n' % -                      (html_str, tooltip))-        else:-          html_str = '%sFAIL</td>\n' % html_str-      elif result.state == 'TIMEOUT':-        html_str = '%s<td bgcolor=\""yellow\"">' % html_str-        if tooltip:-          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">TIMEOUT</a></td>\n' -                      % (html_str, tooltip))-        else:-          html_str = '%sTIMEOUT</td>\n' % html_str-  else:-    html_str = '%s<td bgcolor=\""magenta\"">Not implemented</td>\n' % html_str-  -  return html_str-- def render_html_report(client_langs, server_langs, test_cases, auth_test_cases,                        resultset, num_failures, cloud_to_prod):-  """"""Generate html report.""""""-  sorted_test_cases = sorted(test_cases)-  sorted_auth_test_cases = sorted(auth_test_cases)-  sorted_client_langs = sorted(client_langs)-  sorted_server_langs = sorted(server_langs)-  html_str = ('<!DOCTYPE html>\n'-              '<html lang=\""en\"">\n'-              '<head><title>Interop Test Result</title></head>\n'-              '<body>\n')-  if num_failures > 1:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d tests failed!</font></h2></p>\n' % -        (html_str, num_failures))-  elif num_failures:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d test failed!</font></h2></p>\n' % -        (html_str, num_failures))-  else:-    html_str = (-        '%s<p><h2><font color=\""green\"">All tests passed!</font></h2></p>\n' % -        html_str)-  if cloud_to_prod:-    # Each column header is the client language.-    html_str = ('%s<h2>Cloud to Prod</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Client languages &#9658;</th>\n') % html_str-    for client_lang in sorted_client_langs:-      html_str = '%s<th>%s\n' % (html_str, client_lang)-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_test_cases + sorted_auth_test_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      for client_lang in sorted_client_langs:-        if not test_case in sorted_auth_test_cases:-          shortname = 'cloud_to_prod:%s:%s' % (client_lang, test_case)-        else:-          shortname = 'cloud_to_prod_auth:%s:%s' % (client_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str -    html_str = '%s</table>\n' % html_str-  if server_langs:-    for test_case in sorted_test_cases:-      # Each column header is the client language.-      html_str = ('%s<h2>%s</h2>\n' -                  '<table style=\""width:100%%\"" border=\""1\"">\n'-                  '<tr bgcolor=\""#00BFFF\"">\n'-                  '<th>Client languages &#9658;<br/>'-                  'Server languages &#9660;</th>\n') % (html_str, test_case)-      for client_lang in sorted_client_langs:-        html_str = '%s<th>%s\n' % (html_str, client_lang)-      html_str = '%s</tr>\n' % html_str-      # Each row head is the server language.-      for server_lang in sorted_server_langs:-        html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, server_lang)-        # Fill up the cells with test result.-        for client_lang in sorted_client_langs:-          shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-              client_lang, server_lang, test_case)-          html_str = fill_one_test_result(shortname, resultset, html_str)-        html_str = '%s</tr>\n' % html_str-      html_str = '%s</table>\n' % html_str--  html_str = ('%s\n'-              '<script>\n'-              '$(document).ready(function(){'-              '$(\'[data-toggle=\""tooltip\""]\').tooltip();\n'   -              '});\n'-              '</script>\n'-              '</body>\n'-              '</html>') % html_str  -     # Write to reports/index.html as set up in Jenkins plugin.","Please add """""" """""" python-style function comment. Perhaps worth mentioning this is  for generating interop tests report.   Worth renaming to render_interop_html_report?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/4035,44192238,2015-11-06T21:57:13Z,test/cpp/interop/stress_interop_client.h,"@@ -84,20 +85,26 @@ class WeightedRandomTestSelector { class StressTestInteropClient {  public:   StressTestInteropClient(int test_id, const grpc::string& server_address,+                          std::shared_ptr<Channel> channel,                           const WeightedRandomTestSelector& test_selector,-                          long test_duration_secs, long sleep_duration_ms);+                          long test_duration_secs, long sleep_duration_ms,+                          long metrics_collection_interval_secs); -  void MainLoop();  // The main function. Use this as the thread entry point.+  // The main funciton. Use this as the thread entry point.+  // qps_gauge is the Gauge to record the requests per second metric+  void MainLoop(std::shared_ptr<Gauge> qps_gauge);","See http://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/ You should be fine using a non-const reference instead (or in this case, due to styleguide rules, a non-const pointer).",
8943572,carl-mastrangelo,https://api.github.com/repos/grpc/grpc/pulls/4062,44495782,2015-11-11T02:30:38Z,tools/run_tests/report_utils.py,"@@ -69,147 +69,35 @@ def render_xml_report(resultset, xml_report):   tree.write(xml_report, encoding='UTF-8')  -# TODO(adelez): Use mako template.-def fill_one_test_result(shortname, resultset, html_str):-  if shortname in resultset:-    # Because interop tests does not have runs_per_test flag, each test is run-    # once. So there should only be one element for each result.-    result = resultset[shortname][0] -    if result.state == 'PASSED':-      html_str = '%s<td bgcolor=\""green\"">PASS</td>\n' % html_str-    else:-      tooltip = ''-      if result.returncode > 0 or result.message:-        if result.returncode > 0:-          tooltip = 'returncode: %d ' % result.returncode-        if result.message:-          escaped_msg = _filter_msg(result.message, 'HTML')-          tooltip = '%smessage: %s' % (tooltip, escaped_msg)       -      if result.state == 'FAILED':-        html_str = '%s<td bgcolor=\""red\"">' % html_str-        if tooltip:  -          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">FAIL</a></td>\n' % -                      (html_str, tooltip))-        else:-          html_str = '%sFAIL</td>\n' % html_str-      elif result.state == 'TIMEOUT':-        html_str = '%s<td bgcolor=\""yellow\"">' % html_str-        if tooltip:-          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">TIMEOUT</a></td>\n' -                      % (html_str, tooltip))-        else:-          html_str = '%sTIMEOUT</td>\n' % html_str-  else:-    html_str = '%s<td bgcolor=\""magenta\"">Not implemented</td>\n' % html_str-  -  return html_str+def render_interop_html_report(+  client_langs, server_langs, test_cases, auth_test_cases, http2_cases, +  resultset, num_failures, cloud_to_prod, http2_interop):+  """"""Generate HTML report for interop tests.""""""+  from mako.runtime import Context+  from mako.template import Template","Seems easy enough to work around:try:  from mako.template import Template  ....except (ImportError):  pass # Mako not supportedThere are a couple advantages to this over the current:- you don't accidentally import the same thing multiple times by calling the function multiple times   - you avoid the possibility of another function depending implicitly on these packages based on call order  - it is explicit that mako is optional, rather than being obscured as it is now.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/4108,44581036,2015-11-11T20:21:50Z,src/objective-c/generated_libraries/RemoteTestClient/RemoteTest.podspec,"@@ -10,7 +10,7 @@ Pod::Spec.new do |s|   s.prepare_command = <<-CMD     BINDIR=../../../../bins/$CONFIG     PROTOC=$BINDIR/protobuf/protoc","Yeah, sorry for that :-/ This file evolved to be used exclusively by the automatic tests (running `./tools/run_tests/run_tests.py -l objc` from the root of the repo). Those will `make plugins` and set `$CONFIG` before doing `pod install`, making the podspec work.As it became inappropriate for a sample, I added a version of it that just uses the installed protoc + plugin [inside the examples directory](https://github.com/grpc/grpc/tree/master/src/objective-c/examples/RemoteTestClient). The Podfile of this sample should just point to that one (as the Podfile for the SwiftSample does). And ideally we should move `generated_libraries/RemoteTestClient/*` into `tests/RemoteTestClient/*` to eliminate confusion. (And also eliminate `generated_libraries/RouteGuideClient`, which isn't used anymore.)Do you want to do that? Otherwise I'm happy to send a PR to your branch with the changes.",
8943572,carl-mastrangelo,https://api.github.com/repos/grpc/grpc/pulls/4062,44587048,2015-11-11T21:14:07Z,tools/run_tests/report_utils.py,"@@ -69,147 +74,36 @@ def render_xml_report(resultset, xml_report):   tree.write(xml_report, encoding='UTF-8')  -# TODO(adelez): Use mako template.-def fill_one_test_result(shortname, resultset, html_str):-  if shortname in resultset:-    # Because interop tests does not have runs_per_test flag, each test is run-    # once. So there should only be one element for each result.-    result = resultset[shortname][0] -    if result.state == 'PASSED':-      html_str = '%s<td bgcolor=\""green\"">PASS</td>\n' % html_str-    else:-      tooltip = ''-      if result.returncode > 0 or result.message:-        if result.returncode > 0:-          tooltip = 'returncode: %d ' % result.returncode-        if result.message:-          escaped_msg = _filter_msg(result.message, 'HTML')-          tooltip = '%smessage: %s' % (tooltip, escaped_msg)       -      if result.state == 'FAILED':-        html_str = '%s<td bgcolor=\""red\"">' % html_str-        if tooltip:  -          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">FAIL</a></td>\n' % -                      (html_str, tooltip))-        else:-          html_str = '%sFAIL</td>\n' % html_str-      elif result.state == 'TIMEOUT':-        html_str = '%s<td bgcolor=\""yellow\"">' % html_str-        if tooltip:-          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">TIMEOUT</a></td>\n' -                      % (html_str, tooltip))-        else:-          html_str = '%sTIMEOUT</td>\n' % html_str-  else:-    html_str = '%s<td bgcolor=\""magenta\"">Not implemented</td>\n' % html_str-  -  return html_str-+def render_interop_html_report(+  client_langs, server_langs, test_cases, auth_test_cases, http2_cases, +  resultset, num_failures, cloud_to_prod, http2_interop):+  """"""Generate HTML report for interop tests.""""""+  # Write to reports/index.html as set up in Jenkins plugin.+  html_report_dir = 'reports'+  if not os.path.exists(html_report_dir):+    os.mkdir(html_report_dir)+  html_file_path = os.path.join(html_report_dir, 'index.html') -def render_html_report(client_langs, server_langs, test_cases, auth_test_cases,-                       http2_cases, resultset, num_failures, cloud_to_prod, -                       http2_interop):-  """"""Generate html report.""""""   sorted_test_cases = sorted(test_cases)   sorted_auth_test_cases = sorted(auth_test_cases)   sorted_http2_cases = sorted(http2_cases)   sorted_client_langs = sorted(client_langs)   sorted_server_langs = sorted(server_langs)-  html_str = ('<!DOCTYPE html>\n'-              '<html lang=\""en\"">\n'-              '<head><title>Interop Test Result</title></head>\n'-              '<body>\n')-  if num_failures > 1:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d tests failed!</font></h2></p>\n' % -        (html_str, num_failures))-  elif num_failures:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d test failed!</font></h2></p>\n' % -        (html_str, num_failures))-  else:-    html_str = (-        '%s<p><h2><font color=\""green\"">All tests passed!</font></h2></p>\n' % -        html_str)-  if cloud_to_prod:-    # Each column header is the client language.-    html_str = ('%s<h2>Cloud to Prod</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Client languages &#9658;</th>\n') % html_str-    for client_lang in sorted_client_langs:-      html_str = '%s<th>%s\n' % (html_str, client_lang)-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_test_cases + sorted_auth_test_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      for client_lang in sorted_client_langs:-        if not test_case in sorted_auth_test_cases:-          shortname = 'cloud_to_prod:%s:%s' % (client_lang, test_case)-        else:-          shortname = 'cloud_to_prod_auth:%s:%s' % (client_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str -    html_str = '%s</table>\n' % html_str-  if http2_interop:-    # Each column header is the server language.-    html_str = ('%s<h2>HTTP/2 Interop</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Servers &#9658;<br/>'-                'Test Cases &#9660;</th>\n') % html_str-    for server_lang in sorted_server_langs:-      html_str = '%s<th>%s\n' % (html_str, server_lang)-    if cloud_to_prod:-      html_str = '%s<th>%s\n' % (html_str, ""prod"")-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_http2_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      # Fill up the cells with test result.-      for server_lang in sorted_server_langs:-        shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-            ""http2"", server_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      if cloud_to_prod:-        shortname = 'cloud_to_prod:%s:%s' % (""http2"", test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str-    html_str = '%s</table>\n' % html_str-  if server_langs:-    for test_case in sorted_test_cases:-      # Each column header is the client language.-      html_str = ('%s<h2>%s</h2>\n' -                  '<table style=\""width:100%%\"" border=\""1\"">\n'-                  '<tr bgcolor=\""#00BFFF\"">\n'-                  '<th>Client languages &#9658;<br/>'-                  'Server languages &#9660;</th>\n') % (html_str, test_case)-      for client_lang in sorted_client_langs:-        html_str = '%s<th>%s\n' % (html_str, client_lang)-      html_str = '%s</tr>\n' % html_str-      # Each row head is the server language.-      for server_lang in sorted_server_langs:-        html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, server_lang)-        # Fill up the cells with test result.-        for client_lang in sorted_client_langs:-          shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-              client_lang, server_lang, test_case)-          html_str = fill_one_test_result(shortname, resultset, html_str)-        html_str = '%s</tr>\n' % html_str-      html_str = '%s</table>\n' % html_str -  html_str = ('%s\n'-              '<script>\n'-              '$(document).ready(function(){'-              '$(\'[data-toggle=\""tooltip\""]\').tooltip();\n'   -              '});\n'-              '</script>\n'-              '</body>\n'-              '</html>') % html_str  -  -  # Write to reports/index.html as set up in Jenkins plugin.-  html_report_dir = 'reports'-  if not os.path.exists(html_report_dir):-    os.mkdir(html_report_dir)-  html_file_path = os.path.join(html_report_dir, 'index.html')-  with open(html_file_path, 'w') as f:-    f.write(html_str)+  template_file = 'templates/interop_html_report.template'+  mytemplate = Template(filename=template_file, format_exceptions=True)","Are you sure this is going to do what you think it does?  If Template has not been imported, this is going to be an exception rather than None.Also, if possible could you try actually running the test on a Windows machine to make sure it still works?",
8943572,carl-mastrangelo,https://api.github.com/repos/grpc/grpc/pulls/4062,44602145,2015-11-11T23:23:14Z,tools/run_tests/report_utils.py,"@@ -69,147 +74,36 @@ def render_xml_report(resultset, xml_report):   tree.write(xml_report, encoding='UTF-8')  -# TODO(adelez): Use mako template.-def fill_one_test_result(shortname, resultset, html_str):-  if shortname in resultset:-    # Because interop tests does not have runs_per_test flag, each test is run-    # once. So there should only be one element for each result.-    result = resultset[shortname][0] -    if result.state == 'PASSED':-      html_str = '%s<td bgcolor=\""green\"">PASS</td>\n' % html_str-    else:-      tooltip = ''-      if result.returncode > 0 or result.message:-        if result.returncode > 0:-          tooltip = 'returncode: %d ' % result.returncode-        if result.message:-          escaped_msg = _filter_msg(result.message, 'HTML')-          tooltip = '%smessage: %s' % (tooltip, escaped_msg)       -      if result.state == 'FAILED':-        html_str = '%s<td bgcolor=\""red\"">' % html_str-        if tooltip:  -          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">FAIL</a></td>\n' % -                      (html_str, tooltip))-        else:-          html_str = '%sFAIL</td>\n' % html_str-      elif result.state == 'TIMEOUT':-        html_str = '%s<td bgcolor=\""yellow\"">' % html_str-        if tooltip:-          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">TIMEOUT</a></td>\n' -                      % (html_str, tooltip))-        else:-          html_str = '%sTIMEOUT</td>\n' % html_str-  else:-    html_str = '%s<td bgcolor=\""magenta\"">Not implemented</td>\n' % html_str-  -  return html_str-+def render_interop_html_report(+  client_langs, server_langs, test_cases, auth_test_cases, http2_cases, +  resultset, num_failures, cloud_to_prod, http2_interop):+  """"""Generate HTML report for interop tests.""""""+  # Write to reports/index.html as set up in Jenkins plugin.+  html_report_dir = 'reports'+  if not os.path.exists(html_report_dir):+    os.mkdir(html_report_dir)+  html_file_path = os.path.join(html_report_dir, 'index.html') -def render_html_report(client_langs, server_langs, test_cases, auth_test_cases,-                       http2_cases, resultset, num_failures, cloud_to_prod, -                       http2_interop):-  """"""Generate html report.""""""   sorted_test_cases = sorted(test_cases)   sorted_auth_test_cases = sorted(auth_test_cases)   sorted_http2_cases = sorted(http2_cases)   sorted_client_langs = sorted(client_langs)   sorted_server_langs = sorted(server_langs)-  html_str = ('<!DOCTYPE html>\n'-              '<html lang=\""en\"">\n'-              '<head><title>Interop Test Result</title></head>\n'-              '<body>\n')-  if num_failures > 1:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d tests failed!</font></h2></p>\n' % -        (html_str, num_failures))-  elif num_failures:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d test failed!</font></h2></p>\n' % -        (html_str, num_failures))-  else:-    html_str = (-        '%s<p><h2><font color=\""green\"">All tests passed!</font></h2></p>\n' % -        html_str)-  if cloud_to_prod:-    # Each column header is the client language.-    html_str = ('%s<h2>Cloud to Prod</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Client languages &#9658;</th>\n') % html_str-    for client_lang in sorted_client_langs:-      html_str = '%s<th>%s\n' % (html_str, client_lang)-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_test_cases + sorted_auth_test_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      for client_lang in sorted_client_langs:-        if not test_case in sorted_auth_test_cases:-          shortname = 'cloud_to_prod:%s:%s' % (client_lang, test_case)-        else:-          shortname = 'cloud_to_prod_auth:%s:%s' % (client_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str -    html_str = '%s</table>\n' % html_str-  if http2_interop:-    # Each column header is the server language.-    html_str = ('%s<h2>HTTP/2 Interop</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Servers &#9658;<br/>'-                'Test Cases &#9660;</th>\n') % html_str-    for server_lang in sorted_server_langs:-      html_str = '%s<th>%s\n' % (html_str, server_lang)-    if cloud_to_prod:-      html_str = '%s<th>%s\n' % (html_str, ""prod"")-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_http2_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      # Fill up the cells with test result.-      for server_lang in sorted_server_langs:-        shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-            ""http2"", server_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      if cloud_to_prod:-        shortname = 'cloud_to_prod:%s:%s' % (""http2"", test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str-    html_str = '%s</table>\n' % html_str-  if server_langs:-    for test_case in sorted_test_cases:-      # Each column header is the client language.-      html_str = ('%s<h2>%s</h2>\n' -                  '<table style=\""width:100%%\"" border=\""1\"">\n'-                  '<tr bgcolor=\""#00BFFF\"">\n'-                  '<th>Client languages &#9658;<br/>'-                  'Server languages &#9660;</th>\n') % (html_str, test_case)-      for client_lang in sorted_client_langs:-        html_str = '%s<th>%s\n' % (html_str, client_lang)-      html_str = '%s</tr>\n' % html_str-      # Each row head is the server language.-      for server_lang in sorted_server_langs:-        html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, server_lang)-        # Fill up the cells with test result.-        for client_lang in sorted_client_langs:-          shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-              client_lang, server_lang, test_case)-          html_str = fill_one_test_result(shortname, resultset, html_str)-        html_str = '%s</tr>\n' % html_str-      html_str = '%s</table>\n' % html_str -  html_str = ('%s\n'-              '<script>\n'-              '$(document).ready(function(){'-              '$(\'[data-toggle=\""tooltip\""]\').tooltip();\n'   -              '});\n'-              '</script>\n'-              '</body>\n'-              '</html>') % html_str  -  -  # Write to reports/index.html as set up in Jenkins plugin.-  html_report_dir = 'reports'-  if not os.path.exists(html_report_dir):-    os.mkdir(html_report_dir)-  html_file_path = os.path.join(html_report_dir, 'index.html')-  with open(html_file_path, 'w') as f:-    f.write(html_str)+  template_file = 'templates/interop_html_report.template'+  mytemplate = Template(filename=template_file, format_exceptions=True)","Won't this also fail on any machine that doesn't have mako installed?  I ran these tests manually on my dev machine so I would imagine other people have the use case.  I don't believe this code is correct either.  If Template does not exist, the if statement will never be reached since an exception is thrown.  I also don't think the Template constructor will return a False-y object, so it would never be hit in the good case either.",
14932100,adelez,https://api.github.com/repos/grpc/grpc/pulls/4062,44602603,2015-11-11T23:27:43Z,tools/run_tests/report_utils.py,"@@ -69,147 +74,36 @@ def render_xml_report(resultset, xml_report):   tree.write(xml_report, encoding='UTF-8')  -# TODO(adelez): Use mako template.-def fill_one_test_result(shortname, resultset, html_str):-  if shortname in resultset:-    # Because interop tests does not have runs_per_test flag, each test is run-    # once. So there should only be one element for each result.-    result = resultset[shortname][0] -    if result.state == 'PASSED':-      html_str = '%s<td bgcolor=\""green\"">PASS</td>\n' % html_str-    else:-      tooltip = ''-      if result.returncode > 0 or result.message:-        if result.returncode > 0:-          tooltip = 'returncode: %d ' % result.returncode-        if result.message:-          escaped_msg = _filter_msg(result.message, 'HTML')-          tooltip = '%smessage: %s' % (tooltip, escaped_msg)       -      if result.state == 'FAILED':-        html_str = '%s<td bgcolor=\""red\"">' % html_str-        if tooltip:  -          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">FAIL</a></td>\n' % -                      (html_str, tooltip))-        else:-          html_str = '%sFAIL</td>\n' % html_str-      elif result.state == 'TIMEOUT':-        html_str = '%s<td bgcolor=\""yellow\"">' % html_str-        if tooltip:-          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">TIMEOUT</a></td>\n' -                      % (html_str, tooltip))-        else:-          html_str = '%sTIMEOUT</td>\n' % html_str-  else:-    html_str = '%s<td bgcolor=\""magenta\"">Not implemented</td>\n' % html_str-  -  return html_str-+def render_interop_html_report(+  client_langs, server_langs, test_cases, auth_test_cases, http2_cases, +  resultset, num_failures, cloud_to_prod, http2_interop):+  """"""Generate HTML report for interop tests.""""""+  # Write to reports/index.html as set up in Jenkins plugin.+  html_report_dir = 'reports'+  if not os.path.exists(html_report_dir):+    os.mkdir(html_report_dir)+  html_file_path = os.path.join(html_report_dir, 'index.html') -def render_html_report(client_langs, server_langs, test_cases, auth_test_cases,-                       http2_cases, resultset, num_failures, cloud_to_prod, -                       http2_interop):-  """"""Generate html report.""""""   sorted_test_cases = sorted(test_cases)   sorted_auth_test_cases = sorted(auth_test_cases)   sorted_http2_cases = sorted(http2_cases)   sorted_client_langs = sorted(client_langs)   sorted_server_langs = sorted(server_langs)-  html_str = ('<!DOCTYPE html>\n'-              '<html lang=\""en\"">\n'-              '<head><title>Interop Test Result</title></head>\n'-              '<body>\n')-  if num_failures > 1:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d tests failed!</font></h2></p>\n' % -        (html_str, num_failures))-  elif num_failures:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d test failed!</font></h2></p>\n' % -        (html_str, num_failures))-  else:-    html_str = (-        '%s<p><h2><font color=\""green\"">All tests passed!</font></h2></p>\n' % -        html_str)-  if cloud_to_prod:-    # Each column header is the client language.-    html_str = ('%s<h2>Cloud to Prod</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Client languages &#9658;</th>\n') % html_str-    for client_lang in sorted_client_langs:-      html_str = '%s<th>%s\n' % (html_str, client_lang)-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_test_cases + sorted_auth_test_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      for client_lang in sorted_client_langs:-        if not test_case in sorted_auth_test_cases:-          shortname = 'cloud_to_prod:%s:%s' % (client_lang, test_case)-        else:-          shortname = 'cloud_to_prod_auth:%s:%s' % (client_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str -    html_str = '%s</table>\n' % html_str-  if http2_interop:-    # Each column header is the server language.-    html_str = ('%s<h2>HTTP/2 Interop</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Servers &#9658;<br/>'-                'Test Cases &#9660;</th>\n') % html_str-    for server_lang in sorted_server_langs:-      html_str = '%s<th>%s\n' % (html_str, server_lang)-    if cloud_to_prod:-      html_str = '%s<th>%s\n' % (html_str, ""prod"")-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_http2_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      # Fill up the cells with test result.-      for server_lang in sorted_server_langs:-        shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-            ""http2"", server_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      if cloud_to_prod:-        shortname = 'cloud_to_prod:%s:%s' % (""http2"", test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str-    html_str = '%s</table>\n' % html_str-  if server_langs:-    for test_case in sorted_test_cases:-      # Each column header is the client language.-      html_str = ('%s<h2>%s</h2>\n' -                  '<table style=\""width:100%%\"" border=\""1\"">\n'-                  '<tr bgcolor=\""#00BFFF\"">\n'-                  '<th>Client languages &#9658;<br/>'-                  'Server languages &#9660;</th>\n') % (html_str, test_case)-      for client_lang in sorted_client_langs:-        html_str = '%s<th>%s\n' % (html_str, client_lang)-      html_str = '%s</tr>\n' % html_str-      # Each row head is the server language.-      for server_lang in sorted_server_langs:-        html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, server_lang)-        # Fill up the cells with test result.-        for client_lang in sorted_client_langs:-          shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-              client_lang, server_lang, test_case)-          html_str = fill_one_test_result(shortname, resultset, html_str)-        html_str = '%s</tr>\n' % html_str-      html_str = '%s</table>\n' % html_str -  html_str = ('%s\n'-              '<script>\n'-              '$(document).ready(function(){'-              '$(\'[data-toggle=\""tooltip\""]\').tooltip();\n'   -              '});\n'-              '</script>\n'-              '</body>\n'-              '</html>') % html_str  -  -  # Write to reports/index.html as set up in Jenkins plugin.-  html_report_dir = 'reports'-  if not os.path.exists(html_report_dir):-    os.mkdir(html_report_dir)-  html_file_path = os.path.join(html_report_dir, 'index.html')-  with open(html_file_path, 'w') as f:-    f.write(html_str)+  template_file = 'templates/interop_html_report.template'+  mytemplate = Template(filename=template_file, format_exceptions=True)",You are right. The code now catches exceptions if the template is not found or rendering fails.,
8943572,carl-mastrangelo,https://api.github.com/repos/grpc/grpc/pulls/4062,44604029,2015-11-11T23:42:52Z,tools/run_tests/report_utils.py,"@@ -69,147 +74,35 @@ def render_xml_report(resultset, xml_report):   tree.write(xml_report, encoding='UTF-8')  -# TODO(adelez): Use mako template.-def fill_one_test_result(shortname, resultset, html_str):-  if shortname in resultset:-    # Because interop tests does not have runs_per_test flag, each test is run-    # once. So there should only be one element for each result.-    result = resultset[shortname][0] -    if result.state == 'PASSED':-      html_str = '%s<td bgcolor=\""green\"">PASS</td>\n' % html_str-    else:-      tooltip = ''-      if result.returncode > 0 or result.message:-        if result.returncode > 0:-          tooltip = 'returncode: %d ' % result.returncode-        if result.message:-          escaped_msg = _filter_msg(result.message, 'HTML')-          tooltip = '%smessage: %s' % (tooltip, escaped_msg)       -      if result.state == 'FAILED':-        html_str = '%s<td bgcolor=\""red\"">' % html_str-        if tooltip:  -          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">FAIL</a></td>\n' % -                      (html_str, tooltip))-        else:-          html_str = '%sFAIL</td>\n' % html_str-      elif result.state == 'TIMEOUT':-        html_str = '%s<td bgcolor=\""yellow\"">' % html_str-        if tooltip:-          html_str = ('%s<a href=\""#\"" data-toggle=\""tooltip\"" '-                      'data-placement=\""auto\"" title=\""%s\"">TIMEOUT</a></td>\n' -                      % (html_str, tooltip))-        else:-          html_str = '%sTIMEOUT</td>\n' % html_str-  else:-    html_str = '%s<td bgcolor=\""magenta\"">Not implemented</td>\n' % html_str-  -  return html_str-+def render_interop_html_report(+  client_langs, server_langs, test_cases, auth_test_cases, http2_cases, +  resultset, num_failures, cloud_to_prod, http2_interop):+  """"""Generate HTML report for interop tests.""""""+  # Write to reports/index.html as set up in Jenkins plugin.+  html_report_dir = 'reports'+  if not os.path.exists(html_report_dir):+    os.mkdir(html_report_dir)+  html_file_path = os.path.join(html_report_dir, 'index.html') -def render_html_report(client_langs, server_langs, test_cases, auth_test_cases,-                       http2_cases, resultset, num_failures, cloud_to_prod, -                       http2_interop):-  """"""Generate html report.""""""   sorted_test_cases = sorted(test_cases)   sorted_auth_test_cases = sorted(auth_test_cases)   sorted_http2_cases = sorted(http2_cases)   sorted_client_langs = sorted(client_langs)   sorted_server_langs = sorted(server_langs)-  html_str = ('<!DOCTYPE html>\n'-              '<html lang=\""en\"">\n'-              '<head><title>Interop Test Result</title></head>\n'-              '<body>\n')-  if num_failures > 1:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d tests failed!</font></h2></p>\n' % -        (html_str, num_failures))-  elif num_failures:-    html_str = (-        '%s<p><h2><font color=\""red\"">%d test failed!</font></h2></p>\n' % -        (html_str, num_failures))-  else:-    html_str = (-        '%s<p><h2><font color=\""green\"">All tests passed!</font></h2></p>\n' % -        html_str)-  if cloud_to_prod:-    # Each column header is the client language.-    html_str = ('%s<h2>Cloud to Prod</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Client languages &#9658;</th>\n') % html_str-    for client_lang in sorted_client_langs:-      html_str = '%s<th>%s\n' % (html_str, client_lang)-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_test_cases + sorted_auth_test_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      for client_lang in sorted_client_langs:-        if not test_case in sorted_auth_test_cases:-          shortname = 'cloud_to_prod:%s:%s' % (client_lang, test_case)-        else:-          shortname = 'cloud_to_prod_auth:%s:%s' % (client_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str -    html_str = '%s</table>\n' % html_str-  if http2_interop:-    # Each column header is the server language.-    html_str = ('%s<h2>HTTP/2 Interop</h2>\n' -                '<table style=\""width:100%%\"" border=\""1\"">\n'-                '<tr bgcolor=\""#00BFFF\"">\n'-                '<th>Servers &#9658;<br/>'-                'Test Cases &#9660;</th>\n') % html_str-    for server_lang in sorted_server_langs:-      html_str = '%s<th>%s\n' % (html_str, server_lang)-    if cloud_to_prod:-      html_str = '%s<th>%s\n' % (html_str, ""prod"")-    html_str = '%s</tr>\n' % html_str-    for test_case in sorted_http2_cases:-      html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, test_case)-      # Fill up the cells with test result.-      for server_lang in sorted_server_langs:-        shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-            ""http2"", server_lang, test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      if cloud_to_prod:-        shortname = 'cloud_to_prod:%s:%s' % (""http2"", test_case)-        html_str = fill_one_test_result(shortname, resultset, html_str)-      html_str = '%s</tr>\n' % html_str-    html_str = '%s</table>\n' % html_str-  if server_langs:-    for test_case in sorted_test_cases:-      # Each column header is the client language.-      html_str = ('%s<h2>%s</h2>\n' -                  '<table style=\""width:100%%\"" border=\""1\"">\n'-                  '<tr bgcolor=\""#00BFFF\"">\n'-                  '<th>Client languages &#9658;<br/>'-                  'Server languages &#9660;</th>\n') % (html_str, test_case)-      for client_lang in sorted_client_langs:-        html_str = '%s<th>%s\n' % (html_str, client_lang)-      html_str = '%s</tr>\n' % html_str-      # Each row head is the server language.-      for server_lang in sorted_server_langs:-        html_str = '%s<tr><td><b>%s</b></td>\n' % (html_str, server_lang)-        # Fill up the cells with test result.-        for client_lang in sorted_client_langs:-          shortname = 'cloud_to_cloud:%s:%s_server:%s' % (-              client_lang, server_lang, test_case)-          html_str = fill_one_test_result(shortname, resultset, html_str)-        html_str = '%s</tr>\n' % html_str-      html_str = '%s</table>\n' % html_str -  html_str = ('%s\n'-              '<script>\n'-              '$(document).ready(function(){'-              '$(\'[data-toggle=\""tooltip\""]\').tooltip();\n'   -              '});\n'-              '</script>\n'-              '</body>\n'-              '</html>') % html_str  -  -  # Write to reports/index.html as set up in Jenkins plugin.-  html_report_dir = 'reports'-  if not os.path.exists(html_report_dir):-    os.mkdir(html_report_dir)-  html_file_path = os.path.join(html_report_dir, 'index.html')-  with open(html_file_path, 'w') as f:-    f.write(html_str)+  template_file = 'templates/interop_html_report.template'+  try:+    mytemplate = Template(filename=template_file, format_exceptions=True)","Sorry to give so much heartache over this, but I was thinking of something like:try:  dummy = Templateexcept NameError:  raise ""Mako not installed!""As it stands, the code below just swallows any exceptions (and costs an indent level)",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/4035,44982250,2015-11-16T21:00:16Z,test/proto/metrics.proto,"@@ -0,0 +1,51 @@++// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// An integration test service that covers all the method signature permutations+// of unary/streaming requests/responses.+syntax = ""proto3"";++package grpc.testing;++message GaugeResponse {+  string name = 1;+  int64 value = 2;",Done. Changed the GaugeResponse as oneof. However I didn't change the implementation of Gauge class in metrics_server.h to have multiple types (I want a really simple metrics server for my use case for now. I can add more functionality in future as needed),
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/4035,44989038,2015-11-16T21:51:43Z,test/cpp/util/metrics_server.h,"@@ -0,0 +1,101 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *is % allowed in string+ */+#ifndef GRPC_TEST_CPP_METRICS_SERVER_H+#define GRPC_TEST_CPP_METRICS_SERVER_H++#include <atomic>+#include <map>+#include <mutex>+#include <vector>++#include ""test/proto/metrics.grpc.pb.h""+#include ""test/proto/metrics.pb.h""++/*+ * This implements a Metrics server defined in test/proto/metrics.proto. Any+ * test service can use this to export Metrics (TODO (sreek): Only Gauges for+ * now).+ *+ * Example:+ *    MetricsServiceImpl metricsImpl;+ *    ..+ *    // Create Gauge(s). Note: Gauges can be created even after calling+ *    // 'StartServer'.+ *    Gauge gauge1 = metricsImpl.CreateGauge(""foo"",is_present);+ *    // gauge1 can now be used anywhere in the program to set values.+ *    ...+ *    // Create the metrics server+ *    std::unique_ptr<grpc::Server> server = metricsImpl.StartServer(port);+ *    server->Wait(); // Note: This is blocking.+ */+namespace grpc {+namespace testing {++using std::map;+using std::vector;++class Gauge {+ public:+  Gauge(long initial_val);+  void Set(long new_val);+  long Get();++ private:+  std::atomic_long val_;+};++class MetricsServiceImpl GRPC_FINAL : public MetricsService::Service {+ public:+  grpc::Status GetAllGauges(ServerContext* context, const EmptyMessage* request,+                            ServerWriter<GaugeResponse>* writer) GRPC_OVERRIDE;++  grpc::Status GetGauge(ServerContext* context, const GaugeRequest* request,+                        GaugeResponse* response) GRPC_OVERRIDE;++  // Create a Gauge with name 'name'. is_present is set to true if the Gauge+  // is already present in the map.+  // NOTE: CreateGauge can be called anytime (i.e before or after calling+  // StartServer).+  std::shared_ptr<Gauge> CreateGauge(string name, bool& is_present);","changed ""bool& "" to ""bool*"" and also renamed the parameter from is_present to already_present ",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/4057,45015797,2015-11-17T02:32:55Z,tools/gke/kubernetes_api.py,"@@ -0,0 +1,216 @@+#!/usr/bin/env python2.7","I did not know about this until you mentioned!. I looked at it and noticed that it does not expose all functionality I need (for example, a service cannot accept multiple container port list: https://github.com/pjs7678/python-kubernetes/blob/master/kubernetes/service.py). Also, the package isn't actively being maintained (the last update was 9 months ago). Better to write our own stuff for now - it is simple enough.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/4149,45172787,2015-11-18T08:45:47Z,src/python/grpcio_test/grpc_test/beta/_beta_features_test.py,"@@ -228,5 +228,57 @@ def test_stream_stream(self):     self.assertEqual(_RESPONSE, response)  +class ContextManagementAndLifecycleTest(unittest.TestCase):++  def setUp(self):+    self._servicer = _Servicer()+    method_implementations = {+        (_GROUP, _UNARY_UNARY):+            utilities.unary_unary_inline(self._servicer.unary_unary),+        (_GROUP, _UNARY_STREAM):+            utilities.unary_stream_inline(self._servicer.unary_stream),+        (_GROUP, _STREAM_UNARY):+            utilities.stream_unary_inline(self._servicer.stream_unary),+        (_GROUP, _STREAM_STREAM):+            utilities.stream_stream_inline(self._servicer.stream_stream),+    }++    self._cardinalities = {+        _UNARY_UNARY: cardinality.Cardinality.UNARY_UNARY,+        _UNARY_STREAM: cardinality.Cardinality.UNARY_STREAM,+        _STREAM_UNARY: cardinality.Cardinality.STREAM_UNARY,+        _STREAM_STREAM: cardinality.Cardinality.STREAM_STREAM,+    }++    server_options = implementations.server_options(+        thread_pool_size=test_constants.POOL_SIZE)+    self._server = implementations.server(+        method_implementations, options=server_options)+    server_credentials = implementations.ssl_server_credentials(+        [(resources.private_key(), resources.certificate_chain(),),])+    port = self._server.add_secure_port('[::]:0', server_credentials)+    self._server.start()+    self._client_credentials = implementations.ssl_client_credentials(+        resources.test_root_certificates(), None, None)+    self._channel = test_utilities.not_really_secure_channel(+        'localhost', port, self._client_credentials, _SERVER_HOST_OVERRIDE)+    self._stub_options = implementations.stub_options(+        thread_pool_size=test_constants.POOL_SIZE)++  def tearDown(self):+    self._server.stop(test_constants.SHORT_TIMEOUT).wait()++  def test_unary_unary(self):+    dynamic_stub = implementations.dynamic_stub(+        self._channel, _GROUP, self._cardinalities, options=self._stub_options)+    with dynamic_stub:+      call_options = interfaces.grpc_call_options(+          disable_compression=True, credentials=self._client_credentials)","Due to bandaid changes made in #3765, the `credentials` argument for `grpc_call_options` no longer has a suitable argument type (and thus anything assigned to it that is non-`None` will result in a runtime error upon use).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4097,45280432,2015-11-18T23:56:29Z,src/core/transport/chttp2/hpack_encoder.c,"@@ -461,6 +489,41 @@ void grpc_chttp2_hpack_compressor_destroy(grpc_chttp2_hpack_compressor *c) {     if (c->entries_elems[i]) GRPC_MDELEM_UNREF(c->entries_elems[i]);   }   GRPC_MDSTR_UNREF(c->timeout_key_str);+  gpr_free(c->table_elem_size);+}++void grpc_chttp2_hpack_compressor_set_max_usable_size(+    grpc_chttp2_hpack_compressor *c, gpr_uint32 max_table_size) {+  c->max_usable_size = max_table_size;+  grpc_chttp2_hpack_compressor_set_max_table_size(+      c, GPR_MIN(c->max_table_size, max_table_size));+}++static void rebuild_elems(grpc_chttp2_hpack_compressor *c, gpr_uint32 new_cap) {+","It's subtle: not having that function present will lead to memorycorruption eventually, but it's a very long eventually.On Wed, Nov 18, 2015 at 3:52 PM David G. Quintas notifications@github.comwrote:> In src/core/transport/chttp2/hpack_encoder.c> https://github.com/grpc/grpc/pull/4097#discussion_r45279935:> > > @@ -461,6 +489,41 @@ void grpc_chttp2_hpack_compressor_destroy(grpc_chttp2_hpack_compressor *c) {> >      if (c->entries_elems[i]) GRPC_MDELEM_UNREF(c->entries_elems[i]);> >    }> >    GRPC_MDSTR_UNREF(c->timeout_key_str);> > -  gpr_free(c->table_elem_size);> >   +}> >   +> >   +void grpc_chttp2_hpack_compressor_set_max_usable_size(> > -    grpc_chttp2_hpack_compressor *c, gpr_uint32 max_table_size) {> > -  c->max_usable_size = max_table_size;> > -  grpc_chttp2_hpack_compressor_set_max_table_size(> > -      c, GPR_MIN(c->max_table_size, max_table_size));> >   +}> >   +> >   +static void rebuild_elems(grpc_chttp2_hpack_compressor *c, gpr_uint32 new_cap) {> >   +> > so much for my review... well, I caught it, albeit for the wrong reasons.> Maybe tests should be more exhaustive too :)> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/4097/files#r45279935.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/4035,45323121,2015-11-19T10:24:15Z,test/cpp/util/metrics_server.cc,"@@ -0,0 +1,118 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *is % allowed in string+ */++#include ""test/cpp/util/metrics_server.h""++#include <vector>++#include <grpc++/server_builder.h>++#include ""test/proto/metrics.grpc.pb.h""+#include ""test/proto/metrics.pb.h""++namespace grpc {+namespace testing {++using std::vector;++Gauge::Gauge(long initial_val) : val_(initial_val) {}++void Gauge::Set(long new_val) {+  val_.store(new_val, std::memory_order_relaxed);","Ok, I guess I didn't realize that they were being read elsewhere. Is it so time-critical as to use atomics rather than mutexes? I just ask because I'm concerned about long-term maintainability if your gauge later needs multiple fields.  I believe that we do not currently use atomics elsewhere in the grpc code and a lot of people are quite allergic to them.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/4035,45324150,2015-11-19T10:34:21Z,test/cpp/util/metrics_server.cc,"@@ -0,0 +1,118 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *is % allowed in string+ */++#include ""test/cpp/util/metrics_server.h""++#include <vector>++#include <grpc++/server_builder.h>++#include ""test/proto/metrics.grpc.pb.h""+#include ""test/proto/metrics.pb.h""++namespace grpc {+namespace testing {++using std::vector;++Gauge::Gauge(long initial_val) : val_(initial_val) {}++void Gauge::Set(long new_val) {+  val_.store(new_val, std::memory_order_relaxed);+}++long Gauge::Get() { return val_.load(std::memory_order_relaxed); }++grpc::Status MetricsServiceImpl::GetAllGauges(+    ServerContext* context, const EmptyMessage* request,+    ServerWriter<GaugeResponse>* writer) {+  gpr_log(GPR_INFO, ""GetAllGauges called"");++  std::lock_guard<std::mutex> lock(mu_);+  for (auto it = gauges_.begin(); it != gauges_.end(); it++) {+    GaugeResponse resp;+    resp.set_name(it->first);           // Gauge name+    resp.set_value(it->second->Get());  // Gauge value+    writer->Write(resp);+  }++  return Status::OK;+}++grpc::Status MetricsServiceImpl::GetGauge(ServerContext* context,+                                          const GaugeRequest* request,+                                          GaugeResponse* response) {+  std::lock_guard<std::mutex> lock(mu_);++  auto it = gauges_.find(request->name());","I think @dgquintas  was arguing for the use of const in general if the value doesn't get changed after creation. ""const auto it"" . This is not used consistently throughout the codebase but is, I believe, a good suggestion that David always makes whenever this sort of pattern arises.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4157,45412731,2015-11-19T22:45:47Z,src/core/iomgr/tcp_server_posix.c,"@@ -84,9 +84,14 @@ typedef struct {     struct sockaddr_un un;   } addr;   size_t addr_len;+  int port;   grpc_closure read_closure;   grpc_closure destroyed_closure;-} server_port;+  gpr_refcount refs;+  struct grpc_tcp_listener *next;+  struct grpc_tcp_listener *dual_stack_second_port;",sibling?Add a big whoop ass comment about why,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/4154,45526248,2015-11-20T22:19:00Z,include/grpc/grpc_security.h,"@@ -165,6 +240,23 @@ typedef void (*grpc_credentials_plugin_metadata_cb)(     void *user_data, const grpc_metadata *creds_md, size_t num_creds_md,     grpc_status_code status, const char *error_details); +/* Context that can be used by metadata credentials plugin in order to create+   auth related metadata. */+typedef struct {",Why do we need all of this information in the metadata plugin? Why do we need the auth context?,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/4203,45678265,2015-11-23T23:40:14Z,src/core/support/avl.c,"@@ -0,0 +1,305 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/avl.h>++#include <assert.h>+#include <stdlib.h>++#include <grpc/support/alloc.h>+#include <grpc/support/string_util.h>+#include <grpc/support/useful.h>++gpr_avl gpr_avl_create(const gpr_avl_vtable *vtable) {+  gpr_avl out;+  out.vtable = vtable;+  out.root = NULL;+  return out;+}++static gpr_avl_node *ref_node(gpr_avl_node *node) {+  if (node) {+    gpr_ref(&node->refs);+  }+  return node;+}++static void unref_node(const gpr_avl_vtable *vtable, gpr_avl_node *node) {+  if (node == NULL) {+    return;+  }+  if (gpr_unref(&node->refs)) {+    vtable->destroy_key(node->key);+    vtable->destroy_value(node->value);+    unref_node(vtable, node->left);+    unref_node(vtable, node->right);+    gpr_free(node);+  }+}++static long node_height(gpr_avl_node *node) {",My brain doesn't want to remember this fact for some reason.,
8943572,carl-mastrangelo,https://api.github.com/repos/grpc/grpc/pulls/4196,45774455,2015-11-24T18:29:52Z,tools/http2_interop/http2interop.go,"@@ -195,21 +191,22 @@ func testUnknownFrameType(ctx *HTTP2InteropCtx) error { }  func testShortPreface(ctx *HTTP2InteropCtx, prefacePrefix string) error {-	c, err := connect(ctx)+	conn, err := connect(ctx) 	if err != nil { 		return err 	}-	defer c.Close()+	defer conn.Close()+	conn.SetDeadline(time.Now().Add(defaultTimeout)) -	if _, err := c.Write([]byte(prefacePrefix)); err != nil {+	if _, err := conn.Write([]byte(prefacePrefix)); err != nil { 		return err 	} -	buf := make([]byte, 256)-	for ; err == nil; _, err = c.Read(buf) {+	if _, err := expectGoAwaySoon(conn); err != nil {","expectGoAway is for when the very first frame should be a Go away.  This is for things like bad TLS configuration.   Sometimes it isn't feasible for the TLS terminator to teardown the connection, so the spec allows sending a goaway frame with inadequate security before any other frames.However, most servers, upon getting a good TLS connection, will immediately send their preface before actually receiving any bytes from the client, in order to speed up the handshake.  In this test, I am intentionally sending a bad preface to the server, which means the server preface may already be on the wire.  This code expects a few valid frames (like settings, continuations, and window updates) before getting a goaway frame from the server.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4208,45927974,2015-11-25T22:46:36Z,src/cpp/client/secure_credentials.cc,"@@ -171,18 +172,25 @@ void MetadataCredentialsPluginWrapper::GetMetadata(   }   if (w->plugin_->IsBlocking()) {     w->thread_pool_->Add(-        std::bind(&MetadataCredentialsPluginWrapper::InvokePlugin, w,-                  context.service_url, cb, user_data));+        std::bind(&MetadataCredentialsPluginWrapper::InvokePlugin, w, context,+                  cb, user_data));   } else {-    w->InvokePlugin(context.service_url, cb, user_data);+    w->InvokePlugin(context, cb, user_data);   } }  void MetadataCredentialsPluginWrapper::InvokePlugin(-    const char* service_url, grpc_credentials_plugin_metadata_cb cb,+    grpc_auth_metadata_context context, grpc_credentials_plugin_metadata_cb cb,     void* user_data) {   std::multimap<grpc::string, grpc::string> metadata;-  Status status = plugin_->GetMetadata(service_url, &metadata);++  // const_cast is safe since the SecureAuthContext does not take owndership and","@yang-g This is a little ugly... As an alternative, I could have a new implementation of `AuthContext` called `ImmutableSecureAuthContext` which would take a `const grpc_auth_context*` as a parameter in the constructor and either `GPR_ASSERT(false)` or do nothing on the mutable methods.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4222,46299711,2015-12-01T16:22:37Z,src/core/iomgr/fd_posix.h,"@@ -111,7 +112,7 @@ grpc_fd *grpc_fd_create(int fd, const char *name);    notify_on_write.    MUST NOT be called with a pollset lock taken */ void grpc_fd_orphan(grpc_exec_ctx *exec_ctx, grpc_fd *fd, grpc_closure *on_done,","How about:``` cvoid grpc_fd_orphan(..., int *release_fd, ...);```With the semantics:if release_fd == NULL, closes the underlying file descriptorif release_fd != NULL, does not close the file descriptor, but set *release_fd = underlying_fd before calling on_done",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4204,46464788,2015-12-02T19:45:34Z,src/cpp/server/server.cc,"@@ -51,6 +51,15 @@  namespace grpc { +class DefaultGlobalCallbacks GRPC_FINAL : public Server::GlobalCallbacks {+ public:+  void PreSynchronousRequest(ServerContext* context) GRPC_OVERRIDE {}+  void PostSynchronousRequest(ServerContext* context) GRPC_OVERRIDE {}+};++static DefaultGlobalCallbacks g_default_callbacks;","I want to avoid littering nullptr checks here: I expect the set of callbacks defined here to grow over time, and starting off badly will result in too many nullptr checks everywhere.I have instead done a gpr_once_init in the server constructor for a default callback object.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/4269,46509315,2015-12-03T03:30:36Z,src/python/grpcio/grpc/beta/_server.py,"@@ -61,86 +67,143 @@ def service(self, group, method, context, output_operator):         raise  -def _disassemble(grpc_link, end_link, pool, event, grace):-  grpc_link.begin_stop()-  end_link.stop(grace).wait()-  grpc_link.end_stop()-  grpc_link.join_link(utilities.NULL_LINK)-  end_link.join_link(utilities.NULL_LINK)-  if pool is not None:-    pool.shutdown(wait=True)-  event.set()+class _Server(interfaces.Server): +  def __init__(+      self, implementations, multi_implementation, pool, pool_size,+      default_timeout, maximum_timeout, grpc_link):+    self._lock = threading.Lock()+    self._implementations = implementations+    self._multi_implementation = multi_implementation+    self._customer_pool = pool+    self._pool_size = pool_size+    self._default_timeout = default_timeout+    self._maximum_timeout = maximum_timeout+    self._grpc_link = grpc_link -class Server(interfaces.Server):+    self._end_link = None+    self._stop_events = None+    self._pool = None -  def __init__(self, grpc_link, end_link, pool):-    self._grpc_link = grpc_link-    self._end_link = end_link-    self._pool = pool+  def _start(self):+    with self._lock:+      if self._end_link is not None:+        raise ValueError('Cannot start already-started server!')++      if self._customer_pool is None:+        self._pool = logging_pool.pool(self._pool_size)+        assembly_pool = self._pool+      else:+        assembly_pool = self._customer_pool++      servicer = _GRPCServicer(+          _crust_implementations.servicer(+              self._implementations, self._multi_implementation, assembly_pool))++      self._end_link = _core_implementations.service_end_link(+          servicer, self._default_timeout, self._maximum_timeout)++      self._grpc_link.join_link(self._end_link)+      self._end_link.join_link(self._grpc_link)+      self._grpc_link.start()+      self._end_link.start()++  def _dissociate_links_and_shut_down_pool(self):+    self._grpc_link.end_stop()+    self._grpc_link.join_link(utilities.NULL_LINK)+    self._end_link.join_link(utilities.NULL_LINK)+    self._end_link = None+    if self._pool is not None:+      self._pool.shutdown(wait=True)+    self._pool = None++  def _stop_stopping(self):+    self._dissociate_links_and_shut_down_pool()+    for stop_event in self._stop_events:+      stop_event.set()+    self._stop_events = None++  def _stop_started(self):+    self._grpc_link.begin_stop()+    self._end_link.stop(0).wait()+    self._dissociate_links_and_shut_down_pool()++  def _foreign_thread_stop(self, end_stop_event, stop_events):+    end_stop_event.wait()+    with self._lock:+      if self._stop_events is stop_events:+        self._stop_stopping()++  def _schedule_stop(self, grace):+    with self._lock:+      if self._end_link is None:+        return _set_event()+      server_stop_event = threading.Event()+      if self._stop_events is None:+        self._stop_events = [server_stop_event]+        self._grpc_link.begin_stop()+      else:+        self._stop_events.append(server_stop_event)+      end_stop_event = self._end_link.stop(grace)+      end_stop_thread = threading.Thread(+          target=self._foreign_thread_stop,+          args=(end_stop_event, self._stop_events))+      end_stop_thread.start()+      return server_stop_event++  def _stop_now(self):+    with self._lock:+      if self._end_link is not None:+        if self._stop_events is None:",Except for the identity thing (not directly anyway). What's the situation being guarded against? Multiple stops and really bad thread scheduling?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4269,46509335,2015-12-03T03:30:57Z,src/python/grpcio/grpc/beta/_server.py,"@@ -61,86 +67,143 @@ def service(self, group, method, context, output_operator):         raise  -def _disassemble(grpc_link, end_link, pool, event, grace):-  grpc_link.begin_stop()-  end_link.stop(grace).wait()-  grpc_link.end_stop()-  grpc_link.join_link(utilities.NULL_LINK)-  end_link.join_link(utilities.NULL_LINK)-  if pool is not None:-    pool.shutdown(wait=True)-  event.set()+class _Server(interfaces.Server): +  def __init__(+      self, implementations, multi_implementation, pool, pool_size,+      default_timeout, maximum_timeout, grpc_link):+    self._lock = threading.Lock()+    self._implementations = implementations+    self._multi_implementation = multi_implementation+    self._customer_pool = pool+    self._pool_size = pool_size+    self._default_timeout = default_timeout+    self._maximum_timeout = maximum_timeout+    self._grpc_link = grpc_link -class Server(interfaces.Server):+    self._end_link = None+    self._stop_events = None+    self._pool = None -  def __init__(self, grpc_link, end_link, pool):-    self._grpc_link = grpc_link-    self._end_link = end_link-    self._pool = pool+  def _start(self):+    with self._lock:+      if self._end_link is not None:+        raise ValueError('Cannot start already-started server!')++      if self._customer_pool is None:+        self._pool = logging_pool.pool(self._pool_size)+        assembly_pool = self._pool+      else:+        assembly_pool = self._customer_pool++      servicer = _GRPCServicer(+          _crust_implementations.servicer(+              self._implementations, self._multi_implementation, assembly_pool))++      self._end_link = _core_implementations.service_end_link(+          servicer, self._default_timeout, self._maximum_timeout)++      self._grpc_link.join_link(self._end_link)+      self._end_link.join_link(self._grpc_link)+      self._grpc_link.start()+      self._end_link.start()++  def _dissociate_links_and_shut_down_pool(self):+    self._grpc_link.end_stop()+    self._grpc_link.join_link(utilities.NULL_LINK)+    self._end_link.join_link(utilities.NULL_LINK)+    self._end_link = None+    if self._pool is not None:+      self._pool.shutdown(wait=True)+    self._pool = None++  def _stop_stopping(self):+    self._dissociate_links_and_shut_down_pool()+    for stop_event in self._stop_events:+      stop_event.set()+    self._stop_events = None++  def _stop_started(self):+    self._grpc_link.begin_stop()+    self._end_link.stop(0).wait()+    self._dissociate_links_and_shut_down_pool()++  def _foreign_thread_stop(self, end_stop_event, stop_events):+    end_stop_event.wait()+    with self._lock:+      if self._stop_events is stop_events:+        self._stop_stopping()++  def _schedule_stop(self, grace):+    with self._lock:+      if self._end_link is None:+        return _set_event()+      server_stop_event = threading.Event()+      if self._stop_events is None:+        self._stop_events = [server_stop_event]+        self._grpc_link.begin_stop()+      else:+        self._stop_events.append(server_stop_event)+      end_stop_event = self._end_link.stop(grace)+      end_stop_thread = threading.Thread(+          target=self._foreign_thread_stop,+          args=(end_stop_event, self._stop_events))+      end_stop_thread.start()+      return server_stop_event++  def _stop_now(self):+    with self._lock:+      if self._end_link is not None:+        if self._stop_events is None:","`None` is a very effective sentinel, and I do like using it in complex-state-objects to indicate ""this field is not valid when the object is in this category of state"".",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4269,46509548,2015-12-03T03:35:01Z,src/python/grpcio/grpc/beta/_server.py,"@@ -61,86 +67,143 @@ def service(self, group, method, context, output_operator):         raise  -def _disassemble(grpc_link, end_link, pool, event, grace):-  grpc_link.begin_stop()-  end_link.stop(grace).wait()-  grpc_link.end_stop()-  grpc_link.join_link(utilities.NULL_LINK)-  end_link.join_link(utilities.NULL_LINK)-  if pool is not None:-    pool.shutdown(wait=True)-  event.set()+class _Server(interfaces.Server): +  def __init__(+      self, implementations, multi_implementation, pool, pool_size,+      default_timeout, maximum_timeout, grpc_link):+    self._lock = threading.Lock()+    self._implementations = implementations+    self._multi_implementation = multi_implementation+    self._customer_pool = pool+    self._pool_size = pool_size+    self._default_timeout = default_timeout+    self._maximum_timeout = maximum_timeout+    self._grpc_link = grpc_link -class Server(interfaces.Server):+    self._end_link = None+    self._stop_events = None+    self._pool = None -  def __init__(self, grpc_link, end_link, pool):-    self._grpc_link = grpc_link-    self._end_link = end_link-    self._pool = pool+  def _start(self):+    with self._lock:+      if self._end_link is not None:+        raise ValueError('Cannot start already-started server!')++      if self._customer_pool is None:+        self._pool = logging_pool.pool(self._pool_size)+        assembly_pool = self._pool+      else:+        assembly_pool = self._customer_pool++      servicer = _GRPCServicer(+          _crust_implementations.servicer(+              self._implementations, self._multi_implementation, assembly_pool))++      self._end_link = _core_implementations.service_end_link(+          servicer, self._default_timeout, self._maximum_timeout)++      self._grpc_link.join_link(self._end_link)+      self._end_link.join_link(self._grpc_link)+      self._grpc_link.start()+      self._end_link.start()++  def _dissociate_links_and_shut_down_pool(self):+    self._grpc_link.end_stop()+    self._grpc_link.join_link(utilities.NULL_LINK)+    self._end_link.join_link(utilities.NULL_LINK)+    self._end_link = None+    if self._pool is not None:+      self._pool.shutdown(wait=True)+    self._pool = None++  def _stop_stopping(self):+    self._dissociate_links_and_shut_down_pool()+    for stop_event in self._stop_events:+      stop_event.set()+    self._stop_events = None++  def _stop_started(self):+    self._grpc_link.begin_stop()+    self._end_link.stop(0).wait()+    self._dissociate_links_and_shut_down_pool()++  def _foreign_thread_stop(self, end_stop_event, stop_events):+    end_stop_event.wait()+    with self._lock:+      if self._stop_events is stop_events:+        self._stop_stopping()++  def _schedule_stop(self, grace):+    with self._lock:+      if self._end_link is None:+        return _set_event()+      server_stop_event = threading.Event()+      if self._stop_events is None:+        self._stop_events = [server_stop_event]+        self._grpc_link.begin_stop()+      else:+        self._stop_events.append(server_stop_event)+      end_stop_event = self._end_link.stop(grace)+      end_stop_thread = threading.Thread(+          target=self._foreign_thread_stop,+          args=(end_stop_event, self._stop_events))+      end_stop_thread.start()+      return server_stop_event++  def _stop_now(self):+    with self._lock:+      if self._end_link is not None:+        if self._stop_events is None:","Exactly. Consider:(1) Server is running.(2) Server is told to stop with grace; thread is kicked off.(3) Server is told to stop with no grace. Grace thread is unblocked on its event, but for some reason doesn't get scheduled on a CPU. Server stops.(4) Server is restarted.(5) Server is told to stop with long grace.(6) Thread kicked off in (2) is finally scheduled and runs on a CPU.Without the identity comparison, that thread would acquire the lock, see that the server is in a shutdown grace period, and complete the shutdown. With the identity comparison, the thread is able to determine that although the server is in a shutdown grace period, _it is not in the same shutdown grace period as the one the thread was scheduled to conclude_, and so it correctly does nothing.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/4228,46517079,2015-12-03T06:38:16Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -73,12 +73,75 @@ def ssl_client_credentials(root_certificates, private_key, certificate_chain):       certificate chain should be used.    Returns:-    A ClientCredentials for use with an SSL-enabled Channel.+    A ChannelCredentials for use with an SSL-enabled Channel.   """"""-  intermediary_low_credentials = _intermediary_low.ClientCredentials(-      root_certificates, private_key, certificate_chain)-  return ClientCredentials(-      intermediary_low_credentials._internal, intermediary_low_credentials)  # pylint: disable=protected-access+  return ChannelCredentials(_low.channel_credentials_ssl(+      root_certificates, private_key, certificate_chain))+++class CallCredentials(object):+  """"""A value encapsulating data asserting an identity over an *established*+  channel. May be composed with ChannelCredentials to always assert identity for+  every call over that channel.++  This class and its instances have no supported interface - it exists to define+  the type of its instances and its instances exist to be passed to other+  functions.+  """"""++  def __init__(self, low_credentials):+    self._low_credentials = low_credentials+++def metadata_call_credentials(metadata_callback, name=None):+  """"""Construct call credentials from an auth metadata plugin.","The return type itself is in the return type doc-comment below, and I'd feel a bit weird then calling the auth metadata plugin an 'auth metadata plugin' as opposed to giving it some proper type.Actually, that's a question: should the `metadata_callback` argument actually be some `metadata_auth_plugin` argument with an abstract class interface somewhere? I'm leaning towards no, for ease of use, but just bringing it up as a possibility.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4228,46517436,2015-12-03T06:46:15Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -73,12 +73,75 @@ def ssl_client_credentials(root_certificates, private_key, certificate_chain):       certificate chain should be used.    Returns:-    A ClientCredentials for use with an SSL-enabled Channel.+    A ChannelCredentials for use with an SSL-enabled Channel.   """"""-  intermediary_low_credentials = _intermediary_low.ClientCredentials(-      root_certificates, private_key, certificate_chain)-  return ClientCredentials(-      intermediary_low_credentials._internal, intermediary_low_credentials)  # pylint: disable=protected-access+  return ChannelCredentials(_low.channel_credentials_ssl(+      root_certificates, private_key, certificate_chain))+++class CallCredentials(object):+  """"""A value encapsulating data asserting an identity over an *established*+  channel. May be composed with ChannelCredentials to always assert identity for+  every call over that channel.++  This class and its instances have no supported interface - it exists to define+  the type of its instances and its instances exist to be passed to other+  functions.+  """"""++  def __init__(self, low_credentials):+    self._low_credentials = low_credentials+++def metadata_call_credentials(metadata_callback, name=None):+  """"""Construct call credentials from an auth metadata plugin.","> The return type itself is in the return type doc-comment below, and I'd feel a bit weird then calling the auth metadata plugin an 'auth metadata plugin' as opposed to giving it some proper type.I'm OK with that but then, I think it would make sense to change the doc for the ssl_credentials which uses `ChannelCredentials` as opposed to `channel credentials` (see my new comment on this).> Actually, that's a question: should the metadata_callback argument actually be some metadata_auth_plugin argument with an abstract class interface somewhere? I'm leaning towards no, for ease of use, but just bringing it up as a possibility.This more of a python question I believe. What would you, user of the API, think would be the most appropriate? Maybe @nathanielmanistaatgoogle has some good insight on this.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4228,46608983,2015-12-03T20:43:41Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -73,12 +73,75 @@ def ssl_client_credentials(root_certificates, private_key, certificate_chain):       certificate chain should be used.    Returns:-    A ClientCredentials for use with an SSL-enabled Channel.+    A ChannelCredentials for use with an SSL-enabled Channel.   """"""-  intermediary_low_credentials = _intermediary_low.ClientCredentials(-      root_certificates, private_key, certificate_chain)-  return ClientCredentials(-      intermediary_low_credentials._internal, intermediary_low_credentials)  # pylint: disable=protected-access+  return ChannelCredentials(_low.channel_credentials_ssl(+      root_certificates, private_key, certificate_chain))+++class CallCredentials(object):+  """"""A value encapsulating data asserting an identity over an *established*+  channel. May be composed with ChannelCredentials to always assert identity for+  every call over that channel.++  This class and its instances have no supported interface - it exists to define+  the type of its instances and its instances exist to be passed to other+  functions.+  """"""++  def __init__(self, low_credentials):+    self._low_credentials = low_credentials+++def metadata_call_credentials(metadata_callback, name=None):+  """"""Construct call credentials from an auth metadata plugin.++  Args:+    metadata_callback (callable): Callback accepting an","(1) Identify the type of a parameter in the prose on the right of the colon, not with the parameter name on the left side of the colon. (https://google.github.io/styleguide/pyguide.html?showone=Comments#Comments contains the canonical sample to follow.)(2) ""callable"" is no more a complete type description than ""set"", ""tuple"", or ""dict"". Just as a description of a dictionary should read ""a dictionary from integers to bytetrings"", the type description here should probably be something like ""a callable taking an X and a Y and either returning a Z or raising a Q"".",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4228,46620491,2015-12-03T22:10:50Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -56,13 +57,12 @@ class ClientCredentials(object):   functions.   """""" -  def __init__(self, low_credentials, intermediary_low_credentials):+  def __init__(self, low_credentials):     self._low_credentials = low_credentials-    self._intermediary_low_credentials = intermediary_low_credentials  -def ssl_client_credentials(root_certificates, private_key, certificate_chain):-  """"""Creates a ClientCredentials for use with an SSL-enabled Channel.+def ssl_channel_credentials(root_certificates, private_key, certificate_chain):","Assuming that the default roots in the python/core package are installed/configured correctly (and we have a challenge with that right now, see #4224), then everything set to `None` is indeed the 90% use case (a grpc client connecting to a server with a publicly trusted cert).Also , it does not make sense to have a private key without a cert chain and vice-versa so maybe these could be a tuple but I'll leave that up to your python sense of zen :).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4274,46918190,2015-12-08T06:10:28Z,src/core/surface/channel.c,"@@ -179,6 +180,16 @@ static grpc_call *grpc_channel_create_call_internal(     send_metadata[num_metadata++] = GRPC_MDELEM_REF(channel->default_authority);   } +  if (propagation_mask & GRPC_PROPAGATE_CENSUS_TRACING_CONTEXT) {+    char buf[GRPC_CENSUS_MAX_ON_THE_WIRE_TAG_BYTES];+    size_t len = census_context_serialize(",We should talk here... But there's no way we can take a link dependency on census from call.c.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4392,47272945,2015-12-10T19:32:12Z,src/core/census/grpc_filter.c,"@@ -115,8 +115,8 @@ static void server_mutate_op(grpc_call_element *elem, static void server_start_transport_op(grpc_exec_ctx *exec_ctx,                                       grpc_call_element *elem,                                       grpc_transport_stream_op *op) {-  call_data *calld = elem->call_data;-  GPR_ASSERT((calld->op_id.upper != 0) || (calld->op_id.lower != 0));+  /* call_data *calld = elem->call_data;","DoneOn Thu, Dec 10, 2015 at 11:22 AM David G. Quintas notifications@github.comwrote:> In src/core/census/grpc_filter.c> https://github.com/grpc/grpc/pull/4392#discussion_r47271512:> > > @@ -115,8 +115,8 @@ static void server_mutate_op(grpc_call_element *elem,> >  static void server_start_transport_op(grpc_exec_ctx *exec_ctx,> >                                        grpc_call_element *elem,> >                                        grpc_transport_stream_op *op) {> > -  call_data *calld = elem->call_data;> > -  GPR_ASSERT((calld->op_id.upper != 0) || (calld->op_id.lower != 0));> > -  /\* call_data *calld = elem->call_data;> > either remove completely or add a TODO explaining why the block has been> (temporarily) commented out.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/4392/files#r47271512.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/4413,47313365,2015-12-11T01:46:48Z,src/ruby/ext/grpc/rb_channel_credentials.c,"@@ -164,21 +166,16 @@ static VALUE grpc_rb_channel_credentials_init(int argc, VALUE *argv, VALUE self)   grpc_channel_credentials *creds = NULL;   grpc_ssl_pem_key_cert_pair key_cert_pair;   MEMZERO(&key_cert_pair, grpc_ssl_pem_key_cert_pair, 1);-  /* TODO: Remove mandatory arg when we support default roots. */-  /* ""12"" == 1 mandatory arg, 2 (credentials) is optional */-  rb_scan_args(argc, argv, ""12"", &pem_root_certs, &pem_private_key,+  /* ""03"" == no mandatory arg, 3 optional */+  rb_scan_args(argc, argv, ""03"", &pem_root_certs, &pem_private_key,                &pem_cert_chain);    TypedData_Get_Struct(self, grpc_rb_channel_credentials,                        &grpc_rb_channel_credentials_data_type, wrapper);-  if (pem_root_certs == Qnil) {-    rb_raise(rb_eRuntimeError,-             ""could not create a credential: nil pem_root_certs"");-    return Qnil;-  }   if (pem_private_key == Qnil && pem_cert_chain == Qnil) {-    creds =-        grpc_ssl_credentials_create(RSTRING_PTR(pem_root_certs), NULL, NULL);+    creds = grpc_ssl_credentials_create(+        pem_root_certs == Qnil ? NULL : RSTRING_PTR(pem_root_certs),","This should probably be separated out into a conditional, like``` rubychar *root_certs = NULL;if (pem_root_certs != Qnil) {  root_certs = RSTRING_PTR(pem_root_certs);}```",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4394,47392334,2015-12-11T19:14:21Z,src/php/ext/grpc/call_credentials.c,"@@ -125,9 +126,105 @@ PHP_METHOD(CallCredentials, createComposite) {   RETURN_DESTROY_ZVAL(creds_object); } +/**+ * Create a call credentials object from the plugin API+ * @param function callback The callback function+ * @return CallCredentials The new call credentials object+ */+PHP_METHOD(CallCredentials, createFromPlugin) {+  zend_fcall_info *fci;+  zend_fcall_info_cache *fci_cache;++  fci = (zend_fcall_info *)emalloc(sizeof(zend_fcall_info));+  fci_cache = (zend_fcall_info_cache *)emalloc(sizeof(zend_fcall_info_cache));+  memset(fci, 0, sizeof(zend_fcall_info));+  memset(fci_cache, 0, sizeof(zend_fcall_info_cache));++  /* ""f"" == 1 function */+  if (zend_parse_parameters(ZEND_NUM_ARGS(), ""f"", fci,+                            fci_cache,+                            fci->params,+                            fci->param_count) == FAILURE) {+    zend_throw_exception(spl_ce_InvalidArgumentException,+                         ""createFromPlugin expects 1 callback"",+                         1 TSRMLS_CC);+    return;+  }++  plugin_state *state;+  state = (plugin_state *)emalloc(sizeof(plugin_state));+  memset(state, 0, sizeof(plugin_state));++  /* save the user provided PHP callback function */+  state->fci = fci;+  state->fci_cache = fci_cache;++  grpc_metadata_credentials_plugin plugin;+  plugin.get_metadata = plugin_get_metadata;+  plugin.destroy = plugin_destroy_state;+  plugin.state = (void *)state;+  plugin.type = """";++  grpc_call_credentials *creds = grpc_metadata_credentials_create_from_plugin(+      plugin, NULL);+  zval *creds_object = grpc_php_wrap_call_credentials(creds);+  RETURN_DESTROY_ZVAL(creds_object);+}++/* Callback function for plugin creds API */+void plugin_get_metadata(void *ptr, grpc_auth_metadata_context context,+                         grpc_credentials_plugin_metadata_cb cb,+                         void *user_data) {+  plugin_state *state = (plugin_state *)ptr;++  /* prepare to call the user callback function with info from the+   * grpc_auth_metadata_context */+  zval **params[1];+  zval *arg;+  zval *retval;+  MAKE_STD_ZVAL(arg);+  ZVAL_STRING(arg, context.service_url, 1);","Looks like the grpc_auth_metadata_context fields are passed as individual params to the callback. Will it break the API if/when we add more (method name, auth context)?",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4444,47539554,2015-12-14T18:52:02Z,test/core/bad_ssl/servers/alpn.c,"@@ -0,0 +1,81 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>++#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/log.h>+#include <grpc/support/useful.h>++#include ""test/core/bad_ssl/server.h""+#include ""test/core/end2end/data/ssl_test_data.h""++static const char *const fake_versions[] = {""not-h2""};",Maybe have a comment explaining the scenario here. e.g. regular client will connect to a server advertising a bad alpn version (see fake_version).,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4444,47539923,2015-12-14T18:54:39Z,test/core/bad_ssl/server.c,"@@ -0,0 +1,92 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/cmdline.h>+#include <grpc/support/log.h>+#include <signal.h>++#include ""test/core/bad_ssl/server.h""+#include ""test/core/util/test_config.h""++static int got_sigint = 0;",Maybe a comment explaining that there's nothing bad with this server code per se but that the misconfiguration will come from the implementation of the main function in other files (e.g. alpn.c or certs.c).,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4453,47565666,2015-12-14T22:05:39Z,src/core/transport/chttp2_transport.c,"@@ -748,6 +753,21 @@ void grpc_chttp2_complete_closure_step(grpc_exec_ctx *exec_ctx,   *pclosure = NULL; } +static void fail_all_outstanding_ops(+    grpc_exec_ctx *exec_ctx, grpc_chttp2_transport_global *transport_global,+    grpc_chttp2_stream_global *stream_global) {+  grpc_chttp2_complete_closure_step(+      exec_ctx, &stream_global->send_initial_metadata_finished, 0);+  grpc_chttp2_complete_closure_step(+      exec_ctx, &stream_global->send_trailing_metadata_finished, 0);+  grpc_chttp2_complete_closure_step(exec_ctx,+                                    &stream_global->send_message_finished, 0);+  grpc_chttp2_complete_closure_step(+      exec_ctx, &stream_global->recv_initial_metadata_finished, 0);+  grpc_chttp2_complete_closure_step(+      exec_ctx, &stream_global->recv_trailing_metadata_finished, 0);+}","I think so. This is built on top of #4451 - and that's what was requiredfor those tests. I'm going to start merging your fixes into this and see ifI can come up with a grand unified PR that addresses all the lost callbackbugs.On Mon, Dec 14, 2015 at 2:02 PM Sree Kuchibhotla notifications@github.comwrote:> In src/core/transport/chttp2_transport.c> https://github.com/grpc/grpc/pull/4453#discussion_r47565257:> > > @@ -748,6 +753,21 @@ void grpc_chttp2_complete_closure_step(grpc_exec_ctx *exec_ctx,> >    *pclosure = NULL;> >  }> > > > +static void fail_all_outstanding_ops(> > -    grpc_exec_ctx *exec_ctx, grpc_chttp2_transport_global *transport_global,> > -    grpc_chttp2_stream_global *stream_global) {> > -  grpc_chttp2_complete_closure_step(> > -      exec_ctx, &stream_global->send_initial_metadata_finished, 0);> > -  grpc_chttp2_complete_closure_step(> > -      exec_ctx, &stream_global->send_trailing_metadata_finished, 0);> > -  grpc_chttp2_complete_closure_step(exec_ctx,> > -                                    &stream_global->send_message_finished, 0);> > -  grpc_chttp2_complete_closure_step(> > -      exec_ctx, &stream_global->recv_initial_metadata_finished, 0);> > -  grpc_chttp2_complete_closure_step(> > -      exec_ctx, &stream_global->recv_trailing_metadata_finished, 0);> >   +}> > Should recv_message_ready closure also be queued here ?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/4453/files#r47565257.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4457,47596034,2015-12-15T04:36:36Z,build.yaml,"@@ -2455,3 +2455,7 @@ node_modules:   - src/node/ext/server.cc   - src/node/ext/server_credentials.cc   - src/node/ext/timeval.cc+python_dependencies:",I like the data driving here.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4449,47663254,2015-12-15T16:48:42Z,tools/run_tests/run_tests.py,"@@ -509,6 +526,7 @@ def __str__(self): _WINDOWS_CONFIG = {     'dbg': 'Debug',     'opt': 'Release',+    'gcov': 'Release',","Yes, I think you're right (but for C# it's actually not a big difference and for windows we don't have a way to collect csharp_ext coverage anyway).As I have 2 pull requests based on this one, would it be fine to address this in a followup PR?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4429,47713612,2015-12-15T23:08:26Z,src/php/.gitignore,"@@ -18,5 +18,4 @@ missing mkinstalldirs  ext/grpc/ltmain.sh-composer.lock","I am afraid we can't just check in composer.lock like this because that could break developers that check out grpc repo and want to work on PHP.In a similar nature, we could actually try to get composer.lock created and all dependencies downloaded in the base PHP docker file. After that, we need to make sure the contents of the PHP repository would get wiped out properly. Then, when actually building PHP from the latest sources, composer should be able to recognize that all the sources have already been downloaded.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4512,47959532,2015-12-17T20:53:33Z,src/core/security/credentials.c,"@@ -179,8 +179,8 @@ void grpc_server_credentials_set_auth_metadata_processor(   GRPC_API_TRACE(       ""grpc_server_credentials_set_auth_metadata_processor(""       ""creds=%p, ""-      ""processor=grpc_auth_metadata_processor { process: %lx, state: %p })"",-      3, (creds, (unsigned long)processor.process, processor.state));",unsigned long long is not a thing for usgpr_uint64,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4512,47974331,2015-12-17T23:03:31Z,src/core/security/credentials.c,"@@ -179,8 +179,8 @@ void grpc_server_credentials_set_auth_metadata_processor(   GRPC_API_TRACE(       ""grpc_server_credentials_set_auth_metadata_processor(""       ""creds=%p, ""-      ""processor=grpc_auth_metadata_processor { process: %lx, state: %p })"",-      3, (creds, (unsigned long)processor.process, processor.state));","to me it seems like there's no guarantee that  long long will be of same size as gpr_uint64.Given the formatting string is %llx, I should really use a long long type as an argument.Actually, based on this post http://stackoverflow.com/questions/14071713/what-is-wrong-with-printfllx, it seems like the %llx might not work on windows :-)I genuinely don't know what the correct approach is.Btw, I did some %ll  (long long)  prints in some of my previous pull requests.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4526,47987328,2015-12-18T02:06:38Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pxd,"@@ -37,3 +37,5 @@ cdef class CompletionQueue:   cdef bint is_polling   cdef bint is_shutting_down   cdef bint is_shutdown++  cdef interpret_event(self, grpc.grpc_event event)","Is this method intended to be used by users of this CompletionQueue class? If not, would a leading underscore be appropriate in its name?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4526,47987465,2015-12-18T02:09:35Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx,"@@ -74,7 +68,41 @@ cdef class CompletionQueue:     with self.poll_condition:       self.is_polling = False       self.poll_condition.notify()+    return self.interpret_event(event)++  def pluck(self, records.OperationTag tag, records.Timespec deadline=None):+    # Plucking a 'None' tag is equivalent to passing control to GRPC core until+    # the deadline.+    # TODO(atash) there's currently no way of getting a tag to pass to this","I'm not sure I understand this comment, at least as far as its belonging at this point in the code. If there's no way to get a non-`None` tag to pass to this method, isn't that a problem for callers of the method, and maybe the comment should go outside the method instead of inside its body? Or am I misunderstanding what the comment is saying?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4526,47987590,2015-12-18T02:11:41Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx,"@@ -74,7 +68,41 @@ cdef class CompletionQueue:     with self.poll_condition:       self.is_polling = False       self.poll_condition.notify()+    return self.interpret_event(event)++  def pluck(self, records.OperationTag tag, records.Timespec deadline=None):+    # Plucking a 'None' tag is equivalent to passing control to GRPC core until+    # the deadline.","... and if the deadline is `None`, as is the case for the call site introduced in this function, what then?Wait, it's not `None`, it's `records.Timespec(None)`. What's that?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/4526,47988199,2015-12-18T02:24:35Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx,"@@ -74,7 +68,41 @@ cdef class CompletionQueue:     with self.poll_condition:       self.is_polling = False       self.poll_condition.notify()+    return self.interpret_event(event)++  def pluck(self, records.OperationTag tag, records.Timespec deadline=None):+    # Plucking a 'None' tag is equivalent to passing control to GRPC core until+    # the deadline.",Current time - immediate deadline.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/4526,47988394,2015-12-18T02:29:23Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx,"@@ -74,7 +68,41 @@ cdef class CompletionQueue:     with self.poll_condition:       self.is_polling = False       self.poll_condition.notify()+    return self.interpret_event(event)++  def pluck(self, records.OperationTag tag, records.Timespec deadline=None):+    # Plucking a 'None' tag is equivalent to passing control to GRPC core until+    # the deadline.+    # TODO(atash) there's currently no way of getting a tag to pass to this+    # function; consider adding such allowances to Call and Server.+    cdef grpc.gpr_timespec c_deadline = grpc.gpr_inf_future(+        grpc.GPR_CLOCK_REALTIME)+    if deadline is not None:+      c_deadline = deadline.c_time+    cdef grpc.grpc_event event++    # Poll within a critical section+    # TODO consider making queue polling contention a hard error to enable+    # easier bug discovery+    with self.poll_condition:+      while self.is_polling:+        self.poll_condition.wait(float(deadline) - time.time())+      self.is_polling = True",There's a condition variable around it in a pattern similar to what I've seen in the rest of the Python code. I'd be perfectly happy with instead using a mutex or with crashing if the non-simultaneity contract was broken on grpc_completion_queue_(next|pluck) instead of waiting.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4512,47989806,2015-12-18T02:55:37Z,test/core/support/alloc_test.c,"@@ -48,8 +48,8 @@ static void test_custom_allocs() {   gpr_allocation_functions fns = {fake_malloc, fake_realloc, fake_free};    gpr_set_allocation_functions(fns);-  GPR_ASSERT((void *)0xdeadbeef == gpr_malloc(0xdeadbeef));","Alright, so the warning is: ........\test\core\support\alloc_test.c(51): warning C4312: 'type cast': conversion from 'unsigned int' to 'void *' of greater size [c:\Users\jtattermusch\github\grpc\vsprojects\vcxproj\test\alloc_test\alloc_test.vcxproj]Basically casting (void *)0xdeadbeef is illegal.   ",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4526,47990326,2015-12-18T03:07:17Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx,"@@ -74,7 +68,41 @@ cdef class CompletionQueue:     with self.poll_condition:       self.is_polling = False       self.poll_condition.notify()+    return self.interpret_event(event)++  def pluck(self, records.OperationTag tag, records.Timespec deadline=None):+    # Plucking a 'None' tag is equivalent to passing control to GRPC core until+    # the deadline.+    # TODO(atash) there's currently no way of getting a tag to pass to this","If the code above this were changed to take a break from continuously calling `next` and call this `pluck` function with a tag that it knew was outstanding, would this method misbehave?If no value other than `None` is safe to pass for `tag`, why even have the parameter?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/4526,47993253,2015-12-18T04:17:36Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx,"@@ -74,7 +68,41 @@ cdef class CompletionQueue:     with self.poll_condition:       self.is_polling = False       self.poll_condition.notify()+    return self.interpret_event(event)++  def pluck(self, records.OperationTag tag, records.Timespec deadline=None):+    # Plucking a 'None' tag is equivalent to passing control to GRPC core until+    # the deadline.+    # TODO(atash) there's currently no way of getting a tag to pass to this","As for misbehavior, it would only misbehave if core misbehaves; w.r.t. core, as long as pluck and next are not being called in an overlapping manner (which is ensured currently by the critical section), this shouldn't be a problem.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/4522,48043043,2015-12-18T16:33:53Z,src/csharp/Grpc.Core/Internal/PlatformInvocationWin64.cs,"@@ -0,0 +1,771 @@+﻿using System;+using System.Runtime.InteropServices;++namespace Grpc.Core.Internal+{+    /// <summary>+    /// Platform invoke method bindings for 64-bit Windows platforms+    /// </summary>+    internal class PlatformInvocationWin64 : IPlatformInvocation+    {+        // Environment++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_init();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_shutdown();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_version_string();  // returns not-owned const char*++        void IPlatformInvocation.grpcsharp_init()+        {+            grpcsharp_init();+        }++        void IPlatformInvocation.grpcsharp_shutdown()+        {+            grpcsharp_shutdown();+        }++        IntPtr IPlatformInvocation.grpcsharp_version_string()+        {+            return grpcsharp_version_string();+        }++        // BatchContextSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern BatchContextSafeHandle grpcsharp_batch_context_create();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_initial_metadata(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_message_length(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_batch_context_recv_message_to_buffer(BatchContextSafeHandle ctx, byte[] buffer, UIntPtr bufferLen);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern StatusCode grpcsharp_batch_context_recv_status_on_client_status(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_status_on_client_details(BatchContextSafeHandle ctx);  // returns const char*++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_status_on_client_trailing_metadata(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CallSafeHandle grpcsharp_batch_context_server_rpc_new_call(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_server_rpc_new_method(BatchContextSafeHandle ctx);  // returns const char*++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_server_rpc_new_host(BatchContextSafeHandle ctx);  // returns const char*++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern Timespec grpcsharp_batch_context_server_rpc_new_deadline(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_server_rpc_new_request_metadata(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern int grpcsharp_batch_context_recv_close_on_server_cancelled(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_batch_context_destroy(IntPtr ctx);++++        BatchContextSafeHandle IPlatformInvocation.grpcsharp_batch_context_create()+        {+            return grpcsharp_batch_context_create();+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_initial_metadata(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_initial_metadata(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_message_length(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_message_length(ctx);+        }++        void IPlatformInvocation.grpcsharp_batch_context_recv_message_to_buffer(BatchContextSafeHandle ctx, byte[] buffer, UIntPtr bufferLen)+        {+            grpcsharp_batch_context_recv_message_to_buffer(ctx, buffer, bufferLen);+        }++        StatusCode IPlatformInvocation.grpcsharp_batch_context_recv_status_on_client_status(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_status_on_client_status(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_status_on_client_details(BatchContextSafeHandle ctx) // returns const char*+        {+            return grpcsharp_batch_context_recv_status_on_client_details(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_status_on_client_trailing_metadata(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_status_on_client_trailing_metadata(ctx);+        }++        CallSafeHandle IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_call(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_server_rpc_new_call(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_method(BatchContextSafeHandle ctx) // returns const char*+        {+            return grpcsharp_batch_context_server_rpc_new_method(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_host(BatchContextSafeHandle ctx) // returns const char*+        {+            return grpcsharp_batch_context_server_rpc_new_host(ctx);+        }++        Timespec IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_deadline(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_server_rpc_new_deadline(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_request_metadata(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_server_rpc_new_request_metadata(ctx);+        }++        int IPlatformInvocation.grpcsharp_batch_context_recv_close_on_server_cancelled(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_close_on_server_cancelled(ctx);+        }++        void IPlatformInvocation.grpcsharp_batch_context_destroy(IntPtr ctx)+        {+            grpcsharp_batch_context_destroy(ctx);+        }++        // CallCredentialsSafeHandle+        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CallCredentialsSafeHandle grpcsharp_composite_call_credentials_create(CallCredentialsSafeHandle creds1, CallCredentialsSafeHandle creds2);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_call_credentials_release(IntPtr credentials);++        CallCredentialsSafeHandle IPlatformInvocation.grpcsharp_composite_call_credentials_create(CallCredentialsSafeHandle creds1, CallCredentialsSafeHandle creds2)+        {+            return grpcsharp_composite_call_credentials_create(creds1, creds2);+        }++        void IPlatformInvocation.grpcsharp_call_credentials_release(IntPtr credentials)+        {+            grpcsharp_call_credentials_release(credentials);+        }+++        // CallSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_cancel(CallSafeHandle call);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_cancel_with_status(CallSafeHandle call, StatusCode status, string description);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_unary(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len, MetadataArraySafeHandle metadataArray, WriteFlags writeFlags);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_client_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_server_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len,+            MetadataArraySafeHandle metadataArray, WriteFlags writeFlags);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_duplex_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_message(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len, WriteFlags writeFlags, bool sendEmptyInitialMetadata);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_close_from_client(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_status_from_server(CallSafeHandle call,+            BatchContextSafeHandle ctx, StatusCode statusCode, string statusMessage, MetadataArraySafeHandle metadataArray, bool sendEmptyInitialMetadata);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_recv_message(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_recv_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_serverside(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_set_credentials(CallSafeHandle call, CallCredentialsSafeHandle credentials);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CStringSafeHandle grpcsharp_call_get_peer(CallSafeHandle call);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_call_destroy(IntPtr call);++++        GRPCCallError IPlatformInvocation.grpcsharp_call_cancel(CallSafeHandle call)+        {+            return grpcsharp_call_cancel(call);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_cancel_with_status(CallSafeHandle call, StatusCode status,+            string description)+        {+            return grpcsharp_call_cancel_with_status(call, status, description);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_unary(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len,+            MetadataArraySafeHandle metadataArray, WriteFlags writeFlags)+        {+            return grpcsharp_call_start_unary(call, ctx, send_buffer, send_buffer_len, metadataArray, writeFlags);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_client_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray)+        {+            return grpcsharp_call_start_client_streaming(call, ctx, metadataArray);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_server_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len,+            MetadataArraySafeHandle metadataArray, WriteFlags writeFlags)+        {+            return grpcsharp_call_start_server_streaming(call, ctx, send_buffer, send_buffer_len, metadataArray,+                writeFlags);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_duplex_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray)+        {+            return grpcsharp_call_start_duplex_streaming(call, ctx, metadataArray);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_message(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len, WriteFlags writeFlags,+            bool sendEmptyInitialMetadata)+        {+            return grpcsharp_call_send_message(call, ctx, send_buffer, send_buffer_len, writeFlags,+                sendEmptyInitialMetadata);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_close_from_client(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_send_close_from_client(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_status_from_server(CallSafeHandle call,+            BatchContextSafeHandle ctx, StatusCode statusCode, string statusMessage,+            MetadataArraySafeHandle metadataArray, bool sendEmptyInitialMetadata)+        {+            return grpcsharp_call_send_status_from_server(call, ctx, statusCode, statusMessage, metadataArray,+                sendEmptyInitialMetadata);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_recv_message(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_recv_message(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_recv_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_recv_initial_metadata(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_serverside(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_start_serverside(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray)+        {+            return grpcsharp_call_send_initial_metadata(call, ctx, metadataArray);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_set_credentials(CallSafeHandle call,+            CallCredentialsSafeHandle credentials)+        {+            return grpcsharp_call_set_credentials(call, credentials);+        }++        CStringSafeHandle IPlatformInvocation.grpcsharp_call_get_peer(CallSafeHandle call)+        {+            return grpcsharp_call_get_peer(call);+        }++        void IPlatformInvocation.grpcsharp_call_destroy(IntPtr call)+        {+            grpcsharp_call_destroy(call);+        }+++++++        // ChannelArgsSafeHandle ++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelArgsSafeHandle grpcsharp_channel_args_create(UIntPtr numArgs);++        [DllImport(""grpc_csharp_ext-x64.dll"", CharSet = CharSet.Ansi)]+        static extern void grpcsharp_channel_args_set_string(ChannelArgsSafeHandle args, UIntPtr index, string key, string value);++        [DllImport(""grpc_csharp_ext-x64.dll"", CharSet = CharSet.Ansi)]+        static extern void grpcsharp_channel_args_set_integer(ChannelArgsSafeHandle args, UIntPtr index, string key, int value);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_args_destroy(IntPtr args);+++        ChannelArgsSafeHandle IPlatformInvocation.grpcsharp_channel_args_create(UIntPtr numArgs)+        {+            return grpcsharp_channel_args_create(numArgs);+        }++        void IPlatformInvocation.grpcsharp_channel_args_set_string(ChannelArgsSafeHandle args, UIntPtr index, string key,+            string value)+        {+            grpcsharp_channel_args_set_string(args, index, key, value);+        }++        void IPlatformInvocation.grpcsharp_channel_args_set_integer(ChannelArgsSafeHandle args, UIntPtr index,+            string key, int value)+        {+            grpcsharp_channel_args_set_integer(args, index, key, value);+        }++        void IPlatformInvocation.grpcsharp_channel_args_destroy(IntPtr args)+        {+            grpcsharp_channel_args_destroy(args);+        }+++        // ChannelCredentialsSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"", CharSet = CharSet.Ansi)]+        static extern ChannelCredentialsSafeHandle grpcsharp_ssl_credentials_create(string pemRootCerts, string keyCertPairCertChain, string keyCertPairPrivateKey);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelCredentialsSafeHandle grpcsharp_composite_channel_credentials_create(ChannelCredentialsSafeHandle channelCreds, CallCredentialsSafeHandle callCreds);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_credentials_release(IntPtr credentials);++        ChannelCredentialsSafeHandle IPlatformInvocation.grpcsharp_ssl_credentials_create(string pemRootCerts, string keyCertPairCertChain,+            string keyCertPairPrivateKey)+        {+            return grpcsharp_ssl_credentials_create(pemRootCerts, keyCertPairCertChain, keyCertPairPrivateKey);+        }++        ChannelCredentialsSafeHandle IPlatformInvocation.grpcsharp_composite_channel_credentials_create(+            ChannelCredentialsSafeHandle channelCreds, CallCredentialsSafeHandle callCreds)+        {+            return grpcsharp_composite_channel_credentials_create(channelCreds, callCreds);+        }++        void IPlatformInvocation.grpcsharp_channel_credentials_release(IntPtr credentials)+        {+            grpcsharp_channel_credentials_release(credentials);+        }+++        // ChannelSafeHandle+++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelSafeHandle grpcsharp_insecure_channel_create(string target, ChannelArgsSafeHandle channelArgs);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelSafeHandle grpcsharp_secure_channel_create(ChannelCredentialsSafeHandle credentials, string target, ChannelArgsSafeHandle channelArgs);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CallSafeHandle grpcsharp_channel_create_call(ChannelSafeHandle channel, CallSafeHandle parentCall, ContextPropagationFlags propagationMask, CompletionQueueSafeHandle cq, string method, string host, Timespec deadline);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelState grpcsharp_channel_check_connectivity_state(ChannelSafeHandle channel, int tryToConnect);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_watch_connectivity_state(ChannelSafeHandle channel, ChannelState lastObservedState,+            Timespec deadline, CompletionQueueSafeHandle cq, BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CStringSafeHandle grpcsharp_channel_get_target(ChannelSafeHandle call);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_destroy(IntPtr channel);++        ChannelSafeHandle IPlatformInvocation.grpcsharp_insecure_channel_create(string target,+            ChannelArgsSafeHandle channelArgs)+        {+            return grpcsharp_insecure_channel_create(target, channelArgs);+        }++        ChannelSafeHandle IPlatformInvocation.grpcsharp_secure_channel_create(ChannelCredentialsSafeHandle credentials,+            string target, ChannelArgsSafeHandle channelArgs)+        {+            return grpcsharp_secure_channel_create(credentials, target, channelArgs);+        }++        CallSafeHandle IPlatformInvocation.grpcsharp_channel_create_call(ChannelSafeHandle channel,+            CallSafeHandle parentCall, ContextPropagationFlags propagationMask, CompletionQueueSafeHandle cq,+            string method, string host, Timespec deadline)+        {+            return grpcsharp_channel_create_call(channel, parentCall, propagationMask, cq, method, host, deadline);+        }++        ChannelState IPlatformInvocation.grpcsharp_channel_check_connectivity_state(ChannelSafeHandle channel, int tryToConnect)+        {+            return grpcsharp_channel_check_connectivity_state(channel, tryToConnect);+        }++        void IPlatformInvocation.grpcsharp_channel_watch_connectivity_state(ChannelSafeHandle channel,+            ChannelState lastObservedState, Timespec deadline, CompletionQueueSafeHandle cq, BatchContextSafeHandle ctx)+        {+            grpcsharp_channel_watch_connectivity_state(channel, lastObservedState, deadline, cq, ctx);+        }++        CStringSafeHandle IPlatformInvocation.grpcsharp_channel_get_target(ChannelSafeHandle call)+        {+            return grpcsharp_channel_get_target(call);+        }++        void IPlatformInvocation.grpcsharp_channel_destroy(IntPtr channel)+        {+            grpcsharp_channel_destroy(channel);+        }+++        // CompletionQueueEvent++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern int grpcsharp_sizeof_grpc_event();++        int IPlatformInvocation.grpcsharp_sizeof_grpc_event()+        {+            return grpcsharp_sizeof_grpc_event();+        }+++        // CompletionQueueSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CompletionQueueSafeHandle grpcsharp_completion_queue_create();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_completion_queue_shutdown(CompletionQueueSafeHandle cq);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CompletionQueueEvent grpcsharp_completion_queue_next(CompletionQueueSafeHandle cq);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CompletionQueueEvent grpcsharp_completion_queue_pluck(CompletionQueueSafeHandle cq, IntPtr tag);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_completion_queue_destroy(IntPtr cq);++        CompletionQueueSafeHandle IPlatformInvocation.grpcsharp_completion_queue_create()+        {+            return grpcsharp_completion_queue_create();+        }++        void IPlatformInvocation.grpcsharp_completion_queue_shutdown(CompletionQueueSafeHandle cq)+        {+            grpcsharp_completion_queue_shutdown(cq);+        }+        CompletionQueueEvent IPlatformInvocation.grpcsharp_completion_queue_next(CompletionQueueSafeHandle cq)+        {+            return grpcsharp_completion_queue_next(cq);+        }++        CompletionQueueEvent IPlatformInvocation.grpcsharp_completion_queue_pluck(CompletionQueueSafeHandle cq,+            IntPtr tag)+        {+            return grpcsharp_completion_queue_pluck(cq, tag);+        }++        void IPlatformInvocation.grpcsharp_completion_queue_destroy(IntPtr cq)+        {+            grpcsharp_completion_queue_destroy(cq);+        }++++        // CStringSafeHandle ++        [DllImport(""grpc_csharp_ext-x64.dll"")]","Ah, I see what this trick was to differentiate between 32bit and x64.This seems like one of the possible approaches, but I was actually thinking of doing something along the path of  inspecting what the size of   IntPtr is (4 or 8) and inspecting the current platform (Linux vs Mac vs Windows) and selecting the right shared library programmatically (""dlopen"" or similar).Once the shared library is loaded, all the PInvokes should work fine and .NET won't go ahead to search for a library that was already loaded.What do you think?",
6033304,cj525,https://api.github.com/repos/grpc/grpc/pulls/4522,48045436,2015-12-18T16:55:58Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -157,8 +157,9 @@ protected void StartReadMessageInternal(AsyncCompletionDelegate<TRead> completio                 Preconditions.CheckNotNull(completionDelegate, ""Completion delegate cannot be null"");                 CheckReadingAllowed(); -                call.StartReceiveMessage(HandleReadFinished);+                // I feel like a prerequisite variable should be set before entering that code path",The return from native which is started by StartReceiveMessage will use readCompletionDelegate and it seemed like a race condition that this member would be set after calling StartReceiveMessage.  Albeit an unlikely race condition.  I will remove this when I separate my pull requests; it is not prerequisite functionality for what I'm trying to accomplish.,
6033304,cj525,https://api.github.com/repos/grpc/grpc/pulls/4522,48046139,2015-12-18T17:02:11Z,src/csharp/Grpc.Core/Internal/PlatformInvocation.cs,"@@ -0,0 +1,257 @@+﻿using System;+using System.Runtime.InteropServices;++namespace Grpc.Core.Internal+{+    /// <summary>+    /// Platform invocation dispatch+    /// </summary>+    internal static class PlatformInvocation+    {+        /// <summary>+        /// Retrieve an implementation of platform invocations specific to the current cpu's architecture.+        /// This allows assemblies to function correctly when compiled for AnyCPU+        /// </summary>+        internal static IPlatformInvocation Implementation { get; private set; }","The only difference is the binding for the DllImport annotation.  Without this, you can only use this library from a matching architecture and platform, which is 32-bit Windows.  After compiling with this change, I was able to compile my driver with AnyCPU and the same build worked in all use-cases (most notably Linux as that is my primary target, although I would like Bigtable.NET to just work in all cases).  Pragmas would have worked but would require different builds.  Also, with an interface the native functionality can be mocked for testing, so I opted for this approach.",
6033304,cj525,https://api.github.com/repos/grpc/grpc/pulls/4522,48048215,2015-12-18T17:24:37Z,src/csharp/Grpc.Core/Internal/PlatformInvocationWin64.cs,"@@ -0,0 +1,771 @@+﻿using System;+using System.Runtime.InteropServices;++namespace Grpc.Core.Internal+{+    /// <summary>+    /// Platform invoke method bindings for 64-bit Windows platforms+    /// </summary>+    internal class PlatformInvocationWin64 : IPlatformInvocation+    {+        // Environment++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_init();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_shutdown();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_version_string();  // returns not-owned const char*++        void IPlatformInvocation.grpcsharp_init()+        {+            grpcsharp_init();+        }++        void IPlatformInvocation.grpcsharp_shutdown()+        {+            grpcsharp_shutdown();+        }++        IntPtr IPlatformInvocation.grpcsharp_version_string()+        {+            return grpcsharp_version_string();+        }++        // BatchContextSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern BatchContextSafeHandle grpcsharp_batch_context_create();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_initial_metadata(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_message_length(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_batch_context_recv_message_to_buffer(BatchContextSafeHandle ctx, byte[] buffer, UIntPtr bufferLen);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern StatusCode grpcsharp_batch_context_recv_status_on_client_status(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_status_on_client_details(BatchContextSafeHandle ctx);  // returns const char*++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_recv_status_on_client_trailing_metadata(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CallSafeHandle grpcsharp_batch_context_server_rpc_new_call(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_server_rpc_new_method(BatchContextSafeHandle ctx);  // returns const char*++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_server_rpc_new_host(BatchContextSafeHandle ctx);  // returns const char*++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern Timespec grpcsharp_batch_context_server_rpc_new_deadline(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern IntPtr grpcsharp_batch_context_server_rpc_new_request_metadata(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern int grpcsharp_batch_context_recv_close_on_server_cancelled(BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_batch_context_destroy(IntPtr ctx);++++        BatchContextSafeHandle IPlatformInvocation.grpcsharp_batch_context_create()+        {+            return grpcsharp_batch_context_create();+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_initial_metadata(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_initial_metadata(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_message_length(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_message_length(ctx);+        }++        void IPlatformInvocation.grpcsharp_batch_context_recv_message_to_buffer(BatchContextSafeHandle ctx, byte[] buffer, UIntPtr bufferLen)+        {+            grpcsharp_batch_context_recv_message_to_buffer(ctx, buffer, bufferLen);+        }++        StatusCode IPlatformInvocation.grpcsharp_batch_context_recv_status_on_client_status(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_status_on_client_status(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_status_on_client_details(BatchContextSafeHandle ctx) // returns const char*+        {+            return grpcsharp_batch_context_recv_status_on_client_details(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_recv_status_on_client_trailing_metadata(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_status_on_client_trailing_metadata(ctx);+        }++        CallSafeHandle IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_call(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_server_rpc_new_call(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_method(BatchContextSafeHandle ctx) // returns const char*+        {+            return grpcsharp_batch_context_server_rpc_new_method(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_host(BatchContextSafeHandle ctx) // returns const char*+        {+            return grpcsharp_batch_context_server_rpc_new_host(ctx);+        }++        Timespec IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_deadline(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_server_rpc_new_deadline(ctx);+        }++        IntPtr IPlatformInvocation.grpcsharp_batch_context_server_rpc_new_request_metadata(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_server_rpc_new_request_metadata(ctx);+        }++        int IPlatformInvocation.grpcsharp_batch_context_recv_close_on_server_cancelled(BatchContextSafeHandle ctx)+        {+            return grpcsharp_batch_context_recv_close_on_server_cancelled(ctx);+        }++        void IPlatformInvocation.grpcsharp_batch_context_destroy(IntPtr ctx)+        {+            grpcsharp_batch_context_destroy(ctx);+        }++        // CallCredentialsSafeHandle+        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CallCredentialsSafeHandle grpcsharp_composite_call_credentials_create(CallCredentialsSafeHandle creds1, CallCredentialsSafeHandle creds2);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_call_credentials_release(IntPtr credentials);++        CallCredentialsSafeHandle IPlatformInvocation.grpcsharp_composite_call_credentials_create(CallCredentialsSafeHandle creds1, CallCredentialsSafeHandle creds2)+        {+            return grpcsharp_composite_call_credentials_create(creds1, creds2);+        }++        void IPlatformInvocation.grpcsharp_call_credentials_release(IntPtr credentials)+        {+            grpcsharp_call_credentials_release(credentials);+        }+++        // CallSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_cancel(CallSafeHandle call);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_cancel_with_status(CallSafeHandle call, StatusCode status, string description);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_unary(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len, MetadataArraySafeHandle metadataArray, WriteFlags writeFlags);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_client_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_server_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len,+            MetadataArraySafeHandle metadataArray, WriteFlags writeFlags);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_duplex_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_message(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len, WriteFlags writeFlags, bool sendEmptyInitialMetadata);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_close_from_client(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_status_from_server(CallSafeHandle call,+            BatchContextSafeHandle ctx, StatusCode statusCode, string statusMessage, MetadataArraySafeHandle metadataArray, bool sendEmptyInitialMetadata);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_recv_message(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_recv_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_start_serverside(CallSafeHandle call,+            BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_send_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern GRPCCallError grpcsharp_call_set_credentials(CallSafeHandle call, CallCredentialsSafeHandle credentials);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CStringSafeHandle grpcsharp_call_get_peer(CallSafeHandle call);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_call_destroy(IntPtr call);++++        GRPCCallError IPlatformInvocation.grpcsharp_call_cancel(CallSafeHandle call)+        {+            return grpcsharp_call_cancel(call);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_cancel_with_status(CallSafeHandle call, StatusCode status,+            string description)+        {+            return grpcsharp_call_cancel_with_status(call, status, description);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_unary(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len,+            MetadataArraySafeHandle metadataArray, WriteFlags writeFlags)+        {+            return grpcsharp_call_start_unary(call, ctx, send_buffer, send_buffer_len, metadataArray, writeFlags);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_client_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray)+        {+            return grpcsharp_call_start_client_streaming(call, ctx, metadataArray);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_server_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len,+            MetadataArraySafeHandle metadataArray, WriteFlags writeFlags)+        {+            return grpcsharp_call_start_server_streaming(call, ctx, send_buffer, send_buffer_len, metadataArray,+                writeFlags);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_duplex_streaming(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray)+        {+            return grpcsharp_call_start_duplex_streaming(call, ctx, metadataArray);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_message(CallSafeHandle call,+            BatchContextSafeHandle ctx, byte[] send_buffer, UIntPtr send_buffer_len, WriteFlags writeFlags,+            bool sendEmptyInitialMetadata)+        {+            return grpcsharp_call_send_message(call, ctx, send_buffer, send_buffer_len, writeFlags,+                sendEmptyInitialMetadata);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_close_from_client(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_send_close_from_client(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_status_from_server(CallSafeHandle call,+            BatchContextSafeHandle ctx, StatusCode statusCode, string statusMessage,+            MetadataArraySafeHandle metadataArray, bool sendEmptyInitialMetadata)+        {+            return grpcsharp_call_send_status_from_server(call, ctx, statusCode, statusMessage, metadataArray,+                sendEmptyInitialMetadata);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_recv_message(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_recv_message(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_recv_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_recv_initial_metadata(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_start_serverside(CallSafeHandle call,+            BatchContextSafeHandle ctx)+        {+            return grpcsharp_call_start_serverside(call, ctx);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_send_initial_metadata(CallSafeHandle call,+            BatchContextSafeHandle ctx, MetadataArraySafeHandle metadataArray)+        {+            return grpcsharp_call_send_initial_metadata(call, ctx, metadataArray);+        }++        GRPCCallError IPlatformInvocation.grpcsharp_call_set_credentials(CallSafeHandle call,+            CallCredentialsSafeHandle credentials)+        {+            return grpcsharp_call_set_credentials(call, credentials);+        }++        CStringSafeHandle IPlatformInvocation.grpcsharp_call_get_peer(CallSafeHandle call)+        {+            return grpcsharp_call_get_peer(call);+        }++        void IPlatformInvocation.grpcsharp_call_destroy(IntPtr call)+        {+            grpcsharp_call_destroy(call);+        }+++++++        // ChannelArgsSafeHandle ++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelArgsSafeHandle grpcsharp_channel_args_create(UIntPtr numArgs);++        [DllImport(""grpc_csharp_ext-x64.dll"", CharSet = CharSet.Ansi)]+        static extern void grpcsharp_channel_args_set_string(ChannelArgsSafeHandle args, UIntPtr index, string key, string value);++        [DllImport(""grpc_csharp_ext-x64.dll"", CharSet = CharSet.Ansi)]+        static extern void grpcsharp_channel_args_set_integer(ChannelArgsSafeHandle args, UIntPtr index, string key, int value);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_args_destroy(IntPtr args);+++        ChannelArgsSafeHandle IPlatformInvocation.grpcsharp_channel_args_create(UIntPtr numArgs)+        {+            return grpcsharp_channel_args_create(numArgs);+        }++        void IPlatformInvocation.grpcsharp_channel_args_set_string(ChannelArgsSafeHandle args, UIntPtr index, string key,+            string value)+        {+            grpcsharp_channel_args_set_string(args, index, key, value);+        }++        void IPlatformInvocation.grpcsharp_channel_args_set_integer(ChannelArgsSafeHandle args, UIntPtr index,+            string key, int value)+        {+            grpcsharp_channel_args_set_integer(args, index, key, value);+        }++        void IPlatformInvocation.grpcsharp_channel_args_destroy(IntPtr args)+        {+            grpcsharp_channel_args_destroy(args);+        }+++        // ChannelCredentialsSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"", CharSet = CharSet.Ansi)]+        static extern ChannelCredentialsSafeHandle grpcsharp_ssl_credentials_create(string pemRootCerts, string keyCertPairCertChain, string keyCertPairPrivateKey);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelCredentialsSafeHandle grpcsharp_composite_channel_credentials_create(ChannelCredentialsSafeHandle channelCreds, CallCredentialsSafeHandle callCreds);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_credentials_release(IntPtr credentials);++        ChannelCredentialsSafeHandle IPlatformInvocation.grpcsharp_ssl_credentials_create(string pemRootCerts, string keyCertPairCertChain,+            string keyCertPairPrivateKey)+        {+            return grpcsharp_ssl_credentials_create(pemRootCerts, keyCertPairCertChain, keyCertPairPrivateKey);+        }++        ChannelCredentialsSafeHandle IPlatformInvocation.grpcsharp_composite_channel_credentials_create(+            ChannelCredentialsSafeHandle channelCreds, CallCredentialsSafeHandle callCreds)+        {+            return grpcsharp_composite_channel_credentials_create(channelCreds, callCreds);+        }++        void IPlatformInvocation.grpcsharp_channel_credentials_release(IntPtr credentials)+        {+            grpcsharp_channel_credentials_release(credentials);+        }+++        // ChannelSafeHandle+++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelSafeHandle grpcsharp_insecure_channel_create(string target, ChannelArgsSafeHandle channelArgs);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelSafeHandle grpcsharp_secure_channel_create(ChannelCredentialsSafeHandle credentials, string target, ChannelArgsSafeHandle channelArgs);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CallSafeHandle grpcsharp_channel_create_call(ChannelSafeHandle channel, CallSafeHandle parentCall, ContextPropagationFlags propagationMask, CompletionQueueSafeHandle cq, string method, string host, Timespec deadline);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern ChannelState grpcsharp_channel_check_connectivity_state(ChannelSafeHandle channel, int tryToConnect);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_watch_connectivity_state(ChannelSafeHandle channel, ChannelState lastObservedState,+            Timespec deadline, CompletionQueueSafeHandle cq, BatchContextSafeHandle ctx);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CStringSafeHandle grpcsharp_channel_get_target(ChannelSafeHandle call);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_channel_destroy(IntPtr channel);++        ChannelSafeHandle IPlatformInvocation.grpcsharp_insecure_channel_create(string target,+            ChannelArgsSafeHandle channelArgs)+        {+            return grpcsharp_insecure_channel_create(target, channelArgs);+        }++        ChannelSafeHandle IPlatformInvocation.grpcsharp_secure_channel_create(ChannelCredentialsSafeHandle credentials,+            string target, ChannelArgsSafeHandle channelArgs)+        {+            return grpcsharp_secure_channel_create(credentials, target, channelArgs);+        }++        CallSafeHandle IPlatformInvocation.grpcsharp_channel_create_call(ChannelSafeHandle channel,+            CallSafeHandle parentCall, ContextPropagationFlags propagationMask, CompletionQueueSafeHandle cq,+            string method, string host, Timespec deadline)+        {+            return grpcsharp_channel_create_call(channel, parentCall, propagationMask, cq, method, host, deadline);+        }++        ChannelState IPlatformInvocation.grpcsharp_channel_check_connectivity_state(ChannelSafeHandle channel, int tryToConnect)+        {+            return grpcsharp_channel_check_connectivity_state(channel, tryToConnect);+        }++        void IPlatformInvocation.grpcsharp_channel_watch_connectivity_state(ChannelSafeHandle channel,+            ChannelState lastObservedState, Timespec deadline, CompletionQueueSafeHandle cq, BatchContextSafeHandle ctx)+        {+            grpcsharp_channel_watch_connectivity_state(channel, lastObservedState, deadline, cq, ctx);+        }++        CStringSafeHandle IPlatformInvocation.grpcsharp_channel_get_target(ChannelSafeHandle call)+        {+            return grpcsharp_channel_get_target(call);+        }++        void IPlatformInvocation.grpcsharp_channel_destroy(IntPtr channel)+        {+            grpcsharp_channel_destroy(channel);+        }+++        // CompletionQueueEvent++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern int grpcsharp_sizeof_grpc_event();++        int IPlatformInvocation.grpcsharp_sizeof_grpc_event()+        {+            return grpcsharp_sizeof_grpc_event();+        }+++        // CompletionQueueSafeHandle++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CompletionQueueSafeHandle grpcsharp_completion_queue_create();++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_completion_queue_shutdown(CompletionQueueSafeHandle cq);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CompletionQueueEvent grpcsharp_completion_queue_next(CompletionQueueSafeHandle cq);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern CompletionQueueEvent grpcsharp_completion_queue_pluck(CompletionQueueSafeHandle cq, IntPtr tag);++        [DllImport(""grpc_csharp_ext-x64.dll"")]+        static extern void grpcsharp_completion_queue_destroy(IntPtr cq);++        CompletionQueueSafeHandle IPlatformInvocation.grpcsharp_completion_queue_create()+        {+            return grpcsharp_completion_queue_create();+        }++        void IPlatformInvocation.grpcsharp_completion_queue_shutdown(CompletionQueueSafeHandle cq)+        {+            grpcsharp_completion_queue_shutdown(cq);+        }+        CompletionQueueEvent IPlatformInvocation.grpcsharp_completion_queue_next(CompletionQueueSafeHandle cq)+        {+            return grpcsharp_completion_queue_next(cq);+        }++        CompletionQueueEvent IPlatformInvocation.grpcsharp_completion_queue_pluck(CompletionQueueSafeHandle cq,+            IntPtr tag)+        {+            return grpcsharp_completion_queue_pluck(cq, tag);+        }++        void IPlatformInvocation.grpcsharp_completion_queue_destroy(IntPtr cq)+        {+            grpcsharp_completion_queue_destroy(cq);+        }++++        // CStringSafeHandle ++        [DllImport(""grpc_csharp_ext-x64.dll"")]","That would result in less nearly-duplicate code, and you could reduce the number of p/invoke calls this way, although because you still need to inspect the run-time environment, there will still be a need for an abstraction for the different targets.  It's not clear to me if that would be cleaner because DllImport takes care of path resolution (/lib:/usr/lib:..) on linux, etc.. and also takes care of freeing the library, which is internal code that you would need to reproduce.  I wouldn't recommend this because of the move to DNX/CoreCLR.  They seem to be in favor of DllMap, which is a monoism: https://github.com/dotnet/coreclr/issues/930, although that topic spurred a rather large thread which is still unresolved.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/4457,48206295,2015-12-21T23:44:28Z,build.yaml,"@@ -2455,3 +2455,7 @@ node_modules:   - src/node/ext/server.cc   - src/node/ext/server_credentials.cc   - src/node/ext/timeval.cc+python_dependencies:","This should probably be called `python_package` or something, to match the Node and Ruby entries. That will make it clearer if we ever need to list something besides dependencies here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4561,48320300,2015-12-23T03:52:45Z,doc/c-style-guide.md,"@@ -0,0 +1,41 @@+GRPC C STYLE GUIDE+=====================++Background+----------++Here we document style rules for C usage in the gRPC Core library.++General+-------++- Layout rules are defined by clang-format, and all code should be passed through+  clang-format. A (docker-based) script to do so is included in +  tools/distrib/clang_format_code.sh.++Header Files+------------++- Public header files (those in the include/grpc tree) should compile as pedantic C89","So I don't think anyone is at exactly c89, but I don't think the world is all c99 either. Particularly there are wrapping toolkits that don't necessarily provide great implementations of the language, and I'd like to keep it easy for folks using them. Even if parts of the census C api are intended to be used directly from C++, they'll need wrapping for our other six languages, and hopefully whichever languages the community provides wrappings for. Since I can't know all the restrictions that might be imposed, I feel for this part it's important to be as conservative as possible and choose a machine verifiable subset of the language. Pedantic C89 has served us wonderfully there.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/4561,48498233,2015-12-28T18:57:59Z,doc/c-style-guide.md,"@@ -0,0 +1,41 @@+GRPC C STYLE GUIDE+=====================++Background+----------++Here we document style rules for C usage in the gRPC Core library.++General+-------++- Layout rules are defined by clang-format, and all code should be passed through+  clang-format. A (docker-based) script to do so is included in +  tools/distrib/clang_format_code.sh.++Header Files+------------++- Public header files (those in the include/grpc tree) should compile as pedantic C89","Again, I'm very much in favor of keeping the surface API (2 header files really) to the lowest common denominator. Having done some wrapping on a variety of platforms in the past, I very much appreciate a minimalist API in terms of language features.",
13909816,daniel-j-born,https://api.github.com/repos/grpc/grpc/pulls/4555,49148448,2016-01-08T01:05:49Z,src/core/iomgr/tcp_server.h,"@@ -80,4 +80,8 @@ int grpc_tcp_listener_get_port(grpc_tcp_listener *listener); void grpc_tcp_listener_ref(grpc_tcp_listener *listener); void grpc_tcp_listener_unref(grpc_tcp_listener *listener); +/* potentially (trivially) implementable: */+int grpc_tcp_listener_get_fd(grpc_tcp_listener *listener, unsigned index);","Why is there an index parameter? Even if the listener has siblings, I think only the listener->fd should be returned here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4555,49203624,2016-01-08T16:02:22Z,src/core/iomgr/tcp_server.h,"@@ -80,4 +80,8 @@ int grpc_tcp_listener_get_port(grpc_tcp_listener *listener); void grpc_tcp_listener_ref(grpc_tcp_listener *listener); void grpc_tcp_listener_unref(grpc_tcp_listener *listener); +/* potentially (trivially) implementable: */+int grpc_tcp_listener_get_fd(grpc_tcp_listener *listener, unsigned index);","Then the sibling fd's become un-accessible. Given that we create siblingsbecause a single add_port caused multiple listening sockets to be created(due to ipv6 dual stack for example), it seems like a general API wouldneed this.On Thu, Jan 7, 2016 at 5:06 PM Dan Born notifications@github.com wrote:> In src/core/iomgr/tcp_server.h> https://github.com/grpc/grpc/pull/4555#discussion_r49148448:> > > @@ -80,4 +80,8 @@ int grpc_tcp_listener_get_port(grpc_tcp_listener *listener);> >  void grpc_tcp_listener_ref(grpc_tcp_listener *listener);> >  void grpc_tcp_listener_unref(grpc_tcp_listener *listener);> > > > +/\* potentially (trivially) implementable: */> > +int grpc_tcp_listener_get_fd(grpc_tcp_listener *listener, unsigned index);> > Why is there an index parameter? Even if the listener has siblings, I> think only the listener->fd should be returned here.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/4555/files#r49148448.",
13909816,daniel-j-born,https://api.github.com/repos/grpc/grpc/pulls/4555,49239283,2016-01-08T21:19:39Z,src/core/iomgr/tcp_server.h,"@@ -80,4 +80,8 @@ int grpc_tcp_listener_get_port(grpc_tcp_listener *listener); void grpc_tcp_listener_ref(grpc_tcp_listener *listener); void grpc_tcp_listener_unref(grpc_tcp_listener *listener); +/* potentially (trivially) implementable: */+int grpc_tcp_listener_get_fd(grpc_tcp_listener *listener, unsigned index);","It seems like what you are trying for is to have the ""head"" sibling (is_sibling==0) be the exposed API and the others (is_sibling==1) be hidden.This is OK as long as you pass the index and the head sibling to tcp_server_posix.c:on_read and on_accept_cb.",
13909816,daniel-j-born,https://api.github.com/repos/grpc/grpc/pulls/4555,49241876,2016-01-08T21:44:22Z,src/core/iomgr/tcp_server.h,"@@ -80,4 +80,8 @@ int grpc_tcp_listener_get_port(grpc_tcp_listener *listener); void grpc_tcp_listener_ref(grpc_tcp_listener *listener); void grpc_tcp_listener_unref(grpc_tcp_listener *listener); +/* potentially (trivially) implementable: */+int grpc_tcp_listener_get_fd(grpc_tcp_listener *listener, unsigned index);","grpc_tcp_server_get_fd() doesn't index into siblings. I'm not sure that's right.grpc_tcp_listener has a refcount, but is also a singly-linked list node. What do you do when the refcount of a node in the middle of a singly-linked list drops to zero? This can be OK if the grpc_tcp_listener API never access grpc_tcp_listener::next, because grpc_tcp_server owns refs and is the only API that accesses grpc_tcp_listener::next. I just want to double-check that this is intentionally part of the design.If grpc_tcp_server_get_fd() can be made to access all the FDs (including siblings), do we need grpc_tcp_listener_get_fd()? on_accept_cb could take the grpc_tcp_server\* and an index. I'd also consider moving the refcount into the grpc_tcp_server, so grpc_tcp_listener_{ref,unref}() ref the grpc_tcp_server. For example, in the current scheme, the server can be deleted before the listeners so that grpc_tcp_listener::server points to a deleted object.It might be worth taking a step back and rethinking some of the design and API goals.",
13909816,daniel-j-born,https://api.github.com/repos/grpc/grpc/pulls/4555,49257606,2016-01-09T01:36:56Z,src/core/iomgr/tcp_server.h,"@@ -80,4 +80,8 @@ int grpc_tcp_listener_get_port(grpc_tcp_listener *listener); void grpc_tcp_listener_ref(grpc_tcp_listener *listener); void grpc_tcp_listener_unref(grpc_tcp_listener *listener); +/* potentially (trivially) implementable: */+int grpc_tcp_listener_get_fd(grpc_tcp_listener *listener, unsigned index);","The only use I've seen of grpc_tcp_listener in existing code is to get the port. You could have add_port() return the port, and keep listener completely private. For the new stuff, you'd go with my earlier idea of passing the grpc_tcp_server to on_accept_cb with an index and fixing grpc_tcp_server_get_fd().That main thing to do is clarify whether grpc_tcp_listener is private or not. It's sort of stuck in between right now, not completely making sense either way.I could send a pull request showing what this would look like.",
64215,codefromthecrypt,https://api.github.com/repos/grpc/grpc/pulls/4750,50070226,2016-01-19T03:49:02Z,test/core/census/tag_set_test.c,"@@ -0,0 +1,387 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++// Test census_tag_set functions, including encoding/decoding++#include <grpc/census.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <stdbool.h>+#include <stdio.h>+#include <stdlib.h>+#include <string.h>+#include ""test/core/util/test_config.h""++static uint8_t one_byte_val = 7;+static uint32_t four_byte_val = 0x12345678;+static uint64_t eight_byte_val = 0x1234567890abcdef;++// A set of tags Used to create a basic tag_set for testing. Each tag has a+// unique set of flags. Note that replace_add_delete_test() relies on specific+// offsets into this array - if you add or delete entries, you will also need+// to change the test.+#define BASIC_TAG_COUNT 8+static census_tag basic_tags[BASIC_TAG_COUNT] = {+    /* 0 */ {""key0"", ""printable"", 10, 0},+    /* 1 */ {""k1"", ""a"", 2, CENSUS_TAG_PROPAGATE},+    /* 2 */ {""k2"", ""longer printable string"", 24, CENSUS_TAG_STATS},","suggestion: using realistic key and values in tests, especially with flags like CENSUS_TAG_STATS, will teach more people how these are used.",
64215,codefromthecrypt,https://api.github.com/repos/grpc/grpc/pulls/4750,50070710,2016-01-19T04:01:28Z,src/core/census/tag_set.c,"@@ -0,0 +1,530 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+/*+- comment about key/value ptrs being to mem+- add comment about encode/decode being for RPC use only.+*/++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags are encoded seperately from non-binary tags. There are a","Binary tags (share the same struct, but )are encoded seperately from non-binary tags.or similar. When I first read this, I later scrolled up and down to see how they are encoded differently.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/4750,50182622,2016-01-19T21:59:53Z,test/core/census/tag_set_test.c,"@@ -0,0 +1,387 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++// Test census_tag_set functions, including encoding/decoding++#include <grpc/census.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <stdbool.h>+#include <stdio.h>+#include <stdlib.h>+#include <string.h>+#include ""test/core/util/test_config.h""++static uint8_t one_byte_val = 7;+static uint32_t four_byte_val = 0x12345678;+static uint64_t eight_byte_val = 0x1234567890abcdef;++// A set of tags Used to create a basic tag_set for testing. Each tag has a+// unique set of flags. Note that replace_add_delete_test() relies on specific+// offsets into this array - if you add or delete entries, you will also need+// to change the test.+#define BASIC_TAG_COUNT 8+static census_tag basic_tags[BASIC_TAG_COUNT] = {+    /* 0 */ {""key0"", ""printable"", 10, 0},+    /* 1 */ {""k1"", ""a"", 2, CENSUS_TAG_PROPAGATE},+    /* 2 */ {""k2"", ""longer printable string"", 24, CENSUS_TAG_STATS},","I'm later going to add some documentation/examples showing the whole system usage. For now, I think keeping the tests more simple/readable is more important. Some of the things being tested (the corner cases) are definitely not ""recommended usage"", so don't want to set bad examples.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4710,50192726,2016-01-19T23:24:27Z,test/cpp/qps/coresched.h,"@@ -0,0 +1,45 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef TEST_QPS_CORESCHED_H+#define TEST_QPS_CORESCHED_H++#include <vector>","Minor nit: I can't get my brain to read 'core sched' here, instead I always end up at 'co re sched' which makes no sense.Can we rename to (perhaps) limit_cores.h (since that's the only exposed functionality).Down the track I expect we'll want to add an allocator to drive the core selection automatically since hardcoding seems fragile.",
1373887,bogdandrutu,https://api.github.com/repos/grpc/grpc/pulls/4750,50458200,2016-01-21T20:23:37Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,",Do I miss something? You know from the census_tag what kind of tag it is so you just going to delete from there. You should do something similar with what you have in the cts_modify_tag.,
1373887,bogdandrutu,https://api.github.com/repos/grpc/grpc/pulls/4750,50458705,2016-01-21T20:26:30Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len) {+  return (tag_set_delete_tag(&tags->tags[LOCAL_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag->key,+                             key_len));+}++// Add a tag to a tag_set. Return true on sucess, false if the tag could+// not be added because of constraints on tag set size.+static bool tag_set_add_tag(struct tag_set *tags, const census_tag *tag,",What does it happen if the tag already exist? Are you going to duplicate it?,
1373887,bogdandrutu,https://api.github.com/repos/grpc/grpc/pulls/4750,50460979,2016-01-21T20:44:43Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len) {+  return (tag_set_delete_tag(&tags->tags[LOCAL_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag->key,+                             key_len));+}++// Add a tag to a tag_set. Return true on sucess, false if the tag could+// not be added because of constraints on tag set size.+static bool tag_set_add_tag(struct tag_set *tags, const census_tag *tag,+                            size_t key_len) {+  if (tags->ntags == CENSUS_MAX_PROPAGATED_TAGS) {+    return false;+  }+  const size_t tag_size = key_len + tag->value_len + TAG_HEADER_SIZE;+  if (tags->kvm_used + tag_size > tags->kvm_size) {+    // allocate new memory if needed+    tags->kvm_size += 2 * CENSUS_MAX_TAG_KV_LEN + TAG_HEADER_SIZE;+    char *new_kvm = gpr_malloc(tags->kvm_size);+    memcpy(new_kvm, tags->kvm, tags->kvm_used);+    gpr_free(tags->kvm);+    tags->kvm = new_kvm;+  }+  char *kvp = tags->kvm + tags->kvm_used;+  *kvp++ = (char)key_len;+  *kvp++ = (char)tag->value_len;+  // ensure reserved flags are not used.+  *kvp++ = (char)(tag->flags & (CENSUS_TAG_PROPAGATE | CENSUS_TAG_STATS |+                                CENSUS_TAG_BINARY));+  memcpy(kvp, tag->key, key_len);+  kvp += key_len;+  memcpy(kvp, tag->value, tag->value_len);+  tags->kvm_used += tag_size;+  tags->ntags++;+  tags->ntags_alloc++;+  return true;+}++// Add/modify/delete a tag to/in a census_tag_set. Caller must validate that+// tag key etc. are valid.+static void cts_modify_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len,+                           census_tag_set_create_status *status) {+  // First delete the tag if it is already present.+  bool deleted = cts_delete_tag(tags, tag, key_len);+  // Determine if we need to add it back.+  bool call_add = tag->value != NULL && tag->value_len != 0;+  bool added = false;+  if (call_add) {+    if (CENSUS_TAG_IS_PROPAGATED(tag->flags)) {+      if (CENSUS_TAG_IS_BINARY(tag->flags)) {+        added =+            tag_set_add_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag, key_len);+      } else {+        added = tag_set_add_tag(&tags->tags[PROPAGATED_TAGS], tag, key_len);+      }+    } else {+      added = tag_set_add_tag(&tags->tags[LOCAL_TAGS], tag, key_len);+    }+  }+  if (status) {+    if (deleted) {+      if (call_add) {+        status->n_modified_tags++;+      } else {+        status->n_deleted_tags++;+      }+    } else {+      if (added) {+        status->n_added_tags++;+      } else {+        status->n_ignored_tags++;+      }+    }+  }+}++// Remove memory used for deleted tags from the tag set. Basic algorithm:+// 1) Walk through tag set to find first deleted tag. Record where it is.+// 2) Find the next not-deleted tag. Copy all of kvm from there to the end+//    ""over"" the deleted tags+// 3) repeat #1 and #2 until we have seen all tags+// 4) if we are still looking for a not-deleted tag, then all the end portion+//    of the kvm is deleted. Just reduce the used amount of memory by the+//    appropriate amount.+static void tag_set_flatten(struct tag_set *tags) {+  if (tags->ntags == tags->ntags_alloc) return;+  bool find_deleted = true;  // are we looking for deleted tags?+  char *kvp = tags->kvm;+  char *dbase;  // record location of deleted tag+  for (int i = 0; i < tags->ntags_alloc; i++) {+    struct raw_tag tag;+    char *next_kvp = decode_tag(&tag, kvp, 0);+    if (find_deleted) {+      if (CENSUS_TAG_IS_DELETED(tag.flags)) {+        dbase = kvp;+        find_deleted = false;+      }+    } else {+      if (!CENSUS_TAG_IS_DELETED(tag.flags)) {+        ptrdiff_t reduce = kvp - dbase;  // #bytes in deleted tags+        GPR_ASSERT(reduce > 0);+        ptrdiff_t copy_size = tags->kvm + tags->kvm_used - kvp;+        GPR_ASSERT(copy_size > 0);+        memmove(dbase, kvp, (size_t)copy_size);+        tags->kvm_used -= (size_t)reduce;+        next_kvp -= reduce;+        find_deleted = true;+      }+    }+    kvp = next_kvp;+  }+  if (!find_deleted) {+    GPR_ASSERT(dbase > tags->kvm);+    tags->kvm_used = (size_t)(dbase - tags->kvm);+  }+  tags->ntags_alloc = tags->ntags;+}++census_tag_set *census_tag_set_create(const census_tag_set *base,+                                      const census_tag *tags, int ntags,+                                      census_tag_set_create_status *status) {+  int n_invalid_tags = 0;+  if (status) {+    memset(status, 0, sizeof(*status));+  }+  census_tag_set *new_ts = gpr_malloc(sizeof(census_tag_set));+  // If we are given a base, copy it into our new tag set. Otherwise set it+  // to zero/NULL everything.+  if (base == NULL) {+    memset(new_ts, 0, sizeof(census_tag_set));+  } else {+    tag_set_copy(&new_ts->tags[PROPAGATED_TAGS], &base->tags[PROPAGATED_TAGS]);+    tag_set_copy(&new_ts->tags[PROPAGATED_BINARY_TAGS],+                 &base->tags[PROPAGATED_BINARY_TAGS]);+    tag_set_copy(&new_ts->tags[LOCAL_TAGS], &base->tags[LOCAL_TAGS]);+  }+  // Walk over the additional tags and, for those that aren't invalid, modify+  // the tag set to add/replace/delete as required.+  for (int i = 0; i < ntags; i++) {+    const census_tag *tag = &tags[i];+    size_t key_len = strlen(tag->key) + 1;+    // ignore the tag if it is too long/short.+    if (key_len != 1 && key_len <= CENSUS_MAX_TAG_KV_LEN &&+        tag->value_len <= CENSUS_MAX_TAG_KV_LEN) {+      cts_modify_tag(new_ts, tag, key_len, status);+    } else {+      n_invalid_tags++;+    }+  }+  // Remove any deleted tags, update status if needed, and return.+  tag_set_flatten(&new_ts->tags[PROPAGATED_TAGS]);+  tag_set_flatten(&new_ts->tags[PROPAGATED_BINARY_TAGS]);+  tag_set_flatten(&new_ts->tags[LOCAL_TAGS]);+  if (status != NULL) {+    status->n_propagated_tags = new_ts->tags[PROPAGATED_TAGS].ntags;+    status->n_propagated_binary_tags =+        new_ts->tags[PROPAGATED_BINARY_TAGS].ntags;+    status->n_local_tags = new_ts->tags[LOCAL_TAGS].ntags;+    status->n_invalid_tags = n_invalid_tags;+  }+  return new_ts;+}++void census_tag_set_destroy(census_tag_set *tags) {+  gpr_free(tags->tags[PROPAGATED_TAGS].kvm);+  gpr_free(tags->tags[PROPAGATED_BINARY_TAGS].kvm);+  gpr_free(tags->tags[LOCAL_TAGS].kvm);+  gpr_free(tags);+}++int census_tag_set_ntags(const census_tag_set *tags) {+  return tags->tags[PROPAGATED_TAGS].ntags ++         tags->tags[PROPAGATED_BINARY_TAGS].ntags ++         tags->tags[LOCAL_TAGS].ntags;+}++// Initialize a tag set iterator. Must be called before first use of the+// iterator.+void census_tag_set_initialize_iterator(const census_tag_set *tags,+                                        census_tag_set_iterator *iterator) {+  iterator->tags = tags;+  iterator->index = 0;+  if (tags->tags[PROPAGATED_TAGS].ntags != 0) {+    iterator->base = PROPAGATED_TAGS;+    iterator->kvm = tags->tags[PROPAGATED_TAGS].kvm;+  } else if (tags->tags[PROPAGATED_BINARY_TAGS].ntags != 0) {+    iterator->base = PROPAGATED_BINARY_TAGS;+    iterator->kvm = tags->tags[PROPAGATED_BINARY_TAGS].kvm;+  } else if (tags->tags[LOCAL_TAGS].ntags != 0) {+    iterator->base = LOCAL_TAGS;+    iterator->kvm = tags->tags[LOCAL_TAGS].kvm;+  } else {+    iterator->base = -1;+  }+}++// Get the contents of the ""next"" tag in the tag set. If there are no more+// tags in the tag set, returns 0 (and 'tag' contents will be unchanged),+// otherwise returns 1. */+int census_tag_set_next_tag(census_tag_set_iterator *iterator,+                            census_tag *tag) {+  if (iterator->base < 0) {+    return 0;+  }+  struct raw_tag raw;+  iterator->kvm = decode_tag(&raw, iterator->kvm, 0);+  tag->key = raw.key;+  tag->value = raw.value;+  tag->value_len = raw.value_len;+  tag->flags = raw.flags;+  if (++iterator->index == iterator->tags->tags[iterator->base].ntags) {+    do {+      if (iterator->base == LOCAL_TAGS) {+        iterator->base = -1;+        return 1;+      }+    } while (iterator->tags->tags[++iterator->base].ntags == 0);+    iterator->index = 0;+    iterator->kvm = iterator->tags->tags[iterator->base].kvm;+  }+  return 1;+}++// Find a tag in a tag_set by key. Return true if found, false otherwise.+static bool tag_set_get_tag_by_key(const struct tag_set *tags, const char *key,+                                   size_t key_len, census_tag *tag) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags; i++) {+    struct raw_tag raw;+    kvp = decode_tag(&raw, kvp, 0);+    if (key_len == raw.key_len && memcmp(raw.key, key, key_len) == 0) {+      tag->key = raw.key;+      tag->value = raw.value;+      tag->value_len = raw.value_len;+      tag->flags = raw.flags;+      return true;+    }+  }+  return false;+}++int census_tag_set_get_tag_by_key(const census_tag_set *tags, const char *key,+                                  census_tag *tag) {+  size_t key_len = strlen(key) + 1;+  if (key_len == 1) {+    return 0;+  }+  if (tag_set_get_tag_by_key(&tags->tags[PROPAGATED_TAGS], key, key_len, tag) ||+      tag_set_get_tag_by_key(&tags->tags[PROPAGATED_BINARY_TAGS], key, key_len,+                             tag) ||+      tag_set_get_tag_by_key(&tags->tags[LOCAL_TAGS], key, key_len, tag)) {+    return 1;+  }+  return 0;+}++// tag_set encoding and decoding functions.+//+// Wire format for tag sets on the wire:+//+// First, a tag set header:+//+// offset   bytes  description+//   0        1    version number+//   1        1    number of bytes in this header. This allows for future+//                 expansion.+//   2        1    number of bytes in each tag header.+//   3        1    ntags value from tag set.+//+//   This is followed by the key/value memory from struct tag_set.++#define ENCODED_VERSION 0      // Version number+#define ENCODED_HEADER_SIZE 4  // size of tag set header++// Encode a tag set. Returns 0 if buffer is too small.+static size_t tag_set_encode(const struct tag_set *tags, char *buffer,+                             size_t buf_size) {+  if (buf_size < ENCODED_HEADER_SIZE + tags->kvm_used) {+    return 0;+  }+  buf_size -= ENCODED_HEADER_SIZE;+  *buffer++ = (char)ENCODED_VERSION;+  *buffer++ = (char)ENCODED_HEADER_SIZE;+  *buffer++ = (char)TAG_HEADER_SIZE;+  *buffer++ = (char)tags->ntags;+  if (tags->ntags == 0) {+    return ENCODED_HEADER_SIZE;+  }+  memcpy(buffer, tags->kvm, tags->kvm_used);+  return ENCODED_HEADER_SIZE + tags->kvm_used;+}++size_t census_tag_set_encode_propagated(const census_tag_set *tags,",I would suggest to make one function similar with what you have for decode for both binary and non-binary.,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/4750,50465430,2016-01-21T21:17:15Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len) {+  return (tag_set_delete_tag(&tags->tags[LOCAL_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag->key,+                             key_len));+}++// Add a tag to a tag_set. Return true on sucess, false if the tag could+// not be added because of constraints on tag set size.+static bool tag_set_add_tag(struct tag_set *tags, const census_tag *tag,","This is only called by cts_modify_tag(), and only after the tag has been deleted. So, while it may potentially be duplicated, one will be marked as deleted and then really removed in tag_set_flatten().",
1373887,bogdandrutu,https://api.github.com/repos/grpc/grpc/pulls/4750,50501092,2016-01-22T04:25:40Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len) {+  return (tag_set_delete_tag(&tags->tags[LOCAL_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag->key,+                             key_len));+}++// Add a tag to a tag_set. Return true on sucess, false if the tag could+// not be added because of constraints on tag set size.+static bool tag_set_add_tag(struct tag_set *tags, const census_tag *tag,",Sure can you add a comment that this function should not be called with duplicates?,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/4750,50565650,2016-01-22T17:34:15Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.",I think it more likely that the reverse will happen (add a field because the header changed). Have added a longer comment about what needs to change if that happens.,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/4750,50576555,2016-01-22T19:05:35Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len) {+  return (tag_set_delete_tag(&tags->tags[LOCAL_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag->key,+                             key_len));+}++// Add a tag to a tag_set. Return true on sucess, false if the tag could+// not be added because of constraints on tag set size.+static bool tag_set_add_tag(struct tag_set *tags, const census_tag *tag,+                            size_t key_len) {+  if (tags->ntags == CENSUS_MAX_PROPAGATED_TAGS) {+    return false;+  }+  const size_t tag_size = key_len + tag->value_len + TAG_HEADER_SIZE;+  if (tags->kvm_used + tag_size > tags->kvm_size) {+    // allocate new memory if needed+    tags->kvm_size += 2 * CENSUS_MAX_TAG_KV_LEN + TAG_HEADER_SIZE;+    char *new_kvm = gpr_malloc(tags->kvm_size);+    memcpy(new_kvm, tags->kvm, tags->kvm_used);+    gpr_free(tags->kvm);+    tags->kvm = new_kvm;+  }+  char *kvp = tags->kvm + tags->kvm_used;+  *kvp++ = (char)key_len;+  *kvp++ = (char)tag->value_len;+  // ensure reserved flags are not used.+  *kvp++ = (char)(tag->flags & (CENSUS_TAG_PROPAGATE | CENSUS_TAG_STATS |+                                CENSUS_TAG_BINARY));+  memcpy(kvp, tag->key, key_len);+  kvp += key_len;+  memcpy(kvp, tag->value, tag->value_len);+  tags->kvm_used += tag_size;+  tags->ntags++;+  tags->ntags_alloc++;+  return true;+}++// Add/modify/delete a tag to/in a census_tag_set. Caller must validate that+// tag key etc. are valid.+static void cts_modify_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len,+                           census_tag_set_create_status *status) {+  // First delete the tag if it is already present.+  bool deleted = cts_delete_tag(tags, tag, key_len);+  // Determine if we need to add it back.+  bool call_add = tag->value != NULL && tag->value_len != 0;+  bool added = false;+  if (call_add) {+    if (CENSUS_TAG_IS_PROPAGATED(tag->flags)) {+      if (CENSUS_TAG_IS_BINARY(tag->flags)) {+        added =+            tag_set_add_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag, key_len);+      } else {+        added = tag_set_add_tag(&tags->tags[PROPAGATED_TAGS], tag, key_len);+      }+    } else {+      added = tag_set_add_tag(&tags->tags[LOCAL_TAGS], tag, key_len);+    }+  }+  if (status) {+    if (deleted) {+      if (call_add) {+        status->n_modified_tags++;+      } else {+        status->n_deleted_tags++;+      }+    } else {+      if (added) {+        status->n_added_tags++;+      } else {+        status->n_ignored_tags++;+      }+    }+  }+}++// Remove memory used for deleted tags from the tag set. Basic algorithm:+// 1) Walk through tag set to find first deleted tag. Record where it is.+// 2) Find the next not-deleted tag. Copy all of kvm from there to the end+//    ""over"" the deleted tags+// 3) repeat #1 and #2 until we have seen all tags+// 4) if we are still looking for a not-deleted tag, then all the end portion+//    of the kvm is deleted. Just reduce the used amount of memory by the+//    appropriate amount.+static void tag_set_flatten(struct tag_set *tags) {+  if (tags->ntags == tags->ntags_alloc) return;+  bool find_deleted = true;  // are we looking for deleted tags?+  char *kvp = tags->kvm;+  char *dbase;  // record location of deleted tag+  for (int i = 0; i < tags->ntags_alloc; i++) {+    struct raw_tag tag;+    char *next_kvp = decode_tag(&tag, kvp, 0);+    if (find_deleted) {+      if (CENSUS_TAG_IS_DELETED(tag.flags)) {+        dbase = kvp;+        find_deleted = false;+      }+    } else {+      if (!CENSUS_TAG_IS_DELETED(tag.flags)) {+        ptrdiff_t reduce = kvp - dbase;  // #bytes in deleted tags+        GPR_ASSERT(reduce > 0);+        ptrdiff_t copy_size = tags->kvm + tags->kvm_used - kvp;+        GPR_ASSERT(copy_size > 0);+        memmove(dbase, kvp, (size_t)copy_size);+        tags->kvm_used -= (size_t)reduce;+        next_kvp -= reduce;+        find_deleted = true;+      }+    }+    kvp = next_kvp;+  }+  if (!find_deleted) {+    GPR_ASSERT(dbase > tags->kvm);+    tags->kvm_used = (size_t)(dbase - tags->kvm);+  }+  tags->ntags_alloc = tags->ntags;+}++census_tag_set *census_tag_set_create(const census_tag_set *base,+                                      const census_tag *tags, int ntags,+                                      census_tag_set_create_status *status) {+  int n_invalid_tags = 0;+  if (status) {+    memset(status, 0, sizeof(*status));+  }+  census_tag_set *new_ts = gpr_malloc(sizeof(census_tag_set));+  // If we are given a base, copy it into our new tag set. Otherwise set it+  // to zero/NULL everything.+  if (base == NULL) {+    memset(new_ts, 0, sizeof(census_tag_set));+  } else {+    tag_set_copy(&new_ts->tags[PROPAGATED_TAGS], &base->tags[PROPAGATED_TAGS]);+    tag_set_copy(&new_ts->tags[PROPAGATED_BINARY_TAGS],+                 &base->tags[PROPAGATED_BINARY_TAGS]);+    tag_set_copy(&new_ts->tags[LOCAL_TAGS], &base->tags[LOCAL_TAGS]);+  }+  // Walk over the additional tags and, for those that aren't invalid, modify+  // the tag set to add/replace/delete as required.+  for (int i = 0; i < ntags; i++) {+    const census_tag *tag = &tags[i];+    size_t key_len = strlen(tag->key) + 1;+    // ignore the tag if it is too long/short.+    if (key_len != 1 && key_len <= CENSUS_MAX_TAG_KV_LEN &&+        tag->value_len <= CENSUS_MAX_TAG_KV_LEN) {+      cts_modify_tag(new_ts, tag, key_len, status);+    } else {+      n_invalid_tags++;+    }+  }+  // Remove any deleted tags, update status if needed, and return.+  tag_set_flatten(&new_ts->tags[PROPAGATED_TAGS]);+  tag_set_flatten(&new_ts->tags[PROPAGATED_BINARY_TAGS]);+  tag_set_flatten(&new_ts->tags[LOCAL_TAGS]);+  if (status != NULL) {+    status->n_propagated_tags = new_ts->tags[PROPAGATED_TAGS].ntags;+    status->n_propagated_binary_tags =+        new_ts->tags[PROPAGATED_BINARY_TAGS].ntags;+    status->n_local_tags = new_ts->tags[LOCAL_TAGS].ntags;+    status->n_invalid_tags = n_invalid_tags;+  }+  return new_ts;+}++void census_tag_set_destroy(census_tag_set *tags) {+  gpr_free(tags->tags[PROPAGATED_TAGS].kvm);+  gpr_free(tags->tags[PROPAGATED_BINARY_TAGS].kvm);+  gpr_free(tags->tags[LOCAL_TAGS].kvm);+  gpr_free(tags);+}++int census_tag_set_ntags(const census_tag_set *tags) {+  return tags->tags[PROPAGATED_TAGS].ntags ++         tags->tags[PROPAGATED_BINARY_TAGS].ntags ++         tags->tags[LOCAL_TAGS].ntags;+}++// Initialize a tag set iterator. Must be called before first use of the+// iterator.+void census_tag_set_initialize_iterator(const census_tag_set *tags,+                                        census_tag_set_iterator *iterator) {+  iterator->tags = tags;+  iterator->index = 0;+  if (tags->tags[PROPAGATED_TAGS].ntags != 0) {+    iterator->base = PROPAGATED_TAGS;+    iterator->kvm = tags->tags[PROPAGATED_TAGS].kvm;+  } else if (tags->tags[PROPAGATED_BINARY_TAGS].ntags != 0) {+    iterator->base = PROPAGATED_BINARY_TAGS;+    iterator->kvm = tags->tags[PROPAGATED_BINARY_TAGS].kvm;+  } else if (tags->tags[LOCAL_TAGS].ntags != 0) {+    iterator->base = LOCAL_TAGS;+    iterator->kvm = tags->tags[LOCAL_TAGS].kvm;+  } else {+    iterator->base = -1;+  }+}++// Get the contents of the ""next"" tag in the tag set. If there are no more+// tags in the tag set, returns 0 (and 'tag' contents will be unchanged),+// otherwise returns 1. */+int census_tag_set_next_tag(census_tag_set_iterator *iterator,+                            census_tag *tag) {+  if (iterator->base < 0) {+    return 0;+  }+  struct raw_tag raw;+  iterator->kvm = decode_tag(&raw, iterator->kvm, 0);+  tag->key = raw.key;+  tag->value = raw.value;+  tag->value_len = raw.value_len;+  tag->flags = raw.flags;+  if (++iterator->index == iterator->tags->tags[iterator->base].ntags) {+    do {+      if (iterator->base == LOCAL_TAGS) {+        iterator->base = -1;+        return 1;+      }+    } while (iterator->tags->tags[++iterator->base].ntags == 0);+    iterator->index = 0;+    iterator->kvm = iterator->tags->tags[iterator->base].kvm;+  }+  return 1;+}++// Find a tag in a tag_set by key. Return true if found, false otherwise.+static bool tag_set_get_tag_by_key(const struct tag_set *tags, const char *key,+                                   size_t key_len, census_tag *tag) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags; i++) {+    struct raw_tag raw;+    kvp = decode_tag(&raw, kvp, 0);+    if (key_len == raw.key_len && memcmp(raw.key, key, key_len) == 0) {+      tag->key = raw.key;+      tag->value = raw.value;+      tag->value_len = raw.value_len;+      tag->flags = raw.flags;+      return true;+    }+  }+  return false;+}++int census_tag_set_get_tag_by_key(const census_tag_set *tags, const char *key,+                                  census_tag *tag) {+  size_t key_len = strlen(key) + 1;+  if (key_len == 1) {+    return 0;+  }+  if (tag_set_get_tag_by_key(&tags->tags[PROPAGATED_TAGS], key, key_len, tag) ||+      tag_set_get_tag_by_key(&tags->tags[PROPAGATED_BINARY_TAGS], key, key_len,+                             tag) ||+      tag_set_get_tag_by_key(&tags->tags[LOCAL_TAGS], key, key_len, tag)) {+    return 1;+  }+  return 0;+}++// tag_set encoding and decoding functions.+//+// Wire format for tag sets on the wire:+//+// First, a tag set header:+//+// offset   bytes  description+//   0        1    version number+//   1        1    number of bytes in this header. This allows for future+//                 expansion.+//   2        1    number of bytes in each tag header.+//   3        1    ntags value from tag set.+//+//   This is followed by the key/value memory from struct tag_set.++#define ENCODED_VERSION 0      // Version number+#define ENCODED_HEADER_SIZE 4  // size of tag set header++// Encode a tag set. Returns 0 if buffer is too small.+static size_t tag_set_encode(const struct tag_set *tags, char *buffer,+                             size_t buf_size) {+  if (buf_size < ENCODED_HEADER_SIZE + tags->kvm_used) {+    return 0;+  }+  buf_size -= ENCODED_HEADER_SIZE;+  *buffer++ = (char)ENCODED_VERSION;+  *buffer++ = (char)ENCODED_HEADER_SIZE;+  *buffer++ = (char)TAG_HEADER_SIZE;+  *buffer++ = (char)tags->ntags;+  if (tags->ntags == 0) {+    return ENCODED_HEADER_SIZE;+  }+  memcpy(buffer, tags->kvm, tags->kvm_used);+  return ENCODED_HEADER_SIZE + tags->kvm_used;+}++size_t census_tag_set_encode_propagated(const census_tag_set *tags,","What do you think of:/\* Encode a tag set into a buffer. The propagated tags are encoded into the   buffer in two regions: one for printable tags, and one for binary tags.   @param tags tag set to be encoded   @param buffer pointer to buffer. This address will be used to encode the                 printable tags.   @param buf_size pointer to total buffer size. Will be set to total number                   of bytes consumed on output.   @param bin_buf_size on output, will be set to the number of bytes used to                       encode the binary tags.   @return A pointer to the binary tag's encoded, or NULL if the buffer was           insufficiently large to hold the encoded tags. Thus, if successful,           printable tags are encoded into           [buffer, buffer + *buf_size - *bin_buf_size) and binary tags into           [returned-ptr, returned-ptr + *bin_buf_size). */char *census_tag_set_encode(const census_tag_set *tags, char *buffer,                            size_t *buf_size, size_t *bin_buf_size);",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/4750,50579197,2016-01-22T19:26:15Z,src/core/census/tag_set.c,"@@ -0,0 +1,535 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>+#include ""src/core/support/string.h""++// Functions in this file support the public tag_set API, as well as+// encoding/decoding tag_sets as part of context transmission across+// RPC's. The overall requirements (in approximate priority order) for the+// tag_set representations:+// 1. Efficient conversion to/from wire format+// 2. Minimal bytes used on-wire+// 3. Efficient tag set creation+// 4. Efficient lookup of value for a key+// 5. Efficient lookup of value for an index (to support iteration)+// 6. Minimal memory footprint+//+// Notes on tradeoffs/decisions:+// * tag includes 1 byte length of key, as well as nil-terminating byte. These+//   are to aid in efficient parsing and the ability to directly return key+//   strings. This is more important than saving a single byte/tag on the wire.+// * The wire encoding uses only single byte values. This eliminates the need+//   to handle endian-ness conversions. It also means there is a hard upper+//   limit of 255 for both CENSUS_MAX_TAG_KV_LEN and CENSUS_MAX_PROPAGATED_TAGS.+// * Keep all tag information (keys/values/flags) in a single memory buffer,+//   that can be directly copied to the wire. This makes iteration by index+//   somewhat less efficient. If it becomes a problem, we could consider+//   building an index at tag_set creation.+// * Binary tags share the same structure as, but are encoded seperately from,+//   non-binary tags. This is primarily because non-binary tags are far more+//   likely to be repeated across multiple RPC calls, so are more efficiently+//   cached and compressed in any metadata schemes.+// * all lengths etc. are restricted to one byte. This eliminates endian+//   issues.++// Structure representing a set of tags. Essentially a count of number of tags+// present, and pointer to a chunk of memory that contains the per-tag details.+struct tag_set {+  int ntags;        // number of tags.+  int ntags_alloc;  // ntags + number of deleted tags (total number of tags+                    // in all of kvm). This will always be == ntags, except+                    // during the process of building a new tag set.+  size_t kvm_size;  // number of bytes allocated for key/value storage.+  size_t kvm_used;  // number of bytes of used key/value memory+  char *kvm;        // key/value memory. Consists of repeated entries of:+                    //   Offset  Size  Description+                    //     0      1    Key length, including trailing 0. (K)+                    //     1      1    Value length. (V)+                    //     2      1    Flags+                    //     3      K    Key bytes+                    //     3 + K  V    Value bytes+                    //+                    // We refer to the first 3 entries as the 'tag header'.+};++// Number of bytes in tag header.+#define TAG_HEADER_SIZE 3  // key length (1) + value length (1) + flags (1)+// Offsets to tag header entries.+#define KEY_LEN_OFFSET 0+#define VALUE_LEN_OFFSET 1+#define FLAG_OFFSET 2++// raw_tag represents the raw-storage form of a tag in the kvm of a tag_set.+struct raw_tag {+  uint8_t key_len;+  uint8_t value_len;+  uint8_t flags;+  char *key;+  char *value;+};++// Use a reserved flag bit for indication of deleted tag.+#define CENSUS_TAG_DELETED CENSUS_TAG_RESERVED+#define CENSUS_TAG_IS_DELETED(flags) (flags & CENSUS_TAG_DELETED)++// Primary (external) representation of a tag set. Composed of 3 underlying+// tag_set structs, one for each of the binary/printable propagated tags, and+// one for everything else.+struct census_tag_set {+  struct tag_set tags[3];+};++// Indices into the tags member of census_tag_set+#define PROPAGATED_TAGS 0+#define PROPAGATED_BINARY_TAGS 1+#define LOCAL_TAGS 2++// Extract a raw tag given a pointer (raw) to the tag header. Allow for some+// extra bytes in the tag header (see encode/decode functions for usage: this+// allows for future expansion of the tag header).+static char *decode_tag(struct raw_tag *tag, char *header, int offset) {+  tag->key_len = (uint8_t)(*header++);+  tag->value_len = (uint8_t)(*header++);+  tag->flags = (uint8_t)(*header++);+  header += offset;+  tag->key = header;+  header += tag->key_len;+  tag->value = header;+  return header + tag->value_len;+}++// Make a copy (in 'to') of an existing tag_set.+static void tag_set_copy(struct tag_set *to, const struct tag_set *from) {+  memcpy(to, from, sizeof(struct tag_set));+  to->kvm = gpr_malloc(to->kvm_size);+  memcpy(to->kvm, from->kvm, to->kvm_used);+}++// Delete a tag from a tag_set, if it exists (returns true it it did).+static bool tag_set_delete_tag(struct tag_set *tags, const char *key,+                               size_t key_len) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags_alloc; i++) {+    uint8_t *flags = (uint8_t *)(kvp + FLAG_OFFSET);+    struct raw_tag tag;+    kvp = decode_tag(&tag, kvp, 0);+    if (CENSUS_TAG_IS_DELETED(tag.flags)) continue;+    if ((key_len == tag.key_len) && (memcmp(key, tag.key, key_len) == 0)) {+      *flags |= CENSUS_TAG_DELETED;+      tags->ntags--;+      return true;+    }+  }+  return false;+}++// Delete a tag from a census_tag_set, return true if it existed.+static bool cts_delete_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len) {+  return (tag_set_delete_tag(&tags->tags[LOCAL_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_TAGS], tag->key, key_len) ||+          tag_set_delete_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag->key,+                             key_len));+}++// Add a tag to a tag_set. Return true on sucess, false if the tag could+// not be added because of constraints on tag set size.+static bool tag_set_add_tag(struct tag_set *tags, const census_tag *tag,+                            size_t key_len) {+  if (tags->ntags == CENSUS_MAX_PROPAGATED_TAGS) {+    return false;+  }+  const size_t tag_size = key_len + tag->value_len + TAG_HEADER_SIZE;+  if (tags->kvm_used + tag_size > tags->kvm_size) {+    // allocate new memory if needed+    tags->kvm_size += 2 * CENSUS_MAX_TAG_KV_LEN + TAG_HEADER_SIZE;+    char *new_kvm = gpr_malloc(tags->kvm_size);+    memcpy(new_kvm, tags->kvm, tags->kvm_used);+    gpr_free(tags->kvm);+    tags->kvm = new_kvm;+  }+  char *kvp = tags->kvm + tags->kvm_used;+  *kvp++ = (char)key_len;+  *kvp++ = (char)tag->value_len;+  // ensure reserved flags are not used.+  *kvp++ = (char)(tag->flags & (CENSUS_TAG_PROPAGATE | CENSUS_TAG_STATS |+                                CENSUS_TAG_BINARY));+  memcpy(kvp, tag->key, key_len);+  kvp += key_len;+  memcpy(kvp, tag->value, tag->value_len);+  tags->kvm_used += tag_size;+  tags->ntags++;+  tags->ntags_alloc++;+  return true;+}++// Add/modify/delete a tag to/in a census_tag_set. Caller must validate that+// tag key etc. are valid.+static void cts_modify_tag(census_tag_set *tags, const census_tag *tag,+                           size_t key_len,+                           census_tag_set_create_status *status) {+  // First delete the tag if it is already present.+  bool deleted = cts_delete_tag(tags, tag, key_len);+  // Determine if we need to add it back.+  bool call_add = tag->value != NULL && tag->value_len != 0;+  bool added = false;+  if (call_add) {+    if (CENSUS_TAG_IS_PROPAGATED(tag->flags)) {+      if (CENSUS_TAG_IS_BINARY(tag->flags)) {+        added =+            tag_set_add_tag(&tags->tags[PROPAGATED_BINARY_TAGS], tag, key_len);+      } else {+        added = tag_set_add_tag(&tags->tags[PROPAGATED_TAGS], tag, key_len);+      }+    } else {+      added = tag_set_add_tag(&tags->tags[LOCAL_TAGS], tag, key_len);+    }+  }+  if (status) {+    if (deleted) {+      if (call_add) {+        status->n_modified_tags++;+      } else {+        status->n_deleted_tags++;+      }+    } else {+      if (added) {+        status->n_added_tags++;+      } else {+        status->n_ignored_tags++;+      }+    }+  }+}++// Remove memory used for deleted tags from the tag set. Basic algorithm:+// 1) Walk through tag set to find first deleted tag. Record where it is.+// 2) Find the next not-deleted tag. Copy all of kvm from there to the end+//    ""over"" the deleted tags+// 3) repeat #1 and #2 until we have seen all tags+// 4) if we are still looking for a not-deleted tag, then all the end portion+//    of the kvm is deleted. Just reduce the used amount of memory by the+//    appropriate amount.+static void tag_set_flatten(struct tag_set *tags) {+  if (tags->ntags == tags->ntags_alloc) return;+  bool find_deleted = true;  // are we looking for deleted tags?+  char *kvp = tags->kvm;+  char *dbase;  // record location of deleted tag+  for (int i = 0; i < tags->ntags_alloc; i++) {+    struct raw_tag tag;+    char *next_kvp = decode_tag(&tag, kvp, 0);+    if (find_deleted) {+      if (CENSUS_TAG_IS_DELETED(tag.flags)) {+        dbase = kvp;+        find_deleted = false;+      }+    } else {+      if (!CENSUS_TAG_IS_DELETED(tag.flags)) {+        ptrdiff_t reduce = kvp - dbase;  // #bytes in deleted tags+        GPR_ASSERT(reduce > 0);+        ptrdiff_t copy_size = tags->kvm + tags->kvm_used - kvp;+        GPR_ASSERT(copy_size > 0);+        memmove(dbase, kvp, (size_t)copy_size);+        tags->kvm_used -= (size_t)reduce;+        next_kvp -= reduce;+        find_deleted = true;+      }+    }+    kvp = next_kvp;+  }+  if (!find_deleted) {+    GPR_ASSERT(dbase > tags->kvm);+    tags->kvm_used = (size_t)(dbase - tags->kvm);+  }+  tags->ntags_alloc = tags->ntags;+}++census_tag_set *census_tag_set_create(const census_tag_set *base,+                                      const census_tag *tags, int ntags,+                                      census_tag_set_create_status *status) {+  int n_invalid_tags = 0;+  if (status) {+    memset(status, 0, sizeof(*status));+  }+  census_tag_set *new_ts = gpr_malloc(sizeof(census_tag_set));+  // If we are given a base, copy it into our new tag set. Otherwise set it+  // to zero/NULL everything.+  if (base == NULL) {+    memset(new_ts, 0, sizeof(census_tag_set));+  } else {+    tag_set_copy(&new_ts->tags[PROPAGATED_TAGS], &base->tags[PROPAGATED_TAGS]);+    tag_set_copy(&new_ts->tags[PROPAGATED_BINARY_TAGS],+                 &base->tags[PROPAGATED_BINARY_TAGS]);+    tag_set_copy(&new_ts->tags[LOCAL_TAGS], &base->tags[LOCAL_TAGS]);+  }+  // Walk over the additional tags and, for those that aren't invalid, modify+  // the tag set to add/replace/delete as required.+  for (int i = 0; i < ntags; i++) {+    const census_tag *tag = &tags[i];+    size_t key_len = strlen(tag->key) + 1;+    // ignore the tag if it is too long/short.+    if (key_len != 1 && key_len <= CENSUS_MAX_TAG_KV_LEN &&+        tag->value_len <= CENSUS_MAX_TAG_KV_LEN) {+      cts_modify_tag(new_ts, tag, key_len, status);+    } else {+      n_invalid_tags++;+    }+  }+  // Remove any deleted tags, update status if needed, and return.+  tag_set_flatten(&new_ts->tags[PROPAGATED_TAGS]);+  tag_set_flatten(&new_ts->tags[PROPAGATED_BINARY_TAGS]);+  tag_set_flatten(&new_ts->tags[LOCAL_TAGS]);+  if (status != NULL) {+    status->n_propagated_tags = new_ts->tags[PROPAGATED_TAGS].ntags;+    status->n_propagated_binary_tags =+        new_ts->tags[PROPAGATED_BINARY_TAGS].ntags;+    status->n_local_tags = new_ts->tags[LOCAL_TAGS].ntags;+    status->n_invalid_tags = n_invalid_tags;+  }+  return new_ts;+}++void census_tag_set_destroy(census_tag_set *tags) {+  gpr_free(tags->tags[PROPAGATED_TAGS].kvm);+  gpr_free(tags->tags[PROPAGATED_BINARY_TAGS].kvm);+  gpr_free(tags->tags[LOCAL_TAGS].kvm);+  gpr_free(tags);+}++int census_tag_set_ntags(const census_tag_set *tags) {+  return tags->tags[PROPAGATED_TAGS].ntags ++         tags->tags[PROPAGATED_BINARY_TAGS].ntags ++         tags->tags[LOCAL_TAGS].ntags;+}++// Initialize a tag set iterator. Must be called before first use of the+// iterator.+void census_tag_set_initialize_iterator(const census_tag_set *tags,+                                        census_tag_set_iterator *iterator) {+  iterator->tags = tags;+  iterator->index = 0;+  if (tags->tags[PROPAGATED_TAGS].ntags != 0) {+    iterator->base = PROPAGATED_TAGS;+    iterator->kvm = tags->tags[PROPAGATED_TAGS].kvm;+  } else if (tags->tags[PROPAGATED_BINARY_TAGS].ntags != 0) {+    iterator->base = PROPAGATED_BINARY_TAGS;+    iterator->kvm = tags->tags[PROPAGATED_BINARY_TAGS].kvm;+  } else if (tags->tags[LOCAL_TAGS].ntags != 0) {+    iterator->base = LOCAL_TAGS;+    iterator->kvm = tags->tags[LOCAL_TAGS].kvm;+  } else {+    iterator->base = -1;+  }+}++// Get the contents of the ""next"" tag in the tag set. If there are no more+// tags in the tag set, returns 0 (and 'tag' contents will be unchanged),+// otherwise returns 1. */+int census_tag_set_next_tag(census_tag_set_iterator *iterator,+                            census_tag *tag) {+  if (iterator->base < 0) {+    return 0;+  }+  struct raw_tag raw;+  iterator->kvm = decode_tag(&raw, iterator->kvm, 0);+  tag->key = raw.key;+  tag->value = raw.value;+  tag->value_len = raw.value_len;+  tag->flags = raw.flags;+  if (++iterator->index == iterator->tags->tags[iterator->base].ntags) {+    do {+      if (iterator->base == LOCAL_TAGS) {+        iterator->base = -1;+        return 1;+      }+    } while (iterator->tags->tags[++iterator->base].ntags == 0);+    iterator->index = 0;+    iterator->kvm = iterator->tags->tags[iterator->base].kvm;+  }+  return 1;+}++// Find a tag in a tag_set by key. Return true if found, false otherwise.+static bool tag_set_get_tag_by_key(const struct tag_set *tags, const char *key,+                                   size_t key_len, census_tag *tag) {+  char *kvp = tags->kvm;+  for (int i = 0; i < tags->ntags; i++) {+    struct raw_tag raw;+    kvp = decode_tag(&raw, kvp, 0);+    if (key_len == raw.key_len && memcmp(raw.key, key, key_len) == 0) {+      tag->key = raw.key;+      tag->value = raw.value;+      tag->value_len = raw.value_len;+      tag->flags = raw.flags;+      return true;+    }+  }+  return false;+}++int census_tag_set_get_tag_by_key(const census_tag_set *tags, const char *key,+                                  census_tag *tag) {+  size_t key_len = strlen(key) + 1;+  if (key_len == 1) {+    return 0;+  }+  if (tag_set_get_tag_by_key(&tags->tags[PROPAGATED_TAGS], key, key_len, tag) ||+      tag_set_get_tag_by_key(&tags->tags[PROPAGATED_BINARY_TAGS], key, key_len,+                             tag) ||+      tag_set_get_tag_by_key(&tags->tags[LOCAL_TAGS], key, key_len, tag)) {+    return 1;+  }+  return 0;+}++// tag_set encoding and decoding functions.+//+// Wire format for tag sets on the wire:+//+// First, a tag set header:+//+// offset   bytes  description+//   0        1    version number+//   1        1    number of bytes in this header. This allows for future+//                 expansion.+//   2        1    number of bytes in each tag header.+//   3        1    ntags value from tag set.+//+//   This is followed by the key/value memory from struct tag_set.++#define ENCODED_VERSION 0      // Version number+#define ENCODED_HEADER_SIZE 4  // size of tag set header++// Encode a tag set. Returns 0 if buffer is too small.+static size_t tag_set_encode(const struct tag_set *tags, char *buffer,+                             size_t buf_size) {+  if (buf_size < ENCODED_HEADER_SIZE + tags->kvm_used) {+    return 0;+  }+  buf_size -= ENCODED_HEADER_SIZE;+  *buffer++ = (char)ENCODED_VERSION;+  *buffer++ = (char)ENCODED_HEADER_SIZE;+  *buffer++ = (char)TAG_HEADER_SIZE;+  *buffer++ = (char)tags->ntags;+  if (tags->ntags == 0) {+    return ENCODED_HEADER_SIZE;+  }+  memcpy(buffer, tags->kvm, tags->kvm_used);+  return ENCODED_HEADER_SIZE + tags->kvm_used;+}++size_t census_tag_set_encode_propagated(const census_tag_set *tags,","Or a second tweak/variation:/\* Encode a tag set into a buffer. The propagated tags are encoded into the   buffer in two regions: one for printable tags, and one for binary tags.   @param tags tag set to be encoded   @param buffer pointer to buffer. This address will be used to encode the                 printable tags.   @param buf_size On input, will be a pointer to total buffer size. On output,                   will be set to total number of bytes consumed by printable                   tags.   @param bin_buf_size on output, will be set to the number of bytes used to                       encode the binary tags.   @return A pointer to the binary tag's encoded, or NULL if the buffer was           insufficiently large to hold the encoded tags. Thus, if successful,           printable tags are encoded into           [buffer, buffer + *buf_size) and binary tags into           [returned-ptr, returned-ptr + *bin_buf_size) (and the return value           should be buffer + *buf_size) */char *census_tag_set_encode(const census_tag_set *tags, char *buffer,                            size_t *buf_size, size_t *bin_buf_size);I think this is a bit cleaner. Will do this unless you have some other suggestion.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4884,50866377,2016-01-26T17:13:03Z,src/python/grpcio/commands.py,"@@ -58,6 +63,117 @@ class CommandError(Exception):   """"""Simple exception class for GRPC custom commands.""""""  +# TODO(atash): Remove this once PyPI has better Linux bdist support+def _linux_target_egg_name(grpc_version):+  """"""Get gRPC's custom made-up target names for Linux.""""""+  assert sys.platform.startswith('linux')+  version = '.'.join(map(str, sys.version_info[0:2]))","How about naming this field `python_version`, just to be extra clear?Also would its value be more accessibly expressed as `'{}.{}'.format(sys.version_info[0], sys.version_info[1])`? I'm not actually sure; it's up to you.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4884,50867081,2016-01-26T17:17:52Z,src/python/grpcio/commands.py,"@@ -58,6 +63,117 @@ class CommandError(Exception):   """"""Simple exception class for GRPC custom commands.""""""  +# TODO(atash): Remove this once PyPI has better Linux bdist support+def _linux_target_egg_name(grpc_version):+  """"""Get gRPC's custom made-up target names for Linux.""""""+  assert sys.platform.startswith('linux')+  version = '.'.join(map(str, sys.version_info[0:2]))+  architecture = platform.machine()+  flavor = 'ucs2' if sys.maxunicode == 65535 else 'ucs4'+  return (+      'grpcio-{grpc_version}-py{version}-linux-{architecture}-{flavor}.egg'+        .format(grpc_version=grpc_version,+                version=version,+                architecture=architecture,+                flavor=flavor))+++class Install(install.install):+  """"""Custom Install command for gRPC Python.++  This is for bdist shims and whatever else we might need a custom install+  command for.+  """"""++  user_options = install.install.user_options + [+      # TODO(atash): remove this once manylinux gets on PyPI+      ('use-linux-bdist', None,+       'Whether to retrieve a binary for Linux instead of building from '+       'source.'),+  ]++  def initialize_options(self):+    install.install.initialize_options(self)+    self.use_linux_bdist = False++  def finalize_options(self):+    install.install.finalize_options(self)++  def run(self):+    if self.use_linux_bdist:+      try:+        egg_path = self._get_linux_bdist_egg()+      except CommandError as error:+        sys.stderr.write(+            '\nWARNING: Failed to acquire grpcio prebuilt binary:\n'+            '{}.\n\n'.format(error.message))+        raise+      try:+        self._run_bdist_retrieval_install(egg_path)+      except KeyboardInterrupt:","I don't think this is necessary; `KeyboardInterrupt` and `Exception` are mutually exclusive. I think I may have given mistaken guidance in a code review a few weeks ago when what I really should have advised at the time was ""avoid catching `Exception` unless you're really sure that you mean to catch things like programming defects as well as the exceptions the code under catch is documented to raise"".",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4884,50867625,2016-01-26T17:21:41Z,src/python/grpcio/commands.py,"@@ -58,6 +63,117 @@ class CommandError(Exception):   """"""Simple exception class for GRPC custom commands.""""""  +# TODO(atash): Remove this once PyPI has better Linux bdist support+def _linux_target_egg_name(grpc_version):+  """"""Get gRPC's custom made-up target names for Linux.""""""+  assert sys.platform.startswith('linux')+  version = '.'.join(map(str, sys.version_info[0:2]))+  architecture = platform.machine()+  flavor = 'ucs2' if sys.maxunicode == 65535 else 'ucs4'+  return (+      'grpcio-{grpc_version}-py{version}-linux-{architecture}-{flavor}.egg'+        .format(grpc_version=grpc_version,+                version=version,+                architecture=architecture,+                flavor=flavor))+++class Install(install.install):+  """"""Custom Install command for gRPC Python.++  This is for bdist shims and whatever else we might need a custom install+  command for.+  """"""++  user_options = install.install.user_options + [+      # TODO(atash): remove this once manylinux gets on PyPI+      ('use-linux-bdist', None,+       'Whether to retrieve a binary for Linux instead of building from '+       'source.'),+  ]++  def initialize_options(self):+    install.install.initialize_options(self)+    self.use_linux_bdist = False++  def finalize_options(self):+    install.install.finalize_options(self)++  def run(self):+    if self.use_linux_bdist:+      try:+        egg_path = self._get_linux_bdist_egg()+      except CommandError as error:+        sys.stderr.write(+            '\nWARNING: Failed to acquire grpcio prebuilt binary:\n'+            '{}.\n\n'.format(error.message))+        raise+      try:+        self._run_bdist_retrieval_install(egg_path)+      except KeyboardInterrupt:+        raise+      except Exception as error:+        # if anything else happens (and given how there's no way to really know+        # what's happening in setuptools here, I mean *anything*), warn the user+        # and fall back to building from source.+        sys.stderr.write(+            '{}\nWARNING: Failed to install grpcio prebuilt binary.\n\n'+                .format(traceback.format_exc()))+        install.install.run(self)+    else:+      install.install.run(self)++  # TODO(atash): Remove this once PyPI has better Linux bdist support+  def _run_bdist_retrieval_install(self, bdist_egg):+    easy_install = self.distribution.get_command_class('easy_install')+    easy_install_command = easy_install(+        self.distribution, args='x', root=self.root, record=self.record,+    )+    easy_install_command.ensure_finalized()+    easy_install_command.always_copy_from = '.'+    easy_install_command.package_index.scan(glob.glob('*.egg'))+    arguments = [bdist_egg]+    if setuptools.bootstrap_install_from:+      args.insert(0, setuptools.bootstrap_install_from)+    easy_install_command.args = arguments++    easy_install_command.run()+    setuptools.bootstrap_install_from = None++  # TODO(atash): Remove this once PyPI has better Linux bdist support+  def _get_linux_bdist_egg(self):","By changing ""self"" to ""distribution"" (or ""version""), you can pull this helper behavior out of the class without increasing its parameter count.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4884,51046613,2016-01-27T20:41:37Z,src/python/grpcio/commands.py,"@@ -58,6 +63,117 @@ class CommandError(Exception):   """"""Simple exception class for GRPC custom commands.""""""  +def _egg_name(self, decorated):","Don't use ""self"" as a parameter name unless writing an instance method.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4884,51046759,2016-01-27T20:42:58Z,src/python/grpcio/commands.py,"@@ -58,6 +63,117 @@ class CommandError(Exception):   """"""Simple exception class for GRPC custom commands.""""""  +def _egg_name(self, decorated):+  """"""+  Args:+    decorated: Boolean describing whether or not to decorate the egg name with+      custom gRPC-specific target information.+  """"""+  egg_command = self.get_finalized_command('bdist_egg')+  base = os.path.splitext(os.path.basename(egg_command.egg_output))[0]+  if decorated:+    flavor = 'ucs2' if sys.maxunicode == 65535 else 'ucs4'+    return '{base}-{flavor}'.format(base=base, flavor=flavor)+  else:+    return base++# TODO(atash): Remove this once PyPI has better Linux bdist support. See+# https://bitbucket.org/pypa/pypi/issues/120/binary-wheels-for-linux-are-not-supported+def _get_linux_bdist_egg(decorated_basename, target_egg_basename):+  """"""Returns a string path to a .egg file for Linux to install.++  If we can retrieve a pre-compiled egg from online, uses it. Else, emits a+  warning and builds from source.+  """"""+  # Break import style to ensure that setup.py has had a chance to install the+  # relevant package eggs.+  from six.moves.urllib import request+  decorated_path = decorated_basename + '.egg'+  try:+    url = (+        'https://storage.googleapis.com/grpc-precompiled-binaries/'+        'python/{target}'+            .format(target=decorated_path))+    egg_data = request.urlopen(url).read()+  except IOError as error:+    raise CommandError(+        '{}\n\nCould not find the bdist egg {}: {}'+            .format(traceback.format_exc(), decorated_path, error.message))+  # Our chosen local egg path.+  egg_path = target_egg_basename + '.egg'+  try:+    with open(egg_path, 'w') as egg_file:+      egg_file.write(egg_data)+  except IOError as error:+    raise CommandError(+        '{}\n\nCould not write grpcio egg: {}'+            .format(traceback.format_exc(), error.message))+  return egg_path+++class Install(install.install):+  """"""Custom Install command for gRPC Python.++  This is for bdist shims and whatever else we might need a custom install+  command for.+  """"""++  user_options = install.install.user_options + [+      # TODO(atash): remove this once manylinux gets on PyPI. See+      # https://bitbucket.org/pypa/pypi/issues/120/binary-wheels-for-linux-are-not-supported+      ('use-linux-bdist', None,+       'Whether to retrieve a binary for Linux instead of building from '+       'source.'),+  ]++  def initialize_options(self):+    install.install.initialize_options(self)+    self.use_linux_bdist = False++  def finalize_options(self):+    install.install.finalize_options(self)++  def run(self):+    if self.use_linux_bdist:+      try:+        egg_path = _get_linux_bdist_egg(_egg_name(self, True),","Always resist passing ""self"" as a parameter when making a call. You could pass `self.get_finalized_command`? Or you could pass `self.get_finalized_command('bdist_egg')`?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/4884,51069091,2016-01-27T23:41:01Z,src/python/grpcio/commands.py,"@@ -58,6 +65,129 @@ class CommandError(Exception):   """"""Simple exception class for GRPC custom commands.""""""  +# TODO(atash): Remove this once PyPI has better Linux bdist support. See+# https://bitbucket.org/pypa/pypi/issues/120/binary-wheels-for-linux-are-not-supported+def _get_linux_bdist_egg(decorated_basename, target_egg_basename):+  """"""Returns a string path to a .egg file for Linux to install.++  If we can retrieve a pre-compiled egg from online, uses it. Else, emits a+  warning and builds from source.+  """"""+  # Break import style to ensure that setup.py has had a chance to install the+  # relevant package eggs.+  from six.moves.urllib import request+  decorated_path = decorated_basename + '.egg'+  try:+    url = (+        'https://storage.googleapis.com/grpc-precompiled-binaries/'+        'python/{target}'+            .format(target=decorated_path))+    egg_data = request.urlopen(url).read()+  except IOError as error:+    raise CommandError(+        '{}\n\nCould not find the bdist egg {}: {}'+            .format(traceback.format_exc(), decorated_path, error.message))+  # Our chosen local egg path.+  egg_path = target_egg_basename + '.egg'+  try:+    with open(egg_path, 'w') as egg_file:+      egg_file.write(egg_data)+  except IOError as error:+    raise CommandError(+        '{}\n\nCould not write grpcio egg: {}'+            .format(traceback.format_exc(), error.message))+  return egg_path+++class EggNameMixin(object):",Missing class doc string - in particular a mixin class should identify _with what_ it must be mixed to be used correctly.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4929,51070824,2016-01-27T23:59:39Z,include/grpc/grpc_security.h,"@@ -143,6 +143,16 @@ grpc_channel_credentials *grpc_google_default_credentials_create(void); #define GRPC_DEFAULT_SSL_ROOTS_FILE_PATH_ENV_VAR \   ""GRPC_DEFAULT_SSL_ROOTS_FILE_PATH"" +/* Overrides the default path for TLS/SSL roots.+   The path must point to a PEM encoded file with all the roots such as the one+   that can be downloaded from https://pki.google.com/roots.pem.+   This function is not thread-safe and must be called at initialization time+   before any ssl credentials are created to have the desired side effect.+   It also does not do any checks about the validity or contents of the path.+   If the GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment is set, it will override+   the roots_path specified in this function. */+void grpc_override_ssl_default_roots_file_path(const char *roots_path);","Right. Windows (at least) has a way of storing data alongside code that'snot in the file system.On Wed, Jan 27, 2016 at 3:58 PM jboeuf notifications@github.com wrote:> In include/grpc/grpc_security.h> https://github.com/grpc/grpc/pull/4929#discussion_r51070613:> > > @@ -143,6 +143,16 @@ grpc_channel_credentials *grpc_google_default_credentials_create(void);> >  #define GRPC_DEFAULT_SSL_ROOTS_FILE_PATH_ENV_VAR \> >    ""GRPC_DEFAULT_SSL_ROOTS_FILE_PATH""> > > > +/\* Overrides the default path for TLS/SSL roots.> > -   The path must point to a PEM encoded file with all the roots such as the one> > -   that can be downloaded from https://pki.google.com/roots.pem.> > -   This function is not thread-safe and must be called at initialization time> > -   before any ssl credentials are created to have the desired side effect.> > -   It also does not do any checks about the validity or contents of the path.> > -   If the GRPC_DEFAULT_SSL_ROOTS_FILE_PATH environment is set, it will override> > -   the roots_path specified in this function. */> >   +void grpc_override_ssl_default_roots_file_path(const char *roots_path);> > so that would be more:> > void grpc_override_ssl_default_roots(const char *roots_pem);> > i..e it's not a file anymore, it's the pem string directly, right?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/4929/files#r51070613.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4933,51173924,2016-01-28T19:29:52Z,src/core/transport/chttp2/stream_lists.c,"@@ -313,12 +313,26 @@ int grpc_chttp2_list_pop_check_read_ops(   return r; } -void grpc_chttp2_list_add_stalled_by_transport(+void grpc_chttp2_list_add_writing_stalled_by_transport(     grpc_chttp2_transport_writing *transport_writing,     grpc_chttp2_stream_writing *stream_writing) {   stream_list_add(TRANSPORT_FROM_WRITING(transport_writing),                   STREAM_FROM_WRITING(stream_writing),-                  GRPC_CHTTP2_LIST_STALLED_BY_TRANSPORT);+                  GRPC_CHTTP2_LIST_WRITING_STALLED_BY_TRANSPORT);+}++void grpc_chttp2_list_flush_writing_stalled_by_transport(+    grpc_chttp2_transport_writing *transport_writing) {","Suggest:``` cvoid grpc_chttp2_list_flush_writing_stalled_by_transport(grpc_chttp2_transport_writing *transport_writing, bool is_window_available);```and move the `transport_writing->outgoing_window > 0` check into writing.c, to avoid flow control logic creeping into the list management code.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/4965,51302404,2016-01-29T19:15:39Z,include/grpc/impl/codegen/port_platform.h,"@@ -337,4 +337,16 @@   } while (0) #endif /* GPR_FORBID_UNREACHABLE_CODE */ ","I think we want a bit more meat here. Probably something along these lines:```#ifdef GPR_WIN32#  ifdef GRPC_DLL#    if GRPC_BUILD_LIBRARY#      define CENSUS_API __declspec(dllexport)#      define GPR_API __declspec(dllexport)#      define GRPC_API __declspec(dllexport)#    else#      define CENSUS_API __declspec(dllimport)#      define GPR_API __declspec(dllimport)#      define GRPC_API __declspec(dllimport)#    endif#  else#    define CENSUS_API#    define GPR_API#    define GRPC_API#  endif#else /* !GPR_WIN32 */... what you currently have#endif```Bottom-line, when building grpc from the Makefile or the Visual Studio project for its ""dynamic"" version, we `-DGRPC_BUILD_LIBRARY=1` and `-DGRPC_DLL=1`, and people who want to use grpc as a DLL compile their code with `-DGRPC_DLL`. This an extremely common way of handling this:https://github.com/madler/zlib/blob/master/zconf.h#L312",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/4971,51337976,2016-01-30T02:05:27Z,src/ruby/ext/grpc/rb_grpc_imports.h,"@@ -0,0 +1,399 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_RB_GRPC_IMPORTS_H_+#define GRPC_RB_GRPC_IMPORTS_H_++#include <include/grpc/census.h>+#include <include/grpc/compression.h>+#include <include/grpc/grpc.h>+#include <include/grpc/grpc_security.h>+","Alright, I give up. There's something wrong here, and I don't know what.If one runs the script plugin manually, he'd get the following extract:```- {arguments: grpc_byte_buffer_reader *reader, header: include/grpc/impl/codegen/byte_buffer.h,  name: grpc_byte_buffer_reader_readall, return_type: gpr_slice}- {arguments: grpc_byte_buffer_reader *reader, header: include/grpc/impl/codegen/byte_buffer.h,  name: grpc_raw_byte_buffer_from_reader, return_type: grpc_byte_buffer *}- {arguments: gpr_slice s, header: include/grpc/impl/codegen/slice.h, name: gpr_slice_ref,  return_type: gpr_slice}```These files and functions are clearly not represented in here however. So something is wrong with the way the plugin works in regards to listing the necessary public APIs.With its name, it should be running after `expand_filegroups.py` however, as we are sorting them by name.So... I am brain farting too much to figure out what's going on.",
1834192,kriswuollett,https://api.github.com/repos/grpc/grpc/pulls/4985,51485118,2016-02-01T21:40:57Z,examples/objective-c/helloworld/main.m,"@@ -42,6 +43,7 @@ int main(int argc, char * argv[]) {   @autoreleasepool {     [GRPCCall useInsecureConnectionsForHost:kHostAddress];+    [GRPCCall usePrimaryUserAgent:@""HelloWorld/1.0"" forHost:kHostAddress];",Sure that makes more sense -- I'll take off the forHost: parameter.,
1834192,kriswuollett,https://api.github.com/repos/grpc/grpc/pulls/4985,51485580,2016-02-01T21:43:38Z,src/objective-c/GRPCClient/GRPCCall+ChannelArg.h,"@@ -0,0 +1,52 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+#import ""GRPCCall.h""++/**+ * Methods to configure GRPC channel options for specific hosts.+ */+@interface GRPCCall (ChannelArg)++/**+ * Use the provided @c primaryUserAgent at the beginning of the HTTP User Agent string for the+ * provided @c host.+ */++ (void)usePrimaryUserAgent:(NSString *)primaryUserAgent forHost:(NSString *)host;++/**+ * Use the provided @c secondaryUserAgent at the end of the HTTP User Agent string for the+ * provided @c host.+ */++ (void)useSecondaryUserAgent:(NSString *)secondaryUserAgent forHost:(NSString *)host;","Sure, let's just use one for now.  I thought it was safer for the first pass at this to use the same naming as the gRPC internals.  Would calling it `userAgentPrefix` be more descriptive than `applicationUserAgent` then?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/4985,51488960,2016-02-01T22:06:18Z,src/objective-c/GRPCClient/GRPCCall+ChannelArg.h,"@@ -0,0 +1,52 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+#import ""GRPCCall.h""++/**+ * Methods to configure GRPC channel options for specific hosts.+ */+@interface GRPCCall (ChannelArg)++/**+ * Use the provided @c primaryUserAgent at the beginning of the HTTP User Agent string for the+ * provided @c host.+ */++ (void)usePrimaryUserAgent:(NSString *)primaryUserAgent forHost:(NSString *)host;++/**+ * Use the provided @c secondaryUserAgent at the end of the HTTP User Agent string for the+ * provided @c host.+ */++ (void)useSecondaryUserAgent:(NSString *)secondaryUserAgent forHost:(NSString *)host;","All public surface we add, we'll have to keep until a future hypothetical gRPC version 2, so it's safer to err on the minimalist side. Plus I'm very biased in favor of making the common use cases as simple as possible.I'm cool with either name for the property :)",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5012,51639969,2016-02-02T21:40:10Z,tools/run_tests/distribtest_targets.py,"@@ -81,10 +81,49 @@ def __str__(self):     return self.name  +class PythonDistribTest:","Missing inheritance from `object`, right?",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/4958,51640140,2016-02-02T21:41:25Z,test/cpp/end2end/end2end_test.cc,"@@ -218,8 +226,39 @@ class TestServiceImpl : public ::grpc::testing::EchoTestService::Service {   explicit TestServiceImpl(const grpc::string& host)",Sorry I was talking about the implementation of this class was moved to a separate file: https://github.com/grpc/grpc/blob/master/test/cpp/end2end/test_service_impl.cc. Is it possible to make the new changes there and use that?,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/4958,51643228,2016-02-02T22:02:31Z,test/cpp/end2end/end2end_test.cc,"@@ -218,8 +226,39 @@ class TestServiceImpl : public ::grpc::testing::EchoTestService::Service {   explicit TestServiceImpl(const grpc::string& host)","hmm..this is weird..I see that you did move TestServiceImpl to a separate file in SHA: d6f7d99dc6551 but somehow, in the latest mater, it is back in end2end_test.cchttps://github.com/grpc/grpc/blob/master/test/cpp/end2end/end2end_test.ccI guess that is why I was confused :). I am trying to see where this got added back but so far couldn't trace it (git blame on end2end_test.cc isn't helping either)..",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/4958,51644300,2016-02-02T22:10:20Z,test/cpp/end2end/end2end_test.cc,"@@ -218,8 +226,39 @@ class TestServiceImpl : public ::grpc::testing::EchoTestService::Service {   explicit TestServiceImpl(const grpc::string& host)","Ah, I think I know which one caused it. Let me try to fix it soon.On Tue, Feb 2, 2016 at 2:02 PM, Sree Kuchibhotla notifications@github.comwrote:> In test/cpp/end2end/end2end_test.cc> https://github.com/grpc/grpc/pull/4958#discussion_r51643228:> > > @@ -218,8 +226,39 @@ class TestServiceImpl : public ::grpc::testing::EchoTestService::Service {> >    explicit TestServiceImpl(const grpc::string& host)> > hmm..this is weird..I see that you did move TestServiceImpl to a separate> file in SHA: d6f7d99> https://github.com/grpc/grpc/commit/d6f7d99dc655151f3705b816de5fdac7011acc87> but somehow, in the latest mater, it is back in end2end_test.cc> > https://github.com/grpc/grpc/blob/master/test/cpp/end2end/end2end_test.cc> > I guess that is why I was confused :). I am trying to see where this got> added back but so far couldn't trace it (git blame on end2end_test.cc isn't> helping either)..> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/4958/files#r51643228.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/5030,51688100,2016-02-03T07:47:22Z,src/python/grpcio/grpc/_cython/loader.c,"@@ -0,0 +1,73 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#if GPR_WIN32","You removed the inclusion to port_platform.h. So GPR_WIN32 isn't defined, that condition is false, and you're skipping the whole windows loading code to fallback to the default ""yay everything is fine"" at the bottom. That's why you're segfaulting. You haven't loaded anything, all of your symbols are NULL.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5030,51783900,2016-02-03T20:42:56Z,src/python/grpcio/grpc/_cython/loader.h,"@@ -0,0 +1,45 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef PYGRPC_LOADER_H_+#define PYGRPC_LOADER_H_++#include ""imports.generated.h""++/* Additional inclusions not covered by ""imports.generated.h"" */+#include <grpc/byte_buffer_reader.h>",(responded to offline)Summary: wanted to keep all the header inclusions used by the extension library in one place; `loader.h` seemed like a decent place to keep it that way. Will add explanatory comment later.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/4985,51784856,2016-02-03T20:50:37Z,src/objective-c/GRPCClient/private/GRPCChannel.m,"@@ -33,22 +33,121 @@  #import ""GRPCChannel.h"" -#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h> -@implementation GRPCChannel+/**+ * Returns @c grpc_channel_credentials from the specifie @c path. If the file at the path could not+ * be read then NULL is returned.  If NULL is returned, @c errorPtr may not be NULL if there are+ * details available describing what went wrong.+ */+static grpc_channel_credentials *CertificatesAtPath(NSString *path, NSError **errorPtr) {+  // Files in PEM format can have non-ASCII characters in their comments (e.g. for the name of the+  // issuer). Load them as UTF8 and produce an ASCII equivalent.+  NSString *contentInUTF8 = [NSString stringWithContentsOfFile:path+                                                      encoding:NSUTF8StringEncoding+                                                         error:errorPtr];+  NSData *contentInASCII = [contentInUTF8 dataUsingEncoding:NSASCIIStringEncoding+                                       allowLossyConversion:YES];+  if (!contentInASCII.bytes) {+    // Passing NULL to grpc_ssl_credentials_create produces behavior we don't want, so return.+    return NULL;+  }+  return grpc_ssl_credentials_create(contentInASCII.bytes, NULL, NULL);+}++void freeChannelArgs(grpc_channel_args *channel_args) {+  for (size_t i = 0; i < channel_args->num_args; ++i) {+    grpc_arg *arg = &channel_args->args[i];+    gpr_free(arg->key);+    if (arg->type == GRPC_ARG_STRING) {+      gpr_free(arg->value.string);+    }+  }+  gpr_free(channel_args);+}++/**+ * Allocates a @c grpc_channel_args and populates it with the options specified in the+ * @c dictionary. Keys must be @c NSString.  If the value responds to @c @selector(UTF8String) then+ * it will be mapped to @c GRPC_ARG_STRING.  If not, it will be mapped to @c GRPC_ARG_INTEGER if the+ * value responds to @c @selector(intValue).  Otherwise, an exception will be raised.+ */+grpc_channel_args * buildChannelArgs(NSDictionary *dictionary) {+  if (!dictionary) {+    return NULL;+  }++  NSArray *keys = [dictionary allKeys];+  NSUInteger argCount = [keys count];++  grpc_channel_args *channelArgs = gpr_malloc(sizeof(grpc_channel_args));+  channelArgs->num_args = argCount;+  channelArgs->args = gpr_malloc(argCount * sizeof(grpc_arg));++  // TODO(kriswuollett) Check that keys adhere to GRPC core library requirements++  Class invalidValueType = NULL;++  for (NSUInteger i = 0; i < argCount; ++i) {+    grpc_arg *arg = &channelArgs->args[i];+    arg->key = gpr_strdup([keys[i] UTF8String]);++    id value = dictionary[keys[i]];+    if ([value respondsToSelector:@selector(UTF8String)]) {+      arg->type = GRPC_ARG_STRING;+      arg->value.string = gpr_strdup([value UTF8String]);+    } else if ([value respondsToSelector:@selector(intValue)]) {+      arg->type = GRPC_ARG_INTEGER;+      arg->value.integer = [value intValue];+    } else {+      invalidValueType = [value class];+      break;+    }+  }++  if (invalidValueType) {+    freeChannelArgs(channelArgs);","Recovering from an exception isn't expected, so there's no need to go out of our way to clean up here.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5047,51797337,2016-02-03T22:20:51Z,tools/run_tests/run_interop_tests.py,"@@ -422,12 +422,18 @@ def _job_kill_handler(job):     time.sleep(2)  -def cloud_to_prod_jobspec(language, test_case, docker_image=None, auth=False):+def cloud_to_prod_jobspec(language, test_case, use_cloud_gateway=False, ","If   using cloud gateway only means changing the server_host, we shouldn't  hard code the feature like this.  It is concievable you'll want to add more possible backends in the future and you really don't want to hand-code a boolean parameter for each of these.",
1834192,kriswuollett,https://api.github.com/repos/grpc/grpc/pulls/4985,51814863,2016-02-04T00:59:12Z,src/objective-c/GRPCClient/private/GRPCChannel.m,"@@ -33,22 +33,121 @@  #import ""GRPCChannel.h"" -#include <grpc/grpc.h>+#include <grpc/grpc_security.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h> -@implementation GRPCChannel+/**+ * Returns @c grpc_channel_credentials from the specifie @c path. If the file at the path could not+ * be read then NULL is returned.  If NULL is returned, @c errorPtr may not be NULL if there are+ * details available describing what went wrong.+ */+static grpc_channel_credentials *CertificatesAtPath(NSString *path, NSError **errorPtr) {+  // Files in PEM format can have non-ASCII characters in their comments (e.g. for the name of the+  // issuer). Load them as UTF8 and produce an ASCII equivalent.+  NSString *contentInUTF8 = [NSString stringWithContentsOfFile:path+                                                      encoding:NSUTF8StringEncoding+                                                         error:errorPtr];+  NSData *contentInASCII = [contentInUTF8 dataUsingEncoding:NSASCIIStringEncoding+                                       allowLossyConversion:YES];+  if (!contentInASCII.bytes) {+    // Passing NULL to grpc_ssl_credentials_create produces behavior we don't want, so return.+    return NULL;+  }+  return grpc_ssl_credentials_create(contentInASCII.bytes, NULL, NULL);+}++void freeChannelArgs(grpc_channel_args *channel_args) {+  for (size_t i = 0; i < channel_args->num_args; ++i) {+    grpc_arg *arg = &channel_args->args[i];+    gpr_free(arg->key);+    if (arg->type == GRPC_ARG_STRING) {+      gpr_free(arg->value.string);+    }+  }+  gpr_free(channel_args);+}++/**+ * Allocates a @c grpc_channel_args and populates it with the options specified in the+ * @c dictionary. Keys must be @c NSString.  If the value responds to @c @selector(UTF8String) then+ * it will be mapped to @c GRPC_ARG_STRING.  If not, it will be mapped to @c GRPC_ARG_INTEGER if the+ * value responds to @c @selector(intValue).  Otherwise, an exception will be raised.+ */+grpc_channel_args * buildChannelArgs(NSDictionary *dictionary) {+  if (!dictionary) {+    return NULL;+  }++  NSArray *keys = [dictionary allKeys];+  NSUInteger argCount = [keys count];++  grpc_channel_args *channelArgs = gpr_malloc(sizeof(grpc_channel_args));+  channelArgs->num_args = argCount;+  channelArgs->args = gpr_malloc(argCount * sizeof(grpc_arg));++  // TODO(kriswuollett) Check that keys adhere to GRPC core library requirements++  Class invalidValueType = NULL;++  for (NSUInteger i = 0; i < argCount; ++i) {+    grpc_arg *arg = &channelArgs->args[i];+    arg->key = gpr_strdup([keys[i] UTF8String]);++    id value = dictionary[keys[i]];+    if ([value respondsToSelector:@selector(UTF8String)]) {+      arg->type = GRPC_ARG_STRING;+      arg->value.string = gpr_strdup([value UTF8String]);+    } else if ([value respondsToSelector:@selector(intValue)]) {+      arg->type = GRPC_ARG_INTEGER;+      arg->value.integer = [value intValue];+    } else {+      invalidValueType = [value class];+      break;+    }+  }++  if (invalidValueType) {+    freeChannelArgs(channelArgs);","Ok, cool. Removed the special handling and am just raising the exception within the loop.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/5057,51824338,2016-02-04T03:10:19Z,src/python/grpcio/grpc/_cython/_cygrpc/grpc.pxi,"@@ -28,15 +28,20 @@ # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  cimport libc.time-from libc.stdint cimport int64_t, uint32_t, int32_t  -cdef extern from ""grpc/support/alloc.h"":+cdef extern from ""grpc/_cython/loader.h"":++  ctypedef int int32_t+  ctypedef unsigned uint32_t+  ctypedef long int64_t","Is this a cython thing? Because ""long"" is 32 bits on Windows. ",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/5078,51956219,2016-02-04T23:35:15Z,binding.gyp,"@@ -78,7 +79,8 @@           # supports ALPN. The target is ""[major].[minor].[patch]"". We split by           # periods and take the first field to get the major version.         'defines': [-          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)'+          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)',+          'GPR_BACKWARDS_COMPATIBILITY_MODE'","I just want to point out that you're doing this in both the ""if"" case and ""else"" case of a conditional expression.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5078,51960192,2016-02-05T00:21:17Z,binding.gyp,"@@ -78,7 +79,8 @@           # supports ALPN. The target is ""[major].[minor].[patch]"". We split by           # periods and take the first field to get the major version.         'defines': [-          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)'+          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)',+          'GPR_BACKWARDS_COMPATIBILITY_MODE'","I get that :)Wasn't sure what the syntax was for 'always'On Thu, Feb 4, 2016, 3:35 PM Michael Lumish notifications@github.comwrote:> In binding.gyp> https://github.com/grpc/grpc/pull/5078#discussion_r51956219:> > > @@ -78,7 +79,8 @@> >            # supports ALPN. The target is ""[major].[minor].[patch]"". We split by> >            # periods and take the first field to get the major version.> >          'defines': [> > -          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)'> > -          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)',> > -          'GPR_BACKWARDS_COMPATIBILITY_MODE'> > I just want to point out that you're doing this in both the ""if"" case and> ""else"" case of a conditional expression.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5078/files#r51956219.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5078,51960501,2016-02-05T00:25:04Z,binding.gyp,"@@ -78,7 +79,8 @@           # supports ALPN. The target is ""[major].[minor].[patch]"". We split by           # periods and take the first field to get the major version.         'defines': [-          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)'+          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)',+          'GPR_BACKWARDS_COMPATIBILITY_MODE'","Masood: everything is good currently, and will be after this PR for LinuxPython. We don't want to use the binary compatibility hacks with other ccore builds, and those by caller are going to be more than the wrappedlanguages.So... The default for c core being binary backwards compatible needs tochange (which it is here), and each wrapped language needs to be tweaked toset the now non default option.On Thu, Feb 4, 2016, 4:21 PM Craig Tiller ctiller@google.com wrote:> I get that :)> > Wasn't sure what the syntax was for 'always'> > On Thu, Feb 4, 2016, 3:35 PM Michael Lumish notifications@github.com> wrote:> > > In binding.gyp> > https://github.com/grpc/grpc/pull/5078#discussion_r51956219:> > > > > @@ -78,7 +79,8 @@> > >            # supports ALPN. The target is ""[major].[minor].[patch]"". We split by> > >            # periods and take the first field to get the major version.> > >          'defines': [> > > -          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)'> > > -          'TSI_OPENSSL_ALPN_SUPPORT=<!(echo <(target) | cut -d. -f1)',> > > -          'GPR_BACKWARDS_COMPATIBILITY_MODE'> > > > I just want to point out that you're doing this in both the ""if"" case and> > ""else"" case of a conditional expression.> > > > —> > Reply to this email directly or view it on GitHub> > https://github.com/grpc/grpc/pull/5078/files#r51956219.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/4985,52067872,2016-02-05T20:22:46Z,src/objective-c/GRPCClient/GRPCCall+ChannelArg.m,"@@ -31,20 +31,21 @@  *  */ -#import ""GRPCUnsecuredChannel.h""+#import ""GRPCCall+ChannelArg.h"" -#include <grpc/grpc.h>+#import ""private/GRPCHost.h"" -@implementation GRPCUnsecuredChannel+@implementation GRPCCall (ChannelArg) -- (instancetype)initWithHost:(NSString *)host {-  return (self = [super initWithChannel:grpc_insecure_channel_create(host.UTF8String, NULL, NULL)]);-}+static NSString *_userAgentPrefix;",This variable is dead now. Sorry that I didn't notice when I sent you that addition.,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/5118,52111539,2016-02-07T02:36:26Z,tools/gce/linux_worker_init.sh,"@@ -0,0 +1,70 @@+#!/bin/bash+# Copyright 2015-2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# Initializes a fresh GCE VM to become a jenkins linux worker.+# You shouldn't run this script on your own, use create_linux_worker.sh+# instead.++set -ex++sudo apt-get update++# Install JRE+sudo apt-get install -y openjdk-7-jre+sudo apt-get install -y unzip lsof++# Install Docker+curl -sSL https://get.docker.com/ | sh++# Setup jenkins user (or the user will already exist bcuz magic)+sudo adduser jenkins --disabled-password || true++# Enable jenkins to use docker without sudo:+sudo usermod -aG docker jenkins++# Use ""overlay"" storage driver for docker+# see https://github.com/grpc/grpc/issues/4988+echo 'DOCKER_OPTS=""${DOCKER_OPTS} --storage-driver=overlay""' | sudo tee --append /etc/default/docker++# Install RVM+# TODO(jtattermusch): why is RVM needed?","The ruby builder, basically. There's in fact no need to have a dedicated machine for that. That's the only dependency I'd need for it.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5121,52235831,2016-02-08T22:19:50Z,templates/tools/dockerfile/test/csharp_jessie_x64/Dockerfile.template,"@@ -0,0 +1,36 @@+%YAML 1.2+--- |+  # Copyright 2015-2016, Google Inc.+  # All rights reserved.+  #+  # Redistribution and use in source and binary forms, with or without+  # modification, are permitted provided that the following conditions are+  # met:+  #+  #     * Redistributions of source code must retain the above copyright+  # notice, this list of conditions and the following disclaimer.+  #     * Redistributions in binary form must reproduce the above+  # copyright notice, this list of conditions and the following disclaimer+  # in the documentation and/or other materials provided with the+  # distribution.+  #     * Neither the name of Google Inc. nor the names of its+  # contributors may be used to endorse or promote products derived from+  # this software without specific prior written permission.+  #+  # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+  # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+  # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+  # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+  # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+  # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+  # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+  # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+  # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+  # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+  # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+  +  FROM debian:jessie+  +  <%include file=""../../apt_get_basic.include""/>+  <%include file=""../../csharp_deps.include""/>+  <%include file=""../../run_tests_addons.include""/>","Suggest swapping these two lines (and similarly in all the Dockerfiles), and putting the `CMD [""bash""]` explicitly at the end of each Dockerfile.Reasoning:- maximizes cache sharing between Dockerfiles- removes strict ordering requirements on include order",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5151,52328767,2016-02-09T16:06:28Z,tools/run_tests/artifact_targets.py,"@@ -62,7 +62,7 @@ def create_jobspec(name, cmdline, environ=None, shell=False,           cmdline=cmdline,           environ=environ,           shortname='build_artifact.%s' % (name),-          timeout_seconds=10*60,+          timeout_seconds=15*60,","It's probably safe to write None here for artifact building: There's unlikely a case where this gets deadlocked (as there is when we're running unit tests), and so it'll prevent us having to tweak numbers going forward.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5190,52549916,2016-02-11T00:26:58Z,tools/run_tests/pre_build_node.bat,"@@ -0,0 +1,39 @@+@rem Copyright 2016, Google Inc.+@rem All rights reserved.+@rem+@rem Redistribution and use in source and binary forms, with or without+@rem modification, are permitted provided that the following conditions are+@rem met:+@rem+@rem     * Redistributions of source code must retain the above copyright+@rem notice, this list of conditions and the following disclaimer.+@rem     * Redistributions in binary form must reproduce the above+@rem copyright notice, this list of conditions and the following disclaimer+@rem in the documentation and/or other materials provided with the+@rem distribution.+@rem     * Neither the name of Google Inc. nor the names of its+@rem contributors may be used to endorse or promote products derived from+@rem this software without specific prior written permission.+@rem+@rem THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+@rem ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+@rem LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+@rem A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+@rem OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+@rem SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+@rem LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+@rem DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+@rem THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+@rem (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+@rem OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++@rem Expire cache after 1 week+npm update --cache-min 604800++npm install node-gyp-install+.\node_modules\.bin\node-gyp-install.cmd++@rem delete the redundant openssl headers+for /f ""delims=v"" %%v in ('node --version') do (+  rmdir ""%HOMEDRIVE%%HOMEPATH%\.node-gyp\%%v\include\node\openssl"" /S /Q","we will eventually need to figure out how to make this work without touching stuff in user's homedir, as this will almost certainly cause flakiness (we will definitely have situations where we have more parallel runs on the same worker).For now, I think this is fine.",
1373887,bogdandrutu,https://api.github.com/repos/grpc/grpc/pulls/5098,52564118,2016-02-11T04:45:11Z,src/core/census/log.c,"@@ -0,0 +1,610 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* Available log space is divided up in blocks of+   CENSUS_LOG_2_MAX_RECORD_SIZE bytes. A block can be in one of the+   following three data structures:+   - Free blocks (free_block_list)+   - Blocks with unread data (dirty_block_list)+   - Blocks currently attached to cores (core_local_blocks[])++   census_log_start_write() moves a block from core_local_blocks[] to the+   end of dirty_block_list when block:+   - is out-of-space OR+   - has an incomplete record (an incomplete record occurs when a thread calls+     census_log_start_write() and is context-switched before calling+     census_log_end_write()+   So, blocks in dirty_block_list are ordered, from oldest to newest, by time+   when block is detached from the core.++   census_log_read_next() first iterates over dirty_block_list and then+   core_local_blocks[]. It moves completely read blocks from dirty_block_list+   to free_block_list. Blocks in core_local_blocks[] are not freed, even when+   completely read.++   If log is configured to discard old records and free_block_list is empty,+   census_log_start_write() iterates over dirty_block_list to allocate a+   new block. It moves the oldest available block (no pending read/write) to+   core_local_blocks[].++   core_local_block_struct is used to implement a map from core id to the block+   associated with that core. This mapping is advisory. It is possible that the+   block returned by this mapping is no longer associated with that core. This+   mapping is updated, lazily, by census_log_start_write().++   Locking in block struct:++   Exclusive g_log.lock must be held before calling any functions operatong on+   block structs except census_log_start_write() and+   census_log_end_write().++   Writes to a block are serialized via writer_lock.+   census_log_start_write() acquires this lock and+   census_log_end_write() releases it. On failure to acquire the lock,+   writer allocates a new block for the current core and updates+   core_local_block accordingly.++   Simultaneous read and write access is allowed. Readers can safely read up to+   committed bytes (bytes_committed).++   reader_lock protects the block, currently being read, from getting recycled.+   start_read() acquires reader_lock and end_read() releases the lock.++   Read/write access to a block is disabled via try_disable_access(). It returns+   with both writer_lock and reader_lock held. These locks are subsequently+   released by enable_access() to enable access to the block.++   A note on naming: Most function/struct names are prepended by cl_+   (shorthand for census_log). Further, functions that manipulate structures+   include the name of the structure, which will be passed as the first+   argument. E.g. cl_block_initialize() will initialize a cl_block.+*/++#include ""src/core/census/log.h""+#include <grpc/support/alloc.h>+#include <grpc/support/atm.h>+#include <grpc/support/cpu.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <string.h>++/* End of platform specific code */++typedef struct census_log_block_list_struct {+  struct census_log_block_list_struct* next;+  struct census_log_block_list_struct* prev;+  struct census_log_block* block;+} cl_block_list_struct;++typedef struct census_log_block {+  /* Pointer to underlying buffer */+  char* buffer;+  gpr_atm writer_lock;+  gpr_atm reader_lock;+  /* Keeps completely written bytes. Declared atomic because accessed+     simultaneously by reader and writer. */+  gpr_atm bytes_committed;+  /* Bytes already read */+  size_t bytes_read;+  /* Links for list */+  cl_block_list_struct link;+/* We want this structure to be cacheline aligned. We assume the following+   sizes for the various parts on 32/64bit systems:+   type                 32b size    64b size+   char*                   4           8+   3x gpr_atm             12          24+   size_t                  4           8+   cl_block_list_struct   12          24+   TOTAL                  32          64++   Depending on the size of our cacheline and the architecture, we+   selectively add char buffering to this structure. The size is checked+   via assert in census_log_initialize(). */+#if defined(GPR_ARCH_64)+#define CL_BLOCK_PAD_SIZE (GPR_CACHELINE_SIZE - 64)+#else+#if defined(GPR_ARCH_32)+#define CL_BLOCK_PAD_SIZE (GPR_CACHELINE_SIZE - 32)+#else+#error ""Unknown architecture""+#endif+#endif+#if CL_BLOCK_PAD_SIZE > 0+  char padding[CL_BLOCK_PAD_SIZE];+#endif+} cl_block;++/* A list of cl_blocks, doubly-linked through cl_block::link. */+typedef struct census_log_block_list {+  int32_t count;           /* Number of items in list. */+  cl_block_list_struct ht; /* head/tail of linked list. */+} cl_block_list;++/* Cacheline aligned block pointers to avoid false sharing. Block pointer must+   be initialized via set_block(), before calling other functions */+typedef struct census_log_core_local_block {+  gpr_atm block;+/* Ensure cachline alignment: we assume sizeof(gpr_atm) == 4 or 8 */+#if defined(GPR_ARCH_64)+#define CL_CORE_LOCAL_BLOCK_PAD_SIZE (GPR_CACHELINE_SIZE - 8)+#else+#if defined(GPR_ARCH_32)+#define CL_CORE_LOCAL_BLOCK_PAD_SIZE (GPR_CACHELINE_SIZE - 4)+#else+#error ""Unknown architecture""+#endif+#endif+#if CL_CORE_LOCAL_BLOCK_PAD_SIZE > 0+  char padding[CL_CORE_LOCAL_BLOCK_PAD_SIZE];+#endif+} cl_core_local_block;++struct census_log {+  int discard_old_records;+  /* Number of cores (aka hardware-contexts) */+  unsigned num_cores;+  /* number of CENSUS_LOG_2_MAX_RECORD_SIZE blocks in log */+  uint32_t num_blocks;+  cl_block* blocks;                       /* Block metadata. */+  cl_core_local_block* core_local_blocks; /* Keeps core to block mappings. */+  gpr_mu lock;+  int initialized; /* has log been initialized? */+  /* Keeps the state of the reader iterator. A value of 0 indicates that+     iterator has reached the end. census_log_init_reader() resets the+     value to num_core to restart iteration. */+  uint32_t read_iterator_state;+  /* Points to the block being read. If non-NULL, the block is locked for+     reading (block_being_read_->reader_lock is held). */+  cl_block* block_being_read;+  /* A non-zero value indicates that log is full. */+  gpr_atm is_full;+  char* buffer;+  cl_block_list free_block_list;+  cl_block_list dirty_block_list;+  gpr_atm out_of_space_count;+};++/* Single internal log */+static struct census_log g_log;++/* Functions that operate on an atomic memory location used as a lock */++/* Returns non-zero if lock is acquired */+static int cl_try_lock(gpr_atm* lock) { return gpr_atm_acq_cas(lock, 0, 1); }++static void cl_unlock(gpr_atm* lock) { gpr_atm_rel_store(lock, 0); }++/* Functions that operate on cl_core_local_block's */++static void cl_core_local_block_set_block(cl_core_local_block* clb,+                                          cl_block* block) {+  gpr_atm_rel_store(&clb->block, (gpr_atm)block);+}++static cl_block* cl_core_local_block_get_block(cl_core_local_block* clb) {+  return (cl_block*)gpr_atm_acq_load(&clb->block);+}++/* Functions that operate on cl_block_list_struct's */++static void cl_block_list_struct_initialize(cl_block_list_struct* bls,+                                            cl_block* block) {+  bls->next = bls->prev = bls;+  bls->block = block;+}++/* Functions that operate on cl_block_list's */++static void cl_block_list_initialize(cl_block_list* list) {+  list->count = 0;+  cl_block_list_struct_initialize(&list->ht, NULL);+}++/* Returns head of *this, or NULL if empty. */+static cl_block* cl_block_list_head(cl_block_list* list) {+  return list->ht.next->block;+}++/* Insert element *e after *pos. */+static void cl_block_list_insert(cl_block_list* list, cl_block_list_struct* pos,+                                 cl_block_list_struct* e) {+  list->count++;+  e->next = pos->next;+  e->prev = pos;+  e->next->prev = e;+  e->prev->next = e;+}++/* Insert block at the head of the list */+static void cl_block_list_insert_at_head(cl_block_list* list, cl_block* block) {+  cl_block_list_insert(list, &list->ht, &block->link);+}++/* Insert block at the tail of the list */+static void cl_block_list_insert_at_tail(cl_block_list* list, cl_block* block) {+  cl_block_list_insert(list, list->ht.prev, &block->link);+}++/* Removes block *b. Requires *b be in the list. */+static void cl_block_list_remove(cl_block_list* list, cl_block* b) {+  list->count--;+  b->link.next->prev = b->link.prev;+  b->link.prev->next = b->link.next;+}++/* Functions that operate on cl_block's */++static void cl_block_initialize(cl_block* block, char* buffer) {+  block->buffer = buffer;+  gpr_atm_rel_store(&block->writer_lock, 0);+  gpr_atm_rel_store(&block->reader_lock, 0);+  gpr_atm_rel_store(&block->bytes_committed, 0);+  block->bytes_read = 0;+  cl_block_list_struct_initialize(&block->link, block);+}++/* Guards against exposing partially written buffer to the reader. */+static void cl_block_set_bytes_committed(cl_block* block,+                                         size_t bytes_committed) {+  gpr_atm_rel_store(&block->bytes_committed, (gpr_atm)bytes_committed);+}++static size_t cl_block_get_bytes_committed(cl_block* block) {+  return (size_t)gpr_atm_acq_load(&block->bytes_committed);+}++/* Tries to disable future read/write access to this block. Succeeds if:+   - no in-progress write AND+   - no in-progress read AND+   - 'discard_data' set to true OR no unread data+   On success, clears the block state and returns with writer_lock_ and+   reader_lock_ held. These locks are released by a subsequent+   cl_block_access_enable() call. */+static bool cl_block_try_disable_access(cl_block* block, int discard_data) {+  if (!cl_try_lock(&block->writer_lock)) {+    return false;+  }+  if (!cl_try_lock(&block->reader_lock)) {+    cl_unlock(&block->writer_lock);+    return false;+  }+  if (!discard_data &&+      (block->bytes_read != cl_block_get_bytes_committed(block))) {+    cl_unlock(&block->reader_lock);+    cl_unlock(&block->writer_lock);+    return false;+  }+  cl_block_set_bytes_committed(block, 0);+  block->bytes_read = 0;+  return true;+}++static void cl_block_enable_access(cl_block* block) {+  cl_unlock(&block->reader_lock);+  cl_unlock(&block->writer_lock);+}++/* Returns with writer_lock held. */+static void* cl_block_start_write(cl_block* block, size_t size) {+  size_t bytes_committed;+  if (!cl_try_lock(&block->writer_lock)) {+    return NULL;+  }+  bytes_committed = cl_block_get_bytes_committed(block);+  if (bytes_committed + size > CENSUS_LOG_MAX_RECORD_SIZE) {+    cl_unlock(&block->writer_lock);+    return NULL;+  }+  return block->buffer + bytes_committed;+}++/* Releases writer_lock and increments committed bytes by 'bytes_written'.+  'bytes_written' must be <= 'size' specified in the corresponding+  StartWrite() call. This function is thread-safe. */+static void cl_block_end_write(cl_block* block, size_t bytes_written) {+  cl_block_set_bytes_committed(+      block, cl_block_get_bytes_committed(block) + bytes_written);+  cl_unlock(&block->writer_lock);+}++/* Returns a pointer to the first unread byte in buffer. The number of bytes+   available are returned in 'bytes_available'. Acquires reader lock that is+   released by a subsequent cl_block_end_read() call. Returns NULL if:+   - read in progress+   - no data available */+static void* cl_block_start_read(cl_block* block, size_t* bytes_available) {+  if (!cl_try_lock(&block->reader_lock)) {+    return NULL;+  }+  /* bytes_committed may change from under us. Use bytes_available to update+     bytes_read below. */+  size_t bytes_committed = cl_block_get_bytes_committed(block);+  GPR_ASSERT(bytes_committed >= block->bytes_read);+  *bytes_available = bytes_committed - block->bytes_read;+  if (*bytes_available == 0) {+    cl_unlock(&block->reader_lock);+    return NULL;+  }+  void* record = block->buffer + block->bytes_read;+  block->bytes_read += *bytes_available;+  return record;+}++static void cl_block_end_read(cl_block* block) {+  cl_unlock(&block->reader_lock);+}++/* Internal functions operating on g_log */++/* Allocates a new free block (or recycles an available dirty block if log is+   configured to discard old records). Returns NULL if out-of-space. */+static cl_block* cl_allocate_block(void) {+  cl_block* block = cl_block_list_head(&g_log.free_block_list);+  if (block != NULL) {+    cl_block_list_remove(&g_log.free_block_list, block);+    return block;+  }+  if (!g_log.discard_old_records) {+    /* No free block and log is configured to keep old records. */+    return NULL;+  }+  /* Recycle dirty block. Start from the oldest. */",Please remove this if we decide to not support circular log.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/4859,52630163,2016-02-11T16:53:18Z,src/core/client_config/subchannel_index.c,"@@ -0,0 +1,259 @@+//+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//+//++#include ""src/core/client_config/subchannel_index.h""++#include <stdbool.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/avl.h>+#include <grpc/support/tls.h>++#include ""src/core/channel/channel_args.h""++// a map of subchannel_key --> subchannel, used for detecting connections+// to the same destination in order to share them+static gpr_avl g_subchannel_index;++static gpr_mu g_mu;++struct grpc_subchannel_key {+  grpc_connector *connector;+  grpc_subchannel_args args;+};++GPR_TLS_DECL(subchannel_index_exec_ctx);++static void enter_ctx(grpc_exec_ctx *exec_ctx) {+  GPR_ASSERT(gpr_tls_get(&subchannel_index_exec_ctx) == 0);+  gpr_tls_set(&subchannel_index_exec_ctx, (intptr_t)exec_ctx);+}++static void leave_ctx(grpc_exec_ctx *exec_ctx) {+  GPR_ASSERT(gpr_tls_get(&subchannel_index_exec_ctx) == (intptr_t)exec_ctx);+  gpr_tls_set(&subchannel_index_exec_ctx, 0);+}++static grpc_exec_ctx *current_ctx() {+  grpc_exec_ctx *c = (grpc_exec_ctx *)gpr_tls_get(&subchannel_index_exec_ctx);+  GPR_ASSERT(c != NULL);+  return c;+}++static grpc_subchannel_key *create_key(+    grpc_connector *connector, grpc_subchannel_args *args,+    grpc_channel_args *(*copy_channel_args)(const grpc_channel_args *args)) {+  grpc_subchannel_key *k = gpr_malloc(sizeof(*k));+  k->connector = grpc_connector_ref(connector);+  k->args.filter_count = args->filter_count;+  k->args.filters = gpr_malloc(sizeof(*k->args.filters) * k->args.filter_count);+  memcpy((grpc_channel_filter *)k->args.filters, args->filters,+         sizeof(*k->args.filters) * k->args.filter_count);+  k->args.addr_len = args->addr_len;+  k->args.addr = gpr_malloc(args->addr_len);+  memcpy(k->args.addr, args->addr, k->args.addr_len);+  k->args.args = copy_channel_args(args->args);+  return k;+}++grpc_subchannel_key *grpc_subchannel_key_create(grpc_connector *connector,+                                                grpc_subchannel_args *args) {+  return create_key(connector, args, grpc_channel_args_normalize);+}++static grpc_subchannel_key *subchannel_key_copy(grpc_subchannel_key *k) {+  return create_key(k->connector, &k->args, grpc_channel_args_copy);+}++static int subchannel_key_compare(grpc_subchannel_key *a,+                                  grpc_subchannel_key *b) {+  int c = GPR_ICMP(a->connector, b->connector);+  if (c != 0) return c;+  c = GPR_ICMP(a->args.addr_len, b->args.addr_len);+  if (c != 0) return c;+  c = GPR_ICMP(a->args.filter_count, b->args.filter_count);+  if (c != 0) return c;+  c = memcmp(a->args.addr, b->args.addr, a->args.addr_len);+  if (c != 0) return c;+  c = memcmp(a->args.filters, b->args.filters,+             a->args.filter_count * sizeof(*a->args.filters));+  return grpc_channel_args_compare(a->args.args, b->args.args);+}++void grpc_subchannel_key_destroy(grpc_exec_ctx *exec_ctx,+                                 grpc_subchannel_key *k) {+  grpc_connector_unref(exec_ctx, k->connector);+  gpr_free(k->args.addr);+  gpr_free((grpc_channel_args *)k->args.filters);+  grpc_channel_args_destroy((grpc_channel_args *)k->args.args);+  gpr_free(k);+}++static void sck_avl_destroy(void *p) {+  grpc_subchannel_key_destroy(current_ctx(), p);+}++static void *sck_avl_copy(void *p) { return subchannel_key_copy(p); }++static long sck_avl_compare(void *a, void *b) {+  return subchannel_key_compare(a, b);+}++static void scv_avl_destroy(void *p) {+  GRPC_SUBCHANNEL_WEAK_UNREF(current_ctx(), p, ""subchannel_index"");+}++static void *scv_avl_copy(void *p) {+  GRPC_SUBCHANNEL_WEAK_REF(p, ""subchannel_index"");+  return p;+}++static const gpr_avl_vtable subchannel_avl_vtable = {+    .destroy_key = sck_avl_destroy,+    .copy_key = sck_avl_copy,+    .compare_keys = sck_avl_compare,+    .destroy_value = scv_avl_destroy,+    .copy_value = scv_avl_copy};++void grpc_subchannel_index_init(void) {+  g_subchannel_index = gpr_avl_create(&subchannel_avl_vtable);+  gpr_mu_init(&g_mu);+}++void grpc_subchannel_index_shutdown(void) {+  gpr_mu_destroy(&g_mu);+  gpr_avl_unref(g_subchannel_index);+}++grpc_subchannel *grpc_subchannel_index_find(grpc_exec_ctx *exec_ctx,+                                            grpc_subchannel_key *key) {+  enter_ctx(exec_ctx);++  // Lock, and take a reference to the subchannel index.+  // We don't need to do the search under a lock as avl's are immutable.+  gpr_mu_lock(&g_mu);+  gpr_avl index = gpr_avl_ref(g_subchannel_index);+  gpr_mu_unlock(&g_mu);++  grpc_subchannel *c =+      GRPC_SUBCHANNEL_REF_FROM_WEAK_REF(gpr_avl_get(index, key), ""index_find"");+  gpr_avl_unref(index);++  leave_ctx(exec_ctx);+  return c;+}++grpc_subchannel *grpc_subchannel_index_register(grpc_exec_ctx *exec_ctx,+                                                grpc_subchannel_key *key,+                                                grpc_subchannel *constructed) {+  enter_ctx(exec_ctx);++  grpc_subchannel *c = NULL;++  while (c == NULL) {+    // Compare and swap loop:+    // - take a reference to the current index+    gpr_mu_lock(&g_mu);+    gpr_avl index = gpr_avl_ref(g_subchannel_index);+    gpr_mu_unlock(&g_mu);++    // - Check to see if a subchannel already exists+    c = gpr_avl_get(index, key);+    if (c != NULL) {+      // yes -> we're done+      GRPC_SUBCHANNEL_WEAK_UNREF(exec_ctx, constructed, ""index_register"");+    } else {+      // no -> update the avl and compare/swap+      gpr_avl updated =+          gpr_avl_add(gpr_avl_ref(index), subchannel_key_copy(key),+                      GRPC_SUBCHANNEL_WEAK_REF(constructed, ""index_register""));++      // it may happen (but it's expected to be unlikely)+      // that some other thread has changed the index:",avl.c is perfectly threadsafe :)It's an immutable data-structure (past ref-counts - which are atomics) that returns a new structure for each mutation op.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5207,52677475,2016-02-11T22:23:03Z,tools/run_tests/build_artifact_python.sh,"@@ -43,7 +43,11 @@ GRPC_PYTHON_USE_CUSTOM_BDIST=0  \ GRPC_PYTHON_BUILD_WITH_CYTHON=1 \ ${SETARCH_CMD} python setup.py  \     bdist_wheel                 \-    sdist                       \+    sdist","Because what we are doing is hands down unorthodox, because there definitively exist more supported ways of supporting binary linux distributions (e.g. debian packages), and the issues already exist and we've already pinged them. Filing subissues flings us into the X-Y of having a particular problem that we're trying to solve and then going about it in one particular way when at any point in time we could realize there is something so much better. For example, I want to outright scrap this whole deal and try something different but I don't have the time to do so before Friday, which is a _hard deadline_ for our package to be available.Given what we have done so far, I vehemently disagree that we 'want' to get to a certain goal in an orthodox way. We simply 'want' to get to the goal for 0.13.0, and we're all signed up for cleanup afterwards.",
9053690,zhangkun83,https://api.github.com/repos/grpc/grpc/pulls/5195,52689347,2016-02-12T00:12:50Z,doc/load-balancing.md,"@@ -0,0 +1,96 @@+Load Balancing in gRPC+=======================++# Objective++To design a load balancing API between a gRPC client and a Load Balancer to+instruct the client how to send load to multiple backend servers. ++# Background++Prior to any gRPC specifics, we explore some usual ways to approach load+balancing.++### Proxy Model++Using a proxy provides a solid trustable client that can report load to the load+balancing system. Proxies typically require more resources to operate since they+have temporary copies of the RPC request and response. This model also increases+latency to the RPCs.++The proxy model was deemed inefficient when considering request heavy services+like storage. ++### Balancing-aware Client++This thicker client places more of the load balancing logic in the client. For+example, the client could contain many load balancing policies (Round Robin,+Random, etc) used to select servers from a list. In this model, a load balancer",There wouldn't necessarily be a load-balancer. The server list may be statically configured or directly from the name resolution system.,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5201,52813780,2016-02-12T23:43:47Z,test/cpp/qps/interarrival.h,"@@ -51,15 +51,15 @@ namespace testing { // stacks. Thus, this code only uses a uniform distribution of doubles [0,1) // and then provides the distribution functions itself. -class RandomDist {+class RandomDistInterface {  public:-  RandomDist() {}-  virtual ~RandomDist() = 0;-  // Argument to operator() is a uniform double in the range [0,1)-  virtual double operator()(double uni) const = 0;+  RandomDistInterface() {}+  virtual ~RandomDistInterface() = 0;+  // Argument to transform is a uniform double in the range [0,1)","It's an abstract base class so I renamed it to ""Interface"" to be consistent with how we name most of our abstract base classes.",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/5225,53041795,2016-02-16T17:04:18Z,src/php/ext/grpc/call.c,"@@ -125,15 +125,9 @@ zval *grpc_parse_metadata_array(grpc_metadata_array *metadata_array) {     memcpy(str_val, elem->value, elem->value_length);     if (zend_hash_find(array_hash, str_key, key_len, (void **)data) ==         SUCCESS) {-      if (Z_TYPE_P(*data) != IS_ARRAY) {-        zend_throw_exception(zend_exception_get_default(),-                             ""Metadata hash somehow contains wrong types."",-                             1 TSRMLS_CC);-          efree(str_key);-          efree(str_val);","I find that this is pretty much unreachable. All the cases where `grpc_parse_metadata_array` is called, the metadata has already been cleaned/verified by a previous call.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/5225,53046160,2016-02-16T17:31:49Z,src/php/ext/grpc/call.c,"@@ -125,15 +125,9 @@ zval *grpc_parse_metadata_array(grpc_metadata_array *metadata_array) {     memcpy(str_val, elem->value, elem->value_length);     if (zend_hash_find(array_hash, str_key, key_len, (void **)data) ==         SUCCESS) {-      if (Z_TYPE_P(*data) != IS_ARRAY) {-        zend_throw_exception(zend_exception_get_default(),-                             ""Metadata hash somehow contains wrong types."",-                             1 TSRMLS_CC);-          efree(str_key);-          efree(str_val);","Actually, I just realized that you removed a whole conditional here. That change should make this function unconditionally fail on any non-empty array.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/5225,53046315,2016-02-16T17:32:50Z,src/php/ext/grpc/call.c,"@@ -125,15 +125,9 @@ zval *grpc_parse_metadata_array(grpc_metadata_array *metadata_array) {     memcpy(str_val, elem->value, elem->value_length);     if (zend_hash_find(array_hash, str_key, key_len, (void **)data) ==         SUCCESS) {-      if (Z_TYPE_P(*data) != IS_ARRAY) {-        zend_throw_exception(zend_exception_get_default(),-                             ""Metadata hash somehow contains wrong types."",-                             1 TSRMLS_CC);-          efree(str_key);-          efree(str_val);","And if the condition is unreachable, just remove it. Otherwise, handle it properly. But don't just remove part of the handling code.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5257,53050316,2016-02-16T17:58:55Z,src/core/surface/completion_queue.c,"@@ -427,7 +439,19 @@ grpc_event grpc_completion_queue_pluck(grpc_completion_queue *cc, void *tag,       break;     }     first_loop = 0;-    grpc_pollset_work(&exec_ctx, &cc->pollset, &worker, now, deadline);+    /* Check alarms - these are a global resource so we just ping+       each time through on every pollset.+       May update deadline to ensure timely wakeups.+       TODO(ctiller): can this work be localized? */+    gpr_timespec iteration_deadline = deadline;+    if (grpc_timer_check(&exec_ctx, now, &iteration_deadline)) {+      GPR_TIMER_MARK(""alarm_triggered"", 0);+      gpr_mu_unlock(GRPC_POLLSET_MU(&cc->pollset));+      grpc_exec_ctx_flush(&exec_ctx);+      gpr_mu_lock(GRPC_POLLSET_MU(&cc->pollset));+      continue;+    }+    grpc_pollset_work(&exec_ctx, &cc->pollset, &worker, now, iteration_deadline);","If we reuse the code we end up in the same complicated tracking mess - Ilike the fact that the mutex manipulation is mostly surfaced now.On Tue, Feb 16, 2016 at 9:54 AM Vijay Pai notifications@github.com wrote:> In src/core/surface/completion_queue.c> https://github.com/grpc/grpc/pull/5257#discussion_r53049561:> > > @@ -427,7 +439,19 @@ grpc_event grpc_completion_queue_pluck(grpc_completion_queue *cc, void *tag,> >        break;> >      }> >      first_loop = 0;> > -    grpc_pollset_work(&exec_ctx, &cc->pollset, &worker, now, deadline);> > -    /\* Check alarms - these are a global resource so we just ping> > -       each time through on every pollset.> > -       May update deadline to ensure timely wakeups.> > -       TODO(ctiller): can this work be localized? */> > -    gpr_timespec iteration_deadline = deadline;> > -    if (grpc_timer_check(&exec_ctx, now, &iteration_deadline)) {> > -      GPR_TIMER_MARK(""alarm_triggered"", 0);> > -      gpr_mu_unlock(GRPC_POLLSET_MU(&cc->pollset));> > -      grpc_exec_ctx_flush(&exec_ctx);> > -      gpr_mu_lock(GRPC_POLLSET_MU(&cc->pollset));> > -      continue;> > -    }> > -    grpc_pollset_work(&exec_ctx, &cc->pollset, &worker, now, iteration_deadline);> > Any way to reuse code here since it's the same as the above case?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5257/files#r53049561.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5258,53050942,2016-02-16T18:03:12Z,test/cpp/end2end/async_end2end_test.cc,"@@ -67,10 +67,10 @@ namespace { void* tag(int i) { return (void*)(intptr_t)i; }  #ifdef GPR_POSIX_SOCKET-static int assert_non_blocking_poll(struct pollfd* pfds, nfds_t nfds,+static int non_blocking_poll(struct pollfd* pfds, nfds_t nfds,                                     int timeout) {-  GPR_ASSERT(timeout == 0);-  return poll(pfds, nfds, timeout);+  /* ignore timeout and always use timeout 0 */","Removing the assert makes this a much weaker test.The original test provided guarantees that we never blocked calling code, which is important for many use cases (imagine a UI thread that wants to do _some_ grpc work).Overriding that here means that we're no longer providing such a guarantee.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5258,53052857,2016-02-16T18:16:59Z,test/cpp/end2end/async_end2end_test.cc,"@@ -67,10 +67,10 @@ namespace { void* tag(int i) { return (void*)(intptr_t)i; }  #ifdef GPR_POSIX_SOCKET-static int assert_non_blocking_poll(struct pollfd* pfds, nfds_t nfds,+static int non_blocking_poll(struct pollfd* pfds, nfds_t nfds,                                     int timeout) {-  GPR_ASSERT(timeout == 0);-  return poll(pfds, nfds, timeout);+  /* ignore timeout and always use timeout 0 */","So the issue was that this function gets invoked not only fromasync_end2end_test , but also from the resolver since the poll override nowtakes place before the library really gets started working. This wasn't thecase before because the poll function was constantly getting overridden andre-defaulted on each verification.On Tue, Feb 16, 2016 at 10:03 AM Craig Tiller notifications@github.comwrote:> In test/cpp/end2end/async_end2end_test.cc> https://github.com/grpc/grpc/pull/5258#discussion_r53050942:> > > ```> >                                  int timeout) {> > ```> > -  GPR_ASSERT(timeout == 0);> > -  return poll(pfds, nfds, timeout);> > -  /\* ignore timeout and always use timeout 0 */> > Removing the assert makes this a much weaker test.> > The original test provided guarantees that we never blocked calling code,> which is important for many use cases (imagine a UI thread that wants to do> _some_ grpc work).> > Overriding that here means that we're no longer providing such a guarantee.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5258/files#r53050942.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5283,53233798,2016-02-17T21:25:51Z,src/python/grpcio/precompiled.py,"@@ -51,9 +52,15 @@  def _tagged_ext_name(base):   uname = platform.uname()-  tags = '-'.join((grpc_version.VERSION, uname[0], uname[4]))-  flavor = 'ucs2' if sys.maxunicode == 65535 else 'ucs4'-  return '{base}-{tags}-{flavor}'.format(base=base, tags=tags, flavor=flavor)+  tags = [",Tuple rather than list.,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/5186,53238738,2016-02-17T22:04:15Z,src/cpp/common/channel_arguments.cc,"@@ -81,6 +90,28 @@ void ChannelArguments::SetCompressionAlgorithm(   SetInt(GRPC_COMPRESSION_ALGORITHM_ARG, algorithm); } +// Note: a second call to this will add in front the result of the first call.","It would help to add more details/context to this comment. Until you pointed me to the issues (https://github.com/grpc/grpc/issues/4069 and https://github.com/grpc/grpc/issues/2661), i thought calling it twice is a ""bug"" and should be avoided :).Perhaps adding a bit more context will help - or just saying that user should call it twice if they want to add more user agent identifiers..> > > (pasting this from #2661)> > > ""RFC 7231§5.5.3 says:> > > By convention, the product identifiers are listed in decreasing order of their significance for identifying the user agent software.> > > Combined with the example, it seems that we should put the application-provided string first.""",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/5293,53278542,2016-02-18T07:15:42Z,src/cpp/common/alarm.cc,"@@ -31,21 +31,17 @@  */  #include <grpc++/alarm.h>-#include <grpc++/completion_queue.h> #include <grpc++/impl/grpc_library.h>-#include <grpc/grpc.h>  namespace grpc {  static internal::GrpcLibraryInitializer g_gli_initializer;-Alarm::Alarm(CompletionQueue* cq, gpr_timespec deadline, void* tag)-    : tag_(tag),-      alarm_(grpc_alarm_create(cq->cq(), deadline, static_cast<void*>(&tag_))) {++Alarm::~Alarm() {   g_gli_initializer.summon();","Because it can't live in the constructor, now in a .h due to the use of templates. The static global variable needs to live inside a compilation unit.You make a good point about the CompletionQueue, hmmm. I guess we could remove it provided we put a big comment in its stead pointing at how if the CQ is ever removed, it'd have to be added back.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/5290,53297369,2016-02-18T10:40:46Z,src/csharp/Grpc.Core/Testing/MockAsyncUnaryCall.cs,"@@ -0,0 +1,94 @@+#region Copyright notice and license++// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++#endregion++using System;+using System.Collections.Generic;+using System.Threading.Tasks;++using Grpc.Core.Internal;+using Grpc.Core.Utils;++namespace Grpc.Core.Testing+{+    /// <summary>Allows mocking gRPC client objects by implementing the code-generated stub client interface <c>IFooClient</c></summary>+    public class MockAsyncUnaryCall<TResponse>","I would leave the word ""mock"" out here. It suggests a kind of testing which may not be the case.Given how similar this is to TaskCompetionSource and CancellationTokenSource, I'd be tempted to call it AsyncUnaryCallSource.At that point, we could add extra useful methods of SetCancelled, SetFaulted etc potentially.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5290,53367600,2016-02-18T19:22:17Z,src/csharp/Grpc.Core/Testing/MockAsyncUnaryCall.cs,"@@ -0,0 +1,94 @@+#region Copyright notice and license++// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++#endregion++using System;+using System.Collections.Generic;+using System.Threading.Tasks;++using Grpc.Core.Internal;+using Grpc.Core.Utils;++namespace Grpc.Core.Testing+{+    /// <summary>Allows mocking gRPC client objects by implementing the code-generated stub client interface <c>IFooClient</c></summary>+    public class MockAsyncUnaryCall<TResponse>+    {+        ClientSideStatus? clientSideStatus;+        TaskCompletionSource<Metadata> responseHeadersTcs = new TaskCompletionSource<Metadata>();+        TaskCompletionSource<TResponse> responseTcs = new TaskCompletionSource<TResponse>();+        AsyncUnaryCall<TResponse> call;++        /// <summary>+        /// Initializes a new instance of the <see cref=""Grpc.Core.Testing.MockAsyncUnaryCall`1""/> class.+        /// </summary>+        public MockAsyncUnaryCall()+        {+            // TODO(jtattermusch): implement dispose action functionality+            this.call = new AsyncUnaryCall<TResponse>(responseTcs.Task, responseHeadersTcs.Task,+                () => clientSideStatus.Value.Status, () => clientSideStatus.Value.Trailers, () => {});+        }++        /// <summary>+        /// Sets the response for this mock call.+        /// </summary>+        public void SetResponse(TResponse response)+        {+            SetResponse(response, Status.DefaultSuccess, new Metadata(), new Metadata());+        }++        /// <summary>+        /// Sets the response for this mock call.+        /// </summary>+        public void SetResponse(TResponse response, Status status, Metadata responseHeaders, Metadata responseTrailers)","Ah, my bad. Yeah, the intention was to allow faking arbitrary scenarios (statuscode delivered, call cancelled, basically you choose what status you obtain) but somehow that got lost in translation.  Will add that.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/5293,53371728,2016-02-18T19:47:39Z,include/grpc++/alarm.h,"@@ -54,7 +56,11 @@ class Alarm : private GrpcLibrary {   /// Once the alarm expires (at \a deadline) or it's cancelled (see \a Cancel),   /// an event with tag \a tag will be added to \a cq. If the alarm expired, the   /// event's success bit will be true, false otherwise (ie, upon cancellation).-  Alarm(CompletionQueue* cq, gpr_timespec deadline, void* tag);+  template <typename T>+  Alarm(CompletionQueue* cq, const T& deadline, void* tag)+      : tag_(tag),+        alarm_(grpc_alarm_create(cq->cq(), TimePoint<T>(deadline).raw_time(),+                                 static_cast<void*>(&tag_))) {} ","Hmm we can't use std::chrono because that results in a REALTIME clock, something not allowed in alarms (racy, see https://github.com/grpc/grpc/blob/master/src/core/iomgr/timer.c#L178). We could try to figure out how to guarantee a monotonic conversion from std::chrono::*, but that's a story for a different day.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5289,53396609,2016-02-18T22:53:59Z,tools/run_tests/run_tests.py,"@@ -810,7 +810,7 @@ def git(cmd, cwd=cwd):   else:     language_make_options = next(iter(languages)).make_options() -if len(languages) != 1 or len(build_configs) != 1:+if len(languages) != 1 and len(build_configs) != 1:","well, that's tough. This condition is here for a reason. I've split up testing docker images per-language a while ago and currently, run_tests.py can only use one docker image in a single run (and yeah, I forgot about code coverage test that requires a single umbrella image when doing the change - my bad).This check is here to protect us against cases where we want to run more languages at a time (-l all), but that would require using more docker images which we currently don't support.I'd be actually surprised if the coverage run would actually work with this ""fix"".",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/5272,53403791,2016-02-19T00:02:05Z,INSTALL.md,"@@ -0,0 +1,38 @@+#If you are in a hurry++On Linux (Debian):++```sh+ $ [sudo] apt-get install libgrpc-dev+```++On MacOS:++```sh+ $ curl -fsSL https://goo.gl/getgrpc | bash -","If you follow that link, it just goes to the latest version of https://github.com/grpc/homebrew-grpc/blob/master/scripts/install",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5293,53425270,2016-02-19T05:53:14Z,src/cpp/common/alarm.cc,"@@ -31,21 +31,17 @@  */  #include <grpc++/alarm.h>-#include <grpc++/completion_queue.h> #include <grpc++/impl/grpc_library.h>-#include <grpc/grpc.h>  namespace grpc {  static internal::GrpcLibraryInitializer g_gli_initializer;-Alarm::Alarm(CompletionQueue* cq, gpr_timespec deadline, void* tag)-    : tag_(tag),-      alarm_(grpc_alarm_create(cq->cq(), deadline, static_cast<void*>(&tag_))) {++Alarm::~Alarm() {   g_gli_initializer.summon();",Any thoughts about this issue? The current state is unkosher but there is a way around it (never allow the construction of a null or CQ-less alarm and just rely on CQ to kickstart the library),
150108,hsaliak,https://api.github.com/repos/grpc/grpc/pulls/5272,53425814,2016-02-19T06:04:30Z,INSTALL.md,"@@ -0,0 +1,38 @@+#If you are in a hurry++On Linux (Debian):++```sh+ $ [sudo] apt-get install libgrpc-dev+```++On MacOS:++```sh+ $ curl -fsSL https://goo.gl/getgrpc | bash -+```+++#Build from Source","Suggest we change the topic to:Build gRPC Core from Source or similar, to indicate that this only builds the C coreA meta comment may also be helpful. Ie: This doc outlines the steps to install gRPC. The installation of gRPC works by installing the C core, followed by language specific components..We should list dependencies we need if we are building from source.Prerequisites. Let's list pre-requisites for1) Windows2) Linux  In this section, we can list the general packages we need, followed by an example for debian. ie: In Debian (wheezy) these dependencies can be installed by running: apt-get install a b c d e..3) Mac OSX ",
150108,hsaliak,https://api.github.com/repos/grpc/grpc/pulls/5272,53426180,2016-02-19T06:11:13Z,INSTALL.md,"@@ -0,0 +1,38 @@+#If you are in a hurry++On Linux (Debian):++```sh+ $ [sudo] apt-get install libgrpc-dev+```++On MacOS:++```sh+ $ curl -fsSL https://goo.gl/getgrpc | bash -","We should direct users to language specific packages if that's what they are actually interested in.If you are in a Hurry and only want to install gRPC as a dependency, follow language specific instructions.For the C core, this can be accomplished by doing the following.WindowsLinuxMac OSX..",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5345,53799478,2016-02-23T15:52:58Z,src/core/iomgr/reachability.h,"@@ -0,0 +1,114 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CORE_IOMGR_REACHABILITY_H+#define GRPC_INTERNAL_CORE_IOMGR_REACHABILITY_H++// Reachability (as used here) is defined as being the existance of a network+// route to a specified address. It does not indicate whether a server is+// serving traffic at that address.++/// Network type: a broad classification of different kinds of network+/// Useful for systems that want to send traffic only on a restricted class+typedef enum grpc_network_type {+  /// Network type is unknown+  GRPC_NETWORK_UNKNOWN_TYPE,+  /// Network is a wired connection+  GRPC_NETWORK_WIRED,+  /// Network is a wifi connection+  GRPC_NETWORK_WIFI,+  /// Network is a cellular connection+  GRPC_NETWORK_CELLULAR+} grpc_network_type;++/// A description of a nic+typedef struct grpc_network_interface {+  /// Type of the network this nic refers to+  grpc_network_type network_type;+  /// Address to pass to bind() to select this nic+  const sockaddr_t *bind_addr;+  size_t bind_addr_len;+  /// A name a sysadmin could use to identify this nic+  const char *name;+} grpc_network_interface;++/// Copy a network interface description+grpc_network_interface *grpc_network_interface_copy(+    grpc_network_interface *src);+/// Destroy a network interface description+void grpc_network_interface_destroy(grpc_network_interface *nic);+/// Enumerate all network interfaces on this system+void grpc_enumerate_network_interfaces(grpc_network_interface **nics,+                                       size_t *nic_count);++/// One time global initialization+void grpc_reachability_init(void);+/// Global shutdown - cancels all outstanding watches+void grpc_reachability_shutdown(void);++/// Watch \a addr for reachability.+/// If \a addr == NULL, watch for any network being available.+/// When \a addr becomes reachable, call \a on_reachable with success=true+/// \a optionally_only_on_nic allows reachability to be awaited only via a+/// specific network interface+void grpc_reachability_await_reachable(+    const sockaddr_t *addr, size_t addr_len,+    const grpc_network_interface *optionally_only_on_nic,+    grpc_closure *on_reachable);+/// Watch \a addr for reachability.+/// If \a addr == NULL, watch for all networks being unavailable.+/// When \a addr becomes unreachable, call \a on_unreachable with success=true+/// \a optionally_only_on_nic allows reachability to be awaited only via a+/// specific network interface+void grpc_reachability_await_unreachable(+    const sockaddr_t *addr, size_t addr_len,+    const grpc_network_interface *optionally_only_on_nic,+    grpc_closure *on_unreachable);++/// Query (instantaneous) reachability of \a addr","That's good to know. After sleeping on it, I'm not sure how useful this routine is anyway.Let's look at some use cases:For name resolution we currently do:```resolve(""www.google.com"").then(func(addresses) {  connectAddresses(addresses);});```Once we take into account reachability we'll probably want to:```resolve(""www.google.com"").then(func(addresses) {  set<Address> usable_addresses;  func becomeUsable(addr) {    usable_addresses.add(addr);    publishAddresses(usable_addresses);    awaitUnreachable(addr).then(becomeUnusable);  }  func becomeUnusable(addr) {    usable_addresses.remove(addr);    publishAddresses(usable_addresses);    awaitReachable(addr).then(becomeUsable);  }  for (addr : addresses) {    awaitReachable(addr).then(becomeUsable);  }});```After shuddering at the complexity a little, I think I'm ok here without the query operator - I don't see that it would drastically simplify things for us.We (likely) also want to have something in subchannel to look for unreachability post-creation, and to treat that like a disconnect. Here, something as simple as:```awaitUnreachable(my_addr, only_on_nic=my_nic).then(disconnect);```is probably all that we need.So... let's drop the query for now? What do you think @TestUser345 - any use case I'm missing?",
17325098,makdharma,https://api.github.com/repos/grpc/grpc/pulls/5345,53805044,2016-02-23T16:24:32Z,src/core/iomgr/reachability.h,"@@ -0,0 +1,114 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CORE_IOMGR_REACHABILITY_H+#define GRPC_INTERNAL_CORE_IOMGR_REACHABILITY_H++// Reachability (as used here) is defined as being the existance of a network+// route to a specified address. It does not indicate whether a server is+// serving traffic at that address.++/// Network type: a broad classification of different kinds of network+/// Useful for systems that want to send traffic only on a restricted class+typedef enum grpc_network_type {+  /// Network type is unknown+  GRPC_NETWORK_UNKNOWN_TYPE,+  /// Network is a wired connection+  GRPC_NETWORK_WIRED,+  /// Network is a wifi connection+  GRPC_NETWORK_WIFI,+  /// Network is a cellular connection+  GRPC_NETWORK_CELLULAR+} grpc_network_type;++/// A description of a nic+typedef struct grpc_network_interface {+  /// Type of the network this nic refers to+  grpc_network_type network_type;+  /// Address to pass to bind() to select this nic+  const sockaddr_t *bind_addr;+  size_t bind_addr_len;+  /// A name a sysadmin could use to identify this nic+  const char *name;+} grpc_network_interface;++/// Copy a network interface description+grpc_network_interface *grpc_network_interface_copy(+    grpc_network_interface *src);+/// Destroy a network interface description+void grpc_network_interface_destroy(grpc_network_interface *nic);+/// Enumerate all network interfaces on this system+void grpc_enumerate_network_interfaces(grpc_network_interface **nics,+                                       size_t *nic_count);++/// One time global initialization+void grpc_reachability_init(void);+/// Global shutdown - cancels all outstanding watches+void grpc_reachability_shutdown(void);++/// Watch \a addr for reachability.+/// If \a addr == NULL, watch for any network being available.+/// When \a addr becomes reachable, call \a on_reachable with success=true+/// \a optionally_only_on_nic allows reachability to be awaited only via a+/// specific network interface+void grpc_reachability_await_reachable(+    const sockaddr_t *addr, size_t addr_len,+    const grpc_network_interface *optionally_only_on_nic,+    grpc_closure *on_reachable);+/// Watch \a addr for reachability.+/// If \a addr == NULL, watch for all networks being unavailable.+/// When \a addr becomes unreachable, call \a on_unreachable with success=true+/// \a optionally_only_on_nic allows reachability to be awaited only via a+/// specific network interface+void grpc_reachability_await_unreachable(+    const sockaddr_t *addr, size_t addr_len,+    const grpc_network_interface *optionally_only_on_nic,+    grpc_closure *on_unreachable);++/// Query (instantaneous) reachability of \a addr","Yes, makes sense to drop the query after thinking through this.On Tue, Feb 23, 2016 at 7:53 AM, Craig Tiller notifications@github.comwrote:> In src/core/iomgr/reachability.h> https://github.com/grpc/grpc/pull/5345#discussion_r53799478:> > > +/// specific network interface> > +void grpc_reachability_await_reachable(> > -    const sockaddr_t *addr, size_t addr_len,> > -    const grpc_network_interface *optionally_only_on_nic,> > -    grpc_closure *on_reachable);> >   +/// Watch \a addr for reachability.> >   +/// If \a addr == NULL, watch for all networks being unavailable.> >   +/// When \a addr becomes unreachable, call \a on_unreachable with success=true> >   +/// \a optionally_only_on_nic allows reachability to be awaited only via a> >   +/// specific network interface> >   +void grpc_reachability_await_unreachable(> > -    const sockaddr_t *addr, size_t addr_len,> > -    const grpc_network_interface *optionally_only_on_nic,> > -    grpc_closure *on_unreachable);> >   +> >   +/// Query (instantaneous) reachability of \a addr> > That's good to know. After sleeping on it, I'm not sure how useful this> routine is anyway.> > Let's look at some use cases:> > For name resolution we currently do:> > resolve(""www.google.com"").then(func(addresses) {>   connectAddresses(addresses);> });> > Once we take into account reachability we'll probably want to:> > resolve(""www.google.com"").then(func(addresses) {>   set<Address> usable_addresses;>   func becomeUsable(addr) {>     usable_addresses.add(addr);>     publishAddresses(usable_addresses);>     awaitUnreachable(addr).then(becomeUnusable);>   }>   func becomeUnusable(addr) {>     usable_addresses.remove(addr);>     publishAddresses(usable_addresses);>     awaitReachable(addr).then(becomeUsable);>   }>   for (addr : addresses) {>     awaitReachable(addr).then(becomeUsable);>   }> });> > After shuddering at the complexity a little, I think I'm ok here without> the query operator - I don't see that it would drastically simplify things> for us.> > We (likely) also want to have something in subchannel to look for> unreachability post-creation, and to treat that like a disconnect. Here,> something as simple as:> > awaitUnreachable(my_addr, only_on_nic=my_nic).then(disconnect);> > is probably all that we need.> > So... let's drop the query for now? What do you think @TestUser345> https://github.com/TestUser345 - any use case I'm missing?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5345/files#r53799478.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5345,53816799,2016-02-23T17:32:53Z,src/core/iomgr/reachability.h,"@@ -0,0 +1,114 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CORE_IOMGR_REACHABILITY_H+#define GRPC_INTERNAL_CORE_IOMGR_REACHABILITY_H++// Reachability (as used here) is defined as being the existance of a network+// route to a specified address. It does not indicate whether a server is+// serving traffic at that address.++/// Network type: a broad classification of different kinds of network+/// Useful for systems that want to send traffic only on a restricted class+typedef enum grpc_network_type {+  /// Network type is unknown+  GRPC_NETWORK_UNKNOWN_TYPE,+  /// Network is a wired connection+  GRPC_NETWORK_WIRED,+  /// Network is a wifi connection+  GRPC_NETWORK_WIFI,+  /// Network is a cellular connection+  GRPC_NETWORK_CELLULAR+} grpc_network_type;++/// A description of a nic+typedef struct grpc_network_interface {+  /// Type of the network this nic refers to+  grpc_network_type network_type;+  /// Address to pass to bind() to select this nic+  const sockaddr_t *bind_addr;+  size_t bind_addr_len;+  /// A name a sysadmin could use to identify this nic+  const char *name;+} grpc_network_interface;++/// Copy a network interface description+grpc_network_interface *grpc_network_interface_copy(+    grpc_network_interface *src);+/// Destroy a network interface description+void grpc_network_interface_destroy(grpc_network_interface *nic);+/// Enumerate all network interfaces on this system+void grpc_enumerate_network_interfaces(grpc_network_interface **nics,+                                       size_t *nic_count);++/// One time global initialization+void grpc_reachability_init(void);+/// Global shutdown - cancels all outstanding watches+void grpc_reachability_shutdown(void);++/// Watch \a addr for reachability.+/// If \a addr == NULL, watch for any network being available.+/// When \a addr becomes reachable, call \a on_reachable with success=true+/// \a optionally_only_on_nic allows reachability to be awaited only via a+/// specific network interface+void grpc_reachability_await_reachable(+    const sockaddr_t *addr, size_t addr_len,+    const grpc_network_interface *optionally_only_on_nic,+    grpc_closure *on_reachable);+/// Watch \a addr for reachability.+/// If \a addr == NULL, watch for all networks being unavailable.+/// When \a addr becomes unreachable, call \a on_unreachable with success=true+/// \a optionally_only_on_nic allows reachability to be awaited only via a+/// specific network interface+void grpc_reachability_await_unreachable(+    const sockaddr_t *addr, size_t addr_len,+    const grpc_network_interface *optionally_only_on_nic,+    grpc_closure *on_unreachable);++/// Query (instantaneous) reachability of \a addr","@jcanizales - interesting. We need to do some research on other platforms.There are two possible outcomes taking this into account:1. We drop awaitReachable as an operation if this is reasonably consistent across platforms.2. We implement awaitReachable as a no-op that instantly completes on iOS.@zsurocking - can you check into usage patterns on Android?I can imagine how to implement such a thing on Linux, though I'm not sure that it's a necessary feature there.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5368,53854255,2016-02-23T21:36:32Z,src/python/grpcio/grpc/compat.py,"@@ -0,0 +1,6 @@+import six++if six.PY2:+  import cStringIO as StringIO","Eep. This `StringIO` is a module, and the one below is a class!",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5368,53865444,2016-02-23T22:57:09Z,src/python/grpcio/grpc/compatibility.py,"@@ -0,0 +1,6 @@+import six++if six.PY2:",This module smells like it doesn't have to exist. Why would `six.moves.cStringIO` not work in places where `grpc.compatibility.StringIO` is drafted for use?,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/5354,53899110,2016-02-24T06:24:31Z,BUILD,"@@ -1557,6 +1447,7 @@ objc_library(   ],   deps = [     "":gpr_objc"",+    "":grpc_codegen_lib_objc"",",This library does not exist.,
6555937,pgrosu,https://api.github.com/repos/grpc/grpc/pulls/5384,53905418,2016-02-24T08:07:20Z,Makefile,"@@ -275,6 +275,12 @@ endif CXX11_CHECK_CMD = $(CXX) -std=c++11 -o $(TMPOUT) -c test/build/c++11.cc HAS_CXX11 = $(shell $(CXX11_CHECK_CMD) 2> /dev/null && echo true || echo false) +CHECK_SHADOW_WORKS_CMD = $(CC) -std=c99 -Werror -Wshadow -o $(TMPOUT) -c test/build/shadow.c+HAS_WORKING_SHADOW = $(shell $(CHECK_SHADOW_WORKS_CMD) 2> /dev/null && echo true || echo false)+ifeq ($(HAS_WORKING_SHADOW),true)+W_SHADOW=-Wshadow+endif",Not sure this one works as expected. For example the following code below always returns true with or without the shadow warning parameter:``` Bash$ `gcc -std=c99 -Werror -o /dev/null -c shadow.c 2> /dev/null` && echo true || echo falsetrue$ `gcc -std=c99 -Werror -Wshadow -o /dev/null -c shadow.c 2> /dev/null` && echo true || echo falsetrue```,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5384,53905993,2016-02-24T08:14:34Z,Makefile,"@@ -275,6 +275,12 @@ endif CXX11_CHECK_CMD = $(CXX) -std=c++11 -o $(TMPOUT) -c test/build/c++11.cc HAS_CXX11 = $(shell $(CXX11_CHECK_CMD) 2> /dev/null && echo true || echo false) +CHECK_SHADOW_WORKS_CMD = $(CC) -std=c99 -Werror -Wshadow -o $(TMPOUT) -c test/build/shadow.c+HAS_WORKING_SHADOW = $(shell $(CHECK_SHADOW_WORKS_CMD) 2> /dev/null && echo true || echo false)+ifeq ($(HAS_WORKING_SHADOW),true)+W_SHADOW=-Wshadow+endif",The purpose of the check is to check to see if the compiler allows the shadow parameter in the expected way. The comparison would be to check the same command on gcc-4.4 vs gcc-4.8 or gcc-5.2,
6555937,pgrosu,https://api.github.com/repos/grpc/grpc/pulls/5384,53916603,2016-02-24T10:04:21Z,Makefile,"@@ -275,6 +275,12 @@ endif CXX11_CHECK_CMD = $(CXX) -std=c++11 -o $(TMPOUT) -c test/build/c++11.cc HAS_CXX11 = $(shell $(CXX11_CHECK_CMD) 2> /dev/null && echo true || echo false) +CHECK_SHADOW_WORKS_CMD = $(CC) -std=c99 -Werror -Wshadow -o $(TMPOUT) -c test/build/shadow.c+HAS_WORKING_SHADOW = $(shell $(CHECK_SHADOW_WORKS_CMD) 2> /dev/null && echo true || echo false)+ifeq ($(HAS_WORKING_SHADOW),true)+W_SHADOW=-Wshadow+endif","So just out of curiosity - and I'm sure you noticed something - but how might it behave differently among the versions?  For example, in the [manual for 5.3](https://gcc.gnu.org/onlinedocs/gcc-5.3.0/gcc/Warning-Options.html#Warning-Options) you'll notice the following:> **-Wshadow**>     Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. Usually if there was a difference among the versions, you would see something like this, specifying the version differences:> **-Wpacked-bitfield-compat**>     The 4.1, 4.2 and 4.3 series of GCC ignore the packed attribute on bit-fields of type char. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field a and b in this structure:```          struct foo          {            char a:4;            char b:8;          } __attribute__ ((packed));```> This warning is enabled by default. Use -Wno-packed-bitfield-compat to disable this warning. Thanks,~p",
5378335,leifurhauks,https://api.github.com/repos/grpc/grpc/pulls/5368,53941806,2016-02-24T14:04:55Z,src/python/grpcio/grpc/compatibility.py,"@@ -0,0 +1,6 @@+import six++if six.PY2:","That should work, I just didn't realize `six.moves.cStringIO` was there. However, `six.moves.cStringIO` is a constructor (py2) / class (py3), not a module, is that alright?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5368,53950310,2016-02-24T15:02:42Z,src/python/grpcio/grpc/compatibility.py,"@@ -0,0 +1,6 @@+import six++if six.PY2:","Our style guide does call for importing only modules and not classes, functions, or other elements of modules. And that will result in code that reads `from six import moves` and `moves.cStringIO`. That may not be the way most people write their code that uses the `six.moves` module, but there are not problems with it either, right?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5402,54288519,2016-02-26T19:19:27Z,tools/big_query/big_query_utils.py,"@@ -0,0 +1,140 @@+#!/usr/bin/env python2.7",nit: not sure we want an dedicated directory for something as specific as big_query utils.tools/stresstest/.... maybe?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5402,54289746,2016-02-26T19:28:04Z,tools/gke/run_stress_tests_on_gke.py,"@@ -0,0 +1,566 @@+#!/usr/bin/env python2.7+# Copyright 2015-2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+import argparse+import datetime+import os+import subprocess+import sys+import time++stress_test_utils_dir = os.path.abspath(os.path.join(+    os.path.dirname(__file__), '../run_tests/stress_test'))+sys.path.append(stress_test_utils_dir)+from stress_test_utils import BigQueryHelper++import kubernetes_api++_GRPC_ROOT = os.path.abspath(os.path.join(+    os.path.dirname(sys.argv[0]), '../..'))+os.chdir(_GRPC_ROOT)++# num of seconds to wait for the GKE image to start and warmup+_GKE_IMAGE_WARMUP_WAIT_SECS = 60++_SERVER_POD_NAME = 'stress-server'+_CLIENT_POD_NAME_PREFIX = 'stress-client'+_DATASET_ID_PREFIX = 'stress_test'+_SUMMARY_TABLE_ID = 'summary'+_QPS_TABLE_ID = 'qps'++_DEFAULT_DOCKER_IMAGE_NAME = 'grpc_stress_test'++# The default port on which the kubernetes proxy server is started on localhost+# (i.e kubectl proxy --port=<port>)+_DEFAULT_KUBERNETES_PROXY_PORT = 8001++# How frequently should the stress client wrapper script (running inside a GKE+# container) poll the health of the stress client (also running inside the GKE+# container) and upload metrics to BigQuery+_DEFAULT_STRESS_CLIENT_POLL_INTERVAL_SECS = 60++# The default setting for stress test server and client+_DEFAULT_STRESS_SERVER_PORT = 8080+_DEFAULT_METRICS_PORT = 8081+_DEFAULT_TEST_CASES_STR = 'empty_unary:1,large_unary:1,client_streaming:1,server_streaming:1,empty_stream:1'+_DEFAULT_NUM_CHANNELS_PER_SERVER = 5+_DEFAULT_NUM_STUBS_PER_CHANNEL = 10+_DEFAULT_METRICS_COLLECTION_INTERVAL_SECS = 30++# Number of stress client instances to launch+_DEFAULT_NUM_CLIENTS = 3++# How frequently should this test monitor the health of Stress clients and+# Servers running in GKE+_DEFAULT_TEST_POLL_INTERVAL_SECS = 60++# Default run time for this test (2 hour)+_DEFAULT_TEST_DURATION_SECS = 7200++# The number of seconds it would take a GKE pod to warm up (i.e get to 'Running'+# state from the time of creation). Ideally this is something the test should+# automatically determine by using Kubernetes API to poll the pods status.+_DEFAULT_GKE_WARMUP_SECS = 60+++class KubernetesProxy:+  """""" Class to start a proxy on localhost to the Kubernetes API server """"""++  def __init__(self, api_port):+    self.port = api_port+    self.p = None+    self.started = False++  def start(self):+    cmd = ['kubectl', 'proxy', '--port=%d' % self.port]+    self.p = subprocess.Popen(args=cmd)+    self.started = True+    time.sleep(2)+    print '..Started'++  def get_port(self):+    return self.port++  def is_started(self):+    return self.started++  def __del__(self):+    if self.p is not None:+      print 'Shutting down Kubernetes proxy..'+      self.p.kill()+++class TestSettings:++  def __init__(self, build_docker_image, test_poll_interval_secs,+               test_duration_secs, kubernetes_proxy_port):+    self.build_docker_image = build_docker_image+    self.test_poll_interval_secs = test_poll_interval_secs+    self.test_duration_secs = test_duration_secs+    self.kubernetes_proxy_port = kubernetes_proxy_port+++class GkeSettings:++  def __init__(self, project_id, docker_image_name):+    self.project_id = project_id+    self.docker_image_name = docker_image_name+    self.tag_name = 'gcr.io/%s/%s' % (project_id, docker_image_name)+++class BigQuerySettings:++  def __init__(self, run_id, dataset_id, summary_table_id, qps_table_id):+    self.run_id = run_id+    self.dataset_id = dataset_id+    self.summary_table_id = summary_table_id+    self.qps_table_id = qps_table_id+++class StressServerSettings:++  def __init__(self, server_pod_name, server_port):+    self.server_pod_name = server_pod_name+    self.server_port = server_port+++class StressClientSettings:++  def __init__(self, num_clients, client_pod_name_prefix, server_pod_name,+               server_port, metrics_port, metrics_collection_interval_secs,+               stress_client_poll_interval_secs, num_channels_per_server,+               num_stubs_per_channel, test_cases_str):+    self.num_clients = num_clients+    self.client_pod_name_prefix = client_pod_name_prefix+    self.server_pod_name = server_pod_name+    self.server_port = server_port+    self.metrics_port = metrics_port+    self.metrics_collection_interval_secs = metrics_collection_interval_secs+    self.stress_client_poll_interval_secs = stress_client_poll_interval_secs+    self.num_channels_per_server = num_channels_per_server+    self.num_stubs_per_channel = num_stubs_per_channel+    self.test_cases_str = test_cases_str++    # == Derived properties ==+    # Note: Client can accept a list of server addresses (a comma separated list+    # of 'server_name:server_port'). In this case, we only have one server+    # address to pass+    self.server_addresses = '%s.default.svc.cluster.local:%d' % (+        server_pod_name, server_port)+    self.client_pod_names_list = ['%s-%d' % (client_pod_name_prefix, i)+                                  for i in range(1, num_clients + 1)]+++def _build_docker_image(image_name, tag_name):+  """""" Build the docker image and add a tag """"""+  print 'Building docker image: %s' % image_name+  os.environ['INTEROP_IMAGE'] = image_name+  # Note that 'BASE_NAME' HAS to be 'grpc_interop_stress_cxx' since the script+  # build_interop_stress_image.sh invokes the following script:+  #   tools/dockerfile/$BASE_NAME/build_interop_stress.sh+  os.environ['BASE_NAME'] = 'grpc_interop_stress_cxx'+  cmd = ['tools/jenkins/build_interop_stress_image.sh']+  p = subprocess.Popen(args=cmd)+  retcode = p.wait()+  if retcode != 0:+    print 'Error in building docker image'+    return False++  print 'Adding an additional tag %s to the image %s' % (tag_name, image_name)+  cmd = ['docker', 'tag', '-f', image_name, tag_name]+  p = subprocess.Popen(args=cmd)",you could also do subprocess.call()https://github.com/grpc/grpc/blob/master/tools/run_tests/dockerjob.py#L92,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/5402,54296915,2016-02-26T20:24:04Z,tools/gke/kubernetes_api.py,"@@ -1,5 +1,5 @@ #!/usr/bin/env python2.7","both big_query_utils.py and kubernetes_api.py are actually very generic and can be used by other tests as well. Do you recommend I move them both under tools/cloud"" ?",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/5402,54325888,2016-02-27T02:14:55Z,tools/run_tests/stress_test/run_client.py,"@@ -0,0 +1,188 @@+#!/usr/bin/env python2.7+# Copyright 2015-2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import datetime+import os+import re+import select+import subprocess+import sys+import time++from stress_test_utils import EventType+from stress_test_utils import BigQueryHelper+++# TODO (sree): Write a python grpc client to directly query the metrics instead+# of calling metrics_client+def _get_qps(metrics_cmd):+  qps = 0+  try:+    # Note: gpr_log() writes even non-error messages to stderr stream. So it is +    # important that we set stderr=subprocess.STDOUT+    p = subprocess.Popen(args=metrics_cmd,+                         stdout=subprocess.PIPE,+                         stderr=subprocess.STDOUT)+    retcode = p.wait()+    (out_str, err_str) = p.communicate()+    if retcode != 0:+      print 'Error in reading metrics information'+      print 'Output: ', out_str+    else:+      # The overall qps is printed at the end of the line+      m = re.search('\d+$', out_str)+      qps = int(m.group()) if m else 0+  except Exception as ex:+    print 'Exception while reading metrics information: ' + str(ex)+  return qps+++def run_client():+  """"""This is a wrapper around the stress test client and performs the following:+      1) Create the following two tables in Big Query:+         (i) Summary table: To record events like the test started, completed+                            successfully or failed+        (ii) Qps table: To periodically record the QPS sent by this client+      2) Start the stress test client and add a row in the Big Query summary+         table+      3) Once every few seconds (as specificed by the poll_interval_secs) poll+         the status of the stress test client process and perform the+         following:+          3.1) If the process is still running, get the current qps by invoking+               the metrics client program and add a row in the Big Query+               Qps table. Sleep for a duration specified by poll_interval_secs+          3.2) If the process exited successfully, add a row in the Big Query+               Summary table and exit+          3.3) If the process failed, add a row in Big Query summary table and+               wait forever.+               NOTE: This script typically runs inside a GKE pod which means+               that the pod gets destroyed when the script exits. However, in+               case the stress test client fails, we would not want the pod to+               be destroyed (since we might want to connect to the pod for+               examining logs). This is the reason why the script waits forever+               in case of failures+  """"""+  env = dict(os.environ)+  image_type = env['STRESS_TEST_IMAGE_TYPE']+  image_name = env['STRESS_TEST_IMAGE']+  args_str = env['STRESS_TEST_ARGS_STR']+  metrics_client_image = env['METRICS_CLIENT_IMAGE']+  metrics_client_args_str = env['METRICS_CLIENT_ARGS_STR']+  run_id = env['RUN_ID']+  pod_name = env['POD_NAME']+  logfile_name = env.get('LOGFILE_NAME')+  poll_interval_secs = float(env['POLL_INTERVAL_SECS'])+  project_id = env['GCP_PROJECT_ID']+  dataset_id = env['DATASET_ID']+  summary_table_id = env['SUMMARY_TABLE_ID']+  qps_table_id = env['QPS_TABLE_ID']++  bq_helper = BigQueryHelper(run_id, image_type, pod_name, project_id,+                             dataset_id, summary_table_id, qps_table_id)+  bq_helper.initialize()++  # Create BigQuery Dataset and Tables: Summary Table and Metrics Table+  if not bq_helper.setup_tables():+    print 'Error in creating BigQuery tables'+    return++  start_time = datetime.datetime.now()++  logfile = None+  details = 'Logging to stdout'+  if logfile_name is not None:+    print 'Opening logfile: %s ...' % logfile_name+    details = 'Logfile: %s' % logfile_name+    logfile = open(logfile_name, 'w')++  # Update status that the test is starting (in the status table)+  bq_helper.insert_summary_row(EventType.STARTING, details)++  metrics_cmd = [metrics_client_image+                ] + [x for x in metrics_client_args_str.split()]+  stress_cmd = [image_name] + [x for x in args_str.split()]++  print 'Launching process %s ...' % stress_cmd+  stress_p = subprocess.Popen(args=stress_cmd,",Not by much. There are a few things that jobset doesn't give me (which I could have added to jobset) like for example: I want the output from stress_test on stdout (or to a well-known/configurable file path - while jobset writes stdout to a temp file)..I need to read the results from metrics_client's stdout (i.e pipe the results back) and parse them before uploading to bigquery - jobset doesn't have this ... etc..Just seemed easier to directly call Subprocess.Popen ..,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5466,54491549,2016-02-29T22:37:46Z,tools/run_tests/distribtest_targets.py,"@@ -97,7 +97,14 @@ def build_jobspec(self):           ['test/distrib/csharp/run_distrib_test.sh'],           environ={'EXTERNAL_GIT_ROOT': '../../..'})     else:","Should this not be `elif self.platform == 'windows':`, with the `else:` that raises an exception retained?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5466,54493533,2016-02-29T22:50:03Z,test/distrib/csharp/run_distrib_test.bat,"@@ -0,0 +1,21 @@+","We may want to extend the copyright checker to recognize batch files.Actually we probably want a whitelist of extensions that don't needcopyrights in the copyright checker (eg vcxproj, sln)On Mon, Feb 29, 2016, 2:39 PM Nathaniel Manista notifications@github.comwrote:> In test/distrib/csharp/run_distrib_test.bat> https://github.com/grpc/grpc/pull/5466#discussion_r54491761:> > > @@ -0,0 +1,21 @@> > +> > What's with a blank line at top-of-file? Should this file not have a> license header like almost every other in the codebase?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5466/files#r54491761.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5478,54494497,2016-02-29T22:56:44Z,src/python/grpcio/grpc/_cython/_cygrpc/completion_queue.pyx.pxi,"@@ -137,10 +137,14 @@ cdef class CompletionQueue:       pass    def __dealloc__(self):+    cdef gpr_timespec c_deadline = gpr_inf_future(GPR_CLOCK_REALTIME)     if self.c_completion_queue != NULL:-      # Ensure shutdown, pump the queue+      # Ensure shutdown       if not self.is_shutting_down:-        self.shutdown()+        grpc_completion_queue_shutdown(self.c_completion_queue)+      # Pump the queue       while not self.is_shutdown:-        self.poll()+        event = grpc_completion_queue_next(+            self.c_completion_queue, c_deadline, NULL)+        self._interpret_event(event)",`_interpret_event` is `cdef` (so it should ostensibly be 'safe' as long as it itself calls no `def` methods on `self`) and has side-effects that notify other objects that are subscribed via the tag (e.g. servers).,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/5488,54618889,2016-03-01T19:15:28Z,package.xml,"@@ -10,11 +10,11 @@   <email>grpc-packages@google.com</email>   <active>yes</active>  </lead>- <date>2016-02-24</date>+ <date>2016-03-01</date>  <time>16:06:07</time>  <version>-  <release>0.8.0</release>-  <api>0.8.0</api>+  <release>0.9.0</release>",Sounds fair to me. The package has come along far enough. I can update it to 0.14 for the next one.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5489,54630527,2016-03-01T20:32:28Z,src/core/surface/completion_queue.c,"@@ -94,7 +94,7 @@ static void on_pollset_shutdown_done(grpc_exec_ctx *exec_ctx, void *cc, void grpc_cq_global_init(void) { gpr_mu_init(&g_freelist_mu); }  void grpc_cq_global_shutdown(void) {-  gpr_mu_destroy(&g_freelist_mu);","This doesn't seem like a fix at all: if there's a thread that's able to manipulate the freelist here, then it's still able to manipulate the freelist after the unlock.Suggest instead doing something similar to iomgr and waiting for all completion queues to be destroyed before proceeding with shutdown.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5524,54663796,2016-03-02T00:57:22Z,templates/README.md,"@@ -20,64 +20,77 @@ Only the structure of the project file is relevant to the template. The actual list of source code and targets isn't.  We currently have template files for GNU Make, Visual Studio 2010 to 2015,-and Bazel. In the future, we would like to expand to generating gyp or cmake+and [Bazel](http://bazel.io). In the future, we would like to expand to+generating [gyp](https://gyp.gsrc.io/) or [cmake](https://cmake.org)","Only for Node. I'm not sure if gyp for C++ is desirable. I suspect not, butback in they day we thought it might be.On Tue, Mar 1, 2016, 4:54 PM Nicolas Noble notifications@github.com wrote:> In templates/README.md> https://github.com/grpc/grpc/pull/5524#discussion_r54663529:> > > @@ -20,64 +20,77 @@ Only the structure of the project file is relevant to the template. The actual> >  list of source code and targets isn't.> > > >  We currently have template files for GNU Make, Visual Studio 2010 to 2015,> > -and Bazel. In the future, we would like to expand to generating gyp or cmake> > +and [Bazel](http://bazel.io). In the future, we would like to expand to> > +generating [gyp](https://gyp.gsrc.io/) or [cmake](https://cmake.org)> > We ARE generating gyp...> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5524/files#r54663529.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5524,54664228,2016-03-02T01:02:37Z,templates/README.md,"@@ -20,64 +20,77 @@ Only the structure of the project file is relevant to the template. The actual list of source code and targets isn't.  We currently have template files for GNU Make, Visual Studio 2010 to 2015,-and Bazel. In the future, we would like to expand to generating gyp or cmake+and [Bazel](http://bazel.io). In the future, we would like to expand to+generating [gyp](https://gyp.gsrc.io/) or [cmake](https://cmake.org)","I have a PR open for cmake also.On Tue, Mar 1, 2016, 4:59 PM Nicolas Noble notifications@github.com wrote:> In templates/README.md> https://github.com/grpc/grpc/pull/5524#discussion_r54663951:> > > @@ -20,64 +20,77 @@ Only the structure of the project file is relevant to the template. The actual> >  list of source code and targets isn't.> > > >  We currently have template files for GNU Make, Visual Studio 2010 to 2015,> > -and Bazel. In the future, we would like to expand to generating gyp or cmake> > +and [Bazel](http://bazel.io). In the future, we would like to expand to> > +generating [gyp](https://gyp.gsrc.io/) or [cmake](https://cmake.org)> > It's really an epsilon away from being standalone, I'd say. But fair> enough, it's only for node at the moment.> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5524/files#r54663951.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5535,54782213,2016-03-02T20:03:27Z,src/core/transport/chttp2_transport.c,"@@ -521,7 +521,6 @@ static void destroy_stream(grpc_exec_ctx *exec_ctx, grpc_transport *gt,                                            s->global.id) == NULL);   } -  grpc_chttp2_list_remove_writable_stream(&t->global, &s->global);","We used to not hold a ref while streams were in the writable list.=> A stream may be destroyed while in the writable list.=> We might need some cleanup here.Now we hold a ref, so it's impossible to get here while the stream is flagged writable, so there's no need for the cleanup.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5541,54803716,2016-03-02T22:30:05Z,tools/run_tests/run_python.sh,"@@ -42,7 +42,12 @@ export LDFLAGS=""-L$ROOT/libs/$CONFIG"" export GRPC_PYTHON_BUILD_WITH_CYTHON=1 export GRPC_PYTHON_ENABLE_CYTHON_TRACING=1 -tox+if [ ""$CONFIG"" = ""gcov"" ]","for code coverage we use the commands from tox.ini to run the tests and generate the coverage report.For a ""regular test run"" (=opt or dbg), we are running tests in parallel and tox cannot handle that. So we make sure everything is built in advance and just run the test here.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5541,54810709,2016-03-02T23:22:15Z,src/python/grpcio/tests/unit/_sanity/_sanity_test.py,"@@ -0,0 +1,51 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import json+from tests import _loader+import unittest+++class Sanity(unittest.TestCase):++  def testTestsJsonUpToDate(self):+    """"""Autodiscovers all test suites and checks that tests.json is up to date""""""+    loader = _loader.Loader()+    loader.loadTestsFromNames(['tests'])+    test_suite_names = [c.id().rsplit('.', 1)[0]","Please avoid single-letter identifiers.The values assigned to `c` are `unittest.TestCase` subclasses, right? How about `test_case_class` for a name? You can win some horizontal space by line-wrapping immediately after `[`:```    test_suite_names = [        test_case_class.id().rsplit('.', 1)[0]        for test_case_class in _loader.iterate_suite_cases(loader.suite)]```.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5541,54811430,2016-03-02T23:28:28Z,src/python/grpcio/tests/unit/_sanity/_sanity_test.py,"@@ -0,0 +1,51 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import json+from tests import _loader","Standard-library imports come first, then local imports. Also you should import any underscore-prefixed attribute of another code element.I think these imports should be```import jsonimport unittestimport tests```and then below where you currently have `_loader.Loader()` you would just have `tests.Loader()`.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/5545,54825336,2016-03-03T01:49:18Z,src/core/iomgr/iocp_windows.c,"@@ -140,10 +142,12 @@ void grpc_iocp_kick(void) {  void grpc_iocp_flush(void) {   grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;+  grpc_iocp_work_status work_status;    do {-    grpc_iocp_work(&exec_ctx, gpr_inf_past(GPR_CLOCK_MONOTONIC));-  } while (grpc_exec_ctx_flush(&exec_ctx));+    work_status = grpc_iocp_work(&exec_ctx, gpr_inf_past(GPR_CLOCK_MONOTONIC));+  } while (grpc_exec_ctx_flush(&exec_ctx) ||+           work_status == GRPC_IOCP_WORK_KICK);",Shouldn't the condition here reverted ? So the lazy check avoids calling the function first since we know it's not going to do anything anyway ?,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/5549,54836757,2016-03-03T05:11:25Z,test/cpp/end2end/async_end2end_test.cc,"@@ -807,7 +807,11 @@ class AsyncEnd2endServerTryCancelTest : public AsyncEnd2endTest {     EXPECT_FALSE(context->IsCancelled());     context->TryCancel();     gpr_log(GPR_INFO, ""Server called TryCancel()"");-    EXPECT_TRUE(context->IsCancelled());+    while (!context->IsCancelled()) {","I was initially thinking the same but when I reasoned about it some more, I felt that this is actually the correct thing to do.These tests were not intended to test the async'Ness of TryCancel () API; Instead, they are supposed to test that the RPC is cancelled properly (when using the C++ async APIs)  when the actual cancellation happens at various points of interest during processing the RPCs (i.e. see  CANCEL_BEFORE / CANCEL_AFTER and CANCEL_DURING_PROCESSING flags)If we let TryCancel() be async, it becomes harder to test CANCEL_BEFORE (and also CANCEL_AFTER scenarios).. Sure, it _feels_ like we are making the test  deterministic by snchronously waiting for TryCancel() to complete; but that's not the case; The CANCEL_DURING_PROCESSING cases are non deterministic (and are semantically equivalent to not Synchronously waiting for TryCancel() to actually cancel the RPC).",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5544,54841735,2016-03-03T06:48:34Z,src/objective-c/GRPCClient/private/GRPCCompletionQueue.m,"@@ -61,22 +70,24 @@ - (instancetype)init {       gDefaultConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);     });     dispatch_async(gDefaultConcurrentQueue, ^{+      gpr_timespec deadline = gpr_time_from_seconds(lTimeoutSecs, GPR_CLOCK_REALTIME);       while (YES) {-        // The following call blocks until an event is available.-        grpc_event event = grpc_completion_queue_next(unmanagedQueue,-                                                      gpr_inf_future(GPR_CLOCK_REALTIME),-                                                      NULL);+        // The following call blocks until an event is available or the deadline elapses.+        grpc_event event = grpc_completion_queue_next(unmanagedQueue, deadline, NULL);         GRPCQueueCompletionHandler handler;         switch (event.type) {-          case GRPC_OP_COMPLETE:+          case GRPC_OP_COMPLETE: // Falling through deliberately+          case GRPC_QUEUE_TIMEOUT:             handler = (__bridge_transfer GRPCQueueCompletionHandler)event.tag;-            handler(event.success);+            if (handler) {","In the current implementation, tag will be NULL on a TIMEOUT. However, this is not specified in the core surface and should not be relied upon. The tag or success value of the grpc_event is only valid on a GRPC_OP_COMPLETE. On a TIMEOUT or SHUTDOWN, only the type is technically valid.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5535,54845063,2016-03-03T07:41:21Z,src/core/iomgr/iomgr.c,"@@ -154,3 +159,14 @@ void grpc_iomgr_unregister_object(grpc_iomgr_object *obj) {   gpr_mu_unlock(&g_mu);   gpr_free(obj->name); }++bool grpc_iomgr_abort_on_leaks(void) {+  char *env = gpr_getenv(""GRPC_ABORT_ON_LEAKS"");+  if (env == NULL) return false;+  static const char *truthy[] = {""yes"",  ""Yes"",  ""YES"", ""true"",+                                 ""True"", ""TRUE"", ""1""};",classic,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/5560,54965909,2016-03-03T23:20:21Z,src/core/transport/transport.h,"@@ -139,8 +139,10 @@ typedef struct grpc_transport_op {   gpr_slice *goaway_message;   /** set the callback for accepting new streams;       this is a permanent callback, unlike the other one-shot closures */",the docstring seems misplaced with the introduction of the boolean guard (which isn't mentioned).,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5560,54981879,2016-03-04T02:10:54Z,src/core/transport/chttp2_transport.c,"@@ -997,15 +995,29 @@ static void perform_transport_op(grpc_exec_ctx *exec_ctx, grpc_transport *gt,     close_transport_locked(exec_ctx, t);   } -  unlock(exec_ctx, t);-   if (close_transport) {-    lock(t);     close_transport_locked(exec_ctx, t);-    unlock(exec_ctx, t);   } } +static void perform_transport_op(grpc_exec_ctx *exec_ctx, grpc_transport *gt,+                                 grpc_transport_op *op) {+  grpc_chttp2_transport *t = (grpc_chttp2_transport *)gt;++  lock(t);++  /* Let's be overly cautious: don't change any state while we're parsing */+  if (t->parsing_active) {+    GPR_ASSERT(t->post_parsing_op == NULL);+    t->post_parsing_op = gpr_malloc(sizeof(*op));+    memcpy(t->post_parsing_op, op, sizeof(*op));+  } else {","I don't think there's any case where we'd come down this path more thanonce during the same parse. If it ever became necessary we could add thenecessary extra machinery to make it work (either by merging ops orcreating a to-do list).Either seems like adding excess machinery too early however, and so I'mreluctant to do it until a use case arrives.On Thu, Mar 3, 2016, 5:16 PM Vijay Pai notifications@github.com wrote:> In src/core/transport/chttp2_transport.c> https://github.com/grpc/grpc/pull/5560#discussion_r54977577:> > >    }> >  }> > > > +static void perform_transport_op(grpc_exec_ctx *exec_ctx, grpc_transport *gt,> > -                                 grpc_transport_op *op) {> > -  grpc_chttp2_transport *t = (grpc_chttp2_transport *)gt;> >   +> > -  lock(t);> >   +> > -  /\* Let's be overly cautious: don't change any state while we're parsing */> > -  if (t->parsing_active) {> > -    GPR_ASSERT(t->post_parsing_op == NULL);> > -    t->post_parsing_op = gpr_malloc(sizeof(*op));> > -    memcpy(t->post_parsing_op, op, sizeof(*op));> > -  } else {> > Is it certain that this only gets called once wth parsing_active? Because> otherwise the code looks inconsistent with the comment (we are changing the> value of t->post_parsing_op after all).> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5560/files#r54977577.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5570,55066958,2016-03-04T18:20:03Z,test/cpp/qps/gen_build_yaml.py,"@@ -0,0 +1,270 @@+#!/usr/bin/env python2.7+# Copyright 2015-2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Generates the appropriate build.yaml data for performance tests.""""""++import yaml++SINGLE_MACHINE_CORES=8","It's run at build file generation time: we need build files to be the sameregardless of the machine they're generated on (for sanity).On Fri, Mar 4, 2016 at 10:13 AM Vijay Pai notifications@github.com wrote:> In test/cpp/qps/gen_build_yaml.py> https://github.com/grpc/grpc/pull/5570#discussion_r55065941:> > > +# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT> > +# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR> > +# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT> > +# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,> > +# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT> > +# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,> > +# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY> > +# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT> > +# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE> > +# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.> > +> > +""""""Generates the appropriate build.yaml data for performance tests.""""""> > +> > +import yaml> > +> > +SINGLE_MACHINE_CORES=8> > Why not multiprocessing.cpu_count() as in run_tests.py ?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5570/files#r55065941.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/5610,55105585,2016-03-04T23:42:10Z,src/node/src/client.js,"@@ -131,9 +131,69 @@ function ClientReadableStream(call, deserialize) {   this.finished = false;   this.reading = false;   this.deserialize = common.wrapIgnoreNull(deserialize);+  /* Status generated from reading messages from the server. Overrides the+   * status from the server if not OK */+  this.read_status = null;+  /* Status received from the server. */+  this.received_status = null; }  /**+ * Called when all messages from the server have been processed. The status+ * parameter indicates that the call should end with that status. status+ * defaults to OK if not provided.+ * @param {Object!} status The status that the call should end with+ */+function _readsDone(status) {+  /* jshint validthis: true */+  if (!status) {+    status = {code: grpc.status.OK, details: 'OK'};",What I have here is consistent with what I have in my server code. I think changing it belongs in another PR.,
10744406,LisaFC,https://api.github.com/repos/grpc/grpc/pulls/5601,55234336,2016-03-07T17:00:22Z,INSTALL.md,"@@ -32,6 +32,16 @@ terminal:  $ [sudo] xcode-select --install ``` +##Protoc++By default gRPC uses [protocol buffers](https://github.com/google/protobuf),+you will need the `protoc` compiler to generate stub server and client code.++If you compile from source, see below, the Makefile will automatically try+and compile the one present in third_party if you cloned the repository+recursively, and that it detects your system is lacking it.+","If you compile gRPC from source, as described below, the Makefile will automatically tryand compile the `protoc` in third_party if you cloned the repositoryrecursively and it detects that you don't already have it installed.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5625,55256615,2016-03-07T19:24:35Z,src/core/channel/subchannel_call_holder.c,"@@ -168,21 +168,23 @@ void grpc_subchannel_call_holder_perform_op(grpc_exec_ctx *exec_ctx,  static void subchannel_ready(grpc_exec_ctx *exec_ctx, void *arg, bool success) {   grpc_subchannel_call_holder *holder = arg;-  grpc_subchannel_call *call;   gpr_mu_lock(&holder->mu);   GPR_ASSERT(holder->creation_phase ==              GRPC_SUBCHANNEL_CALL_HOLDER_PICKING_SUBCHANNEL);-  call = GET_CALL(holder);-  GPR_ASSERT(call == NULL || call == CANCELLED_CALL);   holder->creation_phase = GRPC_SUBCHANNEL_CALL_HOLDER_NOT_CREATING;   if (holder->connected_subchannel == NULL) {     fail_locked(exec_ctx, holder);   } else {-    gpr_atm_rel_store(","So, there's a similar rel_store in line 156 above. Is that one not dangerous also?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5629,55287218,2016-03-07T22:48:56Z,src/python/grpcio/commands.py,"@@ -264,6 +264,41 @@ def run(self):       self.distribution.fetch_build_eggs(self.distribution.tests_require)  +class TestLite(setuptools.Command):+  """"""Command to run tests without fetching or building anything.""""""++  description = 'run tests without fetching or building anything.'+  user_options = []++  def initialize_options(self):+    pass++  def finalize_options(self):+    # distutils requires this override.+    pass++  def run(self):+    self._add_eggs_to_path()++    import tests+    loader = tests.Loader()+    loader.loadTestsFromNames(['tests'])+    runner = tests.Runner()+    result = runner.run(loader.suite)+    if not result.wasSuccessful():+      sys.exit(1)","Could we change this to `sys.exit('Test failure')`? If we need to make it any more detailed we can do so, but right now I'd rather like to see Python provide, independent of the runner behavior, a little bit more than just an error code on exit.",
10744406,LisaFC,https://api.github.com/repos/grpc/grpc/pulls/5632,55356991,2016-03-08T13:18:57Z,src/php/README.md,"@@ -79,58 +88,96 @@ $ make $ sudo make install ``` +### Update php.ini+ Add this line to your `php.ini` file, e.g. `/etc/php5/cli/php.ini`  ```sh extension=grpc.so ``` -Install Composer+## Unit Tests++You will need the source code to run tests++```sh+$ git clone https://github.com/grpc/grpc.git+$ cd grpc+$ git pull --recurse-submodules && git submodule update --init --recursive+```++Run unit tests  ```sh $ cd grpc/src/php+$ ./bin/run_tests.sh+```++## Generated Code Tests++### Composer++You need to install `composer`, to pull in some runtime dependencies based on the `composer.json` file.++```sh $ curl -sS https://getcomposer.org/installer | php $ sudo mv composer.phar /usr/local/bin/composer++$ cd grpc/src/php $ composer install ``` -## Unit Tests+### Protobuf compiler -Run unit tests+You need the install the protobuf compiler, `protoc`, 3.0.0+.++If you had compiled the gRPC C core library from source above, the `protoc` binary should have been installed as well. In the case it wasn't, you can run the following commands to install it.","If you compiled the gRPC C core library from source above, the `protoc` binary should have been installed as well. If it hasn't been installed, you can run the following commands to install it.",
10744406,LisaFC,https://api.github.com/repos/grpc/grpc/pulls/5632,55359008,2016-03-08T13:39:07Z,src/php/README.md,"@@ -79,58 +88,96 @@ $ make $ sudo make install ``` +### Update php.ini+ Add this line to your `php.ini` file, e.g. `/etc/php5/cli/php.ini`  ```sh extension=grpc.so ``` -Install Composer+## Unit Tests++You will need the source code to run tests++```sh+$ git clone https://github.com/grpc/grpc.git+$ cd grpc+$ git pull --recurse-submodules && git submodule update --init --recursive+```++Run unit tests  ```sh $ cd grpc/src/php+$ ./bin/run_tests.sh+```++## Generated Code Tests++### Composer++You need to install `composer`, to pull in some runtime dependencies based on the `composer.json` file.++```sh $ curl -sS https://getcomposer.org/installer | php $ sudo mv composer.phar /usr/local/bin/composer++$ cd grpc/src/php $ composer install ``` -## Unit Tests+### Protobuf compiler -Run unit tests+You need the install the protobuf compiler, `protoc`, 3.0.0+.++If you had compiled the gRPC C core library from source above, the `protoc` binary should have been installed as well. In the case it wasn't, you can run the following commands to install it.  ```sh-$ cd grpc/src/php-$ ./bin/run_tests.sh+$ cd grpc/third_party/protobuf+$ sudo make install   # 'make' should have been run by core grpc ``` -## Generated Code Tests+Or you can download a `protoc` binaries from [here](https://github.com/google/protobuf/releases).+ -Install `protoc-gen-php`+### PHP protobuf compiler++You need to install `protoc-gen-php`, so that you can generate stub classes `.php` files from service definition `.proto` files.",You need to install `protoc-gen-php` to generate stub class `.php` files from service definition `.proto` files.,
8943572,carl-mastrangelo,https://api.github.com/repos/grpc/grpc/pulls/5641,55374187,2016-03-08T15:26:30Z,doc/compression.md,"@@ -0,0 +1,105 @@+## **gRPC Compression**++The keywords ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"",+""SHOULD NOT"", ""RECOMMENDED"",  ""MAY"", and ""OPTIONAL"" in this document are to be+interpreted as described in [RFC 2119](http://www.ietf.org/rfc/rfc2119.txt).++### Intent++Compression is used to reduce the amount of bandwidth used between peers. The+compression supported by gRPC acts _at the individual message level_, taking+_message_ [as defined in the wire format+document](PROTOCOL-HTTP2.md).++The implementation supports different compression algorithms. A _default+compression level_, to be used in the absence of message-specific settings, MAY+be specified for during channel creation.++The ability to control compression settings per call and to enable/disable+compression on a per message basis MAY be used to prevent CRIME/BEAST attacks.+It also allows for asymmetric compression communication, whereby a response MAY+be compressed differently, if at all.++### Specification++Compression MAY be configured by the Client Application by calling the+appropriate API method. There are two scenarios where compression MAY be+configured:+++  At channel creation time, which sets the channel default compression and+   therefore the compression that SHALL be used in the absence of per-RPC+   compression configuration.++  At response time, via:+   +  For unary RPCs, the {Client,Server}Context instance. +   +  For streaming RPCs, the {Client,Server}Writer instance. In this case,+      configuration is reduced to disabling compression altogether.++### Compression Method Asymmetry Between Peers++A gRPC peer MAY choose to respond using a different compression method to that+of the request, including not performing any compression, regardless of channel+and RPC settings (for example, if compression would result in small or negative+gains).++A compressed message from a client with an algorithm unsupported by a server,+WILL result in an INVALID\_ARGUMENT error, alongside the receiving peer's+`grpc-accept-encoding` header specifying the algorithms it accepts. If an+INTERNAL error is returned from the server despite having used one of the+algorithms from the `grpc-accept-encoding h`eader, the cause MUST NOT be related+to compression. Data sent from a server compressed with an algorithm not+supported by the client will also result in an INTERNAL error.","Again, clarification:  does this result in an internal error on the client side, or is the server library returning this error back to the server application?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5628,55470656,2016-03-09T04:24:21Z,CONTRIBUTING.md,"@@ -36,9 +36,13 @@ In order to run most of the available tests, one would need to run:  `./tools/run_tests/run_tests.py` -If you want to run all the possible tests for any of the languages {c, c++, node, php, python}, do this:+If you want to run tests for any of the languages {c, c++, node, php, python}, do this:",csharp missing in the list.,
10744406,LisaFC,https://api.github.com/repos/grpc/grpc/pulls/5668,55547732,2016-03-09T16:42:11Z,src/cpp/README.md,"@@ -6,3 +6,62 @@ This directory contains source code for C++ implementation of gRPC. #Status  Beta++#Pre-requisites++##Linux++```sh+ $ [sudo] apt-get install build-essential autoconf libtool+```++##Mac OSX++For a Mac system, git is not available by default. You will first need to+install Xcode from the Mac AppStore and then run the following command from a+terminal:++```sh+ $ [sudo] xcode-select --install+```++##Protoc++By default gRPC uses [protocol buffers](https://github.com/google/protobuf),+you will need the `protoc` compiler to generate stub server and client code.++If you compile gRPC from source, as described below, the Makefile will+automatically try and compile the `protoc` in third party if you cloned the+repository recursively and it detects that you don't already have it+installed.++If it hasn't been installed, you can run the following commands to install it.++```sh+$ cd grpc/third_party/protobuf+$ sudo make install   # 'make' should have been run by core grpc+```++Alternatively, you can download `protoc` binaries from+[the protocol buffers Github repository](https://github.com/google/protobuf/releases).++#INSTALLATION++Currently to install gRPC for C++, you need to build from source as described below.++#Build from Source++```sh+ $ git clone https://github.com/grpc/grpc.git+ $ cd grpc+ $ git submodule update --init+ $ make+ $ [sudo] make install+```++#DOCUMENTATION++- The gRPC C++ refenrence documentation is available online at","We actually have a bit more documentation than that - how about something like:You can find out how to build and run our simplest gRPC C++ example in our [C++ quick start](https://github.com/grpc/grpc/tree/{{ site.data.config.grpc_release_branch }}/examples/cpp).For more detailed documentation on using gRPC in C++ , see our main documentation site at [grpc.io](http://grpc.io), specifically:- [Overview](http://www.grpc.io/docs/): An introduction to gRPC with a simple Hello World example in all our supported languages, including C++.- [gRPC Basics - C++](http://www.grpc.io/docs/tutorials/basic/c.html): A tutorial that steps you through creating a simple gRPC C++ example application.- [Asynchronous Basics - C++](http://www.grpc.io/docs/tutorials/async/helloasync-cpp.html): A tutorial that shows you how to use gRPC C++'s asynchronous/non-blocking APIs.",
10744406,LisaFC,https://api.github.com/repos/grpc/grpc/pulls/5668,55547891,2016-03-09T16:42:54Z,src/cpp/README.md,"@@ -6,3 +6,62 @@ This directory contains source code for C++ implementation of gRPC. #Status  Beta++#Pre-requisites++##Linux++```sh+ $ [sudo] apt-get install build-essential autoconf libtool+```++##Mac OSX++For a Mac system, git is not available by default. You will first need to+install Xcode from the Mac AppStore and then run the following command from a+terminal:++```sh+ $ [sudo] xcode-select --install+```++##Protoc++By default gRPC uses [protocol buffers](https://github.com/google/protobuf),+you will need the `protoc` compiler to generate stub server and client code.++If you compile gRPC from source, as described below, the Makefile will+automatically try and compile the `protoc` in third party if you cloned the+repository recursively and it detects that you don't already have it+installed.++If it hasn't been installed, you can run the following commands to install it.++```sh+$ cd grpc/third_party/protobuf+$ sudo make install   # 'make' should have been run by core grpc+```++Alternatively, you can download `protoc` binaries from+[the protocol buffers Github repository](https://github.com/google/protobuf/releases).++#INSTALLATION++Currently to install gRPC for C++, you need to build from source as described below.++#Build from Source++```sh+ $ git clone https://github.com/grpc/grpc.git+ $ cd grpc+ $ git submodule update --init+ $ make+ $ [sudo] make install+```++#DOCUMENTATION++- The gRPC C++ refenrence documentation is available online at+  [grpc.io](http://www.grpc.io/docs/tutorials/basic/c.html)+- [Helloworld example](../../examples/cpp/helloworld)+",Would it be useful to add an Examples heading as well. Eg: # ExamplesCode examples for gRPC C++ live in this repository's [examples/cpp](https://github.com/grpc/grpc/tree/{{ site.data.config.grpc_release_branch }}/examples/cpp) directory.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5592,55643418,2016-03-10T07:45:38Z,src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h,"@@ -0,0 +1,43 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCCall.h""++/** Helpers for setting SSL Trusted Roots, Client Certificates, and Private Key */+@interface GRPCCall (ChannelCredentials)+++ (void)setSslPemRootCerts:(NSString *)pemRootCerts forHost:(NSString *)host;++ (void)setSslPemPrivateKey:(NSString *)pemPrivateKey forHost:(NSString *)host;++ (void)setSslPemCertChain:(NSString *)pemCertChain forHost:(NSString *)host;","Would someone ever want to set a certificates chain without setting a private key, and vice versa?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5592,55644620,2016-03-10T08:01:29Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -127,8 +181,10 @@ - (GRPCChannel *)channel {         args[@GRPC_SSL_TARGET_NAME_OVERRIDE_ARG] = _hostNameOverride;       } +      grpc_channel_credentials *creds = [self channelCredentials:_pemRootCerts privateKey:_pemPrivateKey certChain: _pemCertChain];","`grpc_ssl_credentials_create` copies the content of the root certs, certificate chain, and private key. Because the majority of channels will use the default root certs, we want to have only a copy of the corresponding `grpc_channel_credentials` in memory (instead of one per channel).For the non-default case it's not bad, because we have just one channel per host. But `-[GRPCHost channel]` is called lazily, only when the first RPC to that host is to be sent. It's preferable if we create the `grpc_channel_credentials` object eagerly instead: If there's something wrong with the certificates or the key, debugging is much easier if the failure shows up when the user calls `[GRPCCall set... forHost:...]`, rather than later on upon starting an RPC.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5628,55689342,2016-03-10T14:49:47Z,CONTRIBUTING.md,"@@ -36,9 +36,13 @@ In order to run most of the available tests, one would need to run:  `./tools/run_tests/run_tests.py` -If you want to run all the possible tests for any of the languages {c, c++, node, php, python}, do this:+If you want to run tests for any of the languages {all, c, c++, csharp, node, objc, php, python, ruby}, do this:","""all"" is only supported for -c gcov (only as a workaround and that change is not even merged yet). Please remove ""all"" from the list",
110123,pquerna,https://api.github.com/repos/grpc/grpc/pulls/5592,55696884,2016-03-10T15:35:35Z,src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h,"@@ -0,0 +1,43 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCCall.h""++/** Helpers for setting SSL Trusted Roots, Client Certificates, and Private Key */+@interface GRPCCall (ChannelCredentials)+++ (void)setSslPemRootCerts:(NSString *)pemRootCerts forHost:(NSString *)host;++ (void)setSslPemPrivateKey:(NSString *)pemPrivateKey forHost:(NSString *)host;++ (void)setSslPemCertChain:(NSString *)pemCertChain forHost:(NSString *)host;","A client certificate and the associated private key are always used together. For example, in the grpc-go API, they are always used together as a constructor for a credentials object:https://godoc.org/google.golang.org/grpc/credentials#NewServerTLSFromCertI'll change it to be one function, that takes both the client certificate and private key at the same time.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5678,55751556,2016-03-10T21:22:15Z,src/ruby/lib/grpc/generic/rpc_server.rb,"@@ -413,9 +428,9 @@ def implemented?(an_rpc)      # handles calls to the server     def loop_handle_server_calls-      fail 'not running' unless @running+      fail 'not started' if running_state == :not_started       loop_tag = Object.new-      until stopped?+      while running_state == :running",is there a concept of volatile in ruby? technically just reading  running_state is unsafe.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5720,55904736,2016-03-11T23:30:22Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -354,8 +357,29 @@ - (void)startWithWriteable:(id<GRXWriteable>)writeable {   _retainSelf = self;    _responseWriteable = [[GRXConcurrentWriteable alloc] initWithWriteable:writeable];++  _wrappedCall = [[GRPCWrappedCall alloc] initWithHost:_host path:_path];+  NSAssert(_wrappedCall, @""Error allocating RPC objects. Low memory?"");+   [self sendHeaders:_requestHeaders];   [self invokeCall];+  // TODO(jcanizales): Extract this logic somewhere common.+  NSString *host = [NSURL URLWithString:[@""https://"" stringByAppendingString:_host]].host;+  if (!host) {+    // TODO(jcanizales): Check this on init.+    [NSException raise:NSInvalidArgumentException format:@""host of %@ is nil"", _host];+  }+  __weak typeof(self) weakSelf = self;+  _connectivityMonitor = [GRPCConnectivityMonitor monitorWithHost:host];","This is interesting:> From my (adamk) testing on Snow Leopard, 0.0.0.0 seems to be reachable if any network connection is available.From my tests, it makes a difference if the server is IPv6-only and the device's local networks only supports IPv4: `SCNetworkReachability` will tell you the server isn't reachable. So I rather keep it this way for now. If `SCNetworkReachability` or the underlying `gethostbyname` isn't smart about caching results, and it makes a noticeable impact, we can tune it. And all things said, the real fix for this problem is in the C gRPC library (and will be done there), at which point we can revert this :)",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5592,55915234,2016-03-12T03:35:04Z,src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h,"@@ -0,0 +1,56 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCCall.h""++/** Helpers for setting SSL Trusted Roots, Client Certificates, and Private Key */","General question re naming: Should we call it ""SSL"" or ""TLS""? IIUC, ""TLS"" is more accurate, but more people know right away what ""SSL"" means.@jtattermusch: Do you know what other wrapping languages use? C uses SSL. @jboeuf thoughts?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5592,55915759,2016-03-12T04:15:35Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -127,9 +205,14 @@ - (GRPCChannel *)channel {         args[@GRPC_SSL_TARGET_NAME_OVERRIDE_ARG] = _hostNameOverride;       } -      _channel = [GRPCChannel secureChannelWithHost:_address-                                 pathToCertificates:_pathToCertificates-                                        channelArgs:args];+      @synchronized(self) {+        if (_channelCreds == nil) {+          [self setSSLCredentials:nil withPrivateKey:nil withCertChain:nil error:nil];+        }+        _channel = [GRPCChannel secureChannelWithHost:_address+                                          credentials:_channelCreds+                                          channelArgs:args];+      }","It's preferable to leave calls to other classes out of the `synchronized` block, so that a reader can easily tell there's no possibility of deadlock. Something like:``` objcgrpc_channel_credentials *channelCreds = NULL;@synchronized(self) {  if (!_channelCreds) {    // Use default root certificates.    [self setSSLCredentials:nil withPrivateKey:nil withCertChain:nil error:nil];  }  channelCreds = _channelCreds;}_channel = [GRPCChannel secureChannelWithHost:_address                                  credentials:channelCreds                                  channelArgs:args];```",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5592,55941740,2016-03-13T18:48:46Z,src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h,"@@ -0,0 +1,56 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCCall.h""++/** Helpers for setting SSL Trusted Roots, Client Certificates, and Private Key */","I think the right terminology is TLS, but C core happens to use SSL in thenames. I think gRPC Java might be using more accurate terminology.On Fri, Mar 11, 2016 at 7:35 PM, Jorge Canizales notifications@github.comwrote:> In src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h> https://github.com/grpc/grpc/pull/5592#discussion_r55915234:> > > - \* ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT> > - \* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR> > - \* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT> > - \* OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,> > - \* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT> > - \* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,> > - \* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY> > - \* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT> > - \* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE> > - \* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.> > - *> > - _/> >   +> >   +#import ""GRPCCall.h""> >   +> >   +/_\* Helpers for setting SSL Trusted Roots, Client Certificates, and Private Key */> > General question re naming: Should we call it ""SSL"" or ""TLS""? IIUC, ""TLS""> is more accurate, but more people know right away what ""SSL"" means.> > @jtattermusch https://github.com/jtattermusch: Do you know what other> wrapping languages use? C uses SSL. @jboeuf https://github.com/jboeuf> thoughts?> > —> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5592/files#r55915234.",
110123,pquerna,https://api.github.com/repos/grpc/grpc/pulls/5592,55942956,2016-03-13T20:16:02Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -127,9 +205,14 @@ - (GRPCChannel *)channel {         args[@GRPC_SSL_TARGET_NAME_OVERRIDE_ARG] = _hostNameOverride;       } -      _channel = [GRPCChannel secureChannelWithHost:_address-                                 pathToCertificates:_pathToCertificates-                                        channelArgs:args];+      @synchronized(self) {+        if (_channelCreds == nil) {+          [self setSSLCredentials:nil withPrivateKey:nil withCertChain:nil error:nil];+        }+        _channel = [GRPCChannel secureChannelWithHost:_address+                                          credentials:_channelCreds+                                          channelArgs:args];+      }","Copying the `channelCreds` pointer to a local pointer creates a race condition with the `grpc_channel_credentials_release` in `setSSLCredentials` above.Options:1) If we could use `grpc_channel_credentials_ref`, we could safely copy the channel credentials locally, but `grpc_channel_credentials_ref` is not an exported function from the C-core.  The C-core doesn't export direct ref functions currently, so doesn't seem like the right path.2) Could add reference counting in GRPCHost to guard the calling of `grpc_channel_credentials_release`3) Document that `setSSLCredentials` is not  multi-threaded thread safe. (and remove the existing `@synchronized` from it4) keep the `@synchronized` with the current scope.2 is just a few more lines of code, 4 is the most simple.  Thoughts? Other ideas?",
110123,pquerna,https://api.github.com/repos/grpc/grpc/pulls/5592,55943022,2016-03-13T20:21:46Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -107,6 +115,76 @@ - (grpc_call *)unmanagedCallWithPath:(NSString *)path completionQueue:(GRPCCompl                                   gpr_inf_future(GPR_CLOCK_REALTIME), NULL); } ++- (BOOL)setSSLCredentials:(nullable NSString *)pemRootCerts+           withPrivateKey:(nullable NSString *)pemPrivateKey+            withCertChain:(nullable NSString *)pemCertChain+                    error:(NSError **)errorPtr {+  static NSData *kDefaultRootsASCII;+  static NSError *kDefaultRootsError;+  static dispatch_once_t loading;+  dispatch_once(&loading, ^{+    NSString *defaultPath = @""gRPCCertificates.bundle/roots""; // .pem+    // Do not use NSBundle.mainBundle, as it's nil for tests of library projects.+    NSBundle *bundle = [NSBundle bundleForClass:self.class];+    NSString *path = [bundle pathForResource:defaultPath ofType:@""pem""];+    NSError *error;+    // Files in PEM format can have non-ASCII characters in their comments (e.g. for the name of the+    // issuer). Load them as UTF8 and produce an ASCII equivalent.+    NSString *contentInUTF8 = [NSString stringWithContentsOfFile:path+                                                        encoding:NSUTF8StringEncoding+                                                           error:&error];","So, my thought was that having the `errorPtr` is a good API, and might be helpful in the future.Currently `grpc_ssl_credentials_create` doesn't validate its parameters, it just copies the bytes in.  But, it seems reasonable to believe in a future where there is a function that can validate the root certs / client certs / private key being correct, and therefore being able to add an error-return in a reasonable way.  ",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/5706,56047485,2016-03-14T18:07:03Z,include/grpc/grpc_security.h,"@@ -48,6 +48,7 @@ extern ""C"" {  #define GRPC_X509_CN_PROPERTY_NAME ""x509_common_name"" #define GRPC_X509_SAN_PROPERTY_NAME ""x509_subject_alternative_name""+#define GRPC_X509_BASE64_FINGERPRINT_PROPERTY_NAME ""x509_base64_fingerprint""","I don't think that we should expose this property which is very much specific for your use case. Instead, we should surface the whole peer PEM cert (and possibly the cert chain but we can do that later).",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5592,56103869,2016-03-15T01:30:03Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -127,9 +205,14 @@ - (GRPCChannel *)channel {         args[@GRPC_SSL_TARGET_NAME_OVERRIDE_ARG] = _hostNameOverride;       } -      _channel = [GRPCChannel secureChannelWithHost:_address-                                 pathToCertificates:_pathToCertificates-                                        channelArgs:args];+      @synchronized(self) {+        if (_channelCreds == nil) {+          [self setSSLCredentials:nil withPrivateKey:nil withCertChain:nil error:nil];+        }+        _channel = [GRPCChannel secureChannelWithHost:_address+                                          credentials:_channelCreds+                                          channelArgs:args];+      }",My feeling is that doing (2) by adding a `GRPCChannelCredentials` class that creates the C object and manages its life (and has `[GRPCChannelCredentials defaultCredentials]` and whatnot) is The Right Way (TM). But it might not be worth the hassle if we're just improving readability with it. So I'm happy with (4) too.,
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/5751,56134901,2016-03-15T09:30:03Z,src/csharp/Grpc.IntegrationTesting/ServicesGrpc.cs,"@@ -47,12 +47,28 @@ public interface IBenchmarkServiceClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IBenchmarkService     {       Task<global::Grpc.Testing.SimpleResponse> UnaryCall(global::Grpc.Testing.SimpleRequest request, ServerCallContext context);       Task StreamingCall(IAsyncStreamReader<global::Grpc.Testing.SimpleRequest> requestStream, IServerStreamWriter<global::Grpc.Testing.SimpleResponse> responseStream, ServerCallContext context);     } +    // server-side abstract class+    public abstract class BenchmarkServiceBase","I think it might be clearer to generate this without the ""Base"" part, given that this is the level of inheritance that most clients will actually want to deal with. So just ""BenchmarkService"" in this case, and ""Health"" above. I think the ""Impl"" suffix for the concrete implementation is okay though.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5755,56204723,2016-03-15T17:26:53Z,src/core/iomgr/tcp_client_posix.c,"@@ -83,6 +84,15 @@ static int prepare_socket(const struct sockaddr *addr, int fd) {             strerror(errno));     goto error;   }+#else+  if (!grpc_set_socket_nonblocking(fd, 1) || !grpc_set_socket_cloexec(fd, 1) ||","There's too much duplicated logic in this block.Can we instead introduce a function: `bool grpc_supports_low_latency(sockaddr *)` that returns true always for the `!GPR_HAVE_UNIX_SOCKET` case, and `addr->sa_family != AF_UNIX` for the `GPR_HAVE_UNIX_SOCKET` case?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5751,56218379,2016-03-15T18:42:34Z,src/csharp/Grpc.IntegrationTesting/ServicesGrpc.cs,"@@ -47,12 +47,28 @@ public interface IBenchmarkServiceClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IBenchmarkService     {       Task<global::Grpc.Testing.SimpleResponse> UnaryCall(global::Grpc.Testing.SimpleRequest request, ServerCallContext context);       Task StreamingCall(IAsyncStreamReader<global::Grpc.Testing.SimpleRequest> requestStream, IServerStreamWriter<global::Grpc.Testing.SimpleResponse> responseStream, ServerCallContext context);     } +    // server-side abstract class+    public abstract class BenchmarkServiceBase","I didn't use just ""Health"" because I think for many services the class name might collide with the namespace name (e.g. service math.Math which i think a pretty common pattern in .proto files). We didn't have this problem with the interface that has the ""I"" prefix.Do you see an issue with class name being the same as the package name?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5751,56219451,2016-03-15T18:48:30Z,src/csharp/Grpc.HealthCheck/HealthGrpc.cs,"@@ -38,11 +38,22 @@ public interface IHealthClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IHealth     {       Task<global::Grpc.Health.V1.HealthCheckResponse> Check(global::Grpc.Health.V1.HealthCheckRequest request, ServerCallContext context);     } +    // server-side abstract class+    public abstract class HealthBase","It feels like making the new class implement an interface that is going away soon isn't a good idea.How exactly would ""class HealthBase : IHealth"" be easier for people to transition? Please note that I now generate two overloads for the method BindService - `BindService(IBenchmarkService serviceImpl)` and `BindService(BenchmarkServiceBase serviceImpl)`.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5767,56265216,2016-03-16T00:32:13Z,src/python/grpcio/grpc/_cython/_cygrpc/records.pyx.pxi,"@@ -240,20 +252,27 @@ cdef class ByteBuffer:     cdef size_t data_slice_length     cdef void *data_slice_pointer     if self.c_byte_buffer != NULL:-      grpc_byte_buffer_reader_init(&reader, self.c_byte_buffer)+      with nogil:+        grpc_byte_buffer_reader_init(&reader, self.c_byte_buffer)       result = b""""-      while grpc_byte_buffer_reader_next(&reader, &data_slice):-        data_slice_pointer = gpr_slice_start_ptr(data_slice)-        data_slice_length = gpr_slice_length(data_slice)-        result += (<char *>data_slice_pointer)[:data_slice_length]-      grpc_byte_buffer_reader_destroy(&reader)+      with nogil:+        while grpc_byte_buffer_reader_next(&reader, &data_slice):+          data_slice_pointer = gpr_slice_start_ptr(data_slice)+          data_slice_length = gpr_slice_length(data_slice)+          with gil:",It was either that or adding yet another temporary. :-/,
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/5751,56290459,2016-03-16T07:21:14Z,src/csharp/Grpc.IntegrationTesting/ServicesGrpc.cs,"@@ -47,12 +47,28 @@ public interface IBenchmarkServiceClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IBenchmarkService     {       Task<global::Grpc.Testing.SimpleResponse> UnaryCall(global::Grpc.Testing.SimpleRequest request, ServerCallContext context);       Task StreamingCall(IAsyncStreamReader<global::Grpc.Testing.SimpleRequest> requestStream, IServerStreamWriter<global::Grpc.Testing.SimpleResponse> responseStream, ServerCallContext context);     } +    // server-side abstract class+    public abstract class BenchmarkServiceBase","Urgh - yes, that would be nasty. See https://blogs.msdn.microsoft.com/ericlippert/2010/03/09/do-not-name-a-class-the-same-as-its-namespace-part-oneThinking about this further, for the _server_-side, this is probably okay - because we genuinely expect users to derive from it in order to implement the service. For the _client_ side, we've already got the Client suffix, so we can presumably have an abstract HealthClient and an implementation of HealthClientImpl.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5786,56448922,2016-03-17T02:49:05Z,src/python/grpcio/tests/_runner.py,"@@ -43,13 +44,6 @@ from tests import _loader from tests import _result -# This number needs to be large enough to outpace output on stdout and stderr-# from the gRPC core, otherwise we could end up in a potential deadlock. This-# stems from the OS waiting on someone to clear a filled pipe buffer while the-# GIL is held from a write to stderr from gRPC core, but said someone is in-# Python code thus necessitating GIL acquisition.-_READ_BYTES = 2**20-  class CapturePipe(object):",Any need to rename this class?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5786,56449052,2016-03-17T02:50:46Z,src/python/grpcio/tests/_runner.py,"@@ -43,13 +44,6 @@ from tests import _loader from tests import _result -# This number needs to be large enough to outpace output on stdout and stderr-# from the gRPC core, otherwise we could end up in a potential deadlock. This-# stems from the OS waiting on someone to clear a filled pipe buffer while the-# GIL is held from a write to stderr from gRPC core, but said someone is in-# Python code thus necessitating GIL acquisition.-_READ_BYTES = 2**20-  class CapturePipe(object):   """"""A context-manager pipe to redirect output to a byte array.",How about removing no-longer-existent class-private attributes from this class-public doc string?Any need to update the summary line?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5788,56538660,2016-03-17T16:56:16Z,templates/tools/dockerfile/clang_update.include,"@@ -0,0 +1,32 @@+#=================+# Update clang to a version with improved tsan++RUN apt-get update && apt-get -y install python cmake && apt-get clean++RUN git clone -n -b release_38 http://llvm.org/git/llvm.git && ${'\\'}","On Thu, Mar 17, 2016 at 7:29 AM, Vijay Pai notifications@github.com wrote:> In templates/tools/dockerfile/clang_update.include> https://github.com/grpc/grpc/pull/5788#discussion_r56512494:> > > @@ -0,0 +1,32 @@> > +#=================> > +# Update clang to a version with improved tsan> > +> > +RUN apt-get update && apt-get -y install python cmake && apt-get clean> > +> > +RUN git clone -n -b release_38 http://llvm.org/git/llvm.git && ${'\'}> > What do you think of doing a checkout by a specific timestamp? That way we> just have to change the desired timestamp each time we update.I'd suggest going with this version of dockerfile for now to get rid of theflake ASAP and figuring out the rest as a followup PR.> —> You are receiving this because you were assigned.> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5788/files/b5b18faddc0f457623eef93bad362851cd3fcd19#r56512494",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5751,56602485,2016-03-18T01:17:48Z,src/csharp/Grpc.IntegrationTesting/ServicesGrpc.cs,"@@ -47,12 +47,28 @@ public interface IBenchmarkServiceClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IBenchmarkService     {       Task<global::Grpc.Testing.SimpleResponse> UnaryCall(global::Grpc.Testing.SimpleRequest request, ServerCallContext context);       Task StreamingCall(IAsyncStreamReader<global::Grpc.Testing.SimpleRequest> requestStream, IServerStreamWriter<global::Grpc.Testing.SimpleResponse> responseStream, ServerCallContext context);     } +    // server-side abstract class+    public abstract class BenchmarkServiceBase","To make this even more complicated, the name of the abstract class cannot be just Health because it is enclosed in an ""umbrella"" static class called ""Health"" (and member names cannot be same as their enclosing types).So basically have these options:1. leave HealthBase as is 2. rename the umbrella class from ""Health"" to ""HeathGrpc"". I think that would actually look good in the code (you'd do things like `class HealthImpl : HealthGrpc.Health {}`  and `HealthGrpc.BindService(...)`). The problem is that all the code using the grpc stubs would need to be updated.  We might be able to afford this if we actually removed the client-side interfaces and figured out the ClientBase at the same time - because these would be breaking changes anyway.3. come up with some other name of the class than ""Health"" or ""HealthBase"".",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5751,56602708,2016-03-18T01:21:18Z,src/csharp/Grpc.HealthCheck/HealthGrpc.cs,"@@ -38,11 +38,22 @@ public interface IHealthClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IHealth     {       Task<global::Grpc.Health.V1.HealthCheckResponse> Check(global::Grpc.Health.V1.HealthCheckRequest request, ServerCallContext context);     } +    // server-side abstract class+    public abstract class HealthBase","If we delay this change to also fix the client-side in the same PR (which seems like it would be a breaking change and there's no way around it), we might be able to kill the serverside interface immediately (also see my other comment about adding Grpc suffix to the umbrella class).",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5713,56617329,2016-03-18T06:26:21Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,4 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -+__all__ = [ ""beta"", ""early_adopter"", ""framework"" ]",Never write a list literal value where a tuple literal value will do.(Here and throughout your entire change.),
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/5751,56618599,2016-03-18T06:51:58Z,src/csharp/Grpc.HealthCheck/HealthGrpc.cs,"@@ -38,11 +38,22 @@ public interface IHealthClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IHealth     {       Task<global::Grpc.Health.V1.HealthCheckResponse> Check(global::Grpc.Health.V1.HealthCheckRequest request, ServerCallContext context);     } +    // server-side abstract class+    public abstract class HealthBase","Doing them in the same PR (but different commits) makes sense to me - and the benefit of not having an obsolete interface is big, IMO.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/5751,56618660,2016-03-18T06:53:18Z,src/csharp/Grpc.IntegrationTesting/ServicesGrpc.cs,"@@ -47,12 +47,28 @@ public interface IBenchmarkServiceClient     }      // server-side interface+    [System.Obsolete(""Service implementations should inherit from the generated abstract base class instead."")]     public interface IBenchmarkService     {       Task<global::Grpc.Testing.SimpleResponse> UnaryCall(global::Grpc.Testing.SimpleRequest request, ServerCallContext context);       Task StreamingCall(IAsyncStreamReader<global::Grpc.Testing.SimpleRequest> requestStream, IServerStreamWriter<global::Grpc.Testing.SimpleResponse> responseStream, ServerCallContext context);     } +    // server-side abstract class+    public abstract class BenchmarkServiceBase","Having got my head round ""this is the server side base, we're not providing an implementation"" I'm in favour of it being called HealthBase, and I apologise for previous confusion.That doesn't mean the change from Health to HealthGrpc is a bad idea - I quite like that.",
5378335,leifurhauks,https://api.github.com/repos/grpc/grpc/pulls/5660,56706973,2016-03-18T19:05:31Z,src/python/grpcio/tests/_runner.py,"@@ -105,6 +105,8 @@ def write_bypass(self, value):     Arguments:       value (str): What to write to the original file.     """"""+    if sys.version_info.major >= 3 and not isinstance(value, bytes):","`six.binary_type` would be equivalent (since `bytes` is an alias for `str` on python2), but I believe this check is to deal with bytearrays, not only to distinguish between binary and text data. On python3, bytearray literals were being printed instead of the contents of those bytearrays. So that makes me wonder whether using `six.binary_type` instead might be misleading?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/5592,56754239,2016-03-19T20:00:20Z,src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h,"@@ -0,0 +1,56 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import ""GRPCCall.h""++/** Helpers for setting SSL Trusted Roots, Client Certificates, and Private Key */+@interface GRPCCall (ChannelCredentials)++/**+ * Use the provided @c pemRootCert as the set of trusted root Certificate Authorities for @c host.+ */++ (BOOL)setTLSPEMRootCerts:(nullable NSString *)pemRootCert+                   forHost:(nonnull NSString *)host+                     error:(NSError **)errorPtr;+/**+ * Configures @c host with TLS/SSL Client Credentials and optionally trusted root Certificate+ * Authorities. If @c pemRootCerts is nil, the default CA Certificates bundled with gRPC will be+ * used.+ */++ (BOOL)setTLSCredentials:(nullable NSString *)pemRootCerts+           withPrivateKey:(nullable NSString *)pemPrivateKey+            withCertChain:(nullable NSString *)pemCertChain+                  forHost:(nonnull NSString *)host+                    error:(NSError **)errorPtr;","@makdharma as I'm on vacation next week, do you want to take over?My only outstanding concern is whether these methods should have `errorPtr` or not (see the pros and cons elsewhere in the review).Actually, @jboeuf: Are there plans to, in the future, check the validity of these values when one sets channel credentials? Or is it out of the question for some reason?After settling that, only a bit of renaming here to make the two methods consistent and follow the style: `s/TLSCrendentials/TLSPEMRootCerts`, and if I remember the style guide correctly, capitalize ""PEM"" in the parameter names.",
4578188,pmarks-net,https://api.github.com/repos/grpc/grpc/pulls/5920,57107243,2016-03-23T04:02:18Z,src/core/iomgr/tcp_server_posix.c,"@@ -508,22 +509,25 @@ int grpc_tcp_server_add_port(grpc_tcp_server *s, const void *addr,   fd = grpc_create_dualstack_socket(addr, SOCK_STREAM, 0, &dsmode);   if (fd < 0) {     gpr_log(GPR_ERROR, ""Unable to create socket: %s"", strerror(errno));-  }-  if (dsmode == GRPC_DSMODE_IPV4 &&-      grpc_sockaddr_is_v4mapped(addr, &addr4_copy)) {-    addr = (struct sockaddr *)&addr4_copy;-    addr_len = sizeof(addr4_copy);-  }-  sp = add_socket_to_server(s, fd, addr, addr_len, port_index, fd_index);-  if (sp2 != NULL && sp != NULL) {-    sp2->sibling = sp;-    sp->is_sibling = 1;+  } else {+    if (dsmode == GRPC_DSMODE_IPV4 &&+        grpc_sockaddr_is_v4mapped(addr, &addr4_copy)) {+      addr = (struct sockaddr *)&addr4_copy;+      addr_len = sizeof(addr4_copy);+    }+    sp = add_socket_to_server(s, fd, addr, addr_len, port_index, fd_index);",`sp2 = sp;` should move down to this line.  You only need to rename the first listener when creating a second one.,
14932100,adelez,https://api.github.com/repos/grpc/grpc/pulls/5966,57634263,2016-03-28T21:08:52Z,tools/gce/create_interop_worker.sh,"@@ -0,0 +1,61 @@+#!/bin/bash+# Copyright 2015-2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# Creates an interop worker on GCE.++set -ex++cd $(dirname $0)++CLOUD_PROJECT=grpc-testing+ZONE=us-east1-a  # canary gateway is reachable from this zone++INSTANCE_NAME=""${1:-grpc-canary-interop2}""++gcloud compute instances create $INSTANCE_NAME \+    --project=""$CLOUD_PROJECT"" \+    --zone ""$ZONE"" \+    --machine-type n1-standard-16 \+    --image ubuntu-15-10 \+    --boot-disk-size 1000 \+    --scopes https://www.googleapis.com/auth/xapi.zoo++echo 'Created GCE instance, waiting 60 seconds for it to come online.'+sleep 60++gcloud compute copy-files \+    --project=""$CLOUD_PROJECT"" \+    --zone ""$ZONE"" \+    jenkins_master.pub linux_worker_init.sh ${INSTANCE_NAME}:~++gcloud compute ssh \+    --project=""$CLOUD_PROJECT"" \+    --zone ""$ZONE"" \+    $INSTANCE_NAME --command ""./linux_worker_init.sh""",There are a few extra steps for interop worker as in listed in the setup doc:Extra steps:copy service account keys to ~jenkins/service_accountsudo apt-get install python-pipsudo pip install mako  (needed for HTML reports)(For PHP flakes only. See #5172) copy .composer/auth.json to $HOME/.composer/auth.json,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5904,57662736,2016-03-29T01:50:30Z,src/csharp/Grpc.IntegrationTesting/ServerRunners.cs,"@@ -50,27 +51,78 @@ namespace Grpc.IntegrationTesting     /// <summary>     /// Helper methods to start server runners for performance testing.     /// </summary>-    public static class ServerRunners+    public class ServerRunners     {+        static readonly ILogger Logger = GrpcEnvironment.Logger.ForType<ServerRunners>();+         /// <summary>         /// Creates a started server runner.         /// </summary>         public static IServerRunner CreateStarted(ServerConfig config)         {-            GrpcPreconditions.CheckArgument(config.ServerType == ServerType.ASYNC_SERVER);+            Logger.Debug(""ServerConfig: {0}"", config);             var credentials = config.SecurityParams != null ? TestCredentials.CreateSslServerCredentials() : ServerCredentials.Insecure; -            // TODO: qps_driver needs to setup payload properly...-            int responseSize = config.PayloadConfig != null ? config.PayloadConfig.SimpleParams.RespSize : 0;+            if (config.AsyncServerThreads != 0)+            {+                Logger.Warning(""ServerConfig.AsyncServerThreads is not supported for C#. Ignoring the value"");+            }+            if (config.CoreLimit != 0)+            {+                Logger.Warning(""ServerConfig.CoreLimit is not supported for C#. Ignoring the value"");+            }+            if (config.CoreList.Count > 0)+            {+                Logger.Warning(""ServerConfig.CoreList is not supported for C#. Ignoring the value"");+            }++            ServerServiceDefinition service = null;+            if (config.ServerType == ServerType.ASYNC_SERVER)+            {+                GrpcPreconditions.CheckArgument(config.PayloadConfig == null,+                    ""ServerConfig.PayloadConfig shouldn't be set for BenchmarkService based server."");    ","Because the things around configuring the payload are not really well documented and server side payload has is actually ignored for ASYNC_SERVER, I prefer to stay on the safe side and assert on things that might lead to generating garbage data without us noticing that.Currently, this assert doesn't limit the functionality at all and if we decide to change the semantics in the future, I can always get rid of that assert once needed. For now, I'd like to keep that assert unless you are strongly against it. Please let me know.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5826,57746193,2016-03-29T15:42:12Z,src/proto/grpc/testing/stats.proto,"@@ -41,6 +41,12 @@ message ServerStats {   // change in server time (in seconds) used by the server process and all   // threads since last reset   double time_system = 3;++  // Number of requests received+  uint64 reqs_received = 4;","For streaming calls, each of the mesages sent/received is referred to as ""FooRequest"" or ""FooResponse"", so I think the naming of the fields is fine.(maybe reqs_received -> requests_received).Let's just add comment  that for streaming RPCs, we do mean number of messages, not RPCs.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5984,57754219,2016-03-29T16:28:17Z,tools/run_tests/run_performance_tests.py,"@@ -0,0 +1,353 @@+#!/usr/bin/env python2.7+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Run performance tests locally or remotely.""""""++import argparse+import jobset+import multiprocessing+import os+import subprocess+import sys+import tempfile+import time+import uuid+++_ROOT = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '../..'))+os.chdir(_ROOT)+++_REMOTE_HOST_USERNAME = 'jenkins'+++class CXXLanguage:++  def __init__(self):+    self.safename = 'cxx'++  def scenarios(self):","It's definitely worth trying to utilize the JSON input and output capabilities of qps_json_driver. But making that work with the remote scenarios might need a bit more work, so let's do that in a followup pull request.Also, once we get output from qps_driver in form of JSON, we can utilize Sree's simple bigquery client https://github.com/grpc/grpc/blob/master/tools/gcp/utils/big_query_utils.py  to push the results to bigquery.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5984,57973953,2016-03-30T22:20:24Z,tools/run_tests/run_performance_tests.py,"@@ -0,0 +1,353 @@+#!/usr/bin/env python2.7+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Run performance tests locally or remotely.""""""++import argparse+import jobset+import multiprocessing+import os+import subprocess+import sys+import tempfile+import time+import uuid+++_ROOT = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '../..'))+os.chdir(_ROOT)+++_REMOTE_HOST_USERNAME = 'jenkins'+++class CXXLanguage:++  def __init__(self):+    self.safename = 'cxx'++  def scenarios(self):+    # TODO(jtattermusch): add more scenarios+    return {+            # Scenario 1: generic async streaming ping-pong (contentionless latency)+            'cpp_async_generic_streaming_ping_pong': [+                '--rpc_type=STREAMING',+                '--client_type=ASYNC_CLIENT',+                '--server_type=ASYNC_GENERIC_SERVER',+                '--outstanding_rpcs_per_channel=1',+                '--client_channels=1',+                '--bbuf_req_size=0',+                '--bbuf_resp_size=0',+                '--async_client_threads=1',+                '--async_server_threads=1',+                '--secure_test=true',+                '--num_servers=1',+                '--num_clients=1',+                '--server_core_limit=0',+                '--client_core_limit=0'],+            # Scenario 5: Sync unary ping-pong with protobufs+            'cpp_sync_unary_ping_pong_protobuf': [+                '--rpc_type=UNARY',+                '--client_type=SYNC_CLIENT',+                '--server_type=SYNC_SERVER',+                '--outstanding_rpcs_per_channel=1',+                '--client_channels=1',+                '--simple_req_size=0',+                '--simple_resp_size=0',+                '--secure_test=true',+                '--num_servers=1',+                '--num_clients=1',+                '--server_core_limit=0',+                '--client_core_limit=0']}++  def __str__(self):+    return 'c++'+++class CSharpLanguage:++  def __init__(self):+    self.safename = str(self)++  def __str__(self):+    return 'csharp'+++class NodeLanguage:++  def __init__(self):+    pass+    self.safename = str(self)++  def __str__(self):+    return 'node'+++_LANGUAGES = {+    'c++' : CXXLanguage(),+    'csharp' : CSharpLanguage(),+    'node' : NodeLanguage(),+}+++class QpsWorkerJob:+  """"""Encapsulates a qps worker server job.""""""++  def __init__(self, spec, host_and_port):+    self._spec = spec+    self.host_and_port = host_and_port+    self._job = jobset.Job(spec, bin_hash=None, newline_on_success=True, travis=True, add_env={})++  def is_running(self):+    """"""Polls a job and returns True if given job is still running.""""""+    return self._job.state(jobset.NoCache()) == jobset._RUNNING++  def kill(self):+    return self._job.kill()+++def create_qpsworker_job(language, port=10000, remote_host=None):+  # TODO: support more languages+  cmd = 'bins/opt/qps_worker --driver_port=%s' % port",Will more languages be supported by adding something to their language definition classes above?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/5984,57974366,2016-03-30T22:24:17Z,tools/run_tests/run_performance_tests.py,"@@ -0,0 +1,353 @@+#!/usr/bin/env python2.7+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Run performance tests locally or remotely.""""""++import argparse+import jobset+import multiprocessing+import os+import subprocess+import sys+import tempfile+import time+import uuid+++_ROOT = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '../..'))+os.chdir(_ROOT)+++_REMOTE_HOST_USERNAME = 'jenkins'+++class CXXLanguage:++  def __init__(self):+    self.safename = 'cxx'++  def scenarios(self):+    # TODO(jtattermusch): add more scenarios+    return {+            # Scenario 1: generic async streaming ping-pong (contentionless latency)","There's a lot of repetition here. Could this instead be done as a hash with k,v pairs like (rpc_type,STREAMING), (client_type,ASYNC_CLIENT) , etc? Then you would copy one hash to the next and then just change the 1 or 2 k,v pairs that you need to change to move from one scenario type to the next. Just suggesting that  many scenarios are very similar to each other. As more options evolve, this would also make the process of keeping the arguments in sync less error-prone.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6037,58163215,2016-04-01T05:17:29Z,test/core/client_config/uri_parser_test.c,"@@ -56,6 +56,56 @@ static void test_fails(const char *uri_text) {   GPR_ASSERT(NULL == grpc_uri_parse(uri_text, 0)); } +static void test_query_parts() {+  {+    const char *uri_text = ""http://foo/path?a&b=B&c=&#frag"";","woops, that belongs on a different PR that's already merged (#6034). I'll create a new PR for that :)Those changes where in here because I simply merged that other branch in order to make progress in parallel.",
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6062,58410495,2016-04-04T17:07:42Z,src/csharp/Grpc.Tools.CSharpGenerator/Program.cs,"@@ -0,0 +1,112 @@+﻿using System;+using System.Diagnostics;+using System.IO;+using System.Linq;+using System.Runtime.InteropServices;++namespace Grpc.Tools.CSharpGenerator+{+    class Program+    {+        //From Managed.Windows.Forms/XplatUI+        [DllImport(""libc"")]+        static extern int uname(IntPtr buf);+        static bool IsRunningOnMac()+        {+            var buf = IntPtr.Zero;+            try+            {+                buf = Marshal.AllocHGlobal(8192);+                // This is a hacktastic way of getting sysname from uname ()+                if (uname(buf) == 0)+                {+                    var os = Marshal.PtrToStringAnsi(buf);+                    if (os == ""Darwin"")+                        return true;+                }+            }+            catch+            {+            }+            finally+            {+                if (buf != IntPtr.Zero)+                    Marshal.FreeHGlobal(buf);+            }+            return false;+        }        +        static void Main(string[] args)+        {+            try+            {+                var projectDir = args[0];","I think it might be ok to have this depend on Grpc.Core - because this is a build time only dependency. Unfortunately this class is internal so I can't use it as-is. Would you feel better if I used some other nuget package that included this check? Again, note that this a build-time dependency only.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6062,58436763,2016-04-04T19:52:23Z,src/csharp/Grpc.Tools.CSharpGenerator/Program.cs,"@@ -0,0 +1,112 @@+﻿using System;+using System.Diagnostics;+using System.IO;+using System.Linq;+using System.Runtime.InteropServices;++namespace Grpc.Tools.CSharpGenerator+{+    class Program+    {+        //From Managed.Windows.Forms/XplatUI+        [DllImport(""libc"")]+        static extern int uname(IntPtr buf);+        static bool IsRunningOnMac()+        {+            var buf = IntPtr.Zero;+            try+            {+                buf = Marshal.AllocHGlobal(8192);+                // This is a hacktastic way of getting sysname from uname ()+                if (uname(buf) == 0)+                {+                    var os = Marshal.PtrToStringAnsi(buf);+                    if (os == ""Darwin"")+                        return true;+                }+            }+            catch+            {+            }+            finally+            {+                if (buf != IntPtr.Zero)+                    Marshal.FreeHGlobal(buf);+            }+            return false;+        }        +        static void Main(string[] args)+        {+            try+            {+                var projectDir = args[0];",At this point you can probably just copy-and-paste the PlatformApi class and add a big comment that this is actually what Grpc.Core already implements. Then we are at least duplicating the very same code and we can figure out the rest in the next step.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6062,58437648,2016-04-04T19:58:25Z,src/csharp/Grpc.Tools.CSharpGenerator/Grpc.Tools.CSharpGenerator.csproj,"@@ -0,0 +1,64 @@+﻿<?xml version=""1.0"" encoding=""utf-8""?>+<Project ToolsVersion=""4.0"" DefaultTargets=""Build"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <Import Project=""$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"" Condition=""Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')"" />+  <PropertyGroup>+    <Configuration Condition="" '$(Configuration)' == '' "">Debug</Configuration>+    <Platform Condition="" '$(Platform)' == '' "">AnyCPU</Platform>+    <ProjectGuid>{B266A314-A7E1-4CF0-935B-3029A0754A90}</ProjectGuid>+    <OutputType>Exe</OutputType>+    <AppDesignerFolder>Properties</AppDesignerFolder>+    <RootNamespace>Grpc.Tools.CSharpGenerator</RootNamespace>+    <AssemblyName>Grpc.Tools.CSharpGenerator</AssemblyName>+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>+    <FileAlignment>512</FileAlignment>+    <SolutionDir Condition=""$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'"">..\</SolutionDir>+    <RestorePackages>true</RestorePackages>+    <NuGetPackageImportStamp>a908814c</NuGetPackageImportStamp>+    <OutputPath>$(SolutionDir)tools\$(Configuration)\$(TargetFilename)</OutputPath>+  </PropertyGroup>+  <PropertyGroup Condition="" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "">+    <DebugSymbols>true</DebugSymbols>+    <DebugType>full</DebugType>+    <Optimize>false</Optimize>+    <DefineConstants>DEBUG;TRACE</DefineConstants>+    <ErrorReport>prompt</ErrorReport>+    <WarningLevel>4</WarningLevel>+    <Prefer32Bit>false</Prefer32Bit>+    <Commandlineparameters>/Users/ananthb/Projects/Grpc.Tools.CSharpGenerator/GrpcTest/ obj/Debug/ greeter.grpc</Commandlineparameters>+  </PropertyGroup>+  <PropertyGroup Condition="" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "">+    <PlatformTarget>AnyCPU</PlatformTarget>+    <DebugType>pdbonly</DebugType>+    <Optimize>true</Optimize>+    <DefineConstants>TRACE</DefineConstants>+    <ErrorReport>prompt</ErrorReport>+    <WarningLevel>4</WarningLevel>+  </PropertyGroup>+  <ItemGroup>+    <Reference Include=""System"" />+    <Reference Include=""System.Core"" />+    <Reference Include=""Microsoft.CSharp"" />+  </ItemGroup>+  <ItemGroup>+    <Compile Include=""Program.cs"" />+    <Compile Include=""Properties\AssemblyInfo.cs"" />+  </ItemGroup>+  <ItemGroup>+    <None Include=""App.config"" />+  </ItemGroup>+  <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />+  <Import Project=""$(SolutionDir)\.nuget\NuGet.targets"" Condition=""Exists('$(SolutionDir)\.nuget\NuGet.targets')"" />+  <Target Name=""EnsureNuGetPackageBuildImports"" BeforeTargets=""PrepareForBuild"">+    <PropertyGroup>+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>+    </PropertyGroup>+    <Error Condition=""!Exists('$(SolutionDir)\.nuget\NuGet.targets')"" Text=""$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))"" />+  </Target>+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. ","I'd like to VS project to look as similar as possible to the other C# projects. But we can figure that out as the last step, after we resolve all the conceptual problems (like how to support .NET core).Btw, have you considered adding just a wrapper script instead of CSharpGenerator.exe written in C#? Basically all we need here is something that wraps the platform-specific executables in a portable fashion.",
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6062,58446878,2016-04-04T20:53:14Z,src/csharp/Grpc.Tools.CSharpGenerator/Program.cs,"@@ -0,0 +1,112 @@+﻿using System;+using System.Diagnostics;+using System.IO;+using System.Linq;+using System.Runtime.InteropServices;++namespace Grpc.Tools.CSharpGenerator+{+    class Program+    {+        //From Managed.Windows.Forms/XplatUI+        [DllImport(""libc"")]+        static extern int uname(IntPtr buf);+        static bool IsRunningOnMac()+        {+            var buf = IntPtr.Zero;+            try+            {+                buf = Marshal.AllocHGlobal(8192);+                // This is a hacktastic way of getting sysname from uname ()+                if (uname(buf) == 0)+                {+                    var os = Marshal.PtrToStringAnsi(buf);+                    if (os == ""Darwin"")+                        return true;+                }+            }+            catch+            {+            }+            finally+            {+                if (buf != IntPtr.Zero)+                    Marshal.FreeHGlobal(buf);+            }+            return false;+        }        +        static void Main(string[] args)+        {+            try+            {+                var projectDir = args[0];+                var intermediateOutputDir = args[1];++                var osName = string.Empty;++                if (Path.DirectorySeparatorChar == '\\')+                    osName = ""windows_{0}"";+                else if (IsRunningOnMac())+                    osName = ""macosx_{0}"";+                else if (Environment.OSVersion.Platform == PlatformID.Unix)+                    osName = ""linux_{0}"";+                else+                {+                    Console.Error.WriteLine(""Could not detect your operating system. The only supported operating systems are Windows, Mac OSX and Linux"");+                    return;+                }++                var bitness = string.Empty;+                if (IntPtr.Size == 8)+                    bitness = ""x64"";+                else if (IntPtr.Size == 4)+                    bitness = ""x86"";+                else+                {+                    Console.Error.WriteLine(""Could not detect your the architecture of your operating system. Only x86 and x64 are currently supported"");+                    return;+                }++                var exeDir = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);+                var protocPath = Path.Combine(exeDir.ParentDirectory(), ""tools"", string.Format(osName, bitness), osName.StartsWith(""windows"") ? ""protoc.exe"" : ""protoc"");+                var grpcCSharpPluginPath = Path.Combine(exeDir.ParentDirectory(), ""tools"", string.Format(osName, bitness), osName.StartsWith(""windows"") ? ""grpc_csharp_plugin.exe"" : ""grpc_csharp_plugin"");+                var protosIncludeDir = projectDir;+                var outputDir = Path.Combine(projectDir, intermediateOutputDir);++                var inputFiles = from protofile in args.Skip(2).TakeWhile(s => true)+                                 select Path.Combine(projectDir, protofile);+                foreach (var f in inputFiles)+                    Console.WriteLine(""Going to process: {0}"", f);++                foreach (var inputFile in inputFiles)+                {+                    var protocArguments = string.Format(""-I{0} --csharp_out {1} --grpc_out {1} --plugin=protoc-gen-grpc={2} {3}"", protosIncludeDir, outputDir, grpcCSharpPluginPath, inputFile);","As a first step, I can support this using the ""Custom Tool namespace"" metadata on that item. Later, I can extend it to be generic by option name. See this example of custom metadata [here](https://msdn.microsoft.com/en-us/library/ms171474.aspx). Consumers that want to use this advanced feature will have to hand-edit their project files and add the metadata in.Does this sound good?",
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6062,58447516,2016-04-04T20:57:10Z,src/csharp/Grpc.Tools.CSharpGenerator/Grpc.Tools.CSharpGenerator.csproj,"@@ -0,0 +1,64 @@+﻿<?xml version=""1.0"" encoding=""utf-8""?>+<Project ToolsVersion=""4.0"" DefaultTargets=""Build"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <Import Project=""$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"" Condition=""Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')"" />+  <PropertyGroup>+    <Configuration Condition="" '$(Configuration)' == '' "">Debug</Configuration>+    <Platform Condition="" '$(Platform)' == '' "">AnyCPU</Platform>+    <ProjectGuid>{B266A314-A7E1-4CF0-935B-3029A0754A90}</ProjectGuid>+    <OutputType>Exe</OutputType>+    <AppDesignerFolder>Properties</AppDesignerFolder>+    <RootNamespace>Grpc.Tools.CSharpGenerator</RootNamespace>+    <AssemblyName>Grpc.Tools.CSharpGenerator</AssemblyName>+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>+    <FileAlignment>512</FileAlignment>+    <SolutionDir Condition=""$(SolutionDir) == '' Or $(SolutionDir) == '*Undefined*'"">..\</SolutionDir>+    <RestorePackages>true</RestorePackages>+    <NuGetPackageImportStamp>a908814c</NuGetPackageImportStamp>+    <OutputPath>$(SolutionDir)tools\$(Configuration)\$(TargetFilename)</OutputPath>+  </PropertyGroup>+  <PropertyGroup Condition="" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' "">+    <DebugSymbols>true</DebugSymbols>+    <DebugType>full</DebugType>+    <Optimize>false</Optimize>+    <DefineConstants>DEBUG;TRACE</DefineConstants>+    <ErrorReport>prompt</ErrorReport>+    <WarningLevel>4</WarningLevel>+    <Prefer32Bit>false</Prefer32Bit>+    <Commandlineparameters>/Users/ananthb/Projects/Grpc.Tools.CSharpGenerator/GrpcTest/ obj/Debug/ greeter.grpc</Commandlineparameters>+  </PropertyGroup>+  <PropertyGroup Condition="" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' "">+    <PlatformTarget>AnyCPU</PlatformTarget>+    <DebugType>pdbonly</DebugType>+    <Optimize>true</Optimize>+    <DefineConstants>TRACE</DefineConstants>+    <ErrorReport>prompt</ErrorReport>+    <WarningLevel>4</WarningLevel>+  </PropertyGroup>+  <ItemGroup>+    <Reference Include=""System"" />+    <Reference Include=""System.Core"" />+    <Reference Include=""Microsoft.CSharp"" />+  </ItemGroup>+  <ItemGroup>+    <Compile Include=""Program.cs"" />+    <Compile Include=""Properties\AssemblyInfo.cs"" />+  </ItemGroup>+  <ItemGroup>+    <None Include=""App.config"" />+  </ItemGroup>+  <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />+  <Import Project=""$(SolutionDir)\.nuget\NuGet.targets"" Condition=""Exists('$(SolutionDir)\.nuget\NuGet.targets')"" />+  <Target Name=""EnsureNuGetPackageBuildImports"" BeforeTargets=""PrepareForBuild"">+    <PropertyGroup>+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>+    </PropertyGroup>+    <Error Condition=""!Exists('$(SolutionDir)\.nuget\NuGet.targets')"" Text=""$([System.String]::Format('$(ErrorText)', '$(SolutionDir)\.nuget\NuGet.targets'))"" />+  </Target>+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. ","I could use a script, but instead of writing and maintaining 2 (3 code paths) scripts, it seemed easier to write a portable executable. As it stands, I can also change the logic inside the generator to be arbitrarily complex if needed. I thought the risks were small and the rewards many with this approach.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/5958,58471638,2016-04-05T00:35:22Z,include/grpc++/security/server_credentials.h,"@@ -39,6 +39,7 @@  #include <grpc++/security/auth_metadata_processor.h> #include <grpc++/support/config.h>+#include <grpc/grpc_security.h>",I'm not super thrilled about this new top level dependency (even though I understand why it's been introduced). @ctiller  may have a good idea on how to make is such that the same enum can be consumed from both C and C++ (as the one that we use for grpc_status_code for example).,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/5958,58472052,2016-04-05T00:41:29Z,include/grpc/grpc_security.h,"@@ -342,12 +350,15 @@ GRPCAPI void grpc_server_credentials_release(grpc_server_credentials *creds);      server. This parameter cannot be NULL.    - num_key_cert_pairs indicates the number of items in the private_key_files      and cert_chain_files parameters. It should be at least 1.-   - force_client_auth, if set to non-zero will force the client to authenticate+   - client_certificate_request, if set to non-zero will force the client to+   authenticate      with an SSL cert. Note that this option is ignored if pem_root_certs is      NULL. */ GRPCAPI grpc_server_credentials *grpc_ssl_server_credentials_create(     const char *pem_root_certs, grpc_ssl_pem_key_cert_pair *pem_key_cert_pairs,-    size_t num_key_cert_pairs, int force_client_auth, void *reserved);+    size_t num_key_cert_pairs,+    grpc_client_certificate_request_type client_certificate_request,",enums are not type safe in C. I'm really worried that client will call this function with the old int parameter which will cause some unexpected behavior....I would prefer to have a new function (grpc_ssl_server_credentials_create_ex) and this will avoid any confusion.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6085,58548353,2016-04-05T14:33:43Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">",Also the Outputs attribute doesn't seem to list the ...Grpc.cs file.,
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6085,58571226,2016-04-05T16:34:55Z,src/csharp/Grpc.Tools.CSharpGenerator/App.config,"@@ -0,0 +1,6 @@+﻿<?xml version=""1.0"" encoding=""utf-8"" ?>","See [here](https://msdn.microsoft.com/en-us/library/jj152935%28v=vs.110%29.aspx). Although to be fair, since I'm not bundling the _exe.config_ along with the nuget, this can be omitted. I'm ok going either way.",
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6085,58572672,2016-04-05T16:43:29Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">","Comment 1: See lines 20 and 23, I transform the input Proto files into filenames with both variations.Comment 2: Yes, I simply include them conditionally (only if they exist - the Touch Task takes care of that for me). I could be explicit about including both transformations though. I'll add that in.",
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6085,58650920,2016-04-06T04:51:27Z,src/csharp/Grpc.Tools.CSharpGenerator/PlatformApis.cs,"@@ -0,0 +1,127 @@+#region Copyright notice and license++// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++#endregion++// NOTE: This code has been taken from Grpc.Core.Internal so that different+// codepaths are not used for OS detection. If/when this class becomes+// public, figure out how to re-use Grpc.Core instead of duplicated code++using System;+using System.Collections.Concurrent;+using System.Diagnostics;+using System.IO;+using System.Reflection;+using System.Runtime.InteropServices;+using System.Threading;++namespace Grpc.Core.Internal+{+    /// <summary>+    /// Utility methods for detecting platform and architecture.+    /// </summary>+    internal static class PlatformApis+    {+        static readonly bool isLinux;+        static readonly bool isMacOSX;+        static readonly bool isWindows;+        static readonly bool isMono;++        static PlatformApis()+        {+#if DNXCORE50+            isLinux = RuntimeInformation.IsOSPlatform(OSPlatform.Linux);+            isMacOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);+            isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);+#else+            var platform = Environment.OSVersion.Platform;++            // PlatformID.MacOSX is never returned, commonly used trick is to identify Mac is by using uname.+            isMacOSX = (platform == PlatformID.Unix && GetUname() == ""Darwin"");+            isLinux = (platform == PlatformID.Unix && !isMacOSX);+            isWindows = (platform == PlatformID.Win32NT || platform == PlatformID.Win32S || platform == PlatformID.Win32Windows);+#endif+            isMono = Type.GetType(""Mono.Runtime"") != null;+        }++        public static bool IsLinux+        {+            get { return isLinux; }+        }++        public static bool IsMacOSX+        {+            get { return isMacOSX; }+        }++        public static bool IsWindows+        {+            get { return isWindows; }+        }++        public static bool IsMono+        {+            get { return isMono; }+        }++        public static bool Is64Bit+        {+            get { return IntPtr.Size == 8; }+        }++        [DllImport(""libc"")]+        static extern int uname(IntPtr buf);++        static string GetUname()","This file as the note indicates, is copied from https://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Core/Internal/PlatformApis.cs. I didn't change a line of code in there because the intent (even though I can't directly use Grpc.Core) is to use the same platform detection code.",
8228229,kkm000,https://api.github.com/repos/grpc/grpc/pulls/6085,58652098,2016-04-06T05:16:01Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">+    <!-- Run our platform independent wrapper that launches protoc with the right arguments -->+    <Exec Condition=""'$(OS)' == 'Windows_NT'"" Command=""$(MSBuildThisFileDirectory)..\tools\Grpc.Tools.CSharpGenerator.exe $(ProjectDir) $(IntermediateOutputPath) @(Proto->'%(filename)%(extension)', ' ')"" LogStandardErrorAsError=""true""/>","@jtattermusch: This is only possible if we eithera) Use tracker. Tracker is an amazingly underdocumented tool, and exists only in Microsoft package of MSBuild. Since it is not in github/microsoft/MSBuild, it is not likely to exist in mono. I have code that fully supports tracker (I wrote it to hande complext dependencies in a 3rd part compiler) and can release it, but it will not be cross-platformTracker works by intercepting tool's I/O and saving lists of files that it actually did read and write.b) Create a managed, .NET version of protoc parser that will read files and tell us what files it is going to generate. Sounds more complex but portable. But you and protoc team will have to maintain these in sync. Nasty.c) Sorry, no (c) that I can think of at the moment. Let's think if there is a better solution.",
605680,aniongithub,https://api.github.com/repos/grpc/grpc/pulls/6085,58652143,2016-04-06T05:16:44Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">","Ah, I see. I tested with many files but none had an underscore in their name. Can you think of any other naming changes so I can modify the task/CSharpGenerator to work correctly? _Now I'm glad I have the C# based Grpc.Tools.CSharpGenerator to work these things out with_",
8228229,kkm000,https://api.github.com/repos/grpc/grpc/pulls/6085,58653053,2016-04-06T05:36:22Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">","I think it should, thanks to this```    <Touch Files=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"" ForceTouch=""true"">        <Output TaskParameter=""TouchedFiles"" ItemName=""Compile"" />    </Touch>```Here the files are added to the Compile collection (presumbaly only if they exist, the [documentation](https://msdn.microsoft.com/en-us/library/37fwbyt5.aspx) does not state the default for AlwaysCreate though.)",
8228229,kkm000,https://api.github.com/repos/grpc/grpc/pulls/6085,58653437,2016-04-06T05:43:54Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">+    <!-- Run our platform independent wrapper that launches protoc with the right arguments -->+    <Exec Condition=""'$(OS)' == 'Windows_NT'"" Command=""$(MSBuildThisFileDirectory)..\tools\Grpc.Tools.CSharpGenerator.exe $(ProjectDir) $(IntermediateOutputPath) @(Proto->'%(filename)%(extension)', ' ')"" LogStandardErrorAsError=""true""/>+    +    <!-- Make sure that our protoc and protoc_csharp_plugin files are executable -->+    <Exec Condition=""'$(OS)' == 'Unix'"" Command=""chmod +x $(MSBuildThisFileDirectory)../tools/*/protoc""/>+    <Exec Condition=""'$(OS)' == 'Unix'"" Command=""chmod +x $(MSBuildThisFileDirectory)../tools/*/grpc_csharp_plugin""/>    ++    <!-- Run our platform independent wrapper that launches protoc with the right arguments -->+    <Exec Condition=""'$(OS)' == 'Unix'"" Command=""mono $(MSBuildThisFileDirectory)../tools/Grpc.Tools.CSharpGenerator.exe $(ProjectDir) $(IntermediateOutputPath) @(Proto->'%(filename)%(extension)', ' ')"" LogStandardErrorAsError=""true""/>+    +    <!-- Ensure that only files that exist (are touchable) are added in to the Compile target -->+    <Touch Files=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"" ForceTouch=""true"">","I have an idea. Using `<Touch>` to test only if the file exists is a little bit of a hack. I think a more straightforward way to add a file to the collection is, _inside a `<Target>`_,``` xml<ItemGroup>  <Compile Condition=""Exists('$(IntermediateOutputPath)%(Proto.FileName).cs')"" Include=""$(IntermediateOutputPath)%(Proto.FileName).cs"" /></ItemGroup>```Not really sure if this is VS2010 compatible, if that version still exists anywhere on Earth. If you decided to go with the <Touch>, please add `AlwaysCreate=""false""`, as [the spec](https://msdn.microsoft.com/en-us/library/37fwbyt5.aspx) does not state the default value for this attribute, and you do not want to create an empty file here by mistake.",
8228229,kkm000,https://api.github.com/repos/grpc/grpc/pulls/6085,58653881,2016-04-06T05:51:12Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">+    <!-- Run our platform independent wrapper that launches protoc with the right arguments -->+    <Exec Condition=""'$(OS)' == 'Windows_NT'"" Command=""$(MSBuildThisFileDirectory)..\tools\Grpc.Tools.CSharpGenerator.exe $(ProjectDir) $(IntermediateOutputPath) @(Proto->'%(filename)%(extension)', ' ')"" LogStandardErrorAsError=""true""/>+    +    <!-- Make sure that our protoc and protoc_csharp_plugin files are executable -->+    <Exec Condition=""'$(OS)' == 'Unix'"" Command=""chmod +x $(MSBuildThisFileDirectory)../tools/*/protoc""/>+    <Exec Condition=""'$(OS)' == 'Unix'"" Command=""chmod +x $(MSBuildThisFileDirectory)../tools/*/grpc_csharp_plugin""/>    ++    <!-- Run our platform independent wrapper that launches protoc with the right arguments -->+    <Exec Condition=""'$(OS)' == 'Unix'"" Command=""mono $(MSBuildThisFileDirectory)../tools/Grpc.Tools.CSharpGenerator.exe $(ProjectDir) $(IntermediateOutputPath) @(Proto->'%(filename)%(extension)', ' ')"" LogStandardErrorAsError=""true""/>+    +    <!-- Ensure that only files that exist (are touchable) are added in to the Compile target -->+    <Touch Files=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"" ForceTouch=""true"">","Please also add the generated files into the FileWrites collection. These are the files that are removed when Clean and Rebuild targets are run. Otherwise, Rebuild will not rebuild the proto files.Actually, just FYI, to keep the build hermetic, the build system saves the list of files generated during the last build, and removes the generated files based not on the current state of project, but on the state at the time the file were generated. This way, even if you remove x.cs from project, x.obj will be cleaned. It is one of .txt files in the intermediate directory.",
8228229,kkm000,https://api.github.com/repos/grpc/grpc/pulls/6085,58656516,2016-04-06T06:26:15Z,src/csharp/Grpc.Tools.MSBuildIntegration/Grpc.Tools.MSBuildIntegration.targets,"@@ -0,0 +1,27 @@+<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">+  <PropertyGroup>+    <CoreCompileDependsOn>Proto;$(CoreCompileDependsOn)</CoreCompileDependsOn>+  </PropertyGroup>+  <ItemGroup>+    <AvailableItemName Include=""Proto""/>+  </ItemGroup>+  <Target Name=""Proto"" Inputs=""@(Proto)"" Outputs=""@(Proto->'$(IntermediateOutputPath)%(FileName).cs')"">","And here's an advantage in writing an MsBuild Task instead: A task can have output parameters, and you can figure out the names programmatically and return them to be used later in the .targets file.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/6108,58803015,2016-04-07T00:16:41Z,requirements.txt,"@@ -5,3 +5,4 @@ cython>=0.23 coverage>=4.0 six>=1.10 wheel>=0.29+lxml>=3.6.0",I don't think we want to eat this dependency on the whole of grpc for the sake of a unit test. We'd rather add it to the list of pip installed packages into the docker files.,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/6108,58803738,2016-04-07T00:26:09Z,requirements.txt,"@@ -5,3 +5,4 @@ cython>=0.23 coverage>=4.0 six>=1.10 wheel>=0.29+lxml>=3.6.0",Sanity should be enough. Note that this Dockerfile is a template itself =)https://github.com/grpc/grpc/blob/master/templates/tools/dockerfile/test/sanity/Dockerfile.template,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6085,59149627,2016-04-11T02:52:04Z,src/csharp/Grpc.Tools.CSharpGenerator/Program.cs,"@@ -0,0 +1,85 @@+﻿using System;+using System.Diagnostics;+using System.IO;+using System.Linq;+using System.Runtime.InteropServices;++namespace Grpc.Tools.CSharpGenerator+{+    class Program+    {+        static void Main(string[] args)+        {+            try+            {+                var projectDir = args[0];+                var intermediateOutputDir = args[1];++                var osName = string.Empty;++                if (Grpc.Core.Internal.PlatformApis.IsWindows)+                    osName = ""windows_{0}"";+                else if (Grpc.Core.Internal.PlatformApis.IsMacOSX)+                    osName = ""macosx_{0}"";+                else if (Grpc.Core.Internal.PlatformApis.IsLinux)+                    osName = ""linux_{0}"";+                else+                {+                    Console.Error.WriteLine(""Could not detect your operating system. The only supported operating systems are Windows, Mac OSX and Linux"");+                    return;+                }++                var bitness = string.Empty;+                if (Grpc.Core.Internal.PlatformApis.Is64Bit)","For windows, x86 and x64 protoc binaries are interchangeable, on linux though, the difference between 64 and 32bit matters (for mac osx it sometimes matters). So for completeness, we select between the 32 and 64 bit version always.This is actually more important for gRPC C# native extension loading - where we load shared library of appropriate bitness depending on the bitness of the current process (but that's a separate story).",
17751169,deepaklukose,https://api.github.com/repos/grpc/grpc/pulls/5958,59273974,2016-04-11T20:20:47Z,src/core/lib/tsi/ssl_transport_security.h,"@@ -137,7 +136,8 @@ tsi_result tsi_create_ssl_server_handshaker_factory(     const size_t *pem_private_keys_sizes, const unsigned char **pem_cert_chains,     const size_t *pem_cert_chains_sizes, size_t key_cert_pair_count,     const unsigned char *pem_client_root_certs,-    size_t pem_client_root_certs_size, int force_client_auth,+    size_t pem_client_root_certs_size,+    tsi_client_certificate_request_type client_certificate_request,",Shouldn't this be okay given that this is internal to gRPC and is used only in C/C++ code? I am okay with adding an another method similar to grpc_ssl_server_credentials_create_ex if you feel strongly about this.,
17751169,deepaklukose,https://api.github.com/repos/grpc/grpc/pulls/5958,59274175,2016-04-11T20:22:05Z,include/grpc++/security/server_credentials.h,"@@ -39,6 +39,7 @@  #include <grpc++/security/auth_metadata_processor.h> #include <grpc++/support/config.h>+#include <grpc/grpc_security.h>",@ctiller What are you thoughts on this? Is there a better way I can include the enum in c++ without adding a dependency to the c code directly.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5826,59410758,2016-04-12T16:51:07Z,src/proto/grpc/testing/control.proto,"@@ -37,17 +37,32 @@ package grpc.testing; enum ClientType {   SYNC_CLIENT = 0;   ASYNC_CLIENT = 1;+  CLIENT_VARIANT_1 = 2;","I'm not sure we want such opaque enum values. Why can't we be more explicit and add enum values for specific client and server types as we need them?e.g.  we can add JAVA_ASYNC_CLIENT_WITH_CORKING (don't think it exists just an example)  once we have such java client and the resulting name is much more descriptive. Then we can use the same enum values to store results in bigquery (because they are descriptive).Over time, if we stop testing some client types and start testing new ones, we can just add new enum values and deprecate the old ones which will end up more comprehensible than reusing the CLIENT_VARIANT_X values - and we won't risk messing up are existing measurements. ",
9046588,louiscryan,https://api.github.com/repos/grpc/grpc/pulls/5826,59430999,2016-04-12T18:43:04Z,src/proto/grpc/testing/control.proto,"@@ -37,17 +37,32 @@ package grpc.testing; enum ClientType {   SYNC_CLIENT = 0;   ASYNC_CLIENT = 1;+  CLIENT_VARIANT_1 = 2;","@vjpai @jtattermusch Instead of having an enum could we ask the worker to return a list of names for the different types and then pass those names to initiate scenarios. In java for example we would haveserver-variants: ""netty-pooled"", ""netty-direct""client-variants: ""netty-pooled"", ""netty-direct"", ""android-okhttp""We don't necessarily need the full M X N of these scenarios so it might be better to return a tuple of the useful combinations  perhaps annotated that with an enum indicating which driver scenarios these tuples should be applied toE.g. [{    server: netty-direct,   client: netty-direct,   scenario-type: latency},{    server: netty-pooled,   client: netty-pooled,   scenario-type: throughput},The generic vs. non-generic is orthogonal to this choice and seems like it should be rolled into RpcType",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/6153,59460504,2016-04-12T21:50:02Z,grpc.gemspec,"@@ -35,6 +35,7 @@ Gem::Specification.new do |s|   s.add_dependency 'googleauth',      '~> 0.5.1'    s.add_development_dependency 'bundler',            '~> 1.9'+  s.add_development_dependency 'facter',             '~> 2.4'",Where did this dependency come from?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6155,59913113,2016-04-15T17:49:39Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -93,6 +93,45 @@ class CallCredentials(object):   def __init__(self, low_credentials):     self._low_credentials = low_credentials +class GoogleOAuth2MetadataPlugin(interfaces.GRPCAuthMetadataPlugin):","The functionality for both implementations of GRPCAuthMetadataPlugin is alright,but I think we can't just expose these implementations in the public API like suggested here.Once JWT functionality gets added to OAuth2 library, the jwt token will be obtained by just doing getting `self.credentials.get_access_token().access_token` (same as for OAuth2).So we basically want a grpc specific  wrapper around  the ""credentials"" object (same functionality as GoogleOAuth2MetadataPlugin, but with a different name).In terms of JWT, it is probably fine to have the class GoogleJWTAuthMetadataPlugin, but it shouldn't be exposed publicly (at least for now).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6155,59914452,2016-04-15T17:57:49Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +144,35 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__+    name = metadata_plugin.__class__.__name__   return CallCredentials(       _low.call_credentials_metadata_plugin(metadata_plugin, name)) +def google_oauth_call_credentials(credentials):","+1 to having a  factory method to create call credentials  object  from   the credential object from the auth library, that's good for usability. Same as above, you probably don't want google_jwt_call_credentials factory method.e.g. in C#,   the class that provides wrappers around  googleCredentials is called GoogleGrpcCredentials. C# supports extension methods, so i can actually do googleCredentials.ToCallCredentials()   and I obtain   a grpc-specific callCredentials from the original googleCredentials, but in python we can achieve the same using a factory method (basically what you are doing here, but I am wondering about the naming).https://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Auth/GoogleGrpcCredentials.cs",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6188,59915579,2016-04-15T18:05:06Z,tools/run_tests/performance/bq_upload_result.py,"@@ -0,0 +1,103 @@+#!/usr/bin/env python2.7+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# Uploads performance benchmark result file to bigquery.++import argparse+import json+import os+import sys+import uuid+++gcp_utils_dir = os.path.abspath(os.path.join(+    os.path.dirname(__file__), '../../gcp/utils'))+sys.path.append(gcp_utils_dir)+import big_query_utils+++_PROJECT_ID='grpc-testing'+++def _upload_scenario_result_to_bigquery(dataset_id, table_id, result_file):+  bq = big_query_utils.create_big_query()+  _create_results_table(bq, dataset_id, table_id)++  with open(result_file, 'r') as f:+    scenario_result = json.loads(f.read())++  if not _insert_result(bq, dataset_id, table_id, scenario_result):+    print 'Error uploading result to bigquery.'+    sys.exit(1)+++def _insert_result(bq, dataset_id, table_id, scenario_result):+  _flatten_result_inplace(scenario_result)+  row = big_query_utils.make_row(str(uuid.uuid4()), scenario_result)+  return big_query_utils.insert_rows(bq,+                                     _PROJECT_ID,+                                     dataset_id,+                                     table_id,+                                     [row])+++def _create_results_table(bq, dataset_id, table_id):+  with open(os.path.dirname(__file__) + '/scenario_result_schema.json', 'r') as f:+    table_schema = json.loads(f.read())+  desc = 'Results of performance benchmarks.'+  return big_query_utils.create_table2(bq, _PROJECT_ID, dataset_id,+                               table_id, table_schema, desc)+++def _flatten_result_inplace(scenario_result):+  """"""Bigquery is not really great for handling deeply nested data+  and repeated fields. To maintain values of some fields while keeping+  the schema relatively simple, we artificially leave some of the fields+  as JSON strings.+  """"""+  scenario_result['scenario']['clientConfig'] = json.dumps(scenario_result['scenario']['clientConfig'])+  scenario_result['scenario']['serverConfig'] = json.dumps(scenario_result['scenario']['serverConfig'])+  scenario_result['latencies'] = json.dumps(scenario_result['latencies'])+  for stats in scenario_result['clientStats']:+    stats['latencies'] = json.dumps(stats['latencies'])+  scenario_result['serverCores'] = json.dumps(scenario_result['serverCores'])+++argp = argparse.ArgumentParser(description='Upload result to big query.')+argp.add_argument('--bq_result_table', required=True, default=None, type=str,+                  help='Bigquery ""dataset.table"" to upload results to.')+argp.add_argument('--file_to_upload', default='scenario_result.json', type=str,+                  help='Report file to upload.')++args = argp.parse_args()++dataset_id, table_id = args.bq_result_table.split('.', 2)",You will have to create the dataset by calling `big_query_utils.create_data_set` first before creating the table.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6155,59915712,2016-04-15T18:05:57Z,src/python/grpcio/tests/unit/beta/test_utilities.py,"@@ -29,10 +29,32 @@  """"""Test-appropriate entry points into the gRPC Python Beta API."""""" +import time+from oauth2client import client as oauth2client_client+from oauth2client import crypt+ from grpc._adapter import _intermediary_low from grpc.beta import implementations +# TODO(kpayson) we should just add self_sign_jwt() to the +#ServiceAccountCredentials in the oauth2 library, this is a placeholder+class JWTCredentials:","Functionality-wise, this seems to work fine. But perhaps we could model this as a wrapper around googleCredentials that would give you a JWT token when `get_access_token().access_token` is invoked (that seems to be the way things will work once we add the functionality to oauth2 library).If you do that, the resulting code would be very similar to what we'll have once we update oauth2 library.  (As you would be using the same factory method to create callCredentials from googleCredentials for all the use cases.)",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6155,59916685,2016-04-15T18:12:12Z,src/python/grpcio/tests/interop/methods.py,"@@ -305,6 +307,30 @@ def _oauth2_auth_token(stub, args):         'expected to find oauth scope ""%s"" in received ""%s""' %             (response.oauth_scope, args.oauth_scope)) +def _jwt_token_creds(stub, args):","btw, for _oauth2_auth_token interop test (above), I am not sure if that test behaves completely up to the spec.  The idea of that test is to test that you can use a oauth2 token obtained out of band (but the test just seems to be using the googleCredentials directly).I think for oauth2 token test, you need to grab the actual oauth2 token  and then create callCredentials from that specific token (basically https://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Auth/GoogleGrpcCredentials.cs#L68). Then you use those callCredentials to make a call and check if everything was successful.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6188,59919910,2016-04-15T18:33:50Z,tools/run_tests/performance/bq_upload_result.py,"@@ -0,0 +1,103 @@+#!/usr/bin/env python2.7+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++# Uploads performance benchmark result file to bigquery.++import argparse+import json+import os+import sys+import uuid+++gcp_utils_dir = os.path.abspath(os.path.join(+    os.path.dirname(__file__), '../../gcp/utils'))+sys.path.append(gcp_utils_dir)+import big_query_utils+++_PROJECT_ID='grpc-testing'+++def _upload_scenario_result_to_bigquery(dataset_id, table_id, result_file):+  bq = big_query_utils.create_big_query()+  _create_results_table(bq, dataset_id, table_id)++  with open(result_file, 'r') as f:+    scenario_result = json.loads(f.read())++  if not _insert_result(bq, dataset_id, table_id, scenario_result):+    print 'Error uploading result to bigquery.'+    sys.exit(1)+++def _insert_result(bq, dataset_id, table_id, scenario_result):+  _flatten_result_inplace(scenario_result)+  row = big_query_utils.make_row(str(uuid.uuid4()), scenario_result)+  return big_query_utils.insert_rows(bq,+                                     _PROJECT_ID,+                                     dataset_id,+                                     table_id,+                                     [row])+++def _create_results_table(bq, dataset_id, table_id):+  with open(os.path.dirname(__file__) + '/scenario_result_schema.json', 'r') as f:+    table_schema = json.loads(f.read())+  desc = 'Results of performance benchmarks.'+  return big_query_utils.create_table2(bq, _PROJECT_ID, dataset_id,+                               table_id, table_schema, desc)+++def _flatten_result_inplace(scenario_result):+  """"""Bigquery is not really great for handling deeply nested data+  and repeated fields. To maintain values of some fields while keeping+  the schema relatively simple, we artificially leave some of the fields+  as JSON strings.+  """"""+  scenario_result['scenario']['clientConfig'] = json.dumps(scenario_result['scenario']['clientConfig'])+  scenario_result['scenario']['serverConfig'] = json.dumps(scenario_result['scenario']['serverConfig'])+  scenario_result['latencies'] = json.dumps(scenario_result['latencies'])+  for stats in scenario_result['clientStats']:+    stats['latencies'] = json.dumps(stats['latencies'])+  scenario_result['serverCores'] = json.dumps(scenario_result['serverCores'])+++argp = argparse.ArgumentParser(description='Upload result to big query.')+argp.add_argument('--bq_result_table', required=True, default=None, type=str,+                  help='Bigquery ""dataset.table"" to upload results to.')+argp.add_argument('--file_to_upload', default='scenario_result.json', type=str,+                  help='Report file to upload.')++args = argp.parse_args()++dataset_id, table_id = args.bq_result_table.split('.', 2)",Discussed offline. I created the dataset manually and I think that's a reasonable thing to do.,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/5958,60271246,2016-04-19T17:13:28Z,include/grpc++/security/server_credentials.h,"@@ -39,6 +39,7 @@  #include <grpc++/security/auth_metadata_processor.h> #include <grpc++/support/config.h>+#include <grpc/grpc_security.h>","OK, I think that it is actually a good idea. Let's have a new header called grpc_security_constants.h where we put this new enum along with all the #define'd string constants for the auth context and the enum for the ssl root override.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/5958,60271648,2016-04-19T17:15:43Z,include/grpc/grpc_security.h,"@@ -334,6 +334,50 @@ typedef struct grpc_server_credentials grpc_server_credentials;    */ GRPCAPI void grpc_server_credentials_release(grpc_server_credentials *creds); +typedef enum {+  /* Server does not request client certificate. A client can present a self+     signed or signed certificates if it wishes to do so and they would be+     accepted. */+  GRPC_SSL_DONT_REQUEST_CLIENT_CERTIFICATE,+  /* Server requests client certificate but does not enforce that the client+     presents a certificate.++     If the client presents a certificate, the client authentication is left to+     the application based on the metadata like certificate etc.++     The key cert pair should still be valid for the SSL connection to be+     established. */+  GRPC_SSL_REQUEST_CLIENT_CERTIFICATE_BUT_DONT_VERIFY,+  /* Server requests client certificate but does not enforce that the client+     presents a certificate.++     If the client presents a certificate, the client authentication is done by+     grpc framework (The client needs to either present a signed cert or skip no+     certificate for a successful connection).++     The key cert pair should still be valid for the SSL connection to be+     established. */+  GRPC_SSL_REQUEST_CLIENT_CERTIFICATE_AND_VERIFY,+  /* Server requests client certificate but enforces that the client presents a+     certificate.++     If the client presents a certificate, the client authentication is left to+     the application based on the metadata like certificate etc.++     The key cert pair should still be valid for the SSL connection to be+     established. */+  GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_BUT_DONT_VERIFY,+  /* Server requests client certificate but enforces that the client presents a+     certificate.++     The cerificate presented by the client is verified by grpc framework (The+     client needs to present signed certs for a successful connection).++     The key cert pair should still be valid for the SSL connection to be+     established. */+  GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_AND_VERIFY+} grpc_ssl_client_certificate_request_type;+ /* Creates an SSL server_credentials object.",You may mark this one as deprecated.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6214,60294404,2016-04-19T19:24:01Z,src/core/ext/transport/cronet/transport/cronet_c_for_grpc.h,"@@ -0,0 +1,202 @@+// Copyright 2016 The Chromium Authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++#ifndef COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_+#define COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_++#ifdef __cplusplus+extern ""C"" {+#endif++#include <stddef.h>++/* Cronet Engine API. */++/* Opaque object representing Cronet Engine. Created and configured outside+ * of this API to facilitate sharing with other components */",> to facilitate sharing with other componentsWhat do you mean?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6216,60294510,2016-04-19T19:24:28Z,src/python/grpcio/tests/qps/histogram.py,"@@ -0,0 +1,85 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import math+import threading++from tests.qps.stats_pb2 import HistogramData+ +""""""Histogram class used for recording performance testing data.",The comment goes after the class declaration.We are trying to follow the go/python-style python style where possible.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6216,60294692,2016-04-19T19:25:29Z,src/python/grpcio/tests/qps/benchmark_client.py,"@@ -0,0 +1,174 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import abc+try:+  import Queue as queue #Python 2.x+except ImportError:+  import queue #Python 3  +from concurrent.futures import ThreadPoolExecutor+import time++from grpc.beta import implementations+from tests.unit import resources+from tests.unit.beta import test_utilities++from tests.interop.messages_pb2 import Payload, SimpleRequest +from tests.qps import services_pb2++_TIMEOUT = 60 * 60 * 24+_SERVER_HOST_OVERRIDE = 'foo.test.google.fr'++""""""Abstract benchmark client interface that exposes a non-blocking ",comment goes after class declaration,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6214,60296375,2016-04-19T19:35:50Z,src/core/ext/transport/cronet/transport/cronet_c_for_grpc.h,"@@ -0,0 +1,202 @@+// Copyright 2016 The Chromium Authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++#ifndef COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_+#define COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_++#ifdef __cplusplus+extern ""C"" {+#endif++#include <stddef.h>++/* Cronet Engine API. */++/* Opaque object representing Cronet Engine. Created and configured outside+ * of this API to facilitate sharing with other components */+typedef struct cronet_engine { void* obj; } cronet_engine;++void cronet_engine_add_quic_hint(cronet_engine* engine,+                                 const char* host,+                                 int port,+                                 int alternate_port);++/* Cronet Bidirectional Stream API */++/* Opaque object representing Cronet Bidirectional Stream. */+typedef struct cronet_bidirectional_stream {+  void* obj;+  void* annotation;+} cronet_bidirectional_stream;++/* A single request or response header element. */+typedef struct cronet_bidirectional_stream_header {+  const char* key;+  const char* value;+} cronet_bidirectional_stream_header;++/* Array of request or response headers or trailers. */+typedef struct cronet_bidirectional_stream_header_array {+  size_t count;+  size_t capacity;+  cronet_bidirectional_stream_header* headers;+} cronet_bidirectional_stream_header_array;++/* Set of callbacks used to receive callbacks from bidirectional stream. */+typedef struct cronet_bidirectional_stream_callback {+  /* Invoked when request headers are sent. Indicates that stream has initiated+   * the request. Consumer may call cronet_bidirectional_stream_write() to start+   * writing data.+   */+  void (*on_request_headers_sent)(cronet_bidirectional_stream* stream);++  /* Invoked when initial response headers are received.+   * Consumer must call cronet_bidirectional_stream_read() to start reading.+   * Consumer may call cronet_bidirectional_stream_write() to start writing or+   * close the stream. Contents of |headers| is valid for duration of the call.+   */","nit: It sounds like the ordering constraints on calling `cronet_bidirectional_stream_write` aren't really dependent on `on_response_headers_received`. If it's the case, should we even mention it in the comment?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6214,60296771,2016-04-19T19:38:25Z,src/core/ext/transport/cronet/transport/cronet_c_for_grpc.h,"@@ -0,0 +1,202 @@+// Copyright 2016 The Chromium Authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++#ifndef COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_+#define COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_++#ifdef __cplusplus+extern ""C"" {+#endif++#include <stddef.h>++/* Cronet Engine API. */++/* Opaque object representing Cronet Engine. Created and configured outside+ * of this API to facilitate sharing with other components */+typedef struct cronet_engine { void* obj; } cronet_engine;++void cronet_engine_add_quic_hint(cronet_engine* engine,+                                 const char* host,+                                 int port,+                                 int alternate_port);++/* Cronet Bidirectional Stream API */++/* Opaque object representing Cronet Bidirectional Stream. */+typedef struct cronet_bidirectional_stream {+  void* obj;+  void* annotation;+} cronet_bidirectional_stream;++/* A single request or response header element. */+typedef struct cronet_bidirectional_stream_header {+  const char* key;+  const char* value;+} cronet_bidirectional_stream_header;++/* Array of request or response headers or trailers. */+typedef struct cronet_bidirectional_stream_header_array {+  size_t count;+  size_t capacity;+  cronet_bidirectional_stream_header* headers;+} cronet_bidirectional_stream_header_array;++/* Set of callbacks used to receive callbacks from bidirectional stream. */+typedef struct cronet_bidirectional_stream_callback {+  /* Invoked when request headers are sent. Indicates that stream has initiated+   * the request. Consumer may call cronet_bidirectional_stream_write() to start+   * writing data.+   */+  void (*on_request_headers_sent)(cronet_bidirectional_stream* stream);++  /* Invoked when initial response headers are received.+   * Consumer must call cronet_bidirectional_stream_read() to start reading.+   * Consumer may call cronet_bidirectional_stream_write() to start writing or+   * close the stream. Contents of |headers| is valid for duration of the call.+   */+  void (*on_response_headers_received)(+      cronet_bidirectional_stream* stream,+      const cronet_bidirectional_stream_header_array* headers,+      const char* negotiated_protocol);++  /* Invoked when data is read into the buffer passed to+   * cronet_bidirectional_stream_read(). Only part of the buffer may be+   * populated. To continue reading, call cronet_bidirectional_stream_read().+   * It may be invoked after on_response_trailers_received()}, if there was+   * pending read data before trailers were received.+   *+   * If count is 0, it means the remote side has signaled that it will send no+   * more data; future calls to cronet_bidirectional_stream_read() will result+   * in the on_data_read() callback or on_succeded() callback if",> the on_data_read() callback or on_succeded() callbackWhat are those? They aren't mentioned before.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6214,60297011,2016-04-19T19:40:01Z,src/core/ext/transport/cronet/transport/cronet_c_for_grpc.h,"@@ -0,0 +1,202 @@+// Copyright 2016 The Chromium Authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++#ifndef COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_+#define COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_++#ifdef __cplusplus+extern ""C"" {+#endif++#include <stddef.h>++/* Cronet Engine API. */++/* Opaque object representing Cronet Engine. Created and configured outside+ * of this API to facilitate sharing with other components */+typedef struct cronet_engine { void* obj; } cronet_engine;++void cronet_engine_add_quic_hint(cronet_engine* engine,+                                 const char* host,+                                 int port,+                                 int alternate_port);++/* Cronet Bidirectional Stream API */++/* Opaque object representing Cronet Bidirectional Stream. */+typedef struct cronet_bidirectional_stream {+  void* obj;+  void* annotation;+} cronet_bidirectional_stream;++/* A single request or response header element. */+typedef struct cronet_bidirectional_stream_header {+  const char* key;+  const char* value;+} cronet_bidirectional_stream_header;++/* Array of request or response headers or trailers. */+typedef struct cronet_bidirectional_stream_header_array {+  size_t count;+  size_t capacity;+  cronet_bidirectional_stream_header* headers;+} cronet_bidirectional_stream_header_array;++/* Set of callbacks used to receive callbacks from bidirectional stream. */+typedef struct cronet_bidirectional_stream_callback {+  /* Invoked when request headers are sent. Indicates that stream has initiated+   * the request. Consumer may call cronet_bidirectional_stream_write() to start+   * writing data.+   */+  void (*on_request_headers_sent)(cronet_bidirectional_stream* stream);++  /* Invoked when initial response headers are received.+   * Consumer must call cronet_bidirectional_stream_read() to start reading.+   * Consumer may call cronet_bidirectional_stream_write() to start writing or+   * close the stream. Contents of |headers| is valid for duration of the call.+   */+  void (*on_response_headers_received)(+      cronet_bidirectional_stream* stream,+      const cronet_bidirectional_stream_header_array* headers,+      const char* negotiated_protocol);++  /* Invoked when data is read into the buffer passed to+   * cronet_bidirectional_stream_read(). Only part of the buffer may be",> into the buffer passed to `cronet_bidirectional_stream_read()`Will that buffer be the value of `data`?,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6214,60297186,2016-04-19T19:41:14Z,src/core/ext/transport/cronet/transport/cronet_c_for_grpc.h,"@@ -0,0 +1,202 @@+// Copyright 2016 The Chromium Authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++#ifndef COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_+#define COMPONENTS_CRONET_IOS_CRONET_C_FOR_GRPC_H_++#ifdef __cplusplus+extern ""C"" {+#endif++#include <stddef.h>++/* Cronet Engine API. */++/* Opaque object representing Cronet Engine. Created and configured outside+ * of this API to facilitate sharing with other components */+typedef struct cronet_engine { void* obj; } cronet_engine;++void cronet_engine_add_quic_hint(cronet_engine* engine,+                                 const char* host,+                                 int port,+                                 int alternate_port);++/* Cronet Bidirectional Stream API */++/* Opaque object representing Cronet Bidirectional Stream. */+typedef struct cronet_bidirectional_stream {+  void* obj;+  void* annotation;+} cronet_bidirectional_stream;++/* A single request or response header element. */+typedef struct cronet_bidirectional_stream_header {+  const char* key;+  const char* value;+} cronet_bidirectional_stream_header;++/* Array of request or response headers or trailers. */+typedef struct cronet_bidirectional_stream_header_array {+  size_t count;+  size_t capacity;+  cronet_bidirectional_stream_header* headers;+} cronet_bidirectional_stream_header_array;++/* Set of callbacks used to receive callbacks from bidirectional stream. */+typedef struct cronet_bidirectional_stream_callback {+  /* Invoked when request headers are sent. Indicates that stream has initiated+   * the request. Consumer may call cronet_bidirectional_stream_write() to start+   * writing data.+   */+  void (*on_request_headers_sent)(cronet_bidirectional_stream* stream);++  /* Invoked when initial response headers are received.+   * Consumer must call cronet_bidirectional_stream_read() to start reading.+   * Consumer may call cronet_bidirectional_stream_write() to start writing or+   * close the stream. Contents of |headers| is valid for duration of the call.+   */+  void (*on_response_headers_received)(+      cronet_bidirectional_stream* stream,+      const cronet_bidirectional_stream_header_array* headers,+      const char* negotiated_protocol);++  /* Invoked when data is read into the buffer passed to+   * cronet_bidirectional_stream_read(). Only part of the buffer may be+   * populated. To continue reading, call cronet_bidirectional_stream_read().+   * It may be invoked after on_response_trailers_received()}, if there was+   * pending read data before trailers were received.+   *+   * If count is 0, it means the remote side has signaled that it will send no+   * more data; future calls to cronet_bidirectional_stream_read() will result+   * in the on_data_read() callback or on_succeded() callback if+   * cronet_bidirectional_stream_write() was invoked with end_of_stream set to+   * true.+   */+  void (*on_read_completed)(cronet_bidirectional_stream* stream,+                            char* data,+                            int count);++  /**+   * Invoked when all data passed to cronet_bidirectional_stream_write() is+   * sent.+   * To continue writing, call cronet_bidirectional_stream_write().+   */+  void (*on_write_completed)(cronet_bidirectional_stream* stream,+                             const char* data);",What will the value of `data` be?,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/5958,60312342,2016-04-19T21:12:29Z,include/grpc++/security/server_credentials.h,"@@ -39,6 +39,7 @@  #include <grpc++/security/auth_metadata_processor.h> #include <grpc++/support/config.h>+#include <grpc/grpc_security.h>","Yup. New header LGTM. Thanks!On Tue, Apr 19, 2016 at 2:03 PM, deepaklukose notifications@github.comwrote:> In include/grpc++/security/server_credentials.h> https://github.com/grpc/grpc/pull/5958#discussion_r60310744:> > > @@ -39,6 +39,7 @@> > > >  #include <grpc++/security/auth_metadata_processor.h>> >  #include <grpc++/support/config.h>> > +#include <grpc/grpc_security.h>> > Done. Can you take another look to ensure this is how you guys envisioned> it.> > —> You are receiving this because you were mentioned.> Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/5958/files/dce598c9547dcb5340375232ce4dfdede369d048#r60310744",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/5826,60324173,2016-04-19T22:35:00Z,src/proto/grpc/testing/control.proto,"@@ -34,20 +34,16 @@ import ""src/proto/grpc/testing/stats.proto"";  package grpc.testing; -enum ClientType {-  SYNC_CLIENT = 0;-  ASYNC_CLIENT = 1;-}--enum ServerType {-  SYNC_SERVER = 0;-  ASYNC_SERVER = 1;-  ASYNC_GENERIC_SERVER = 2;-}- enum RpcType {-  UNARY = 0;-  STREAMING = 1;+  // First there are ping-pong RPCs in which the client sends a request and the+  // server sends a response+  UNARY = 0; // unary RPC, ping-pong by nature+  STREAMING_PING_PONG = 1; // streaming ping-pong RPCs","considering we are already running the tests on jenkins in multiple languages, changing the naming here will probably require a bit more coordination between language implementations.Also, we will need to test that all the languages work before we submit this change.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6190,60327641,2016-04-19T23:06:57Z,src/core/lib/channel/channel_stack.c,"@@ -189,29 +189,32 @@ void grpc_call_stack_init(grpc_exec_ctx *exec_ctx,   } } -void grpc_call_stack_set_pollset(grpc_exec_ctx *exec_ctx,-                                 grpc_call_stack *call_stack,-                                 grpc_pollset *pollset) {+void grpc_call_stack_set_pollset_or_pollset_set(+    grpc_exec_ctx *exec_ctx, grpc_call_stack *call_stack, grpc_pollset *pollset,+    grpc_pollset_set *or_pollset_set) {   size_t count = call_stack->count;   grpc_call_element *call_elems;   char *user_data;   size_t i; +  GPR_ASSERT(!(pollset != NULL && or_pollset_set != NULL));",makes my brain bleed: rename parameter? (I know I suggested the name),
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6229,60468470,2016-04-20T19:03:24Z,src/proto/grpc/binary_log/v1alpha/log.proto,"@@ -29,20 +29,20 @@ ","@kpayson64   if this PR gets delayed, can we at least create a separate PR to fix the log.proto? (it seems to be an independent change).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6249,60632452,2016-04-21T18:31:28Z,test/core/memory/memory_client.c,"@@ -0,0 +1,180 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/grpc.h>++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/cmdline.h>+#include <grpc/support/log.h>+#include <grpc/support/useful.h>+#include ""test/core/util/memory_counters.h""+#include ""test/core/util/test_config.h""++static struct grpc_memory_counters counters, previous_counters;++static void show_counters() {+  gpr_log(GPR_INFO, ""  actual memory allocated:       %zu"", counters.total_size_relative);+  gpr_log(GPR_INFO, ""  total memory allocated:        %zu"", counters.total_size_absolute);+  gpr_log(GPR_INFO, ""  current number of allocations: %zu"", counters.total_allocs_relative);+  gpr_log(GPR_INFO, ""  total number of allocations:   %zu"", counters.total_allocs_absolute);+}++static void show_difference() {+  gpr_log(GPR_INFO, ""  actual memory allocated:       %zi"", counters.total_size_relative - previous_counters.total_size_relative);+  gpr_log(GPR_INFO, ""  total memory allocated:        %zi"", counters.total_size_absolute - previous_counters.total_size_absolute);+  gpr_log(GPR_INFO, ""  current number of allocations: %zi"", counters.total_allocs_relative - previous_counters.total_allocs_relative);+  gpr_log(GPR_INFO, ""  total number of allocations:   %zi"", counters.total_allocs_absolute - previous_counters.total_allocs_absolute);+}++static void memory_probe(const char *op) {+  gpr_log(GPR_INFO, ""Client - Memory usage after %s:"", op);+  counters = grpc_memory_counters_snapshot();+  show_counters();+  gpr_log(GPR_INFO, ""Client - Difference since last probe:"");+  show_difference();+  previous_counters = counters;+  gpr_log(GPR_INFO, ""----------------"");+}++int main(int argc, char **argv) {+  grpc_byte_buffer *the_buffer;+  grpc_channel *channel;+  grpc_completion_queue *cq;+  grpc_call *call;+  grpc_call_error error;+  grpc_op ops[6];+  grpc_op *op;+  grpc_metadata_array initial_metadata_recv;+  grpc_metadata_array trailing_metadata_recv;+  grpc_byte_buffer *response_payload_recv = NULL;+  grpc_status_code status;+  char *details = NULL;+  size_t details_capacity = 0;+  char *fake_argv[1];+  int payload_size = 1;+  char *target = ""localhost:8080"";+  gpr_cmdline *cl;+  grpc_event event;++  grpc_memory_counters_init();+  previous_counters = grpc_memory_counters_snapshot();+  grpc_init();++  GPR_ASSERT(argc >= 1);+  fake_argv[0] = argv[0];+  grpc_test_init(1, fake_argv);++  cl = gpr_cmdline_create(""memory test client"");+  gpr_cmdline_add_int(cl, ""payload_size"", ""Size of the payload to send"",+                      &payload_size);+  gpr_cmdline_add_string(cl, ""target"", ""Target host:port"", &target);+  gpr_cmdline_parse(cl, argc, argv);+  gpr_cmdline_destroy(cl);+  memory_probe(""grpc_init & command line"");++  channel = grpc_insecure_channel_create(target, NULL, NULL);+  memory_probe(""grpc_insecure_channel_create"");++  cq = grpc_completion_queue_create(NULL);+  memory_probe(""grpc_completion_queue_create"");+  gpr_slice slice = gpr_slice_from_copied_string(""x"");+  the_buffer = grpc_raw_byte_buffer_create(&slice, (size_t)payload_size);+  memory_probe(""grpc_raw_byte_buffer_create"");++  grpc_metadata_array_init(&initial_metadata_recv);+  grpc_metadata_array_init(&trailing_metadata_recv);+  memory_probe(""grpc_metadata_array_init*2"");++  op = ops;++  memset(ops, 0, sizeof(ops));+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = 0;+  op++;+  op->op = GRPC_OP_SEND_MESSAGE;+  op->data.send_message = the_buffer;+  op++;+  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+  op++;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &initial_metadata_recv;+  op++;+  op->op = GRPC_OP_RECV_MESSAGE;+  op->data.recv_message = &response_payload_recv;+  op++;+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;+  op->data.recv_status_on_client.status = &status;+  op->data.recv_status_on_client.status_details = &details;+  op->data.recv_status_on_client.status_details_capacity = &details_capacity;+  op++;++  call = grpc_channel_create_call(channel, NULL, GRPC_PROPAGATE_DEFAULTS, cq,+                                  ""/Reflector/reflectUnary"", ""localhost"",+                                  gpr_inf_future(GPR_CLOCK_REALTIME), NULL);+  memory_probe(""grpc_channel_create_call"");+  error = grpc_call_start_batch(call, ops, (size_t)(op - ops), (void *)1, NULL);+  memory_probe(""grpc_call_start_batch"");+  GPR_ASSERT(error == GRPC_CALL_OK);+  grpc_completion_queue_next(cq, gpr_inf_future(GPR_CLOCK_REALTIME), NULL);+  memory_probe(""grpc_completion_queue_next"");+  grpc_call_destroy(call);+  gpr_free(details);+  memory_probe(""grpc_call_destroy"");+  grpc_byte_buffer_destroy(response_payload_recv);+  memory_probe(""grpc_byte_buffer_destroy"");++  grpc_channel_destroy(channel);+  memory_probe(""grpc_channel_destroy"");+  grpc_completion_queue_shutdown(cq);+  memory_probe(""grpc_completion_queue_shutdown"");+  do {+    event = grpc_completion_queue_next(cq, gpr_inf_future(GPR_CLOCK_REALTIME),+                                       NULL);+  } while (event.type != GRPC_QUEUE_SHUTDOWN);+  memory_probe(""grpc_completion_queue_next*n"");+  grpc_completion_queue_destroy(cq);+  memory_probe(""grpc_completion_queue_destroy"");+  grpc_byte_buffer_destroy(the_buffer);+  memory_probe(""grpc_byte_memory_buffer_destroy"");+  gpr_slice_unref(slice);+",grpc_metadata_array_destroy(&initial_metadata);grpc_metadata_array_destroy(&trailing_metadata);,
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/6172,60675367,2016-04-22T00:19:09Z,include/grpc++/impl/server_builder_plugin.h,"@@ -0,0 +1,70 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_SERVER_BUILDER_PLUGIN_H+#define GRPCXX_IMPL_SERVER_BUILDER_PLUGIN_H++#include <memory>++#include <grpc++/support/config.h>++namespace grpc {++class ServerInitializer;++class ServerBuilderPlugin {+ public:+  virtual ~ServerBuilderPlugin() {}+  virtual grpc::string name() = 0;+  virtual void InitServer(ServerInitializer* si) = 0;+  virtual void Finish(ServerInitializer* si) = 0;+  virtual void ChangeArguments(const grpc::string& name, void* value) = 0;+  virtual bool has_synchronous_methods() const { return false; }+  virtual bool has_async_methods() const { return false; }+};++}  // namespace grpc++#define DECLARE_PLUGIN(plugin_name)                                    \+  namespace sBP##plugin_name {                                         \",The naming in this macro is following the style in [gflags](https://github.com/gflags/gflags/blob/master/src/gflags_declare.h.in#L112).  Maybe the uppercase letters are used to avoid conflicts with user-defined namespaces.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6254,60809259,2016-04-22T22:03:57Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +105,33 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__+    name = metadata_plugin.__class__.__name__   return CallCredentials(       _low.call_credentials_metadata_plugin(metadata_plugin, name)) +def google_call_credentials(credentials):","I think the naming ""google_call_credentials"" and ""access_token_call_credential"" is good, let's get a second opinion from @nathanielmanistaatgoogle  or @soltanmm.  If everything else looks good, I think it's fine to submit this change and revisit the naming if necessary.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,60824177,2016-04-23T06:36:47Z,src/python/grpcio/grpc/beta/_auth.py,"@@ -0,0 +1,72 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent.futures import ThreadPoolExecutor","[""Use imports for packages and modules only.""](https://google.github.io/styleguide/pyguide.html?showone=Imports#Imports) Do not import classes, functions, or other code elements of modules.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,60824208,2016-04-23T06:39:31Z,src/python/grpcio/grpc/beta/_auth.py,"@@ -0,0 +1,72 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent.futures import ThreadPoolExecutor++from grpc.beta import interfaces+++class GoogleCallCredentials(interfaces.GRPCAuthMetadataPlugin):+  """"""Metadata wrapper for googleCredentials from the oauth2client library""""""++  def __init__(self, credentials):+    self._credentials = credentials+    self._pool = ThreadPoolExecutor(max_workers=1)++  def __call__(self, context, callback):+    # MetadataPlugins cannot block (see grpc.beta.interfaces.py)+    future = self._pool.submit(self._credentials.get_access_token)+    future.add_done_callback(lambda x: self._get_token_callback(callback, x))+ +  def _get_token_callback(self, callback, future):+    access_token = None+    error = None+    try:+      access_token = future.result().access_token+    except Exception as e:+      error = e+    _sign_request(callback, access_token, error)++  def __del__(self):+    self._pool.shutdown(wait=False)+++class AccessTokenCallCredentials(interfaces.GRPCAuthMetadataPlugin):+  """"""Metadata wrapper for raw access token credentials""""""++  def __init__(self, access_token):+    self._access_token = access_token++  def __call__(self, context, callback):+    _sign_request(callback, self._access_token, None)+++def _sign_request(callback, token, error):+  metadata = [('authorization', 'Bearer {}'.format(token))]","Never write a list literal (`[<expression>]`) where a tuple literal will do (`(<expression>,)`). Will a tuple literal do here?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,60977292,2016-04-25T19:55:29Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +105,33 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__+    name = metadata_plugin.__class__.__name__   return CallCredentials(       _low.call_credentials_metadata_plugin(metadata_plugin, name)) +def google_call_credentials(credentials):+  """"""Construct CallCredentials from google credentials++  Args:+    credentials: A google credentials object from oauth2client","Don't be ambiguous about the type of this parameter - use the correct, formal name of the interface or class.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,60977471,2016-04-25T19:56:46Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +105,33 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__+    name = metadata_plugin.__class__.__name__   return CallCredentials(       _low.call_credentials_metadata_plugin(metadata_plugin, name)) +def google_call_credentials(credentials):+  """"""Construct CallCredentials from google credentials++  Args:+    credentials: A google credentials object from oauth2client++  Returns:+    A CallCredentials object for header authentication+  """"""+  return metadata_call_credentials(_auth.GoogleCallCredentials(credentials))++def access_token_call_credentials(access_token):+  """"""Construct CallCredentials from a raw access token++  Args:+    access_token: A raw access token used for authentication","What's a ""raw access token""? A byte string? An instance of some interface or class?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,60978544,2016-04-25T20:03:35Z,src/python/grpcio/tests/unit/beta/_implementations_test.py,"@@ -48,6 +48,19 @@ def test_application_provided_root_certificates(self):     self.assertIsInstance(         channel_credentials, implementations.ChannelCredentials) +class CallCredentialsTest(unittest.TestCase):++  def test_google_call_credentials(self):+    class MockGoogleCreds:",Missing inheritance from `object` - but why are you using a mock here anyway? Why not use a real instance?[I have some opinions on the subject](https://www.youtube.com/watch?v=Xu5EhKVZdV8).,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6281,60981137,2016-04-25T20:19:25Z,src/csharp/Grpc.Core/VersionInfo.cs,"@@ -35,13 +35,20 @@ namespace Grpc.Core {     /// <summary>     /// Provides info about current version of gRPC.+    /// See https://codingforsmarties.wordpress.com/2016/01/21/how-to-version-assemblies-destined-for-nuget/+    /// for rationale about assembly versioning.     /// </summary>     public static class VersionInfo     {         /// <summary>-        /// Current version of gRPC C# assemblies+        /// Current <c>AssemblyVersion</c> attribute of gRPC C# assemblies         /// </summary>-        public const string CurrentAssemblyVersion = ""0.14.0.0"";+        public const string CurrentAssemblyVersion = ""1.0.0.0"";","The major version now is technically ""0"", but does it make sense to make the assembly version ""1.0.0.0"", as that would avoid the need for redirect once GA is released?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,61007577,2016-04-25T23:28:54Z,src/python/grpcio/tests/unit/beta/_auth_test.py,"@@ -0,0 +1,95 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests of standard AuthMetadataPlugins.""""""++import threading+import unittest++from grpc.beta import _auth+++class GoogleCallCredentialsTest(unittest.TestCase):++  def test_google_call_credentials_success(self):+    callback_event = threading.Event()++    def mock_callback(metadata, error):+      self.assertEqual(metadata, (('authorization', 'Bearer token'),))+      self.assertIsNone(error)+      callback_event.set()++    class MockAccessToken(dict):+      pass++    class MockGoogleCreds(object):++      def get_access_token(self):+        token = MockAccessToken()+        token.access_token = 'token'+        return token++    call_creds = _auth.GoogleCallCredentials(MockGoogleCreds())+    call_creds(None, mock_callback)+    self.assertTrue(callback_event.wait(1.0))++  def test_google_call_credentials_error(self):+    callback_event = threading.Event()++    def mock_callback(metadata, error):+      self.assertIsNotNone(error)+      callback_event.set()++    class MockGoogleCreds(object):",This class doesn't require any of what's available to it in function-scope; please extract it to module-scope.,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6254,61009790,2016-04-25T23:51:01Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +106,37 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__","By default python objects don't have a **name** attribute.  If I pass in an arbitrary MetadataPlugin, it will throw an exception.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6254,61011054,2016-04-26T00:03:53Z,src/python/grpcio/tests/interop/client.py,"@@ -109,8 +104,7 @@ def _test_case_from_arg(test_case_arg):   for test_case in methods.TestCase:     if test_case_arg == test_case.value:       return test_case-  else:",glint complained:W0120:107:_test_case_from_arg: Else clause on loop without a break statement [useless-else-on-loop]I've changed it back though.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6214,61011209,2016-04-26T00:05:52Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -0,0 +1,583 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>++#include <grpc/impl/codegen/port_platform.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>+#include <grpc/support/slice_buffer.h>+#include <grpc/support/string_util.h>+#include <grpc/support/useful.h>++#include ""src/core/ext/transport/chttp2/transport/incoming_metadata.h""+#include ""src/core/lib/iomgr/exec_ctx.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/channel.h""+#include ""src/core/lib/transport/metadata_batch.h""+#include ""src/core/lib/transport/transport_impl.h""+#include ""third_party/objective_c/Cronet/cronet_c_for_grpc.h""++#ifdef COMPILE_WITH_CRONET++#define GRPC_HEADER_SIZE_IN_BYTES 5+#define MAX_HDRS 100++#define GRPC_CRONET_TRACE(...)                   \+  {                                              \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  }+#define CRONET_READ(...)                                                   \+  {                                                                        \+    GRPC_CRONET_TRACE(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()""); \+    cronet_bidirectional_stream_read(__VA_ARGS__);                         \+  }+#define SET_RECV_STATE(STATE)                                                \+  {                                                                          \+    GRPC_CRONET_TRACE(GPR_DEBUG, ""next_state = %s"", recv_state_name[STATE]); \+    cronet_recv_state = STATE;                                               \+  }++// Global flag that gets set with GRPC_TRACE env variable+int grpc_cronet_trace = 1;++// Cronet transport object+struct grpc_cronet_transport {+  grpc_transport base; /* must be first element in this structure */+  cronet_engine *engine;+  const char *host;+};++typedef struct grpc_cronet_transport grpc_cronet_transport;++enum send_state {+  CRONET_SEND_IDLE = 0,+  CRONET_REQ_STARTED,+  CRONET_SEND_HEADER,+  CRONET_WRITE,+  CRONET_WRITE_COMPLETED,+};++enum recv_state {+  CRONET_RECV_IDLE = 0,+  CRONET_RECV_READ_LENGTH,+  CRONET_RECV_READ_DATA,+  CRONET_RECV_CLOSED,+};++const char *recv_state_name[] = {""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"",+                                 ""CRONET_RECV_READ_DATA,"",+                                 ""CRONET_RECV_CLOSED""};++// Enum that identifies calling function.+enum e_caller {+  PERFORM_STREAM_OP,+  ON_READ_COMPLETE,+  ON_RESPONSE_HEADERS_RECEIVED,+  ON_RESPONSE_TRAILERS_RECEIVED+};++enum callback_id {+  CB_SEND_INITIAL_METADATA = 0,+  CB_SEND_MESSAGE,+  CB_SEND_TRAILING_METADATA,+  CB_RECV_MESSAGE,+  CB_RECV_INITIAL_METADATA,+  CB_RECV_TRAILING_METADATA,+  CB_NUM_CALLBACKS+};++struct stream_obj {+  // we store received bytes here as they trickle in.+  gpr_slice_buffer write_slicebuffer;+  cronet_bidirectional_stream *cbs;+  gpr_slice slice;+  gpr_slice_buffer read_slicebuffer;+  struct grpc_slice_buffer_stream sbs;+  char *read_buffer;+  uint32_t remaining_read_bytes;+  uint32_t total_read_bytes;++  char *write_buffer;+  size_t write_buffer_size;++  //+  char *url;+  char *host;++  bool response_headers_received;+  bool read_requested;+  bool response_trailers_received;+  bool read_closed;++  // Recv message stuff+  grpc_byte_buffer **recv_message;+  // Initial metadata stuff+  grpc_metadata_batch *recv_initial_metadata;+  // Trailing metadata stuff+  grpc_metadata_batch *recv_trailing_metadata;+  grpc_chttp2_incoming_metadata_buffer imb;++  // This mutex protects receive state machine execution+  gpr_mu recv_mu;+  // we can queue up up to 2 callbacks for each OP+  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];++  // storage for header+  cronet_bidirectional_stream_header headers[MAX_HDRS];+  uint32_t num_headers;+  cronet_bidirectional_stream_header_array header_array;+};++typedef struct stream_obj stream_obj;++void next_send_step(stream_obj *s);+void next_recv_step(stream_obj *s, enum e_caller caller);++enum send_state cronet_send_state;+enum recv_state cronet_recv_state;++static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,+                                   grpc_stream *gs, grpc_pollset *pollset) {}++void enqueue_callbacks(grpc_closure *callback_list[]) {+  grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;+  if (callback_list[0]) {+    // GRPC_CRONET_TRACE(GPR_DEBUG, ""enqueuing callback = %p"",+    // callback_list[0]);+    grpc_exec_ctx_enqueue(&exec_ctx, callback_list[0], true, NULL);+    callback_list[0] = NULL;+  }+  if (callback_list[1]) {+    // GRPC_CRONET_TRACE(GPR_DEBUG, ""enqueuing callback = %p"",+    // callback_list[1]);+    grpc_exec_ctx_enqueue(&exec_ctx, callback_list[1], true, NULL);+    callback_list[1] = NULL;+  }+  grpc_exec_ctx_finish(&exec_ctx);+}++void on_canceled(cronet_bidirectional_stream *stream) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""on_canceled %p"", stream);+}+void on_failed(cronet_bidirectional_stream *stream, int net_error) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""on_failed %p, error = %d"", stream, net_error);+}+void on_succeded(cronet_bidirectional_stream *stream) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""on_succeeded %p"", stream);+}+void on_response_trailers_received(+    cronet_bidirectional_stream *stream,+    const cronet_bidirectional_stream_header_array *trailers) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""R: on_response_trailers_received"");+  stream_obj *s = (stream_obj *)stream->annotation;++  memset(&s->imb, 0, sizeof(s->imb));+  grpc_chttp2_incoming_metadata_buffer_init(&s->imb);+  int i = 0;+  for (i = 0; i < trailers->count; i++) {+    grpc_chttp2_incoming_metadata_buffer_add(+        &s->imb, grpc_mdelem_from_metadata_strings(+                     grpc_mdstr_from_string(trailers->headers[i].key),+                     grpc_mdstr_from_string(trailers->headers[i].value)));+  }+  s->response_trailers_received = true;+  next_recv_step(s, ON_RESPONSE_TRAILERS_RECEIVED);+}+void on_write_completed(cronet_bidirectional_stream *stream, const char *data) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""W: on_write_completed"");+  stream_obj *s = (stream_obj *)stream->annotation;+  enqueue_callbacks(s->callback_list[CB_SEND_MESSAGE]);+  cronet_send_state = CRONET_WRITE_COMPLETED;+  next_send_step(s);+}++void process_recv_message(stream_obj *s, const uint8_t *recv_data) {+  gpr_slice read_data_slice = gpr_slice_malloc(s->total_read_bytes);+  uint8_t *dst_p = GPR_SLICE_START_PTR(read_data_slice);+  memcpy(dst_p, recv_data, s->total_read_bytes);+  gpr_slice_buffer_add(&s->read_slicebuffer, read_data_slice);+  grpc_slice_buffer_stream_init(&s->sbs, &s->read_slicebuffer, 0);+  *s->recv_message = (grpc_byte_buffer *)&s->sbs;+}++int parse_grpc_header(const uint8_t *data) {+  const uint8_t *p = data + 1;+  uint32_t length = 0;+  length |= ((uint8_t)*p++) << 24;+  length |= ((uint8_t)*p++) << 16;+  length |= ((uint8_t)*p++) << 8;+  length |= ((uint8_t)*p++);+  return length;+}++void on_read_completed(cronet_bidirectional_stream *stream, char *data,+                       int count) {+  stream_obj *s = (stream_obj *)stream->annotation;+  GRPC_CRONET_TRACE(GPR_DEBUG,+                    ""R: on_read_completed count=%d, total=%d, remaining=%d"",+                    count, s->total_read_bytes, s->remaining_read_bytes);+  if (count > 0) {+    GPR_ASSERT(s->recv_message);+    s->remaining_read_bytes -= count;+    next_recv_step(s, ON_READ_COMPLETE);+  } else {+    s->read_closed = true;+    next_recv_step(s, ON_READ_COMPLETE);+  }+}++void on_response_headers_received(+    cronet_bidirectional_stream *stream,+    const cronet_bidirectional_stream_header_array *headers,+    const char *negotiated_protocol) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""R: on_response_headers_received"");+  stream_obj *s = (stream_obj *)stream->annotation;+  enqueue_callbacks(s->callback_list[CB_RECV_INITIAL_METADATA]);+  s->response_headers_received = true;+  next_recv_step(s, ON_RESPONSE_HEADERS_RECEIVED);+}++void on_request_headers_sent(cronet_bidirectional_stream *stream) {+  GRPC_CRONET_TRACE(GPR_DEBUG, ""W: on_request_headers_sent"");+  stream_obj *s = (stream_obj *)stream->annotation;+  enqueue_callbacks(s->callback_list[CB_SEND_INITIAL_METADATA]);+  cronet_send_state = CRONET_SEND_HEADER;+  next_send_step(s);+}++// Callback function pointers (invoked by cronet in response to events)+cronet_bidirectional_stream_callback callbacks = {on_request_headers_sent,+                                                  on_response_headers_received,+                                                  on_read_completed,+                                                  on_write_completed,+                                                  on_response_trailers_received,+                                                  on_succeded,+                                                  on_failed,+                                                  on_canceled};++void invoke_closing_callback(stream_obj *s) {+  grpc_chttp2_incoming_metadata_buffer_publish(&s->imb,+                                               s->recv_trailing_metadata);+  if (s->callback_list[CB_RECV_TRAILING_METADATA]) {+    enqueue_callbacks(s->callback_list[CB_RECV_TRAILING_METADATA]);+  }+}++// This is invoked from perform_stream_op, and all on_xxxx callbacks.+void next_recv_step(stream_obj *s, enum e_caller caller) {+  gpr_mu_lock(&s->recv_mu);+  switch (cronet_recv_state) {+    case CRONET_RECV_IDLE:+      GRPC_CRONET_TRACE(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_IDLE"");+      if (caller == PERFORM_STREAM_OP ||+          caller == ON_RESPONSE_HEADERS_RECEIVED) {+        if (s->read_closed && s->response_trailers_received) {+          invoke_closing_callback(s);+          SET_RECV_STATE(CRONET_RECV_CLOSED);+        } else if (s->response_headers_received == true &&+                   s->read_requested == true) {+          SET_RECV_STATE(CRONET_RECV_READ_LENGTH);+          s->total_read_bytes = s->remaining_read_bytes =+              GRPC_HEADER_SIZE_IN_BYTES;+          GPR_ASSERT(s->read_buffer);+          CRONET_READ(s->cbs, s->read_buffer, s->remaining_read_bytes);+        }+      }+      break;+    case CRONET_RECV_READ_LENGTH:+      GRPC_CRONET_TRACE(GPR_DEBUG,+                        ""cronet_recv_state = CRONET_RECV_READ_LENGTH"");+      if (caller == ON_READ_COMPLETE) {+        if (s->read_closed) {+          invoke_closing_callback(s);+          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);+          SET_RECV_STATE(CRONET_RECV_CLOSED);+        } else {+          GPR_ASSERT(s->remaining_read_bytes == 0);+          SET_RECV_STATE(CRONET_RECV_READ_DATA);+          s->total_read_bytes = s->remaining_read_bytes =+              parse_grpc_header(s->read_buffer);+          s->read_buffer = gpr_realloc(s->read_buffer, s->remaining_read_bytes);+          GPR_ASSERT(s->read_buffer);+          CRONET_READ(s->cbs, (char *)s->read_buffer, s->remaining_read_bytes);+        }+      }+      break;+    case CRONET_RECV_READ_DATA:+      GRPC_CRONET_TRACE(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_DATA"");+      if (caller == ON_READ_COMPLETE) {+        if (s->remaining_read_bytes > 0) {+          int offset = s->total_read_bytes - s->remaining_read_bytes;+          GPR_ASSERT(s->read_buffer);+          CRONET_READ(s->cbs, (char *)s->read_buffer + offset,+                      s->remaining_read_bytes);+        } else {+          gpr_slice_buffer_init(&s->read_slicebuffer);+          uint8_t *p = s->read_buffer;+          process_recv_message(s, p);+          SET_RECV_STATE(CRONET_RECV_IDLE);+          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);+        }+      }+      break;+    case CRONET_RECV_CLOSED:+      break;+    default:+      GPR_ASSERT(0);  // Should not reach here+      break;+  }+  gpr_mu_unlock(&s->recv_mu);+}++// This function takes the data from s->write_slicebuffer and assembles into+// a contiguous byte stream with 5 byte gRPC header prepended.+void create_grpc_frame(stream_obj *s) {+  gpr_slice slice = gpr_slice_buffer_take_first(&s->write_slicebuffer);+  uint8_t *raw_data = GPR_SLICE_START_PTR(slice);+  size_t length = GPR_SLICE_LENGTH(slice);+  s->write_buffer_size = length + GRPC_HEADER_SIZE_IN_BYTES;+  s->write_buffer = gpr_realloc(s->write_buffer, s->write_buffer_size);+  uint8_t *p = s->write_buffer;+  // Append 5 byte header+  *p++ = 0;+  *p++ = (uint8_t)(length >> 24);+  *p++ = (uint8_t)(length >> 16);+  *p++ = (uint8_t)(length >> 8);+  *p++ = (uint8_t)(length);+  // append actual data+  memcpy(p, raw_data, length);+}++void do_write(stream_obj *s) {+  gpr_slice_buffer *sb = &s->write_slicebuffer;+  GPR_ASSERT(sb->count <= 1);+  if (sb->count > 0) {+    create_grpc_frame(s);+    GRPC_CRONET_TRACE(GPR_DEBUG, ""W: cronet_bidirectional_stream_write"");+    cronet_bidirectional_stream_write(s->cbs, s->write_buffer,+                                      (int)s->write_buffer_size, false);+  }+}++//+void next_send_step(stream_obj *s) {+  switch (cronet_send_state) {+    case CRONET_SEND_IDLE:+      GPR_ASSERT(+          s->cbs);  // cronet_bidirectional_stream is not initialized yet.+      cronet_send_state = CRONET_REQ_STARTED;+      GRPC_CRONET_TRACE(GPR_DEBUG, ""cronet_bidirectional_stream_start to %s"",+                        s->url);+      cronet_bidirectional_stream_start(s->cbs, s->url, 0, ""POST"",+                                        &s->header_array, false);+      break;+    case CRONET_SEND_HEADER:+      do_write(s);+      cronet_send_state = CRONET_WRITE;+      break;+    case CRONET_WRITE_COMPLETED:+      do_write(s);+      break;+    default:+      GPR_ASSERT(0);+      break;+  }+}++void create_url(const char *path, const char *host, stream_obj *s) {+  const char prefix[] = ""https://"";+  s->url = gpr_malloc(strlen(prefix) + strlen(host) + strlen(path) + 1);+  strcpy(s->url, prefix);+  strcat(s->url, host);+  strcat(s->url, path);+}++static void convert_metadata_to_cronet_headers(grpc_linked_mdelem *head,+                                               const char *host,+                                               stream_obj *s) {+  grpc_linked_mdelem *curr = head;+  while (s->num_headers < MAX_HDRS) {",Silently discarding seems to be a bad option,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,61030775,2016-04-26T05:34:30Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +106,37 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__","It seems to me that an object's name, if present, is more likely to be helpful than its class name. Should this code look for the object name and only use the class name if it is not found? I believe @soltanmm originally authored this and may have an opinion.",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/6220,61179904,2016-04-26T23:07:08Z,package.xml,"@@ -996,8 +996,8 @@ Update to wrap gRPC C Core version 0.10.0   </release>   <release>    <version>-    <release>0.14.0</release>-    <api>0.14.0</api>+    <release>0.8.1</release>","So this is a bit backward. This line of code you are looking at is at the bottom of the file, in the area of listing all the history of releases. However, in the past, I had (incorrectly) replaced the release number there, with a templatized release string. Since this is the generated file, it contains whatever it's on the current release, even though the content of that block, did refer to the old 0.8.1 release. Anyway, I am pretty sure this is correct. It's just that the release string is in multiple places. This is the history section which adds to the confusion.",
5857998,BenchR267,https://api.github.com/repos/grpc/grpc/pulls/6205,61282017,2016-04-27T15:40:39Z,src/compiler/objective_c_plugin.cc,"@@ -82,10 +81,12 @@ class ObjectiveCGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {         declarations += grpc_objective_c_generator::GetHeader(service);       } +      ::grpc::string nonNullBegin = ""\nNS_ASSUME_NONNULL_BEGIN\n\n"";","Sorry for the long response time, I was very busy :) Very good proposal, I am not that much into C++ so I am not familiar with all coding styles :) I've changed it in 1843ccb",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6190,61343603,2016-04-27T21:55:32Z,src/core/ext/client_config/subchannel_call_holder.c,"@@ -68,6 +68,7 @@ void grpc_subchannel_call_holder_init(   holder->waiting_ops_capacity = 0;   holder->creation_phase = GRPC_SUBCHANNEL_CALL_HOLDER_NOT_CREATING;   holder->owning_call = owning_call;+  holder->pollset_set = grpc_pollset_set_create();",This is going to be quite bad for performance. The typical case is that we just want to set a pollset and not go ahead and create a new big container of object. Suggest bifurcating here and only creating the pollset_set when necessary.,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/6284,61357398,2016-04-28T00:09:25Z,src/compiler/csharp_plugin.cc,"@@ -48,7 +48,29 @@ class CSharpGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {                 const grpc::string &parameter,                 grpc::protobuf::compiler::GeneratorContext *context,                 grpc::string *error) const {-    grpc::string code = grpc_csharp_generator::GetServices(file);+    std::vector<std::pair<grpc::string, grpc::string> > options;+    grpc::protobuf::compiler::ParseGeneratorParameter(parameter, &options);++    bool generate_client = true;","In general, I would recommend moving all of these into a ""generator options"" class that would have the proper defaults and everything, which makes it easier for maintenance in the future. Doesn't need to be done now however.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6328,61503416,2016-04-28T21:12:45Z,tools/run_tests/performance/remote_host_prepare.sh,"@@ -41,10 +41,9 @@ ssh ""${USER_AT_HOST}"" ""rm -rf ~/performance_workspace && mkdir -p ~/performance_ # could also kill jenkins. ssh ""${USER_AT_HOST}"" ""killall -9 qps_worker mono node ruby || true""","technically, no. but let's leave it to minimize the chance we don't get garbage data out of the multi-machine setup.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6172,61622749,2016-04-29T18:17:40Z,src/cpp/plugin/reflection/reflection.proto,"@@ -0,0 +1,93 @@+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// Service exported by server reflection++syntax = ""proto3"";+import ""google/protobuf/descriptor.proto"";++package grpc.reflection.v1;++service ServerReflection {+  // List the full names of registered services.+  rpc ListService(EmptyRequest) returns (ListServiceResponse) {+  }++  // Find a proto file by file name.+  rpc GetFileByName(FileNameRequest) returns (FileDescriptorProtoResponse) {+  }++  // Find the proto file that declares the given fully-qualified symbol name.+  rpc GetFileContainingSymbol(SymbolRequest)+      returns (FileDescriptorProtoResponse) {+  }++  // Find the proto file which defines an extension extending the given message+  // type with the given field number.+  rpc GetFileContainingExtention(ExtensionRequest)+      returns (FileDescriptorProtoResponse) {+  }++  // Finds the tag numbers used by all known extensions of extendee_type, and+  // appends them to ExtensionNumberResponse in an undefined order.+  rpc GetAllExtensionNumbers(TypeRequest) returns (ExtensionNumberResponse) {+  }+}++message EmptyRequest {+}++message FileNameRequest {+  string filename = 1;+}++message SymbolRequest {+  string symbol = 1;+}++message ExtensionRequest {+  string containing_type = 1;+  int32 extension_number = 2;+}++message TypeRequest {+  string type = 1;+}++message ListServiceResponse {+  repeated string services = 1;+}++message FileDescriptorProtoResponse {+  google.protobuf.FileDescriptorProto file_descriptor_proto = 1;","for some languages (like C# and ruby I think), the only supported proto version is  proto3. That means they have limited support for work with descriptors (that are proto2).  In C# for example,   you can obtain an opaque binary blob that contains serialized version of FileDescriptorProto, but you don't have access to that proto message itself.Therefore, we'll probably need to send a ""bytes"" field here, which contains serialized version of FileDescriptorProto.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6393,61786418,2016-05-02T19:06:17Z,src/csharp/Grpc.Core/Internal/AsyncCall.cs,"@@ -407,12 +407,15 @@ private void HandleReceivedResponseHeaders(bool success, Metadata responseHeader         /// <summary>         /// Handler for unary response completion.         /// </summary>-        private void HandleUnaryResponse(bool success, ClientSideStatus receivedStatus, byte[] receivedMessage, Metadata responseHeaders)+        private void HandleUnaryResponse(bool sucess, ClientSideStatus receivedStatus, byte[] receivedMessage, Metadata responseHeaders)         {+            // NOTE: because this event is a result of batch containing GRPC_OP_RECV_STATUS_ON_CLIENT,+            // success will be always set to true.","The recv_status_on_client will also make the other ops succeed.https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/grpc_types.h#L307_This operation always succeeds, meaning ops paired with this operation      will also appear to succeed, even though they may not have. In that case      the status will indicate some failure._",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/6414,61994743,2016-05-04T06:41:51Z,src/proto/grpc/reflection/v1alpha/reflection.proto,"@@ -0,0 +1,92 @@+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// Service exported by server reflection++syntax = ""proto3"";++package grpc.reflection.v1alpha;++service ServerReflection {+  // List the full names of registered services.+  rpc ListService(EmptyRequest) returns (ListServiceResponse) {+  }++  // Find a proto file by file name.+  rpc GetFileByName(FileNameRequest) returns (FileDescriptorProtoResponse) {+  }++  // Find the proto file that declares the given fully-qualified symbol name.+  rpc GetFileContainingSymbol(SymbolRequest)+      returns (FileDescriptorProtoResponse) {+  }++  // Find the proto file which defines an extension extending the given message+  // type with the given field number.+  rpc GetFileContainingExtension(ExtensionRequest)+      returns (FileDescriptorProtoResponse) {+  }++  // Finds the tag numbers used by all known extensions of extendee_type, and+  // appends them to ExtensionNumberResponse in an undefined order.+  rpc GetAllExtensionNumbers(TypeRequest) returns (ExtensionNumberResponse) {",I think the reflection service is still useful. The extensions issue is mentioned in the definition file in: https://github.com/grpc/grpc/blob/master/doc/server-reflection.md . It should be the job of the command line tool or similar tools to handle the unimplemented error.,
10135909,dklempner,https://api.github.com/repos/grpc/grpc/pulls/6414,62274868,2016-05-06T00:12:20Z,src/proto/grpc/reflection/v1alpha/reflection.proto,"@@ -0,0 +1,131 @@+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// Service exported by server reflection++syntax = ""proto3"";++package grpc.reflection.v1alpha;++service ServerReflection {+  // The reflection service is structured as a bidirectional stream, ensuring+  // all related requests go to a single server.+  rpc DescriptorDatabaseInfo(stream DescriptorDatabaseRequest)+      returns (stream DescriptorDatabaseResponse);+}++// The message sent by the client when calling DescriptorDatabaseInfo method.+message DescriptorDatabaseRequest {+  string host = 1;+  // To use reflection service, the client should set one of the following+  // fields in message_request. The server distinguishes requests by their+  // defined field and then handles them using corresponding methods.+  oneof message_request {+    // Find a proto file by the file name.+    string file_by_filename = 3;++    // Find the proto file that declares the given fully-qualified symbol name.+    // This field should be a fully-qualified symbol name+    // (e.g. <package>.<service>[.<method>] or <package>.<type>).+    string file_containing_symbol = 4;++    // Find the proto file which defines an extension extending the given+    // message type with the given field number.+    ExtensionRequest file_containing_extension = 5;++    // Finds the tag numbers used by all known extensions of extendee_type, and+    // appends them to ExtensionNumberResponse in an undefined order.+    // Its corresponding method is best-effort: it's not guaranteed that the+    // reflection service will implement this method, and it's not guaranteed+    // that this method will provide all extensions. Returns+    // StatusCode::UNIMPLEMENTED if it's not implemented.+    // This field should be a fully-qualified type name. The format is+    // <package>.<type>+    string all_extension_numbers_of_type = 6;++    // List the full names of registered services. The content will not be+    // checked.+    string list_services = 7;","We don't need this -- DescriptorDatabase doesn't have this API.Well, I'm lying, it does, inside Google. DescriptorDatabase::FindAllServiceNames() is a non-opensource API hack for proto2 migration, dealing with the problem that Stubby doesn't (or didn't historically) put package names on the wire.grpc doesn't have that problem, so we probably don't need this API. If it turns out that we do we should consider adding it along with open sourcing the equivalent DescriptorDatabase API.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6453,62292059,2016-05-06T06:13:40Z,src/python/grpcio/tests/protoc_plugin/beta_python_plugin_test.py,"@@ -244,35 +244,63 @@ class PythonPluginTest(unittest.TestCase):   methods and does not exist for response-streaming methods.   """""" -  def setUp(self):","I'm going to make the wild guess that it's to attempt to enforce `_gen_protos` being invoked exactly once. If that's the case, I'd prefer using the documented methods mentioned [here](https://docs.python.org/2.7/library/unittest.html#setupclass-and-teardownclass) and [here](https://docs.python.org/2.7/library/unittest.html#setupmodule-and-teardownmodule).",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6462,62351132,2016-05-06T16:06:54Z,tools/run_tests/performance/scenario_config.py,"@@ -69,6 +71,86 @@ WIDE=64  +def _get_secargs(is_secure):+  if is_secure:+    return SECURE_SECARGS+  else:+    return None+++def remove_nonproto_fields(scenario):+  """"""Remove special-purpose that contains some extra info about the scenario+  but don't belong to the ScenarioConfig protobuf message""""""+  scenario.pop('CATEGORIES', None)+  scenario.pop('SERVER_LANGUAGE', None)+  return scenario+++def _ping_pong_scenario(name, rpc_type,+                        client_type, server_type,+                        secure=True,+                        use_generic_payload=False,+                        use_unconstrained_client=False,+                        server_language=None,+                        server_core_limit=0,+                        async_server_threads=0,+                        warmup_seconds=WARMUP_SECONDS,+                        categories=[]):+  """"""Creates a basic ping pong scenario.""""""+  scenario = {+    'name': name,+    'num_servers': 1,+    'num_clients': 1,+    'client_config': {+      'client_type': client_type,+      'security_params': _get_secargs(secure),+      'outstanding_rpcs_per_channel': 1,+      'client_channels': 1,+      'async_client_threads': 1,+      'rpc_type': rpc_type,+      'load_params': {+        'closed_loop': {}+      },+      'histogram_params': HISTOGRAM_PARAMS,+    },+    'server_config': {+      'server_type': server_type,+      'security_params': _get_secargs(secure),+      'core_limit': server_core_limit,+      'async_server_threads': async_server_threads,+    },+    'warmup_seconds': warmup_seconds,+    'benchmark_seconds': BENCHMARK_SECONDS+  }+  if use_generic_payload:+    if server_type != 'ASYNC_GENERIC_SERVER':+      raise Exception('Use ASYNC_GENERIC_SERVER for generic payload.')+    scenario['client_config']['payload_config'] = EMPTY_GENERIC_PAYLOAD+    scenario['server_config']['payload_config'] = EMPTY_GENERIC_PAYLOAD+  else:+    # For proto payload, only the client should get the config.+    scenario['client_config']['payload_config'] = EMPTY_PROTO_PAYLOAD++  if use_unconstrained_client:+    scenario['num_clients'] = 0  # use as many client as available.+    # TODO(jtattermusch): for SYNC_CLIENT, this will create 100*64 threads+    # and that's probably too much (at least for wrapped languages).","We maybe should limit the number of outstanding rpcs per channel and total channel count for wrapped languages (use a language-specific value of DEEP and WIDE). I had been trying to do that in the long-dead PR as part of the response to the ""Capabilities"" RPC, but maybe we can do it this way instead. Let's leave it a TODO for now.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/6373,62370851,2016-05-06T18:28:44Z,src/cpp/server/server_builder.cc,"@@ -41,9 +41,21 @@  namespace grpc { +static std::vector<std::unique_ptr<ServerBuilderPlugin> (*)()>* plugin_list;",Name it g_plugin_factory_list?,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/6449,62386831,2016-05-06T20:30:58Z,test/cpp/interop/client.cc,"@@ -81,6 +81,14 @@ DEFINE_string(default_service_account, """", DEFINE_string(service_account_key_file, """",               ""Path to service account json key file.""); DEFINE_string(oauth_scope, """", ""Scope for OAuth tokens."");+DEFINE_bool(do_not_abort_on_transient_failures, false,",nit: the flag name is long and has a not in it. Maybe remove do_not_ and change the default value?,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6449,62389808,2016-05-06T20:55:22Z,test/cpp/interop/client.cc,"@@ -81,6 +81,14 @@ DEFINE_string(default_service_account, """", DEFINE_string(service_account_key_file, """",               ""Path to service account json key file.""); DEFINE_string(oauth_scope, """", ""Scope for OAuth tokens."");+DEFINE_bool(do_not_abort_on_transient_failures, false,","Actually I  too do not like double-negative names like this one :( and I started off by naming this `abort_on_transient_failures` (with default value to `true`). However, I felt that the name `abort_on_transient_failures` (irrespective of its default value) gave the impression that abort was not called for non-transient failures - which is not true.So I felt `do_not_abort_on_transient_failures` was a better name.. It does correctly seem to convey that normally abort is called on all failures and that we just do not want to call it on transient failures.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6503,62598473,2016-05-10T01:00:31Z,src/python/grpcio/grpc/_cython/_cygrpc/grpcstr.pyx.pxi,"@@ -0,0 +1,37 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+++cdef inline bytes cstr(object s):","Nit: mind naming the file `grpc_str.*` or even `grpc_string.*` and the function `c_string` or `to_ascii` or somesuch? Cython may not be Python but until we have a style guide for it I'm leaning towards erring on the side of Python-style for signatures and such.Also: is the `inline` here necessary? I don't see this being used across multiple C-level translation units, so I'd rather us not have it if it isn't necessary.",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6499,62599080,2016-05-10T01:08:59Z,src/core/lib/surface/call.c,"@@ -1087,6 +1089,24 @@ static void receiving_initial_metadata_ready(grpc_exec_ctx *exec_ctx,         &call->metadata_batch[1 /* is_receiving */][0 /* is_trailing */];     grpc_metadata_batch_filter(md, recv_initial_filter, call); +    /* make sure the received grpc-encoding is amongst the ones listed in+     * grpc-accept-encoding */++    GPR_ASSERT(call->encodings_accepted_by_peer != 0);+    if (!GPR_BITGET(call->encodings_accepted_by_peer,+                    call->compression_algorithm)) {+      extern int grpc_compression_trace;+      if (grpc_compression_trace) {+        char *algo_name;+        grpc_compression_algorithm_name(call->compression_algorithm,+                                        &algo_name);+        gpr_log(GPR_ERROR,+                ""Compression algorithm (grpc-encoding = '%s') not present in ""+                ""the bitset of accepted encodings (grpc-accept-encodings: ""+                ""'0x%x')"",+                algo_name, call->encodings_accepted_by_peer);+      }+    }",You might want to fail the batch here:  `bctl->success = false` (and not execute the next set of instructions to set a deadline alarm).,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6254,62706493,2016-05-10T16:36:55Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +106,37 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__","@soltanmm As far as I can tell, objects having names is the exception and not the rule.  Is that the behavior we want, or are we just obfuscating naming unnecessarily?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6479,62781762,2016-05-11T01:46:18Z,src/compiler/python_generator.cc,"@@ -156,8 +157,23 @@ grpc::string ModuleName(const grpc::string& filename) {   return basename + ""_pb2""; } +// TODO(https://github.com/google/protobuf/issues/888):+// Export `ModuleAlias` from protobuf's+// `src/google/protobuf/compiler/python/python_generator.cc` file.+grpc::string ModuleAlias(const grpc::string& filename) {+  grpc::string module_name = ModuleName(filename);+  // We can't have dots in the module name, so we replace each with _dot_.+  // But that could lead to a collision between a.b and a_dot_b, so we also+  // duplicate each underscore.+  module_name = StringReplace(module_name, ""_"", ""__"");+  module_name = StringReplace(module_name, ""."", ""_dot_"");+  return module_name;+}++ bool GetModuleAndMessagePath(const Descriptor* type,-                             pair<grpc::string, grpc::string>* out) {+                             const ServiceDescriptor* service,+                             grpc::string& out) {",Style nit: [C++ style](https://google.github.io/styleguide/cppguide.html#Function_Parameter_Ordering) has us use pointers for output parameters rather than lvalue references.,
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/6479,62919304,2016-05-11T20:21:31Z,src/compiler/python_generator.cc,"@@ -156,8 +157,23 @@ grpc::string ModuleName(const grpc::string& filename) {   return basename + ""_pb2""; } +// TODO(https://github.com/google/protobuf/issues/888):+// Export `ModuleAlias` from protobuf's+// `src/google/protobuf/compiler/python/python_generator.cc` file.+grpc::string ModuleAlias(const grpc::string& filename) {+  grpc::string module_name = ModuleName(filename);+  // We can't have dots in the module name, so we replace each with _dot_.+  // But that could lead to a collision between a.b and a_dot_b, so we also+  // duplicate each underscore.+  module_name = StringReplace(module_name, ""_"", ""__"");+  module_name = StringReplace(module_name, ""."", ""_dot_"");+  return module_name;+}++ bool GetModuleAndMessagePath(const Descriptor* type,-                             pair<grpc::string, grpc::string>* out) {+                             const ServiceDescriptor* service,+                             grpc::string& out) {","Yes, please don't use references for output parameters. It's fine to have const references though.",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6546,62924056,2016-05-11T20:49:56Z,tools/run_tests/stress_test/configs/java.json,"@@ -24,6 +24,9 @@         }       }     },+    ""env"": {","Yes, I am sure... https://github.com/grpc/grpc/blob/master/tools/run_tests/stress_test/configs/python.json#L25https://github.com/grpc/grpc/blob/master/tools/run_tests/stress_test/configs/python.json#L51",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/5456,62940996,2016-05-11T22:54:45Z,src/core/lib/iomgr/ev_poll_posix.c,"@@ -0,0 +1,1222 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>++#ifdef GPR_POSIX_SOCKET++#include ""src/core/lib/iomgr/ev_poll_posix.h""++#include <assert.h>+#include <errno.h>+#include <poll.h>+#include <string.h>+#include <sys/socket.h>+#include <unistd.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>+#include <grpc/support/tls.h>+#include <grpc/support/useful.h>++#include ""src/core/lib/iomgr/iomgr_internal.h""+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""+#include ""src/core/lib/profiling/timers.h""+#include ""src/core/lib/support/block_annotate.h""++/*******************************************************************************+ * FD declarations+ */++typedef struct grpc_fd_watcher {+  struct grpc_fd_watcher *next;+  struct grpc_fd_watcher *prev;+  grpc_pollset *pollset;+  grpc_pollset_worker *worker;+  grpc_fd *fd;+} grpc_fd_watcher;++struct grpc_fd {+  int fd;+  /* refst format:+     bit0:   1=active/0=orphaned+     bit1-n: refcount+     meaning that mostly we ref by two to avoid altering the orphaned bit,+     and just unref by 1 when we're ready to flag the object as orphaned */+  gpr_atm refst;++  gpr_mu mu;+  int shutdown;+  int closed;+  int released;++  /* The watcher list.++     The following watcher related fields are protected by watcher_mu.++     An fd_watcher is an ephemeral object created when an fd wants to+     begin polling, and destroyed after the poll.++     It denotes the fd's interest in whether to read poll or write poll+     or both or neither on this fd.++     If a watcher is asked to poll for reads or writes, the read_watcher+     or write_watcher fields are set respectively. A watcher may be asked+     to poll for both, in which case both fields will be set.++     read_watcher and write_watcher may be NULL if no watcher has been+     asked to poll for reads or writes.++     If an fd_watcher is not asked to poll for reads or writes, it's added+     to a linked list of inactive watchers, rooted at inactive_watcher_root.+     If at a later time there becomes need of a poller to poll, one of+     the inactive pollers may be kicked out of their poll loops to take+     that responsibility. */+  grpc_fd_watcher inactive_watcher_root;+  grpc_fd_watcher *read_watcher;+  grpc_fd_watcher *write_watcher;++  grpc_closure *read_closure;+  grpc_closure *write_closure;++  grpc_closure *on_done_closure;++  grpc_iomgr_object iomgr_object;+};++/* Begin polling on an fd.+   Registers that the given pollset is interested in this fd - so that if read+   or writability interest changes, the pollset can be kicked to pick up that+   new interest.+   Return value is:+     (fd_needs_read? read_mask : 0) | (fd_needs_write? write_mask : 0)+   i.e. a combination of read_mask and write_mask determined by the fd's current+   interest in said events.+   Polling strategies that do not need to alter their behavior depending on the+   fd's current interest (such as epoll) do not need to call this function.+   MUST NOT be called with a pollset lock taken */+static uint32_t fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,+                              grpc_pollset_worker *worker, uint32_t read_mask,+                              uint32_t write_mask, grpc_fd_watcher *rec);+/* Complete polling previously started with fd_begin_poll+   MUST NOT be called with a pollset lock taken+   if got_read or got_write are 1, also does the become_{readable,writable} as+   appropriate. */+static void fd_end_poll(grpc_exec_ctx *exec_ctx, grpc_fd_watcher *rec,+                        int got_read, int got_write);++/* Return 1 if this fd is orphaned, 0 otherwise */+static bool fd_is_orphaned(grpc_fd *fd);++/* Reference counting for fds */+/*#define GRPC_FD_REF_COUNT_DEBUG*/+#ifdef GRPC_FD_REF_COUNT_DEBUG+static void fd_ref(grpc_fd *fd, const char *reason, const char *file, int line);+static void fd_unref(grpc_fd *fd, const char *reason, const char *file,+                     int line);+#define GRPC_FD_REF(fd, reason) fd_ref(fd, reason, __FILE__, __LINE__)+#define GRPC_FD_UNREF(fd, reason) fd_unref(fd, reason, __FILE__, __LINE__)+#else+static void fd_ref(grpc_fd *fd);+static void fd_unref(grpc_fd *fd);+#define GRPC_FD_REF(fd, reason) fd_ref(fd)+#define GRPC_FD_UNREF(fd, reason) fd_unref(fd)+#endif++#define CLOSURE_NOT_READY ((grpc_closure *)0)+#define CLOSURE_READY ((grpc_closure *)1)++/*******************************************************************************+ * pollset declarations+ */++typedef struct grpc_cached_wakeup_fd {+  grpc_wakeup_fd fd;+  struct grpc_cached_wakeup_fd *next;+} grpc_cached_wakeup_fd;++struct grpc_pollset_worker {+  grpc_cached_wakeup_fd *wakeup_fd;+  int reevaluate_polling_on_wakeup;+  int kicked_specifically;+  struct grpc_pollset_worker *next;+  struct grpc_pollset_worker *prev;+};++struct grpc_pollset {+  gpr_mu mu;+  grpc_pollset_worker root_worker;+  int in_flight_cbs;+  int shutting_down;+  int called_shutdown;+  int kicked_without_pollers;+  grpc_closure *shutdown_done;+  grpc_closure_list idle_jobs;+  /* all polled fds */+  size_t fd_count;+  size_t fd_capacity;+  grpc_fd **fds;+  /* fds that have been removed from the pollset explicitly */+  size_t del_count;+  size_t del_capacity;+  grpc_fd **dels;+  /* Local cache of eventfds for workers */+  grpc_cached_wakeup_fd *local_wakeup_cache;+};++struct grpc_pollset_vtable {",This struct (`grpc_pollset_vtable`) is no longer needed in this file.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6254,62963521,2016-05-12T04:22:45Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +106,37 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__","Woops, this one slipped by me. I think your change is the right way to go for non-function callables (which I think I'd not considered at the time). The problem is that we expect most users to just write a new function and pass it in. Functions have `__name__` attributes that are meaningful, but their `__class__` attributes are always `function`. So we'd at least want to maintain support for that use case.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6254,63079267,2016-05-12T19:10:31Z,src/python/grpcio/grpc/beta/implementations.py,"@@ -105,10 +106,37 @@ def metadata_call_credentials(metadata_plugin, name=None):     A CallCredentials object for use in a GRPCCallOptions object.   """"""   if name is None:-    name = metadata_plugin.__name__","I've updated the behavior to check for the function name first, and then fall back on the class name.",
10135909,dklempner,https://api.github.com/repos/grpc/grpc/pulls/6414,63087222,2016-05-12T20:03:54Z,src/proto/grpc/reflection/v1alpha/reflection.proto,"@@ -0,0 +1,131 @@+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++// Service exported by server reflection++syntax = ""proto3"";++package grpc.reflection.v1alpha;++service ServerReflection {+  // The reflection service is structured as a bidirectional stream, ensuring+  // all related requests go to a single server.+  rpc DescriptorDatabaseInfo(stream DescriptorDatabaseRequest)+      returns (stream DescriptorDatabaseResponse);+}++// The message sent by the client when calling DescriptorDatabaseInfo method.+message DescriptorDatabaseRequest {+  string host = 1;+  // To use reflection service, the client should set one of the following+  // fields in message_request. The server distinguishes requests by their+  // defined field and then handles them using corresponding methods.+  oneof message_request {+    // Find a proto file by the file name.+    string file_by_filename = 3;++    // Find the proto file that declares the given fully-qualified symbol name.+    // This field should be a fully-qualified symbol name+    // (e.g. <package>.<service>[.<method>] or <package>.<type>).+    string file_containing_symbol = 4;++    // Find the proto file which defines an extension extending the given+    // message type with the given field number.+    ExtensionRequest file_containing_extension = 5;++    // Finds the tag numbers used by all known extensions of extendee_type, and+    // appends them to ExtensionNumberResponse in an undefined order.+    // Its corresponding method is best-effort: it's not guaranteed that the+    // reflection service will implement this method, and it's not guaranteed+    // that this method will provide all extensions. Returns+    // StatusCode::UNIMPLEMENTED if it's not implemented.+    // This field should be a fully-qualified type name. The format is+    // <package>.<type>+    string all_extension_numbers_of_type = 6;++    // List the full names of registered services. The content will not be+    // checked.+    string list_services = 7;","For future reference: my confusion here was that this isn't actually a DescriptorDatabase request, confusion compounded that we have an internal google extension to DescriptorDatabase that does almost exactly this from the proto point of view. (As in, ""list all services known to proto"" as opposed to ""list all services on the server"" (or ""known to the reflection service"")",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6572,63185524,2016-05-13T13:50:46Z,src/core/ext/transport/chttp2/transport/bin_decoder.h,"@@ -0,0 +1,48 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H+#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H++#include <grpc/support/slice.h>++/* base64 decode a slice with pad chars. Returns a new slice, does not take+   ownership of the input */+gpr_slice grpc_chttp2_base64_decode(gpr_slice input);++/* base64 decode a slice without pad chars, data length is needed. Returns a new+   slice, does not take ownership of the input */+gpr_slice grpc_chttp2_base64_decode_with_length(gpr_slice input,","I think we might need a slightly lower level interface here: requiring accumulation of a full slice will add quite some complexity to hpack_parser, and that'll be kind of bad (that code is complex enough).What about something like:```struct grpc_base64_decode_context {  /* input/output: */  uint8_t *input_cur;  uint8_t *input_end;  uint8_t *output_cur;  uint8_t *output_end;  /* private: */  uint8_t state;};void grpc_base64_decode_partial(grpc_base64_decode_context *ctx);```Callers of this code would be responsible for setting pointers to input and output buffers, and on exit could make just a couple of checks:```if (ctx.input_cur == ctx.input_end) get_more_input();if (ctx.output_cur == ctx.output_end) got_more_bytes();```grpc_chttp2_base64_decode_with_length could then be implemented in terms of the incremental parsing function.What do you think?",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/6572,63224118,2016-05-13T17:52:13Z,src/core/ext/transport/chttp2/transport/bin_decoder.h,"@@ -0,0 +1,48 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H+#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H++#include <grpc/support/slice.h>++/* base64 decode a slice with pad chars. Returns a new slice, does not take+   ownership of the input */+gpr_slice grpc_chttp2_base64_decode(gpr_slice input);++/* base64 decode a slice without pad chars, data length is needed. Returns a new+   slice, does not take ownership of the input */+gpr_slice grpc_chttp2_base64_decode_with_length(gpr_slice input,",Cool. So grpc_base64_decode_partial will decode the data until either input_end is reached or output_end is reached? It won't do any check on the length of input/output memory?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6572,63225264,2016-05-13T17:59:05Z,src/core/ext/transport/chttp2/transport/bin_decoder.h,"@@ -0,0 +1,48 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H+#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H++#include <grpc/support/slice.h>++/* base64 decode a slice with pad chars. Returns a new slice, does not take+   ownership of the input */+gpr_slice grpc_chttp2_base64_decode(gpr_slice input);++/* base64 decode a slice without pad chars, data length is needed. Returns a new+   slice, does not take ownership of the input */+gpr_slice grpc_chttp2_base64_decode_with_length(gpr_slice input,","That would be the idea. If you can think of a more efficient interface,speak up :) I'm drawing inspiration from zlib here.On Fri, May 13, 2016 at 10:52 AM Yuchen Zeng notifications@github.comwrote:> In src/core/ext/transport/chttp2/transport/bin_decoder.h> https://github.com/grpc/grpc/pull/6572#discussion_r63224118:> > > - \* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.> > - *> > - _/> >   +> >   +#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H> >   +#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_TRANSPORT_BIN_DECODER_H> >   +> >   +#include <grpc/support/slice.h>> >   +> >   +/_ base64 decode a slice with pad chars. Returns a new slice, does not take> > -   ownership of the input _/> >   +gpr_slice grpc_chttp2_base64_decode(gpr_slice input);> >   +> >   +/_ base64 decode a slice without pad chars, data length is needed. Returns a new> > -   slice, does not take ownership of the input */> >   +gpr_slice grpc_chttp2_base64_decode_with_length(gpr_slice input,> > Cool. So grpc_base64_decode_partial will decode the data until either> input_end is reached or output_end is reached? It won't do any check on the> length of input/output memory?> > —> You are receiving this because you commented.> > Reply to this email directly or view it on GitHub> https://github.com/grpc/grpc/pull/6572/files/d982bba41d8676f33431d540d8a4b0c15e426f1c#r63224118",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5456,63230345,2016-05-13T18:30:25Z,src/core/lib/iomgr/ev_poll_posix.c,"@@ -0,0 +1,1212 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>++#ifdef GPR_POSIX_SOCKET++#include ""src/core/lib/iomgr/ev_poll_posix.h""++#include <assert.h>+#include <errno.h>+#include <poll.h>+#include <string.h>+#include <sys/socket.h>+#include <unistd.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>+#include <grpc/support/tls.h>+#include <grpc/support/useful.h>++#include ""src/core/lib/iomgr/iomgr_internal.h""+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""+#include ""src/core/lib/profiling/timers.h""+#include ""src/core/lib/support/block_annotate.h""++/*******************************************************************************+ * FD declarations+ */++typedef struct grpc_fd_watcher {+  struct grpc_fd_watcher *next;+  struct grpc_fd_watcher *prev;+  grpc_pollset *pollset;+  grpc_pollset_worker *worker;+  grpc_fd *fd;+} grpc_fd_watcher;++struct grpc_fd {+  int fd;+  /* refst format:+     bit0:   1=active/0=orphaned+     bit1-n: refcount+     meaning that mostly we ref by two to avoid altering the orphaned bit,+     and just unref by 1 when we're ready to flag the object as orphaned */+  gpr_atm refst;++  gpr_mu mu;+  int shutdown;+  int closed;+  int released;++  /* The watcher list.++     The following watcher related fields are protected by watcher_mu.++     An fd_watcher is an ephemeral object created when an fd wants to+     begin polling, and destroyed after the poll.++     It denotes the fd's interest in whether to read poll or write poll+     or both or neither on this fd.++     If a watcher is asked to poll for reads or writes, the read_watcher+     or write_watcher fields are set respectively. A watcher may be asked+     to poll for both, in which case both fields will be set.++     read_watcher and write_watcher may be NULL if no watcher has been+     asked to poll for reads or writes.++     If an fd_watcher is not asked to poll for reads or writes, it's added+     to a linked list of inactive watchers, rooted at inactive_watcher_root.+     If at a later time there becomes need of a poller to poll, one of+     the inactive pollers may be kicked out of their poll loops to take+     that responsibility. */+  grpc_fd_watcher inactive_watcher_root;+  grpc_fd_watcher *read_watcher;+  grpc_fd_watcher *write_watcher;++  grpc_closure *read_closure;+  grpc_closure *write_closure;++  grpc_closure *on_done_closure;++  grpc_iomgr_object iomgr_object;+};++/* Begin polling on an fd.+   Registers that the given pollset is interested in this fd - so that if read+   or writability interest changes, the pollset can be kicked to pick up that+   new interest.+   Return value is:+     (fd_needs_read? read_mask : 0) | (fd_needs_write? write_mask : 0)+   i.e. a combination of read_mask and write_mask determined by the fd's current+   interest in said events.+   Polling strategies that do not need to alter their behavior depending on the+   fd's current interest (such as epoll) do not need to call this function.+   MUST NOT be called with a pollset lock taken */+static uint32_t fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,+                              grpc_pollset_worker *worker, uint32_t read_mask,+                              uint32_t write_mask, grpc_fd_watcher *rec);+/* Complete polling previously started with fd_begin_poll+   MUST NOT be called with a pollset lock taken+   if got_read or got_write are 1, also does the become_{readable,writable} as+   appropriate. */+static void fd_end_poll(grpc_exec_ctx *exec_ctx, grpc_fd_watcher *rec,+                        int got_read, int got_write);++/* Return 1 if this fd is orphaned, 0 otherwise */+static bool fd_is_orphaned(grpc_fd *fd);++/* Reference counting for fds */+/*#define GRPC_FD_REF_COUNT_DEBUG*/+#ifdef GRPC_FD_REF_COUNT_DEBUG+static void fd_ref(grpc_fd *fd, const char *reason, const char *file, int line);+static void fd_unref(grpc_fd *fd, const char *reason, const char *file,+                     int line);+#define GRPC_FD_REF(fd, reason) fd_ref(fd, reason, __FILE__, __LINE__)+#define GRPC_FD_UNREF(fd, reason) fd_unref(fd, reason, __FILE__, __LINE__)+#else+static void fd_ref(grpc_fd *fd);+static void fd_unref(grpc_fd *fd);+#define GRPC_FD_REF(fd, reason) fd_ref(fd)+#define GRPC_FD_UNREF(fd, reason) fd_unref(fd)+#endif++#define CLOSURE_NOT_READY ((grpc_closure *)0)+#define CLOSURE_READY ((grpc_closure *)1)++/*******************************************************************************+ * pollset declarations+ */++typedef struct grpc_cached_wakeup_fd {+  grpc_wakeup_fd fd;+  struct grpc_cached_wakeup_fd *next;+} grpc_cached_wakeup_fd;++struct grpc_pollset_worker {+  grpc_cached_wakeup_fd *wakeup_fd;+  int reevaluate_polling_on_wakeup;+  int kicked_specifically;+  struct grpc_pollset_worker *next;+  struct grpc_pollset_worker *prev;+};++struct grpc_pollset {+  gpr_mu mu;+  grpc_pollset_worker root_worker;+  int in_flight_cbs;+  int shutting_down;+  int called_shutdown;+  int kicked_without_pollers;+  grpc_closure *shutdown_done;+  grpc_closure_list idle_jobs;+  /* all polled fds */+  size_t fd_count;+  size_t fd_capacity;+  grpc_fd **fds;+  /* fds that have been removed from the pollset explicitly */+  size_t del_count;+  size_t del_capacity;+  grpc_fd **dels;+  /* Local cache of eventfds for workers */+  grpc_cached_wakeup_fd *local_wakeup_cache;+};++/* Add an fd to a pollset */+static void pollset_add_fd(grpc_exec_ctx *exec_ctx, grpc_pollset *pollset,+                           struct grpc_fd *fd);++static void pollset_set_add_fd(grpc_exec_ctx *exec_ctx,+                               grpc_pollset_set *pollset_set, grpc_fd *fd);++/* Convert a timespec to milliseconds:+   - very small or negative poll times are clamped to zero to do a+     non-blocking poll (which becomes spin polling)+   - other small values are rounded up to one millisecond+   - longer than a millisecond polls are rounded up to the next nearest+     millisecond to avoid spinning+   - infinite timeouts are converted to -1 */+static int poll_deadline_to_millis_timeout(gpr_timespec deadline,+                                           gpr_timespec now);++/* Allow kick to wakeup the currently polling worker */+#define GRPC_POLLSET_CAN_KICK_SELF 1+/* Force the wakee to repoll when awoken */+#define GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP 2+/* As per pollset_kick, with an extended set of flags (defined above)+   -- mostly for fd_posix's use. */+static void pollset_kick_ext(grpc_pollset *p,+                             grpc_pollset_worker *specific_worker,+                             uint32_t flags);++/* Return 1 if the pollset has active threads in pollset_work (pollset must+ * be locked) */+static int pollset_has_workers(grpc_pollset *pollset);++/*******************************************************************************+ * pollset_set definitions+ */++struct grpc_pollset_set {+  gpr_mu mu;++  size_t pollset_count;+  size_t pollset_capacity;+  grpc_pollset **pollsets;++  size_t pollset_set_count;+  size_t pollset_set_capacity;+  struct grpc_pollset_set **pollset_sets;++  size_t fd_count;+  size_t fd_capacity;+  grpc_fd **fds;+};++/*******************************************************************************+ * fd_posix.c+ */++#ifdef GRPC_FD_REF_COUNT_DEBUG+#define REF_BY(fd, n, reason) ref_by(fd, n, reason, __FILE__, __LINE__)+#define UNREF_BY(fd, n, reason) unref_by(fd, n, reason, __FILE__, __LINE__)+static void ref_by(grpc_fd *fd, int n, const char *reason, const char *file,+                   int line) {+  gpr_log(GPR_DEBUG, ""FD %d %p   ref %d %d -> %d [%s; %s:%d]"", fd->fd, fd, n,+          gpr_atm_no_barrier_load(&fd->refst),+          gpr_atm_no_barrier_load(&fd->refst) + n, reason, file, line);+#else+#define REF_BY(fd, n, reason) ref_by(fd, n)+#define UNREF_BY(fd, n, reason) unref_by(fd, n)+static void ref_by(grpc_fd *fd, int n) {+#endif+  GPR_ASSERT(gpr_atm_no_barrier_fetch_add(&fd->refst, n) > 0);+}++#ifdef GRPC_FD_REF_COUNT_DEBUG+static void unref_by(grpc_fd *fd, int n, const char *reason, const char *file,+                     int line) {+  gpr_atm old;+  gpr_log(GPR_DEBUG, ""FD %d %p unref %d %d -> %d [%s; %s:%d]"", fd->fd, fd, n,+          gpr_atm_no_barrier_load(&fd->refst),+          gpr_atm_no_barrier_load(&fd->refst) - n, reason, file, line);+#else+static void unref_by(grpc_fd *fd, int n) {+  gpr_atm old;+#endif+  old = gpr_atm_full_fetch_add(&fd->refst, -n);+  if (old == n) {+    gpr_mu_destroy(&fd->mu);+    grpc_iomgr_unregister_object(&fd->iomgr_object);+    gpr_free(fd);+  } else {+    GPR_ASSERT(old > n);+  }+}++static grpc_fd *fd_create(int fd, const char *name) {+  grpc_fd *r = gpr_malloc(sizeof(*r));+  gpr_mu_init(&r->mu);+  gpr_atm_rel_store(&r->refst, 1);+  r->shutdown = 0;+  r->read_closure = CLOSURE_NOT_READY;+  r->write_closure = CLOSURE_NOT_READY;+  r->fd = fd;+  r->inactive_watcher_root.next = r->inactive_watcher_root.prev =+      &r->inactive_watcher_root;+  r->read_watcher = r->write_watcher = NULL;+  r->on_done_closure = NULL;+  r->closed = 0;+  r->released = 0;++  char *name2;+  gpr_asprintf(&name2, ""%s fd=%d"", name, fd);+  grpc_iomgr_register_object(&r->iomgr_object, name2);+  gpr_free(name2);+#ifdef GRPC_FD_REF_COUNT_DEBUG+  gpr_log(GPR_DEBUG, ""FD %d %p create %s"", fd, r, name);+#endif+  return r;+}++static bool fd_is_orphaned(grpc_fd *fd) {+  return (gpr_atm_acq_load(&fd->refst) & 1) == 0;+}++static void pollset_kick_locked(grpc_fd_watcher *watcher) {+  gpr_mu_lock(&watcher->pollset->mu);+  GPR_ASSERT(watcher->worker);+  pollset_kick_ext(watcher->pollset, watcher->worker,+                   GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP);+  gpr_mu_unlock(&watcher->pollset->mu);+}++static void maybe_wake_one_watcher_locked(grpc_fd *fd) {+  if (fd->inactive_watcher_root.next != &fd->inactive_watcher_root) {+    pollset_kick_locked(fd->inactive_watcher_root.next);+  } else if (fd->read_watcher) {+    pollset_kick_locked(fd->read_watcher);+  } else if (fd->write_watcher) {+    pollset_kick_locked(fd->write_watcher);+  }+}++static void wake_all_watchers_locked(grpc_fd *fd) {+  grpc_fd_watcher *watcher;+  for (watcher = fd->inactive_watcher_root.next;+       watcher != &fd->inactive_watcher_root; watcher = watcher->next) {+    pollset_kick_locked(watcher);+  }+  if (fd->read_watcher) {+    pollset_kick_locked(fd->read_watcher);+  }+  if (fd->write_watcher && fd->write_watcher != fd->read_watcher) {+    pollset_kick_locked(fd->write_watcher);+  }+}++static int has_watchers(grpc_fd *fd) {+  return fd->read_watcher != NULL || fd->write_watcher != NULL ||+         fd->inactive_watcher_root.next != &fd->inactive_watcher_root;+}++static void close_fd_locked(grpc_exec_ctx *exec_ctx, grpc_fd *fd) {+  fd->closed = 1;+  if (!fd->released) {+    close(fd->fd);+  }+  grpc_exec_ctx_enqueue(exec_ctx, fd->on_done_closure, true, NULL);+}++static int fd_wrapped_fd(grpc_fd *fd) {+  if (fd->released || fd->closed) {+    return -1;+  } else {+    return fd->fd;+  }+}++static void fd_orphan(grpc_exec_ctx *exec_ctx, grpc_fd *fd,+                      grpc_closure *on_done, int *release_fd,+                      const char *reason) {+  fd->on_done_closure = on_done;+  fd->released = release_fd != NULL;+  if (!fd->released) {+    shutdown(fd->fd, SHUT_RDWR);+  } else {+    *release_fd = fd->fd;+  }+  gpr_mu_lock(&fd->mu);+  REF_BY(fd, 1, reason); /* remove active status, but keep referenced */+  if (!has_watchers(fd)) {+    close_fd_locked(exec_ctx, fd);+  } else {+    wake_all_watchers_locked(fd);+  }+  gpr_mu_unlock(&fd->mu);+  UNREF_BY(fd, 2, reason); /* drop the reference */+}++/* increment refcount by two to avoid changing the orphan bit */+#ifdef GRPC_FD_REF_COUNT_DEBUG+static void fd_ref(grpc_fd *fd, const char *reason, const char *file,+                   int line) {+  ref_by(fd, 2, reason, file, line);+}++static void fd_unref(grpc_fd *fd, const char *reason, const char *file,+                     int line) {+  unref_by(fd, 2, reason, file, line);+}+#else+static void fd_ref(grpc_fd *fd) { ref_by(fd, 2); }++static void fd_unref(grpc_fd *fd) { unref_by(fd, 2); }+#endif++static void notify_on_locked(grpc_exec_ctx *exec_ctx, grpc_fd *fd,+                             grpc_closure **st, grpc_closure *closure) {+  if (*st == CLOSURE_NOT_READY) {+    /* not ready ==> switch to a waiting state by setting the closure */+    *st = closure;+  } else if (*st == CLOSURE_READY) {+    /* already ready ==> queue the closure to run immediately */+    *st = CLOSURE_NOT_READY;+    grpc_exec_ctx_enqueue(exec_ctx, closure, !fd->shutdown, NULL);+    maybe_wake_one_watcher_locked(fd);+  } else {+    /* upcallptr was set to a different closure.  This is an error! */+    gpr_log(GPR_ERROR,+            ""User called a notify_on function with a previous callback still ""+            ""pending"");+    abort();+  }+}++/* returns 1 if state becomes not ready */+static int set_ready_locked(grpc_exec_ctx *exec_ctx, grpc_fd *fd,+                            grpc_closure **st) {+  if (*st == CLOSURE_READY) {+    /* duplicate ready ==> ignore */+    return 0;+  } else if (*st == CLOSURE_NOT_READY) {+    /* not ready, and not waiting ==> flag ready */+    *st = CLOSURE_READY;+    return 0;+  } else {+    /* waiting ==> queue closure */+    grpc_exec_ctx_enqueue(exec_ctx, *st, !fd->shutdown, NULL);+    *st = CLOSURE_NOT_READY;+    return 1;+  }+}++static void fd_shutdown(grpc_exec_ctx *exec_ctx, grpc_fd *fd) {+  gpr_mu_lock(&fd->mu);+  GPR_ASSERT(!fd->shutdown);+  fd->shutdown = 1;+  set_ready_locked(exec_ctx, fd, &fd->read_closure);+  set_ready_locked(exec_ctx, fd, &fd->write_closure);+  gpr_mu_unlock(&fd->mu);+}++static void fd_notify_on_read(grpc_exec_ctx *exec_ctx, grpc_fd *fd,+                              grpc_closure *closure) {+  gpr_mu_lock(&fd->mu);+  notify_on_locked(exec_ctx, fd, &fd->read_closure, closure);+  gpr_mu_unlock(&fd->mu);+}++static void fd_notify_on_write(grpc_exec_ctx *exec_ctx, grpc_fd *fd,+                               grpc_closure *closure) {+  gpr_mu_lock(&fd->mu);+  notify_on_locked(exec_ctx, fd, &fd->write_closure, closure);+  gpr_mu_unlock(&fd->mu);+}++static uint32_t fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,+                              grpc_pollset_worker *worker, uint32_t read_mask,+                              uint32_t write_mask, grpc_fd_watcher *watcher) {+  uint32_t mask = 0;+  grpc_closure *cur;+  int requested;+  /* keep track of pollers that have requested our events, in case they change+   */+  GRPC_FD_REF(fd, ""poll"");++  gpr_mu_lock(&fd->mu);++  /* if we are shutdown, then don't add to the watcher set */+  if (fd->shutdown) {+    watcher->fd = NULL;+    watcher->pollset = NULL;+    watcher->worker = NULL;+    gpr_mu_unlock(&fd->mu);+    GRPC_FD_UNREF(fd, ""poll"");+    return 0;+  }++  /* if there is nobody polling for read, but we need to, then start doing so */+  cur = fd->read_closure;+  requested = cur != CLOSURE_READY;+  if (read_mask && fd->read_watcher == NULL && requested) {+    fd->read_watcher = watcher;+    mask |= read_mask;+  }+  /* if there is nobody polling for write, but we need to, then start doing so+   */+  cur = fd->write_closure;+  requested = cur != CLOSURE_READY;+  if (write_mask && fd->write_watcher == NULL && requested) {+    fd->write_watcher = watcher;+    mask |= write_mask;+  }+  /* if not polling, remember this watcher in case we need someone to later */+  if (mask == 0 && worker != NULL) {+    watcher->next = &fd->inactive_watcher_root;+    watcher->prev = watcher->next->prev;+    watcher->next->prev = watcher->prev->next = watcher;+  }+  watcher->pollset = pollset;+  watcher->worker = worker;+  watcher->fd = fd;+  gpr_mu_unlock(&fd->mu);++  return mask;+}++static void fd_end_poll(grpc_exec_ctx *exec_ctx, grpc_fd_watcher *watcher,+                        int got_read, int got_write) {+  int was_polling = 0;+  int kick = 0;+  grpc_fd *fd = watcher->fd;++  if (fd == NULL) {+    return;+  }++  gpr_mu_lock(&fd->mu);++  if (watcher == fd->read_watcher) {+    /* remove read watcher, kick if we still need a read */+    was_polling = 1;+    if (!got_read) {+      kick = 1;+    }+    fd->read_watcher = NULL;+  }+  if (watcher == fd->write_watcher) {+    /* remove write watcher, kick if we still need a write */+    was_polling = 1;+    if (!got_write) {+      kick = 1;+    }+    fd->write_watcher = NULL;+  }+  if (!was_polling && watcher->worker != NULL) {+    /* remove from inactive list */+    watcher->next->prev = watcher->prev;+    watcher->prev->next = watcher->next;+  }+  if (got_read) {+    if (set_ready_locked(exec_ctx, fd, &fd->read_closure)) {+      kick = 1;+    }+  }+  if (got_write) {+    if (set_ready_locked(exec_ctx, fd, &fd->write_closure)) {+      kick = 1;+    }+  }+  if (kick) {+    maybe_wake_one_watcher_locked(fd);+  }+  if (fd_is_orphaned(fd) && !has_watchers(fd) && !fd->closed) {+    close_fd_locked(exec_ctx, fd);+  }+  gpr_mu_unlock(&fd->mu);++  GRPC_FD_UNREF(fd, ""poll"");+}++/*******************************************************************************+ * pollset_posix.c+ */++GPR_TLS_DECL(g_current_thread_poller);+GPR_TLS_DECL(g_current_thread_worker);++static void remove_worker(grpc_pollset *p, grpc_pollset_worker *worker) {+  worker->prev->next = worker->next;+  worker->next->prev = worker->prev;+}++static int pollset_has_workers(grpc_pollset *p) {+  return p->root_worker.next != &p->root_worker;+}++static grpc_pollset_worker *pop_front_worker(grpc_pollset *p) {+  if (pollset_has_workers(p)) {+    grpc_pollset_worker *w = p->root_worker.next;+    remove_worker(p, w);+    return w;+  } else {+    return NULL;+  }+}++static void push_back_worker(grpc_pollset *p, grpc_pollset_worker *worker) {+  worker->next = &p->root_worker;+  worker->prev = worker->next->prev;+  worker->prev->next = worker->next->prev = worker;+}++static void push_front_worker(grpc_pollset *p, grpc_pollset_worker *worker) {+  worker->prev = &p->root_worker;+  worker->next = worker->prev->next;+  worker->prev->next = worker->next->prev = worker;+}++static void pollset_kick_ext(grpc_pollset *p,+                             grpc_pollset_worker *specific_worker,+                             uint32_t flags) {+  GPR_TIMER_BEGIN(""pollset_kick_ext"", 0);++  /* pollset->mu already held */+  if (specific_worker != NULL) {+    if (specific_worker == GRPC_POLLSET_KICK_BROADCAST) {+      GPR_TIMER_BEGIN(""pollset_kick_ext.broadcast"", 0);+      GPR_ASSERT((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP) == 0);+      for (specific_worker = p->root_worker.next;+           specific_worker != &p->root_worker;+           specific_worker = specific_worker->next) {+        grpc_wakeup_fd_wakeup(&specific_worker->wakeup_fd->fd);+      }+      p->kicked_without_pollers = 1;+      GPR_TIMER_END(""pollset_kick_ext.broadcast"", 0);+    } else if (gpr_tls_get(&g_current_thread_worker) !=+               (intptr_t)specific_worker) {+      GPR_TIMER_MARK(""different_thread_worker"", 0);+      if ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP) != 0) {+        specific_worker->reevaluate_polling_on_wakeup = 1;+      }+      specific_worker->kicked_specifically = 1;+      grpc_wakeup_fd_wakeup(&specific_worker->wakeup_fd->fd);+    } else if ((flags & GRPC_POLLSET_CAN_KICK_SELF) != 0) {+      GPR_TIMER_MARK(""kick_yoself"", 0);+      if ((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP) != 0) {+        specific_worker->reevaluate_polling_on_wakeup = 1;+      }+      specific_worker->kicked_specifically = 1;+      grpc_wakeup_fd_wakeup(&specific_worker->wakeup_fd->fd);+    }+  } else if (gpr_tls_get(&g_current_thread_poller) != (intptr_t)p) {+    GPR_ASSERT((flags & GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP) == 0);+    GPR_TIMER_MARK(""kick_anonymous"", 0);+    specific_worker = pop_front_worker(p);+    if (specific_worker != NULL) {+      if (gpr_tls_get(&g_current_thread_worker) == (intptr_t)specific_worker) {+        GPR_TIMER_MARK(""kick_anonymous_not_self"", 0);+        push_back_worker(p, specific_worker);+        specific_worker = pop_front_worker(p);+        if ((flags & GRPC_POLLSET_CAN_KICK_SELF) == 0 &&+            gpr_tls_get(&g_current_thread_worker) ==+                (intptr_t)specific_worker) {+          push_back_worker(p, specific_worker);+          specific_worker = NULL;+        }+      }+      if (specific_worker != NULL) {+        GPR_TIMER_MARK(""finally_kick"", 0);+        push_back_worker(p, specific_worker);+        grpc_wakeup_fd_wakeup(&specific_worker->wakeup_fd->fd);+      }+    } else {+      GPR_TIMER_MARK(""kicked_no_pollers"", 0);+      p->kicked_without_pollers = 1;+    }+  }++  GPR_TIMER_END(""pollset_kick_ext"", 0);+}++static void pollset_kick(grpc_pollset *p,+                         grpc_pollset_worker *specific_worker) {+  pollset_kick_ext(p, specific_worker, 0);+}++/* global state management */++static void pollset_global_init(void) {+  gpr_tls_init(&g_current_thread_poller);+  gpr_tls_init(&g_current_thread_worker);+  grpc_wakeup_fd_init(&grpc_global_wakeup_fd);+}++static void pollset_global_shutdown(void) {+  grpc_wakeup_fd_destroy(&grpc_global_wakeup_fd);+  gpr_tls_destroy(&g_current_thread_poller);+  gpr_tls_destroy(&g_current_thread_worker);+}++static void kick_poller(void) { grpc_wakeup_fd_wakeup(&grpc_global_wakeup_fd); }++/* main interface */++static void pollset_init(grpc_pollset *pollset, gpr_mu **mu) {+  gpr_mu_init(&pollset->mu);+  *mu = &pollset->mu;+  pollset->root_worker.next = pollset->root_worker.prev = &pollset->root_worker;+  pollset->in_flight_cbs = 0;+  pollset->shutting_down = 0;+  pollset->called_shutdown = 0;+  pollset->kicked_without_pollers = 0;+  pollset->idle_jobs.head = pollset->idle_jobs.tail = NULL;+  pollset->local_wakeup_cache = NULL;+  pollset->kicked_without_pollers = 0;+  pollset->fd_count = 0;+  pollset->fd_capacity = 0;+  pollset->del_count = 0;+  pollset->del_capacity = 0;+  pollset->fds = NULL;+  pollset->dels = NULL;+}++static void pollset_destroy(grpc_pollset *pollset) {+  GPR_ASSERT(pollset->in_flight_cbs == 0);+  GPR_ASSERT(!pollset_has_workers(pollset));+  GPR_ASSERT(pollset->idle_jobs.head == pollset->idle_jobs.tail);+  while (pollset->local_wakeup_cache) {+    grpc_cached_wakeup_fd *next = pollset->local_wakeup_cache->next;+    grpc_wakeup_fd_destroy(&pollset->local_wakeup_cache->fd);+    gpr_free(pollset->local_wakeup_cache);+    pollset->local_wakeup_cache = next;+  }+  gpr_free(pollset->fds);+  gpr_free(pollset->dels);+  gpr_mu_destroy(&pollset->mu);+}++static void pollset_reset(grpc_pollset *pollset) {+  GPR_ASSERT(pollset->shutting_down);+  GPR_ASSERT(pollset->in_flight_cbs == 0);+  GPR_ASSERT(!pollset_has_workers(pollset));+  GPR_ASSERT(pollset->idle_jobs.head == pollset->idle_jobs.tail);+  GPR_ASSERT(pollset->fd_count == 0);+  GPR_ASSERT(pollset->del_count == 0);+  pollset->shutting_down = 0;+  pollset->called_shutdown = 0;+  pollset->kicked_without_pollers = 0;+}++static void pollset_add_fd(grpc_exec_ctx *exec_ctx, grpc_pollset *pollset,+                           grpc_fd *fd) {+  gpr_mu_lock(&pollset->mu);+  size_t i;+  /* TODO(ctiller): this is O(num_fds^2); maybe switch to a hash set here */+  for (i = 0; i < pollset->fd_count; i++) {+    if (pollset->fds[i] == fd) goto exit;+  }+  if (pollset->fd_count == pollset->fd_capacity) {+    pollset->fd_capacity =+        GPR_MAX(pollset->fd_capacity + 8, pollset->fd_count * 3 / 2);+    pollset->fds =+        gpr_realloc(pollset->fds, sizeof(grpc_fd *) * pollset->fd_capacity);+  }+  pollset->fds[pollset->fd_count++] = fd;+  GRPC_FD_REF(fd, ""multipoller"");+  pollset_kick(pollset, NULL);+exit:+  gpr_mu_unlock(&pollset->mu);+}++static void finish_shutdown(grpc_exec_ctx *exec_ctx, grpc_pollset *pollset) {+  GPR_ASSERT(grpc_closure_list_empty(pollset->idle_jobs));+  size_t i;+  for (i = 0; i < pollset->fd_count; i++) {+    GRPC_FD_UNREF(pollset->fds[i], ""multipoller"");+  }+  for (i = 0; i < pollset->del_count; i++) {+    GRPC_FD_UNREF(pollset->dels[i], ""multipoller_del"");+  }+  pollset->fd_count = 0;+  pollset->del_count = 0;+  grpc_exec_ctx_enqueue(exec_ctx, pollset->shutdown_done, true, NULL);+}++static void pollset_work(grpc_exec_ctx *exec_ctx, grpc_pollset *pollset,+                         grpc_pollset_worker **worker_hdl, gpr_timespec now,+                         gpr_timespec deadline) {+  grpc_pollset_worker worker;+  *worker_hdl = &worker;++  /* pollset->mu already held */+  int added_worker = 0;+  int locked = 1;+  int queued_work = 0;+  int keep_polling = 0;+  GPR_TIMER_BEGIN(""pollset_work"", 0);+  /* this must happen before we (potentially) drop pollset->mu */+  worker.next = worker.prev = NULL;+  worker.reevaluate_polling_on_wakeup = 0;+  if (pollset->local_wakeup_cache != NULL) {+    worker.wakeup_fd = pollset->local_wakeup_cache;+    pollset->local_wakeup_cache = worker.wakeup_fd->next;+  } else {+    worker.wakeup_fd = gpr_malloc(sizeof(*worker.wakeup_fd));+    grpc_wakeup_fd_init(&worker.wakeup_fd->fd);+  }+  worker.kicked_specifically = 0;+  /* If there's work waiting for the pollset to be idle, and the+     pollset is idle, then do that work */+  if (!pollset_has_workers(pollset) &&+      !grpc_closure_list_empty(pollset->idle_jobs)) {+    GPR_TIMER_MARK(""pollset_work.idle_jobs"", 0);+    grpc_exec_ctx_enqueue_list(exec_ctx, &pollset->idle_jobs, NULL);+    goto done;+  }+  /* If we're shutting down then we don't execute any extended work */+  if (pollset->shutting_down) {+    GPR_TIMER_MARK(""pollset_work.shutting_down"", 0);+    goto done;+  }+  /* Give do_promote priority so we don't starve it out */+  if (pollset->in_flight_cbs) {+    GPR_TIMER_MARK(""pollset_work.in_flight_cbs"", 0);+    gpr_mu_unlock(&pollset->mu);+    locked = 0;+    goto done;+  }+  /* Start polling, and keep doing so while we're being asked to+     re-evaluate our pollers (this allows poll() based pollers to+     ensure they don't miss wakeups) */+  keep_polling = 1;+  while (keep_polling) {+    keep_polling = 0;+    if (!pollset->kicked_without_pollers) {+      if (!added_worker) {+        push_front_worker(pollset, &worker);+        added_worker = 1;+        gpr_tls_set(&g_current_thread_worker, (intptr_t)&worker);+      }+      gpr_tls_set(&g_current_thread_poller, (intptr_t)pollset);+      GPR_TIMER_BEGIN(""maybe_work_and_unlock"", 0);+#define POLLOUT_CHECK (POLLOUT | POLLHUP | POLLERR)+#define POLLIN_CHECK (POLLIN | POLLHUP | POLLERR)++      int timeout;+      int r;+      size_t i, j, fd_count;+      nfds_t pfd_count;+      /* TODO(ctiller): inline some elements to avoid an allocation */+      grpc_fd_watcher *watchers;+      struct pollfd *pfds;++      timeout = poll_deadline_to_millis_timeout(deadline, now);+      /* TODO(ctiller): perform just one malloc here if we exceed the inline+       * case */+      pfds = gpr_malloc(sizeof(*pfds) * (pollset->fd_count + 2));+      watchers = gpr_malloc(sizeof(*watchers) * (pollset->fd_count + 2));+      fd_count = 0;+      pfd_count = 2;+      pfds[0].fd = GRPC_WAKEUP_FD_GET_READ_FD(&grpc_global_wakeup_fd);+      pfds[0].events = POLLIN;+      pfds[0].revents = 0;+      pfds[1].fd = GRPC_WAKEUP_FD_GET_READ_FD(&worker.wakeup_fd->fd);+      pfds[1].events = POLLIN;+      pfds[1].revents = 0;+      for (i = 0; i < pollset->fd_count; i++) {+        int remove = fd_is_orphaned(pollset->fds[i]);+        for (j = 0; !remove && j < pollset->del_count; j++) {+          if (pollset->fds[i] == pollset->dels[j]) remove = 1;+        }+        if (remove) {+          GRPC_FD_UNREF(pollset->fds[i], ""multipoller"");+        } else {+          pollset->fds[fd_count++] = pollset->fds[i];+          watchers[pfd_count].fd = pollset->fds[i];+          GRPC_FD_REF(watchers[pfd_count].fd, ""multipoller_start"");+          pfds[pfd_count].fd = pollset->fds[i]->fd;+          pfds[pfd_count].revents = 0;+          pfd_count++;+        }+      }+      for (j = 0; j < pollset->del_count; j++) {+        GRPC_FD_UNREF(pollset->dels[j], ""multipoller_del"");+      }+      pollset->del_count = 0;+      pollset->fd_count = fd_count;+      gpr_mu_unlock(&pollset->mu);++      for (i = 2; i < pfd_count; i++) {+        grpc_fd *fd = watchers[i].fd;+        pfds[i].events = (short)fd_begin_poll(fd, pollset, &worker, POLLIN,+                                              POLLOUT, &watchers[i]);+        GRPC_FD_UNREF(fd, ""multipoller_start"");+      }++      /* TODO(vpai): Consider first doing a 0 timeout poll here to avoid+         even going into the blocking annotation if possible */+      GRPC_SCHEDULING_START_BLOCKING_REGION;+      r = grpc_poll_function(pfds, pfd_count, timeout);+      GRPC_SCHEDULING_END_BLOCKING_REGION;++      if (r < 0) {+        if (errno != EINTR) {+          gpr_log(GPR_ERROR, ""poll() failed: %s"", strerror(errno));+        }+        for (i = 2; i < pfd_count; i++) {+          fd_end_poll(exec_ctx, &watchers[i], 0, 0);+        }+      } else if (r == 0) {+        for (i = 2; i < pfd_count; i++) {+          fd_end_poll(exec_ctx, &watchers[i], 0, 0);+        }+      } else {+        if (pfds[0].revents & POLLIN_CHECK) {+          grpc_wakeup_fd_consume_wakeup(&grpc_global_wakeup_fd);+        }+        if (pfds[1].revents & POLLIN_CHECK) {+          grpc_wakeup_fd_consume_wakeup(&worker.wakeup_fd->fd);+        }+        for (i = 2; i < pfd_count; i++) {+          if (watchers[i].fd == NULL) {+            fd_end_poll(exec_ctx, &watchers[i], 0, 0);+          } else {+            fd_end_poll(exec_ctx, &watchers[i], pfds[i].revents & POLLIN_CHECK,+                        pfds[i].revents & POLLOUT_CHECK);+          }+        }+      }++      gpr_free(pfds);+      gpr_free(watchers);+      GPR_TIMER_END(""maybe_work_and_unlock"", 0);+      locked = 0;+      gpr_tls_set(&g_current_thread_poller, 0);+    } else {+      GPR_TIMER_MARK(""pollset_work.kicked_without_pollers"", 0);+      pollset->kicked_without_pollers = 0;+    }+  /* Finished execution - start cleaning up.+     Note that we may arrive here from outside the enclosing while() loop.+     In that case we won't loop though as we haven't added worker to the+     worker list, which means nobody could ask us to re-evaluate polling). */+  done:+    if (!locked) {+      queued_work |= grpc_exec_ctx_flush(exec_ctx);+      gpr_mu_lock(&pollset->mu);+      locked = 1;+    }+    /* If we're forced to re-evaluate polling (via pollset_kick with+       GRPC_POLLSET_REEVALUATE_POLLING_ON_WAKEUP) then we land here and force+       a loop */+    if (worker.reevaluate_polling_on_wakeup) {+      worker.reevaluate_polling_on_wakeup = 0;+      pollset->kicked_without_pollers = 0;+      if (queued_work || worker.kicked_specifically) {+        /* If there's queued work on the list, then set the deadline to be+           immediate so we get back out of the polling loop quickly */+        deadline = gpr_inf_past(GPR_CLOCK_MONOTONIC);+      }+      keep_polling = 1;+    }+    if (keep_polling) {+      now = gpr_now(now.clock_type);","Yeah. I'm not certain it's actually needed, but seems a bit more robust regardless: if we keep polling, right now we reset the deadline to inf_past... but later we might change that (I don't know why)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/5456,63230457,2016-05-13T18:31:07Z,src/core/lib/iomgr/ev_poll_posix.c,"@@ -0,0 +1,1212 @@+/*+ *+ * Copyright 2015-2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>++#ifdef GPR_POSIX_SOCKET++#include ""src/core/lib/iomgr/ev_poll_posix.h""++#include <assert.h>+#include <errno.h>+#include <poll.h>+#include <string.h>+#include <sys/socket.h>+#include <unistd.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>+#include <grpc/support/tls.h>+#include <grpc/support/useful.h>++#include ""src/core/lib/iomgr/iomgr_internal.h""+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""+#include ""src/core/lib/profiling/timers.h""+#include ""src/core/lib/support/block_annotate.h""++/*******************************************************************************+ * FD declarations+ */++typedef struct grpc_fd_watcher {+  struct grpc_fd_watcher *next;+  struct grpc_fd_watcher *prev;+  grpc_pollset *pollset;+  grpc_pollset_worker *worker;+  grpc_fd *fd;+} grpc_fd_watcher;++struct grpc_fd {+  int fd;+  /* refst format:+     bit0:   1=active/0=orphaned+     bit1-n: refcount+     meaning that mostly we ref by two to avoid altering the orphaned bit,+     and just unref by 1 when we're ready to flag the object as orphaned */+  gpr_atm refst;++  gpr_mu mu;+  int shutdown;+  int closed;+  int released;++  /* The watcher list.++     The following watcher related fields are protected by watcher_mu.++     An fd_watcher is an ephemeral object created when an fd wants to+     begin polling, and destroyed after the poll.++     It denotes the fd's interest in whether to read poll or write poll+     or both or neither on this fd.++     If a watcher is asked to poll for reads or writes, the read_watcher+     or write_watcher fields are set respectively. A watcher may be asked+     to poll for both, in which case both fields will be set.++     read_watcher and write_watcher may be NULL if no watcher has been+     asked to poll for reads or writes.++     If an fd_watcher is not asked to poll for reads or writes, it's added+     to a linked list of inactive watchers, rooted at inactive_watcher_root.+     If at a later time there becomes need of a poller to poll, one of+     the inactive pollers may be kicked out of their poll loops to take+     that responsibility. */+  grpc_fd_watcher inactive_watcher_root;+  grpc_fd_watcher *read_watcher;+  grpc_fd_watcher *write_watcher;++  grpc_closure *read_closure;+  grpc_closure *write_closure;++  grpc_closure *on_done_closure;++  grpc_iomgr_object iomgr_object;+};++/* Begin polling on an fd.+   Registers that the given pollset is interested in this fd - so that if read+   or writability interest changes, the pollset can be kicked to pick up that+   new interest.+   Return value is:+     (fd_needs_read? read_mask : 0) | (fd_needs_write? write_mask : 0)+   i.e. a combination of read_mask and write_mask determined by the fd's current+   interest in said events.+   Polling strategies that do not need to alter their behavior depending on the+   fd's current interest (such as epoll) do not need to call this function.+   MUST NOT be called with a pollset lock taken */+static uint32_t fd_begin_poll(grpc_fd *fd, grpc_pollset *pollset,+                              grpc_pollset_worker *worker, uint32_t read_mask,+                              uint32_t write_mask, grpc_fd_watcher *rec);+/* Complete polling previously started with fd_begin_poll+   MUST NOT be called with a pollset lock taken+   if got_read or got_write are 1, also does the become_{readable,writable} as+   appropriate. */+static void fd_end_poll(grpc_exec_ctx *exec_ctx, grpc_fd_watcher *rec,+                        int got_read, int got_write);++/* Return 1 if this fd is orphaned, 0 otherwise */+static bool fd_is_orphaned(grpc_fd *fd);++/* Reference counting for fds */+/*#define GRPC_FD_REF_COUNT_DEBUG*/+#ifdef GRPC_FD_REF_COUNT_DEBUG+static void fd_ref(grpc_fd *fd, const char *reason, const char *file, int line);+static void fd_unref(grpc_fd *fd, const char *reason, const char *file,+                     int line);+#define GRPC_FD_REF(fd, reason) fd_ref(fd, reason, __FILE__, __LINE__)+#define GRPC_FD_UNREF(fd, reason) fd_unref(fd, reason, __FILE__, __LINE__)+#else+static void fd_ref(grpc_fd *fd);+static void fd_unref(grpc_fd *fd);+#define GRPC_FD_REF(fd, reason) fd_ref(fd)+#define GRPC_FD_UNREF(fd, reason) fd_unref(fd)+#endif++#define CLOSURE_NOT_READY ((grpc_closure *)0)+#define CLOSURE_READY ((grpc_closure *)1)++/*******************************************************************************+ * pollset declarations+ */++typedef struct grpc_cached_wakeup_fd {+  grpc_wakeup_fd fd;+  struct grpc_cached_wakeup_fd *next;+} grpc_cached_wakeup_fd;++struct grpc_pollset_worker {+  grpc_cached_wakeup_fd *wakeup_fd;+  int reevaluate_polling_on_wakeup;+  int kicked_specifically;+  struct grpc_pollset_worker *next;+  struct grpc_pollset_worker *prev;+};++struct grpc_pollset {+  gpr_mu mu;+  grpc_pollset_worker root_worker;+  int in_flight_cbs;+  int shutting_down;+  int called_shutdown;+  int kicked_without_pollers;+  grpc_closure *shutdown_done;+  grpc_closure_list idle_jobs;+  /* all polled fds */+  size_t fd_count;+  size_t fd_capacity;+  grpc_fd **fds;+  /* fds that have been removed from the pollset explicitly */+  size_t del_count;+  size_t del_capacity;+  grpc_fd **dels;",Totally antiquated... happy to remove later.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6481,63236862,2016-05-13T19:15:53Z,include/grpc/impl/codegen/grpc_types.h,"@@ -332,7 +333,12 @@ typedef struct grpc_op {     struct {       size_t count;       grpc_metadata *metadata;-      grpc_compression_level compression_level;+      /** If \a is_set, \a compression_level will be used for the call.+       * Otherwise, \a compression_level won't be considered */+      struct {+        bool is_set;+        grpc_compression_level compression_level;+      } maybe_compression_level;","We reserve 8 pointers for op data (see a few lines above): we are fine here.That said, this is a public header and must be c89. Please lose the bool.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6591,63270475,2016-05-14T03:26:00Z,src/core/lib/surface/call.c,"@@ -984,6 +984,10 @@ static void continue_receiving_slices(grpc_exec_ctx *exec_ctx,       call->receiving_message = 0;       grpc_byte_stream_destroy(exec_ctx, call->receiving_stream);       call->receiving_stream = NULL;+      if (call->status[STATUS_FROM_API_OVERRIDE].code != GRPC_STATUS_OK) {","Yeah, I don't like how it smells (having had to choose STATUS_FROM_API_OVERRIDE for lack of something else). Also testing for != OK. How about having a bool in the call instance that's set by `grpc_call_cancel` for purposes of internal cleanups like this one?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6588,63393133,2016-05-16T17:42:27Z,src/python/grpcio/grpc/_adapter/_low.py,"@@ -195,26 +195,30 @@ def start_batch(self, ops, tag):         translated_op = cygrpc.operation_send_initial_metadata(             cygrpc.Metadata(                 cygrpc.Metadatum(key, value)-                for key, value in op.initial_metadata))+                for key, value in op.initial_metadata),+            op.write_flags)",It's a code smell that something called `write_flags` is being passed to all these different functions that have nothing to do with writing (and one function that does). Is the name `flags` available for the attribute being passed on the changed lines in this file?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6588,63394720,2016-05-16T17:52:02Z,src/python/grpcio/tests/unit/_cython/cygrpc_test.py,"@@ -188,12 +193,12 @@ def testEcho(self):                          CLIENT_METADATA_ASCII_VALUE),         cygrpc.Metadatum(CLIENT_METADATA_BIN_KEY, CLIENT_METADATA_BIN_VALUE)])     client_start_batch_result = client_call.start_batch(cygrpc.Operations([-        cygrpc.operation_send_initial_metadata(client_initial_metadata),-        cygrpc.operation_send_message(REQUEST),-        cygrpc.operation_send_close_from_client(),-        cygrpc.operation_receive_initial_metadata(),-        cygrpc.operation_receive_message(),-        cygrpc.operation_receive_status_on_client()+        cygrpc.operation_send_initial_metadata(client_initial_metadata, 0),","I'm not yet ready to suggest that we include such a constant in our public API, but at least within this file how about an `_EMPTY_FLAGS` constant? All these zeroes start to melt one's brain appearing as they do without context.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6588,63558605,2016-05-17T16:42:05Z,src/python/grpcio/grpc/_adapter/_low.py,"@@ -195,26 +195,30 @@ def start_batch(self, ops, tag):         translated_op = cygrpc.operation_send_initial_metadata(             cygrpc.Metadata(                 cygrpc.Metadatum(key, value)-                for key, value in op.initial_metadata))+                for key, value in op.initial_metadata),+            op.write_flags)","No need to change anything, but a different perspective: isn't the initial metadata send the most important write we do? It's required of every RPC, and nothing happens until it's written.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6588,63575558,2016-05-17T18:16:15Z,src/python/grpcio/grpc/_adapter/_types.py,"@@ -165,7 +165,7 @@ class OpArgs(collections.namedtuple(     message (bytes): Only valid if type == OpType.SEND_MESSAGE, else is None.     status (Status): Only valid if type == OpType.SEND_STATUS_FROM_SERVER, else       is None.-    write_flags (int): a bit OR'ing of 0 or more OpWriteFlags values.+    flags (int): a bit OR'ing of 0 or more OpWriteFlags values.","Should the class mentioned here be renamed ""OpFlags""?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6588,63575776,2016-05-17T18:17:38Z,src/python/grpcio/grpc/_adapter/_types.py,"@@ -165,7 +165,7 @@ class OpArgs(collections.namedtuple(     message (bytes): Only valid if type == OpType.SEND_MESSAGE, else is None.     status (Status): Only valid if type == OpType.SEND_STATUS_FROM_SERVER, else       is None.-    write_flags (int): a bit OR'ing of 0 or more OpWriteFlags values.+    flags (int): a bit OR'ing of 0 or more OpWriteFlags values.","""A bit-ORing ..."" or ""A bitwise ORing of ...""? I just accidentally misread this as describing a one-bit integer. :-P",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6588,63597867,2016-05-17T20:31:24Z,src/python/grpcio/grpc/_adapter/_types.py,"@@ -165,7 +165,7 @@ class OpArgs(collections.namedtuple(     message (bytes): Only valid if type == OpType.SEND_MESSAGE, else is None.     status (Status): Only valid if type == OpType.SEND_STATUS_FROM_SERVER, else       is None.-    write_flags (int): a bit OR'ing of 0 or more OpWriteFlags values.+    flags (int): a bit OR'ing of 0 or more OpWriteFlags values.","While the flags element is available to all `grpc_op` types (whether the kind that writes _or not_) in the core, the specific flags exposed are only of the section titled ""Write Flags"" [here](https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/grpc_types.h#L197) in core. I wouldn't mind the change, but at this point we're just trading naming for symmetry and there's no write answer.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6588,63598378,2016-05-17T20:34:00Z,src/python/grpcio/grpc/_adapter/_types.py,"@@ -165,7 +165,7 @@ class OpArgs(collections.namedtuple(     message (bytes): Only valid if type == OpType.SEND_MESSAGE, else is None.     status (Status): Only valid if type == OpType.SEND_STATUS_FROM_SERVER, else       is None.-    write_flags (int): a bit OR'ing of 0 or more OpWriteFlags values.+    flags (int): a bit OR'ing of 0 or more OpWriteFlags values.","And it's not public, so if we want to expose other call flags, it's easy enough to rename the class at that later time. Right?",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6499,63639552,2016-05-18T03:12:07Z,src/core/lib/surface/call.c,"@@ -1087,6 +1089,24 @@ static void receiving_initial_metadata_ready(grpc_exec_ctx *exec_ctx,         &call->metadata_batch[1 /* is_receiving */][0 /* is_trailing */];     grpc_metadata_batch_filter(md, recv_initial_filter, call); +    /* make sure the received grpc-encoding is amongst the ones listed in+     * grpc-accept-encoding */++    GPR_ASSERT(call->encodings_accepted_by_peer != 0);",@dgquintas : Thanks for clarifying this offline. Just to document what we talked:  The LSB is always set either at line 265 (by the server when creating the call object) and may also be set in `set_encodings_accepted_by_peer()` function which is called (in some cases) by the `grpc_metadata_batch_filter()` function in the previous line (i.e line: 1090),
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6254,63709317,2016-05-18T14:10:32Z,src/python/grpcio/tests/unit/beta/_auth_test.py,"@@ -0,0 +1,98 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests of standard AuthMetadataPlugins.""""""++import threading+import unittest++from grpc.beta import _auth+++class MockAccessTokenInfo(dict):",Why does this class need to exist? Why can't a `dict` be used instead at its one use-site?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6611,63718061,2016-05-18T14:53:03Z,src/ruby/ext/grpc/rb_completion_queue.c,"@@ -52,21 +52,47 @@ typedef struct next_call_stack {   grpc_event event;   gpr_timespec timeout;   void *tag;+  volatile int interrupted; } next_call_stack;  /* Calls grpc_completion_queue_next without holding the ruby GIL */ static void *grpc_rb_completion_queue_next_no_gil(void *param) {   next_call_stack *const next_call = (next_call_stack*)param;-  next_call->event =-      grpc_completion_queue_next(next_call->cq, next_call->timeout, NULL);+  gpr_timespec increment = gpr_time_from_millis(20, GPR_TIMESPAN);+  gpr_timespec deadline;+  do {+    deadline = gpr_time_add(gpr_now(GPR_CLOCK_REALTIME), increment);","in next_call->timeout is in 19msec and our deadline is in 20, we just skip?",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/6611,63729418,2016-05-18T15:47:23Z,src/ruby/ext/grpc/rb_completion_queue.c,"@@ -52,21 +52,47 @@ typedef struct next_call_stack {   grpc_event event;   gpr_timespec timeout;   void *tag;+  volatile int interrupted; } next_call_stack;  /* Calls grpc_completion_queue_next without holding the ruby GIL */ static void *grpc_rb_completion_queue_next_no_gil(void *param) {   next_call_stack *const next_call = (next_call_stack*)param;-  next_call->event =-      grpc_completion_queue_next(next_call->cq, next_call->timeout, NULL);+  gpr_timespec increment = gpr_time_from_millis(20, GPR_TIMESPAN);","It's a time period that's short from the point of view of a human, but long in terms of processing time. In the future, we can tune it if it turns out to have a significant performance impact.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6327,63937177,2016-05-19T19:10:01Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def disable_next_message_compression(self):+    """"""Disables compression of the next message passed by the application.""""""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self):+    """"""Accesses the terminal metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The terminal metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The integer status code of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self, terminal_metadata):+    """"""Accepts the terminal metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side terminal metadata to transmit.++    Args:+      terminal_metadata: The terminal metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(+      self, request, timeout=None, metadata=None, disable_compression=False,+      subcall_of=None, credentials=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated abnormally. The raised+        RpcError will also be a Call for the RPC affording the RPC's metadata,+        status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(+      self, request, timeout=None, metadata=None, disable_compression=False,+      subcall_of=None, credentials=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. In the event of RPC abortion, the returned+        Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(+      self, request, timeout=None, metadata=None, disable_compression=False,+      subcall_of=None, credentials=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating abnormal termination of the RPC.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None,+      with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated abnormally. The raised+        RpcError will also be a Call for the RPC affording the RPC's metadata,+        status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(+      self, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. In the event of RPC abortion, the returned+        Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating abnormal termination of the RPC.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):+    """"""Subscribes to this Channel's connectivity.++    Args:+      callback: A callable to be invoked and passed an integer value describing+        this Channel's connectivity. The callable will be invoked immediately+        upon subscription and again for every change to this Channel's+        connectivity thereafter until it is unsubscribed.+      try_to_connect: A boolean indicating whether or not this Channel should+        attempt to connect if it is not already connected and ready to conduct+        RPCs.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unsubscribe(self, callback):+    """"""Unsubscribes a callback from this Channel's connectivity.++    Args:+      callback: A callable previously registered with this Channel from having+        been passed to its ""subscribe"" method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def blocking_unary_unary(+      self, method, request, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None,+      with_call=False):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def future_unary_unary(+      self, method, request, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def inline_unary_stream(+      self, method, request, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def blocking_stream_unary(+      self, method, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None,+      with_call=False):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def future_stream_unary(+      self, method, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def inline_stream_stream(+      self, method, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_unary(self, method):+    """"""Creates a UnaryUnaryMultiCallable for a unary-unary method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A UnaryUnaryMultiCallable value for the named unary-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_stream(self, method):+    """"""Creates a UnaryStreamMultiCallable for a unary-stream method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A UnaryStreamMultiCallable value for the name unary-stream method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_unary(self, method):+    """"""Creates a StreamUnaryMultiCallable for a stream-unary method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A StreamUnaryMultiCallable value for the named stream-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_stream(self, method):+    """"""Creates a StreamStreamMultiCallable for a stream-stream method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A StreamStreamMultiCallable value for the named stream-stream method.+    """"""+    raise NotImplementedError()+++class Server(six.with_metaclass(abc.ABCMeta)):+  """"""Services RPCs.""""""++  @abc.abstractmethod+  def add_service(self, service):+    """"""Something something https://github.com/grpc/grpc/issues/4418?""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_insecure_port(self, address):+    """"""Reserves a port for insecure RPC service once this Server becomes active.++    This method may only be called before calling this Server's start method is+    called.++    Args:+      address: The address for which to open a port.++    Returns:+      An integer port on which RPCs will be serviced after this link has been+        started. This is typically the same number as the port number contained+        in the passed address, but will likely be different if the port number+        contained in the passed address was zero.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def start(self):+    """"""Starts this Server's service of RPCs.++    This method may only be called while the server is not serving RPCs (i.e. it+    is not idempotent).+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stop(self, grace):+    """"""Stops this Server's service of RPCs.++    All calls to this method immediately stop service of new RPCs. When existing+    RPCs are aborted is controlled by the grace period parameter passed to this+    method.++    This method may be called at any time and is idempotent. Passing a smaller+    grace value than has been passed in a previous call will have the effect of+    stopping the Server sooner. Passing a larger grace value than has been+    passed in a previous call will not have the effect of stopping the sooner+    later.++    Args:+      grace: A duration of time in seconds to allow existing RPCs to complete+        before being aborted by this Server's stopping. May be zero for+        immediate abortion of all in-progress RPCs.++    Returns:+      A threading.Event that will be set when this Server has completely+      stopped. The returned event may not be set until after the full grace+      period (if some ongoing RPC continues for the full length of the period)+      of it may be set much sooner (such as if this Server had no RPCs underway+      at the time it was stopped or if all RPCs that it had underway completed+      very early in the grace period).+    """"""+    raise NotImplementedError()+++def channel_ready_future(channel):+  """"""Creates a Future tracking when a Channel is ready.++  Cancelling the returned Future does not tell the given+  Channel to abandon attempts it may have been making to+  connect; cancelling merely deactivates the return Future's+  subscription to the given Channel's connectivity.++  Args:+    channel: A Channel.++  Returns:+    A Future that matures when the given Channel has connectivity ¯\_(ツ)_/¯ (""2""?)+  """"""+  raise NotImplementedError",Is this meant to eventually become a concrete function or is it a placeholder for some really semantically-fancy abstract module-level things?,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6327,63937827,2016-05-19T19:14:14Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.",I like the added specific of _this_ future object in the semantically organized documentation in addition to the prose (as opposed to the article 'a').,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6643,63955770,2016-05-19T21:14:21Z,src/csharp/Grpc.IntegrationTesting/ClientRunners.cs,"@@ -55,6 +58,15 @@ public class ClientRunners     {         static readonly ILogger Logger = GrpcEnvironment.Logger.ForType<ClientRunners>(); +        // Profilers to use for clients.+        static readonly BlockingCollection<BasicProfiler> profilers = new BlockingCollection<BasicProfiler>();++        internal static void AddProfiler(BasicProfiler profiler)","High level comment:Perhaps I don't fully understand the use case of profiling, but could we simplify this by just instantiating a profiler in ClientRunnerImpl if some boolean field is set?  Or do we actually need to be able to set a specific profiler per client runner?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,63955927,2016-05-19T21:15:38Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def disable_next_message_compression(self):+    """"""Disables compression of the next message passed by the application.""""""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self):+    """"""Accesses the terminal metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The terminal metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The integer status code of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self, terminal_metadata):+    """"""Accepts the terminal metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side terminal metadata to transmit.++    Args:+      terminal_metadata: The terminal metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(+      self, request, timeout=None, metadata=None, disable_compression=False,+      subcall_of=None, credentials=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated abnormally. The raised+        RpcError will also be a Call for the RPC affording the RPC's metadata,+        status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(+      self, request, timeout=None, metadata=None, disable_compression=False,+      subcall_of=None, credentials=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. In the event of RPC abortion, the returned+        Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(+      self, request, timeout=None, metadata=None, disable_compression=False,+      subcall_of=None, credentials=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating abnormal termination of the RPC.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None,+      with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated abnormally. The raised+        RpcError will also be a Call for the RPC affording the RPC's metadata,+        status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(+      self, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. In the event of RPC abortion, the returned+        Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      disable_compression: Whether or not to disable compression of the request.+      subcall_of: ¯\_(ツ)_/¯ A ServicerContext I guess?+      credentials: ¯\_(ツ)_/¯ Per-call credentials of some type?++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating abnormal termination of the RPC.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):+    """"""Subscribes to this Channel's connectivity.++    Args:+      callback: A callable to be invoked and passed an integer value describing+        this Channel's connectivity. The callable will be invoked immediately+        upon subscription and again for every change to this Channel's+        connectivity thereafter until it is unsubscribed.+      try_to_connect: A boolean indicating whether or not this Channel should+        attempt to connect if it is not already connected and ready to conduct+        RPCs.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unsubscribe(self, callback):+    """"""Unsubscribes a callback from this Channel's connectivity.++    Args:+      callback: A callable previously registered with this Channel from having+        been passed to its ""subscribe"" method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def blocking_unary_unary(+      self, method, request, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None,+      with_call=False):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def future_unary_unary(+      self, method, request, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def inline_unary_stream(+      self, method, request, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def blocking_stream_unary(+      self, method, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None,+      with_call=False):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def future_stream_unary(+      self, method, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def inline_stream_stream(+      self, method, request_iterator, timeout=None, metadata=None,+      disable_compression=False, subcall_of=None, credentials=None):+    """"""""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_unary(self, method):+    """"""Creates a UnaryUnaryMultiCallable for a unary-unary method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A UnaryUnaryMultiCallable value for the named unary-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_stream(self, method):+    """"""Creates a UnaryStreamMultiCallable for a unary-stream method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A UnaryStreamMultiCallable value for the name unary-stream method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_unary(self, method):+    """"""Creates a StreamUnaryMultiCallable for a stream-unary method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A StreamUnaryMultiCallable value for the named stream-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_stream(self, method):+    """"""Creates a StreamStreamMultiCallable for a stream-stream method.++    Args:+      method: The method identifier of the RPC.++    Returns:+      A StreamStreamMultiCallable value for the named stream-stream method.+    """"""+    raise NotImplementedError()+++class Server(six.with_metaclass(abc.ABCMeta)):+  """"""Services RPCs.""""""++  @abc.abstractmethod+  def add_service(self, service):+    """"""Something something https://github.com/grpc/grpc/issues/4418?""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_insecure_port(self, address):+    """"""Reserves a port for insecure RPC service once this Server becomes active.++    This method may only be called before calling this Server's start method is+    called.++    Args:+      address: The address for which to open a port.++    Returns:+      An integer port on which RPCs will be serviced after this link has been+        started. This is typically the same number as the port number contained+        in the passed address, but will likely be different if the port number+        contained in the passed address was zero.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def start(self):+    """"""Starts this Server's service of RPCs.++    This method may only be called while the server is not serving RPCs (i.e. it+    is not idempotent).+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stop(self, grace):+    """"""Stops this Server's service of RPCs.++    All calls to this method immediately stop service of new RPCs. When existing+    RPCs are aborted is controlled by the grace period parameter passed to this+    method.++    This method may be called at any time and is idempotent. Passing a smaller+    grace value than has been passed in a previous call will have the effect of+    stopping the Server sooner. Passing a larger grace value than has been+    passed in a previous call will not have the effect of stopping the sooner+    later.++    Args:+      grace: A duration of time in seconds to allow existing RPCs to complete+        before being aborted by this Server's stopping. May be zero for+        immediate abortion of all in-progress RPCs.++    Returns:+      A threading.Event that will be set when this Server has completely+      stopped. The returned event may not be set until after the full grace+      period (if some ongoing RPC continues for the full length of the period)+      of it may be set much sooner (such as if this Server had no RPCs underway+      at the time it was stopped or if all RPCs that it had underway completed+      very early in the grace period).+    """"""+    raise NotImplementedError()+++def channel_ready_future(channel):+  """"""Creates a Future tracking when a Channel is ready.++  Cancelling the returned Future does not tell the given+  Channel to abandon attempts it may have been making to+  connect; cancelling merely deactivates the return Future's+  subscription to the given Channel's connectivity.++  Args:+    channel: A Channel.++  Returns:+    A Future that matures when the given Channel has connectivity ¯\_(ツ)_/¯ (""2""?)+  """"""+  raise NotImplementedError","Concrete function.Since I dislike Python's ""detecting when you've raised a class, calling its constructor and propagating the constructed instance instead"" feature, I always raise instances in my permanent code. That means that when I use `raise <class object>`, it's a note to myself in draft code that it is a place where I'll come back and fill in the code later.I think it's cute that the difference between the meanings is a mere `()`.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6643,63970282,2016-05-19T23:26:03Z,src/csharp/Grpc.IntegrationTesting/ClientRunners.cs,"@@ -55,6 +58,15 @@ public class ClientRunners     {         static readonly ILogger Logger = GrpcEnvironment.Logger.ForType<ClientRunners>(); +        // Profilers to use for clients.+        static readonly BlockingCollection<BasicProfiler> profilers = new BlockingCollection<BasicProfiler>();++        internal static void AddProfiler(BasicProfiler profiler)","I am not super happy with this solution, but the idea is that you need one profiler per thread and in the program's Main, you need to dump profiler's data to a text file right before the application exits and you need access to the profiler from there.So in main, you create the profiler, add it with ClientRunners.AddProfiler() and once everything's finished, you can do profiler.Dump(""somefile.txt"").",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6643,63973025,2016-05-19T23:57:58Z,src/csharp/Grpc.Core/Properties/AssemblyInfo.cs,"@@ -16,6 +16,12 @@     ""0442bb8e12768722de0b0cb1b15e955b32a11352740ee59f2c94c48edc8e177d1052536b8ac651bce11ce5da3a"" +     ""27fc95aff3dc604a6971417453f9483c7b5e836756d5b271bf8f2403fe186e31956148c03d804487cf642f8cc0"" +     ""71394ee9672dfe5b55ea0f95dfd5a7f77d22c962ccf51320d3"")]+[assembly: InternalsVisibleTo(""Grpc.IntegrationTesting,PublicKey="" ++    ""00240000048000009400000006020000002400005253413100040000010001002f5797a92c6fcde81bd4098f43"" +","I tried this and it didn't end up being more readable. The problem is that to define such constant I need a static class and a namespace and refer to it using a its fully qualified name.So if you insist, I can do it, but otherwise I think it would be fine to leave this as is.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6663,64012995,2016-05-20T09:25:59Z,tools/distrib/python/grpcio_tools/grpc/__init__.py,"@@ -1,3 +1,5 @@+#!/usr/bin/env python2.7","Everything under this directory is library code and should not have a shebang. I can't speak for the rest of the tool files, but at least some others beyond this directory are lib files rather than executable scripts.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64078328,2016-05-20T17:34:09Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def disable_next_message_compression(self):+    """"""Disables compression of the next message passed by the application.""""""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self):+    """"""Accesses the terminal metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The terminal metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The integer status code of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self, terminal_metadata):+    """"""Accepts the terminal metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side terminal metadata to transmit.++    Args:+      terminal_metadata: The terminal metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""","I agree with the sentiment. I think I'm leaning the other way, but I'm open to being persuaded to move these code elements to another module.It comes down to the question of whether we expect this module to be friendlier to _read_ or friendier to _use_. If we want it friendlier to read, that means leaving the code elements that users are going to directly use in the file and migrating other code elements out to a less prominent place in some other module or modules. But since those other code elements are referenced from the code elements directly used by the users, that means that they still see them (in `Returns:` and `Raises:` documentation, at least).I think I like having everything in this module because it contributes to ease of use, even if that means the text of the module is less friendly for users of the code to read. When you make when you make an asynchronous RPC call, what's the type of the future that you get back? `grpc.Future`. Not `grpc.future.Future` or `grpc.interfaces.Future`. I like buying that benefit at the cost of the module's text being long to read.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6327,64093862,2016-05-20T19:19:30Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def disable_next_message_compression(self):+    """"""Disables compression of the next message passed by the application.""""""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self):+    """"""Accesses the terminal metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The terminal metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The integer status code of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self, terminal_metadata):+    """"""Accepts the terminal metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side terminal metadata to transmit.++    Args:+      terminal_metadata: The terminal metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""","Well, to start, I'd say `grpc.utility.Future`, where `grpc.utility` would include every interface we don't expect the user to create themselves sans _maybe_ the error types (else we'd just have a heavily populated `grpc` or `interfaces` namespace all over again with `future`, `server`, `blahblah` and the user not knowing which things said user _cares_ about, i.e. the root objects said user must self-manage).If you lean in the current direction, consider comment section headers, because now that we're traveling into long-and-flat-file-structure-land that we've been historically stylistically abhorrent of where there's no easy-to-recognize syntactic difference between code elements of different kinds (especially in this case, e.g. errors vs. contexts vs. callables vs. servers/clients differ only by the natural-language semantics of their identifiers/comments and _maybe_ length for errors), that's what those comments are for.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6503,64156151,2016-05-22T20:58:11Z,src/python/grpcio/commands.py,"@@ -190,8 +190,8 @@ def run(self):                                 stderr=subprocess.STDOUT)       except subprocess.CalledProcessError as e:         sys.stderr.write(-            'warning: Command:\n{}\nMessage:\n{}\nOutput:\n{}'.format(-                command, e.message, e.output))+            'warning: Command:\n{}\nOutput:\n{}'.format(","I don't understand what the changes to this file have to do with ""initial Python3 support"" - perhaps embellish your commit log message with a list of ""throughout the codebase, changed this thing into this other thing for this reason"" items?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6503,64156277,2016-05-22T21:05:47Z,src/python/grpcio/grpc/_links/service.py,"@@ -177,7 +178,10 @@ def _on_service_acceptance_event(self, event, server):     call = service_acceptance.call     call.accept(self._completion_queue, call)     try:-      group, method = service_acceptance.method.split(b'/')[1:3]+      service_method = service_acceptance.method+      if sys.version_info[0] >= 3:","Since we are using `six` throughout the rest of the library for Python 3 compatibility, please maintain uniformity by changing this to `if six.PY3:`.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6503,64156393,2016-05-22T21:12:58Z,src/python/grpcio/tests/unit/framework/foundation/_logging_pool_test.py,"@@ -29,6 +29,8 @@  """"""Tests for grpc.framework.foundation.logging_pool."""""" +from __future__ import division",Is this necessary? Doesn't `1 // 0` suffice to raise an exception in both Python 2 and Python 3?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6661,64156546,2016-05-22T21:24:05Z,tools/run_tests/performance/scenario_config.py,"@@ -127,7 +128,12 @@ def _ping_pong_scenario(name, rpc_type,     'warmup_seconds': warmup_seconds,     'benchmark_seconds': BENCHMARK_SECONDS   }-  if use_generic_payload:+  if use_big_generic_payload:","nit: ideally, if both big_generic_payload and use_generic_payload are set, this should throw so we don't get unexpected behavior.Fine to leave for now I think.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6662,64224653,2016-05-23T13:45:59Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -44,7 +44,7 @@ def check_status         # raise BadStatus, propagating the metadata if present.         md = status.metadata         with_sym_keys = Hash[md.each_pair.collect { |x, y| [x.to_sym, y] }]","btw, the metadata value should be a multi-map (and it looks like a ruby Hash isn't)",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6612,64236565,2016-05-23T14:54:49Z,test/cpp/end2end/hybrid_end2end_test.cc,"@@ -207,6 +207,9 @@ class HybridEnd2endTest : public ::testing::Test {     ServerBuilder builder;     builder.AddListeningPort(server_address_.str(),                              grpc::InsecureServerCredentials());+    // Always add a sync unimplemented service: we rely on having at least one+    // synchronous method to get a listening cq+    builder.RegisterService(&unimplemented_service_);","Do we really need this to get a listening cq ? - the hybrid server already has a ""sync part"" and that should give us a listening cq anyway.On a related note: I thought that these tests might have been previously failing because non-listening completion queues were not being added to `server->cqs` and hence weren't getting picked up for queuing completed events. I see that you fixed that (i.e add non-listening cqs to `server-cqs` and don't start a listener in `grpc_server_start` function on those pollsets) So shouldn't that fix take care of the hybrid_end2end test failures ?",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/6662,64243072,2016-05-23T15:47:12Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -44,7 +44,7 @@ def check_status         # raise BadStatus, propagating the metadata if present.         md = status.metadata         with_sym_keys = Hash[md.each_pair.collect { |x, y| [x.to_sym, y] }]","A value in the hash can be a list of strings, which is handled appropriately in the core.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6612,64277072,2016-05-23T19:50:40Z,test/cpp/end2end/hybrid_end2end_test.cc,"@@ -207,6 +207,9 @@ class HybridEnd2endTest : public ::testing::Test {     ServerBuilder builder;     builder.AddListeningPort(server_address_.str(),                              grpc::InsecureServerCredentials());+    // Always add a sync unimplemented service: we rely on having at least one+    // synchronous method to get a listening cq+    builder.RegisterService(&unimplemented_service_);","We've at least one test in the suite that overrides all methods as async or generic, meaning there's no sync part - meaning there's no sync listener (and that test needs one).We could either split out some code for that specific test (which one is escaping me at the minute), or live with this to ensure that there's a sync listener around.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6327,64390045,2016-05-24T13:30:32Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):+    """"""Subscribes to this Channel's connectivity.++    Args:+      callback: A callable to be invoked and passed a ChannelConnectivity value+        describing this Channel's connectivity. The callable will be invoked+        immediately upon subscription and again for every change to this+        Channel's connectivity thereafter until it is unsubscribed or this+        Channel object goes out of scope.+      try_to_connect: A boolean indicating whether or not this Channel should+        attempt to connect if it is not already connected and ready to conduct+        RPCs.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unsubscribe(self, callback):+    """"""Unsubscribes a callback from this Channel's connectivity.++    Args:+      callback: A callable previously registered with this Channel from having+        been passed to its ""subscribe"" method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_unary(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a UnaryUnaryMultiCallable for a unary-unary method.++    Args:+      method: The name of the RPC method.++    Returns:+      A UnaryUnaryMultiCallable value for the named unary-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_stream(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a UnaryStreamMultiCallable for a unary-stream method.++    Args:+      method: The name of the RPC method.++    Returns:+      A UnaryStreamMultiCallable value for the name unary-stream method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_unary(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a StreamUnaryMultiCallable for a stream-unary method.++    Args:+      method: The name of the RPC method.++    Returns:+      A StreamUnaryMultiCallable value for the named stream-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_stream(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a StreamStreamMultiCallable for a stream-stream method.++    Args:+      method: The name of the RPC method.++    Returns:+      A StreamStreamMultiCallable value for the named stream-stream method.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self, trailing_metadata):+    """"""Accepts the trailing metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side trailing metadata to transmit.++    Args:+      trailing_metadata: The trailing metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class RpcMethodHandler(six.with_metaclass(abc.ABCMeta)):+  """"""An implementation of a single RPC method.++  Attributes:+    request_streaming: Whether the RPC supports exactly one request message or+      any arbitrary number of request messages.+    response_streaming: Whether the RPC supports exactly one response message or+      any arbitrary number of response messages.+    request_deserializer: A callable behavior that accepts a byte string and+      returns an object suitable to be passed to this object's business logic,+      or None to indicate that this object's business logic should be passed the+      raw request bytes.+    response_serializer: A callable behavior that accepts an object produced by+      this object's business logic and returns a byte string, or None to+      indicate that the byte strings produced by this object's business logic+      should be transmitted on the wire as they are.+    unary_unary: This object's application-specific business logic as a callable+      value that takes a request value and a ServicerContext object and returns+      a response value. Only non-None if both request_streaming and+      response_streaming are False.+    unary_stream: This object's application-specific business logic as a+      callable value that takes a request value and a ServicerContext object and+      returns an iterator of response values. Only non-None if request_streaming+      is False and response_streaming is True.+    stream_unary: This object's application-specific business logic as a+      callable value that takes an iterator of request values and a+      ServicerContext object and returns a response value. Only non-None if+      request_streaming is True and response_streaming is False.+    stream_stream: This object's application-specific business logic as a+      callable value that takes an iterator of request values and a+      ServicerContext object and returns an iterator of response values. Only+      non-None if request_streaming and response_streaming are both True.+  """"""+++class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):+  """"""An implementation of arbitrarily many RPC methods.""""""++  @abc.abstractmethod+  def service(self, method):+    """"""Services an RPC (or not).++    Args:+      method: The name of the RPC method to be serviced.++    Returns:+      An RpcMethodHandler with which the RPC may be serviced, or None to+        indicate that this object will not be servicing the RPC.+    """"""+    raise NotImplementedError()+++class Server(six.with_metaclass(abc.ABCMeta)):","Is it worth switching this to a builder pattern?``` pythonclass ServerBuilder:  def add_XXX_handlers()  def add_port()  def build_and_start()class Server:  def stop()```My preference here is that it clearly labels lifetime phases, and gives a language way of not shooting yourself in the foot.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64394567,2016-05-24T13:55:59Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):+    """"""Subscribes to this Channel's connectivity.++    Args:+      callback: A callable to be invoked and passed a ChannelConnectivity value+        describing this Channel's connectivity. The callable will be invoked+        immediately upon subscription and again for every change to this+        Channel's connectivity thereafter until it is unsubscribed or this+        Channel object goes out of scope.+      try_to_connect: A boolean indicating whether or not this Channel should+        attempt to connect if it is not already connected and ready to conduct+        RPCs.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unsubscribe(self, callback):+    """"""Unsubscribes a callback from this Channel's connectivity.++    Args:+      callback: A callable previously registered with this Channel from having+        been passed to its ""subscribe"" method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_unary(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a UnaryUnaryMultiCallable for a unary-unary method.++    Args:+      method: The name of the RPC method.++    Returns:+      A UnaryUnaryMultiCallable value for the named unary-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def unary_stream(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a UnaryStreamMultiCallable for a unary-stream method.++    Args:+      method: The name of the RPC method.++    Returns:+      A UnaryStreamMultiCallable value for the name unary-stream method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_unary(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a StreamUnaryMultiCallable for a stream-unary method.++    Args:+      method: The name of the RPC method.++    Returns:+      A StreamUnaryMultiCallable value for the named stream-unary method.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def stream_stream(+      self, method, request_serializer=None, response_deserializer=None):+    """"""Creates a StreamStreamMultiCallable for a stream-stream method.++    Args:+      method: The name of the RPC method.++    Returns:+      A StreamStreamMultiCallable value for the named stream-stream method.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self, trailing_metadata):+    """"""Accepts the trailing metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side trailing metadata to transmit.++    Args:+      trailing_metadata: The trailing metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class RpcMethodHandler(six.with_metaclass(abc.ABCMeta)):+  """"""An implementation of a single RPC method.++  Attributes:+    request_streaming: Whether the RPC supports exactly one request message or+      any arbitrary number of request messages.+    response_streaming: Whether the RPC supports exactly one response message or+      any arbitrary number of response messages.+    request_deserializer: A callable behavior that accepts a byte string and+      returns an object suitable to be passed to this object's business logic,+      or None to indicate that this object's business logic should be passed the+      raw request bytes.+    response_serializer: A callable behavior that accepts an object produced by+      this object's business logic and returns a byte string, or None to+      indicate that the byte strings produced by this object's business logic+      should be transmitted on the wire as they are.+    unary_unary: This object's application-specific business logic as a callable+      value that takes a request value and a ServicerContext object and returns+      a response value. Only non-None if both request_streaming and+      response_streaming are False.+    unary_stream: This object's application-specific business logic as a+      callable value that takes a request value and a ServicerContext object and+      returns an iterator of response values. Only non-None if request_streaming+      is False and response_streaming is True.+    stream_unary: This object's application-specific business logic as a+      callable value that takes an iterator of request values and a+      ServicerContext object and returns a response value. Only non-None if+      request_streaming is True and response_streaming is False.+    stream_stream: This object's application-specific business logic as a+      callable value that takes an iterator of request values and a+      ServicerContext object and returns an iterator of response values. Only+      non-None if request_streaming and response_streaming are both True.+  """"""+++class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):+  """"""An implementation of arbitrarily many RPC methods.""""""++  @abc.abstractmethod+  def service(self, method):+    """"""Services an RPC (or not).++    Args:+      method: The name of the RPC method to be serviced.++    Returns:+      An RpcMethodHandler with which the RPC may be serviced, or None to+        indicate that this object will not be servicing the RPC.+    """"""+    raise NotImplementedError()+++class Server(six.with_metaclass(abc.ABCMeta)):","It's worth switching this to a builder pattern if it matches use of the builder patter to create servers in C++, Java, Go, and Ruby.(investigates...)Two of those languages use builders to construct servers and two don't. Well phooey.The mild pushback I would offer is that (1) it's just not something I've seen at all in Python, let alone commonly used, and (2) use of the pattern is great in compiled languages because the lifecycle violation is a type error surfaced at compile time, whereas here the pattern would add another class to the API without advancing the time at which the developer learns of their mistake from server-start-time to any earlier time.Although the more I reflect on ""add another type to the API"" the less mild I feel...",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6327,64476263,2016-05-24T21:19:32Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):","Can we surface `protocol_options` here? (And in all other instances with `timeout, metadata`)",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64503256,2016-05-25T01:35:43Z,src/objective-c/CronetFramework.podspec,"@@ -0,0 +1,138 @@+#+#  Be sure to run `pod spec lint cronet.podspec' to ensure this is a+#  valid spec and to remove all comments including this before submitting the spec.+#+#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html+#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/+#++Pod::Spec.new do |s|++  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #+  #+  #  These will help people to find your library, and whilst it+  #  can feel like a chore to fill in it's definitely to your advantage. The+  #  summary should be tweet-length, and the description more in depth.+  #++  s.name         = ""CronetFramework""+  s.version      = ""0.0.2""+  s.summary      = ""Cronet, precompiled and used as a framework.""++  # This description is used to generate tags and improve search results.+  #   * Think: What does it do? Why did you write it? What is the focus?+  #   * Try to keep it short, snappy and to the point.+  #   * Write the description between the DESC delimiters below.+  #   * Finally, don't worry about the indent, CocoaPods strips it!+  #s.description  = <<-DESC+  #                 DESC++  s.homepage     = ""http://chromium.org""+  # s.screenshots  = ""www.example.com/screenshots_1.gif"", ""www.example.com/screenshots_2.gif""+++  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #+  #+  #  Licensing your code is important. See http://choosealicense.com for more info.+  #  CocoaPods will detect a license file if there is a named LICENSE*+  #  Popular ones are 'MIT', 'BSD' and 'Apache License, Version 2.0'.+  #+  s.license      = { :type => 'BSD' }++  s.vendored_framework = ""Cronet.framework""+++  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #+  #+  #  Specify the authors of the library, with email addresses. Email addresses+  #  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also+  #  accepts just a name if you'd rather not provide an email address.+  #+  #  Specify a social_media_url where others can refer to, for example a twitter+  #  profile URL.+  #++  s.author             = """"",Is there an email list for Chromium contributors?,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64503354,2016-05-25T01:37:13Z,src/objective-c/GRPCClient/GRPCCall+Cronet.h,"@@ -0,0 +1,47 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+#import ""GRPCCall.h""++/**+ * TODOTODOTODO: Description+ */+@interface GRPCCall (Cronet)+++(void) setUseCronet:(BOOL) useCronet+                    :(void *)cronet_engine;","All parameters should be named.Also, fix spacing (Ctrl + i in XCode will do it automatically on the current or selected lines).",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64572235,2016-05-25T13:31:30Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):","My intention is to add them as individual keyword arguments rather than one `protocol_options` value.They're not here right now because this change is large enough without them, but this is where they will go.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64585409,2016-05-25T14:43:04Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):","I like `None` here because the semantics are ""maybe we will, maybe we won't, if you care either way pass it explicitly; we expect most callers not to care"", whereas a default value of `False` would promise a specific behavior in the user-didn't-pass-a-value case.Consistent with what?",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6327,64588806,2016-05-25T14:58:50Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):","Consistent with the treatment of default booleans in the API.  It looks like this is the only case where None is used as a default boolean value.If they try_to_connect behavior is easy to define, I would prefer a boolean, but if we have a bunch of internal conditions that determine the try_to_connect default behavior I agree `None` is the right default value.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64597120,2016-05-25T15:41:47Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):","Ah, okay. The difference between this site and the other boolean keyword parameters in the API is that not promising a specific default in those other places would render the calls harder to use (to the point of uselessness; one would need to program one's function call returning either one or two return values). Here the method still presents utility even if the default value of the extra parameter is ambiguous.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64634660,2016-05-25T19:12:05Z,src/objective-c/CronetFramework.podspec,"@@ -0,0 +1,138 @@+#+#  Be sure to run `pod spec lint cronet.podspec' to ensure this is a+#  valid spec and to remove all comments including this before submitting the spec.+#+#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html+#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/+#++Pod::Spec.new do |s|++  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #+  #+  #  These will help people to find your library, and whilst it+  #  can feel like a chore to fill in it's definitely to your advantage. The+  #  summary should be tweet-length, and the description more in depth.+  #++  s.name         = ""CronetFramework""+  s.version      = ""0.0.2""+  s.summary      = ""Cronet, precompiled and used as a framework.""++  # This description is used to generate tags and improve search results.+  #   * Think: What does it do? Why did you write it? What is the focus?+  #   * Try to keep it short, snappy and to the point.+  #   * Write the description between the DESC delimiters below.+  #   * Finally, don't worry about the indent, CocoaPods strips it!+  #s.description  = <<-DESC+  #                 DESC++  s.homepage     = ""http://chromium.org""+  # s.screenshots  = ""www.example.com/screenshots_1.gif"", ""www.example.com/screenshots_2.gif""+++  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #+  #+  #  Licensing your code is important. See http://choosealicense.com for more info.+  #  CocoaPods will detect a license file if there is a named LICENSE*+  #  Popular ones are 'MIT', 'BSD' and 'Apache License, Version 2.0'.+  #+  s.license      = { :type => 'BSD' }++  s.vendored_framework = ""Cronet.framework""+++  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #+  #+  #  Specify the authors of the library, with email addresses. Email addresses+  #  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also+  #  accepts just a name if you'd rather not provide an email address.+  #+  #  Specify a social_media_url where others can refer to, for example a twitter+  #  profile URL.+  #++  s.author             = """"","We can then just write here something like ""the Chromium authors"". It's supposed to let people know who maintains the library (not the podspec).",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6327,64642792,2016-05-25T20:00:20Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):","I'm with @kpayson64 on this. I'd maybe understand if the reasoning was that we wanted to collect feedback on how users most often specified `try_to_connect` and wanted to ensure that we had backwards compatibility (as far as documentation is concerned, not necessarily how developers used our code [because we could still break people who used our code improperly {ambiguous defaults make it easier for developers to use our code incorrectly}]), but this otherwise isn't jiving with my internalized dichotomy of reasonable defaults and explicit arguments.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64709005,2016-05-26T08:34:17Z,src/objective-c/GRPCClient/GRPCCall+Cronet.h,"@@ -39,8 +39,7 @@  */ @interface GRPCCall (Cronet) -+(void) setUseCronet:(BOOL) useCronet-                    :(cronet_engine *)cronet_engine;++(void)useCronet:(cronet_engine *)cronet_engine;","nit: `useCronetEngine:(cronet_engine *)engine;` or `useCronetWithEngine:(cronet_engine *)engine;`The [convention](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html) (which is important not only for usability, but also to play nicely with Swift) is to name each parameter before its colon, so that reading an invocation aloud makes grammatical sense.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64709353,2016-05-26T08:36:47Z,src/objective-c/GRPCClient/GRPCCall+Cronet.h,"@@ -39,8 +39,7 @@  */ @interface GRPCCall (Cronet) -+(void) setUseCronet:(BOOL) useCronet-                    :(cronet_engine *)cronet_engine;++(void)useCronet:(cronet_engine *)cronet_engine;  +(void *)getCronetEngine;","Method names that start with `get` have the specific convention of putting the return value in a pointer passed as a parameter. For the equivalent to Java getters, the naming convention is:`+(cronet_engine *)cronetEngine;`",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64711647,2016-05-26T08:54:51Z,src/objective-c/GRPCClient/GRPCCall+Cronet.m,"@@ -38,9 +38,8 @@  @implementation GRPCCall (Cronet) -+ (void)setUseCronet:(BOOL)useCronet-                    :(cronet_engine *)cronet_engine {-  use_cronet = useCronet;++ (void)useCronet:(cronet_engine *)cronet_engine {+  use_cronet = YES;   g_cronet_engine = cronet_engine;","nit: variables and method parameters should be named in camelCase, per [the style guide](https://google.github.io/styleguide/objcguide.xml?showone=Variable_Names#Variable_Names), and favor readability over shortness. So these should be `useCronet` and `globalCronetEngine`.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6586,64712050,2016-05-26T08:57:49Z,src/objective-c/GRPCClient/GRPCCall+Cronet.h,"@@ -39,8 +39,7 @@  */ @interface GRPCCall (Cronet) -+(void) setUseCronet:(BOOL) useCronet-                    :(cronet_engine *)cronet_engine;++(void)useCronet:(cronet_engine *)cronet_engine;","Document that the method isn't thread-safe, and should be called before starting RPCs. Add a sample invocation with starting Cronet and getting the singleton, and the doc will be perfect.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64942100,2016-05-27T17:44:29Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def disable_next_message_compression(self):+    """"""Disables compression of the next message passed by the application.""""""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self):+    """"""Accesses the terminal metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The terminal metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The integer status code of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self, terminal_metadata):+    """"""Accepts the terminal metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side terminal metadata to transmit.++    Args:+      terminal_metadata: The terminal metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""","Okay, wrapping this up: **I think we've heard quite loudly from our users that the `grpc` Python package is where they expect every developer-user-facing code element to be found**. I can think of two ways to go about satisfying that requirement:1. put everything in `grpc/__init__.py`, as is currently drafted, or2. spread code elements out reasonably into files like `_future.py`, `_multi_callables.py`, `_context.py`, and then alias them in `grpc/__init__.py`, being careful that the names by which they are officially known are the aliases in the `grpc` namespace and their having been defined in submodules is just an implementation artifact.I favor the first choice, but I could live with the second, because both deliver the desired developer-user experience of```>>> import grpc>>> help(grpc)>>> help(grpc.Future)>>> help(grpc.Channel)>>> help(grpc.insecure_channel)```. What's _not_ part of the developer-user experience that we need to deliver is ""the text of `grpc/__init__.py` has to be not too long"". Developer-users should be learning gRPC Python from [the documentation](http://www.grpc.io/grpc/python/) or maybe from the read-eval-print loop as above.The length of `grpc/__init__.py` is only a problem for us who maintain it and for power developer-users who want to change it. If it were an implementation module, I'd feel like it was on the long side, but since it's nearly all non-executable specification text I think it's just fine.Please insist on breaking it up if you feel strongly, otherwise have I persuaded you at all?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,64943580,2016-05-27T17:55:06Z,src/python/grpcio/grpc/__init__.py,"@@ -27,5 +27,760 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +""""""gRPC's Python API.""""""+ __import__('pkg_resources').declare_namespace(__name__) +import abc+import enum++import six++from grpc._cython import cygrpc as _cygrpc+++@enum.unique+class ChannelConnectivity(enum.Enum):+  """"""Mirrors grpc_connectivity_state in the gRPC Core.++  Attributes:+    IDLE: The channel is idle.+    CONNECTING: The channel is connecting.+    READY: The channel is ready to conduct RPCs.+    TRANSIENT_FAILURE: The channel has seen a failure from which it expects to+      recover.+    FATAL_FAILURE: The channel has seen a failure from which it cannot recover.+  """"""+  IDLE              = (_cygrpc.ConnectivityState.idle, 'idle')+  CONNECTING        = (_cygrpc.ConnectivityState.connecting, 'connecting')+  READY             = (_cygrpc.ConnectivityState.ready, 'ready')+  TRANSIENT_FAILURE = (+      _cygrpc.ConnectivityState.transient_failure, 'transient failure')+  FATAL_FAILURE     = (_cygrpc.ConnectivityState.fatal_failure, 'fatal failure')+++@enum.unique+class StatusCode(enum.Enum):+  """"""Mirrors grpc_status_code in the gRPC Core.""""""+  OK                  = (_cygrpc.StatusCode.ok, 'ok')+  CANCELLED           = (_cygrpc.StatusCode.cancelled, 'cancelled')+  UNKNOWN             = (_cygrpc.StatusCode.unknown, 'unknown')+  INVALID_ARGUMENT    = (+      _cygrpc.StatusCode.invalid_argument, 'invalid argument')+  DEADLINE_EXCEEDED   = (+      _cygrpc.StatusCode.deadline_exceeded, 'deadline exceeded')+  NOT_FOUND           = (_cygrpc.StatusCode.not_found, 'not found')+  ALREADY_EXISTS      = (_cygrpc.StatusCode.already_exists, 'already exists')+  PERMISSION_DENIED   = (+      _cygrpc.StatusCode.permission_denied, 'permission denied')+  RESOURCE_EXHAUSTED  = (+      _cygrpc.StatusCode.resource_exhausted, 'resource exhausted')+  FAILED_PRECONDITION = (+      _cygrpc.StatusCode.failed_precondition, 'failed precondition')+  ABORTED             = (_cygrpc.StatusCode.aborted, 'aborted')+  OUT_OF_RANGE        = (_cygrpc.StatusCode.out_of_range, 'out of range')+  UNIMPLEMENTED       = (_cygrpc.StatusCode.unimplemented, 'unimplemented')+  INTERNAL            = (_cygrpc.StatusCode.internal, 'internal')+  UNAVAILABLE         = (_cygrpc.StatusCode.unavailable, 'unavailable')+  DATA_LOSS           = (_cygrpc.StatusCode.data_loss, 'data loss')+  UNAUTHENTICATED     = (_cygrpc.StatusCode.unauthenticated, 'unauthenticated')+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      FutureTimeoutError: If a timeout value is passed and the computation does+        not terminate within the allotted time.+      FutureCancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""Raised by the gRPC library to indicate non-OK-status RPC termination.""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out, or None if no deadline was specified for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def trailing_metadata(self):+    """"""Accesses the trailing metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The trailing metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The StatusCode value for the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class UnaryStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-stream RPC.""""""++  @abc.abstractmethod+  def __call__(self, request, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request: The request value for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class StreamUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-unary RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(+      self, request_iterator, timeout=None, metadata=None, with_call=False):+    """"""Synchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.+      with_call: Whether or not to include return a Call for the RPC in addition+        to the response.++    Returns:+      The response value for the RPC, and a Call for the RPC if with_call was+        set to True at invocation.++    Raises:+      RpcError: Indicating that the RPC terminated with non-OK status. The+        raised RpcError will also be a Call for the RPC affording the RPC's+        metadata, status code, and details.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def future(self, request_iterator, timeout=None, metadata=None):+    """"""Asynchronously invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and a Future. In the event of+        RPC completion, the return Future's result value will be the response+        message of the RPC. Should the event terminate with non-OK status, the+        returned Future's exception value will be an RpcError.+    """"""+    raise NotImplementedError()+++class StreamStreamMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a stream-stream RPC in any call style.""""""++  @abc.abstractmethod+  def __call__(self, request_iterator, timeout=None, metadata=None):+    """"""Invokes the underlying RPC.++    Args:+      request_iterator: An iterator that yields request values for the RPC.+      timeout: An optional duration of time in seconds to allow for the RPC.+      metadata: An optional sequence of pairs of bytes to be transmitted to the+        service-side of the RPC.++    Returns:+      An object that is both a Call for the RPC and an iterator of response+        values. Drawing response values from the returned iterator may raise+        RpcError indicating termination of the RPC with non-OK status.+    """"""+    raise NotImplementedError()+++class Channel(six.with_metaclass(abc.ABCMeta)):+  """"""Affords RPC invocation via generic methods.""""""++  @abc.abstractmethod+  def subscribe(self, callback, try_to_connect=None):","Changed to a default value of `False`. I don't feel any differently, but if I couldn't persuade you two, perhaps this isn't the time and place to elevate the semantics of boolean-typed keyword parameter default values for the entire Pythonsphere.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6724,64968445,2016-05-27T21:25:30Z,src/python/grpcio/tests/unit/framework/common/test_control.py,"@@ -72,19 +73,31 @@ def control(self):       if self._fail:         raise Defect() -      while self._paused:+      while self._pause:+        self._paused = True+        self._condition.notify_all()         self._condition.wait()+      self._paused = False    @contextlib.contextmanager   def pause(self):     """"""Pauses code under control while controlling code is in context.""""""     with self._condition:-      self._paused = True+      self._pause = True     yield     with self._condition:","After reading `@contextlib.contextmanager`, what I said doesn't make sense...What I intended is something along these lines:```@contextlib.contextmanagerwith self._condition:  self._pause = Trueself._block_until_paused()yieldself._pause = Falseself._condition.notify_all()```Then anytime we have```with control.pause()  #Do some stuff```We know that control is actually paused without needing to call  `block_until_paused`  ",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6724,64970897,2016-05-27T21:49:39Z,src/python/grpcio/tests/unit/framework/common/test_control.py,"@@ -72,19 +73,31 @@ def control(self):       if self._fail:         raise Defect() -      while self._paused:+      while self._pause:+        self._paused = True+        self._condition.notify_all()         self._condition.wait()+      self._paused = False    @contextlib.contextmanager   def pause(self):     """"""Pauses code under control while controlling code is in context.""""""     with self._condition:-      self._paused = True+      self._pause = True     yield     with self._condition:","That would be really bad because the way this object is used is```with control.pause():  <set in motion the behavior under test that would lead to the system under test being paused>  <either call control.block_until_paused or don't>  <maybe do some other stuff>```. With the semantics you suggest, that code would have to be changed to```<set in motion the behavior under test that would lead to the system under test being paused>with control.pause():  <either call control.block_until_paused or don't>  <maybe do some other stuff>```and that would create a race condition in which the system under test could pass the control point (where it calls `control.control()`) _before_ the test system enters the `control.pause()` context.Concretely, look at the way this is used in expiration tests: we say that the service-side application should pause, then we invoke the RPC, then we chill out until we see the RPC time out, and then we leave the pause context and allow the service-side application to return from its RPC method handler. With the behavior you propose, the test would have to invoke the RPC before entering the pause context and the service-side application could finish servicing the RPC method before the test enters the pause context.Right?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6254,65017087,2016-05-30T01:55:49Z,src/python/grpcio/grpc/_cython/_cygrpc/credentials.pyx.pxi,"@@ -137,7 +137,7 @@ cdef void plugin_get_metadata(   cy_context.context = context   self.plugin_callback(cy_context, python_callback) -cdef void plugin_destroy_c_plugin_state(void *state):+cdef void plugin_destroy_c_plugin_state(void *state) with gil:",Sorry for the long round trip. What's up with the added GIL acquisition? Does the decref go boom without it? I could've sworn Cython was supposed to whine if acquiring the GIL was needed to avoid going boom.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6327,65167991,2016-05-31T11:58:09Z,src/python/grpcio/grpc/__init__.py,"@@ -27,4 +27,716 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. +"""""""""""" +import abc++import six+++class FutureTimeoutError(Exception):+  """"""Indicates that a method call on a Future timed out.""""""+++class FutureCancelledError(Exception):+  """"""Indicates that the computation underlying a Future was cancelled.""""""+++class Future(six.with_metaclass(abc.ABCMeta)):+  """"""A representation of a computation in another control flow.++  Computations represented by a Future may be yet to be begun, may be ongoing,+  or may have already completed.+  """"""++  @abc.abstractmethod+  def cancel(self):+    """"""Attempts to cancel the computation.++    This method does not block.++    Returns:+      True if the computation has not yet begun, will not be allowed to take+        place, and determination of both was possible without blocking. False+        under all other circumstances including but not limited to the+        computation's already having begun, the computation's already having+        finished, and the computation's having been scheduled for execution on a+        remote system for which a determination of whether or not it commenced+        before being cancelled cannot be made without blocking.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancelled(self):+    """"""Describes whether the computation was cancelled.++    This method does not block.++    Returns:+      True if the computation was cancelled any time before its result became+        immediately available. False under all other circumstances including but+        not limited to this object's cancel method not having been called and+        the computation's result having become immediately available.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def running(self):+    """"""Describes whether the computation is taking place.++    This method does not block.++    Returns:+      True if the computation is scheduled to take place in the future or is+        taking place now, or False if the computation took place in the past or+        was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def done(self):+    """"""Describes whether the computation has taken place.++    This method does not block.++    Returns:+      True if the computation is known to have either completed or have been+        unscheduled or interrupted. False if the computation may possibly be+        executing or scheduled to execute later.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def result(self, timeout=None):+    """"""Accesses the outcome of the computation or raises its exception.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        finish or be cancelled, or None if this method should block until the+        computation has finished or is cancelled no matter how long that takes.++    Returns:+      The return value of the computation.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+      Exception: If the computation raised an exception, this call will raise+        the same exception.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def exception(self, timeout=None):+    """"""Return the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The exception raised by the computation, or None if the computation did+        not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def traceback(self, timeout=None):+    """"""Access the traceback of the exception raised by the computation.++    This method may return immediately or may block.++    Args:+      timeout: The length of time in seconds to wait for the computation to+        terminate or be cancelled, or None if this method should block until+        the computation is terminated or is cancelled no matter how long that+        takes.++    Returns:+      The traceback of the exception raised by the computation, or None if the+        computation did not raise an exception.++    Raises:+      TimeoutError: If a timeout value is passed and the computation does not+        terminate within the allotted time.+      CancelledError: If the computation was cancelled.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def add_done_callback(self, fn):+    """"""Adds a function to be called at completion of the computation.++    The callback will be passed this Future object describing the outcome of+    the computation.++    If the computation has already completed, the callback will be called+    immediately.++    Args:+      fn: A callable taking a this Future object as its single parameter.+    """"""+    raise NotImplementedError()+++class RpcError(Exception):+  """"""""""""+++class RpcContext(six.with_metaclass(abc.ABCMeta)):+  """"""Provides RPC-related information and action.""""""++  @abc.abstractmethod+  def is_active(self):+    """"""Describes whether the RPC is active or has terminated.""""""+    raise NotImplementedError()++  @abc.abstractmethod+  def time_remaining(self):+    """"""Describes the length of allowed time remaining for the RPC.++    Returns:+      A nonnegative float indicating the length of allowed time in seconds+      remaining for the RPC to complete before it is considered to have timed+      out.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def cancel(self):+    """"""Cancels the RPC.++    Idempotent and has no effect if the RPC has already terminated.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def disable_next_message_compression(self):+    """"""Disables compression of the next message passed by the application.""""""+    raise NotImplementedError()+++class Call(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""Invocation-side utility object for an RPC.""""""++  @abc.abstractmethod+  def initial_metadata(self):+    """"""Accesses the initial metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The initial metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self):+    """"""Accesses the terminal metadata from the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The terminal metadata as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self):+    """"""Accesses the status code emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The integer status code of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self):+    """"""Accesses the details value emitted by the service-side of the RPC.++    This method blocks until the value is available.++    Returns:+      The bytes of the details of the RPC.+    """"""+    raise NotImplementedError()+++class ServicerContext(six.with_metaclass(abc.ABCMeta, RpcContext)):+  """"""A context object passed to method implementations.""""""++  @abc.abstractmethod+  def invocation_metadata(self):+    """"""Accesses the metadata from the invocation-side of the RPC.++    Returns:+      The invocation metadata object as a sequence of pairs of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def initial_metadata(self, initial_metadata):+    """"""Accepts the initial metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side initial metadata to transmit.++    Args:+      initial_metadata: The initial metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def terminal_metadata(self, terminal_metadata):+    """"""Accepts the terminal metadata value of the RPC.++    This method need not be called by method implementations if they have no+    service-side terminal metadata to transmit.++    Args:+      terminal_metadata: The terminal metadata of the RPC as a sequence of pairs+        of bytes.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def code(self, code):+    """"""Accepts the status code of the RPC.++    This method need not be called by method implementations if they wish the+    gRPC runtime to determine the status code of the RPC.++    Args:+      code: The integer status code of the RPC to be transmitted to the+        invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def details(self, details):+    """"""Accepts the service-side details of the RPC.++    This method need not be called by method implementations if they have no+    details to transmit.++    Args:+      details: The details bytes of the RPC to be transmitted to+        the invocation side of the RPC.+    """"""+    raise NotImplementedError()++  @abc.abstractmethod+  def peer(self):+    """"""Identifies the peer that invoked the RPC being serviced.++    Returns:+      A string identifying the peer that invoked the RPC being serviced.+    """"""+    raise NotImplementedError()+++class UnaryUnaryMultiCallable(six.with_metaclass(abc.ABCMeta)):+  """"""Affords invoking a unary-unary RPC.""""""","Strong personal distaste rooted in the belief that if a body of code is large enough to warrant breaking up it's better to break it up according to the language's mechanism of division (modules, in this case) rather than according to something not at all structural (like section comments).But I've gotten over it and added section comments. It's far more important that this move forward.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6725,65222025,2016-05-31T17:00:15Z,src/python/grpcio/tests/unit/_cython/_read_some_but_not_all_responses_test.py,"@@ -0,0 +1,251 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test a corner-case at the level of the Cython API.""""""++import threading+import unittest++from grpc._cython import cygrpc++_INFINITE_FUTURE = cygrpc.Timespec(float('+inf'))+_EMPTY_FLAGS = 0+_EMPTY_METADATA = cygrpc.Metadata(())+++class _ServerDriver(object):++  def __init__(self, completion_queue, shutdown_tag):+    self._condition = threading.Condition()+    self._completion_queue = completion_queue+    self._shutdown_tag = shutdown_tag+    self._events = []+    self._saw_shutdown_tag = False++  def start(self):+    def in_thread():+      while True:+        event = self._completion_queue.poll()+        with self._condition:+          self._events.append(event)+          self._condition.notify()+          if event.tag is self._shutdown_tag:+            self._saw_shutdown_tag = True+            break+    thread = threading.Thread(target=in_thread)+    thread.start()++  def done(self):+    with self._condition:+      return self._saw_shutdown_tag++  def first_event(self):+    with self._condition:+      while not self._events:+        self._condition.wait()+      return self._events[0]++  def events(self):+    with self._condition:+      while not self._saw_shutdown_tag:+        self._condition.wait()+      return tuple(self._events)+++class _QueueDriver(object):++  def __init__(self, condition, completion_queue, due):+    self._condition = condition+    self._completion_queue = completion_queue+    self._due = due+    self._events = []+    self._returned = False++  def start(self):+    def in_thread():+      while True:+        event = self._completion_queue.poll()+        with self._condition:+          self._events.append(event)+          self._due.remove(event.tag)+          self._condition.notify_all()+          if not self._due:+            self._returned = True+            return+    thread = threading.Thread(target=in_thread)+    thread.start()++  def done(self):+    with self._condition:+      return self._returned++  def event_with_tag(self, tag):+    with self._condition:+      while True:+        for event in self._events:+          if event.tag is tag:+            return event+        self._condition.wait()++  def events(self):+    with self._condition:+      while not self._returned:+        self._condition.wait()+      return tuple(self._events)+++class ReadSomeButNotAllResponsesTest(unittest.TestCase):++  def testReadSomeButNotAllResponses(self):+    server_completion_queue = cygrpc.CompletionQueue()+    server = cygrpc.Server()+    server.register_completion_queue(server_completion_queue)+    port = server.add_http2_port('[::]:0')+    server.start()+    channel = cygrpc.Channel('localhost:{}'.format(port))++    server_shutdown_tag = 'server_shutdown_tag'+    server_driver = _ServerDriver(server_completion_queue, server_shutdown_tag)+    server_driver.start()++    client_condition = threading.Condition()+    client_due = set()+    client_completion_queue = cygrpc.CompletionQueue()+    client_driver = _QueueDriver(+        client_condition, client_completion_queue, client_due)+    client_driver.start()++    server_call_condition = threading.Condition()+    server_send_initial_metadata_tag = 'server_send_initial_metadata_tag'+    server_send_first_message_tag = 'server_send_first_message_tag'+    server_send_second_message_tag = 'server_send_second_message_tag'+    server_complete_rpc_tag = 'server_complete_rpc_tag'+    server_call_due = set((+        server_send_initial_metadata_tag,+        server_send_first_message_tag,+        server_send_second_message_tag,+        server_complete_rpc_tag,+    ))+    server_call_completion_queue = cygrpc.CompletionQueue()+    server_call_driver = _QueueDriver(+        server_call_condition, server_call_completion_queue, server_call_due)+    server_call_driver.start()++    server_rpc_tag = 'server_rpc_tag'+    request_call_result = server.request_call(+        server_call_completion_queue, server_completion_queue, server_rpc_tag)++    client_call = channel.create_call(+        None, _EMPTY_FLAGS, client_completion_queue, b'/twinkies', None,+        _INFINITE_FUTURE)+    client_receive_initial_metadata_tag = 'client_receive_initial_metadata_tag'+    client_complete_rpc_tag = 'client_complete_rpc_tag'+    with client_condition:+      client_receive_initial_metadata_start_batch_result = (+          client_call.start_batch(cygrpc.Operations([+              cygrpc.operation_receive_initial_metadata(_EMPTY_FLAGS),+          ]), client_receive_initial_metadata_tag))+      client_due.add(client_receive_initial_metadata_tag)+      client_complete_rpc_start_batch_result = (+          client_call.start_batch(cygrpc.Operations([+              cygrpc.operation_send_initial_metadata(+                  _EMPTY_METADATA, _EMPTY_FLAGS),+              cygrpc.operation_send_close_from_client(_EMPTY_FLAGS),","I agree that if it were dropped the test would pass, but dropping it would alter the semantics of the test from ""client says here's one message and I'm done"" to ""client says here's one message and there may be more"". Not that it matters much in a ""here's a test I wrote let's check it in rather than deleting it"" scenario, but let's leave the `send_close_from_client` in place?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5521,65260044,2016-05-31T20:49:51Z,src/python/grpcio/grpc/_channel.py,"@@ -0,0 +1,683 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""""""""++import sys+import threading+import time++import grpc+from grpc import _common+from grpc._cython import cygrpc++_INFINITE_FUTURE = cygrpc.Timespec(float('+inf'))++_UNARY_UNARY_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.send_message,+    cygrpc.OperationType.send_close_from_client,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_message,+    cygrpc.OperationType.receive_status_on_client,+)+_UNARY_STREAM_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.send_message,+    cygrpc.OperationType.send_close_from_client,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_status_on_client,+)+_STREAM_UNARY_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_message,+    cygrpc.OperationType.receive_status_on_client,+)+_STREAM_STREAM_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_status_on_client,+)+++def _deadline(timeout):+  if timeout is None:+    return None, _INFINITE_FUTURE+  else:+    deadline = time.time() + timeout+    return deadline, cygrpc.Timespec(deadline)+++def _call_flags(disable_compression):+  if disable_compression:+    return cygrpc.WriteFlag.no_compress+  else:+    return 0+++def _unknown_code_details(unknown_cygrpc_code, details):+  return b'Server sent unknown code {} and details ""{}""'.format(+      unknown_cygrpc_code, details)+++def _wait_once_until(condition, until):+  if until is None:+    condition.wait()+  else:+    remaining = until - time.time()+    if remaining < 0:+      raise grpc.FutureTimeoutError()+    else:+      condition.wait(timeout=remaining)+++class _RPCState(object):++  def __init__(self, due, code, details):+    self.condition = threading.Condition()+    # The cygrpc.OperationType objects representing events due from the RPC's+    # completion queue.+    self.due = set(due)+    self.disable_next_compression = False+    self.initial_metadata = None+    self.response = None+    self.trailing_metadata = None+    self.code = code+    self.details = details+    # The semantics of grpc.Future.cancel and grpc.Future.cancelled are+    # slightly wonky, so they have to be tracked separately from the rest of the+    # result of the RPC. This field tracks whether cancellation was requested+    # prior to termination of the RPC.+    self.cancelled = False+    self.callbacks = []+++def _handle_event(event, state, response_deserializer):+  for batch_operation in event.batch_operations:+    operation_type = batch_operation.type+    state.due.remove(operation_type)+    if operation_type is cygrpc.OperationType.receive_initial_metadata:+      state.initial_metadata = batch_operation.received_metadata+    elif operation_type is cygrpc.OperationType.receive_message:+      serialized_response = batch_operation.received_message.bytes()+      if serialized_response is not None:+        response = _common.deserialize(+            serialized_response, response_deserializer)+        if response is None:+          state.code = grpc.StatusCode.INTERNAL+          state.details = b'Exception deserializing response!'+        else:+          state.response = response+    elif operation_type is cygrpc.OperationType.receive_status_on_client:+      state.trailing_metadata = batch_operation.received_metadata+      if state.code is None:+        code = _common.CYGRPC_STATUS_CODE_TO_STATUS_CODE.get(+            batch_operation.received_status_code)+        if code is None:+          state.code = grpc.StatusCode.UNKNOWN+          state.details = _unknown_code_details(+              batch_operation.received_status_code,+              batch_operation.received_status_details)+        else:+          state.code = code+          state.details = batch_operation.received_status_details+      for callback in state.callbacks:+        callback()+++def _event_handler(state, call, response_deserializer):+  def handle_event(event):+    with state.condition:+      _handle_event(event, state, response_deserializer)+      state.condition.notify_all()+      if state.due:+        return None+      else:+        return call+  return handle_event+++def _drain(state, completion_queue, response_deserializer):+  while state.due:+    event = completion_queue.poll()+    _handle_event(event, state, response_deserializer)+++def _consume_request_iterator(+    request_iterator, state, call, request_serializer):+  event_handler = _event_handler(state, call, None)+  def consume_request_iterator():+    for request in request_iterator:+      serialized_request = _common.serialize(request, request_serializer)+      with state.condition:+        if state.code is None:+          if serialized_request is None:+            call.cancel()+            state.code = grpc.StatusCode.INTERNAL+            state.details = b'Exception serializing request!'+            return+          else:+            operations = (cygrpc.operation_send_message(serialized_request),)+            call.start_batch(cygrpc.Operations(operations), event_handler)+            state.due.add(cygrpc.OperationType.send_message)+            while True:+              state.condition.wait()+              if state.code is None:+                if cygrpc.OperationType.send_message not in state.due:+                  break+              else:+                return+    with state.condition:+      if state.code is None:+        operations = (cygrpc.operation_send_close_from_client(),)+        call.start_batch(cygrpc.Operations(operations), event_handler)+        state.due.add(cygrpc.OperationType.send_close_from_client)+  thread = threading.Thread(target=consume_request_iterator)+  thread.start()+++class _Rendezvous(grpc.Future, grpc.Call, grpc.RpcError):","I still find this whole inheritance-instead-of-composition thing enormously confusing, but without statically typed attributes my personal reservations are kinda moot...",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/5521,65263925,2016-05-31T21:13:23Z,src/python/grpcio/grpc/_channel.py,"@@ -0,0 +1,683 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""""""""++import sys+import threading+import time++import grpc+from grpc import _common+from grpc._cython import cygrpc++_INFINITE_FUTURE = cygrpc.Timespec(float('+inf'))++_UNARY_UNARY_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.send_message,+    cygrpc.OperationType.send_close_from_client,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_message,+    cygrpc.OperationType.receive_status_on_client,+)+_UNARY_STREAM_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.send_message,+    cygrpc.OperationType.send_close_from_client,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_status_on_client,+)+_STREAM_UNARY_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_message,+    cygrpc.OperationType.receive_status_on_client,+)+_STREAM_STREAM_INITIAL_DUE = (+    cygrpc.OperationType.send_initial_metadata,+    cygrpc.OperationType.receive_initial_metadata,+    cygrpc.OperationType.receive_status_on_client,+)+++def _deadline(timeout):+  if timeout is None:+    return None, _INFINITE_FUTURE+  else:+    deadline = time.time() + timeout+    return deadline, cygrpc.Timespec(deadline)+++def _call_flags(disable_compression):+  if disable_compression:+    return cygrpc.WriteFlag.no_compress+  else:+    return 0+++def _unknown_code_details(unknown_cygrpc_code, details):+  return b'Server sent unknown code {} and details ""{}""'.format(+      unknown_cygrpc_code, details)+++def _wait_once_until(condition, until):+  if until is None:+    condition.wait()+  else:+    remaining = until - time.time()+    if remaining < 0:+      raise grpc.FutureTimeoutError()+    else:+      condition.wait(timeout=remaining)+++class _RPCState(object):++  def __init__(self, due, code, details):+    self.condition = threading.Condition()+    # The cygrpc.OperationType objects representing events due from the RPC's+    # completion queue.+    self.due = set(due)+    self.disable_next_compression = False+    self.initial_metadata = None+    self.response = None+    self.trailing_metadata = None+    self.code = code+    self.details = details+    # The semantics of grpc.Future.cancel and grpc.Future.cancelled are+    # slightly wonky, so they have to be tracked separately from the rest of the+    # result of the RPC. This field tracks whether cancellation was requested+    # prior to termination of the RPC.+    self.cancelled = False+    self.callbacks = []+++def _handle_event(event, state, response_deserializer):+  for batch_operation in event.batch_operations:+    operation_type = batch_operation.type+    state.due.remove(operation_type)+    if operation_type is cygrpc.OperationType.receive_initial_metadata:+      state.initial_metadata = batch_operation.received_metadata+    elif operation_type is cygrpc.OperationType.receive_message:+      serialized_response = batch_operation.received_message.bytes()+      if serialized_response is not None:+        response = _common.deserialize(+            serialized_response, response_deserializer)+        if response is None:+          state.code = grpc.StatusCode.INTERNAL+          state.details = b'Exception deserializing response!'+        else:+          state.response = response+    elif operation_type is cygrpc.OperationType.receive_status_on_client:+      state.trailing_metadata = batch_operation.received_metadata+      if state.code is None:+        code = _common.CYGRPC_STATUS_CODE_TO_STATUS_CODE.get(+            batch_operation.received_status_code)+        if code is None:+          state.code = grpc.StatusCode.UNKNOWN+          state.details = _unknown_code_details(+              batch_operation.received_status_code,+              batch_operation.received_status_details)+        else:+          state.code = code+          state.details = batch_operation.received_status_details+      for callback in state.callbacks:+        callback()+++def _event_handler(state, call, response_deserializer):+  def handle_event(event):+    with state.condition:+      _handle_event(event, state, response_deserializer)+      state.condition.notify_all()+      if state.due:+        return None+      else:+        return call+  return handle_event+++def _drain(state, completion_queue, response_deserializer):+  while state.due:+    event = completion_queue.poll()+    _handle_event(event, state, response_deserializer)+++def _consume_request_iterator(+    request_iterator, state, call, request_serializer):+  event_handler = _event_handler(state, call, None)+  def consume_request_iterator():+    for request in request_iterator:+      serialized_request = _common.serialize(request, request_serializer)+      with state.condition:+        if state.code is None:+          if serialized_request is None:+            call.cancel()+            state.code = grpc.StatusCode.INTERNAL+            state.details = b'Exception serializing request!'+            return+          else:+            operations = (cygrpc.operation_send_message(serialized_request),)+            call.start_batch(cygrpc.Operations(operations), event_handler)+            state.due.add(cygrpc.OperationType.send_message)+            while True:+              state.condition.wait()+              if state.code is None:+                if cygrpc.OperationType.send_message not in state.due:+                  break+              else:+                return+    with state.condition:+      if state.code is None:+        operations = (cygrpc.operation_send_close_from_client(),)+        call.start_batch(cygrpc.Operations(operations), event_handler)+        state.due.add(cygrpc.OperationType.send_close_from_client)+  thread = threading.Thread(target=consume_request_iterator)+  thread.start()+++class _Rendezvous(grpc.Future, grpc.Call, grpc.RpcError):",It threads a very narrow needle eye with the way it has one `cancel` method satisfying two different `cancel` specifications from two different interfaces with only coincidentally compatible semantics.I think I'd like to tease this class apart in the future.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6352,65630923,2016-06-02T22:36:20Z,src/core/lib/iomgr/error.h,"@@ -0,0 +1,143 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_LIB_IOMGR_ERROR_H+#define GRPC_CORE_LIB_IOMGR_ERROR_H++#include <stdbool.h>+#include <stdint.h>++#include <grpc/support/time.h>++// Opaque representation of an error.+// Errors are refcounted objects that represent the result of an operation.+// Ownership laws:+//  if a grpc_error is returned by a function, the caller owns a ref to that+//    instance+//  if a grpc_error is passed to a grpc_closure callback function (functions+//    with the signature:+//      void (*f)(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error))+//    then those functions do not automatically own a ref to error+//  if a grpc_error is passed to *ANY OTHER FUNCTION* then that function takes+//    ownership of the error+typedef struct grpc_error grpc_error;++typedef enum {+  GRPC_ERROR_INT_ERRNO,+  GRPC_ERROR_INT_FILE_LINE,+  GRPC_ERROR_INT_STATUS_CODE,+  GRPC_ERROR_INT_WARNING,+  GRPC_ERROR_INT_STREAM_ID,+  GRPC_ERROR_INT_GRPC_STATUS,+  GRPC_ERROR_INT_OFFSET,+  GRPC_ERROR_INT_INDEX,+  GRPC_ERROR_INT_SIZE,+  GRPC_ERROR_INT_HTTP2_ERROR,+  GRPC_ERROR_INT_TSI_CODE,+  GRPC_ERROR_INT_SECURITY_STATUS,+  GRPC_ERROR_INT_WSA_ERROR,+  GRPC_ERROR_INT_FD,+} grpc_error_ints;++typedef enum {+  GRPC_ERROR_STR_DESCRIPTION,+  GRPC_ERROR_STR_FILE,+  GRPC_ERROR_STR_OS_ERROR,+  GRPC_ERROR_STR_SYSCALL,+  GRPC_ERROR_STR_TARGET_ADDRESS,+  GRPC_ERROR_STR_GRPC_MESSAGE,+  GRPC_ERROR_STR_RAW_BYTES,+  GRPC_ERROR_STR_TSI_ERROR,+  GRPC_ERROR_STR_FILENAME,+} grpc_error_strs;++typedef enum {+  GRPC_ERROR_TIME_CREATED,+} grpc_error_times;++#define GRPC_ERROR_NONE ((grpc_error *)NULL)+#define GRPC_ERROR_OOM ((grpc_error *)1)+#define GRPC_ERROR_CANCELLED ((grpc_error *)2)++const char *grpc_error_string(grpc_error *error);+void grpc_error_free_string(const char *str);++grpc_error *grpc_error_create(const char *file, int line, const char *desc,+                              grpc_error **referencing, size_t num_referencing);+#define GRPC_ERROR_CREATE(desc) \+  grpc_error_create(__FILE__, __LINE__, desc, NULL, 0)++// Create an error that references some other errors. This function adds a+// reference to each error in errs - it does not consume an existing reference+#define GRPC_ERROR_CREATE_REFERENCING(desc, errs, count) \+  grpc_error_create(__FILE__, __LINE__, desc, errs, count)++//#define GRPC_ERROR_REFCOUNT_DEBUG+#ifdef GRPC_ERROR_REFCOUNT_DEBUG+grpc_error *grpc_error_ref(grpc_error *err, const char *file, int line,+                           const char *func);+void grpc_error_unref(grpc_error *err, const char *file, int line,+                      const char *func);+#define GRPC_ERROR_REF(err) grpc_error_ref(err, __FILE__, __LINE__, __func__)+#define GRPC_ERROR_UNREF(err) \+  grpc_error_unref(err, __FILE__, __LINE__, __func__)+#else+grpc_error *grpc_error_ref(grpc_error *err);+void grpc_error_unref(grpc_error *err);+#define GRPC_ERROR_REF(err) grpc_error_ref(err)+#define GRPC_ERROR_UNREF(err) grpc_error_unref(err)+#endif++grpc_error *grpc_error_set_int(grpc_error *src, grpc_error_ints which,+                               intptr_t value);+bool grpc_error_get_int(grpc_error *error, grpc_error_ints which, intptr_t *p);+grpc_error *grpc_error_set_time(grpc_error *src, grpc_error_times which,+                                gpr_timespec value);+grpc_error *grpc_error_set_str(grpc_error *src, grpc_error_strs which,+                               const char *value);+grpc_error *grpc_error_add_child(grpc_error *src, grpc_error *child);+grpc_error *grpc_os_error(const char *file, int line, int err,",Continuing with my pedantic streak :) What constitutes an OS error? Docs for this and other categories probably belong as field docs in the enum(s) above.,
9053690,zhangkun83,https://api.github.com/repos/grpc/grpc/pulls/6779,65751307,2016-06-03T18:08:08Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -31,6 +31,34 @@  *  */ +/** Round Robin Policy.+ *+ * This policy keeps:+ * - A circular list of ready (connected) subchannels, the+ *   *readylist*. An empty readylist consists solely of its root (dummy) node.+ * - A pointer to the last element picked from the readylist, the *lastpick*.+ *   Initially set to point to the readylist's root.+ *+ * Behavior:+ * - When a subchannel connects, it's *prepended* to the readylist's root node.+ *   Ie, if readylist = A <-> B <-> ROOT <-> C+ *                      ^                    ^+ *                      |____________________|+ *   and subchannel D becomes connected, the addition of D to the readylist+ *   results in  readylist = A <-> B <-> D <-> ROOT <-> C+ *                           ^                          ^+ *                           |__________________________|+ * - When a subchannel disconnects, it's removed from the readylist. If the+ *   subchannel being removed was the most recently picked, the *lastpick*+ *   pointer moves to the removed node's previous element. Note that if the+ *   readylist only had one element, this is still legal, as the lastpick would+ *   point to the dummy root node, for an empty readylist.+ * - Upon picking, *lastpick* is updated to point to the returned (connected)+ *   subchannel. Note that it possible that the selected subchannel becomes+ *   disconnected in the interim between the selection and the actual usage of+ *   the subchannel by the caller.","The actual round-robin list could repeat addresses, e.g., `A B C B C A A D`. If `A` is the first to be ready, do you add three `A`s to the readylist?What Java does is much simpler. It keeps the original list, and assigns each new RPC in the round-robin manner throughout the entire list, regardless whether the address is connected or not. If an address become connected, all RPCs that have been assigned to it will be sent. If an address errors out, the RPCs on it will fail.",
9053690,zhangkun83,https://api.github.com/repos/grpc/grpc/pulls/6779,65753036,2016-06-03T18:18:48Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -31,6 +31,34 @@  *  */ +/** Round Robin Policy.+ *+ * This policy keeps:+ * - A circular list of ready (connected) subchannels, the+ *   *readylist*. An empty readylist consists solely of its root (dummy) node.+ * - A pointer to the last element picked from the readylist, the *lastpick*.+ *   Initially set to point to the readylist's root.+ *+ * Behavior:+ * - When a subchannel connects, it's *prepended* to the readylist's root node.+ *   Ie, if readylist = A <-> B <-> ROOT <-> C+ *                      ^                    ^+ *                      |____________________|+ *   and subchannel D becomes connected, the addition of D to the readylist+ *   results in  readylist = A <-> B <-> D <-> ROOT <-> C+ *                           ^                          ^+ *                           |__________________________|+ * - When a subchannel disconnects, it's removed from the readylist. If the+ *   subchannel being removed was the most recently picked, the *lastpick*+ *   pointer moves to the removed node's previous element. Note that if the+ *   readylist only had one element, this is still legal, as the lastpick would+ *   point to the dummy root node, for an empty readylist.+ * - Upon picking, *lastpick* is updated to point to the returned (connected)+ *   subchannel. Note that it possible that the selected subchannel becomes+ *   disconnected in the interim between the selection and the actual usage of+ *   the subchannel by the caller.","That said, the current Java behavior doesn't work well if some server keeps failing. It's probably better to skip the failing servers in this case. But I do prefer round-robin on the original list instead of on a separately constructed one.",
10121772,iamqizhao,https://api.github.com/repos/grpc/grpc/pulls/6779,65755025,2016-06-03T18:31:24Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -31,6 +31,34 @@  *  */ +/** Round Robin Policy.+ *+ * This policy keeps:+ * - A circular list of ready (connected) subchannels, the+ *   *readylist*. An empty readylist consists solely of its root (dummy) node.+ * - A pointer to the last element picked from the readylist, the *lastpick*.+ *   Initially set to point to the readylist's root.+ *+ * Behavior:+ * - When a subchannel connects, it's *prepended* to the readylist's root node.+ *   Ie, if readylist = A <-> B <-> ROOT <-> C+ *                      ^                    ^+ *                      |____________________|+ *   and subchannel D becomes connected, the addition of D to the readylist+ *   results in  readylist = A <-> B <-> D <-> ROOT <-> C+ *                           ^                          ^+ *                           |__________________________|+ * - When a subchannel disconnects, it's removed from the readylist. If the+ *   subchannel being removed was the most recently picked, the *lastpick*+ *   pointer moves to the removed node's previous element. Note that if the+ *   readylist only had one element, this is still legal, as the lastpick would+ *   point to the dummy root node, for an empty readylist.+ * - Upon picking, *lastpick* is updated to point to the returned (connected)+ *   subchannel. Note that it possible that the selected subchannel becomes+ *   disconnected in the interim between the selection and the actual usage of+ *   the subchannel by the caller.","@zhangkun83 round-robin on the original list is not hard to achieve. We can add an ""connected/not connected"" boolean to each address and then iterate on the original list but skip the one which is not connected. Anyways, this is implementation detail and may be different in different languages.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6704,65772885,2016-06-03T20:46:57Z,test/distrib/cpp/run_distrib_test.sh,"@@ -0,0 +1,52 @@+#!/bin/bash+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++set -ex++git clone https://github.com/grpc/grpc.git","if you run this e.g. on the release branch, it still runs the distrib tests on upstream/master. We need to clone the repo for outside of the docker container.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6786,65781390,2016-06-03T21:53:50Z,src/core/lib/transport/metadata.c,"@@ -504,7 +507,8 @@ static void grow_mdtab(mdtab_shard *shard) { }  static void rehash_mdtab(mdtab_shard *shard) {-  if (shard->free > shard->capacity / 4) {+  if ((size_t)gpr_atm_no_barrier_load(&shard->free_estimate) >","I agree with @dklempner . I guess ssize_t is what this belongs as.... I don't believe that this problem will ever arise on a platform with L-L ordering, but could happen on a true RMO platform.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6779,65786584,2016-06-03T22:47:54Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -31,6 +31,34 @@  *  */ +/** Round Robin Policy.+ *+ * This policy keeps:+ * - A circular list of ready (connected) subchannels, the+ *   *readylist*. An empty readylist consists solely of its root (dummy) node.+ * - A pointer to the last element picked from the readylist, the *lastpick*.+ *   Initially set to point to the readylist's root.+ *+ * Behavior:+ * - When a subchannel connects, it's *prepended* to the readylist's root node.+ *   Ie, if readylist = A <-> B <-> ROOT <-> C+ *                      ^                    ^+ *                      |____________________|+ *   and subchannel D becomes connected, the addition of D to the readylist+ *   results in  readylist = A <-> B <-> D <-> ROOT <-> C+ *                           ^                          ^+ *                           |__________________________|+ * - When a subchannel disconnects, it's removed from the readylist. If the+ *   subchannel being removed was the most recently picked, the *lastpick*+ *   pointer moves to the removed node's previous element. Note that if the+ *   readylist only had one element, this is still legal, as the lastpick would+ *   point to the dummy root node, for an empty readylist.+ * - Upon picking, *lastpick* is updated to point to the returned (connected)+ *   subchannel. Note that it possible that the selected subchannel becomes+ *   disconnected in the interim between the selection and the actual usage of+ *   the subchannel by the caller.","For the record, this implementation doesn't differentiate repeated addresses: [A, B, A] is a regular three element list (same as, say, [X, Y, Z]) and A will be returned twice as often as B, on average.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6791,65807797,2016-06-04T21:19:33Z,tools/distrib/python/grpcio_tools/grpc/__init__.py,"@@ -1,4 +1,4 @@-# Copyright 2016, Google Inc.+# Copyright 2015-2016, Google Inc.",Am I reading this right that you're copying most of gRPC Python's library code into tools/distrib/python/grpcio_tools/grpc? Huh? What's up with that?,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6791,65808025,2016-06-04T21:42:29Z,tools/distrib/python/grpcio_tools/grpc/__init__.py,"@@ -1,4 +1,4 @@-# Copyright 2016, Google Inc.+# Copyright 2015-2016, Google Inc.","Just the top level files due to namespace package issues that percolate out of us wanting to use auditwheel for our manylinux1 wheels. There might be a magic combination of actions that make user-installing and us testing work simultaneously, but I haven't dug too deep into that. As this is dirty dirty dirty, I prolly' should.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6787,65828664,2016-06-06T00:52:41Z,src/python/grpcio/grpc/_server.py,"@@ -65,12 +65,23 @@ def _serialized_request(request_event):   return request_event.batch_operations[0].received_message.bytes()  -def _code(state):",Good question!Short answer: the former.Long answer: these changes make safe service-side application code that fails not by raising an exception but by merely returning an invalid value (like None). Putting the fix in `_server.py` means that the fix applies to such illegitimate code written against both APIs.,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6794,65955652,2016-06-06T19:47:28Z,src/csharp/Grpc.Core/AsyncDuplexStreamingCall.cs,"@@ -117,6 +117,10 @@ public Metadata GetTrailers()         /// Otherwise, requests cancellation of the call which should terminate all pending async operations associated with the call.         /// As a result, all resources being used by the call should be released eventually.         /// </summary>+        /// <remarks>+        /// Normally, there is no need for you to dispose the call unless you want to utilize the+        /// ""Cancel"" semantics of invoking <c>Dispose</c>.+        /// </remarks>         public void Dispose()","If I'm understanding this correctly, dispose just wraps `call.cancel()`.I'm not sure that the added remarks add any clarity to what this method does, it seems pretty clear from the summary.I think the confusion stems not from a lack of documentation, but rather c# idioms.It seems like the .NET community leans towards calling Dispose on any object that implements IDisosable, but there isn't quite a consensus.My personal opinion is that you should just expose a `Cancel()` method.  I've seen suggestions where `Dispose()` should be wrapped with domain-specific method names: https://msdn.microsoft.com/en-us/library/b1yfkh5e(v=vs.100).aspx",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6610,65980849,2016-06-06T22:25:03Z,src/core/ext/transport/chttp2/server/insecure/server_chttp2_posix.c,"@@ -57,7 +60,8 @@ void grpc_server_add_insecure_channel_from_fd(grpc_server *server, int fd) {   const grpc_channel_args *server_args = grpc_server_get_channel_args(server);   grpc_transport *transport = grpc_create_chttp2_transport(       &exec_ctx, server_args, server_endpoint, 0 /* is_client */);-  grpc_server_setup_transport(&exec_ctx, server, transport, server_args);+  grpc_endpoint_add_to_pollset(&exec_ctx, server_endpoint, grpc_cq_pollset(cq));","I think you can drop the extra parameter, and just pass through NULL here for the pollset without any problem.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6803,65982457,2016-06-06T22:38:31Z,src/core/lib/iomgr/ev_epoll_linux.c,"@@ -0,0 +1,1391 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>++#ifdef GPR_POSIX_SOCKET++#include ""src/core/lib/iomgr/ev_epoll_linux.h""++#include <assert.h>+#include <errno.h>+#include <poll.h>+#include <signal.h>+#include <string.h>+#include <sys/epoll.h>+#include <sys/socket.h>+#include <unistd.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>+#include <grpc/support/tls.h>+#include <grpc/support/useful.h>++#include ""src/core/lib/iomgr/ev_posix.h""+#include ""src/core/lib/iomgr/iomgr_internal.h""+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""+#include ""src/core/lib/profiling/timers.h""+#include ""src/core/lib/support/block_annotate.h""++struct polling_island;++/*******************************************************************************+ * Fd Declarations+ */+struct grpc_fd {+  int fd;+  /* refst format:+       bit 0    : 1=Active / 0=Orphaned+       bits 1-n : refcount+     Ref/Unref by two to avoid altering the orphaned bit */+  gpr_atm refst;++  gpr_mu mu;++  /* Indicates that the fd is shutdown and that any pending read/write closures+     should fail */+  bool shutdown;++  /* The fd is either closed or we relinquished control of it. In either cases,+     this indicates that the 'fd' on this structure is no longer valid */+  bool orphaned;++  grpc_closure *read_closure;+  grpc_closure *write_closure;","Without a watch list needing to be maintained (like in the poll() implementation), there's a mostly lockfree implementation of the read/write_closure code that's available.We don't need to do so now, but a TODO at least to switch to it would be worthwhile.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6826,66190615,2016-06-08T04:23:35Z,src/objective-c/ProtoRPC/ProtoMethod.h,"@@ -48,3 +49,11 @@                         service:(NSString *)service                          method:(NSString *)method; @end++/**+ * This subclass is empty now. Eventually we'll remove ProtoService class+ * to avoid potential naming conflict",nit: remove `the` ProtoService class [...] conflict`s.`Same in the docs of the other two.,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6732,66275094,2016-06-08T15:12:40Z,test/cpp/qps/driver.cc,"@@ -341,6 +342,16 @@ std::unique_ptr<ScenarioResult> RunScenario(       }     } +    // Reduce channel count so that total channels specified is held regardless+    // of the number of clients available+    size_t num_channels =+        (i == num_clients - 1)+            ? client_config.client_channels() - channels_allocated+            : client_config.client_channels() / num_clients;","But if this is important, let it be client_channels/(num_clients - i) to avoid bad imbalance.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6791,66343909,2016-06-08T21:30:17Z,src/python/grpcio_tests/commands.py,"@@ -0,0 +1,217 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Provides distutils command classes for the gRPC Python setup process.""""""++import distutils+import glob+import os+import os.path+import platform+import re+import shutil+import subprocess+import sys+import traceback++import setuptools+from setuptools.command import build_ext+from setuptools.command import build_py+from setuptools.command import easy_install+from setuptools.command import install+from setuptools.command import test++PYTHON_STEM = os.path.dirname(os.path.abspath(__file__))+GRPC_STEM = os.path.abspath(PYTHON_STEM + '../../../../')+GRPC_PROTO_STEM = os.path.join(GRPC_STEM, 'src', 'proto')+PROTO_STEM = os.path.join(PYTHON_STEM, 'src', 'proto')+PYTHON_PROTO_TOP_LEVEL = os.path.join(PYTHON_STEM, 'src')+++class CommandError(object):+  pass+++class GatherProto(setuptools.Command):++  description = 'gather proto dependencies'+  user_options = []++  def initialize_options(self):+    pass++  def finalize_options(self):+    pass++  def run(self):+    # TODO(atash) ensure that we're running from the repository directory when+    # this command is used+    try:+      shutil.rmtree(PROTO_STEM)+    except Exception as error:+      # We don't care if this command fails+      pass+    shutil.copytree(GRPC_PROTO_STEM, PROTO_STEM)+    for root, _, _ in os.walk(PYTHON_PROTO_TOP_LEVEL):+      path = os.path.join(root, '__init__.py')+      open(path, 'a').close()+++class BuildProtoModules(setuptools.Command):+  """"""Command to generate project *_pb2.py modules from proto files.""""""++  description = 'build protobuf modules'+  user_options = [+    ('include=', None, 'path patterns to include in protobuf generation'),+    ('exclude=', None, 'path patterns to exclude from protobuf generation')+  ]++  def initialize_options(self):+    self.exclude = None+    self.include = r'.*\.proto$'++  def finalize_options(self):+    pass++  def run(self):+    import grpc.tools.protoc as protoc++    include_regex = re.compile(self.include)+    exclude_regex = re.compile(self.exclude) if self.exclude else None+    paths = []+    for walk_root, directories, filenames in os.walk(PROTO_STEM):+      for filename in filenames:+        path = os.path.join(walk_root, filename)+        if include_regex.match(path) and not (+            exclude_regex and exclude_regex.match(path)):+          paths.append(path)++    # TODO(kpayson): It would be nice to do this in a batch command,+    # but we currently have name conflicts in src/proto+    for path in paths:+      command = [+          'grpc.tools.protoc',+          '-I {}'.format(PROTO_STEM),+          '--python_out={}'.format(PROTO_STEM),+          '--grpc_python_out={}'.format(PROTO_STEM),+      ] + [path]+      if protoc.main(command) != 0:","This feels like we are cheating a bit... I'd feel more confident about our setup installation if we were to run it as a bash command like the user is expected to, I'm guessing something along the lines of `python -m grpc.tools.protoc <args>`",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6791,66345257,2016-06-08T21:39:00Z,src/python/grpcio_tests/tests/protoc_plugin/beta_python_plugin_test.py,"@@ -245,63 +250,13 @@ class PythonPluginTest(unittest.TestCase):   """"""    def setUp(self):-    # Assume that the appropriate protoc and grpc_python_plugins are on the-    # path.-    protoc_command = 'protoc'-    protoc_plugin_filename = distutils.spawn.find_executable(-        'grpc_python_plugin')-    if not os.path.isfile(protoc_command):-      # Assume that if we haven't built protoc that it's on the system.-      protoc_command = 'protoc'--    # Ensure that the output directory exists.-    self.outdir = tempfile.mkdtemp()--    # Find all proto files-    paths = []-    root_dir = os.path.dirname(os.path.realpath(__file__))-    proto_dir = os.path.join(root_dir, 'protos')-    for walk_root, _, filenames in os.walk(proto_dir):-      for filename in filenames:-        if filename.endswith('.proto'):-          path = os.path.join(walk_root, filename)-          paths.append(path)--    # Invoke protoc with the plugin.-    cmd = [-        protoc_command,-        '--plugin=protoc-gen-python-grpc=%s' % protoc_plugin_filename,-        '-I %s' % root_dir,-        '--python_out=%s' % self.outdir,-        '--python-grpc_out=%s' % self.outdir-    ] + paths-    subprocess.check_call(' '.join(cmd), shell=True, env=os.environ,-                          cwd=os.path.dirname(os.path.realpath(__file__)))--    # Generated proto directories dont include __init__.py, but-    # these are needed for python package resolution-    for walk_root, _, _ in os.walk(os.path.join(self.outdir, 'protos')):-      path = os.path.join(walk_root, '__init__.py')-      open(path, 'a').close()--    sys.path.insert(0, self.outdir)--    import protos.payload.test_payload_pb2 as payload_pb2  # pylint: disable=g-import-not-at-top-    import protos.requests.r.test_requests_pb2 as request_pb2  # pylint: disable=g-import-not-at-top-    import protos.responses.test_responses_pb2 as response_pb2  # pylint: disable=g-import-not-at-top-    import protos.service.test_service_pb2 as service_pb2  # pylint: disable=g-import-not-at-top     self._payload_pb2 = payload_pb2","This was a nasty hack to build the protos as part of the test.  If we are no longer doing that, we might as well do imports as intended ie self._payload_pb2 -> payload_pb2 throughout the file.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/6839,66346820,2016-06-08T21:49:04Z,doc/interop-test-descriptions.md,"@@ -90,11 +90,11 @@ Client asserts: * clients are free to assert that the response payload body contents are zero   and comparing the entire response message against a golden response -### large_compressed_unary+### server_compressed_unary -This test verifies compressed unary calls succeed in sending messages. It-sends one unary request for every payload type, with and without requesting a-compressed response from the server.+This test verifies compressed server-only unary calls succeed in sending+messages. It sends one unary request for every payload type, with and without",It no longer requests an UNCOMPRESSABLE payload.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6791,66347765,2016-06-08T21:54:31Z,src/python/grpcio_tests/commands.py,"@@ -0,0 +1,217 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Provides distutils command classes for the gRPC Python setup process.""""""++import distutils+import glob+import os+import os.path+import platform+import re+import shutil+import subprocess+import sys+import traceback++import setuptools+from setuptools.command import build_ext+from setuptools.command import build_py+from setuptools.command import easy_install+from setuptools.command import install+from setuptools.command import test++PYTHON_STEM = os.path.dirname(os.path.abspath(__file__))+GRPC_STEM = os.path.abspath(PYTHON_STEM + '../../../../')+GRPC_PROTO_STEM = os.path.join(GRPC_STEM, 'src', 'proto')+PROTO_STEM = os.path.join(PYTHON_STEM, 'src', 'proto')+PYTHON_PROTO_TOP_LEVEL = os.path.join(PYTHON_STEM, 'src')+++class CommandError(object):+  pass+++class GatherProto(setuptools.Command):++  description = 'gather proto dependencies'+  user_options = []++  def initialize_options(self):+    pass++  def finalize_options(self):+    pass++  def run(self):+    # TODO(atash) ensure that we're running from the repository directory when+    # this command is used+    try:+      shutil.rmtree(PROTO_STEM)+    except Exception as error:+      # We don't care if this command fails+      pass+    shutil.copytree(GRPC_PROTO_STEM, PROTO_STEM)+    for root, _, _ in os.walk(PYTHON_PROTO_TOP_LEVEL):+      path = os.path.join(root, '__init__.py')+      open(path, 'a').close()+++class BuildProtoModules(setuptools.Command):+  """"""Command to generate project *_pb2.py modules from proto files.""""""++  description = 'build protobuf modules'+  user_options = [+    ('include=', None, 'path patterns to include in protobuf generation'),+    ('exclude=', None, 'path patterns to exclude from protobuf generation')+  ]++  def initialize_options(self):+    self.exclude = None+    self.include = r'.*\.proto$'++  def finalize_options(self):+    pass++  def run(self):+    import grpc.tools.protoc as protoc++    include_regex = re.compile(self.include)+    exclude_regex = re.compile(self.exclude) if self.exclude else None+    paths = []+    for walk_root, directories, filenames in os.walk(PROTO_STEM):+      for filename in filenames:+        path = os.path.join(walk_root, filename)+        if include_regex.match(path) and not (+            exclude_regex and exclude_regex.match(path)):+          paths.append(path)++    # TODO(kpayson): It would be nice to do this in a batch command,+    # but we currently have name conflicts in src/proto+    for path in paths:+      command = [+          'grpc.tools.protoc',+          '-I {}'.format(PROTO_STEM),+          '--python_out={}'.format(PROTO_STEM),+          '--grpc_python_out={}'.format(PROTO_STEM),+      ] + [path]+      if protoc.main(command) != 0:","Hard nix: depending on `bash` or any other tools being present and behaving like they ought to is a bad idea, e.g. it wouldn't work on Windows outside of an MSYS/Cygwin/Git-bash environment",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6764,66376373,2016-06-09T03:03:48Z,src/python/grpcio/grpc/_adapter/_low.py,"@@ -170,10 +170,14 @@ def set_credentials(self, creds): class Channel(_types.Channel):    def __init__(self, target, args, creds=None):-    args = list(args) + [-        (cygrpc.ChannelArgKey.primary_user_agent_string, _USER_AGENT)]+    args = dict(args)",@ctiller: is it guaranteed that duplicated channel argument keys will never be useful (e.g. channel arguments are never a multimap)?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6764,66379612,2016-06-09T04:00:13Z,src/python/grpcio/grpc/_adapter/_low.py,"@@ -170,10 +170,14 @@ def set_credentials(self, creds): class Channel(_types.Channel):    def __init__(self, target, args, creds=None):-    args = list(args) + [-        (cygrpc.ChannelArgKey.primary_user_agent_string, _USER_AGENT)]+    args = dict(args)","Actually the opposite... at least the user agent strings are alreadyallowed to be repeated. There might be more.On Wed, Jun 8, 2016 at 8:04 PM Masood Malekghassemi <notifications@github.com> wrote:> In src/python/grpcio/grpc/_adapter/_low.py> https://github.com/grpc/grpc/pull/6764#discussion_r66376373:> > > @@ -170,10 +170,14 @@ def set_credentials(self, creds):> >  class Channel(_types.Channel):> > > >    def **init**(self, target, args, creds=None):> > -    args = list(args) + [> > -        (cygrpc.ChannelArgKey.primary_user_agent_string, _USER_AGENT)]> > -    args = dict(args)> > @ctiller https://github.com/ctiller: is it guaranteed that duplicated> channel argument keys will never be useful (e.g. channel arguments are> never a multimap)?> > —> You are receiving this because you were mentioned.> > Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/6764/files/bf4776a7b61be4eeda73805098a8011131f7557a#r66376373,> or mute the thread> https://github.com/notifications/unsubscribe/AJpudW4y5DFCpnyRrUiAJ3y64vfoReAqks5qJ4KlgaJpZM4Is9r2> .",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6839,66541755,2016-06-09T23:49:32Z,doc/interop-test-descriptions.md,"@@ -887,6 +943,19 @@ payload body of size `SimpleRequest.response_size` bytes and type as appropriate for the `SimpleRequest.response_type`. If the server does not support the `response_type`, then it should fail the RPC with `INVALID_ARGUMENT`. +### CompressedResponse+[CompressedResponse]: #compressedresponse++When the client sets `SimpleRequest.request_compressed_response` to true, the+response is sent back compressed.++### CompressedRequest","This seems error prone. If you take an server that doesn't implement this and run the client_compressed_unary against it, it will succeed so you the only way to check that the interop tests actually do what they are supposed to is to manually check the serverside code - and that's bad. Can we redefine the behavior so that you can tell servers that recognize expect_compressed_request from the ones that do not?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6839,66542544,2016-06-09T23:57:54Z,doc/interop-test-descriptions.md,"@@ -130,11 +138,39 @@ Procedure:       zero and comparing the entire response message against a golden response  - 2. Client calls UnaryCall with:+### server_compressed_unary++This test verifies the server can compress unary messages. It sends two unary+requests for a COMPRESSABLE payload type, expecting the server response to be+compressed or not according to the `request_compressed_response` boolean.++Whether compression was actually performed is determined by the compression bit+in the response's message flags.+++Server features:+* [UnaryCall][]+* [Compressable Payload][]+* [Compressed Response][]++Procedure:+ 1. Client calls UnaryCall with:+     ```     {-      request_compressed_response: bool-      response_type: UNCOMPRESSABLE+      request_compressed_response: true","naming:  `response_size` means   send me a response of given size.  With that logic, `request_compressed_response` should be   just `response_compressed`. The ""request_"" prefix is extraneous. ",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6503,66560082,2016-06-10T04:22:07Z,src/python/grpcio/grpc/_channel.py,"@@ -85,7 +85,7 @@ def _deadline(timeout):   def _unknown_code_details(unknown_cygrpc_code, details):-  return b'Server sent unknown code {} and details ""{}""'.format(+  return 'Server sent unknown code {} and details ""{}""'.format(",I guess the question also applies to all such similar changes in the remainder of this file.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6503,66560627,2016-06-10T04:33:14Z,src/python/grpcio/grpc/beta/_server_adaptations.py,"@@ -292,31 +293,40 @@ class _GenericRpcHandler(grpc.GenericRpcHandler):   def __init__(       self, method_implementations, multi_method_implementation,       request_deserializers, response_serializers):-    self._method_implementations = method_implementations+    self._method_implementations = {}+    for method_pair in method_implementations:+      method = _common.fully_qualified_method(method_pair[0], method_pair[1])+      self._method_implementations[method] = (+          method_implementations[method_pair])+    self._request_deserializers = {}+    request_deserializers = request_deserializers or {}+    for method_pair in request_deserializers:+      method = _common.fully_qualified_method(method_pair[0], method_pair[1])+      self._request_deserializers[method] = (+          request_deserializers[method_pair])+    self._response_serializers = {}+    response_serializers = response_serializers or {}+    for method_pair in response_serializers:+      method = _common.fully_qualified_method(method_pair[0], method_pair[1])+      self._response_serializers[method] = (+          response_serializers[method_pair])","Some part of me wishes that Python included some additional standard utility function to remap dictionary keys (like in `itertools`, or something...), but, I guess I don't feel too strongly about us writing one and using it to reduce the code duplication here (and I guess it'd just end up looking a lot like a dictionary-comprehension/generator anyway). Just a thought.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6857,66688921,2016-06-10T22:19:58Z,src/python/grpcio/grpc/_common.py,"@@ -97,3 +98,27 @@ def serialize(message, serializer): def deserialize(serialized_message, deserializer):   return _transform(serialized_message, deserializer,                     'Exception deserializing message!')+++class CleanupThread(threading.Thread):+  """"""A wrapper around thread for custom join behavior.+  +  On Interpreter exit, Python will attempt to join outstanding threads+  prior to garbage collection.  We may need to do additional cleanup, and+  we acomplish this by wrapping the join() method.+  """"""+  +  def __init__(self, group=None, target=None, join_target=None, name=None,+               args=(), join_args=(), kwargs={}, join_kwargs={}):+    """"""join_target() will be called with a timeout,","Nearly without exception the doc string of an `__init__` method should be```Constructor.Attributes:  <attribute names and descriptions>```. No work of any consequence should be done in a constructor, and thus there should be nothing to say about it except to describe its parameters. See [the style guide](https://google.github.io/styleguide/pyguide.html) for [examples](https://google.github.io/styleguide/pyguide.html?showone=Comments#Comments).",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6857,66689080,2016-06-10T22:21:52Z,src/python/grpcio/grpc/_common.py,"@@ -97,3 +98,27 @@ def serialize(message, serializer): def deserialize(serialized_message, deserializer):   return _transform(serialized_message, deserializer,                     'Exception deserializing message!')+++class CleanupThread(threading.Thread):+  """"""A wrapper around thread for custom join behavior.+  +  On Interpreter exit, Python will attempt to join outstanding threads+  prior to garbage collection.  We may need to do additional cleanup, and+  we acomplish this by wrapping the join() method.+  """"""+  +  def __init__(self, group=None, target=None, join_target=None, name=None,","The behavior to be called at join-time should be a required (and non-`None`) construction parameter because if it's ever `None` this class has no point in being used at that particular use-site.Also I recommend just taking a single no-arg parameter (call it ""behavior""?) and leave it to use-sites to wrap their args and kwargs in a `lambda` or custom function.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6857,66689200,2016-06-10T22:22:54Z,src/python/grpcio/grpc/_common.py,"@@ -97,3 +98,27 @@ def serialize(message, serializer): def deserialize(serialized_message, deserializer):   return _transform(serialized_message, deserializer,                     'Exception deserializing message!')+++class CleanupThread(threading.Thread):+  """"""A wrapper around thread for custom join behavior.","""wrapper around"" sounds too much like delegation; what we're doing here is inheritance. How about ""A threading.Thread subclass supporting custom behavior at join-time.""?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6857,66689379,2016-06-10T22:24:47Z,src/python/grpcio/grpc/_common.py,"@@ -97,3 +98,27 @@ def serialize(message, serializer): def deserialize(serialized_message, deserializer):   return _transform(serialized_message, deserializer,                     'Exception deserializing message!')+++class CleanupThread(threading.Thread):+  """"""A wrapper around thread for custom join behavior.+  +  On Interpreter exit, Python will attempt to join outstanding threads+  prior to garbage collection.  We may need to do additional cleanup, and+  we acomplish this by wrapping the join() method.+  """"""+  +  def __init__(self, group=None, target=None, join_target=None, name=None,+               args=(), join_args=(), kwargs={}, join_kwargs={}):+    """"""join_target() will be called with a timeout,+    followed by join_args then join_kwargs.""""""+    super(CleanupThread, self).__init__(group=group, target=target, +                                     name=name, args=args, kwargs=kwargs)+    self._join_target = join_target+    self._join_args = join_args+    self._join_kwargs = join_kwargs++  def join(self, timeout=None):+    if self._join_target:+      self._join_target(timeout, *self._join_args, **self._join_kwargs)","A thread may be `join`ed multiple times. Must the `_join_target` be idempotent, or should this class take additional measures to ensure that the `_join_target` is only called once?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6857,66689668,2016-06-10T22:28:25Z,src/python/grpcio/grpc/_server.py,"@@ -719,6 +708,26 @@ def cancel_all_calls_after_grace():   return shutdown_event  +def _join_server_thread(timeout, state):+  if not timeout:+    _stop(state, 2.0).wait()","Magic number. To best emulate ""wait as long as it takes"", shouldn't the value passed here be astronomically high (and, sadly, an equally magic number)?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6547,66694755,2016-06-10T23:38:28Z,src/python/grpcio/tests/unit/_empty_request_test.py,"@@ -0,0 +1,137 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import unittest++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants++_STREAM_COUNT = 1000+_TIMEOUT = 1000+_REQUEST = b''+_RESPONSE = b''++_UNARY_UNARY = b'/test/UnaryUnary'+_UNARY_STREAM = b'/test/UnaryStream'+_STREAM_UNARY = b'/test/StreamUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary_unary(request, servicer_context):+  return _RESPONSE+++def handle_unary_stream(request, servicer_context):+  for i in range(_STREAM_COUNT):","`i` is never used, so name it `unused_i`, `ignored_i`, or `_`. `unused_` is favored when an identifier's name really means something interesting and helpful to readers; `_` is the right name for this circumstance.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6874,66698396,2016-06-11T01:29:34Z,src/python/grpcio/grpc/utilities.py,"@@ -0,0 +1,153 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Utilities for use with gRPC Python.""""""++import collections++import grpc+++class _RpcMethodHandler(",Can you not instantiate RpcMethodHandler directly?  I assumed you could because there were no actual methods.,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6874,66698549,2016-06-11T01:41:35Z,src/python/grpcio/grpc/utilities.py,"@@ -0,0 +1,153 @@+# Copyright 2016, Google Inc.","I'm not too hot on the utilities.py name.  This file seems to only contain helper methods for rpc handler construction, I would prefer to see it called handlers.py, rpc_handlers.py, or something along those lines.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6547,66699693,2016-06-11T02:51:26Z,src/python/grpcio/tests/unit/_empty_request_test.py,"@@ -0,0 +1,135 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import unittest++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants++_REQUEST = b''+_RESPONSE = b''++_UNARY_UNARY = b'/test/UnaryUnary'+_UNARY_STREAM = b'/test/UnaryStream'+_STREAM_UNARY = b'/test/StreamUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary_unary(request, servicer_context):+  return _RESPONSE+++def handle_unary_stream(request, servicer_context):+  for _ in range(test_constants.STREAM_LENGTH):+    yield _RESPONSE+++def handle_stream_unary(request_iterator, servicer_context):+  for request in request_iterator:+    pass+  return _RESPONSE+++def handle_stream_stream(request_iterator, servicer_context):+  for request in request_iterator:+    yield _RESPONSE+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = handle_stream_stream+    elif self.request_streaming:+      self.stream_unary = handle_stream_unary+    elif self.response_streaming:+      self.unary_stream = handle_unary_stream+    else:+      self.unary_unary = handle_unary_unary+++class _GenericHandler(grpc.GenericRpcHandler):++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(False, False)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(False, True)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(True, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(True, True)+    else:+      return None+++class EmptyRequestTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(),), self._server_pool)+    port = self._server.add_insecure_port('[::]:0')+    self._server.start()+    self._channel = grpc.insecure_channel('localhost:%d' % port)++  def tearDown(self):+    self._server.stop(0)++  def testUnaryUnary(self):+    response = self._channel.unary_unary(_UNARY_UNARY)(_REQUEST)+    self.assertEqual(_RESPONSE, response)++  def testUnaryStream(self):+    response = self._channel.unary_stream(_UNARY_STREAM)(_REQUEST)+    self.assertEqual([_RESPONSE]*test_constants.STREAM_LENGTH, list(response))",Always use the most specific assertion method possible - `assertSequenceEqual` would be a good choice here. `assertListEqual` doesn't quite fit because a list's being in the comparison is an artifact of the test (the system under test only returned an iterator to the test).,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6857,66700151,2016-06-11T03:38:59Z,src/python/grpcio/grpc/_server.py,"@@ -719,6 +708,24 @@ def cancel_all_calls_after_grace():   return shutdown_event  +def _start(state):+  with state.lock:+    if state.stage is not _ServerStage.STOPPED:+      raise ValueError('Cannot start already-started server!')+    state.server.start()+    state.stage = _ServerStage.STARTED+    _request_call(state)    +    def cleanup_server(timeout):+      if not timeout:","Always favor```if <condition>:  <other statements>else:  <some statements>```over```if not <condition>:  <some statements>else:  <other statements>```. Except here I don't think it's a boolean comparison that best fits the situation: `timeout` may be a numeric value or it may be `None`, and I think the branch works best when aligned that way.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6503,66728536,2016-06-12T22:08:28Z,src/python/grpcio/grpc/_channel.py,"@@ -142,7 +142,7 @@ def _handle_event(event, state, response_deserializer):         response = _common.deserialize(             serialized_response, response_deserializer)         if response is None:-          details = b'Exception deserializing response!'+          details = 'Exception deserializing response!'","In Python3.4, byte strings are particularly annoying to manage.  I believe some of the `details` you were creating used `.format()` which is not supported for byte strings.  Pretty much all the other nice functions on `str` don't work either.For that reason, I relaxed the API to also accept ascii encodable `str` types.  This is similar to what the library was doing before with the Python2 `unicode` strings.  It would accept them, and then utf-8 encode them before passing them to the c-core.  I felt that utf-8 encoding was too lenient because there are multiple canonical encodings for non-ascii characters, and so I restricted it to ascii characters. ",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6547,66728853,2016-06-12T22:26:48Z,src/python/grpcio/tests/unit/_empty_request_test.py,"@@ -0,0 +1,135 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import unittest++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants++_REQUEST = b''+_RESPONSE = b''++_UNARY_UNARY = b'/test/UnaryUnary'+_UNARY_STREAM = b'/test/UnaryStream'+_STREAM_UNARY = b'/test/StreamUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary_unary(request, servicer_context):+  return _RESPONSE+++def handle_unary_stream(request, servicer_context):+  for _ in range(test_constants.STREAM_LENGTH):+    yield _RESPONSE+++def handle_stream_unary(request_iterator, servicer_context):+  for request in request_iterator:+    pass+  return _RESPONSE+++def handle_stream_stream(request_iterator, servicer_context):+  for request in request_iterator:+    yield _RESPONSE+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = handle_stream_stream+    elif self.request_streaming:+      self.stream_unary = handle_stream_unary+    elif self.response_streaming:+      self.unary_stream = handle_unary_stream+    else:+      self.unary_unary = handle_unary_unary+++class _GenericHandler(grpc.GenericRpcHandler):++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(False, False)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(False, True)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(True, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(True, True)+    else:+      return None+++class EmptyRequestTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(),), self._server_pool)+    port = self._server.add_insecure_port('[::]:0')+    self._server.start()+    self._channel = grpc.insecure_channel('localhost:%d' % port)++  def tearDown(self):+    self._server.stop(0)++  def testUnaryUnary(self):+    response = self._channel.unary_unary(_UNARY_UNARY)(_REQUEST)+    self.assertEqual(_RESPONSE, response)++  def testUnaryStream(self):+    response = self._channel.unary_stream(_UNARY_STREAM)(_REQUEST)+    self.assertEqual([_RESPONSE]*test_constants.STREAM_LENGTH, list(response))",Makes sense.  I left the `list()` conversion in there though because `assertSequenceEqual` requires a length attribute.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6839,66837982,2016-06-13T17:59:44Z,doc/interop-test-descriptions.md,"@@ -85,56 +83,96 @@ Procedure:  Client asserts: * call was successful-* response payload type is COMPRESSABLE * response payload body is 314159 bytes in size * clients are free to assert that the response payload body contents are zero   and comparing the entire response message against a golden response -### large_compressed_unary+### client_compressed_unary -This test verifies compressed unary calls succeed in sending messages. It-sends one unary request for every payload type, with and without requesting a-compressed response from the server.+This test verifies the client can compress unary messages. It sends an initial+inconsistent request to verify whether the server supports the+[CompressedRequest][] feature. If it does, it should catch the inconsistency and+fail the call with an `INVALID_ARGUMENT` status. If the feature is supported, it+proceeds with two unary calls, for compressed and uncompressed payloads. -In all scenarios, whether compression was actually performed is determined by-the compression bit in the response's message flags.+Server features:+* [UnaryCall][]+* [CompressedRequest][]++Procedure:+ 1. Client calls UnaryCall with the feature probe, an **uncompressed** message:+    ```+    {+      expect_compressed: false+      response_size: 314159+      payload:{+        body: 271828 bytes of zeros+      }+    }+    ```++ 1. Client calls UnaryCall with the *compressed* message:","nit: list point numbering is ""1."" for all the items.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6839,66839393,2016-06-13T18:08:39Z,src/proto/grpc/testing/messages.proto,"@@ -78,10 +77,13 @@ message SimpleRequest {   bool fill_oauth_scope = 5;    // Whether to request the server to compress the response.-  bool request_compressed_response = 6;+  bool response_compressed = 6;    // Whether server should return a given status   EchoStatus response_status = 7;++  // Whether the server should expect this request to be compressed.+  bool expect_compressed = 8;",Didn't we say that this field should be nullable to make sure we don't change behavior of other interop tests?https://github.com/google/protobuf/blob/814685ca2cd9280ca401e1842fd6311440921a0a/src/google/protobuf/wrappers.proto#L100Same for StreamingInputCallRequest.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6839,66840375,2016-06-13T18:14:35Z,doc/interop-test-descriptions.md,"@@ -206,25 +245,75 @@ Client asserts: * call was successful * response aggregated_payload_size is 74922 ++### client_compressed_streaming++This test verifies the client can compress streaming messages. It sends an+initial inconsistent streaming call comprised of a single message to verify if+the server implements the [CompressedRequest][] feature. If it does, the client+will then send another streaming call, comprised of two messages: the first one+compressed with `expect_compressed` true; the second one uncompressed with+`expected_compressed` false.++Procedure:+ 1. Client calls StreamingInputCall+ 1. Client sends the following feature-probing *uncompressed* message","That's a feature. Markdown will do the right thing when it renders it. By having always 1., we don't need to change all the numbers if we insert something in the middle, etc.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6882,66841270,2016-06-13T18:19:39Z,src/python/grpcio/tests/unit/_metadata_test.py,"@@ -0,0 +1,211 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_CHANNEL_ARGS = (('grpc.primary_user_agent', 'primary-agent'),+                 ('grpc.secondary_user_agent', 'secondary-agent'))++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x00'++_UNARY_UNARY = b'/test/UnaryUnary'+_UNARY_STREAM = b'/test/UnaryStream'+_STREAM_UNARY = b'/test/StreamUnary'+_STREAM_STREAM = b'/test/StreamStream'++_USER_AGENT = 'Python-gRPC-{}'.format(_grpcio_metadata.__version__)++_CLIENT_MD = (+    (b'client-md-key', b'client-md-key'),+    (b'client-md-key-bin', b'\x00\x01')+)++_SERVER_INITIAL_MD = (+    (b'server-initial-md-key', b'server-initial-md-value'),+    (b'server-initial-md-key-bin', b'\x00\x02')+)++_SERVER_TRAILING_MD = (+    (b'server-trailing-md-key', b'server-trailing-md-value'),+    (b'server-trailing-md-key-bin', b'\x00\x03')+)+++def user_agent(metadata):+  for key, val in metadata:+    if key == b'user-agent':+      return val.decode('ascii')+  raise KeyError('No user agent!')+++def validate_client_metadata(test, servicer_context):+  test.assertTrue(test_common.metadata_transmitted(+      _CLIENT_MD, servicer_context.invocation_metadata()))+  test.assertTrue(user_agent(servicer_context.invocation_metadata())+                  .startswith('primary-agent ' + _USER_AGENT))+  test.assertTrue(user_agent(servicer_context.invocation_metadata())+                  .endswith('secondary-agent'))+++def handle_unary_unary(test, request, servicer_context):+  validate_client_metadata(test, servicer_context)+  servicer_context.send_initial_metadata(_SERVER_INITIAL_MD)+  servicer_context.set_trailing_metadata(_SERVER_TRAILING_MD)+  return _RESPONSE+++def handle_unary_stream(test, request, servicer_context):+  validate_client_metadata(test, servicer_context)+  servicer_context.send_initial_metadata(_SERVER_INITIAL_MD)+  servicer_context.set_trailing_metadata(_SERVER_TRAILING_MD)+  for _ in range(test_constants.STREAM_LENGTH):+    yield _RESPONSE+++def handle_stream_unary(test, request_iterator, servicer_context):+  validate_client_metadata(test, servicer_context)+  servicer_context.send_initial_metadata(_SERVER_INITIAL_MD)+  servicer_context.set_trailing_metadata(_SERVER_TRAILING_MD)+  for request in request_iterator:+    pass+  return _RESPONSE+++def handle_stream_stream(test, request_iterator, servicer_context):+  validate_client_metadata(test, servicer_context)+  servicer_context.send_initial_metadata(_SERVER_INITIAL_MD)+  servicer_context.set_trailing_metadata(_SERVER_TRAILING_MD)+  for request in request_iterator:+    yield _RESPONSE+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream_stream(test, x, y)+    elif self.request_streaming:+      self.stream_unary = lambda x, y: handle_stream_unary(test, x, y)+    elif self.response_streaming:+      self.unary_stream = lambda x, y: handle_unary_stream(test, x, y)+    else:+      self.unary_unary = lambda x, y: handle_unary_unary(test, x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def __init__(self, test):+    self._test = test++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(self._test, False, False)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(self._test, False, True)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(self._test, True, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(self._test, True, True)+    else:+      return None+++class MetadataTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(weakref.proxy(self)),),+                               self._server_pool)+    port = self._server.add_insecure_port('[::]:0')+    self._server.start()+    self._channel = grpc.insecure_channel('localhost:%d' % port,+                                          options=_CHANNEL_ARGS)++  def tearDown(self):+    self._server.stop(0)++  def testUnaryUnary(self):+    multi_callable = self._channel.unary_unary(_UNARY_UNARY)+    _, call = multi_callable(_REQUEST, metadata=_CLIENT_MD, with_call=True)+    self.assertTrue(test_common.metadata_transmitted(+        _SERVER_INITIAL_MD, call.initial_metadata()))+    self.assertTrue(test_common.metadata_transmitted(+        _SERVER_TRAILING_MD, call.trailing_metadata()))++  def testUnaryStream(self):+    multi_callable = self._channel.unary_stream(_UNARY_STREAM)+    call = multi_callable(_REQUEST, metadata=_CLIENT_MD)+    self.assertTrue(test_common.metadata_transmitted(+        _SERVER_INITIAL_MD, call.initial_metadata()))+    for _ in call:+      pass+    self.assertTrue(test_common.metadata_transmitted(+        _SERVER_TRAILING_MD, call.trailing_metadata()))++  def testStreamUnary(self):+    multi_callable = self._channel.stream_unary(_STREAM_UNARY)+    _, call = multi_callable([_REQUEST]*test_constants.STREAM_LENGTH,","Nitpicks, but:1. `unused_response` over `_` here.2. Single whitespace on either side of binary infix operators.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6882,66868228,2016-06-13T21:06:53Z,src/python/grpcio/tests/unit/_metadata_test.py,"@@ -0,0 +1,211 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_CHANNEL_ARGS = (('grpc.primary_user_agent', 'primary-agent'),+                 ('grpc.secondary_user_agent', 'secondary-agent'))++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x00'++_UNARY_UNARY = b'/test/UnaryUnary'+_UNARY_STREAM = b'/test/UnaryStream'+_STREAM_UNARY = b'/test/StreamUnary'+_STREAM_STREAM = b'/test/StreamStream'++_USER_AGENT = 'Python-gRPC-{}'.format(_grpcio_metadata.__version__)++_CLIENT_MD = (+    (b'client-md-key', b'client-md-key'),+    (b'client-md-key-bin', b'\x00\x01')+)++_SERVER_INITIAL_MD = (+    (b'server-initial-md-key', b'server-initial-md-value'),+    (b'server-initial-md-key-bin', b'\x00\x02')+)++_SERVER_TRAILING_MD = (+    (b'server-trailing-md-key', b'server-trailing-md-value'),+    (b'server-trailing-md-key-bin', b'\x00\x03')+)+++def user_agent(metadata):+  for key, val in metadata:+    if key == b'user-agent':+      return val.decode('ascii')+  raise KeyError('No user agent!')+++def validate_client_metadata(test, servicer_context):","Good Catch!Very interesting behavior here,`test.assertTrue(False)` in `validate_metadata` has the following behavior:StreamUnary/UnaryUnary fail because of a raised StatusCode.UNKNOWN exceptionStreamStream/UnaryStream fail with an assertion error.So we will catch violations, just maybe not in the way we would expect.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6704,66880368,2016-06-13T22:27:54Z,test/distrib/cpp/run_distrib_test.sh,"@@ -0,0 +1,52 @@+#!/bin/bash+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++set -ex++git clone $EXTERNAL_GIT_ROOT+cd grpc && git submodule update --init++cd third_party/protobuf && ./autogen.sh && \+./configure && make -j12 && make check && make install && ldconfig",nit: -j12 is probably too much (multiple distribtests are running in parallel on the same worker).  -j8 or -j4 should be fine.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/6882,66886562,2016-06-13T23:25:39Z,src/python/grpcio/tests/unit/_metadata_test.py,"@@ -0,0 +1,211 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_CHANNEL_ARGS = (('grpc.primary_user_agent', 'primary-agent'),+                 ('grpc.secondary_user_agent', 'secondary-agent'))++_REQUEST = b'\x00\x00\x00'+_RESPONSE = b'\x00\x00\x00'++_UNARY_UNARY = b'/test/UnaryUnary'+_UNARY_STREAM = b'/test/UnaryStream'+_STREAM_UNARY = b'/test/StreamUnary'+_STREAM_STREAM = b'/test/StreamStream'++_USER_AGENT = 'Python-gRPC-{}'.format(_grpcio_metadata.__version__)++_CLIENT_MD = (+    (b'client-md-key', b'client-md-key'),+    (b'client-md-key-bin', b'\x00\x01')+)++_SERVER_INITIAL_MD = (+    (b'server-initial-md-key', b'server-initial-md-value'),+    (b'server-initial-md-key-bin', b'\x00\x02')+)++_SERVER_TRAILING_MD = (+    (b'server-trailing-md-key', b'server-trailing-md-value'),+    (b'server-trailing-md-key-bin', b'\x00\x03')+)+++def user_agent(metadata):+  for key, val in metadata:+    if key == b'user-agent':+      return val.decode('ascii')+  raise KeyError('No user agent!')+++def validate_client_metadata(test, servicer_context):","The proper way to work around this is to have some shared object with fields like `test_failed_in_other_thread` and `how_it_failed_in_other_thread` and then set them in this server thread and then check them in the test method(s), so that when the test fails, how it fails is clear from the exception raised from the test thread.I'm willing to let it slide for this test, but keep it in mind for the future.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6791,66898943,2016-06-14T01:58:06Z,tools/run_tests/run_tests.py,"@@ -438,16 +456,21 @@ def makefile_name(self):   def dockerfile_dir(self):     return 'tools/dockerfile/test/python_jessie_%s' % _docker_arch_suffix(self.args.arch) -  def _get_tox_envs(self, compiler):-    """"""Returns name of tox environment based on selected compiler.""""""-    if compiler == 'default':-      return ('py27', 'py34')-    elif compiler == 'python2.7':-      return ('py27',)+  def _get_pythons(self, compiler):+    if os.name == 'nt':+      venv_relative_python = 'Scripts/python.exe'+      toolchain = 'mingw32'+    else:+      venv_relative_python = 'bin/python'+      toolchain = 'unix'+    python27_config = PythonConfig('python2.7', 'py27', venv_relative_python, toolchain)+    python34_config = PythonConfig('python3.4', 'py34', venv_relative_python, toolchain)+    if compiler == 'python2.7' or compiler == 'default':",Looks like this might have been the result of some creative merge logic:(My original Python3 commit)https://github.com/kpayson64/grpc/blob/1efb6017ec1edb26706895dfe71f4d72ea387cf4/tools/run_tests/run_tests.py#L428Can you change python2.7 to only run python2.7?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6839,67085453,2016-06-15T01:11:25Z,doc/interop-test-descriptions.md,"@@ -341,27 +341,16 @@ Server features:   Procedure:- 1. Client calls StreamingOutputCall with:--    ```-    {-      response_compressed: true-      response_parameters:{-        size: 31415-      }-      response_parameters:{-        size: 58979-      }-    }-    ```+ 1. Client calls StreamingOutputCall with `StreamingOutputCallRequest`:      ```     {-      response_compressed: false       response_parameters:{+        response_compressed: true","response_compressed -> compressed   (this is response_parameters message, so ""response"" is implicit, same as for ""size"").",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/5759,67166582,2016-06-15T14:00:55Z,src/python/grpcio/tests/unit/framework/interfaces/links/test_utilities.py,"@@ -51,7 +51,7 @@ def _safe_for_log_ticket(ticket):       possibly features values like the string ""<payload of length 972321>"" in       place of the actual values of the given ticket.   """"""-  if isinstance(ticket.payload, (basestring,)):+  if isinstance(ticket.payload, (str,)):","We've already decided to use `six`, and as best I can tell the `builtins` module from `future` would require breakage from our current style guide to provide ergonomic gains. That said...This is an interesting suggestion as far as choice-of-dependencies go. Not immediately desirable or even desirable in the long run (I'd rather cythonize in the long run), but mid-term it _might_ be worth considering.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6915,67255444,2016-06-15T22:10:33Z,include/grpc++/channel_filter.h,"@@ -0,0 +1,211 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc/grpc.h>++#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/surface/channel_init.h""++//+// An interface to define filters.+//+// To define a filter, implement a subclass of each of CallData and+// ChannelData.  Then register the filter like this:+//   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+//       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX);+//++namespace grpc {++// Represents call data.+// Note: Must be copyable.+class CallData {+ public:+  // Do not override the destructor.  Instead, put clean-up code in the+  // Destroy() method.+  virtual ~CallData() {}++  virtual void Destroy() {}++  virtual void StartTransportStreamOp(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      grpc_transport_stream_op *op);++  virtual void SetPollsetOrPollsetSet(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      grpc_polling_entity *pollent);++  virtual char* GetPeer(grpc_exec_ctx *exec_ctx, grpc_call_element *elem);++ protected:+  CallData() {}+};++// Represents channel data.+// Note: Must be copyable.+class ChannelData {+ public:+  // Do not override the destructor.  Instead, put clean-up code in the+  // Destroy() method.+  virtual ~ChannelData() {}++  virtual void Destroy() {}++  virtual void StartTransportOp(+      grpc_exec_ctx *exec_ctx, grpc_channel_element *elem,+      grpc_transport_op *op);++ protected:+  ChannelData() {}+};++namespace internal {++// Defines static members for passing to C core.+template<typename ChannelDataType, typename CallDataType>+class ChannelFilter {+  static const size_t call_data_size = sizeof(CallDataType);++  static void InitCallElement(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      grpc_call_element_args *args) {+    CallDataType* call_data = elem->call_data;","This method should be just:``` cnew (elem->call_data) CallDataType();```... there's no guarantee that the data pointed to is initialized, so we want to avoid calling the destructor (or that might crash)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6915,67255510,2016-06-15T22:11:02Z,include/grpc++/channel_filter.h,"@@ -0,0 +1,211 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc/grpc.h>++#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/surface/channel_init.h""++//+// An interface to define filters.+//+// To define a filter, implement a subclass of each of CallData and+// ChannelData.  Then register the filter like this:+//   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+//       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX);+//++namespace grpc {++// Represents call data.+// Note: Must be copyable.+class CallData {+ public:+  // Do not override the destructor.  Instead, put clean-up code in the+  // Destroy() method.+  virtual ~CallData() {}++  virtual void Destroy() {}++  virtual void StartTransportStreamOp(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      grpc_transport_stream_op *op);++  virtual void SetPollsetOrPollsetSet(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      grpc_polling_entity *pollent);++  virtual char* GetPeer(grpc_exec_ctx *exec_ctx, grpc_call_element *elem);++ protected:+  CallData() {}+};++// Represents channel data.+// Note: Must be copyable.+class ChannelData {+ public:+  // Do not override the destructor.  Instead, put clean-up code in the+  // Destroy() method.+  virtual ~ChannelData() {}++  virtual void Destroy() {}++  virtual void StartTransportOp(+      grpc_exec_ctx *exec_ctx, grpc_channel_element *elem,+      grpc_transport_op *op);++ protected:+  ChannelData() {}+};++namespace internal {++// Defines static members for passing to C core.+template<typename ChannelDataType, typename CallDataType>+class ChannelFilter {+  static const size_t call_data_size = sizeof(CallDataType);++  static void InitCallElement(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      grpc_call_element_args *args) {+    CallDataType* call_data = elem->call_data;+    *call_data = CallDataType();+  }++  static void DestroyCallElement(+      grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+      const grpc_call_stats *stats, void *and_free_memory) {+    CallDataType* call_data = elem->call_data;","Similarly, this should just be:``` creinterpret_cast<CallDataType*>(elem->call_data)->~CallDataType();```",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6915,67403784,2016-06-16T18:55:05Z,src/cpp/common/channel_filter.cc,"@@ -0,0 +1,105 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc++/channel_filter.h>++#include ""src/core/lib/channel/channel_stack.h""++namespace grpc {++//+// CallData+//++void CallData::StartTransportStreamOp(grpc_exec_ctx *exec_ctx,+                                      grpc_call_element *elem,+                                      grpc_transport_stream_op *op) {+  grpc_call_next_op(exec_ctx, elem, op);+}++void CallData::SetPollsetOrPollsetSet(grpc_exec_ctx *exec_ctx,+                                      grpc_call_element *elem,+                                      grpc_polling_entity *pollent) {+  grpc_call_stack_ignore_set_pollset_or_pollset_set(exec_ctx, elem, pollent);+}++char *CallData::GetPeer(grpc_exec_ctx *exec_ctx, grpc_call_element *elem) {+  return grpc_call_next_get_peer(exec_ctx, elem);+}++//+// ChannelData+//++void ChannelData::StartTransportOp(grpc_exec_ctx *exec_ctx,+                                   grpc_channel_element *elem,+                                   grpc_transport_op *op) {+  grpc_channel_next_op(exec_ctx, elem, op);+}++//+// RegisterChannelFilter()+//++namespace internal {++std::vector<FilterRecord> *channel_filters = nullptr;","Some nullptr issues are discussed in https://github.com/grpc/grpc/blob/master/doc/cpp-style-guide.md . I have added this particular one to the big compatibility issue in #6863 . This initialization is not needed because channel_filters here has static lifetime, and all pointers with static lifetime are implicitly initialized to nullptr.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6915,67404015,2016-06-16T18:56:23Z,src/cpp/common/channel_filter.cc,"@@ -0,0 +1,105 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc++/channel_filter.h>++#include ""src/core/lib/channel/channel_stack.h""++namespace grpc {++//+// CallData+//++void CallData::StartTransportStreamOp(grpc_exec_ctx *exec_ctx,+                                      grpc_call_element *elem,+                                      grpc_transport_stream_op *op) {+  grpc_call_next_op(exec_ctx, elem, op);+}++void CallData::SetPollsetOrPollsetSet(grpc_exec_ctx *exec_ctx,+                                      grpc_call_element *elem,+                                      grpc_polling_entity *pollent) {+  grpc_call_stack_ignore_set_pollset_or_pollset_set(exec_ctx, elem, pollent);+}++char *CallData::GetPeer(grpc_exec_ctx *exec_ctx, grpc_call_element *elem) {+  return grpc_call_next_get_peer(exec_ctx, elem);+}++//+// ChannelData+//++void ChannelData::StartTransportOp(grpc_exec_ctx *exec_ctx,+                                   grpc_channel_element *elem,+                                   grpc_transport_op *op) {+  grpc_channel_next_op(exec_ctx, elem, op);+}++//+// RegisterChannelFilter()+//++namespace internal {++std::vector<FilterRecord> *channel_filters = nullptr;++namespace {++bool MaybeAddFilter(grpc_channel_stack_builder *builder, void *arg) {+  const FilterRecord &filter = *(FilterRecord *)arg;+  if (filter.include_filter != nullptr) {",The problem is discussed in https://github.com/grpc/grpc/blob/master/doc/cpp-style-guide.md :nullptr wasn't accepted by gcc until 4.6. We can't use NULL as a substitute for nullptr (it's just the numerical value 0),
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6849,67531936,2016-06-17T15:46:33Z,gRPC-ProtoRPC.podspec,"@@ -0,0 +1,69 @@+# GRPC CocoaPods podspec+# This file has been automatically generated from a template file.+# Please look at the templates directory instead.+# This file can be regenerated from the template by running+# tools/buildgen/generate_projects.sh++# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+++Pod::Spec.new do |s|+  s.name     = 'gRPC-ProtoRPC'+  version = '0.14.0'+  s.version  = version+  s.summary  = 'RPC library for Protocol Buffers, based on gRPC'+  s.homepage = 'http://www.grpc.io'+  s.license  = 'New BSD'+  s.authors  = { 'The gRPC contributors' => 'grpc-packages@google.com' }++  s.source = {+    :git => 'https://github.com/grpc/grpc.git',+    :tag => ""release-#{version.gsub(/\./, '_')}-objectivec-#{version}"",+  }++  s.ios.deployment_target = '7.1'+  s.osx.deployment_target = '10.9'++  name = 'ProtoRPC'+  s.module_name = name+  s.header_dir = name++  src_dir = 'src/objective-c/ProtoRPC'+  s.source_files = ""#{src_dir}/*.{h,m}""+  s.header_mappings_dir = ""#{src_dir}""++  s.dependency 'gRPC', version+  s.dependency 'gRPC-RxLibrary', version+  s.dependency 'Protobuf', '~> 3.0.0-beta-2'+  # This is needed by all pods that depend on Protobuf:+  s.pod_target_xcconfig = {+    'GCC_PREPROCESSOR_DEFINITIONS' => '$(inherited) GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS=1',","I agree. It surprised me too. Maybe they need to add a `dependent_targets_xcconfig` property. I think I tried changing `Protobuf.podspec` to use the deprecated `xcconfig` property, hoping it would modify all targets. But apparently it's just translated into `user_target_xcconfig` and `pod_target_xcconfig`.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/6934,67547115,2016-06-17T17:34:17Z,examples/objective-c/route_guide/ViewControllers.m,"@@ -83,17 +83,24 @@ + (instancetype)noteWithMessage:(NSString *)message @interface GetFeatureViewController : UIViewController {   RTGRouteGuide *service; }+@property (weak, nonatomic) IBOutlet UILabel *outputLabel; @end  @implementation GetFeatureViewController  - (void)execRequest {   void (^handler)(RTGFeature *response, NSError *error) = ^(RTGFeature *response, NSError *error) {     if (response.name.length) {+      NSString *str =[NSString stringWithFormat:@""%@\nFound feature called %@ at %@."", self.outputLabel.text, response.location, response.name];+      self.outputLabel.text = str;       NSLog(@""Found feature called %@ at %@."", response.name, response.location);","It looks like we could remove boilerplate for the people reading the example by doing:``` objective-cif (response.name.length) {  [self log:@""Found feature called %@ at %@."", response.name, response.location];} ...```The log method can be declared, along with the `outputLabel` and `service` properties, in a superclass that's common to all these view controllers:``` objc@interface SampleViewController : UIViewController@property(weak, nonatomic) IBOutlet UILabel *outputLabel;@property(strong, nonatomic) RTGRouteGuide *service;- (void)log:(NSString *)formatString, ...;@end@implementation SampleViewController- (void)log:(NSString *)formatString, ... {  va_list args;  va_start(args, formatString);  NSString *str = [NSString stringWithFormat:formatString arguments:args];  self.outputLabel.text = [self.outputLabel.text stringByAppendingString:str];  NSLog(str);  va_end(args);}@end```",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/6104,67548949,2016-06-17T17:46:28Z,src/csharp/Grpc.Auth/project.json,"@@ -0,0 +1,32 @@+{+  ""version"": ""0.14.0-anexperiment"",+  ""title"": ""gRPC C# Auth"",+  ""authors"": [ ""Google Inc."" ],+  ""copyright"": ""Copyright 2015, Google Inc."",+  ""packOptions"": {+    ""summary"": ""Auth library for C# implementation of gRPC - an RPC library and framework"",+    ""description"": ""Auth library for C# implementation of gRPC - an RPC library and framework. See project site for more info."",+    ""owners"": [ ""grpc-packages"" ],+    ""licenseUrl"": ""https://github.com/grpc/grpc/blob/master/LICENSE"",+    ""projectUrl"": ""https://github.com/grpc/grpc"",+    ""requireLicenseAcceptance"": false,+    ""tags"": [ ""gRPC RPC Protocol HTTP/2 Auth OAuth2"" ],+  },+  ""dependencies"": {+    ""Grpc.Core"": ""0.14.0-anexperiment"",+    ""Google.Apis.Auth"": ""1.11.1""+  },+  ""frameworks"": {+    ""net45"": { },+    ""netstandard1.5"": {+      ""imports"": [+        ""net45""+      ],+      ""dependencies"": {+        ""Microsoft.NETCore.Portable.Compatibility"": ""1.0.1-rc2-24027"",+        ""NETStandard.Library"": ""1.5.0-rc2-24027"",","It would be better (I think) to specify fine-grained dependencies rather than the general library, for the benefit of applications wanting to package as little as possible. Can dig into it if you like... and it can definitely be postponed.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/6104,67549312,2016-06-17T17:48:43Z,src/csharp/Grpc.Core.Tests/project.json,"@@ -0,0 +1,35 @@+{","The NUnit test runner is nearly ready now, at which point in a dotnet-cli-only world we could ditch the entry point. But it makes sense to keep this for the moment - I can help get it more up to date when we want to.See https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Test/project.json as an example.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6863,67584488,2016-06-17T22:35:55Z,include/grpc++/impl/codegen/core_codegen.h,"@@ -42,42 +42,44 @@ namespace grpc { /// Implementation of the core codegen interface.","woooops, this whole set of overrides is my bad :grimacing: sorry",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6863,67585423,2016-06-17T22:48:51Z,include/grpc++/impl/codegen/config.h,"@@ -54,6 +54,7 @@ // nullptr was added in gcc 4.6 #if (__GNUC__ * 100 + __GNUC_MINOR__ < 406) #define GRPC_CXX0X_NO_NULLPTR 1+#define GRPC_CXX0X_LIMITED_TOSTRING 1","gcc4.4 only supports std::to_string(long long), (long long unsigned), or (long double). So, for int and unsigned int types, there was an ambiguous conversion.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/6959,67592816,2016-06-18T01:27:13Z,tools/run_tests/run_tests.py,"@@ -445,6 +445,10 @@ def _get_tox_envs(self, compiler):       return ('py27',)     elif compiler == 'python3.4':       return ('py34',)+    elif compiler == 'python3.5':+      return ('py35',)+    elif compiler == 'python3.6':+      return ('py36',)     else:       raise Exception('Compiler %s not supported.' % compiler) ","In line 835 there is a list of supported compilers, I think you might need to add python3.5 and python3.6 there as well.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6104,67594252,2016-06-18T03:00:33Z,src/csharp/Grpc.Auth/project.json,"@@ -0,0 +1,32 @@+{+  ""version"": ""0.14.0-anexperiment"",+  ""title"": ""gRPC C# Auth"",+  ""authors"": [ ""Google Inc."" ],+  ""copyright"": ""Copyright 2015, Google Inc."",+  ""packOptions"": {+    ""summary"": ""Auth library for C# implementation of gRPC - an RPC library and framework"",+    ""description"": ""Auth library for C# implementation of gRPC - an RPC library and framework. See project site for more info."",+    ""owners"": [ ""grpc-packages"" ],+    ""licenseUrl"": ""https://github.com/grpc/grpc/blob/master/LICENSE"",+    ""projectUrl"": ""https://github.com/grpc/grpc"",+    ""requireLicenseAcceptance"": false,+    ""tags"": [ ""gRPC RPC Protocol HTTP/2 Auth OAuth2"" ],+  },+  ""dependencies"": {+    ""Grpc.Core"": ""0.14.0-anexperiment"",+    ""Google.Apis.Auth"": ""1.11.1""+  },+  ""frameworks"": {+    ""net45"": { },+    ""netstandard1.5"": {+      ""imports"": [","Yes, this is because Google.Api.Auth is not supporting coreclr yet. Having this allows me to add a dependency and make things compile ""as if"" it was portable yet.I would have added an explanatory comment, but project.json files don't support comments (which is actually pretty painful).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6912,67706647,2016-06-20T15:08:42Z,tools/run_tests/build_package_node.sh,"@@ -58,6 +58,8 @@ tools_version=$(npm list | grep -oP '(?<=grpc-tools@)\S+') output_dir=$artifacts/grpc-precompiled-binaries/node/grpc-tools/v$tools_version mkdir -p $output_dir +well_known_protos=( any api compiler/plugin descriptor duration empty field_mask source_context struct timestamp type wrappers )",compiler/plugin protos is probably unneeded here (but you can have it if you want to).Here's list of .proto files for Protobuf.Tools nuget.https://github.com/google/protobuf/blob/master/csharp/Google.Protobuf.Tools.nuspec,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/6839,67708203,2016-06-20T15:17:18Z,src/proto/grpc/testing/messages.proto,"@@ -38,9 +38,6 @@ package grpc.testing; enum PayloadType {   // Compressable text format.   COMPRESSABLE = 0;--  // Uncompressable binary format.-  UNCOMPRESSABLE = 1;",did you intend to remove this or deprecate this?,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/6912,67720080,2016-06-20T16:24:22Z,tools/run_tests/build_package_node.sh,"@@ -58,6 +58,8 @@ tools_version=$(npm list | grep -oP '(?<=grpc-tools@)\S+') output_dir=$artifacts/grpc-precompiled-binaries/node/grpc-tools/v$tools_version mkdir -p $output_dir +well_known_protos=( any api compiler/plugin descriptor duration empty field_mask source_context struct timestamp type wrappers )",That list is from the bazel query posted on issue #6740. I decided to be thorough.,
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/6922,67794154,2016-06-21T01:12:45Z,src/objective-c/ProtoRPC/ProtoService.m,"@@ -65,6 +65,8 @@ - (instancetype)initWithHost:(NSString *)host   return self; } +#pragma clang diagnostic push+#pragma clang diagnostic ignored ""-Wincompatible-pointer-types""","```method:methodName```triggers this warning. `methodName` has type 'ProtoMethod *', but 'GRPCProtoMethod *' is expected here. Looks like it's caused by the deprecated API.",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/6922,67795001,2016-06-21T01:23:47Z,src/objective-c/tests/GRPCClientTests.m,"@@ -303,7 +303,7 @@ - (void)testExceptions {    // Try to set parameters to nil for GRPCCall. This should cause an exception   @try {-    GRPCCall *call = [[GRPCCall alloc] initWithHost:nil+    GRPCCall *call __unused = [[GRPCCall alloc] initWithHost:nil",Looks like the unused object here is initialized to trigger an expected exception.,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/6893,67904210,2016-06-21T16:34:58Z,test/core/end2end/bad_server_response_test.c,"@@ -0,0 +1,335 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+#include <string.h>++#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>+#include <grpc/support/slice.h>+#include <grpc/support/thd.h>++#include ""src/core/ext/transport/chttp2/transport/internal.h""+#include ""src/core/lib/iomgr/sockaddr.h""+#include ""src/core/lib/support/string.h""+#include ""test/core/end2end/cq_verifier.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""+#include ""test/core/util/test_tcp_server.h""++#define HTTP1_RESP                           \+  ""HTTP/1.0 400 Bad Request\n""               \+  ""Content-Type: text/html; charset=UTF-8\n"" \+  ""Content-Length: 0\n""                      \+  ""Date: Tue, 07 Jun 2016 17:43:20 GMT\n\n""++#define HTTP2_RESP(STATUS_CODE)          \+  ""\x00\x00\x00\x04\x00\x00\x00\x00\x00"" \+  ""\x00\x00""                             \+  ""7\x01\x04\x00\x00\x00\x01""            \+  ""\x10\x0e""                             \+  ""content-length\x01""                   \+  ""0""                                    \+  ""\x10\x0c""                             \+  ""content-type\x09text/html""            \+  ""\x10\x07:status\x03"" #STATUS_CODE++#define UNPARSEABLE_RESP ""Bad Request\n""++#define HTTP1_DETAIL_MSG ""Connection dropped: received http1.x response""++#define HTTP2_DETAIL_MSG(STATUS_CODE) \+  ""Received http2 header with status: "" #STATUS_CODE++#define UNPARSEABLE_DETAIL_MSG \+  ""Connection dropped: received unparseable response""++struct rpc_state {+  char *target;+  grpc_completion_queue *cq;+  grpc_channel *channel;+  grpc_call *call;+  size_t incoming_data_length;+  gpr_slice_buffer temp_incoming_buffer;+  gpr_slice_buffer outgoing_buffer;+  grpc_endpoint *tcp;+  gpr_atm done_atm;+  bool write_done;+  const char *response_payload;+  size_t response_payload_length;+};++static int server_port;+static struct rpc_state state;+static grpc_closure on_read;+static grpc_closure on_write;++static void *tag(intptr_t t) { return (void *)t; }++static void done_write(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  GPR_ASSERT(error == GRPC_ERROR_NONE);++  gpr_atm_rel_store(&state.done_atm, 1);+}++static void handle_write(grpc_exec_ctx *exec_ctx) {+  gpr_slice slice = gpr_slice_from_copied_buffer(state.response_payload,+                                                 state.response_payload_length);++  gpr_slice_buffer_reset_and_unref(&state.outgoing_buffer);+  gpr_slice_buffer_add(&state.outgoing_buffer, slice);+  grpc_endpoint_write(exec_ctx, state.tcp, &state.outgoing_buffer, &on_write);+}++static void handle_read(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  GPR_ASSERT(error == GRPC_ERROR_NONE);+  state.incoming_data_length += state.temp_incoming_buffer.length;++  size_t i;+  for (i = 0; i < state.temp_incoming_buffer.count; i++) {+    char *dump = gpr_dump_slice(state.temp_incoming_buffer.slices[i],+                                GPR_DUMP_HEX | GPR_DUMP_ASCII);+    gpr_log(GPR_DEBUG, ""%s"", dump);+    gpr_free(dump);+  }++  gpr_log(GPR_DEBUG,+          ""got %"" PRIuPTR "" bytes, http2 connect string is %"" PRIuPTR "" bytes"",+          state.incoming_data_length, GRPC_CHTTP2_CLIENT_CONNECT_STRLEN);+  if (state.incoming_data_length > GRPC_CHTTP2_CLIENT_CONNECT_STRLEN) {+    handle_write(exec_ctx);+  } else {+    grpc_endpoint_read(exec_ctx, state.tcp, &state.temp_incoming_buffer,+                       &on_read);+  }+}++static void on_connect(grpc_exec_ctx *exec_ctx, void *arg, grpc_endpoint *tcp,+                       grpc_pollset *accepting_pollset,+                       grpc_tcp_server_acceptor *acceptor) {+  test_tcp_server *server = arg;+  grpc_closure_init(&on_read, handle_read, NULL);+  grpc_closure_init(&on_write, done_write, NULL);+  gpr_slice_buffer_init(&state.temp_incoming_buffer);+  gpr_slice_buffer_init(&state.outgoing_buffer);+  state.tcp = tcp;+  grpc_endpoint_add_to_pollset(exec_ctx, tcp, server->pollset);+  grpc_endpoint_read(exec_ctx, tcp, &state.temp_incoming_buffer, &on_read);+}++static gpr_timespec n_sec_deadline(int seconds) {+  return gpr_time_add(gpr_now(GPR_CLOCK_REALTIME),+                      gpr_time_from_seconds(seconds, GPR_TIMESPAN));+}++static void start_rpc(int target_port, grpc_status_code expected_status,+                      const char *expected_detail) {+  grpc_op ops[6];+  grpc_op *op;+  grpc_metadata_array initial_metadata_recv;+  grpc_metadata_array trailing_metadata_recv;",Likely you need to memset ops to quiet msan and call grpc_metadata_array_destroy() on the initial/trailing metadata_recv.,
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/6922,67921675,2016-06-21T18:11:23Z,src/objective-c/tests/GRPCClientTests.m,"@@ -303,7 +303,7 @@ - (void)testExceptions {    // Try to set parameters to nil for GRPCCall. This should cause an exception   @try {-    GRPCCall *call = [[GRPCCall alloc] initWithHost:nil+    GRPCCall *call __unused = [[GRPCCall alloc] initWithHost:nil",Removed object `call` and cast the expression to void to eliminate the 'expression result unused' warning.,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/6947,67962808,2016-06-21T22:17:58Z,include/grpc++/impl/codegen/async_stream.h,"@@ -52,11 +52,14 @@ class ClientAsyncStreamingInterface {    /// Request notification of the reading of the initial metadata. Completion   /// will be notified by \a tag on the associated completion queue.+  /// This call is optional, but if it is used, it cannot be used concurrently+  /// with Read   ///   /// \param[in] tag Tag identifying this request.   virtual void ReadInitialMetadata(void* tag) = 0; -  /// Request notification completion.+  /// Indicate that the stream is to be finished and request notification+  /// Should not be used concurrently with other operations","Since these are bidi streams, client-side finish isn't really like a read op; it really indicates the end. We don't view it as meaningful to write in parallel with finish. Finish is supposed to be called after read failure has happened.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6973,67977725,2016-06-22T00:37:59Z,src/core/lib/iomgr/network_status_tracker.c,"@@ -0,0 +1,82 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/lib/iomgr/endpoint.h""+#include <grpc/support/alloc.h>++typedef struct endpoint_ll_node {+  grpc_endpoint *ep;+  struct endpoint_ll_node *next;+} endpoint_ll_node;++static endpoint_ll_node *head = NULL;++// TODO(makarandd): Install callback with OS to monitor network status.+void grpc_initialize_network_status_monitor() {+}++void grpc_destroy_network_status_monitor() {+  for (endpoint_ll_node *curr = head; curr != NULL; ) {+    endpoint_ll_node *next = curr->next;+    gpr_free(curr);+    curr = next;+  }+}++void grpc_network_status_register_endpoint(grpc_endpoint *ep) {+  if (head == NULL) {+    head = (endpoint_ll_node *)gpr_malloc(sizeof(endpoint_ll_node));+    head->ep = ep;+    head->next = NULL;+  } else {+    endpoint_ll_node *prev_head = head;+    head = (endpoint_ll_node *)gpr_malloc(sizeof(endpoint_ll_node));+    head->ep = ep;+    head->next = prev_head;+  }+}++// Walk the linked-list from head and execute shutdown. It is possible that+// other threads might be in the process of shutdown as well, but that has+// no side effect.+void grpc_network_status_shutdown_all_endpoints() {+  if (head == NULL) {+    return;+  }+  grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;++  for (endpoint_ll_node *curr = head; curr != NULL; curr = curr->next) {+    curr->ep->vtable->shutdown(&exec_ctx, curr->ep);","ASAN output tells a story: https://grpc-testing.appspot.com/job/gRPC_pull_requests/10071/config=asan,language=c,platform=linux/consoleFull```===================================================================21487==ERROR: AddressSanitizer: heap-use-after-free on address 0x61400000fe40 at pc 0x0000005b810f bp 0x7ffe4ee84730 sp 0x7ffe4ee84728READ of size 8 at 0x61400000fe40 thread T0    #0 0x5b810e in grpc_network_status_shutdown_all_endpoints /var/local/git/grpc/src/core/lib/iomgr/network_status_tracker.c:79:15    #1 0x54cf18 in test_invoke_network_status_change /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:190:3    #2 0x54b9b2 in network_status_change /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:240:3    #3 0x4f56ee in grpc_end2end_tests /var/local/git/grpc/test/core/end2end/end2end_nosec_tests.c:308:7    #4 0x4f38d3 in main /var/local/git/grpc/test/core/end2end/fixtures/h2_census.c:127:5    #5 0x7f94c507ab44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)    #6 0x41c005 in _start (/var/local/git/grpc/bins/asan/h2_census_nosec_test+0x41c005)0x61400000fe40 is located 0 bytes inside of 408-byte region [0x61400000fe40,0x61400000ffd8)freed by thread T0 here:    #0 0x4c1a60 in __interceptor_free /llvm/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:38    #1 0x6a7368 in gpr_free /var/local/git/grpc/src/core/lib/support/alloc.c:68:3    #2 0x5c6743 in tcp_free /var/local/git/grpc/src/core/lib/iomgr/tcp_posix.c:120:3    #3 0x5c1b3d in tcp_unref /var/local/git/grpc/src/core/lib/iomgr/tcp_posix.c:148:5    #4 0x5c28f7 in tcp_destroy /var/local/git/grpc/src/core/lib/iomgr/tcp_posix.c:157:3    #5 0x5ab6e2 in grpc_endpoint_destroy /var/local/git/grpc/src/core/lib/iomgr/endpoint.c:62:3    #6 0x5a2f39 in finish /var/local/git/grpc/src/core/lib/http/httpcli.c:112:5    #7 0x5a298f in on_read /var/local/git/grpc/src/core/lib/http/httpcli.c:162:5    #8 0x5b4886 in grpc_exec_ctx_flush /var/local/git/grpc/src/core/lib/iomgr/exec_ctx.c:70:7    #9 0x73e021 in pollset_work /var/local/git/grpc/src/core/lib/iomgr/ev_poll_posix.c:989:22    #10 0x5b36f3 in grpc_pollset_work /var/local/git/grpc/src/core/lib/iomgr/ev_posix.c:197:10    #11 0x585b12 in grpc_pick_port_using_server /var/local/git/grpc/test/core/util/port_server_client.c:221:47    #12 0x581672 in grpc_pick_unused_port /var/local/git/grpc/test/core/util/port_posix.c:188:16    #13 0x58307f in grpc_pick_unused_port_or_die /var/local/git/grpc/test/core/util/port_posix.c:233:14    #14 0x4f3a53 in chttp2_create_fixture_fullstack /var/local/git/grpc/test/core/end2end/fixtures/h2_census.c:61:14    #15 0x54dea9 in begin_test /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:59:7    #16 0x54bd7a in test_invoke_network_status_change /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:112:7    #17 0x54b9b2 in network_status_change /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:240:3    #18 0x4f56ee in grpc_end2end_tests /var/local/git/grpc/test/core/end2end/end2end_nosec_tests.c:308:7    #19 0x4f38d3 in main /var/local/git/grpc/test/core/end2end/fixtures/h2_census.c:127:5    #20 0x7f94c507ab44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)previously allocated by thread T0 here:    #0 0x4c1d68 in malloc /llvm/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52    #1 0x6a7217 in gpr_malloc /var/local/git/grpc/src/core/lib/support/alloc.c:58:7    #2 0x5c0a2b in grpc_tcp_create /var/local/git/grpc/src/core/lib/iomgr/tcp_posix.c:458:31    #3 0x5c012b in on_writable /var/local/git/grpc/src/core/lib/iomgr/tcp_client_posix.c:193:13    #4 0x5b4886 in grpc_exec_ctx_flush /var/local/git/grpc/src/core/lib/iomgr/exec_ctx.c:70:7    #5 0x73e021 in pollset_work /var/local/git/grpc/src/core/lib/iomgr/ev_poll_posix.c:989:22    #6 0x5b36f3 in grpc_pollset_work /var/local/git/grpc/src/core/lib/iomgr/ev_posix.c:197:10    #7 0x585b12 in grpc_pick_port_using_server /var/local/git/grpc/test/core/util/port_server_client.c:221:47    #8 0x581672 in grpc_pick_unused_port /var/local/git/grpc/test/core/util/port_posix.c:188:16    #9 0x58307f in grpc_pick_unused_port_or_die /var/local/git/grpc/test/core/util/port_posix.c:233:14    #10 0x4f3a53 in chttp2_create_fixture_fullstack /var/local/git/grpc/test/core/end2end/fixtures/h2_census.c:61:14    #11 0x54dea9 in begin_test /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:59:7    #12 0x54bd7a in test_invoke_network_status_change /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:112:7    #13 0x54b9b2 in network_status_change /var/local/git/grpc/test/core/end2end/tests/network_status_change.c:240:3    #14 0x4f56ee in grpc_end2end_tests /var/local/git/grpc/test/core/end2end/end2end_nosec_tests.c:308:7    #15 0x4f38d3 in main /var/local/git/grpc/test/core/end2end/fixtures/h2_census.c:127:5    #16 0x7f94c507ab44 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b44)SUMMARY: AddressSanitizer: heap-use-after-free /var/local/git/grpc/src/core/lib/iomgr/network_status_tracker.c:79:15 in grpc_network_status_shutdown_all_endpointsShadow bytes around the buggy address:  0x0c287fff9f70: 00 00 00 00 00 00 00 00 00 00 00 fa fa fa fa fa  0x0c287fff9f80: fa fa fa fa fa fa fa fa 00 00 00 00 00 00 00 00  0x0c287fff9f90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  0x0c287fff9fa0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  0x0c287fff9fb0: 00 00 00 00 00 00 00 00 00 fa fa fa fa fa fa fa=>0x0c287fff9fc0: fa fa fa fa fa fa fa fa[fd]fd fd fd fd fd fd fd  0x0c287fff9fd0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd  0x0c287fff9fe0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd  0x0c287fff9ff0: fd fd fd fd fd fd fd fd fd fd fd fa fa fa fa fa  0x0c287fffa000: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa  0x0c287fffa010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes):  Addressable:           00  Partially addressable: 01 02 03 04 05 06 07   Heap left redzone:       fa  Heap right redzone:      fb  Freed heap region:       fd  Stack left redzone:      f1  Stack mid redzone:       f2  Stack right redzone:     f3  Stack partial redzone:   f4  Stack after return:      f5  Stack use after scope:   f8  Global redzone:          f9  Global init order:       f6  Poisoned by user:        f7  Container overflow:      fc  Array cookie:            ac  Intra object redzone:    bb  ASan internal:           fe  Left alloca redzone:     ca  Right alloca redzone:    cb==21487==ABORTING```",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/6973,67977878,2016-06-22T00:39:53Z,src/core/lib/iomgr/network_status_tracker.c,"@@ -0,0 +1,82 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/lib/iomgr/endpoint.h""+#include <grpc/support/alloc.h>++typedef struct endpoint_ll_node {+  grpc_endpoint *ep;+  struct endpoint_ll_node *next;+} endpoint_ll_node;++static endpoint_ll_node *head = NULL;++// TODO(makarandd): Install callback with OS to monitor network status.+void grpc_initialize_network_status_monitor() {+}++void grpc_destroy_network_status_monitor() {+  for (endpoint_ll_node *curr = head; curr != NULL; ) {+    endpoint_ll_node *next = curr->next;+    gpr_free(curr);+    curr = next;+  }+}++void grpc_network_status_register_endpoint(grpc_endpoint *ep) {+  if (head == NULL) {+    head = (endpoint_ll_node *)gpr_malloc(sizeof(endpoint_ll_node));+    head->ep = ep;+    head->next = NULL;+  } else {+    endpoint_ll_node *prev_head = head;+    head = (endpoint_ll_node *)gpr_malloc(sizeof(endpoint_ll_node));+    head->ep = ep;+    head->next = prev_head;+  }+}++// Walk the linked-list from head and execute shutdown. It is possible that+// other threads might be in the process of shutdown as well, but that has+// no side effect.+void grpc_network_status_shutdown_all_endpoints() {+  if (head == NULL) {+    return;+  }+  grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;++  for (endpoint_ll_node *curr = head; curr != NULL; curr = curr->next) {+    curr->ep->vtable->shutdown(&exec_ctx, curr->ep);","That sounds similar to an issue I had once with Ruby: call pointers were becoming invalid while corresponding batches were still pending, which led to what looked like memory corruption.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6991,67992868,2016-06-22T04:26:07Z,src/csharp/Grpc.Core.Tests/CompressionTest.cs,"@@ -118,5 +119,30 @@ public void WriteOptions_Unary()              await call.ResponseStream.ToListAsync();         }++        [Test]+        public void CanReadCompressedMessages()+        {+            var compressionMetadata = new Metadata+            {+                { new Metadata.Entry(""grpc-internal-encoding-request"", ""gzip"") }","Shouldn't this be encapsulated, like in the `CreateClientCompressionMetadata` method you use in other places?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6991,67993415,2016-06-22T04:36:48Z,src/csharp/Grpc.IntegrationTesting/InteropClient.cs,"@@ -618,11 +601,113 @@ public static void RunUnimplementedMethod(UnimplementedService.UnimplementedServ             Console.WriteLine(""Passed!"");         } +        public static void RunClientCompressedUnary(TestService.TestServiceClient client)+        {+            Console.WriteLine(""running client_compressed_unary"");+            var probeRequest = new SimpleRequest+            {+                ExpectCompressed = new BoolValue+                {+                    Value = true  // lie about compression+                },+                ResponseSize = 314159,+                Payload = CreateZerosPayload(271828)+            };+            var e = Assert.Throws<RpcException>(() => client.UnaryCall(probeRequest, CreateClientCompressionMetadata(false)));+            Assert.AreEqual(StatusCode.InvalidArgument, e.Status.StatusCode);++            var compressedRequest = new SimpleRequest+            {+                ExpectCompressed = new BoolValue+                {+                    Value = true+                },+                ResponseSize = 314159,+                Payload = CreateZerosPayload(271828)+            };+            var response1 = client.UnaryCall(compressedRequest, CreateClientCompressionMetadata(true));+            Assert.AreEqual(314159, response1.Payload.Body.Length);++            var uncompressedRequest = new SimpleRequest+            {+                ExpectCompressed = new BoolValue+                {+                    Value = false+                },+                ResponseSize = 314159,+                Payload = CreateZerosPayload(271828)+            };+            var response2 = client.UnaryCall(uncompressedRequest, CreateClientCompressionMetadata(false));+            Assert.AreEqual(314159, response2.Payload.Body.Length);++            Console.WriteLine(""Passed!"");+        }++        public static async Task RunClientCompressedStreamingAsync(TestService.TestServiceClient client)+        {+            Console.WriteLine(""running client_compressed_streaming"");+            try+            {+                var probeCall = client.StreamingInputCall(CreateClientCompressionMetadata(false));+                await probeCall.RequestStream.WriteAsync(new StreamingInputCallRequest+                {+                    ExpectCompressed = new BoolValue+                    {+                        Value = true+                    },+                    Payload = CreateZerosPayload(27182)+                });++                // cannot use Assert.ThrowsAsync because it uses Task.Wait and would deadlock.+                await probeCall;+                Assert.Fail();+            }+            catch (RpcException e)+            {+                Assert.AreEqual(StatusCode.InvalidArgument, e.Status.StatusCode);+            }++            var call = client.StreamingInputCall(CreateClientCompressionMetadata(true));+            await call.RequestStream.WriteAsync(new StreamingInputCallRequest+            {+                ExpectCompressed = new BoolValue+                {+                    Value = true+                },+                Payload = CreateZerosPayload(27182)+            });++            call.RequestStream.WriteOptions = new WriteOptions(WriteFlags.NoCompress);+            await call.RequestStream.WriteAsync(new StreamingInputCallRequest+            {+                ExpectCompressed = new BoolValue+                {+                    Value = false+                },+                Payload = CreateZerosPayload(45904)+            });+            await call.RequestStream.CompleteAsync();++            var response = await call.ResponseAsync;+            Assert.AreEqual(73086, response.AggregatedPayloadSize);++            Console.WriteLine(""Passed!"");+        }+         private static Payload CreateZerosPayload(int size)         {             return new Payload { Body = ByteString.CopyFrom(new byte[size]) };         } +        private static Metadata CreateClientCompressionMetadata(bool compressed)+        {+            var algorithmName = compressed ? ""gzip"" : ""identity"";+            return new Metadata+            {+                { new Metadata.Entry(""grpc-internal-encoding-request"", algorithmName) }",would it be possible to use `GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY` from https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/compression_types.h#L46?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6991,67993427,2016-06-22T04:37:00Z,src/csharp/Grpc.Core.Tests/CompressionTest.cs,"@@ -118,5 +119,30 @@ public void WriteOptions_Unary()              await call.ResponseStream.ToListAsync();         }++        [Test]+        public void CanReadCompressedMessages()+        {+            var compressionMetadata = new Metadata+            {+                { new Metadata.Entry(""grpc-internal-encoding-request"", ""gzip"") }","Actually, would it be possible to use `GRPC_COMPRESSION_REQUEST_ALGORITHM_MD_KEY` from https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/compression_types.h#L46?",
6081171,thunderboltsid,https://api.github.com/repos/grpc/grpc/pulls/6959,68115713,2016-06-22T19:08:05Z,tools/run_tests/run_tests.py,"@@ -440,11 +440,15 @@ def dockerfile_dir(self):   def _get_tox_envs(self, compiler):     """"""Returns name of tox environment based on selected compiler.""""""     if compiler == 'default':-      return ('py27', 'py34')+      return ('py27', 'py34', 'py35', 'py36')","@jtattermusch Currently, the dockerfiles are installing python versions using the package manager i.e. `apt-get install python-all-dev` and `apt-get install python3-all-dev`. If we want to test this code against recent python versions, we'll have to either add a [PPA](https://launchpad.net/~fkrull/+archive/ubuntu/deadsnakes) to the package manager and that can give us at least python 3.5 (not sure if it's the dev version) or start using [pyenv](https://github.com/yyuu/pyenv) to manage the installations of python versions. Any suggestions / recommendations?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7001,68268266,2016-06-23T16:34:03Z,src/python/grpcio/grpc/_channel.py,"@@ -212,7 +213,17 @@ def consume_request_iterator():         )         call.start_batch(cygrpc.Operations(operations), event_handler)         state.due.add(cygrpc.OperationType.send_close_from_client)-  thread = threading.Thread(target=consume_request_iterator)++  def stop_write_thread(timeout):","While the patient is on the table: the thread both consumes the request iterator and writes requests to the call, but since ""consume_and_write"" is too long a term, I just went with the consumption aspect. Maintain that consistency with names like `stop_consumption_thread` and `consumption_thread`? Or tell me I'm being too fussy?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7001,68270902,2016-06-23T16:49:36Z,src/python/grpcio/grpc/_channel.py,"@@ -652,16 +663,24 @@ def __init__(self, channel):     self.managed_calls = None  -def _call_spin(state):-  while True:-    event = state.completion_queue.poll()-    completed_call = event.tag(event)-    if completed_call is not None:-      with state.lock:-        state.managed_calls.remove(completed_call)-        if not state.managed_calls:-          state.managed_calls = None-          return+def _run_call_spin_thread(state):+  call_spin_running = True+  def call_spin():","`channel_spin` or `spin`, but not `call_spin` (and similarly for other names in this area).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7003,68280127,2016-06-23T17:40:17Z,src/core/lib/profiling/basic_timers.c,"@@ -141,7 +141,7 @@ static void write_log(gpr_timer_log *log) {       entry->tm = gpr_time_0(entry->tm.clock_type);     }     fprintf(output_file,-            ""{\""t\"": %lld.%09d, \""thd\"": \""%d\"", \""type\"": \""%c\"", \""tag\"": ""+            ""{\""t\"": %""PRId64"".%09d, \""thd\"": \""%d\"", \""type\"": \""%c\"", \""tag\"": ""             ""\""%s\"", \""file\"": \""%s\"", \""line\"": %d, \""imp\"": %d}\n"",             (long long)entry->tm.tv_sec, (int)entry->tm.tv_nsec, entry->thd,",Remove (long long) for tv_sec?,
9094670,tkchin,https://api.github.com/repos/grpc/grpc/pulls/6922,68445256,2016-06-24T18:53:17Z,src/objective-c/ProtoRPC/ProtoService.m,"@@ -69,9 +69,9 @@ - (ProtoRPC *)RPCToMethod:(NSString *)method            requestsWriter:(GRXWriter *)requestsWriter             responseClass:(Class)responseClass        responsesWriteable:(id<GRXWriteable>)responsesWriteable {-  ProtoMethod *methodName = [[ProtoMethod alloc] initWithPackage:_packageName-                                                         service:_serviceName-                                                          method:method];+  GRPCProtoMethod *methodName = [[GRPCProtoMethod alloc] initWithPackage:_packageName+                                                                 service:_serviceName+                                                                  method:method];   return [[ProtoRPC alloc] initWithHost:_host","Shouldn't grpc also be returning instances of GRPCProtoCall? The compiler generates methods that say GRPCProtoCall is returned, but in actuality it is returning a superclass. Caused some strange behavior for us because of some category methods we added.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7063,68476660,2016-06-24T23:34:46Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(test, x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(test, x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def __init__(self, test):+    self._test = test++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(self._test, False, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(self._test, True, True)+    else:+      return None+++class CompressionTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(weakref.proxy(self)),),+                               self._server_pool)+    self._port = self._server.add_insecure_port('[::]:0')+    self._server.start()++  def tearDown(self):+    self._server.stop(0)++  def testUnary(self):+    request = b'\x00' * 100++    # Client -> server compressed through default client channel compression+    # settings. Server -> client compressed via server-side metadata setting.+    compressed_channel = grpc.insecure_channel('localhost:%d' % self._port,+        options=[('grpc.default_compression_algorithm', 1)])","the ""1"" should ideally be replaced by a constant representing a compression algorithm from https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/compression_types.h#L57Perhaps this constant already exists somewhere in the Python codebase.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7063,68476688,2016-06-24T23:34:57Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(test, x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(test, x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def __init__(self, test):+    self._test = test++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(self._test, False, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(self._test, True, True)+    else:+      return None+++class CompressionTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(weakref.proxy(self)),),+                               self._server_pool)+    self._port = self._server.add_insecure_port('[::]:0')+    self._server.start()++  def tearDown(self):+    self._server.stop(0)++  def testUnary(self):+    request = b'\x00' * 100++    # Client -> server compressed through default client channel compression+    # settings. Server -> client compressed via server-side metadata setting.+    compressed_channel = grpc.insecure_channel('localhost:%d' % self._port,+        options=[('grpc.default_compression_algorithm', 1)])+    multi_callable = compressed_channel.unary_unary(_UNARY_UNARY)+    response = multi_callable(request)+    self.assertEqual(response, request)++    # Client -> server compressed through client metadata setting. Server ->+    # client compressed via server-side metadata setting.+    uncompressed_channel = grpc.insecure_channel('localhost:%d' % self._port,+        options=[('grpc.default_compression_algorithm', 0)])+    multi_callable = compressed_channel.unary_unary(_UNARY_UNARY)+    response = multi_callable(request, metadata=[+      ('grpc-internal-encoding-request', 'gzip')])+    self.assertEqual(response, request)+++  def testStreaming(self):+    request = b'\x00' * 100++    compressed_channel = grpc.insecure_channel('localhost:%d' % self._port,+        options=[('grpc.default_compression_algorithm', 1)])","the ""1"" should ideally be replaced by a constant representing a compression algorithm from https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/compression_types.h#L57Perhaps this constant already exists somewhere in the Python codebase.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7063,68476756,2016-06-24T23:35:32Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(test, x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(test, x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def __init__(self, test):+    self._test = test++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(self._test, False, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(self._test, True, True)+    else:+      return None+++class CompressionTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(weakref.proxy(self)),),+                               self._server_pool)+    self._port = self._server.add_insecure_port('[::]:0')+    self._server.start()++  def tearDown(self):+    self._server.stop(0)++  def testUnary(self):+    request = b'\x00' * 100++    # Client -> server compressed through default client channel compression+    # settings. Server -> client compressed via server-side metadata setting.+    compressed_channel = grpc.insecure_channel('localhost:%d' % self._port,+        options=[('grpc.default_compression_algorithm', 1)])+    multi_callable = compressed_channel.unary_unary(_UNARY_UNARY)+    response = multi_callable(request)+    self.assertEqual(response, request)++    # Client -> server compressed through client metadata setting. Server ->+    # client compressed via server-side metadata setting.+    uncompressed_channel = grpc.insecure_channel('localhost:%d' % self._port,+        options=[('grpc.default_compression_algorithm', 0)])","the ""0"" should ideally be replaced by a constant representing a compression algorithm from https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/compression_types.h#L57Perhaps this constant already exists somewhere in the Python codebase.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7063,68476970,2016-06-24T23:38:36Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):",Drop unused parameter `test`.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7063,68476977,2016-06-24T23:38:48Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):",Drop unused parameter `test`.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7063,68477003,2016-06-24T23:39:09Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):",`test` will become unused; drop it.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7063,68477014,2016-06-24T23:39:25Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(test, x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(test, x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def __init__(self, test):",`test` will become unused; drop it.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7063,68477035,2016-06-24T23:39:44Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,136 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side metadata API.""""""++import unittest+import weakref++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(test, request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(test, request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, test, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(test, x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(test, x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def __init__(self, test):+    self._test = test",`_test` will become unused; drop it.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7063,68490684,2016-06-25T16:42:40Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,133 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side compression.""""""++import unittest++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(False, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(True, True)+    else:+      return None+++class CompressionTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(),), self._server_pool)+    self._port = self._server.add_insecure_port('[::]:0')+    self._server.start()++  def testUnary(self):+    request = b'\x00' * 100",is that big enough for compression to kick in?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7063,68492238,2016-06-25T18:43:34Z,src/python/grpcio/tests/unit/_compression_test.py,"@@ -0,0 +1,133 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+""""""Tests server and client side compression.""""""++import unittest++import grpc+from grpc import _grpcio_metadata+from grpc.framework.foundation import logging_pool++from tests.unit import test_common+from tests.unit.framework.common import test_constants++_UNARY_UNARY = b'/test/UnaryUnary'+_STREAM_STREAM = b'/test/StreamStream'+++def handle_unary(request, servicer_context):+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  return request+++def handle_stream(request_iterator, servicer_context):+  # TODO(issue:#6891) We should be able to remove this loop,+  # and replace with return; yield+  servicer_context.send_initial_metadata([+    ('grpc-internal-encoding-request', 'gzip')])+  for request in request_iterator:+    yield request+++class _MethodHandler(grpc.RpcMethodHandler):++  def __init__(self, request_streaming, response_streaming):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = None+    self.response_serializer = None+    self.unary_unary = None+    self.unary_stream = None+    self.stream_unary = None+    self.stream_stream = None+    if self.request_streaming and self.response_streaming:+      self.stream_stream = lambda x, y: handle_stream(x, y)+    elif not self.request_streaming and not self.response_streaming:+      self.unary_unary = lambda x, y: handle_unary(x, y)+++class _GenericHandler(grpc.GenericRpcHandler):++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(False, False)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(True, True)+    else:+      return None+++class CompressionTest(unittest.TestCase):++  def setUp(self):+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)+    self._server = grpc.server((_GenericHandler(),), self._server_pool)+    self._port = self._server.add_insecure_port('[::]:0')+    self._server.start()++  def testUnary(self):+    request = b'\x00' * 100","Yes, especially when the amount of entropy is so low.On Sat, Jun 25, 2016 at 9:42 AM, Jan Tattermusch notifications@github.comwrote:> In src/python/grpcio/tests/unit/_compression_test.py> https://github.com/grpc/grpc/pull/7063#discussion_r68490684:> > > -    elif handler_call_details.method == _STREAM_STREAM:> > -      return _MethodHandler(True, True)> > -    else:> > -      return None> >   +> >   +> >   +class CompressionTest(unittest.TestCase):> >   +> > -  def setUp(self):> > -    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)> > -    self._server = grpc.server((_GenericHandler(),), self._server_pool)> > -    self._port = self._server.add_insecure_port('[::]:0')> > -    self._server.start()> >   +> > -  def testUnary(self):> > -    request = b'\x00' \* 100> > is that big enough for compression to kick in?> > —> You are receiving this because you authored the thread.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7063/files/6e789893ea72b24ed664dcf3e14ab979b52de16a#r68490684,> or mute the thread> https://github.com/notifications/unsubscribe/AAHVmX62p4OWXlTgiL4H1Q6wU8U0p_5Rks5qPVqRgaJpZM4I-M__> .",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6644,68624467,2016-06-27T17:57:27Z,src/core/lib/iomgr/socket_utils_common_posix.c,"@@ -169,6 +169,28 @@ grpc_error *grpc_set_socket_reuse_addr(int fd, int reuse) {   return GRPC_ERROR_NONE; } +/* set a socket to reuse old addresses */+grpc_error *grpc_set_socket_reuse_port(int fd, int reuse) {+#ifndef SO_REUSEPORT+  return GRPC_ERROR_CREATE(""SO_REUSEPORT unavailable on compiling system"");+#else+  int val = (reuse != 0);+  int newval;+  socklen_t intlen = sizeof(newval);+  if (0 != setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val))) {+    return GRPC_OS_ERROR(errno, ""setsockopt(SO_REUSEPORT)"");+  }+  if (0 != getsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &newval, &intlen)) {+    return GRPC_OS_ERROR(errno, ""getsockopt(SO_REUSEPORT)"");+  }+  if ((newval != 0) != val) {","I'm not sure it's specified that 1 is true in this case (and similar hastripped us before on some platforms), hence the extra care.On Mon, Jun 27, 2016, 10:37 AM Sree Kuchibhotla notifications@github.comwrote:> In src/core/lib/iomgr/socket_utils_common_posix.c> https://github.com/grpc/grpc/pull/6644#discussion_r68620746:> > > @@ -169,6 +169,28 @@ grpc_error *grpc_set_socket_reuse_addr(int fd, int reuse) {> >    return GRPC_ERROR_NONE;> >  }> > > > +/\* set a socket to reuse old addresses */> > +grpc_error *grpc_set_socket_reuse_port(int fd, int reuse) {> > +#ifndef SO_REUSEPORT> > -  return GRPC_ERROR_CREATE(""SO_REUSEPORT unavailable on compiling system"");> >   +#else> > -  int val = (reuse != 0);> > -  int newval;> > -  socklen_t intlen = sizeof(newval);> > -  if (0 != setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val))) {> > -    return GRPC_OS_ERROR(errno, ""setsockopt(SO_REUSEPORT)"");> > -  }> > -  if (0 != getsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &newval, &intlen)) {> > -    return GRPC_OS_ERROR(errno, ""getsockopt(SO_REUSEPORT)"");> > -  }> > -  if ((newval != 0) != val) {> > Wouldn't checking (newval != val) be enough here ?> > —> You are receiving this because you authored the thread.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/6644/files/f467846b1b6910c2fe6cf5c9802baafd3deb5186#r68620746,> or mute the thread> https://github.com/notifications/unsubscribe/AJpudTYF2hfL0SUg9lzKw72aDxv_V8xnks5qQApHgaJpZM4Ih8u2> .",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,68681768,2016-06-28T00:46:42Z,src/python/grpcio/grpc/_common.py,"@@ -75,12 +75,41 @@         CYGRPC_STATUS_CODE_TO_STATUS_CODE) } +def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      return b.decode('latin1')+ -def metadata(application_metadata):+def grpc_metadata(application_metadata):","Consider renaming this ""cygrpc_metadata""?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,68681797,2016-06-28T00:47:06Z,src/python/grpcio/grpc/_common.py,"@@ -75,12 +75,41 @@         CYGRPC_STATUS_CODE_TO_STATUS_CODE) } +def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      return b.decode('latin1')+ -def metadata(application_metadata):+def grpc_metadata(application_metadata):   return _EMPTY_METADATA if application_metadata is None else cygrpc.Metadata(-      cygrpc.Metadatum(key, value) for key, value in application_metadata)+      cygrpc.Metadatum(encode(key), encode(value))+          for key, value in application_metadata)  +def application_metadata(grpc_metadata):","Consider renaming this function's parameter ""cygrpc_metadata""?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7102,68795553,2016-06-28T16:46:54Z,src/csharp/Grpc.Examples.MathClient/project.json,"@@ -5,6 +5,10 @@   ""configurations"": {     ""Debug"": {       ""buildOptions"": {+        ""define"": [ ""SIGNED"" ],","For most of the project.json files, the duplicated values are actually generated from a template.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7076,68804627,2016-06-28T17:36:26Z,src/python/grpcio/grpc/__init__.py,"@@ -721,6 +768,26 @@ def peer(self):     raise NotImplementedError()    @abc.abstractmethod+  def parent(self, child=None, census=None):+    """"""Creates a value to associate invoked RPCs with the current RPC.++    This method's parameters have no guaranteed defaults; if either True or+    False is desired for the value of an argument the argument should be+    explicitly passed.++    Args:+      child: An optional boolean indicating whether or not the invoked RPC","What census information gets propagated when child=False?  If it is possible to propagate census data as a root, I think it would be more natural to have some client side API that exposes that.",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/7081,68827010,2016-06-28T19:34:46Z,.travis.yml,"@@ -16,20 +41,24 @@ before_install:   - popd install:   - make grpc_objective_c_plugin-  - pushd src/objective-c/tests+  - install bins/opt/grpc_objective_c_plugin /usr/local/bin/protoc-gen-objcgrpc+  - install bins/opt/protobuf/protoc /usr/local/bin/protoc+  - pushd $TEST_PATH   - pod install   - popd before_script:-  - make interop_server-  - bins/$CONFIG/interop_server --port=5050 &-  - bins/$CONFIG/interop_server --port=5051 --use_tls &-xcode_workspace: src/objective-c/tests/Tests.xcworkspace-xcode_scheme:-  - RxLibraryUnitTests-  - InteropTestsLocalSSL-  - InteropTestsLocalCleartext-  # TODO(jcanizales): Investigate why they time out:-  # - InteropTestsRemote-xcode_sdk: iphonesimulator9.3+  - if [ ""${INTEROP_SERVER}"" = ""true"" ]; then+      make interop_server;+      (bins/$CONFIG/interop_server --port=5050 &);+      (bins/$CONFIG/interop_server --port=5051 --use_tls &);+    fi+script:+  - if [ ""${BUILD_ONLY}"" = ""true"" ]; then+      xctool -workspace ""$TEST_PATH/$WORKSPACE"" -scheme ""$SCHEME""+      -sdk iphonesimulator9.3 clean build;+    else+      xctool -workspace ""$TEST_PATH/$WORKSPACE"" -scheme ""$SCHEME""+      -sdk iphonesimulator9.3 build test;",Removed `build`. I was trying to use the same command as in https://github.com/travis-ci/travis-build/blob/master/lib/travis/build/script/objective_c.rb#L82,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7076,68839681,2016-06-28T20:45:42Z,src/python/grpcio/grpc/__init__.py,"@@ -721,6 +768,26 @@ def peer(self):     raise NotImplementedError()    @abc.abstractmethod+  def parent(self, child=None, census=None):+    """"""Creates a value to associate invoked RPCs with the current RPC.++    This method's parameters have no guaranteed defaults; if either True or+    False is desired for the value of an argument the argument should be+    explicitly passed.++    Args:+      child: An optional boolean indicating whether or not the invoked RPC","At the Core API level, census information only gets propagated by a call to `grpc_census_call_set_context`, and from the way that API looks I gather that census propagation is completely independent of parent-child relationship. That's why they're two independent parameters in this method.I don't understand what you mean by ""root""?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7076,68842905,2016-06-28T21:03:43Z,src/python/grpcio/grpc/__init__.py,"@@ -721,6 +768,26 @@ def peer(self):     raise NotImplementedError()    @abc.abstractmethod+  def parent(self, child=None, census=None):+    """"""Creates a value to associate invoked RPCs with the current RPC.++    This method's parameters have no guaranteed defaults; if either True or+    False is desired for the value of an argument the argument should be+    explicitly passed.++    Args:+      child: An optional boolean indicating whether or not the invoked RPC","I think the issue here might be the name of this method and the value that it returns - if parenthood and census propagation are independent, maybe this method should be `ServicerContext.association(child=None, census=None)` and the value it returns be an instance of `Association` and then RPCs get invoked as `my_response = my_stub.MyRpcMethod(my_request, association=my_association)`.@ctiller, @jtattermusch: what do you think?",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7076,68844409,2016-06-28T21:12:16Z,src/python/grpcio/grpc/__init__.py,"@@ -721,6 +768,26 @@ def peer(self):     raise NotImplementedError()    @abc.abstractmethod+  def parent(self, child=None, census=None):+    """"""Creates a value to associate invoked RPCs with the current RPC.++    This method's parameters have no guaranteed defaults; if either True or+    False is desired for the value of an argument the argument should be+    explicitly passed.++    Args:+      child: An optional boolean indicating whether or not the invoked RPC","Beyond naming though, is it valid to create an association without having access to a `ServicerContext` i.e. client side census data?",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7076,68858839,2016-06-28T22:55:33Z,src/python/grpcio/grpc/__init__.py,"@@ -721,6 +768,26 @@ def peer(self):     raise NotImplementedError()    @abc.abstractmethod+  def parent(self, child=None, census=None):+    """"""Creates a value to associate invoked RPCs with the current RPC.++    This method's parameters have no guaranteed defaults; if either True or+    False is desired for the value of an argument the argument should be+    explicitly passed.++    Args:+      child: An optional boolean indicating whether or not the invoked RPC","Here's what I imagined in c-code:```census_context* ctx = census_context_create(NULL, tags, ntags, status)grpc_call* call = grpc_channel_create_call(channel, NULL, flags, completion_queue, method, host, deadline, NULL)grpc_census_call_set_context(call, ctx)....```Which seems like it could be done from the client side.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7076,68985831,2016-06-29T16:59:37Z,src/python/grpcio/grpc/__init__.py,"@@ -421,29 +423,50 @@ def __call__(self, context, callback): class ServerCredentials(object):   """"""A value encapsulating the data required to open a secure port on a Server. -  This class has no supported interface - it exists to define the type of its-  instances and its instances exist to be passed to other functions.+  This class has no supported interface - not even construction. It exists to+  define the type of its instances and its instances exist to be passed to+  other functions.   """"""    def __init__(self, credentials):     self._credentials = credentials  +#################################  Parent  #####################################+++class Parent(object):",nit: maybe a too general name for a pretty specific concept?FYI in C# a similar concept is called ContextPropagationToken.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7076,68986151,2016-06-29T17:01:44Z,src/python/grpcio/grpc/__init__.py,"@@ -421,29 +423,50 @@ def __call__(self, context, callback): class ServerCredentials(object):   """"""A value encapsulating the data required to open a secure port on a Server. -  This class has no supported interface - it exists to define the type of its-  instances and its instances exist to be passed to other functions.+  This class has no supported interface - not even construction. It exists to+  define the type of its instances and its instances exist to be passed to+  other functions.   """"""    def __init__(self, credentials):     self._credentials = credentials  +#################################  Parent  #####################################+++class Parent(object):+  """"""An object used to chain RPCs.",You might wanna describe what's the results of chaining.1. does parent call's deadline get propagated?2. does parent call's cancellation get propagated?,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7076,68986483,2016-06-29T17:03:56Z,src/python/grpcio/grpc/__init__.py,"@@ -421,29 +423,50 @@ def __call__(self, context, callback): class ServerCredentials(object):   """"""A value encapsulating the data required to open a secure port on a Server. -  This class has no supported interface - it exists to define the type of its-  instances and its instances exist to be passed to other functions.+  This class has no supported interface - not even construction. It exists to+  define the type of its instances and its instances exist to be passed to+  other functions.   """"""    def __init__(self, credentials):     self._credentials = credentials  +#################################  Parent  #####################################+++class Parent(object):+  """"""An object used to chain RPCs.","C# allows to specify ""ContextPropagationOptions"" where you decide what you want to propagate (deadline, cancellation, census stuff will be added later).",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7120,68986697,2016-06-29T17:05:23Z,src/objective-c/GRPCClient/private/NSData+GRPC.m,"@@ -71,7 +71,7 @@ + (instancetype)grpc_dataWithByteBuffer:(grpc_byte_buffer *)buffer {   }   char *array;   NSUInteger length;-  MallocAndCopyByteBufferToCharArray(buffer, &length, &array);+  MallocAndCopyByteBufferToCharArray(buffer, (size_t *)&length, &array);","This fools `MallocAndCopyByteBufferToCharArray` into thinking it can write memory beyond what is allocated in the stack for `length` (`NSUInteger` is an `int` and `size_t` is a `long`). Because the size of the response is controlled by the server (and more so because `MallocAndCopyByteBufferToCharArray` is decompressing), it makes a server able to crash the client, which is a bug.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6915,69025696,2016-06-29T20:54:25Z,include/grpc++/channel_filter.h,"@@ -0,0 +1,365 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc++/impl/codegen/config.h>+#include <grpc/census.h>+#include <grpc/grpc.h>++#include <functional>+#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/security/context/security_context.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""src/core/lib/transport/metadata_batch.h""++//+// An interface to define filters.+//+// To define a filter, implement a subclass of each of CallData and+// ChannelData.  Then register the filter using something like this:+//   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+//       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);+//++namespace grpc {++// A C++ wrapper for the grpc_metadata_batch struct.+class MetadataBatch {+ public:+  explicit MetadataBatch(grpc_metadata_batch *batch) : batch_(batch) {}++  grpc_metadata_batch *batch() const { return batch_; }",maybe we'd want a version of `batch()` returning a constant pointer? That'd allow for const instances of `MetadataBatch`.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6915,69037601,2016-06-29T22:08:24Z,include/grpc++/channel_filter.h,"@@ -0,0 +1,365 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc++/impl/codegen/config.h>+#include <grpc/census.h>+#include <grpc/grpc.h>++#include <functional>+#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/security/context/security_context.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""src/core/lib/transport/metadata_batch.h""++//+// An interface to define filters.+//+// To define a filter, implement a subclass of each of CallData and+// ChannelData.  Then register the filter using something like this:+//   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+//       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);+//++namespace grpc {++// A C++ wrapper for the grpc_metadata_batch struct.+class MetadataBatch {+ public:+  explicit MetadataBatch(grpc_metadata_batch *batch) : batch_(batch) {}++  grpc_metadata_batch *batch() const { return batch_; }","I don't anticipate this being used anywhere other than a filter, and since we don't know whether or not a given filter will want to modify metadata, we need to pass it in as non-const.  So it doesn't seem like there's any immediate benefit in a const method.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7076,69037761,2016-06-29T22:09:37Z,src/python/grpcio/grpc/__init__.py,"@@ -421,29 +423,50 @@ def __call__(self, context, callback): class ServerCredentials(object):   """"""A value encapsulating the data required to open a secure port on a Server. -  This class has no supported interface - it exists to define the type of its-  instances and its instances exist to be passed to other functions.+  This class has no supported interface - not even construction. It exists to+  define the type of its instances and its instances exist to be passed to+  other functions.   """"""    def __init__(self, credentials):     self._credentials = credentials  +#################################  Parent  #####################################+++class Parent(object):+  """"""An object used to chain RPCs.",Agreed; will propose changing the place where instances of this class are made available to applications to operate on a per-propagated-quality basis.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7076,69038372,2016-06-29T22:14:28Z,src/python/grpcio/grpc/__init__.py,"@@ -721,6 +768,26 @@ def peer(self):     raise NotImplementedError()    @abc.abstractmethod+  def parent(self, child=None, census=None):","@ctiller, @jtattermusch: would this method better match the capabilities delivered elsewhere in gRPC if it were changed to offer one-parameter-per-propagateable-thing? As in:```def association(    self, deadline=None, census_stats=None, census_tracing=None,    cancellation=None):```(that parameter order comes from [this order](https://github.com/grpc/grpc/blob/01d7dbac1f747ca45135f1d79c38656db0701ec6/include/grpc/impl/codegen/propagation_bits.h#L46); feel invited to request a better one).",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7091,69040924,2016-06-29T22:35:13Z,src/python/grpcio/grpc/_common.py,"@@ -76,9 +76,41 @@ }  -def metadata(application_metadata):+def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')","Definitely not a stupid question:In all the places where we encode on behalf of the user, the string is required to an ascii string, ie method names/message details/metadata keys/values.  This will fail fast if they don't satisfy that contract.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,69049387,2016-06-29T23:58:01Z,src/python/grpcio/grpc/_common.py,"@@ -76,9 +76,41 @@ }  -def metadata(application_metadata):+def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      logging.exception('Invalid encoding on {}'.format(b))+      return b.decode('latin1')+++def cygrpc_metadata(application_metadata):   return _EMPTY_METADATA if application_metadata is None else cygrpc.Metadata(-      cygrpc.Metadatum(key, value) for key, value in application_metadata)+      cygrpc.Metadatum(encode(key), encode(value))+          for key, value in application_metadata)+++def application_metadata(cygrpc_metadata):+  if cygrpc_metadata is None:+    return []","Never write a list where a tuple (or generator expression, or something even simpler) will do. Can this be `()`?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,69049548,2016-06-29T23:59:54Z,src/python/grpcio/grpc/_common.py,"@@ -76,9 +76,41 @@ }  -def metadata(application_metadata):+def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      logging.exception('Invalid encoding on {}'.format(b))+      return b.decode('latin1')+++def cygrpc_metadata(application_metadata):   return _EMPTY_METADATA if application_metadata is None else cygrpc.Metadata(-      cygrpc.Metadatum(key, value) for key, value in application_metadata)+      cygrpc.Metadatum(encode(key), encode(value))+          for key, value in application_metadata)+++def application_metadata(cygrpc_metadata):+  if cygrpc_metadata is None:+    return []+  else:+    result = []","""result"" is almost always a bad name (along with ""ret""). How about ""decoded_metadata""?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,69049671,2016-06-30T00:01:17Z,src/python/grpcio/grpc/_common.py,"@@ -76,9 +76,41 @@ }  -def metadata(application_metadata):+def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      logging.exception('Invalid encoding on {}'.format(b))+      return b.decode('latin1')+++def cygrpc_metadata(application_metadata):   return _EMPTY_METADATA if application_metadata is None else cygrpc.Metadata(-      cygrpc.Metadatum(key, value) for key, value in application_metadata)+      cygrpc.Metadatum(encode(key), encode(value))+          for key, value in application_metadata)+++def application_metadata(cygrpc_metadata):+  if cygrpc_metadata is None:+    return []+  else:+    result = []+    for key, value in cygrpc_metadata:+      if key[-4:] == b'-bin':+        result.append((decode(key), value))+      else:+        result.append((decode(key), decode(value)))+    return result",How about `return tuple(decoded_metadata)`? Let's avoid returning a mutable value unless we're aware of some use case that really warrants it?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,69051088,2016-06-30T00:16:53Z,src/python/grpcio/grpc/_common.py,"@@ -76,9 +76,41 @@ }  -def metadata(application_metadata):+def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      logging.exception('Invalid encoding on {}'.format(b))+      return b.decode('latin1')+++def cygrpc_metadata(application_metadata):   return _EMPTY_METADATA if application_metadata is None else cygrpc.Metadata(-      cygrpc.Metadatum(key, value) for key, value in application_metadata)+      cygrpc.Metadatum(encode(key), encode(value))+          for key, value in application_metadata)+++def application_metadata(cygrpc_metadata):+  if cygrpc_metadata is None:+    return []+  else:+    result = []+    for key, value in cygrpc_metadata:","```return tuple(    (decode(key), value if key[-4:] == b'-bin' else decode(value))    for key, value in cygrpc_metadata)```isn't too unattractive, is it?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7091,69052920,2016-06-30T00:38:27Z,src/python/grpcio/grpc/_common.py,"@@ -76,9 +76,36 @@ }  -def metadata(application_metadata):+def encode(s):+  if isinstance(s, bytes):+    return s+  else:+    return s.encode('ascii')+++def decode(b):+  if isinstance(b, str):+    return b+  else:+    try:+      return b.decode('utf8')+    except UnicodeDecodeError:+      logging.exception('Invalid encoding on {}'.format(b))+      return b.decode('latin1')+++def cygrpc_metadata(application_metadata):   return _EMPTY_METADATA if application_metadata is None else cygrpc.Metadata(-      cygrpc.Metadatum(key, value) for key, value in application_metadata)+      cygrpc.Metadatum(encode(key), encode(value))+          for key, value in application_metadata)+++def application_metadata(cygrpc_metadata):+  if cygrpc_metadata is None:+    return ()+  return tuple(",Always favor```if <condition>:  <statements>  return <expression>else:  <other statements>  return <other expression>```over```if <condition>:  <statements>  return <expression><other statements>return <other expression>```.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7109,69155627,2016-06-30T15:33:33Z,src/compiler/python_generator.cc,"@@ -66,6 +66,9 @@ using std::vector;  namespace grpc_python_generator { +GeneratorConfiguration::GeneratorConfiguration()","Public data members not good enough for ya, eh? If it's strongly desired, sure, that can happen.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7190,69234733,2016-07-01T01:01:38Z,src/objective-c/GRPCClient/private/NSData+GRPC.m,"@@ -42,7 +42,11 @@ static void MallocAndCopyByteBufferToCharArray(grpc_byte_buffer *buffer,                                                size_t *length, char **array) {   grpc_byte_buffer_reader reader;-  grpc_byte_buffer_reader_init(&reader, buffer);+  if (!grpc_byte_buffer_reader_init(&reader, buffer)) {",Please add a comment explaining that `grpc_byte_buffer_reader_init` can fail if the data sent by the server could not be decompressed for any reason; that the server is to blame; and thus we want the RPC to fail with error code `INTERNAL`.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/6791,69324174,2016-07-01T16:23:12Z,setup.py,"@@ -119,9 +116,13 @@ # For Python3.4, this is OSX 10.6, but we need Thread Local Support (__thread) if 'darwin' in sys.platform and PY3:   mac_target = sysconfig.get_config_var('MACOSX_DEPLOYMENT_TARGET')+  # The working computer's mac os x version defines what frameworks are+  # available to build against.+  mac_version = platform.mac_ver()[0]","I got errors building locally against 10.7 (missing standard library header files). If that sounds familiar to you and you have an environment fix s.t. the proper configuration is the builder's responsibility, I'd be more than happy to go back to 10.7.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7170,69372819,2016-07-02T05:17:18Z,src/python/grpcio/grpc/__init__.py,"@@ -299,6 +300,20 @@ def add_callback(self, callback):     raise NotImplementedError()  +############################  gRPC Metadata  ##################################+++class Metadatum(collections.namedtuple('Metadatum', ('key', 'value'))):","While it's true that we have a few concrete classes in the API they're all instances of our having been forced to have them by the shape of the underlying core API. That isn't the case here, so this should be an interface.`HandlerCallDetails` would be a good example after which to model this class except for where I forgot the mandatory blank line in its doc string. :-P",
6081171,thunderboltsid,https://api.github.com/repos/grpc/grpc/pulls/7112,69629231,2016-07-05T20:13:08Z,tools/dockerfile/test/python_pyenv_x64/Dockerfile,"@@ -0,0 +1,115 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++FROM debian:jessie","Running the script currently results in the following stack trace:```Traceback (most recent call last):  File ""src/boringssl/gen_build_yaml.py"", line 163, in <module>    generate_build_files.main([g])  File ""/Users/siddharthshukla/grpc_forks/thunderboltsid/grpc/third_party/boringssl/util/generate_build_files.py"", line 468, in main    stdout=err_data)  File ""/Users/siddharthshukla/.pyenv/versions/2.7-dev/lib/python2.7/subprocess.py"", line 536, in check_call    retcode = call(*popenargs, **kwargs)  File ""/Users/siddharthshukla/.pyenv/versions/2.7-dev/lib/python2.7/subprocess.py"", line 523, in call    return Popen(*popenargs, **kwargs).wait()  File ""/Users/siddharthshukla/.pyenv/versions/2.7-dev/lib/python2.7/subprocess.py"", line 711, in __init__    errread, errwrite)  File ""/Users/siddharthshukla/.pyenv/versions/2.7-dev/lib/python2.7/subprocess.py"", line 1343, in _execute_child    raise child_exceptionOSError: [Errno 2] No such file or directory```",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7216,69784459,2016-07-06T18:24:15Z,src/ruby/ext/grpc/rb_compression_options.c,"@@ -0,0 +1,351 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <ruby/ruby.h>++#include ""rb_compression_options.h""+#include ""rb_grpc_imports.generated.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>+#include <grpc/impl/codegen/compression_types.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <string.h>++#include ""rb_grpc.h""++static VALUE grpc_rb_cCompressionOptions = Qnil;++/* grpc_rb_compression_options wraps a grpc_compression_options.+ * Note that ruby objects of this type don't carry any state in other+ * Ruby objects and don't have a mark for GC. */+typedef struct grpc_rb_compression_options {+  /* The actual compression options that's being wrapped */+  grpc_compression_options *wrapped;+} grpc_rb_compression_options;++/* Destroys the compression options instances and free the+ * wrapped grpc compression options. */+static void grpc_rb_compression_options_free(void *p) {+  grpc_rb_compression_options *wrapper = NULL;+  if (p == NULL) {+    return;+  };+  wrapper = (grpc_rb_compression_options *)p;++  if (wrapper->wrapped != NULL) {+    gpr_free(wrapper->wrapped);+    wrapper->wrapped = NULL;+  }++  xfree(p);+}++/* Ruby recognized data type for the CompressionOptions class. */+static rb_data_type_t grpc_rb_compression_options_data_type = {+    ""grpc_compression_options"",+    {NULL,+     grpc_rb_compression_options_free,+     GRPC_RB_MEMSIZE_UNAVAILABLE,+     {NULL, NULL}},+    NULL,+    NULL,+#ifdef RUBY_TYPED_FREE_IMMEDIATELY+    RUBY_TYPED_FREE_IMMEDIATELY+#endif+};++/* Allocates CompressionOptions instances.+   Allocate the wrapped grpc compression options and+   initialize it here too. */+static VALUE grpc_rb_compression_options_alloc(VALUE cls) {+  grpc_rb_compression_options *wrapper =+      gpr_malloc(sizeof(grpc_rb_compression_options));+  wrapper->wrapped = NULL;+  wrapper->wrapped = gpr_malloc(sizeof(grpc_compression_options));+  grpc_compression_options_init(wrapper->wrapped);++  return TypedData_Wrap_Struct(cls, &grpc_rb_compression_options_data_type,+                               wrapper);+}++/* Disables a compression algorithm, given the GRPC core internal number of a+ * compression algorithm. */+VALUE grpc_rb_compression_options_disable_compression_algorithm_internal(+    VALUE self, VALUE algorithm_to_disable) {+  grpc_compression_algorithm compression_algorithm = 0;+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_algorithm =+      (grpc_compression_algorithm)NUM2INT(algorithm_to_disable);++  grpc_compression_options_disable_algorithm(wrapper->wrapped,+                                             compression_algorithm);++  return Qnil;+}++/* Provides a bitset as a ruby number that is suitable to pass to+ * the GRPC core as a channel argument to enable compression algorithms. */+VALUE grpc_rb_compression_options_get_enabled_algorithms_bitset(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  return INT2NUM((int)wrapper->wrapped->enabled_algorithms_bitset);+}++void grpc_rb_compression_options_set_default_level_helper(+    grpc_compression_options *compression_options,+    grpc_compression_level level) {+  compression_options->default_level.is_set |= 1;+  compression_options->default_level.level = level;+}++/* Sets the default compression level, given the name of a compression level.+ * Throws an error if no algorithm matched. */+VALUE grpc_rb_compression_options_set_default_level(VALUE self,+                                                    VALUE new_level) {+  char *level_name = NULL;+  grpc_rb_compression_options *wrapper = NULL;+  long name_len = 0;+  VALUE ruby_str = Qnil;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  /* Take both string and symbol parameters */+  ruby_str = rb_funcall(new_level, rb_intern(""to_s""), 0);","I think it would make sense for this function to accept only symbol parameters. We are dealing with a predefined set of values that are unlikely to change in the foreseeable future, and symbols work well in that case. Plus, if you do it that way, you can predefine the symbols and compare against them directly, instead of doing string comparisons.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7195,69785318,2016-07-06T18:28:41Z,tools/run_tests/run_tests.py,"@@ -431,23 +420,50 @@ def makefile_name(self):   def dockerfile_dir(self):     return 'tools/dockerfile/test/python_jessie_%s' % _docker_arch_suffix(self.args.arch) -  def _get_pythons(self, compiler):+  def _get_pythons(self, args):+    if args.arch == 'x86':+      bits = '32'+    else:+      bits = '64'     if os.name == 'nt':-      venv_relative_python = 'Scripts/python.exe'-      toolchain = 'mingw32'+      shell = ['bash']+      builder = [os.path.abspath('tools/run_tests/build_python_msys2.sh')]+      builder_prefix_arguments = ['MINGW{}'.format(bits)]+      venv_relative_python = ['Scripts/python.exe']+      toolchain = ['mingw32']+      python_pattern_function = lambda major, minor, bits: (+          '/c/Python{major}{minor}/python.exe'.format(major=major, minor=minor, bits=bits)+	  if bits == '64' else+	  '/c/Python{major}{minor}_{bits}bits/python.exe'.format(+              major=major, minor=minor, bits=bits))     else:-      venv_relative_python = 'bin/python'-      toolchain = 'unix'-    python27_config = PythonConfig('python2.7', 'py27', venv_relative_python, toolchain)-    python34_config = PythonConfig('python3.4', 'py34', venv_relative_python, toolchain)-    if compiler == 'default':-      return (python27_config, python34_config,)-    elif compiler == 'python2.7':+      shell = []+      builder = [os.path.abspath('tools/run_tests/build_python.sh')]+      builder_prefix_arguments = []+      venv_relative_python = ['bin/python']+      toolchain = ['unix']+      # Bit-ness is handled by the test machine's environment+      python_pattern_function = lambda major, minor, bits: 'python{major}.{minor}'.format(major=major, minor=minor)+    runner = [os.path.abspath('tools/run_tests/run_python.sh')]+    python_config_generator = lambda name, major, minor, bits: PythonConfig(+        name,+        shell + builder + builder_prefix_arguments+	    + [python_pattern_function(major=major, minor=minor, bits=bits)]+	    + [name] + venv_relative_python + toolchain,+        shell + runner + [os.path.join(name, venv_relative_python[0])])+    python27_config = python_config_generator(name='py27', major='2', minor='7', bits=bits)+    python34_config = python_config_generator(name='py34', major='3', minor='4', bits=bits)+    if args.compiler == 'default':+      if os.name == 'nt':","I'll note that this was a strange decision on my part. My gut justification is that Python 3 support is AFAIK in `beta`, so dragging Windows along immediately seemed a bit much (correct me if I'm wrong).",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7216,69786255,2016-07-06T18:34:33Z,src/ruby/ext/grpc/rb_compression_options.c,"@@ -0,0 +1,351 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <ruby/ruby.h>++#include ""rb_compression_options.h""+#include ""rb_grpc_imports.generated.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>+#include <grpc/impl/codegen/compression_types.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <string.h>++#include ""rb_grpc.h""++static VALUE grpc_rb_cCompressionOptions = Qnil;++/* grpc_rb_compression_options wraps a grpc_compression_options.+ * Note that ruby objects of this type don't carry any state in other+ * Ruby objects and don't have a mark for GC. */+typedef struct grpc_rb_compression_options {+  /* The actual compression options that's being wrapped */+  grpc_compression_options *wrapped;+} grpc_rb_compression_options;++/* Destroys the compression options instances and free the+ * wrapped grpc compression options. */+static void grpc_rb_compression_options_free(void *p) {+  grpc_rb_compression_options *wrapper = NULL;+  if (p == NULL) {+    return;+  };+  wrapper = (grpc_rb_compression_options *)p;++  if (wrapper->wrapped != NULL) {+    gpr_free(wrapper->wrapped);+    wrapper->wrapped = NULL;+  }++  xfree(p);+}++/* Ruby recognized data type for the CompressionOptions class. */+static rb_data_type_t grpc_rb_compression_options_data_type = {+    ""grpc_compression_options"",+    {NULL,+     grpc_rb_compression_options_free,+     GRPC_RB_MEMSIZE_UNAVAILABLE,+     {NULL, NULL}},+    NULL,+    NULL,+#ifdef RUBY_TYPED_FREE_IMMEDIATELY+    RUBY_TYPED_FREE_IMMEDIATELY+#endif+};++/* Allocates CompressionOptions instances.+   Allocate the wrapped grpc compression options and+   initialize it here too. */+static VALUE grpc_rb_compression_options_alloc(VALUE cls) {+  grpc_rb_compression_options *wrapper =+      gpr_malloc(sizeof(grpc_rb_compression_options));+  wrapper->wrapped = NULL;+  wrapper->wrapped = gpr_malloc(sizeof(grpc_compression_options));+  grpc_compression_options_init(wrapper->wrapped);++  return TypedData_Wrap_Struct(cls, &grpc_rb_compression_options_data_type,+                               wrapper);+}++/* Disables a compression algorithm, given the GRPC core internal number of a+ * compression algorithm. */+VALUE grpc_rb_compression_options_disable_compression_algorithm_internal(+    VALUE self, VALUE algorithm_to_disable) {+  grpc_compression_algorithm compression_algorithm = 0;+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_algorithm =+      (grpc_compression_algorithm)NUM2INT(algorithm_to_disable);++  grpc_compression_options_disable_algorithm(wrapper->wrapped,+                                             compression_algorithm);++  return Qnil;+}++/* Provides a bitset as a ruby number that is suitable to pass to+ * the GRPC core as a channel argument to enable compression algorithms. */+VALUE grpc_rb_compression_options_get_enabled_algorithms_bitset(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  return INT2NUM((int)wrapper->wrapped->enabled_algorithms_bitset);+}++void grpc_rb_compression_options_set_default_level_helper(+    grpc_compression_options *compression_options,+    grpc_compression_level level) {+  compression_options->default_level.is_set |= 1;+  compression_options->default_level.level = level;+}++/* Sets the default compression level, given the name of a compression level.+ * Throws an error if no algorithm matched. */+VALUE grpc_rb_compression_options_set_default_level(VALUE self,+                                                    VALUE new_level) {+  char *level_name = NULL;+  grpc_rb_compression_options *wrapper = NULL;+  long name_len = 0;+  VALUE ruby_str = Qnil;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  /* Take both string and symbol parameters */+  ruby_str = rb_funcall(new_level, rb_intern(""to_s""), 0);++  level_name = RSTRING_PTR(ruby_str);+  name_len = RSTRING_LEN(ruby_str);++  /* Check the compression level of the name passed in, and see which macro+   * from the GRPC core header files match. */+  if (strncmp(level_name, ""none"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_NONE);+  } else if (strncmp(level_name, ""low"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_LOW);+  } else if (strncmp(level_name, ""medium"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_MED);+  } else if (strncmp(level_name, ""high"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_HIGH);+  } else {+    rb_raise(rb_eNameError,+             ""Invalid compression level name. Supported levels: none, low, ""+             ""medium, high"");+  }++  return Qnil;+}++/* Gets the internal value of a compression algorithm suitable as the value+ * in a GRPC core channel arguments hash.+ * Raises an error if the name of the algorithm passed in is invalid. */+void grpc_rb_compression_options_get_internal_value_of_algorithm(+    VALUE algorithm_name, grpc_compression_algorithm *compression_algorithm) {+  VALUE ruby_str = Qnil;+  char *name_str = NULL;+  long name_len = 0;++  /* Accept ruby symbol and string parameters. */+  ruby_str = rb_funcall(algorithm_name, rb_intern(""to_s""), 0);+  name_str = RSTRING_PTR(ruby_str);+  name_len = RSTRING_LEN(ruby_str);++  /* Raise an error if the name isn't recognized as a compression algorithm by+   * the algorithm parse function+   * in GRPC core. */+  if (!grpc_compression_algorithm_parse(name_str, name_len,+                                        compression_algorithm)) {+    rb_raise(rb_eNameError,+             ""Invalid compression algorithm name."");+  }+}++/* Sets the default algorithm to the name of the algorithm passed in.+ * Raises an error if the name is not a valid compression algorithm name. */+VALUE grpc_rb_compression_options_set_default_algorithm(VALUE self,+                                                        VALUE algorithm_name) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  grpc_rb_compression_options_get_internal_value_of_algorithm(+      algorithm_name, &wrapper->wrapped->default_algorithm.algorithm);+  wrapper->wrapped->default_algorithm.is_set |= 1;++  return Qnil;+}++/* Gets the internal value of the default compression level that is to be passed+ * to the+ * the GRPC core as a channel argument value.+ * A nil return value means that it hasn't been set. */+VALUE grpc_rb_compression_options_default_algorithm_internal_value(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  if (wrapper->wrapped->default_algorithm.is_set) {+    return INT2NUM(wrapper->wrapped->default_algorithm.algorithm);+  } else {+    return Qnil;+  }+}++/* Gets the internal value of the default compression level that is to be passed+ * to the GRPC core as a channel argument value.+ * A nil return value means that it hasn't been set. */+VALUE grpc_rb_compression_options_default_level_internal_value(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  if (wrapper->wrapped->default_level.is_set) {+    return INT2NUM((int)wrapper->wrapped->default_level.level);+  } else {+    return Qnil;+  }+}++/* Disables compression algorithms by their names. Raises an error if an unkown+ * name was passed. */+VALUE grpc_rb_compression_options_disable_algorithms(int argc, VALUE *argv,+                                                     VALUE self) {+  VALUE algorithm_names = Qnil;+  VALUE ruby_str = Qnil;+  grpc_compression_algorithm internal_algorithm_value;++  /* read variadic argument list of names into the algorithm_name ruby array. */+  rb_scan_args(argc, argv, ""0*"", &algorithm_names);++  for (int i = 0; i < RARRAY_LEN(algorithm_names); i++) {+    ruby_str =+        rb_funcall(rb_ary_entry(algorithm_names, i), rb_intern(""to_s""), 0);+    grpc_rb_compression_options_get_internal_value_of_algorithm(+        ruby_str, &internal_algorithm_value);+    rb_funcall(self, rb_intern(""disable_algorithm_internal""), 1,+               LONG2NUM((long)internal_algorithm_value));+  }++  return Qnil;+}++/* Provides a ruby hash of GRPC core channel argument key-values that+ * correspond to the compression settings on this instance. */+VALUE grpc_rb_compression_options_to_hash(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;+  grpc_compression_options *compression_options = NULL;+  VALUE channel_arg_hash = rb_funcall(rb_cHash, rb_intern(""new""), 0);++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_options = wrapper->wrapped;++  /* Add key-value pairs to the new Ruby hash. It can be used+   * as GRPC core channel arguments. */+  if (compression_options->default_level.is_set) {+    rb_funcall(channel_arg_hash, rb_intern(""[]=""), 2,+               rb_str_new2(GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL),+               INT2NUM((int)compression_options->default_level.level));","This should be done with `rb_hash_aset`, like we use at https://github.com/grpc/grpc/blob/master/src/ruby/ext/grpc/rb_call.c#L483.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7216,69786590,2016-07-06T18:36:25Z,src/ruby/ext/grpc/rb_compression_options.c,"@@ -0,0 +1,351 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <ruby/ruby.h>++#include ""rb_compression_options.h""+#include ""rb_grpc_imports.generated.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>+#include <grpc/impl/codegen/compression_types.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <string.h>++#include ""rb_grpc.h""++static VALUE grpc_rb_cCompressionOptions = Qnil;++/* grpc_rb_compression_options wraps a grpc_compression_options.+ * Note that ruby objects of this type don't carry any state in other+ * Ruby objects and don't have a mark for GC. */+typedef struct grpc_rb_compression_options {+  /* The actual compression options that's being wrapped */+  grpc_compression_options *wrapped;+} grpc_rb_compression_options;++/* Destroys the compression options instances and free the+ * wrapped grpc compression options. */+static void grpc_rb_compression_options_free(void *p) {+  grpc_rb_compression_options *wrapper = NULL;+  if (p == NULL) {+    return;+  };+  wrapper = (grpc_rb_compression_options *)p;++  if (wrapper->wrapped != NULL) {+    gpr_free(wrapper->wrapped);+    wrapper->wrapped = NULL;+  }++  xfree(p);+}++/* Ruby recognized data type for the CompressionOptions class. */+static rb_data_type_t grpc_rb_compression_options_data_type = {+    ""grpc_compression_options"",+    {NULL,+     grpc_rb_compression_options_free,+     GRPC_RB_MEMSIZE_UNAVAILABLE,+     {NULL, NULL}},+    NULL,+    NULL,+#ifdef RUBY_TYPED_FREE_IMMEDIATELY+    RUBY_TYPED_FREE_IMMEDIATELY+#endif+};++/* Allocates CompressionOptions instances.+   Allocate the wrapped grpc compression options and+   initialize it here too. */+static VALUE grpc_rb_compression_options_alloc(VALUE cls) {+  grpc_rb_compression_options *wrapper =+      gpr_malloc(sizeof(grpc_rb_compression_options));+  wrapper->wrapped = NULL;+  wrapper->wrapped = gpr_malloc(sizeof(grpc_compression_options));+  grpc_compression_options_init(wrapper->wrapped);++  return TypedData_Wrap_Struct(cls, &grpc_rb_compression_options_data_type,+                               wrapper);+}++/* Disables a compression algorithm, given the GRPC core internal number of a+ * compression algorithm. */+VALUE grpc_rb_compression_options_disable_compression_algorithm_internal(+    VALUE self, VALUE algorithm_to_disable) {+  grpc_compression_algorithm compression_algorithm = 0;+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_algorithm =+      (grpc_compression_algorithm)NUM2INT(algorithm_to_disable);++  grpc_compression_options_disable_algorithm(wrapper->wrapped,+                                             compression_algorithm);++  return Qnil;+}++/* Provides a bitset as a ruby number that is suitable to pass to+ * the GRPC core as a channel argument to enable compression algorithms. */+VALUE grpc_rb_compression_options_get_enabled_algorithms_bitset(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  return INT2NUM((int)wrapper->wrapped->enabled_algorithms_bitset);+}++void grpc_rb_compression_options_set_default_level_helper(+    grpc_compression_options *compression_options,+    grpc_compression_level level) {+  compression_options->default_level.is_set |= 1;+  compression_options->default_level.level = level;+}++/* Sets the default compression level, given the name of a compression level.+ * Throws an error if no algorithm matched. */+VALUE grpc_rb_compression_options_set_default_level(VALUE self,+                                                    VALUE new_level) {+  char *level_name = NULL;+  grpc_rb_compression_options *wrapper = NULL;+  long name_len = 0;+  VALUE ruby_str = Qnil;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  /* Take both string and symbol parameters */+  ruby_str = rb_funcall(new_level, rb_intern(""to_s""), 0);++  level_name = RSTRING_PTR(ruby_str);+  name_len = RSTRING_LEN(ruby_str);++  /* Check the compression level of the name passed in, and see which macro+   * from the GRPC core header files match. */+  if (strncmp(level_name, ""none"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_NONE);+  } else if (strncmp(level_name, ""low"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_LOW);+  } else if (strncmp(level_name, ""medium"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_MED);+  } else if (strncmp(level_name, ""high"", name_len) == 0) {+    grpc_rb_compression_options_set_default_level_helper(+        wrapper->wrapped, GRPC_COMPRESS_LEVEL_HIGH);+  } else {+    rb_raise(rb_eNameError,+             ""Invalid compression level name. Supported levels: none, low, ""+             ""medium, high"");+  }++  return Qnil;+}++/* Gets the internal value of a compression algorithm suitable as the value+ * in a GRPC core channel arguments hash.+ * Raises an error if the name of the algorithm passed in is invalid. */+void grpc_rb_compression_options_get_internal_value_of_algorithm(+    VALUE algorithm_name, grpc_compression_algorithm *compression_algorithm) {","Why not just have this function return the `grpc_compression_algorithm`. You just have one out parameter, and you don't even have a return value.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7195,69871713,2016-07-07T08:51:17Z,src/python/grpcio/build.py,"@@ -0,0 +1,118 @@+# Copyright 2016, Google Inc.","Hm. My initial reaction was, ""I have no guarantee that `spawn` isn't going to be used in other cross-cutting ways by future `distutils` code in later Py3 revisions, while I have a pretty strong semver guarantee that I'm safe until Py4 since I'm maintaining the semantics that're now present in Py3 for this function.""Maybe code simplicity and maintenance comfort is preferable, though. While I'm not quite yet on the fence about it, I'm leaning rather heavily on a weak board and I can hear some rusted nails popping.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7195,69940557,2016-07-07T16:33:25Z,src/python/grpcio/build.py,"@@ -0,0 +1,118 @@+# Copyright 2016, Google Inc.","CCompiler Spawn is a documented part of the distuitils API, so its use shouldn't change in the Py3 line https://docs.python.org/3/distutils/apiref.htmlI would argue that the bug is in `spawn()` to begin with, the issue in `link()` is just a symptom because it happens to generate a large enough command for spawn.  I think we should just pipe all our commands to a file, and then use the file, and then use the command file hack for everything.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7195,69958777,2016-07-07T18:19:39Z,tools/run_tests/build_python.sh,"@@ -61,17 +127,24 @@ if [ ""${PLATFORM/Darwin}"" = ""$PLATFORM"" ]; then     fi   fi fi--# Find `realpath`-if [ -x ""$(command -v realpath)"" ]; then-  export REALPATH=realpath-elif [ -x ""$(command -v grealpath)"" ]; then-  export REALPATH=grealpath-else-  echo 'Couldn'""'""'t find `realpath` or `grealpath`'-  exit 1+# TODO(atash) consider conceptualizing MinGW as a first-class platform and move+# these flags into our `setup.py`s+if [ $(is_mingw) ]; then+  # We're on MinGW, and our CFLAGS and LDFLAGS will be eaten by the void. Use+  # our work-around environment variables instead.+  PYTHON_MSVCR=`$PYTHON -c ""from distutils.cygwinccompiler import get_msvcr; print(get_msvcr()[0])""`+  export GRPC_PYTHON_LDFLAGS=""-static-libgcc -static-libstdc++ -mcrtdll=$PYTHON_MSVCR -static -lpthread""+  # See https://sourceforge.net/p/mingw-w64/bugs/363/+  export GRPC_PYTHON_CFLAGS=""-D_ftime=_ftime64 -D_timeb=__timeb64""+  # TODO(atash) set these flags for only grpcio-tools (they don't do any harm to",Hm. The change grew a little quickly. It's probably large enough to deserve its own PR. Mind waiting on the flag movement until post-merge?,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7195,69962616,2016-07-07T18:39:25Z,src/python/grpcio/build.py,"@@ -0,0 +1,118 @@+# Copyright 2016, Google Inc.","Are you sure you read that article all the way through? Command-files are an opt-in feature only stylistically recommended. Further, `gcc` accepts command files in a different manner than the toy example provided by Microsoft.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7195,69972801,2016-07-07T19:40:13Z,src/python/grpcio/build.py,"@@ -0,0 +1,118 @@+# Copyright 2016, Google Inc.","Here's what I have in mind```def _spawn_nt(cmd):  temporary_directory = tempfile.mkdtemp()  command_filename = os.path.abspath(    os.path.join(temporary_directory, 'command'))  with open(command_filename, 'w') as command_file:    escaped_args = [arg.replace('\\', '\\\\') for arg in cmd[1:]]    command_file.write(' '.join(escaped_args))  disutils.spawn.spawn([cmd[0], command_filename])  # Cleanup tmp file maybe ? Not sure if spawn blocks until completedef monkeypatch_unix_compiler():  if os.name == 'nt':    unixccompiler.UnixCCompiler.spawn = _spawn_nt```",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7170,70013896,2016-07-08T01:17:22Z,src/python/grpcio/grpc/__init__.py,"@@ -299,6 +299,23 @@ def add_callback(self, callback):     raise NotImplementedError()  +############################  gRPC Metadata  ##################################+++class Metadatum(six.with_metaclass(abc.ABCMeta, tuple)):",Drop `tuple` from the superclass list.,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7274,70028460,2016-07-08T06:02:23Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -456,17 +454,19 @@ def initialize(wrapped)     # SingleReqView limits access to an ActiveCall's methods for use in server     # handlers that receive just one request.     SingleReqView = view_class(:cancelled, :deadline, :metadata,","Thought that SingleReqView and MultiReqView were only for call objects in server handlers, in which case trailing metadata shouldn't be relevant?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6595,70106455,2016-07-08T17:01:49Z,src/core/lib/support/time.c,"@@ -80,103 +80,62 @@ gpr_timespec gpr_inf_past(gpr_clock_type type) {   return out; } -/* TODO(ctiller): consider merging _nanos, _micros, _millis into a single-   function for maintainability. Similarly for _seconds, _minutes, and _hours */--gpr_timespec gpr_time_from_nanos(int64_t ns, gpr_clock_type type) {-  gpr_timespec result;-  result.clock_type = type;-  if (ns == INT64_MAX) {-    result = gpr_inf_future(type);-  } else if (ns == INT64_MIN) {-    result = gpr_inf_past(type);-  } else if (ns >= 0) {-    result.tv_sec = ns / GPR_NS_PER_SEC;-    result.tv_nsec = (int32_t)(ns - result.tv_sec * GPR_NS_PER_SEC);+static gpr_timespec get_timespec_by_different_second_unit(int64_t t, int64_t n,","How about renaming the function to `to_seconds_from_sub_second_time`? The original name is a bit redundant: its signature already show it returns a timespec; I found the rest of the name a bit confusing (admittedly because ""second"" is an overloaded term). I understand this is a matter of personal preference, so feel free to push back.On a more important now, could you also rename `n` to `units_per_sec` and `t` to `time_in_units`? I feel more strongly about this. `t` and `n` (especially `n`) are too short to be descriptive in this context. It also makes it clear what the output unit is with some simple dimensionality analysis: (time in units) / (units per sec) = (time in units) / (units/sec) = secs.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6595,70109346,2016-07-08T17:24:08Z,src/core/lib/support/time.c,"@@ -80,103 +80,62 @@ gpr_timespec gpr_inf_past(gpr_clock_type type) {   return out; } -/* TODO(ctiller): consider merging _nanos, _micros, _millis into a single-   function for maintainability. Similarly for _seconds, _minutes, and _hours */--gpr_timespec gpr_time_from_nanos(int64_t ns, gpr_clock_type type) {-  gpr_timespec result;-  result.clock_type = type;-  if (ns == INT64_MAX) {-    result = gpr_inf_future(type);-  } else if (ns == INT64_MIN) {-    result = gpr_inf_past(type);-  } else if (ns >= 0) {-    result.tv_sec = ns / GPR_NS_PER_SEC;-    result.tv_nsec = (int32_t)(ns - result.tv_sec * GPR_NS_PER_SEC);+static gpr_timespec get_timespec_by_different_second_unit(int64_t t, int64_t n,+                                                          gpr_clock_type type) {+  gpr_timespec out;+  if (t == INT64_MAX) {+    out = gpr_inf_future(type);+  } else if (t == INT64_MIN) {+    out = gpr_inf_past(type);   } else {-    /* Calculation carefully formulated to avoid any possible under/overflow. */-    result.tv_sec = (-(999999999 - (ns + GPR_NS_PER_SEC)) / GPR_NS_PER_SEC) - 1;-    result.tv_nsec = (int32_t)(ns - result.tv_sec * GPR_NS_PER_SEC);+    if (t >= 0) {+      out.tv_sec = t / n;+    } else {+      out.tv_sec = (-((n - 1) - (t + n)) / n) - 1;+    }+    out.tv_nsec = (int32_t)((t - out.tv_sec * n) * GPR_NS_PER_SEC / n);+    out.clock_type = type;   }-  return result;+  return out; } -gpr_timespec gpr_time_from_micros(int64_t us, gpr_clock_type type) {-  gpr_timespec result;-  result.clock_type = type;-  if (us == INT64_MAX) {-    result = gpr_inf_future(type);-  } else if (us == INT64_MIN) {-    result = gpr_inf_past(type);-  } else if (us >= 0) {-    result.tv_sec = us / 1000000;-    result.tv_nsec = (int32_t)((us - result.tv_sec * 1000000) * 1000);+static gpr_timespec get_timespec_by_hour_or_minute_unit(int64_t t, int64_t n,","Following the previous comment, I suggest changing the name to `to_seconds_from_above_second_time`. This follows the same naming schema and doesn't limit you to only ""hour or minute"". This function could be used to calculate seconds in a week, or in a year. The current name misrepresents what it's able to do. Same comment regarding `t` and `n`: how about renaming `n` to `secs_per_unit` (note this is different from the previous suggestion for `n`) and `t` to `time_in_units`? Similarly: (time in units) \* (secs / unit) = secs.",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/7282,70113903,2016-07-08T17:54:30Z,src/csharp/Grpc.Core/Internal/UnmanagedLibrary.cs,"@@ -82,6 +82,32 @@ public UnmanagedLibrary(string[] libraryPathAlternatives)         /// <returns></returns>         public IntPtr LoadSymbol(string symbolName)         {+            if (PlatformApis.IsWindows)+            {+                // See http://stackoverflow.com/questions/10473310 for background on this.+                if (PlatformApis.Is64Bit)+                {+                    return Windows.GetProcAddress(this.handle, symbolName);+                }+                else+                {+                    // Yes, we could potentially predict the size... but it's a lot simpler to just try+                    // all the candidates. Most functions have a suffix of @0, @4 or @8 so we won't be trying+                    // many options - and if it takes a little bit longer to fail if we've really got the wrong+                    // library, that's not a big problem. This is only called once per function in the native library.+                    symbolName = ""_"" + symbolName + ""@"";","Put it this way: running `dumpbin /exports grpc_csharp_ext.dll` showed everything being done this way.Now it could be that if we change how the library is built, that would change what's exported...(We could try _also_ just finding the name without any prefix/suffix, of course.)",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7282,70118640,2016-07-08T18:24:31Z,src/csharp/Grpc.Core/Internal/UnmanagedLibrary.cs,"@@ -82,6 +82,32 @@ public UnmanagedLibrary(string[] libraryPathAlternatives)         /// <returns></returns>         public IntPtr LoadSymbol(string symbolName)         {+            if (PlatformApis.IsWindows)+            {+                // See http://stackoverflow.com/questions/10473310 for background on this.+                if (PlatformApis.Is64Bit)+                {+                    return Windows.GetProcAddress(this.handle, symbolName);+                }+                else+                {+                    // Yes, we could potentially predict the size... but it's a lot simpler to just try+                    // all the candidates. Most functions have a suffix of @0, @4 or @8 so we won't be trying+                    // many options - and if it takes a little bit longer to fail if we've really got the wrong+                    // library, that's not a big problem. This is only called once per function in the native library.+                    symbolName = ""_"" + symbolName + ""@"";","Thanks, saw here https://msdn.microsoft.com/en-us/library/aa984739(v=vs.71).aspx that DLLImport was limited to __std_call anyways, so I think its the same then.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7282,70119923,2016-07-08T18:32:48Z,src/csharp/Grpc.Core/Grpc.Core.targets,"@@ -1,29 +1,29 @@ ﻿<?xml version=""1.0"" encoding=""utf-8""?> <Project ToolsVersion=""4.0"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">   <ItemGroup>-    <Content Include=""$(MSBuildThisFileDirectory)..\..\build\native\bin\windows_x86\grpc_csharp_ext.dll"">+    <Content Include=""$(MSBuildThisFileDirectory)..\..\runtimes\win-x86\native\grpc_csharp_ext.x86.dll"">       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>-      <Link>nativelibs\windows_x86\grpc_csharp_ext.dll</Link>+      <Link>grpc_csharp_ext.x86.dll</Link>","So with this change, all library versions have a unique name, rather than needing to be placed in a unique directory? Is this why this now just refers to the name here?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7282,70121525,2016-07-08T18:42:54Z,src/csharp/Grpc.Core/Internal/NativeExtension.cs,"@@ -97,21 +94,31 @@ public NativeMethods NativeMethods         /// </summary>         private static UnmanagedLibrary Load()         {-            // TODO: allow customizing path to native extension (possibly through exposing a GrpcEnvironment property).--            var libraryFlavor = string.Format(""{0}_{1}"", GetPlatformString(), GetArchitectureString());--            var assemblyDirectory = Path.GetDirectoryName(GetAssemblyPath());--            // With old-style VS projects, the native libraries get copied using a .targets rule to the build output folder-            // alongside the compiled assembly.-            var classicPath = Path.Combine(assemblyDirectory, NativeLibrariesDir, libraryFlavor, GetNativeLibraryFilename());--            // DNX-style project.json projects will use Grpc.Core assembly directly in the location where it got restored-            // by nuget. We locate the native libraries based on known structure of Grpc.Core nuget package.-            var dnxStylePath = Path.Combine(assemblyDirectory, DnxStyleNativeLibrariesDir, libraryFlavor, GetNativeLibraryFilename());--            return new UnmanagedLibrary(new string[] {classicPath, dnxStylePath});+            string[] paths;+            string explicitPath = GrpcEnvironment.NativeLibrary;+            if (explicitPath != null)+            {+                paths = new[] { explicitPath };+            }+            else+            {+                var assemblyDirectory = Path.GetDirectoryName(GetAssemblyPath());++                // With old-style VS projects, the native libraries get copied using a .targets rule to the build output folder+                // alongside the compiled assembly.+                // With dotnet cli projects, the native libraries (just the required ones) are similarly copied to the built output folder,","Is this why the the shared library sources are now kept in "".../runtime/<os>-<arch>/..."" instead of "".../build/..."" directories? Is this following a dotnet convention of where it finds the required library?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7282,70124233,2016-07-08T18:59:10Z,src/csharp/Grpc.Core/Internal/NativeExtension.cs,"@@ -97,21 +94,31 @@ public NativeMethods NativeMethods         /// </summary>         private static UnmanagedLibrary Load()         {-            // TODO: allow customizing path to native extension (possibly through exposing a GrpcEnvironment property).--            var libraryFlavor = string.Format(""{0}_{1}"", GetPlatformString(), GetArchitectureString());--            var assemblyDirectory = Path.GetDirectoryName(GetAssemblyPath());--            // With old-style VS projects, the native libraries get copied using a .targets rule to the build output folder-            // alongside the compiled assembly.-            var classicPath = Path.Combine(assemblyDirectory, NativeLibrariesDir, libraryFlavor, GetNativeLibraryFilename());--            // DNX-style project.json projects will use Grpc.Core assembly directly in the location where it got restored-            // by nuget. We locate the native libraries based on known structure of Grpc.Core nuget package.-            var dnxStylePath = Path.Combine(assemblyDirectory, DnxStyleNativeLibrariesDir, libraryFlavor, GetNativeLibraryFilename());--            return new UnmanagedLibrary(new string[] {classicPath, dnxStylePath});+            string[] paths;+            string explicitPath = GrpcEnvironment.NativeLibrary;+            if (explicitPath != null)+            {+                paths = new[] { explicitPath };+            }+            else+            {+                var assemblyDirectory = Path.GetDirectoryName(GetAssemblyPath());++                // With old-style VS projects, the native libraries get copied using a .targets rule to the build output folder+                // alongside the compiled assembly.+                // With dotnet cli projects, the native libraries (just the required ones) are similarly copied to the built output folder,+                // through the magic of Microsoft.NETCore.Platforms.+                var classicPath = Path.Combine(assemblyDirectory, GetNativeLibraryFilename());++                // DNX-style project.json projects will use Grpc.Core assembly directly in the location where it got restored+                // by nuget. We locate the native libraries based on known structure of Grpc.Core nuget package.","So the classic VS and dotnet projects find and copy the library, but these projects using project.json just look them up in the Nuget package and don't copy?",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/7282,70125804,2016-07-08T19:10:56Z,src/csharp/Grpc.Core/Internal/NativeExtension.cs,"@@ -97,21 +94,31 @@ public NativeMethods NativeMethods         /// </summary>         private static UnmanagedLibrary Load()         {-            // TODO: allow customizing path to native extension (possibly through exposing a GrpcEnvironment property).--            var libraryFlavor = string.Format(""{0}_{1}"", GetPlatformString(), GetArchitectureString());--            var assemblyDirectory = Path.GetDirectoryName(GetAssemblyPath());--            // With old-style VS projects, the native libraries get copied using a .targets rule to the build output folder-            // alongside the compiled assembly.-            var classicPath = Path.Combine(assemblyDirectory, NativeLibrariesDir, libraryFlavor, GetNativeLibraryFilename());--            // DNX-style project.json projects will use Grpc.Core assembly directly in the location where it got restored-            // by nuget. We locate the native libraries based on known structure of Grpc.Core nuget package.-            var dnxStylePath = Path.Combine(assemblyDirectory, DnxStyleNativeLibrariesDir, libraryFlavor, GetNativeLibraryFilename());--            return new UnmanagedLibrary(new string[] {classicPath, dnxStylePath});+            string[] paths;+            string explicitPath = GrpcEnvironment.NativeLibrary;+            if (explicitPath != null)+            {+                paths = new[] { explicitPath };+            }+            else+            {+                var assemblyDirectory = Path.GetDirectoryName(GetAssemblyPath());++                // With old-style VS projects, the native libraries get copied using a .targets rule to the build output folder+                // alongside the compiled assembly.+                // With dotnet cli projects, the native libraries (just the required ones) are similarly copied to the built output folder,+                // through the magic of Microsoft.NETCore.Platforms.+                var classicPath = Path.Combine(assemblyDirectory, GetNativeLibraryFilename());++                // DNX-style project.json projects will use Grpc.Core assembly directly in the location where it got restored+                // by nuget. We locate the native libraries based on known structure of Grpc.Core nuget package.","- Classic VS (msbuild with csproj) will end up with _all_ the native libraries alongside the assemblies- dotnet cli projects will end up with just the right native library alongside all the other assemblies- dnx projects (which should be considered deprecated now, to be honest - but let's support if we can, for the moment) load the assemblies from the package directory... at least in the cases we've looked at. (Again, it's not terribly clear)",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7170,70131753,2016-07-08T19:56:46Z,src/python/grpcio/grpc/__init__.py,"@@ -299,6 +299,23 @@ def add_callback(self, callback):     raise NotImplementedError()  +############################  gRPC Metadata  ##################################+++class Metadatum(six.with_metaclass(abc.ABCMeta, tuple)):","Because clients provide Metadata and we don't offer a concrete implementation, this allows them to provide a tuple in the place of Metadata and still adhere to the type spec.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7170,70131896,2016-07-08T19:57:45Z,src/python/grpcio/grpc/__init__.py,"@@ -299,6 +299,23 @@ def add_callback(self, callback):     raise NotImplementedError()  +############################  gRPC Metadata  ##################################+++class Metadatum(six.with_metaclass(abc.ABCMeta, tuple)):+  """"""A single entry in a Metadata collection.+  +  A metadata entry is a 2-tuple where the first entry is the key and the+  second is the value, i.e. (key, value).  The metadata key is an ASCII str,+  and must be a valid HTTP header name.  The metadata value can be+  either a valid HTTP ASCII str, or bytes.  If bytes are provided,+  the key must end with '-bin', i.e. ('binary-metadata-bin', b'\x00\xFF')++  Metadatum is an abstract type, all instances should be tuples as +  described above.+  """"""",See above.  Clients providing tuples as metadata would be invalid according to the type spec.,
13909816,daniel-j-born,https://api.github.com/repos/grpc/grpc/pulls/7047,70151482,2016-07-08T22:44:24Z,src/core/lib/iomgr/tcp_server_posix.c,"@@ -70,6 +71,8 @@  #define MIN_SAFE_ACCEPT_QUEUE_SIZE 100 +int grpc_tcp_server_posix_expand_wildcard_addr = 0;","I've been unable to find a good place to add it. The ideal situation would be to have the constructor for grpc_channel_args set a default value for the flag based on probing local hardware, and then the caller could customize the flag directly if necessary. However, it's a struct with no constructor, e.g., https://github.com/grpc/grpc/blob/master/src/cpp/server/server.cc#L295I don't want to have to set it explicitly everywhere a grpc_channel_args is stack or heap allocated.I need a grpc_channel_args_init (constructor, essentially) to add my code to, but none exists.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7047,70153119,2016-07-08T23:03:33Z,src/core/lib/iomgr/tcp_server_posix.c,"@@ -70,6 +71,8 @@  #define MIN_SAFE_ACCEPT_QUEUE_SIZE 100 +int grpc_tcp_server_posix_expand_wildcard_addr = 0;","The correct thing is probably to add a mutation pass to server builderplugins. +Yuchen Zeng zyc@google.com could you have a look at what wouldbe required to allow a plugin to mutate channel args?On Fri, Jul 8, 2016 at 3:44 PM Dan Born notifications@github.com wrote:> In src/core/lib/iomgr/tcp_server_posix.c> https://github.com/grpc/grpc/pull/7047#discussion_r70151482:> > > @@ -70,6 +71,8 @@> > > >  #define MIN_SAFE_ACCEPT_QUEUE_SIZE 100> > > > +int grpc_tcp_server_posix_expand_wildcard_addr = 0;> > I've been unable to find a good place to add it. The ideal situation would> be to have the constructor for grpc_channel_args set a default value for> the flag based on probing local hardware, and then the caller could> customize the flag directly if necessary. However, it's a struct with no> constructor, e.g.,> https://github.com/grpc/grpc/blob/master/src/cpp/server/server.cc#L295> > I don't want to have to set it explicitly everywhere a grpc_channel_args> is stack or heap allocated.> > I need a grpc_channel_args_init (constructor, essentially) to add my code> to, but none exists.> > —> You are receiving this because you were assigned.> > Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7047/files/a3a709782500b6e158710b49e365fd99a022354c#r70151482,> or mute the thread> https://github.com/notifications/unsubscribe/AJpudcWh1vc5ryia8Iziw_RFqtRFLk0oks5qTtLXgaJpZM4I-GnO> .",
17011,jskeet,https://api.github.com/repos/grpc/grpc/pulls/7282,70247769,2016-07-11T12:28:22Z,src/csharp/Grpc.Core.Tests/project.json,"@@ -14,10 +14,10 @@         },         ""copyToOutput"": {           ""mappings"": {-            ""nativelibs/windows_x64/grpc_csharp_ext.dll"": ""../../../vsprojects/x64/Debug/grpc_csharp_ext.dll"",-            ""nativelibs/windows_x86/grpc_csharp_ext.dll"": ""../../../vsprojects/Debug/grpc_csharp_ext.dll"",-            ""nativelibs/linux_x64/libgrpc_csharp_ext.so"": ""../../../libs/dbg/libgrpc_csharp_ext.so"",-            ""nativelibs/macosx_x64/libgrpc_csharp_ext.dylib"": ""../../../libs/dbg/libgrpc_csharp_ext.dylib""+            ""grpc_csharp_ext.x64.dll"": ""../../../vsprojects/x64/Debug/grpc_csharp_ext.dll"",",Worked it out now - I didn't have `go` installed. Looking better now. I suspect that `CONTRIBUTING.md` could do with being updated for the various dependencies required before running the toolchain. (I didn't have pyyaml or mako installed before today either...),
9053690,zhangkun83,https://api.github.com/repos/grpc/grpc/pulls/7294,70294611,2016-07-11T16:52:57Z,doc/load-balancing.md,"@@ -53,14 +53,67 @@ unavailability or health issues. The load balancer will make any necessary complex decisions and inform the client. The load balancer may communicate with the backend servers to collect load and health information. ++## Requirements++#### Simple API and client++The gRPC client load balancing code must be simple and portable. The client+should only contain simple algorithms (ie Round Robin) for server selection. For+complex algorithms, the client should rely on a load balancer to provide load+balancing configuration and the list of servers to which the client should send+requests. The balancer will update the server list as needed to balance the load+as well as handle server unavailability or health issues. The load balancer will+make any necessary complex decisions and inform the client. The load balancer+may communicate with the backend servers to collect load and health information.++#### Security++The load balancer may be separate from the actual server backends and a+compromise of the load balancer should only lead to a compromise of the+loadbalancing functionality. In other words, a compromised load balancer should+not be able to cause a client to trust a (potentially malicious) backend server+any more than in a comparable situation without loadbalancing.+ # Proposed Architecture -The gRPC load balancing approach follows the third approach, by having an-external load balancer which provides simple clients with a list of servers.+The gRPC load balancing implements the external load balancing server approach:+an external load balancer provides simple clients with an up-to-date list of+servers.++![image](images/load_balancing_design.png)++1. On startup, the gRPC client issues a name resolution request for the service.+   The name will resolve to one or more IP addresses to gRPC servers, a hint on+   whether the IP address(es) point to a load balancer or not, and also return a+   client config.+2. The gRPC client connects to a gRPC Server.+   1. If the name resolution has hinted that the endpoint is a load balancer,+      the client will attempt to open a stream to the load balancer service. The+      server may respond in only one of the following ways.+      1. `status::UNIMPLEMENTED`. There is no loadbalancing in use. The client","In the revised security design, the naming system's response will indicate whether the endpoint is loadbalancer or not. I don't think we need this fallback behavior any more. I think it's appropriate to fail in this case.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7216,70309727,2016-07-11T18:22:32Z,src/ruby/ext/grpc/rb_compression_options.c,"@@ -0,0 +1,592 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <ruby/ruby.h>++#include ""rb_compression_options.h""+#include ""rb_grpc_imports.generated.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>+#include <grpc/impl/codegen/compression_types.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <string.h>++#include ""rb_grpc.h""++static VALUE grpc_rb_cCompressionOptions = Qnil;++/* grpc_rb_compression_options wraps a grpc_compression_options.+ * It can be used to get the channel argument key-values for specific+ * compression settings. */++/* Note that ruby objects of this type don't carry any state in other+ * Ruby objects and don't have a mark for GC. */+typedef struct grpc_rb_compression_options {+  /* The actual compression options that's being wrapped */+  grpc_compression_options *wrapped;+} grpc_rb_compression_options;++/* Destroys the compression options instances and free the+ * wrapped grpc compression options. */+static void grpc_rb_compression_options_free(void *p) {+  grpc_rb_compression_options *wrapper = NULL;+  if (p == NULL) {+    return;+  };+  wrapper = (grpc_rb_compression_options *)p;++  if (wrapper->wrapped != NULL) {+    gpr_free(wrapper->wrapped);+    wrapper->wrapped = NULL;+  }++  xfree(p);+}++/* Ruby recognized data type for the CompressionOptions class. */+static rb_data_type_t grpc_rb_compression_options_data_type = {+    ""grpc_compression_options"",+    {NULL,+     grpc_rb_compression_options_free,+     GRPC_RB_MEMSIZE_UNAVAILABLE,+     {NULL, NULL}},+    NULL,+    NULL,+#ifdef RUBY_TYPED_FREE_IMMEDIATELY+    RUBY_TYPED_FREE_IMMEDIATELY+#endif+};++/* Allocates CompressionOptions instances.+   Allocate the wrapped grpc compression options and+   initialize it here too. */+static VALUE grpc_rb_compression_options_alloc(VALUE cls) {+  grpc_rb_compression_options *wrapper =+      gpr_malloc(sizeof(grpc_rb_compression_options));+  wrapper->wrapped = NULL;+  wrapper->wrapped = gpr_malloc(sizeof(grpc_compression_options));+  grpc_compression_options_init(wrapper->wrapped);++  return TypedData_Wrap_Struct(cls, &grpc_rb_compression_options_data_type,+                               wrapper);+}++/* Disables a compression algorithm, given the GRPC core internal number of a+ * compression algorithm. */+VALUE grpc_rb_compression_options_disable_compression_algorithm_internal(+    VALUE self, VALUE algorithm_to_disable) {+  grpc_compression_algorithm compression_algorithm = 0;+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_algorithm =+      (grpc_compression_algorithm)NUM2INT(algorithm_to_disable);++  grpc_compression_options_disable_algorithm(wrapper->wrapped,+                                             compression_algorithm);++  return Qnil;+}++/* Provides a bitset as a ruby number that is suitable to pass to+ * the GRPC core as a channel argument to enable compression algorithms. */+/* Gets the compression internal enum value of a compression level given its+ * name. */+grpc_compression_level grpc_rb_compression_options_level_name_to_value_internal(+    VALUE level_name) {+  VALUE none_symbol = Qnil;+  VALUE low_symbol = Qnil;+  VALUE medium_symbol = Qnil;+  VALUE high_symbol = Qnil;++  Check_Type(level_name, T_SYMBOL);++  /* Ruby symbols that correspond to names of valid compression levels */+  none_symbol =+      rb_const_get(grpc_rb_cCompressionOptions, rb_intern(""COMPRESS_NONE_SYM""));+  low_symbol =+      rb_const_get(grpc_rb_cCompressionOptions, rb_intern(""COMPRESS_LOW_SYM""));+  medium_symbol = rb_const_get(grpc_rb_cCompressionOptions,+                               rb_intern(""COMPRESS_MEDIUM_SYM""));+  high_symbol =+      rb_const_get(grpc_rb_cCompressionOptions, rb_intern(""COMPRESS_HIGH_SYM""));++  /* Check the compression level of the name passed in, and see which macro+   * from the GRPC core header files match. */+  if (RTEST(rb_funcall(level_name, rb_intern(""==""), 1, none_symbol)) != 0) {+    return GRPC_COMPRESS_LEVEL_NONE;+  } else if (RTEST(rb_funcall(level_name, rb_intern(""==""), 1, low_symbol)) !=+             0) {+    return GRPC_COMPRESS_LEVEL_LOW;+  } else if (RTEST(rb_funcall(level_name, rb_intern(""==""), 1, medium_symbol)) !=+             0) {+    return GRPC_COMPRESS_LEVEL_MED;+  } else if (RTEST(rb_funcall(level_name, rb_intern(""==""), 1, high_symbol)) !=+             0) {+    return GRPC_COMPRESS_LEVEL_HIGH;+  } else {+    rb_raise(rb_eArgError,+             ""Unrecognized compression level name.""+             ""Valid compression level names are none, low, medium, and high."");+  }+}++/*  Wrapper over grpc_rb_compression_options_level_name_to_value available for+ * use or testing.+ * Raises an exception for unrecognized level names. */+VALUE grpc_rb_compression_options_level_name_to_value(VALUE self,+                                                      VALUE level_name) {+  (void)self;+  return INT2NUM((int)grpc_rb_compression_options_level_name_to_value_internal(+      level_name));+}++/* Sets the default compression level, given the name of a compression level.+ * Throws an error if no algorithm matched. */+void grpc_rb_compression_options_set_default_level(+    grpc_compression_options *options, VALUE new_level_name) {+  options->default_level.level =+      grpc_rb_compression_options_level_name_to_value_internal(new_level_name);+  options->default_level.is_set = 1;+}++/* Gets the internal value of a compression algorithm suitable as the value+ * in a GRPC core channel arguments hash.+ * algorithm_value is an out parameter.+ * Raises an error if the name of the algorithm passed in is invalid. */+void grpc_rb_compression_options_algorithm_name_to_value_internal(+    grpc_compression_algorithm *algorithm_value, VALUE algorithm_name) {+  char *name_str = NULL;+  long name_len = 0;+  VALUE algorithm_name_as_string = Qnil;++  Check_Type(algorithm_name, T_SYMBOL);++  /* Convert the algorithm symbol to a ruby string, so that we can get the+   * correct C string out of it. */+  algorithm_name_as_string = rb_funcall(algorithm_name, rb_intern(""to_s""), 0);++  name_str = RSTRING_PTR(algorithm_name_as_string);+  name_len = RSTRING_LEN(algorithm_name_as_string);++  /* Raise an error if the name isn't recognized as a compression algorithm by+   * the algorithm parse function+   * in GRPC core. */+  if (!grpc_compression_algorithm_parse(name_str, name_len, algorithm_value)) {+    rb_raise(rb_eNameError, ""Invalid compression algorithm name: %s"",+             StringValueCStr(algorithm_name_as_string));+  }+}++/* Wrapper around algorithm_name_to_value_internal function available for use or+ * testing. */+VALUE grpc_rb_compression_options_algorithm_name_to_value(+    VALUE self, VALUE algorithm_name) {+  grpc_compression_algorithm algorithm_value;+  (void)self;+  grpc_rb_compression_options_algorithm_name_to_value_internal(&algorithm_value,+                                                               algorithm_name);++  return INT2NUM((int)algorithm_value);+}++/* Indicates whether a given algorithm is enabled on this instance, given the+ * readable algorithm name. */+VALUE grpc_rb_compression_options_is_algorithm_enabled(VALUE self,+                                                       VALUE algorithm_name) {+  grpc_rb_compression_options *wrapper = NULL;+  grpc_compression_algorithm internal_algorithm_value;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  grpc_rb_compression_options_algorithm_name_to_value_internal(+      &internal_algorithm_value, algorithm_name);++  if (grpc_compression_options_is_algorithm_enabled(wrapper->wrapped,+                                                    internal_algorithm_value)) {+    return Qtrue;+  }+  return Qfalse;+}++/* Sets the default algorithm to the name of the algorithm passed in.+ * Raises an error if the name is not a valid compression algorithm name. */+void grpc_rb_compression_options_set_default_algorithm(+    grpc_compression_options *options, VALUE algorithm_name) {+  grpc_rb_compression_options_algorithm_name_to_value_internal(+      &options->default_algorithm.algorithm, algorithm_name);+  options->default_algorithm.is_set = 1;+}++/* Disables an algorithm on the current instance, given the name of an+ * algorithm.+ * Fails if the algorithm name is invalid. */+void grpc_rb_compression_options_disable_algorithm(+    grpc_compression_options *compression_options, VALUE algorithm_name) {+  grpc_compression_algorithm internal_algorithm_value;++  grpc_rb_compression_options_algorithm_name_to_value_internal(+      &internal_algorithm_value, algorithm_name);+  grpc_compression_options_disable_algorithm(compression_options,+                                             internal_algorithm_value);+}++/* Provides a ruby hash of GRPC core channel argument key-values that+ * correspond to the compression settings on this instance. */+VALUE grpc_rb_compression_options_to_hash(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;+  grpc_compression_options *compression_options = NULL;+  VALUE channel_arg_hash = rb_hash_new();+  VALUE key = Qnil;+  VALUE value = Qnil;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_options = wrapper->wrapped;++  /* Add key-value pairs to the new Ruby hash. It can be used+   * as GRPC core channel arguments. */+  if (compression_options->default_level.is_set) {+    key = rb_str_new2(GRPC_COMPRESSION_CHANNEL_DEFAULT_LEVEL);+    value = INT2NUM((int)compression_options->default_level.level);+    rb_hash_aset(channel_arg_hash, key, value);+  }++  if (compression_options->default_algorithm.is_set) {+    key = rb_str_new2(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM);+    value = INT2NUM((int)compression_options->default_algorithm.algorithm);+    rb_hash_aset(channel_arg_hash, key, value);+  }++  key = rb_str_new2(GRPC_COMPRESSION_CHANNEL_ENABLED_ALGORITHMS_BITSET);+  value = INT2NUM((int)compression_options->enabled_algorithms_bitset);+  rb_hash_aset(channel_arg_hash, key, value);++  return channel_arg_hash;+}++/* Converts an internal enum level value to a readable level name.+ * Fails if the level value is invalid. */+VALUE grpc_rb_compression_options_level_value_to_name_internal(+    grpc_compression_level compression_value) {+  switch (compression_value) {+    case GRPC_COMPRESS_LEVEL_NONE:+      return rb_const_get(grpc_rb_cCompressionOptions,+                          rb_intern(""COMPRESS_NONE_SYM""));+    case GRPC_COMPRESS_LEVEL_LOW:+      return rb_const_get(grpc_rb_cCompressionOptions,+                          rb_intern(""COMPRESS_LOW_SYM""));+    case GRPC_COMPRESS_LEVEL_MED:+      return rb_const_get(grpc_rb_cCompressionOptions,+                          rb_intern(""COMPRESS_MEDIUM_SYM""));+    case GRPC_COMPRESS_LEVEL_HIGH:+      return rb_const_get(grpc_rb_cCompressionOptions,+                          rb_intern(""COMPRESS_HIGH_SYM""));+    default:+      rb_raise(+          rb_eArgError,+          ""Failed to convert compression level value to name for value: %d"",+          (int)compression_value);+  }+}++/* Wrapper of internal method that makes it available for use and testing. */+VALUE grpc_rb_compression_options_level_value_to_name(VALUE self,+                                                      VALUE compression_value) {+  (void)self;+  Check_Type(compression_value, T_FIXNUM);+  return grpc_rb_compression_options_level_value_to_name_internal(+      (grpc_compression_level)NUM2INT(compression_value));+}++/* Converts an algorithm internal enum value to a readable name.+ * Fails if the enum value is invalid. */+VALUE grpc_rb_compression_options_algorithm_value_to_name_internal(+    grpc_compression_algorithm internal_value) {+  char *algorithm_name = NULL;++  if (!grpc_compression_algorithm_name(internal_value, &algorithm_name)) {+    rb_raise(rb_eArgError, ""Failed to convert algorithm value to name"");+  }++  return ID2SYM(rb_intern(algorithm_name));+}++/* Wrapper of algorithm_to_name internal function available for ues and testing.+ */+VALUE grpc_rb_compression_options_algorithm_value_to_name(+    VALUE self, VALUE algorithm_value) {+  grpc_compression_algorithm algorithm_internal_value =+      (grpc_compression_algorithm)NUM2INT(algorithm_value);+  (void)self;++  return grpc_rb_compression_options_algorithm_value_to_name_internal(+      algorithm_internal_value);+}++/* Gets the internal value of the default compression level that is to be passed+ * to the GRPC core as a channel argument value.+ * A nil return value means that it hasn't been set. */+VALUE grpc_rb_compression_options_get_default_algorithm_internal_value(+    VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  if (wrapper->wrapped->default_algorithm.is_set) {+    return INT2NUM(wrapper->wrapped->default_algorithm.algorithm);+  }+  return Qnil;+}++/* Gets the readable name of the default algorithm if one has been set.+ * Returns nil if no algorithm has been set. */+VALUE grpc_rb_compression_options_get_default_algorithm(VALUE self) {+  VALUE algorithm_value =+      grpc_rb_compression_options_get_default_algorithm_internal_value(self);++  if (RTEST(algorithm_value)) {+    return grpc_rb_compression_options_algorithm_value_to_name(self,+                                                               algorithm_value);+  }++  return Qnil;+}++/* Gets the internal enum value of the default algorithm if one has been set.+ * Returns nil if no default algorithm has been set. */+VALUE grpc_rb_compression_options_get_default_level_internal_value(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  if (wrapper->wrapped->default_level.is_set) {+    return INT2NUM((int)wrapper->wrapped->default_level.level);+  }+  return Qnil;+}++/* Gets the internal value of the default compression level that is to be passed+ * to the GRPC core as a channel argument value.+ * A nil return value means that it hasn't been set. */+VALUE grpc_rb_compression_options_get_default_level(VALUE self) {+  grpc_compression_level internal_value;+  VALUE ruby_value =+      grpc_rb_compression_options_get_default_level_internal_value(self);++  if (RTEST(ruby_value)) {+    internal_value = (grpc_compression_level)NUM2INT(ruby_value);+    return grpc_rb_compression_options_level_value_to_name_internal(+        internal_value);+  }++  return Qnil;+}++/* Gets a list of the disabled algorithms as readable names.+ * Returns an empty list of no algorithms have been disabled. */+VALUE grpc_rb_compression_options_get_disabled_algorithms(VALUE self) {+  VALUE disabled_algorithms = rb_ary_new();+  grpc_compression_algorithm internal_value;+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  for (internal_value = GRPC_COMPRESS_NONE;+       internal_value < GRPC_COMPRESS_ALGORITHMS_COUNT; internal_value++) {+    if (!grpc_compression_options_is_algorithm_enabled(wrapper->wrapped,+                                                       internal_value)) {+      rb_ary_push(disabled_algorithms,+                  grpc_rb_compression_options_algorithm_value_to_name_internal(+                      internal_value));+    }+  }+  return disabled_algorithms;+}++/* Provides a bitset as a ruby number that is suitable to pass to+ * the GRPC core as a channel argument to enable compression algorithms. */+VALUE grpc_rb_compression_options_get_enabled_algorithms_bitset(VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  return INT2NUM((int)wrapper->wrapped->enabled_algorithms_bitset);+}++/* Initializes the compression options wrapper.+ * Takes an optional hash parameter.+ *+ * Example call-seq:+ *   options = CompressionOptions.new(+ *     default_level: :none,+ *     disabled_algorithms: [:gzip]+ *   )+ *   channel_arg hash = Hash.new[...]+ *   channel_arg_hash_with_compression_options = channel_arg_hash.merge(options)+ */+VALUE grpc_rb_compression_options_init(int argc, VALUE *argv, VALUE self) {+  grpc_rb_compression_options *wrapper = NULL;+  VALUE default_algorithm = Qnil;+  VALUE default_level = Qnil;+  VALUE disabled_algorithms = Qnil;+  VALUE algorithm_name = Qnil;+  VALUE hash_arg = Qnil;++  rb_scan_args(argc, argv, ""01"", &hash_arg);++  /* Check if the hash parameter was passed, or if invalid arguments were+   * passed. */+  if (hash_arg == Qnil) {+    return self;+  } else if (TYPE(hash_arg) != T_HASH || argc > 1) {+    rb_raise(rb_eArgError,+             ""Invalid arguments. Expecting optional hash parameter"");+  }++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);++  /* Set the default algorithm if one was chosen. */+  default_algorithm =+      rb_hash_aref(hash_arg, ID2SYM(rb_intern(""default_algorithm"")));+  if (default_algorithm != Qnil) {+    grpc_rb_compression_options_set_default_algorithm(wrapper->wrapped,+                                                      default_algorithm);+  }++  /* Set the default level if one was chosen. */+  default_level = rb_hash_aref(hash_arg, ID2SYM(rb_intern(""default_level"")));+  if (default_level != Qnil) {+    grpc_rb_compression_options_set_default_level(wrapper->wrapped,+                                                  default_level);+  }++  /* Set the disabled algorithms if any were chosen. */+  disabled_algorithms =+      rb_hash_aref(hash_arg, ID2SYM(rb_intern(""disabled_algorithms"")));+  if (disabled_algorithms != Qnil) {+    Check_Type(disabled_algorithms, T_ARRAY);++    for (int i = 0; i < RARRAY_LEN(disabled_algorithms); i++) {+      algorithm_name = rb_ary_entry(disabled_algorithms, i);+      grpc_rb_compression_options_disable_algorithm(wrapper->wrapped,+                                                    algorithm_name);+    }+  }++  return self;+}++void Init_grpc_compression_options() {+  grpc_rb_cCompressionOptions = rb_define_class_under(+      grpc_rb_mGrpcCore, ""CompressionOptions"", rb_cObject);++  /* Allocates an object managed by the ruby runtime. */+  rb_define_alloc_func(grpc_rb_cCompressionOptions,+                       grpc_rb_compression_options_alloc);++  /* Initializes the ruby wrapper. #new method takes an optional hash argument.+   */+  rb_define_method(grpc_rb_cCompressionOptions, ""initialize"",+                   grpc_rb_compression_options_init, -1);++  /* Gets the bitset of enabled algorithms. */+  rb_define_method(grpc_rb_cCompressionOptions, ""enabled_algorithms_bitset"",+                   grpc_rb_compression_options_get_enabled_algorithms_bitset,+                   0);++  /* Methods for getting the default algorithm, default level, and disabled+   * algorithms as readable names. */+  rb_define_method(grpc_rb_cCompressionOptions, ""default_algorithm"",+                   grpc_rb_compression_options_get_default_algorithm, 0);+  rb_define_method(grpc_rb_cCompressionOptions, ""default_level"",+                   grpc_rb_compression_options_get_default_level, 0);+  rb_define_method(grpc_rb_cCompressionOptions, ""disabled_algorithms"",+                   grpc_rb_compression_options_get_disabled_algorithms, 0);++  /* Methods for getting the internal enum default algorithm and level enum+   * values of an instance. */+  rb_define_method(+      grpc_rb_cCompressionOptions, ""default_algorithm_internal_value"",+      grpc_rb_compression_options_get_default_algorithm_internal_value, 0);+  rb_define_method(grpc_rb_cCompressionOptions, ""default_level_internal_value"",+                   grpc_rb_compression_options_get_default_level_internal_value,+                   0);++  /* Determines whether or not an algorithm is enabled, given a readable+   * algorithm name.*/+  rb_define_method(grpc_rb_cCompressionOptions, ""is_algorithm_enabled"",+                   grpc_rb_compression_options_is_algorithm_enabled, 1);++  /* Methods for converting to and from algorithm enum values and their readable+   * names. */+  rb_define_singleton_method(+      grpc_rb_cCompressionOptions, ""algorithm_name_to_value"",+      grpc_rb_compression_options_algorithm_name_to_value, 1);+  rb_define_singleton_method(+      grpc_rb_cCompressionOptions, ""algorithm_value_to_name"",+      grpc_rb_compression_options_algorithm_value_to_name, 1);++  /* Methods for converting to and from compression level enum values and their+   * readable names. */+  rb_define_singleton_method(grpc_rb_cCompressionOptions, ""level_name_to_value"",+                             grpc_rb_compression_options_level_name_to_value,+                             1);+  rb_define_singleton_method(grpc_rb_cCompressionOptions, ""level_value_to_name"",+                             grpc_rb_compression_options_level_value_to_name,+                             1);++  /* Provides a hash of the compression settings suitable+   * for passing to server or channel args. */+  rb_define_method(grpc_rb_cCompressionOptions, ""to_hash"",+                   grpc_rb_compression_options_to_hash, 0);+  rb_define_alias(grpc_rb_cCompressionOptions, ""to_channel_arg_hash"",+                  ""to_hash"");++  /* Ruby symbols for the names of the different compression levels. */+  rb_define_const(grpc_rb_cCompressionOptions, ""COMPRESS_NONE_SYM"",+                  ID2SYM(rb_intern(""none"")));","You shouldn't need constants that hold symbols. The symbol itself should be a suitable constant for referring to a level. And if you get rid of the constants, you can just store the ID directly, like in the channel code (https://github.com/grpc/grpc/blob/master/src/ruby/ext/grpc/rb_channel.c#L377).",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7216,70310220,2016-07-11T18:25:20Z,src/ruby/ext/grpc/rb_compression_options.c,"@@ -0,0 +1,592 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <ruby/ruby.h>++#include ""rb_compression_options.h""+#include ""rb_grpc_imports.generated.h""++#include <grpc/compression.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>+#include <grpc/impl/codegen/compression_types.h>+#include <grpc/impl/codegen/grpc_types.h>+#include <string.h>++#include ""rb_grpc.h""++static VALUE grpc_rb_cCompressionOptions = Qnil;++/* grpc_rb_compression_options wraps a grpc_compression_options.+ * It can be used to get the channel argument key-values for specific+ * compression settings. */++/* Note that ruby objects of this type don't carry any state in other+ * Ruby objects and don't have a mark for GC. */+typedef struct grpc_rb_compression_options {+  /* The actual compression options that's being wrapped */+  grpc_compression_options *wrapped;+} grpc_rb_compression_options;++/* Destroys the compression options instances and free the+ * wrapped grpc compression options. */+static void grpc_rb_compression_options_free(void *p) {+  grpc_rb_compression_options *wrapper = NULL;+  if (p == NULL) {+    return;+  };+  wrapper = (grpc_rb_compression_options *)p;++  if (wrapper->wrapped != NULL) {+    gpr_free(wrapper->wrapped);+    wrapper->wrapped = NULL;+  }++  xfree(p);+}++/* Ruby recognized data type for the CompressionOptions class. */+static rb_data_type_t grpc_rb_compression_options_data_type = {+    ""grpc_compression_options"",+    {NULL,+     grpc_rb_compression_options_free,+     GRPC_RB_MEMSIZE_UNAVAILABLE,+     {NULL, NULL}},+    NULL,+    NULL,+#ifdef RUBY_TYPED_FREE_IMMEDIATELY+    RUBY_TYPED_FREE_IMMEDIATELY+#endif+};++/* Allocates CompressionOptions instances.+   Allocate the wrapped grpc compression options and+   initialize it here too. */+static VALUE grpc_rb_compression_options_alloc(VALUE cls) {+  grpc_rb_compression_options *wrapper =+      gpr_malloc(sizeof(grpc_rb_compression_options));+  wrapper->wrapped = NULL;+  wrapper->wrapped = gpr_malloc(sizeof(grpc_compression_options));+  grpc_compression_options_init(wrapper->wrapped);++  return TypedData_Wrap_Struct(cls, &grpc_rb_compression_options_data_type,+                               wrapper);+}++/* Disables a compression algorithm, given the GRPC core internal number of a+ * compression algorithm. */+VALUE grpc_rb_compression_options_disable_compression_algorithm_internal(+    VALUE self, VALUE algorithm_to_disable) {+  grpc_compression_algorithm compression_algorithm = 0;+  grpc_rb_compression_options *wrapper = NULL;++  TypedData_Get_Struct(self, grpc_rb_compression_options,+                       &grpc_rb_compression_options_data_type, wrapper);+  compression_algorithm =+      (grpc_compression_algorithm)NUM2INT(algorithm_to_disable);++  grpc_compression_options_disable_algorithm(wrapper->wrapped,+                                             compression_algorithm);++  return Qnil;+}++/* Provides a bitset as a ruby number that is suitable to pass to+ * the GRPC core as a channel argument to enable compression algorithms. */+/* Gets the compression internal enum value of a compression level given its+ * name. */+grpc_compression_level grpc_rb_compression_options_level_name_to_value_internal(+    VALUE level_name) {+  VALUE none_symbol = Qnil;+  VALUE low_symbol = Qnil;+  VALUE medium_symbol = Qnil;+  VALUE high_symbol = Qnil;++  Check_Type(level_name, T_SYMBOL);++  /* Ruby symbols that correspond to names of valid compression levels */+  none_symbol =+      rb_const_get(grpc_rb_cCompressionOptions, rb_intern(""COMPRESS_NONE_SYM""));+  low_symbol =+      rb_const_get(grpc_rb_cCompressionOptions, rb_intern(""COMPRESS_LOW_SYM""));+  medium_symbol = rb_const_get(grpc_rb_cCompressionOptions,+                               rb_intern(""COMPRESS_MEDIUM_SYM""));+  high_symbol =+      rb_const_get(grpc_rb_cCompressionOptions, rb_intern(""COMPRESS_HIGH_SYM""));++  /* Check the compression level of the name passed in, and see which macro+   * from the GRPC core header files match. */+  if (RTEST(rb_funcall(level_name, rb_intern(""==""), 1, none_symbol)) != 0) {","If you get rid of the constants and store the IDs directly, as I suggested in my other comment, you can do direct comparisons, like we do in the channel code (https://github.com/grpc/grpc/blob/master/src/ruby/ext/grpc/rb_channel.c#L147).",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7216,70325374,2016-07-11T19:57:56Z,src/ruby/spec/compression_options_spec.rb,"@@ -0,0 +1,308 @@+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++require 'grpc'++describe GRPC::Core::CompressionOptions do+  # Names of supported compression algorithms and their internal enum values+  ALGORITHMS = {+    identity: 0,+    deflate: 1,+    gzip: 2+  }++  # Compression algorithms and their corresponding bits in the internal+  # enabled algorithms bitset for GRPC core channel args.+  ALGORITHM_BITS = {+    identity: 0x1,+    deflate: 0x2,+    gzip: 0x4+  }++  # ""enabled algorithms bitset"" when all compression algorithms are enabled+  ALL_ENABLED_BITSET = 0x7","Alternatively, you could assume that the individual bitset values for each algorithm will stay constant, but not assume that the algorithm list you have is complete. So, you could check that disabling a particular algorithm causes the corresponding bit to be 0 in the bitset.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7317,70523364,2016-07-12T21:11:39Z,src/python/grpcio/_unixccompiler_patch.py,"@@ -32,90 +32,43 @@ from distutils import ccompiler from distutils import errors from distutils import unixccompiler+from distutils import util import os import os.path import shutil import sys import tempfile +def _unix_commandfile_spawn(unused_self, command, *args, **kwargs):","Erp, the `*CCompiler` classes are old-style, so `super()` doesn't work with them. Just going to directly call the `CCompiler.spawn` method.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7347,70534878,2016-07-12T22:33:54Z,src/ruby/pb/test/client.rb,"@@ -216,10 +233,29 @@ def each_item   end end +# Intended to be used to wrap a call_op, and to adjust+# the write flag of the call_op in between messages yielded to it.+class WriteFlagSettingStreamingInputEnumerable+  attr_accessor :call_op++  def initialize(requests_and_write_flags)+    @requests_and_write_flags = requests_and_write_flags+  end++  def each+    @requests_and_write_flags.each do |request_and_flag|+      @call_op.write_flag = request_and_flag[:write_flag] if+        request_and_flag[:write_flag]","I think this won't do exactly what you want. It will never set the write flag to 0. Instead, I think you should set `@call_op.write_flag` unconditionally, and pass `0` for cases where no write flag should be set.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7285,70672441,2016-07-13T17:39:28Z,test/cpp/qps/server_async.cc,"@@ -123,21 +123,22 @@ class AsyncQpsServerTest : public Server {      for (int i = 0; i < num_threads; i++) {       shutdown_state_.emplace_back(new PerThreadShutdownState());-    }-    for (int i = 0; i < num_threads; i++) {       threads_.emplace_back(&AsyncQpsServerTest::ThreadFunc, this, i);     }   }   ~AsyncQpsServerTest() {     for (auto ss = shutdown_state_.begin(); ss != shutdown_state_.end(); ++ss) {-      (*ss)->set_shutdown();+      std::lock_guard<std::mutex> lock((*ss)->mutex);+      (*ss)->shutdown = true;     }     server_->Shutdown();",I added a deadline here in #6737 to deflake (with good success),
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,70694020,2016-07-13T19:39:39Z,src/objective-c/tests/End2EndTest/Podfile,"@@ -0,0 +1,83 @@+source 'https://github.com/CocoaPods/Specs.git'+platform :ios, '8.0'++install! 'cocoapods', :deterministic_uuids => false++# Location of gRPC's repo root relative to this file.+GRPC_LOCAL_SRC = '../../../..'++# Install the dependencies in the main target plus all test targets.+%w(+  End2EndTest+).each do |target_name|+  target target_name do+    pod 'BoringSSL', :podspec => ""#{GRPC_LOCAL_SRC}/src/objective-c"", :inhibit_warnings => true+    pod 'CronetFramework', :podspec => ""#{GRPC_LOCAL_SRC}/src/objective-c""+    pod 'gRPC-Core', :path => GRPC_LOCAL_SRC+    pod 'gRPC-Cronet', :path => GRPC_LOCAL_SRC+  end+end++# gRPC-Core.podspec needs to be modified to be successfully used for local development. A Podfile's+# pre_install hook lets us do that. The block passed to it runs after the podspecs are downloaded+# and before they are installed in the user project.+#+# This podspec searches for the gRPC core library headers under ""$(PODS_ROOT)/gRPC-Core"", where+# Cocoapods normally places the downloaded sources. When doing local development of the libraries,+# though, Cocoapods just takes the sources from whatever directory was specified using `:path`, and+# doesn't copy them under $(PODS_ROOT). When using static libraries, one can sometimes rely on the+# symbolic links to the pods headers that Cocoapods creates under ""$(PODS_ROOT)/Headers"". But those+# aren't created when using dynamic frameworks. So our solution is to modify the podspec on the fly+# to point at the local directory where the sources are.+#+# TODO(jcanizales): Send a PR to Cocoapods to get rid of this need.+pre_install do |installer|+  # This is the gRPC-Core podspec object, as initialized by its podspec file.+  grpc_core_spec = installer.pod_targets.find{|t| t.name == 'gRPC-Core'}.root_spec++  # Copied from gRPC-Core.podspec, except for the adjusted src_root:+  src_root = ""$(PODS_ROOT)/../#{GRPC_LOCAL_SRC}""+  grpc_core_spec.pod_target_xcconfig = {+    'GRPC_SRC_ROOT' => src_root,+    'HEADER_SEARCH_PATHS' => '""$(inherited)"" ""$(GRPC_SRC_ROOT)/include""',+    'USER_HEADER_SEARCH_PATHS' => '""$(GRPC_SRC_ROOT)""',+    # If we don't set these two settings, `include/grpc/support/time.h` and+    # `src/core/lib/support/string.h` shadow the system `<time.h>` and `<string.h>`, breaking the+    # build.+    'USE_HEADERMAP' => 'NO',+    'ALWAYS_SEARCH_USER_PATHS' => 'NO',+  }++# This is the gRPC-Core podspec object, as initialized by its podspec file.+  grpc_core_spec = installer.pod_targets.find{|t| t.name == 'gRPC-Cronet'}.root_spec","Please fix the variable name (and the comment on top), and extract lines 38-49 and 54-65 into a single function so it's not duplicated.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,70713326,2016-07-13T21:34:54Z,src/objective-c/tests/End2EndTest/End2EndTest/AppDelegate.h,"@@ -0,0 +1,17 @@+//+//  AppDelegate.h+//  End2EndTest+//+//  Created by mxyan on 7/11/16.+//  Copyright © 2016 Google. All rights reserved.+//","Yeah, technically, the new files you create should be copyrighted in 2016. In practice I think it's not a big deal if we miss some, but IANAL!",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7371,70717896,2016-07-13T22:06:50Z,src/core/lib/iomgr/udp_server.c,"@@ -217,14 +217,23 @@ static int prepare_socket(int fd, const struct sockaddr *addr,     goto error;   } -  if (!grpc_set_socket_nonblocking(fd, 1) || !grpc_set_socket_cloexec(fd, 1)) {-    gpr_log(GPR_ERROR, ""Unable to configure socket %d: %s"", fd,-            strerror(errno));+  if (grpc_set_socket_nonblocking(fd, 1) != GRPC_ERROR_NONE) {+    gpr_log(GPR_ERROR, ""Unable to set nonblocking %d: %s"", fd, strerror(errno));","You are discarding all the info returned by `grpc_set_socket_nonblocking`. Ideally, this server should do something like https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/tcp_server_posix.c#L347 At the very least, print the contents of the `grpc_error` (see `grpc_error_string` at https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/error.h#L129).Same for the rest of the changes.",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6737,70724972,2016-07-13T23:14:25Z,src/core/ext/transport/chttp2/transport/internal.h,"@@ -319,10 +335,10 @@ struct grpc_chttp2_transport {      /** is a thread currently in the global lock */     bool global_active;-    /** is a thread currently writing */-    bool writing_active;     /** is a thread currently parsing */     bool parsing_active;+    /** write execution state of the transport */",Update the comment at line 361  (which still refers to the old `writing_active` field)  i.e```  /** state only accessible by the chain of execution that      set writing_active=1 */  grpc_chttp2_transport_writing writing;```,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,70727731,2016-07-13T23:41:28Z,src/objective-c/tests/End2EndTest/End2EndTest/h2_ssl.m,"@@ -0,0 +1,206 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>+#import <Cronet/Cronet.h>++#import <UIKit/UIKit.h>+#import ""AppDelegate.h""++typedef struct fullstack_secure_fixture_data {+  char *localaddr;+} fullstack_secure_fixture_data;","Having ~140 lines of (almost) duplicated code is not the greatest thing for maintainability, as we don't want to be manually cherrypicking changes from the original test into this one. If we were to #include the original `.c` file here, what changes would need to be done for it to work?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,70739483,2016-07-14T02:14:08Z,src/objective-c/tests/End2EndTest/End2EndTest/h2_ssl.m,"@@ -0,0 +1,206 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>","Oh, sorry for the lack of clarity. What I meant is that a line like `#include <grpc/grpc_cronet.h>` (as in https://github.com/grpc/grpc/blob/master/src/objective-c/GRPCClient/private/GRPCChannel.m#L38 ) might not compile if you put `grpc_cronet.h` in a framework called `GRPCCronet` (or anything other than exactly `grpc`).Putting these things as a subspec of gRPC-Core might be a way to solve it, as it'll then go inside `grpc.framework`.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6737,70744233,2016-07-14T03:33:32Z,src/core/lib/iomgr/workqueue.h,"@@ -49,34 +50,25 @@  /* grpc_workqueue is forward declared in exec_ctx.h */ ","Documented. enqueue is a little loose: I'm planning on changing the semantics a little in #7279, so I documented the union of that - it'll give us some future flexibility also.",
97579,rjshade,https://api.github.com/repos/grpc/grpc/pulls/7371,70790545,2016-07-14T11:38:41Z,src/core/lib/iomgr/udp_server.c,"@@ -217,14 +217,23 @@ static int prepare_socket(int fd, const struct sockaddr *addr,     goto error;   } -  if (!grpc_set_socket_nonblocking(fd, 1) || !grpc_set_socket_cloexec(fd, 1)) {-    gpr_log(GPR_ERROR, ""Unable to configure socket %d: %s"", fd,-            strerror(errno));+  if (grpc_set_socket_nonblocking(fd, 1) != GRPC_ERROR_NONE) {+    gpr_log(GPR_ERROR, ""Unable to set nonblocking %d: %s"", fd, strerror(errno));","@dgquintas thanks, these changes are intended to switch over to use grpc_error as simply as possible. I am working on a followup that will change udp_server.c to be more similar to tcp_server_posix.c in terms of error handling.Also this is a step to fixing https://github.com/grpc/grpc/issues/6624 ... but this stuff needs to build first.",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/6737,70857581,2016-07-14T18:25:40Z,src/core/lib/iomgr/ev_epoll_linux.c,"@@ -462,69 +473,72 @@ static void polling_island_remove_fd_locked(polling_island *pi, grpc_fd *fd, }  /* Might return NULL in case of an error */-static polling_island *polling_island_create(grpc_fd *initial_fd,+static polling_island *polling_island_create(grpc_exec_ctx *exec_ctx,+                                             grpc_fd *initial_fd,                                              grpc_error **error) {   polling_island *pi = NULL;-  char *err_msg;   const char *err_desc = ""polling_island_create""; -  /* Try to get one from the polling island freelist */-  gpr_mu_lock(&g_pi_freelist_mu);-  if (g_pi_freelist != NULL) {-    pi = g_pi_freelist;-    g_pi_freelist = g_pi_freelist->next_free;-    pi->next_free = NULL;-  }-  gpr_mu_unlock(&g_pi_freelist_mu);+  *error = GRPC_ERROR_NONE; -  /* Create new polling island if we could not get one from the free list */-  if (pi == NULL) {-    pi = gpr_malloc(sizeof(*pi));-    gpr_mu_init(&pi->mu);-    pi->fd_cnt = 0;-    pi->fd_capacity = 0;-    pi->fds = NULL;-  }+  pi = gpr_malloc(sizeof(*pi));+  gpr_mu_init(&pi->mu);+  pi->fd_cnt = 0;+  pi->fd_capacity = 0;+  pi->fds = NULL;+  pi->epoll_fd = -1;+  pi->workqueue = NULL; -  gpr_ref_init(&pi->ref_count, 0);+  gpr_atm_rel_store(&pi->ref_count, 0);   gpr_atm_rel_store(&pi->merged_to, (gpr_atm)NULL);    pi->epoll_fd = epoll_create1(EPOLL_CLOEXEC);    if (pi->epoll_fd < 0) {-    gpr_asprintf(&err_msg, ""epoll_create1 failed with error %d (%s)"", errno,-                 strerror(errno));-    append_error(error, GRPC_OS_ERROR(errno, err_msg), err_desc);-    gpr_free(err_msg);-  } else {-    polling_island_add_wakeup_fd_locked(pi, &grpc_global_wakeup_fd, error);-    pi->next_free = NULL;+    append_error(error, GRPC_OS_ERROR(errno, ""epoll_create1""), err_desc);+    goto done;+  } -    if (initial_fd != NULL) {-      /* Lock the polling island here just in case we got this structure from-         the freelist and the polling island lock was not released yet (by the-         code that adds the polling island to the freelist) */-      gpr_mu_lock(&pi->mu);-      polling_island_add_fds_locked(pi, &initial_fd, 1, true, error);-      gpr_mu_unlock(&pi->mu);-    }+  polling_island_add_wakeup_fd_locked(pi, &grpc_global_wakeup_fd, error);++  if (initial_fd != NULL) {+    polling_island_add_fds_locked(pi, &initial_fd, 1, true, error);+  }++  if (append_error(error, grpc_workqueue_create(exec_ctx, &pi->workqueue),+                   err_desc) &&+      *error == GRPC_ERROR_NONE) {+    polling_island_add_fds_locked(pi, &pi->workqueue->wakeup_read_fd, 1, true,+                                  error);+    GPR_ASSERT(pi->workqueue->wakeup_read_fd->polling_island == NULL);+    pi->workqueue->wakeup_read_fd->polling_island = pi;+    PI_ADD_REF(pi, ""fd"");   } +done:+  if (*error != GRPC_ERROR_NONE) {+    if (pi->epoll_fd >= 0) {+      close(pi->epoll_fd);+    }+    if (pi->workqueue != NULL) {+      GRPC_WORKQUEUE_UNREF(exec_ctx, pi->workqueue, ""polling_island"");+    }+    gpr_mu_destroy(&pi->mu);+    gpr_free(pi);+    pi = NULL;+  }   return pi; } -static void polling_island_delete(polling_island *pi) {+static void polling_island_delete(grpc_exec_ctx *exec_ctx, polling_island *pi) {   GPR_ASSERT(pi->fd_cnt == 0);    gpr_atm_rel_store(&pi->merged_to, (gpr_atm)NULL);",This line can be deleted; now that we do not have a freelist,
9807532,ivannaranjo,https://api.github.com/repos/grpc/grpc/pulls/7401,70953233,2016-07-15T10:33:37Z,src/csharp/Grpc.Core/Internal/NativeExtension.cs,"@@ -176,17 +178,18 @@ private static string GetArchitectureString()         // platform specific file name of the extension library         private static string GetNativeLibraryFilename()         {+            string architecture = GetArchitectureString();","You do the platform check twice, inside of `GetArchitectureString()` and here. Why not just move the architecture check here and return the hardcoded name of the library? The `String.Format` doesn't really gain much in this scenario.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7024,70981493,2016-07-15T14:26:05Z,test/core/end2end/tests/filter_call_init_fails.c,"@@ -0,0 +1,263 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdbool.h>+#include <stdio.h>+#include <string.h>++#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpc/support/useful.h>+#include ""src/core/lib/channel/channel_stack_builder.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""test/core/end2end/cq_verifier.h""++enum { TIMEOUT = 200000 };++static bool g_enable_filter = false;++static void *tag(intptr_t t) { return (void *)t; }++static grpc_end2end_test_fixture begin_test(grpc_end2end_test_config config,+                                            const char *test_name,+                                            grpc_channel_args *client_args,+                                            grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  gpr_log(GPR_INFO, ""%s/%s"", test_name, config.name);+  f = config.create_fixture(client_args, server_args);+  config.init_server(&f, server_args);+  config.init_client(&f, client_args);+  return f;+}++static gpr_timespec n_seconds_time(int n) {+  return GRPC_TIMEOUT_SECONDS_TO_DEADLINE(n);+}++static gpr_timespec five_seconds_time(void) { return n_seconds_time(5); }++static void drain_cq(grpc_completion_queue *cq) {+  grpc_event ev;+  do {+    ev = grpc_completion_queue_next(cq, five_seconds_time(), NULL);+  } while (ev.type != GRPC_QUEUE_SHUTDOWN);+}++static void shutdown_server(grpc_end2end_test_fixture *f) {+  if (!f->server) return;+  grpc_server_shutdown_and_notify(f->server, f->cq, tag(1000));+  GPR_ASSERT(grpc_completion_queue_pluck(+                 f->cq, tag(1000), GRPC_TIMEOUT_SECONDS_TO_DEADLINE(5), NULL)+                 .type == GRPC_OP_COMPLETE);+  grpc_server_destroy(f->server);+  f->server = NULL;+}++static void shutdown_client(grpc_end2end_test_fixture *f) {+  if (!f->client) return;+  grpc_channel_destroy(f->client);+  f->client = NULL;+}++static void end_test(grpc_end2end_test_fixture *f) {+  shutdown_server(f);+  shutdown_client(f);++  grpc_completion_queue_shutdown(f->cq);+  drain_cq(f->cq);+  grpc_completion_queue_destroy(f->cq);+}++// Simple request via a server filter that always fails to initialize+// the call.+static void test_request(grpc_end2end_test_config config) {+  grpc_call *c;+  grpc_call *s;+  gpr_slice request_payload_slice = gpr_slice_from_copied_string(""hello world"");+  grpc_byte_buffer *request_payload =+      grpc_raw_byte_buffer_create(&request_payload_slice, 1);+  gpr_timespec deadline = five_seconds_time();+  grpc_end2end_test_fixture f =+      begin_test(config, ""filter_call_init_fails"", NULL, NULL);+  cq_verifier *cqv = cq_verifier_create(f.cq);+  grpc_op ops[6];+  grpc_op *op;+  grpc_metadata_array initial_metadata_recv;+  grpc_metadata_array trailing_metadata_recv;+  grpc_metadata_array request_metadata_recv;+  grpc_byte_buffer *request_payload_recv = NULL;+  grpc_call_details call_details;+  grpc_status_code status;+  grpc_call_error error;+  char *details = NULL;+  size_t details_capacity = 0;++  c = grpc_channel_create_call(f.client, NULL, GRPC_PROPAGATE_DEFAULTS, f.cq,+                               ""/foo"", ""foo.test.google.fr"", deadline, NULL);+  GPR_ASSERT(c);++  grpc_metadata_array_init(&initial_metadata_recv);+  grpc_metadata_array_init(&trailing_metadata_recv);+  grpc_metadata_array_init(&request_metadata_recv);+  grpc_call_details_init(&call_details);++  memset(ops, 0, sizeof(ops));+  op = ops;+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = 0;+  op->data.send_initial_metadata.metadata = NULL;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_SEND_MESSAGE;+  op->data.send_message = request_payload;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &initial_metadata_recv;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;+  op->data.recv_status_on_client.status = &status;+  op->data.recv_status_on_client.status_details = &details;+  op->data.recv_status_on_client.status_details_capacity = &details_capacity;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  error = grpc_call_start_batch(c, ops, (size_t)(op - ops), tag(1), NULL);+  GPR_ASSERT(GRPC_CALL_OK == error);++  error =+      grpc_server_request_call(f.server, &s, &call_details,+                               &request_metadata_recv, f.cq, f.cq, tag(101));+  GPR_ASSERT(GRPC_CALL_OK == error);++  cq_expect_completion(cqv, tag(1), 1);+  cq_verify(cqv);++  GPR_ASSERT(status == GRPC_STATUS_PERMISSION_DENIED);+  GPR_ASSERT(0 == strcmp(details, ""access denied""));++  gpr_free(details);+  grpc_metadata_array_destroy(&initial_metadata_recv);+  grpc_metadata_array_destroy(&trailing_metadata_recv);+  grpc_metadata_array_destroy(&request_metadata_recv);+  grpc_call_details_destroy(&call_details);++  grpc_call_destroy(c);++  cq_verifier_destroy(cqv);++  grpc_byte_buffer_destroy(request_payload);+  grpc_byte_buffer_destroy(request_payload_recv);++  end_test(&f);+  config.tear_down_data(&f);+}++/*******************************************************************************+ * Test filter - always fails to initialize a call+ */++static grpc_error *init_call_elem(grpc_exec_ctx *exec_ctx,+                                  grpc_call_element *elem,+                                  grpc_call_element_args *args) {+  return grpc_error_set_int(GRPC_ERROR_CREATE(""access denied""),+                            GRPC_ERROR_INT_GRPC_STATUS,+                            GRPC_STATUS_PERMISSION_DENIED);+}++static void destroy_call_elem(grpc_exec_ctx *exec_ctx, grpc_call_element *elem,+                              const grpc_call_stats *stats,+                              void *and_free_memory) {}++static void init_channel_elem(grpc_exec_ctx *exec_ctx,+                              grpc_channel_element *elem,+                              grpc_channel_element_args *args) {}++static void destroy_channel_elem(grpc_exec_ctx *exec_ctx,+                                 grpc_channel_element *elem) {}++static const grpc_channel_filter test_filter = {+    grpc_call_next_op,+    grpc_channel_next_op,+    0,+    init_call_elem,+    grpc_call_stack_ignore_set_pollset_or_pollset_set,+    destroy_call_elem,+    0,+    init_channel_elem,+    destroy_channel_elem,+    grpc_call_next_get_peer,+    ""filter_call_init_fails""};++/*******************************************************************************+ * Registration+ */++static bool maybe_add_filter(grpc_channel_stack_builder *builder, void *arg) {+  if (g_enable_filter) {+    return grpc_channel_stack_builder_prepend_filter(builder, &test_filter,","Can you make this grpc_channel_stack_builder_append_filter, and make the stage priority below (currently 0) be MAX_INT?Reasoning:We often use fixtures to test how different filters behave. By doing an append at maximum priority, we force this filter to be the last one instantiated. By forcing it to be the last one instantiated, we allow all the other filters to be instantiated first, giving us a test of how gracefully (or not) the filters behave.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/6924,70988691,2016-07-15T15:09:23Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,888 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).","A paragraph or two on the control flow in this file would be useful here.Particularly:- the flow of retrieving the pick list (which functions are invoked, and when)- the flow of making a single pick",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6924,70989139,2016-07-15T15:12:05Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,888 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).","True. Ack. Note that there's another PR updating the gRPC LB docs: https://github.com/dgquintas/grpc/blob/26b60607297ff5caf01c72ba31f70b2641fd9198/doc/load-balancing.mdStill, that doesn't cover the things you mention, so yeah, +1",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,71016320,2016-07-15T18:07:40Z,src/objective-c/tests/CoreCronetEnd2EndTests/CoreCronetEnd2EndTests.m,"@@ -31,22 +31,31 @@  *  */ -#import ""ViewController.h""+#import <XCTest/XCTest.h> -@interface ViewController ()+@interface CoreCronetEnd2EndTests : XCTestCase",(You can delete this class extension.),
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,71070325,2016-07-16T19:01:29Z,src/objective-c/tests/CoreCronetEnd2EndTests/h2_ssl.m,"@@ -0,0 +1,203 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>+#import <Cronet/Cronet.h>++typedef struct fullstack_secure_fixture_data {+  char *localaddr;+} fullstack_secure_fixture_data;++static grpc_end2end_test_fixture chttp2_create_fixture_secure_fullstack(+    grpc_channel_args *client_args, grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data *ffd =+      gpr_malloc(sizeof(fullstack_secure_fixture_data));+  memset(&f, 0, sizeof(f));++  gpr_join_host_port(&ffd->localaddr, ""localhost"", port);++  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create(NULL);++  return f;+}++static void process_auth_failure(void *state, grpc_auth_context *ctx,+                                 const grpc_metadata *md, size_t md_count,+                                 grpc_process_auth_metadata_done_cb cb,+                                 void *user_data) {+  GPR_ASSERT(state == NULL);+  cb(user_data, NULL, 0, NULL, 0, GRPC_STATUS_UNAUTHENTICATED, NULL);+}++static void cronet_init_client_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args,+    cronet_engine *cronetEngine) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  f->client =+      grpc_cronet_secure_channel_create(cronetEngine, ffd->localaddr, client_args, NULL);+  GPR_ASSERT(f->client != NULL);+}++static void chttp2_init_server_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args,+    grpc_server_credentials *server_creds) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  if (f->server) {+    grpc_server_destroy(f->server);+  }+  f->server = grpc_server_create(server_args, NULL);+  grpc_server_register_completion_queue(f->server, f->cq, NULL);+  GPR_ASSERT(grpc_server_add_secure_http2_port(f->server, ffd->localaddr,+                                               server_creds));+  grpc_server_credentials_release(server_creds);+  grpc_server_start(f->server);+}++void chttp2_tear_down_secure_fullstack(grpc_end2end_test_fixture *f) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  gpr_free(ffd->localaddr);+  gpr_free(ffd);+}++static void cronet_init_client_simple_ssl_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args) {+  grpc_arg ssl_name_override = {GRPC_ARG_STRING,+                                GRPC_SSL_TARGET_NAME_OVERRIDE_ARG,+                                {""foo.test.google.fr""}};+  +  grpc_channel_args *new_client_args =+      grpc_channel_args_copy_and_add(client_args, &ssl_name_override, 1);+  [Cronet setHttp2Enabled:YES];+  [Cronet start];+  cronet_engine *cronetEngine = [Cronet getGlobalEngine];+  +  cronet_init_client_secure_fullstack(f, new_client_args, cronetEngine);+  grpc_channel_args_destroy(new_client_args);+}++static int fail_server_auth_check(grpc_channel_args *server_args) {+  size_t i;+  if (server_args == NULL) return 0;+  for (i = 0; i < server_args->num_args; i++) {+    if (strcmp(server_args->args[i].key, FAIL_AUTH_CHECK_SERVER_ARG_NAME) ==+        0) {+      return 1;+    }+  }+  return 0;+}++static void chttp2_init_server_simple_ssl_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args) {+  grpc_ssl_pem_key_cert_pair pem_cert_key_pair = {test_server1_key,+                                                  test_server1_cert};+  grpc_server_credentials *ssl_creds =+      grpc_ssl_server_credentials_create(NULL, &pem_cert_key_pair, 1, 0, NULL);+  if (fail_server_auth_check(server_args)) {+    grpc_auth_metadata_processor processor = {process_auth_failure, NULL, NULL};+    grpc_server_credentials_set_auth_metadata_processor(ssl_creds, processor);+  }+  chttp2_init_server_secure_fullstack(f, server_args, ssl_creds);+}++/* All test configurations */++static grpc_end2end_test_config configs[] = {+    {""chttp2/simple_ssl_fullstack"",+     FEATURE_MASK_SUPPORTS_DELAYED_CONNECTION |+         FEATURE_MASK_SUPPORTS_PER_CALL_CREDENTIALS,+     chttp2_create_fixture_secure_fullstack,+     cronet_init_client_simple_ssl_secure_fullstack,+     chttp2_init_server_simple_ssl_secure_fullstack,+     chttp2_tear_down_secure_fullstack},+};++int main(int argc, char **argv) {","Ok I'm getting contradictory signals :) On one hand, we want to evolve this independently, which is why we're duplicating it. And on the other, we want to be able to replace the whole thing with another duplicated fixture?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7424,71072049,2016-07-16T21:18:39Z,tools/distrib/python/grpcio_tools/setup.py,"@@ -76,6 +76,10 @@   if mac_target and (pkg_resources.parse_version(mac_target) < 		     pkg_resources.parse_version('10.9.0')):     os.environ['MACOSX_DEPLOYMENT_TARGET'] = '10.9'+    os.environ['_PYTHON_HOST_PLATFORM'] = re.sub(",Use of `re` without import of `re`; smells like what's at the heart of `NameError: name 're' is not defined` in the failed test logs?,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7374,71076120,2016-07-17T04:04:38Z,tools/distrib/python/grpcio_tools/grpc/tools/command.py,"@@ -35,6 +35,25 @@ from grpc.tools import protoc  +def build_package_protos(package_root):","Could we either rename this to `build_proto_modules` or rename `BuildProtoModules` to `BuildPackageProtos` (~~my preference is on the former, but~~ whatever's fine as long as the two correspond with each other)?EDIT: Took me like ten seconds to realize your name is probably better.",
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/7368,71091897,2016-07-17T23:16:24Z,src/objective-c/tests/CoreCronetEnd2EndTests/h2_ssl.m,"@@ -0,0 +1,203 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>+#import <Cronet/Cronet.h>++typedef struct fullstack_secure_fixture_data {+  char *localaddr;+} fullstack_secure_fixture_data;++static grpc_end2end_test_fixture chttp2_create_fixture_secure_fullstack(+    grpc_channel_args *client_args, grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data *ffd =+      gpr_malloc(sizeof(fullstack_secure_fixture_data));+  memset(&f, 0, sizeof(f));++  gpr_join_host_port(&ffd->localaddr, ""localhost"", port);++  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create(NULL);++  return f;+}++static void process_auth_failure(void *state, grpc_auth_context *ctx,+                                 const grpc_metadata *md, size_t md_count,+                                 grpc_process_auth_metadata_done_cb cb,+                                 void *user_data) {+  GPR_ASSERT(state == NULL);+  cb(user_data, NULL, 0, NULL, 0, GRPC_STATUS_UNAUTHENTICATED, NULL);+}++static void cronet_init_client_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args,+    cronet_engine *cronetEngine) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  f->client =+      grpc_cronet_secure_channel_create(cronetEngine, ffd->localaddr, client_args, NULL);+  GPR_ASSERT(f->client != NULL);+}++static void chttp2_init_server_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args,+    grpc_server_credentials *server_creds) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  if (f->server) {+    grpc_server_destroy(f->server);+  }+  f->server = grpc_server_create(server_args, NULL);+  grpc_server_register_completion_queue(f->server, f->cq, NULL);+  GPR_ASSERT(grpc_server_add_secure_http2_port(f->server, ffd->localaddr,+                                               server_creds));+  grpc_server_credentials_release(server_creds);+  grpc_server_start(f->server);+}++void chttp2_tear_down_secure_fullstack(grpc_end2end_test_fixture *f) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  gpr_free(ffd->localaddr);+  gpr_free(ffd);+}++static void cronet_init_client_simple_ssl_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args) {+  grpc_arg ssl_name_override = {GRPC_ARG_STRING,+                                GRPC_SSL_TARGET_NAME_OVERRIDE_ARG,+                                {""foo.test.google.fr""}};+  +  grpc_channel_args *new_client_args =+      grpc_channel_args_copy_and_add(client_args, &ssl_name_override, 1);+  [Cronet setHttp2Enabled:YES];+  [Cronet start];+  cronet_engine *cronetEngine = [Cronet getGlobalEngine];+  +  cronet_init_client_secure_fullstack(f, new_client_args, cronetEngine);+  grpc_channel_args_destroy(new_client_args);+}++static int fail_server_auth_check(grpc_channel_args *server_args) {+  size_t i;+  if (server_args == NULL) return 0;+  for (i = 0; i < server_args->num_args; i++) {+    if (strcmp(server_args->args[i].key, FAIL_AUTH_CHECK_SERVER_ARG_NAME) ==+        0) {+      return 1;+    }+  }+  return 0;+}++static void chttp2_init_server_simple_ssl_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args) {+  grpc_ssl_pem_key_cert_pair pem_cert_key_pair = {test_server1_key,+                                                  test_server1_cert};+  grpc_server_credentials *ssl_creds =+      grpc_ssl_server_credentials_create(NULL, &pem_cert_key_pair, 1, 0, NULL);+  if (fail_server_auth_check(server_args)) {+    grpc_auth_metadata_processor processor = {process_auth_failure, NULL, NULL};+    grpc_server_credentials_set_auth_metadata_processor(ssl_creds, processor);+  }+  chttp2_init_server_secure_fullstack(f, server_args, ssl_creds);+}++/* All test configurations */++static grpc_end2end_test_config configs[] = {+    {""chttp2/simple_ssl_fullstack"",+     FEATURE_MASK_SUPPORTS_DELAYED_CONNECTION |+         FEATURE_MASK_SUPPORTS_PER_CALL_CREDENTIALS,+     chttp2_create_fixture_secure_fullstack,+     cronet_init_client_simple_ssl_secure_fullstack,+     chttp2_init_server_simple_ssl_secure_fullstack,+     chttp2_tear_down_secure_fullstack},+};++int main(int argc, char **argv) {",In my understanding we duplicated it because it does not worth spending time worrying about duplication and refactoring codes for duplication in different test fixtures... correct me if I am wrong :)  By replacing I mean in the future we might want to use another fixture (not h2_ssl) for the testing in XCode. Leaving main() inside the fixture would make the replacement (a little bit) easier. Seems not conflicting for me,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7368,71092181,2016-07-17T23:33:32Z,src/objective-c/tests/CoreCronetEnd2EndTests/h2_ssl.m,"@@ -0,0 +1,203 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>+#import <Cronet/Cronet.h>++typedef struct fullstack_secure_fixture_data {+  char *localaddr;+} fullstack_secure_fixture_data;++static grpc_end2end_test_fixture chttp2_create_fixture_secure_fullstack(+    grpc_channel_args *client_args, grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data *ffd =+      gpr_malloc(sizeof(fullstack_secure_fixture_data));+  memset(&f, 0, sizeof(f));++  gpr_join_host_port(&ffd->localaddr, ""localhost"", port);++  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create(NULL);++  return f;+}++static void process_auth_failure(void *state, grpc_auth_context *ctx,+                                 const grpc_metadata *md, size_t md_count,+                                 grpc_process_auth_metadata_done_cb cb,+                                 void *user_data) {+  GPR_ASSERT(state == NULL);+  cb(user_data, NULL, 0, NULL, 0, GRPC_STATUS_UNAUTHENTICATED, NULL);+}++static void cronet_init_client_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args,+    cronet_engine *cronetEngine) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  f->client =+      grpc_cronet_secure_channel_create(cronetEngine, ffd->localaddr, client_args, NULL);+  GPR_ASSERT(f->client != NULL);+}++static void chttp2_init_server_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args,+    grpc_server_credentials *server_creds) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  if (f->server) {+    grpc_server_destroy(f->server);+  }+  f->server = grpc_server_create(server_args, NULL);+  grpc_server_register_completion_queue(f->server, f->cq, NULL);+  GPR_ASSERT(grpc_server_add_secure_http2_port(f->server, ffd->localaddr,+                                               server_creds));+  grpc_server_credentials_release(server_creds);+  grpc_server_start(f->server);+}++void chttp2_tear_down_secure_fullstack(grpc_end2end_test_fixture *f) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  gpr_free(ffd->localaddr);+  gpr_free(ffd);+}++static void cronet_init_client_simple_ssl_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args) {+  grpc_arg ssl_name_override = {GRPC_ARG_STRING,+                                GRPC_SSL_TARGET_NAME_OVERRIDE_ARG,+                                {""foo.test.google.fr""}};+  +  grpc_channel_args *new_client_args =+      grpc_channel_args_copy_and_add(client_args, &ssl_name_override, 1);+  [Cronet setHttp2Enabled:YES];+  [Cronet start];+  cronet_engine *cronetEngine = [Cronet getGlobalEngine];+  +  cronet_init_client_secure_fullstack(f, new_client_args, cronetEngine);+  grpc_channel_args_destroy(new_client_args);+}++static int fail_server_auth_check(grpc_channel_args *server_args) {+  size_t i;+  if (server_args == NULL) return 0;+  for (i = 0; i < server_args->num_args; i++) {+    if (strcmp(server_args->args[i].key, FAIL_AUTH_CHECK_SERVER_ARG_NAME) ==+        0) {+      return 1;+    }+  }+  return 0;+}++static void chttp2_init_server_simple_ssl_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args) {+  grpc_ssl_pem_key_cert_pair pem_cert_key_pair = {test_server1_key,+                                                  test_server1_cert};+  grpc_server_credentials *ssl_creds =+      grpc_ssl_server_credentials_create(NULL, &pem_cert_key_pair, 1, 0, NULL);+  if (fail_server_auth_check(server_args)) {+    grpc_auth_metadata_processor processor = {process_auth_failure, NULL, NULL};+    grpc_server_credentials_set_auth_metadata_processor(ssl_creds, processor);+  }+  chttp2_init_server_secure_fullstack(f, server_args, ssl_creds);+}++/* All test configurations */++static grpc_end2end_test_config configs[] = {+    {""chttp2/simple_ssl_fullstack"",+     FEATURE_MASK_SUPPORTS_DELAYED_CONNECTION |+         FEATURE_MASK_SUPPORTS_PER_CALL_CREDENTIALS,+     chttp2_create_fixture_secure_fullstack,+     cronet_init_client_simple_ssl_secure_fullstack,+     chttp2_init_server_simple_ssl_secure_fullstack,+     chttp2_tear_down_secure_fullstack},+};++int main(int argc, char **argv) {","We try hard to keep these fixtures simple, meaning efforts to factor outcommon parts are frowned upon: one should never need to debug the fixturesto figure out which core API calls it ends up making.On Sun, Jul 17, 2016, 4:16 PM Muxi Yan notifications@github.com wrote:> In src/objective-c/tests/CoreCronetEnd2EndTests/h2_ssl.m> https://github.com/grpc/grpc/pull/7368#discussion_r71091897:> > > -  chttp2_init_server_secure_fullstack(f, server_args, ssl_creds);> >   +}> >   +> >   +/\* All test configurations */> >   +> >   +static grpc_end2end_test_config configs[] = {> > -    {""chttp2/simple_ssl_fullstack"",> > -     FEATURE_MASK_SUPPORTS_DELAYED_CONNECTION |> > -         FEATURE_MASK_SUPPORTS_PER_CALL_CREDENTIALS,> > -     chttp2_create_fixture_secure_fullstack,> > -     cronet_init_client_simple_ssl_secure_fullstack,> > -     chttp2_init_server_simple_ssl_secure_fullstack,> > -     chttp2_tear_down_secure_fullstack},> >   +};> >   +> >   +int main(int argc, char **argv) {> > In my understanding we duplicated it because it does not worth spending> time worrying about duplication and refactoring codes for duplication in> different test fixtures... correct me if I am wrong :) By replacing I mean> in the future we might want to use another fixture (not h2_ssl) for the> testing in XCode. Leaving main() inside the fixture would make the> replacement (a little bit) easier.> > —> You are receiving this because you are subscribed to this thread.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7368/files/e04089e7c043e34e79bd077ca9a8c0b98d6c9ec7#r71091897,> or mute the thread> https://github.com/notifications/unsubscribe-auth/AJpuddwbiYrStDSuN_GO48KmZtd1CDk9ks5qWrfXgaJpZM4JLvdh> .",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7424,71116037,2016-07-18T08:55:51Z,tools/distrib/python/grpcio_tools/setup.py,"@@ -76,6 +77,10 @@   if mac_target and (pkg_resources.parse_version(mac_target) < 		     pkg_resources.parse_version('10.9.0')):     os.environ['MACOSX_DEPLOYMENT_TARGET'] = '10.9'+    os.environ['_PYTHON_HOST_PLATFORM'] = re.sub(+        r'macosx-[0-9]+\.[0-9]+-(.+)',+        r'macosx-10.9-\1',+        util.get_platform())","Yes they should be, and yes I kind of turned my brain off on this one after checking the output of just `grpcio`. After #7416 is in we can spin off a distrib build and verify all the things.",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7432,71192558,2016-07-18T17:37:34Z,src/python/grpcio_tests/commands.py,"@@ -41,6 +40,7 @@ import traceback  import setuptools+from distutils import errors"," `distutils` is a standard Python library, so this import should be right back up before `glob`. Let's try not to run away from the style guide too much when it's easy not to.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7419,71199890,2016-07-18T18:18:19Z,examples/python/route_guide/run_codegen.py,"@@ -28,5 +27,16 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -# Runs the protoc with gRPC plugin to generate protocol messages and gRPC stubs.-python -m grpc.tools.protoc -I../../protos --python_out=. --grpc_python_out=. ../../protos/route_guide.proto","I didn't realize this was part of a larger demo change.  To me, the new quick-start feels like it got more complicated, especially the explicit use of Python2.7, which would imply that grpcio or grpcio-tools doesn't work with Python3, which shouldn't be the case.I'll defer my opinion, but I still see a reference to `python -m grpc.tools.protoc -I../../protos --python_out=. --grpc_python_out=. ../../protos/route_guide.proto`in the aforementioned PR which is no longer accurate after this change.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7447,71202414,2016-07-18T18:32:21Z,test/cpp/interop/server_helper_auth.cc,"@@ -0,0 +1,63 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""test/cpp/interop/server_helper.h""++#include <memory>++#include <gflags/gflags.h>+#include <grpc++/security/server_credentials.h>++#include ""src/core/lib/surface/call_test_only.h""+#include ""test/core/end2end/data/ssl_test_data.h""++DECLARE_bool(use_tls);++namespace grpc {+namespace testing {++std::shared_ptr<ServerCredentials> CreateInteropServerCredentials() {+  if (FLAGS_use_tls) {+    SslServerCredentialsOptions::PemKeyCertPair pkcp = {test_server1_key,+                                                        test_server1_cert};","This would normally get my spidey-sense tingling (brace-lists) but this case was certainly safe, so it's all good.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/7447,71202556,2016-07-18T18:33:11Z,test/cpp/interop/server_helper_auth.cc,"@@ -0,0 +1,63 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""test/cpp/interop/server_helper.h""++#include <memory>++#include <gflags/gflags.h>+#include <grpc++/security/server_credentials.h>++#include ""src/core/lib/surface/call_test_only.h""+#include ""test/core/end2end/data/ssl_test_data.h""++DECLARE_bool(use_tls);++namespace grpc {+namespace testing {++std::shared_ptr<ServerCredentials> CreateInteropServerCredentials() {+  if (FLAGS_use_tls) {+    SslServerCredentialsOptions::PemKeyCertPair pkcp = {test_server1_key,+                                                        test_server1_cert};","Note that I didn't write this. I only moved code from one file to another.On Mon, Jul 18, 2016 at 11:32 AM, Vijay Pai notifications@github.comwrote:> In test/cpp/interop/server_helper_auth.cc> https://github.com/grpc/grpc/pull/7447#discussion_r71202414:> > > +> > +#include <gflags/gflags.h>> > +#include <grpc++/security/server_credentials.h>> > +> > +#include ""src/core/lib/surface/call_test_only.h""> > +#include ""test/core/end2end/data/ssl_test_data.h""> > +> > +DECLARE_bool(use_tls);> > +> > +namespace grpc {> > +namespace testing {> > +> > +std::shared_ptr<ServerCredentials> CreateInteropServerCredentials() {> > -  if (FLAGS_use_tls) {> > -    SslServerCredentialsOptions::PemKeyCertPair pkcp = {test_server1_key,> > -                                                        test_server1_cert};> > This would normally get my spidey-sense tingling (brace-lists) but this> case was certainly safe, so it's all good.> > —> You are receiving this because you authored the thread.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7447/files/6b00175833540ad8af4c13627c9690145a9f158b#r71202414,> or mute the thread> https://github.com/notifications/unsubscribe-auth/AG8bptvie7YnjNmN7AR49B2O4lFguKb-ks5qW8bCgaJpZM4JO_6g> .",
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/7368,71206561,2016-07-18T18:55:14Z,src/objective-c/tests/CoreCronetEnd2EndTests/h2_ssl.m,"@@ -0,0 +1,203 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>+#import <Cronet/Cronet.h>++typedef struct fullstack_secure_fixture_data {+  char *localaddr;+} fullstack_secure_fixture_data;++static grpc_end2end_test_fixture chttp2_create_fixture_secure_fullstack(+    grpc_channel_args *client_args, grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  int port = grpc_pick_unused_port_or_die();+  fullstack_secure_fixture_data *ffd =+      gpr_malloc(sizeof(fullstack_secure_fixture_data));+  memset(&f, 0, sizeof(f));++  gpr_join_host_port(&ffd->localaddr, ""localhost"", port);++  f.fixture_data = ffd;+  f.cq = grpc_completion_queue_create(NULL);++  return f;+}++static void process_auth_failure(void *state, grpc_auth_context *ctx,+                                 const grpc_metadata *md, size_t md_count,+                                 grpc_process_auth_metadata_done_cb cb,+                                 void *user_data) {+  GPR_ASSERT(state == NULL);+  cb(user_data, NULL, 0, NULL, 0, GRPC_STATUS_UNAUTHENTICATED, NULL);+}++static void cronet_init_client_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *client_args,+    cronet_engine *cronetEngine) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  f->client =+      grpc_cronet_secure_channel_create(cronetEngine, ffd->localaddr, client_args, NULL);+  GPR_ASSERT(f->client != NULL);+}++static void chttp2_init_server_secure_fullstack(+    grpc_end2end_test_fixture *f, grpc_channel_args *server_args,+    grpc_server_credentials *server_creds) {+  fullstack_secure_fixture_data *ffd = f->fixture_data;+  if (f->server) {+    grpc_server_destroy(f->server);+  }+  f->server = grpc_server_create(server_args, NULL);+  grpc_server_register_completion_queue(f->server, f->cq, NULL);+  GPR_ASSERT(grpc_server_add_secure_http2_port(f->server, ffd->localaddr,+                                               server_creds));+  grpc_server_credentials_release(server_creds);+  grpc_server_start(f->server);+}++void chttp2_tear_down_secure_fullstack(grpc_end2end_test_fixture *f) {",My bad :),
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7419,71207324,2016-07-18T18:59:13Z,examples/python/route_guide/run_codegen.py,"@@ -28,5 +27,16 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -# Runs the protoc with gRPC plugin to generate protocol messages and gRPC stubs.-python -m grpc.tools.protoc -I../../protos --python_out=. --grpc_python_out=. ../../protos/route_guide.proto",There shouldn't be anything _incorrect_ about `python -m grpc.tools.protoc -I../../protos --python_out=. --grpc_python_out=. ../../protos/route_guide.proto`; right? Just that it's no longer the content of the script that the reader runs to generate their code? [I've left a comment in the doc change](https://github.com/grpc/grpc.github.io/pull/223/files#r71206320).,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7433,71212052,2016-07-18T19:25:41Z,src/compiler/python_generator.h,"@@ -48,22 +58,72 @@ struct GeneratorConfiguration {   grpc::string beta_package_root; }; -class PythonGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {- public:-  PythonGrpcGenerator(const GeneratorConfiguration& config);-  ~PythonGrpcGenerator();+// An abstract interface representing a method.+struct Method {+  virtual ~Method() {}++  virtual grpc::string name() const = 0;++  virtual grpc::string input_type_name() const = 0;+  virtual grpc::string output_type_name() const = 0;+  virtual bool get_module_message_path_input(grpc::string* out) const = 0;+  virtual bool get_module_message_path_output(grpc::string* out) const = 0;++  virtual bool ClientStreaming() const = 0;+  virtual bool ServerStreaming() const = 0; +};++// An abstract interface representing a service+struct Service {+  virtual ~Service() {}++  virtual grpc::string name() const = 0;++  virtual int method_count() const = 0;+  virtual std::unique_ptr<const Method> method(int i) const = 0;","Unless you want to chuck some portable `unique_ptr`-like implementation (I say 'like' because I don't think we care about thread safety in this context) into the common headers (which is fine by me - dunno about everyone else), I'd say either return raw pointers with a documented contract on the caller to free (if you stick with doing views/proxies) or go with templates/policies.Given that gRPC C++ does things similar to what's in this PR: maybe unifying the approach across languages in a C++98-compliant way would be nice? Move the service/method wrappers out of the C++ generator and into some common header, add in some portable smart pointers, call it a day. @ctiller thoughts?EDIT: pared down excess stream-of-consciousness verbiage to get to the point quicker",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,71214140,2016-07-18T19:37:48Z,src/objective-c/tests/CoreCronetEnd2EndTests/CoreCronetEnd2EndTests.m,"@@ -0,0 +1,48 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#import <XCTest/XCTest.h>+#include ""./h2_ssl_cronet.h""++@interface CoreCronetEnd2EndTests : XCTestCase++@end++@implementation CoreCronetEnd2EndTests++- (void)testCoreCronetEnd2End {+  char *argv[] = {""h2_ssl""};+  main(1, argv);","I guess I can live with this as long as you add a comment explaining that this is _not_ the app's `main` function, rather one declared by the C test fixture; and that for some reason the compiler seems to be happy with it.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,71214951,2016-07-18T19:43:02Z,src/objective-c/tests/CoreCronetEnd2EndTests/h2_ssl_cronet.m,"@@ -0,0 +1,203 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* + * This fixture creates a server full stack using chttp2 and a client+ * full stack using Cronet. End-to-end tests are run against this fixture+ * setting.","Explain that it's an adaptation of the `h2_ssl.c` file of the C library, for people wondering what's up with the C89?",
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7374,71217617,2016-07-18T19:58:29Z,tools/run_tests/build_artifact_python.sh,"@@ -39,15 +39,6 @@ export PIP=${PIP:-pip} export AUDITWHEEL=${AUDITWHEEL:-auditwheel}  -if [ ""$SKIP_PIP_INSTALL"" == """" ]","Why was this removed? When I said 'optimization' earlier, I meant that it was an optimization to skip this step, not an optimization to install.Unless we no longer break when we don't have these lines? I guess we'll see in the watched build.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6924,71240806,2016-07-18T22:14:13Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle+ * state, \a query_for_backends() is called. It creates an instance of \a+ * lb_client_data, an internal struct meant to contain the data associated with+ * the internal communication with the LB server. This instance is created via+ * \a lb_client_data_create(). There, the call over lb_channel to pick-first+ * from {a1..an} is created, the \a LoadBalancingRequest message is assembled+ * and all necessary callbacks for the progress of the internal call configured.+ *+ * Back in \a query_for_backends(), the internal *streaming* call to the LB+ * server (whichever address from {a1..an} pick-first chose) is kicked off.+ * It'll progress over the callbacks configured in \a lb_client_data_create()+ * (see the field docstrings of \a lb_client_data for more details).+ *+ * If the call fails with UNIMPLEMENTED, the original call will also fail.+ * There's a misconfiguration somewhere: at least one of {a1..an} isn't a LB+ * server, which contradicts the LB bit being set. If the internal call times+ * out, the usual behavior of pick-first applies, continuing to pick from the+ * list {a1..an}.+ *+ * Upon sucesss, a \a LoadBalancingResponse is expected in \a res_rcvd_cb. An+ * invalid one results in the termination of the streaming call. A new streaming+ * call should be created if possible, failing the original call otherwise.+ * For a valid \a LoadBalancingResponse, the server list of actual backends is+ * extracted. A Round Robin policy will be created from this list. There are two+ * possible scenarios:+ *+ * 1. This is the first server list received. There was no previous instance of+ *    the Round Robin policy. \a rr_handover() will instantiate the RR policy+ *    and perform all the pending operations over it.+ * 2. There's already a RR policy instance active. We need to introduce the new+ *    one build from the new serverlist, but taking care not to disrupt the+ *    operations in progress over the old RR instance. This is done by+ *    decreasing the reference count on the old policy. The moment no more+ *    references are held on the old RR policy, it'll be destroyed and \a+ *    rr_connectivity_changed notified with a \a GRPC_CHANNEL_SHUTDOWN state.+ *    At this point we can transition to a new RR instance safely, which is done+ *    once again via \a rr_handover().+ *+ *+ * Once a RR policy instance is in place (and getting updated as described),+ * calls to for a pick, a ping or a cancellation will be serviced right away by+ * forwarding them to the RR instance. Any time there's no RR policy available+ * (ie, right after the creation of the gRRPCLB policy, if an empty serverlist+ * is received, etc), pick/ping requests are added to a list of pending+ * picks/pings to be flushed and serviced as part of \a rr_handover() the moment+ * the RR policy instance becomes available.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md for the+ * high level design and details. */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).+ */++#include <string.h>++#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/client_channel_factory.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/parse_address.h""+#include ""src/core/ext/lb_policy/grpclb/grpclb.h""+#include ""src/core/ext/lb_policy/grpclb/load_balancer_api.h""+#include ""src/core/lib/iomgr/sockaddr_utils.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/call.h""+#include ""src/core/lib/surface/channel.h""++int grpc_lb_glb_trace = 0;++typedef struct wrapped_rr_closure_arg {+  /* the original closure. Usually a on_complete/notify cb for pick() and ping()+   * calls against the internal RR instance, respectively. */+  grpc_closure *wrapped_closure;++  /* The RR instance related to the closure */+  grpc_lb_policy *rr_policy;++  /* when not NULL, represents a pending_{pick,ping} node to be freed upon+   * closure execution */+  void *owning_pending_node; /* to be freed if not NULL */+} wrapped_rr_closure_arg;++/* The \a on_complete closure passed as part of the pick requires keeping a+ * reference to its associated round robin instance. We wrap this closure in+ * order to unref the round robin instance upon its invocation */+static void wrapped_rr_closure(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  wrapped_rr_closure_arg *wc_arg = arg;+  if (wc_arg->rr_policy != NULL) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Unreffing RR (0x%"" PRIxPTR "")"",+              (intptr_t)wc_arg->rr_policy);+    }+    GRPC_LB_POLICY_UNREF(exec_ctx, wc_arg->rr_policy, ""wrapped_rr_closure"");+  }+  GPR_ASSERT(wc_arg->wrapped_closure != NULL);+  grpc_exec_ctx_sched(exec_ctx, wc_arg->wrapped_closure, error, NULL);+  gpr_free(wc_arg->owning_pending_node);+}++/* Linked list of pending pick requests. It stores all information needed to+ * eventually call (Round Robin's) pick() on them. They mainly stay pending+ * waiting for the RR policy to be created/updated.+ *+ * One particularity is the wrapping of the user-provided \a on_complete closure+ * (in \a wrapped_on_complete and \a wrapped_on_complete_arg). This is needed in+ * order to correctly unref the RR policy instance upon completion of the pick.+ * See \a wrapped_rr_closure for details. */+typedef struct pending_pick {+  struct pending_pick *next;++  /* polling entity for the pick()'s async notification */+  grpc_polling_entity *pollent;++  /* the initial metadata for the pick. See grpc_lb_policy_pick() */+  grpc_metadata_batch *initial_metadata;++  /* bitmask passed to pick() and used for selective cancelling. See+   * grpc_lb_policy_cancel_picks() */+  uint32_t initial_metadata_flags;++  /* output argument where to store the pick()ed connected subchannel, or NULL+   * upon error. */+  grpc_connected_subchannel **target;++  /* a closure wrapping the original on_complete one to be invoked once the+   * pick() has completed (regardless of success) */+  grpc_closure wrapped_on_complete;++  /* args for wrapped_on_complete */+  wrapped_rr_closure_arg wrapped_on_complete_arg;+} pending_pick;++/* Same as the \a pending_pick struct but for ping operations */+typedef struct pending_ping {+  struct pending_ping *next;++  /* a closure wrapping the original on_complete one to be invoked once the+   * ping() has completed (regardless of success) */+  grpc_closure wrapped_notify;++  /* args for wrapped_notify */+  wrapped_rr_closure_arg wrapped_notify_arg;+} pending_ping;++typedef struct glb_lb_policy glb_lb_policy;++/* Used internally for the client call to the LB */+typedef struct lb_client_data {+  gpr_mu mu;++  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once initial metadata's been received */+  grpc_closure md_rcvd;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;++  /* After the client has sent a close to the LB server */+  grpc_closure close_sent;++  /* ... and the status from the LB server has been received */+  grpc_closure srv_status_rcvd;++  grpc_call *lb_call;    /* streaming call to the LB server, */+  gpr_timespec deadline; /* for the streaming call to the LB server */++  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */+  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */++  /* what's being sent to the LB server. Note that its value may vary if the LB+   * server indicates a redirect. */+  grpc_byte_buffer *request_payload;++  /* response from the LB server, if any. Processed in res_rcvd_cb() */+  grpc_byte_buffer *response_payload;++  /* the call's status and status detailset in srv_status_rcvd_cb() */+  grpc_status_code status;+  char *status_details;+  size_t status_details_capacity;++  /* pointer back to the enclosing policy */+  glb_lb_policy *p;+} lb_client_data;++/* Keeps track and reacts to changes in connectivity of the RR instance */+typedef struct rr_connectivity_data {+  grpc_closure on_change;+  grpc_connectivity_state state;+  glb_lb_policy *p;+} rr_connectivity_data;++struct glb_lb_policy {+  /** base policy: must be first */+  grpc_lb_policy base;++  /** mutex protecting remaining members */+  gpr_mu mu;++  grpc_client_channel_factory *cc_factory;++  /** for communicating with the LB server */+  grpc_channel *lb_channel;++  /** the RR policy to use of the backend servers returned by the LB server */+  grpc_lb_policy *rr_policy;++  bool started_picking;++  /** our connectivity state tracker */+  grpc_connectivity_state_tracker state_tracker;++  /** stores the deserialized response from the LB. May be NULL until one such+   * response has arrived. */+  grpc_grpclb_serverlist *serverlist;++  /** list of picks that are waiting on RR's policy connectivity */+  pending_pick *pending_picks;++  /** list of pings that are waiting on RR's policy connectivity */+  pending_ping *pending_pings;++  /** client data associated with the LB server communication */+  lb_client_data *lbcd;++  /** for tracking of the RR connectivity */+  rr_connectivity_data *rr_connectivity;++  /* a wrapped (see ...) on-complete closure for readily available RR picks */+  grpc_closure wrapped_on_complete;++  /* arguments for the wrapped_on_complete closure */+  wrapped_rr_closure_arg wc_arg;+};++static void rr_handover(grpc_exec_ctx *exec_ctx, glb_lb_policy *p,+                        grpc_error *error);+static void rr_connectivity_changed(grpc_exec_ctx *exec_ctx, void *arg,+                                    grpc_error *error) {+  rr_connectivity_data *rrcd = arg;+  glb_lb_policy *p = rrcd->p;+  if (rrcd->state == GRPC_CHANNEL_SHUTDOWN) {+    if (p->serverlist != NULL) {+      /* a RR policy is shutting down but there's a serverlist available ->+       * perform a handover */+      rr_handover(exec_ctx, p, error);+    } else {+      /* shutting down and no new serverlist available. Bail out. */+      gpr_free(rrcd);+    }+  } else {+    if (error == GRPC_ERROR_NONE) {+      /* RR not shutting down. Mimic the RR's policy state */+      grpc_connectivity_state_set(exec_ctx, &p->state_tracker, rrcd->state,+                                  error, ""rr_connectivity_changed"");+      /* resubscribe */+      grpc_lb_policy_notify_on_state_change(exec_ctx, p->rr_policy,+                                            &rrcd->state, &rrcd->on_change);+    } else { /* error */+      gpr_free(rrcd);+    }+  }+  GRPC_ERROR_UNREF(error);+}++static void add_pending_pick(pending_pick **root, grpc_polling_entity *pollent,+                             grpc_metadata_batch *initial_metadata,+                             uint32_t initial_metadata_flags,+                             grpc_connected_subchannel **target,+                             grpc_closure *on_complete) {+  pending_pick *pp = gpr_malloc(sizeof(*pp));+  memset(pp, 0, sizeof(pending_pick));+  memset(&pp->wrapped_on_complete_arg, 0, sizeof(wrapped_rr_closure_arg));+  pp->next = *root;+  pp->pollent = pollent;+  pp->target = target;+  pp->initial_metadata = initial_metadata;+  pp->initial_metadata_flags = initial_metadata_flags;+  pp->wrapped_on_complete_arg.wrapped_closure = on_complete;+  grpc_closure_init(&pp->wrapped_on_complete, wrapped_rr_closure,+                    &pp->wrapped_on_complete_arg);+  *root = pp;+}++static void add_pending_ping(pending_ping **root, grpc_closure *notify) {+  pending_ping *pping = gpr_malloc(sizeof(*pping));+  memset(pping, 0, sizeof(pending_ping));+  memset(&pping->wrapped_notify_arg, 0, sizeof(wrapped_rr_closure_arg));+  pping->next = *root;+  grpc_closure_init(&pping->wrapped_notify, wrapped_rr_closure,+                    &pping->wrapped_notify_arg);+  pping->wrapped_notify_arg.wrapped_closure = notify;+  *root = pping;+}++static void lb_client_data_destroy(lb_client_data *lbcd);++static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  GPR_ASSERT(lbcd->lb_call);+  grpc_call_error call_error;+  grpc_op ops[1];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &lbcd->initial_metadata_recv;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  call_error = grpc_call_start_batch_and_execute(+      exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->md_rcvd);+  GPR_ASSERT(GRPC_CALL_OK == call_error);+}++static void md_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  GPR_ASSERT(lbcd->lb_call);+  grpc_call_error call_error;+  grpc_op ops[1];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;++  op->op = GRPC_OP_SEND_MESSAGE;+  op->data.send_message = lbcd->request_payload;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  call_error = grpc_call_start_batch_and_execute(+      exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->req_sent);+  GPR_ASSERT(GRPC_CALL_OK == call_error);+}++static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  grpc_call_error call_error;++  grpc_op ops[1];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;++  op->op = GRPC_OP_RECV_MESSAGE;+  op->data.recv_message = &lbcd->response_payload;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  call_error = grpc_call_start_batch_and_execute(+      exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->res_rcvd);+  GPR_ASSERT(GRPC_CALL_OK == call_error);+}++static void res_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  grpc_op ops[2];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;+  if (lbcd->response_payload != NULL) {+    /* Received data from the LB server. Look inside lbcd->response_payload, for+     * a serverlist. */+    grpc_byte_buffer_reader bbr;+    grpc_byte_buffer_reader_init(&bbr, lbcd->response_payload);+    gpr_slice response_slice = grpc_byte_buffer_reader_readall(&bbr);+    grpc_byte_buffer_destroy(lbcd->response_payload);+    grpc_grpclb_serverlist *serverlist =+        grpc_grpclb_response_parse_serverlist(response_slice);+    if (serverlist != NULL) {+      gpr_slice_unref(response_slice);+      if (grpc_lb_glb_trace) {+        gpr_log(GPR_INFO, ""Serverlist with %zu servers received"",+                serverlist->num_servers);+      }++      /* update serverlist */+      if (serverlist->num_servers > 0) {+        if (grpc_grpclb_serverlist_equals(lbcd->p->serverlist, serverlist)) {+          if (grpc_lb_glb_trace) {+            gpr_log(GPR_INFO,+                    ""Incoming server list identical to current, ignoring."");+          }+        } else { /* new serverlist */+          if (lbcd->p->serverlist != NULL) {+            /* dispose of the old serverlist */+            grpc_grpclb_destroy_serverlist(lbcd->p->serverlist);+          }+          /* and update the copy in the glb_lb_policy instance */+          lbcd->p->serverlist = serverlist;+        }+        if (lbcd->p->rr_policy == NULL) {+          /* initial ""handover"", in this case from a null RR policy, meaning+           * it'll just create the first RR policy instance */+          rr_handover(exec_ctx, lbcd->p, error);+        } else {+          /* unref the RR policy, eventually leading to its substitution with a+           * new one constructed from the received serverlist (see+           * rr_connectivity_changed) */+          GRPC_LB_POLICY_UNREF(exec_ctx, lbcd->p->rr_policy,+                               ""serverlist_received"");+        }+      } else {+        if (grpc_lb_glb_trace) {+          gpr_log(GPR_INFO,+                  ""Received empty server list. Picks will stay pending until a ""+                  ""response with > 0 servers is received"");+        }+      }++      /* keep listening for serverlist updates */+      op->op = GRPC_OP_RECV_MESSAGE;+      op->data.recv_message = &lbcd->response_payload;+      op->flags = 0;+      op->reserved = NULL;+      op++;+      const grpc_call_error call_error = grpc_call_start_batch_and_execute(+          exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops),+          &lbcd->res_rcvd); /* loop */+      GPR_ASSERT(GRPC_CALL_OK == call_error);+      return;+    }++    GPR_ASSERT(serverlist == NULL);+    gpr_log(GPR_ERROR, ""Invalid LB response received: '%s'"",+            gpr_dump_slice(response_slice, GPR_DUMP_ASCII));+    gpr_slice_unref(response_slice);++    /* Disconnect from server returning invalid response. */+    op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+    op->flags = 0;+    op->reserved = NULL;+    op++;+    grpc_call_error call_error = grpc_call_start_batch_and_execute(+        exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->close_sent);+    GPR_ASSERT(GRPC_CALL_OK == call_error);+  }+  /* empty payload: call cancelled by server. Cleanups happening in+   * srv_status_rcvd_cb */+}++static void close_sent_cb(grpc_exec_ctx *exec_ctx, void *arg,+                          grpc_error *error) {+  if (grpc_lb_glb_trace) {+    gpr_log(GPR_INFO,+            ""Close from LB client sent. Waiting from server status now"");+  }+}++static void query_for_backends(grpc_exec_ctx *exec_ctx, glb_lb_policy *p);+static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  lb_client_data *lbcd = arg;+  glb_lb_policy *p = lbcd->p;+  if (grpc_lb_glb_trace) {+    gpr_log(GPR_INFO,+            ""status from lb server received. Status = %d, Details = '%s', ""+            ""Capaticy ""+            ""= %zu"",+            lbcd->status, lbcd->status_details, lbcd->status_details_capacity);+  }++  grpc_call_destroy(lbcd->lb_call);+  lb_client_data_destroy(lbcd);+  p->lbcd = NULL;+  /* TODO(dgq): deal with stream termination properly (fire up another one? fail+   * the original call?) */+}++static lb_client_data *lb_client_data_create(glb_lb_policy *p) {+  lb_client_data *lbcd = gpr_malloc(sizeof(lb_client_data));+  memset(lbcd, 0, sizeof(lb_client_data));++  gpr_mu_init(&lbcd->mu);+  grpc_closure_init(&lbcd->md_sent, md_sent_cb, lbcd);++  grpc_closure_init(&lbcd->md_rcvd, md_recv_cb, lbcd);+  grpc_closure_init(&lbcd->req_sent, req_sent_cb, lbcd);+  grpc_closure_init(&lbcd->res_rcvd, res_rcvd_cb, lbcd);+  grpc_closure_init(&lbcd->close_sent, close_sent_cb, lbcd);+  grpc_closure_init(&lbcd->srv_status_rcvd, srv_status_rcvd_cb, lbcd);++  /* TODO(dgq): get the deadline from the client config instead of fabricating+   * one here. */","On the other hand, we probably want an infinite deadline here...",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7368,71414700,2016-07-19T20:16:14Z,src/objective-c/tests/CoreCronetEnd2EndTests/CoreCronetEnd2EndTests.m,"@@ -32,26 +32,349 @@  */  #import <XCTest/XCTest.h>-#import ""src/objective-c/tests/CoreCronetEnd2EndTests/fixture.h""+#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>++#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/security/credentials/credentials.h""+#include ""src/core/lib/support/env.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""test/core/end2end/data/ssl_test_data.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""++#include <grpc/grpc_cronet.h>+#import <Cronet/Cronet.h>+","Add a comment here explaining that a lot of this code follows the style of the gRPC C library, instead of Objective-C style, because it's brought from the ???.c C fixture.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7386,71440741,2016-07-19T23:10:28Z,include/grpc_c/status_code.h,"@@ -0,0 +1,160 @@+/*",Please don't duplicate this when a typedef is sufficient.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7386,71442244,2016-07-19T23:24:36Z,src/c/bidi_streaming_blocking_call.c,"@@ -0,0 +1,160 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+++#include <grpc_c/grpc_c.h>+#include <grpc/support/log.h>+#include ""bidi_streaming_blocking_call.h""+#include <grpc_c/completion_queue.h>+#include ""alloc.h""+#include ""tag.h""+#include ""completion_queue.h""++GRPC_client_reader_writer *GRPC_bidi_streaming_blocking_call(GRPC_channel *channel,+                                                        const GRPC_method rpc_method,+                                                        GRPC_client_context *const context) {+  grpc_completion_queue *cq = GRPC_completion_queue_create();+  grpc_call *call = grpc_channel_create_call(channel,+                                             NULL,+                                             GRPC_PROPAGATE_DEFAULTS,+                                             cq,+                                             rpc_method.name,+                                             """",+                                             context->deadline,+                                             NULL);+  context->call = call;+  context->rpc_method = rpc_method;++  grpc_call_op_set set = {+    {+      grpc_op_send_metadata+    },+    .context = context,+    .user_tag = &set+  };++  grpc_client_reader_writer *reader_writer = GRPC_ALLOC_STRUCT(grpc_client_reader_writer, {",Please verify this initialization pattern works on all compilers in our portability suite.,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/7269,71558462,2016-07-20T16:25:40Z,test/cpp/util/grpc_cli.cc,"@@ -86,6 +90,7 @@ DEFINE_string(output_binary_file, """", DEFINE_string(metadata, """",               ""Metadata to send to server, in the form of key1:val1:key2:val2""); DEFINE_string(proto_path, ""."", ""Path to look for the proto file."");+DEFINE_string(proto_file, """", ""Name of the proto file."");",Let's call it protofiles. I think we need to support a list rather than just a file (which can be done in a later pr).,
2877531,tengyifei,https://api.github.com/repos/grpc/grpc/pulls/7386,71566819,2016-07-20T17:13:21Z,include/grpc_c/grpc_c.h,"@@ -0,0 +1,76 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+++#ifndef GRPC_C_PUBLIC_H+#define GRPC_C_PUBLIC_H++#include <stdlib.h>+#include <grpc_c/message.h>++typedef struct grpc_channel GRPC_channel;+typedef struct grpc_status GRPC_status;+typedef struct grpc_client_context GRPC_client_context;+typedef struct grpc_completion_queue GRPC_completion_queue;++typedef struct grpc_client_reader_writer GRPC_client_reader_writer;+typedef struct grpc_client_reader GRPC_client_reader;+typedef struct grpc_client_writer GRPC_client_writer;+typedef struct grpc_client_async_reader_writer GRPC_client_async_reader_writer;+typedef struct grpc_client_async_reader GRPC_client_async_reader;+typedef struct grpc_client_async_writer GRPC_client_async_writer;+typedef struct grpc_client_async_response_reader GRPC_client_async_response_reader;++typedef struct GRPC_method {+  enum RpcType {+    NORMAL_RPC = 0,+    CLIENT_STREAMING,  /* request streaming */+    SERVER_STREAMING,  /* response streaming */+    BIDI_STREAMING+  } type;+  const char* name;+} GRPC_method;++/* For C compilers without bool support */+#ifndef __cplusplus",Yeah agree with you. The only issue being there's a specific test that enforces C89 for all public C headers. We could certainly add a whitelist of exempted headers/targets but that will bloat the project generator with cross-cutting concerns. What's your take?,
2877531,tengyifei,https://api.github.com/repos/grpc/grpc/pulls/7386,71570846,2016-07-20T17:36:09Z,src/c/server_streaming_blocking_call.c,"@@ -0,0 +1,126 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+++#include <grpc_c/grpc_c.h>+#include <grpc/grpc.h>+#include <grpc/support/log.h>+#include ""server_streaming_blocking_call.h""+#include <grpc_c/completion_queue.h>+#include ""alloc.h""+#include ""completion_queue.h""+#include ""tag.h""++GRPC_client_reader *GRPC_server_streaming_blocking_call(GRPC_channel *channel,+                                                        const GRPC_method rpc_method,+                                                        GRPC_client_context *const context,+                                                        const GRPC_message request) {+  grpc_completion_queue *cq = GRPC_completion_queue_create();+  grpc_call *call = grpc_channel_create_call(channel,+                                             NULL,+                                             GRPC_PROPAGATE_DEFAULTS,+                                             cq,+                                             rpc_method.name,+                                             """",+                                             context->deadline,+                                             NULL);+  context->call = call;+  context->rpc_method = rpc_method;++  grpc_call_op_set set = {",DRY principle? Since different APIs would need a duplicate ops definition otherwise.Actually this was modelled from C++'s CallOpSet.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7497,71811290,2016-07-22T00:30:35Z,setup.py,"@@ -232,6 +206,14 @@ def cython_extensions():     'sphinx_rtd_theme>=0.1.8',     'six>=1.10', )+if BUILD_WITH_CYTHON:+  sys.stderr.write(+    ""You requested a Cython build via GRPC_PYTHON_BUILD_WITH_CYTHON, ""+    ""but do not have Cython installed. We won't stop you from using ""+    ""other commands, but the extension files will fail to build."")+elif NEED_CYTHON:+  sys.stderr.write('We could not find Cython. Setup could take a while...\n')",Minutes or hours? Let's try include something likely to be realistic in this message?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7497,71811520,2016-07-22T00:34:01Z,src/python/grpcio/commands.py,"@@ -184,6 +184,70 @@ def run(self):     build_py.build_py.run(self)  +def _poison_extensions(extensions, message):+  """"""Includes a file that will always fail to compile in all extensions.""""""+  poison_filename = os.path.join(PYTHON_STEM, 'poison.c')+  with open(poison_filename, 'w') as poison:+    poison.write('#error {}'.format(message))+  for extension in extensions:+    extension.sources = [poison_filename]++def check_and_update_cythonization(extensions):+  """"""Replace .pyx files with their generated counterparts and return whether or+     not cythonization still needs to occur.""""""+  built = True+  for extension in extensions:+    pyx_sources = [source for source in extension.sources if os.path.splitext(source)[1] == '.pyx']",`itertools.groupby` rather than two separate list comprehensions?,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7497,71886492,2016-07-22T14:23:48Z,src/python/grpcio/commands.py,"@@ -184,6 +184,70 @@ def run(self):     build_py.build_py.run(self)  +def _poison_extensions(extensions, message):+  """"""Includes a file that will always fail to compile in all extensions.""""""+  poison_filename = os.path.join(PYTHON_STEM, 'poison.c')+  with open(poison_filename, 'w') as poison:+    poison.write('#error {}'.format(message))+  for extension in extensions:+    extension.sources = [poison_filename]++def check_and_update_cythonization(extensions):+  """"""Replace .pyx files with their generated counterparts and return whether or+     not cythonization still needs to occur.""""""+  built = True+  for extension in extensions:+    pyx_sources = [source for source in extension.sources if os.path.splitext(source)[1] == '.pyx']","Changed it to not require list comprehensions, though I do think they were more readable and that performance concerns don't matter here (using `itertools.groupby` increased the line count by five or so and complicated matters with gunky key munging, so didn't go down that route).",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7497,71895879,2016-07-22T15:19:10Z,src/python/grpcio/commands.py,"@@ -184,6 +184,70 @@ def run(self):     build_py.build_py.run(self)  +def _poison_extensions(extensions, message):+  """"""Includes a file that will always fail to compile in all extensions.""""""+  poison_filename = os.path.join(PYTHON_STEM, 'poison.c')+  with open(poison_filename, 'w') as poison:+    poison.write('#error {}'.format(message))+  for extension in extensions:+    extension.sources = [poison_filename]++def check_and_update_cythonization(extensions):+  """"""Replace .pyx files with their generated counterparts and return whether or+     not cythonization still needs to occur.""""""+  built = True+  for extension in extensions:+    pyx_sources = [source for source in extension.sources if os.path.splitext(source)[1] == '.pyx']",Well that's why I ended the comment with a question mark. The way it's written in the current draft is fine or the list comprehensions would be okay.,
4889063,soltanmm,https://api.github.com/repos/grpc/grpc/pulls/7433,71979900,2016-07-24T00:07:47Z,src/compiler/python_generator.h,"@@ -35,8 +35,18 @@ #define GRPC_INTERNAL_COMPILER_PYTHON_GENERATOR_H  #include <utility>+#include <memory>+#include <vector> -#include ""src/compiler/config.h""+#ifndef GRPC_CUSTOM_STRING",Why is this being duplicated from `src/compiler/config.h`?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6915,72185874,2016-07-26T04:21:33Z,src/cpp/common/channel_filter.cc,"@@ -0,0 +1,120 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <string.h>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/cpp/common/channel_filter.h""++namespace grpc {++//","Not personally against this type of banner comments, but we don't use them across the codebase. If anything, I'd reduce them to a single line with no empty lines in between, viz:```// MetadataBatchgrpc_linked_mdelem moar codez ...```",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6915,72187458,2016-07-26T04:45:59Z,src/cpp/common/channel_filter.h,"@@ -0,0 +1,373 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc++/impl/codegen/config.h>+#include <grpc/census.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>++#include <functional>+#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/security/context/security_context.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""src/core/lib/transport/metadata_batch.h""++///+/// An interface to define filters.+///+/// To define a filter, implement a subclass of each of \c CallData and+/// \c ChannelData. Then register the filter using something like this:+/// \code{.cpp}+///   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+///       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);+/// \endcode+///++namespace grpc {++/// A C++ wrapper for the \c grpc_metadata_batch struct.+class MetadataBatch {+ public:+  explicit MetadataBatch(grpc_metadata_batch *batch) : batch_(batch) {}++  grpc_metadata_batch *batch() const { return batch_; }++  // Adds metadata and returns the newly allocated storage.+  // The caller takes ownership of the result, which must exist for the+  // lifetime of the gRPC call.+  grpc_linked_mdelem *AddMetadata(const string &key, const string &value);++  class const_iterator : public std::iterator<std::bidirectional_iterator_tag,+                                              const grpc_mdelem> {+   public:+    const grpc_mdelem &operator*() const { return *elem_->md; }+    const grpc_mdelem *operator->() const { return elem_->md; }++    const_iterator &operator++() {+      elem_ = elem_->next;+      return *this;+    }+    const_iterator operator++(int) {+      const_iterator tmp(*this);+      operator++();+      return tmp;+    }+    const_iterator &operator--() {+      elem_ = elem_->prev;+      return *this;+    }+    const_iterator operator--(int) {+      const_iterator tmp(*this);+      operator--();+      return tmp;+    }++    bool operator==(const const_iterator &other) const {+      return elem_ == other.elem_;+    }+    bool operator!=(const const_iterator &other) const {+      return elem_ != other.elem_;+    }++   private:+    friend class MetadataBatch;+    explicit const_iterator(grpc_linked_mdelem *elem) : elem_(elem) {}++    grpc_linked_mdelem *elem_;+  };++  const_iterator begin() const { return const_iterator(batch_->list.head); }+  const_iterator end() const { return const_iterator(nullptr); }++ private:+  grpc_metadata_batch *batch_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_op struct.+class TransportOp {+ public:+  explicit TransportOp(grpc_transport_op *op) : op_(op) {}++  grpc_transport_op *op() const { return op_; }++  // TODO(roth): Add a C++ wrapper for grpc_error?+  grpc_error *disconnect_with_error() const {+    return op_->disconnect_with_error;+  }+  bool send_goaway() const { return op_->send_goaway; }++  // TODO(roth): Add methods for additional fields as needed.++ private:+  grpc_transport_op *op_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_stream_op struct.+class TransportStreamOp {+ public:+  explicit TransportStreamOp(grpc_transport_stream_op *op)+      : op_(op),+        send_initial_metadata_(op->send_initial_metadata),+        send_trailing_metadata_(op->send_trailing_metadata),+        recv_initial_metadata_(op->recv_initial_metadata),+        recv_trailing_metadata_(op->recv_trailing_metadata) {}++  grpc_transport_stream_op *op() const { return op_; }++  grpc_closure *on_complete() const { return op_->on_complete; }+  void set_on_complete(grpc_closure *closure) { op_->on_complete = closure; }++  MetadataBatch *send_initial_metadata() {+    return op_->send_initial_metadata == nullptr ? nullptr+                                                 : &send_initial_metadata_;","why not simply return `op_->send_initial_metadata_`? In case `op_` goes away, given that it's not owned?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7523,72347369,2016-07-26T22:08:44Z,.gitmodules,"@@ -17,3 +17,6 @@ [submodule ""third_party/nanopb""] 	path = third_party/nanopb 	url = https://github.com/nanopb/nanopb.git+[submodule ""tools/thrift""]+	path = tools/thrift+	url = https://github.com/chedeti/thrift.git","Why is the module specified like this? If it's your thrift code generation system, then that belongs as actual contents of the repository in tools/thrift , not as a submodule.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7523,72348076,2016-07-26T22:13:36Z,build.yaml,"@@ -1184,6 +1184,13 @@ libs:   - grpc_test_util   - grpc++_test_util   - grpc+++- name: thrift_util+  build: all+  language: c+++  public_headers:+  - include/grpc++/impl/codegen/thrift_serializer.h+  - include/grpc++/impl/codegen/thrift_serializer_inl.h+  - include/grpc++/impl/codegen/thrift_utils.h","As you've already seen, this doesn't make sense as a headers-only library. I understand that your purpose is to get it included as part of the installation. You should follow the same steps used for proto_utils.h ; define the name, don't put a build: all on it, and make sure that it gets added to some other dependence chain.",
4488261,thinkerou,https://api.github.com/repos/grpc/grpc/pulls/7542,72372277,2016-07-27T02:33:22Z,src/php/ext/grpc/php7_wrapper.h,"@@ -56,6 +56,14 @@ #define PHP_GRPC_WRAP_OBJECT_END(name) \   } name; +#define PHP_GRPC_FREE_WRAPPED_FUNC_START(klass) \+  void free_##klass(void *object TSRMLS_DC) { \+    klass *p = (klass *)object;","Because the name of function end with class name, like `free_wrapped_grpc_timeval`, etc, so I use `klass`.",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/7542,72372434,2016-07-27T02:36:25Z,src/php/ext/grpc/php7_wrapper.h,"@@ -56,6 +56,14 @@ #define PHP_GRPC_WRAP_OBJECT_END(name) \   } name; +#define PHP_GRPC_FREE_WRAPPED_FUNC_START(klass) \+  void free_##klass(void *object TSRMLS_DC) { \+    klass *p = (klass *)object;",then why not `class`?,
4488261,thinkerou,https://api.github.com/repos/grpc/grpc/pulls/7542,72373637,2016-07-27T02:55:59Z,src/php/ext/grpc/php7_wrapper.h,"@@ -56,6 +56,14 @@ #define PHP_GRPC_WRAP_OBJECT_END(name) \   } name; +#define PHP_GRPC_FREE_WRAPPED_FUNC_START(klass) \+  void free_##klass(void *object TSRMLS_DC) { \+    klass *p = (klass *)object;","I think it conflict to `class`, we should use `class_type`, OK?",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/7542,72373860,2016-07-27T02:59:10Z,src/php/ext/grpc/php7_wrapper.h,"@@ -56,6 +56,14 @@ #define PHP_GRPC_WRAP_OBJECT_END(name) \   } name; +#define PHP_GRPC_FREE_WRAPPED_FUNC_START(klass) \+  void free_##klass(void *object TSRMLS_DC) { \+    klass *p = (klass *)object;",how about `class_object`?,
3523733,hvardhanx,https://api.github.com/repos/grpc/grpc/pulls/7433,72523498,2016-07-27T21:04:57Z,src/compiler/helper.h,"@@ -0,0 +1,128 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_COMPILER_HELPER_H+#define GRPC_INTERNAL_COMPILER_HELPER_H++ #include <memory>+ #include <vector>++ #ifndef GRPC_CUSTOM_STRING+ #include <string>+ #define GRPC_CUSTOM_STRING std::string+ #endif++ namespace grpc {++ typedef GRPC_CUSTOM_STRING string;++ }  // namespace grpc++// A common interface for objects having comments in the source.+// Return formatted comments to be inserted in generated code.+struct CommentHolder {+  virtual ~CommentHolder() {}+  virtual grpc::string GetLeadingCppComments() const = 0;+  virtual grpc::string GetTrailingCppComments() const = 0;+  virtual void GetPythonComments() const = 0;",This calls [PrintAllComments](https://github.com/grpc/grpc/blob/master/src/compiler/python_generator.cc#L209) in `python_generator_helpers.h`.,
6555937,pgrosu,https://api.github.com/repos/grpc/grpc/pulls/7557,72542322,2016-07-27T23:25:26Z,src/objective-c/tests/CoreCronetEnd2EndTests/CoreCronetEnd2EndTests.m,"@@ -236,7 +245,7 @@ - (void)testBadHostname { }  - (void)testBinaryMetadata {-  [self testIndividualCase:""binary_metadata""];+  //[self testIndividualCase:""binary_metadata""];","If the test is commented out, then why include the `testBinaryMetadata` method if the model of how it would be tested is not described?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7538,72648701,2016-07-28T15:49:57Z,tools/run_tests/run_tests.py,"@@ -488,19 +490,35 @@ def _get_pythons(self, args):       builder_prefix_arguments = []       venv_relative_python = ['bin/python']       toolchain = ['unix']+       # Bit-ness is handled by the test machine's environment       python_pattern_function = lambda major, minor, bits: 'python{major}.{minor}'.format(major=major, minor=minor)++      pypy_pattern_function = lambda major: 'pypy{major}'.format(major=major) if major == 3 else 'pypy'",Just define `_pypy_pattern(major):` as a module-scope function (even though it will have a one-line body and be used in only one place).,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7538,72648997,2016-07-28T15:51:40Z,tools/run_tests/run_tests.py,"@@ -488,19 +490,35 @@ def _get_pythons(self, args):       builder_prefix_arguments = []       venv_relative_python = ['bin/python']       toolchain = ['unix']+       # Bit-ness is handled by the test machine's environment       python_pattern_function = lambda major, minor, bits: 'python{major}.{minor}'.format(major=major, minor=minor)++      pypy_pattern_function = lambda major: 'pypy{major}'.format(major=major) if major == 3 else 'pypy'+     runner = [os.path.abspath('tools/run_tests/run_python.sh')]+     python_config_generator = lambda name, major, minor, bits: PythonConfig(","Rather than further bloat this already-too-long method, pull both `python_config_generator` and `pypy_config_generator` out into module-scope module-private helper functions?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6924,72649165,2016-07-28T15:52:27Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle","Suggest rewording this so it's a bit easier to understand: ""is requested"" -> ""gets a request for""Also, I am a big proponent of the Oxford comma (http://stephentall.org/wp-content/uploads/2011/09/oxford-comma.jpg).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6924,72649397,2016-07-28T15:53:49Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle+ * state, \a query_for_backends() is called. It creates an instance of \a+ * lb_client_data, an internal struct meant to contain the data associated with+ * the internal communication with the LB server. This instance is created via+ * \a lb_client_data_create(). There, the call over lb_channel to pick-first+ * from {a1..an} is created, the \a LoadBalancingRequest message is assembled+ * and all necessary callbacks for the progress of the internal call configured.+ *+ * Back in \a query_for_backends(), the internal *streaming* call to the LB+ * server (whichever address from {a1..an} pick-first chose) is kicked off.+ * It'll progress over the callbacks configured in \a lb_client_data_create()+ * (see the field docstrings of \a lb_client_data for more details).+ *+ * If the call fails with UNIMPLEMENTED, the original call will also fail.+ * There's a misconfiguration somewhere: at least one of {a1..an} isn't a LB+ * server, which contradicts the LB bit being set. If the internal call times+ * out, the usual behavior of pick-first applies, continuing to pick from the+ * list {a1..an}.+ *+ * Upon sucesss, a \a LoadBalancingResponse is expected in \a res_rcvd_cb. An+ * invalid one results in the termination of the streaming call. A new streaming+ * call should be created if possible, failing the original call otherwise.+ * For a valid \a LoadBalancingResponse, the server list of actual backends is+ * extracted. A Round Robin policy will be created from this list. There are two+ * possible scenarios:+ *+ * 1. This is the first server list received. There was no previous instance of+ *    the Round Robin policy. \a rr_handover() will instantiate the RR policy+ *    and perform all the pending operations over it.+ * 2. There's already a RR policy instance active. We need to introduce the new+ *    one build from the new serverlist, but taking care not to disrupt the+ *    operations in progress over the old RR instance. This is done by+ *    decreasing the reference count on the old policy. The moment no more+ *    references are held on the old RR policy, it'll be destroyed and \a+ *    rr_connectivity_changed notified with a \a GRPC_CHANNEL_SHUTDOWN state.+ *    At this point we can transition to a new RR instance safely, which is done+ *    once again via \a rr_handover().+ *+ *+ * Once a RR policy instance is in place (and getting updated as described),+ * calls to for a pick, a ping or a cancellation will be serviced right away by+ * forwarding them to the RR instance. Any time there's no RR policy available+ * (ie, right after the creation of the gRPCLB policy, if an empty serverlist+ * is received, etc), pick/ping requests are added to a list of pending+ * picks/pings to be flushed and serviced as part of \a rr_handover() the moment+ * the RR policy instance becomes available.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md for the+ * high level design and details. */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).+ */++#include <string.h>++#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/client_channel_factory.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/parse_address.h""+#include ""src/core/ext/lb_policy/grpclb/grpclb.h""+#include ""src/core/ext/lb_policy/grpclb/load_balancer_api.h""+#include ""src/core/lib/iomgr/sockaddr_utils.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/call.h""+#include ""src/core/lib/surface/channel.h""++int grpc_lb_glb_trace = 0;++typedef struct wrapped_rr_closure_arg {+  /* the original closure. Usually a on_complete/notify cb for pick() and ping()+   * calls against the internal RR instance, respectively. */+  grpc_closure *wrapped_closure;++  /* The RR instance related to the closure */+  grpc_lb_policy *rr_policy;++  /* when not NULL, represents a pending_{pick,ping} node to be freed upon+   * closure execution */+  void *owning_pending_node; /* to be freed if not NULL */+} wrapped_rr_closure_arg;++/* The \a on_complete closure passed as part of the pick requires keeping a+ * reference to its associated round robin instance. We wrap this closure in+ * order to unref the round robin instance upon its invocation */+static void wrapped_rr_closure(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  wrapped_rr_closure_arg *wc_arg = arg;+  if (wc_arg->rr_policy != NULL) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Unreffing RR (0x%"" PRIxPTR "")"",+              (intptr_t)wc_arg->rr_policy);+    }+    GRPC_LB_POLICY_UNREF(exec_ctx, wc_arg->rr_policy, ""wrapped_rr_closure"");+  }+  GPR_ASSERT(wc_arg->wrapped_closure != NULL);+  grpc_exec_ctx_sched(exec_ctx, wc_arg->wrapped_closure, error, NULL);+  gpr_free(wc_arg->owning_pending_node);+}++/* Linked list of pending pick requests. It stores all information needed to+ * eventually call (Round Robin's) pick() on them. They mainly stay pending+ * waiting for the RR policy to be created/updated.+ *+ * One particularity is the wrapping of the user-provided \a on_complete closure+ * (in \a wrapped_on_complete and \a wrapped_on_complete_arg). This is needed in+ * order to correctly unref the RR policy instance upon completion of the pick.+ * See \a wrapped_rr_closure for details. */+typedef struct pending_pick {+  struct pending_pick *next;++  /* polling entity for the pick()'s async notification */+  grpc_polling_entity *pollent;++  /* the initial metadata for the pick. See grpc_lb_policy_pick() */+  grpc_metadata_batch *initial_metadata;++  /* bitmask passed to pick() and used for selective cancelling. See+   * grpc_lb_policy_cancel_picks() */+  uint32_t initial_metadata_flags;++  /* output argument where to store the pick()ed connected subchannel, or NULL+   * upon error. */+  grpc_connected_subchannel **target;++  /* a closure wrapping the original on_complete one to be invoked once the+   * pick() has completed (regardless of success) */+  grpc_closure wrapped_on_complete;++  /* args for wrapped_on_complete */+  wrapped_rr_closure_arg wrapped_on_complete_arg;+} pending_pick;++/* Same as the \a pending_pick struct but for ping operations */+typedef struct pending_ping {+  struct pending_ping *next;++  /* a closure wrapping the original on_complete one to be invoked once the+   * ping() has completed (regardless of success) */+  grpc_closure wrapped_notify;++  /* args for wrapped_notify */+  wrapped_rr_closure_arg wrapped_notify_arg;+} pending_ping;++typedef struct glb_lb_policy glb_lb_policy;++/* Used internally for the client call to the LB */+typedef struct lb_client_data {+  gpr_mu mu;++  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once initial metadata's been received */+  grpc_closure md_rcvd;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;++  /* After the client has sent a close to the LB server */+  grpc_closure close_sent;++  /* ... and the status from the LB server has been received */+  grpc_closure srv_status_rcvd;++  grpc_call *lb_call;    /* streaming call to the LB server, */+  gpr_timespec deadline; /* for the streaming call to the LB server */++  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */+  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */++  /* what's being sent to the LB server. Note that its value may vary if the LB+   * server indicates a redirect. */+  grpc_byte_buffer *request_payload;++  /* response from the LB server, if any. Processed in res_rcvd_cb() */+  grpc_byte_buffer *response_payload;++  /* the call's status and status detailset in srv_status_rcvd_cb() */+  grpc_status_code status;+  char *status_details;+  size_t status_details_capacity;++  /* pointer back to the enclosing policy */+  glb_lb_policy *p;","In general, I think that abbreviated variable names like this make the code less readable.  Code gets read a lot more than it gets written, so I think we should optimize for the read case.  I think it's worth typing the extra characters of ""policy"" instead of ""p"" when writing the code to make it easier for people to read the code later.I think that we should follow the general naming rules outlined in the Google C++ style guide:https://google.github.io/styleguide/cppguide.html#General_Naming_RulesSame comment applies to other variable and field names in various places below (e.g., ""lbcd"", ""rrcd"", etc).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6924,72649460,2016-07-28T15:53:57Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle+ * state, \a query_for_backends() is called. It creates an instance of \a+ * lb_client_data, an internal struct meant to contain the data associated with+ * the internal communication with the LB server. This instance is created via+ * \a lb_client_data_create(). There, the call over lb_channel to pick-first+ * from {a1..an} is created, the \a LoadBalancingRequest message is assembled+ * and all necessary callbacks for the progress of the internal call configured.+ *+ * Back in \a query_for_backends(), the internal *streaming* call to the LB+ * server (whichever address from {a1..an} pick-first chose) is kicked off.+ * It'll progress over the callbacks configured in \a lb_client_data_create()+ * (see the field docstrings of \a lb_client_data for more details).+ *+ * If the call fails with UNIMPLEMENTED, the original call will also fail.+ * There's a misconfiguration somewhere: at least one of {a1..an} isn't a LB+ * server, which contradicts the LB bit being set. If the internal call times+ * out, the usual behavior of pick-first applies, continuing to pick from the+ * list {a1..an}.+ *+ * Upon sucesss, a \a LoadBalancingResponse is expected in \a res_rcvd_cb. An+ * invalid one results in the termination of the streaming call. A new streaming+ * call should be created if possible, failing the original call otherwise.+ * For a valid \a LoadBalancingResponse, the server list of actual backends is+ * extracted. A Round Robin policy will be created from this list. There are two+ * possible scenarios:+ *+ * 1. This is the first server list received. There was no previous instance of+ *    the Round Robin policy. \a rr_handover() will instantiate the RR policy+ *    and perform all the pending operations over it.+ * 2. There's already a RR policy instance active. We need to introduce the new+ *    one build from the new serverlist, but taking care not to disrupt the+ *    operations in progress over the old RR instance. This is done by+ *    decreasing the reference count on the old policy. The moment no more+ *    references are held on the old RR policy, it'll be destroyed and \a+ *    rr_connectivity_changed notified with a \a GRPC_CHANNEL_SHUTDOWN state.+ *    At this point we can transition to a new RR instance safely, which is done+ *    once again via \a rr_handover().+ *+ *+ * Once a RR policy instance is in place (and getting updated as described),+ * calls to for a pick, a ping or a cancellation will be serviced right away by+ * forwarding them to the RR instance. Any time there's no RR policy available+ * (ie, right after the creation of the gRPCLB policy, if an empty serverlist+ * is received, etc), pick/ping requests are added to a list of pending+ * picks/pings to be flushed and serviced as part of \a rr_handover() the moment+ * the RR policy instance becomes available.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md for the+ * high level design and details. */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).+ */++#include <string.h>++#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/client_channel_factory.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/parse_address.h""+#include ""src/core/ext/lb_policy/grpclb/grpclb.h""+#include ""src/core/ext/lb_policy/grpclb/load_balancer_api.h""+#include ""src/core/lib/iomgr/sockaddr_utils.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/call.h""+#include ""src/core/lib/surface/channel.h""++int grpc_lb_glb_trace = 0;++typedef struct wrapped_rr_closure_arg {+  /* the original closure. Usually a on_complete/notify cb for pick() and ping()+   * calls against the internal RR instance, respectively. */+  grpc_closure *wrapped_closure;++  /* The RR instance related to the closure */+  grpc_lb_policy *rr_policy;++  /* when not NULL, represents a pending_{pick,ping} node to be freed upon+   * closure execution */+  void *owning_pending_node; /* to be freed if not NULL */+} wrapped_rr_closure_arg;++/* The \a on_complete closure passed as part of the pick requires keeping a+ * reference to its associated round robin instance. We wrap this closure in+ * order to unref the round robin instance upon its invocation */+static void wrapped_rr_closure(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  wrapped_rr_closure_arg *wc_arg = arg;+  if (wc_arg->rr_policy != NULL) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Unreffing RR (0x%"" PRIxPTR "")"",+              (intptr_t)wc_arg->rr_policy);+    }+    GRPC_LB_POLICY_UNREF(exec_ctx, wc_arg->rr_policy, ""wrapped_rr_closure"");+  }+  GPR_ASSERT(wc_arg->wrapped_closure != NULL);+  grpc_exec_ctx_sched(exec_ctx, wc_arg->wrapped_closure, error, NULL);+  gpr_free(wc_arg->owning_pending_node);+}++/* Linked list of pending pick requests. It stores all information needed to+ * eventually call (Round Robin's) pick() on them. They mainly stay pending+ * waiting for the RR policy to be created/updated.+ *+ * One particularity is the wrapping of the user-provided \a on_complete closure+ * (in \a wrapped_on_complete and \a wrapped_on_complete_arg). This is needed in+ * order to correctly unref the RR policy instance upon completion of the pick.+ * See \a wrapped_rr_closure for details. */+typedef struct pending_pick {+  struct pending_pick *next;++  /* polling entity for the pick()'s async notification */+  grpc_polling_entity *pollent;++  /* the initial metadata for the pick. See grpc_lb_policy_pick() */+  grpc_metadata_batch *initial_metadata;++  /* bitmask passed to pick() and used for selective cancelling. See+   * grpc_lb_policy_cancel_picks() */+  uint32_t initial_metadata_flags;++  /* output argument where to store the pick()ed connected subchannel, or NULL+   * upon error. */+  grpc_connected_subchannel **target;++  /* a closure wrapping the original on_complete one to be invoked once the+   * pick() has completed (regardless of success) */+  grpc_closure wrapped_on_complete;++  /* args for wrapped_on_complete */+  wrapped_rr_closure_arg wrapped_on_complete_arg;+} pending_pick;++/* Same as the \a pending_pick struct but for ping operations */+typedef struct pending_ping {+  struct pending_ping *next;++  /* a closure wrapping the original on_complete one to be invoked once the+   * ping() has completed (regardless of success) */+  grpc_closure wrapped_notify;++  /* args for wrapped_notify */+  wrapped_rr_closure_arg wrapped_notify_arg;+} pending_ping;++typedef struct glb_lb_policy glb_lb_policy;++/* Used internally for the client call to the LB */+typedef struct lb_client_data {+  gpr_mu mu;++  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once initial metadata's been received */+  grpc_closure md_rcvd;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;++  /* After the client has sent a close to the LB server */+  grpc_closure close_sent;++  /* ... and the status from the LB server has been received */+  grpc_closure srv_status_rcvd;++  grpc_call *lb_call;    /* streaming call to the LB server, */+  gpr_timespec deadline; /* for the streaming call to the LB server */++  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */+  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */++  /* what's being sent to the LB server. Note that its value may vary if the LB+   * server indicates a redirect. */+  grpc_byte_buffer *request_payload;++  /* response from the LB server, if any. Processed in res_rcvd_cb() */+  grpc_byte_buffer *response_payload;++  /* the call's status and status detailset in srv_status_rcvd_cb() */+  grpc_status_code status;+  char *status_details;+  size_t status_details_capacity;++  /* pointer back to the enclosing policy */+  glb_lb_policy *p;+} lb_client_data;++/* Keeps track and reacts to changes in connectivity of the RR instance */+typedef struct rr_connectivity_data {+  grpc_closure on_change;+  grpc_connectivity_state state;+  glb_lb_policy *p;+} rr_connectivity_data;++struct glb_lb_policy {+  /** base policy: must be first */+  grpc_lb_policy base;++  /** mutex protecting remaining members */+  gpr_mu mu;++  grpc_client_channel_factory *cc_factory;++  /** for communicating with the LB server */+  grpc_channel *lb_channel;++  /** the RR policy to use of the backend servers returned by the LB server */+  grpc_lb_policy *rr_policy;++  bool started_picking;++  /** our connectivity state tracker */+  grpc_connectivity_state_tracker state_tracker;++  /** stores the deserialized response from the LB. May be NULL until one such+   * response has arrived. */+  grpc_grpclb_serverlist *serverlist;++  /** list of picks that are waiting on RR's policy connectivity */+  pending_pick *pending_picks;++  /** list of pings that are waiting on RR's policy connectivity */+  pending_ping *pending_pings;++  /** client data associated with the LB server communication */+  lb_client_data *lbcd;++  /** for tracking of the RR connectivity */+  rr_connectivity_data *rr_connectivity;++  /* a wrapped (see ...) on-complete closure for readily available RR picks */+  grpc_closure wrapped_on_complete;++  /* arguments for the wrapped_on_complete closure */+  wrapped_rr_closure_arg wc_arg;+};++static void rr_handover(grpc_exec_ctx *exec_ctx, glb_lb_policy *p,","Suggestion, feel free to ignore: I think the organization of this code might be clearer if it were organized by ""class"" -- i.e., put the functions that are effectively methods of a given struct right after that struct, so that all of the code related to a given struct is in one place.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6924,72649494,2016-07-28T15:54:10Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle+ * state, \a query_for_backends() is called. It creates an instance of \a+ * lb_client_data, an internal struct meant to contain the data associated with+ * the internal communication with the LB server. This instance is created via+ * \a lb_client_data_create(). There, the call over lb_channel to pick-first+ * from {a1..an} is created, the \a LoadBalancingRequest message is assembled+ * and all necessary callbacks for the progress of the internal call configured.+ *+ * Back in \a query_for_backends(), the internal *streaming* call to the LB+ * server (whichever address from {a1..an} pick-first chose) is kicked off.+ * It'll progress over the callbacks configured in \a lb_client_data_create()+ * (see the field docstrings of \a lb_client_data for more details).+ *+ * If the call fails with UNIMPLEMENTED, the original call will also fail.+ * There's a misconfiguration somewhere: at least one of {a1..an} isn't a LB+ * server, which contradicts the LB bit being set. If the internal call times+ * out, the usual behavior of pick-first applies, continuing to pick from the+ * list {a1..an}.+ *+ * Upon sucesss, a \a LoadBalancingResponse is expected in \a res_rcvd_cb. An+ * invalid one results in the termination of the streaming call. A new streaming+ * call should be created if possible, failing the original call otherwise.+ * For a valid \a LoadBalancingResponse, the server list of actual backends is+ * extracted. A Round Robin policy will be created from this list. There are two+ * possible scenarios:+ *+ * 1. This is the first server list received. There was no previous instance of+ *    the Round Robin policy. \a rr_handover() will instantiate the RR policy+ *    and perform all the pending operations over it.+ * 2. There's already a RR policy instance active. We need to introduce the new+ *    one build from the new serverlist, but taking care not to disrupt the+ *    operations in progress over the old RR instance. This is done by+ *    decreasing the reference count on the old policy. The moment no more+ *    references are held on the old RR policy, it'll be destroyed and \a+ *    rr_connectivity_changed notified with a \a GRPC_CHANNEL_SHUTDOWN state.+ *    At this point we can transition to a new RR instance safely, which is done+ *    once again via \a rr_handover().+ *+ *+ * Once a RR policy instance is in place (and getting updated as described),+ * calls to for a pick, a ping or a cancellation will be serviced right away by+ * forwarding them to the RR instance. Any time there's no RR policy available+ * (ie, right after the creation of the gRPCLB policy, if an empty serverlist+ * is received, etc), pick/ping requests are added to a list of pending+ * picks/pings to be flushed and serviced as part of \a rr_handover() the moment+ * the RR policy instance becomes available.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md for the+ * high level design and details. */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).+ */++#include <string.h>++#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/client_channel_factory.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/parse_address.h""+#include ""src/core/ext/lb_policy/grpclb/grpclb.h""+#include ""src/core/ext/lb_policy/grpclb/load_balancer_api.h""+#include ""src/core/lib/iomgr/sockaddr_utils.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/call.h""+#include ""src/core/lib/surface/channel.h""++int grpc_lb_glb_trace = 0;++typedef struct wrapped_rr_closure_arg {+  /* the original closure. Usually a on_complete/notify cb for pick() and ping()+   * calls against the internal RR instance, respectively. */+  grpc_closure *wrapped_closure;++  /* The RR instance related to the closure */+  grpc_lb_policy *rr_policy;++  /* when not NULL, represents a pending_{pick,ping} node to be freed upon+   * closure execution */+  void *owning_pending_node; /* to be freed if not NULL */+} wrapped_rr_closure_arg;++/* The \a on_complete closure passed as part of the pick requires keeping a+ * reference to its associated round robin instance. We wrap this closure in+ * order to unref the round robin instance upon its invocation */+static void wrapped_rr_closure(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  wrapped_rr_closure_arg *wc_arg = arg;+  if (wc_arg->rr_policy != NULL) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Unreffing RR (0x%"" PRIxPTR "")"",+              (intptr_t)wc_arg->rr_policy);+    }+    GRPC_LB_POLICY_UNREF(exec_ctx, wc_arg->rr_policy, ""wrapped_rr_closure"");+  }+  GPR_ASSERT(wc_arg->wrapped_closure != NULL);+  grpc_exec_ctx_sched(exec_ctx, wc_arg->wrapped_closure, error, NULL);+  gpr_free(wc_arg->owning_pending_node);+}++/* Linked list of pending pick requests. It stores all information needed to+ * eventually call (Round Robin's) pick() on them. They mainly stay pending+ * waiting for the RR policy to be created/updated.+ *+ * One particularity is the wrapping of the user-provided \a on_complete closure+ * (in \a wrapped_on_complete and \a wrapped_on_complete_arg). This is needed in+ * order to correctly unref the RR policy instance upon completion of the pick.+ * See \a wrapped_rr_closure for details. */+typedef struct pending_pick {+  struct pending_pick *next;++  /* polling entity for the pick()'s async notification */+  grpc_polling_entity *pollent;++  /* the initial metadata for the pick. See grpc_lb_policy_pick() */+  grpc_metadata_batch *initial_metadata;++  /* bitmask passed to pick() and used for selective cancelling. See+   * grpc_lb_policy_cancel_picks() */+  uint32_t initial_metadata_flags;++  /* output argument where to store the pick()ed connected subchannel, or NULL+   * upon error. */+  grpc_connected_subchannel **target;++  /* a closure wrapping the original on_complete one to be invoked once the+   * pick() has completed (regardless of success) */+  grpc_closure wrapped_on_complete;++  /* args for wrapped_on_complete */+  wrapped_rr_closure_arg wrapped_on_complete_arg;+} pending_pick;++/* Same as the \a pending_pick struct but for ping operations */+typedef struct pending_ping {+  struct pending_ping *next;++  /* a closure wrapping the original on_complete one to be invoked once the+   * ping() has completed (regardless of success) */+  grpc_closure wrapped_notify;++  /* args for wrapped_notify */+  wrapped_rr_closure_arg wrapped_notify_arg;+} pending_ping;++typedef struct glb_lb_policy glb_lb_policy;++/* Used internally for the client call to the LB */+typedef struct lb_client_data {+  gpr_mu mu;++  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once initial metadata's been received */+  grpc_closure md_rcvd;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;++  /* After the client has sent a close to the LB server */+  grpc_closure close_sent;++  /* ... and the status from the LB server has been received */+  grpc_closure srv_status_rcvd;++  grpc_call *lb_call;    /* streaming call to the LB server, */+  gpr_timespec deadline; /* for the streaming call to the LB server */++  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */+  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */++  /* what's being sent to the LB server. Note that its value may vary if the LB+   * server indicates a redirect. */+  grpc_byte_buffer *request_payload;++  /* response from the LB server, if any. Processed in res_rcvd_cb() */+  grpc_byte_buffer *response_payload;++  /* the call's status and status detailset in srv_status_rcvd_cb() */+  grpc_status_code status;+  char *status_details;+  size_t status_details_capacity;++  /* pointer back to the enclosing policy */+  glb_lb_policy *p;+} lb_client_data;++/* Keeps track and reacts to changes in connectivity of the RR instance */+typedef struct rr_connectivity_data {+  grpc_closure on_change;+  grpc_connectivity_state state;+  glb_lb_policy *p;+} rr_connectivity_data;++struct glb_lb_policy {+  /** base policy: must be first */+  grpc_lb_policy base;++  /** mutex protecting remaining members */+  gpr_mu mu;++  grpc_client_channel_factory *cc_factory;++  /** for communicating with the LB server */+  grpc_channel *lb_channel;++  /** the RR policy to use of the backend servers returned by the LB server */+  grpc_lb_policy *rr_policy;++  bool started_picking;++  /** our connectivity state tracker */+  grpc_connectivity_state_tracker state_tracker;++  /** stores the deserialized response from the LB. May be NULL until one such+   * response has arrived. */+  grpc_grpclb_serverlist *serverlist;++  /** list of picks that are waiting on RR's policy connectivity */+  pending_pick *pending_picks;++  /** list of pings that are waiting on RR's policy connectivity */+  pending_ping *pending_pings;++  /** client data associated with the LB server communication */+  lb_client_data *lbcd;++  /** for tracking of the RR connectivity */+  rr_connectivity_data *rr_connectivity;++  /* a wrapped (see ...) on-complete closure for readily available RR picks */+  grpc_closure wrapped_on_complete;++  /* arguments for the wrapped_on_complete closure */+  wrapped_rr_closure_arg wc_arg;+};++static void rr_handover(grpc_exec_ctx *exec_ctx, glb_lb_policy *p,+                        grpc_error *error);+static void rr_connectivity_changed(grpc_exec_ctx *exec_ctx, void *arg,+                                    grpc_error *error) {+  rr_connectivity_data *rrcd = arg;+  glb_lb_policy *p = rrcd->p;+  if (rrcd->state == GRPC_CHANNEL_SHUTDOWN) {+    if (p->serverlist != NULL) {+      /* a RR policy is shutting down but there's a serverlist available ->+       * perform a handover */+      rr_handover(exec_ctx, p, error);+    } else {+      /* shutting down and no new serverlist available. Bail out. */+      gpr_free(rrcd);+    }+  } else {+    if (error == GRPC_ERROR_NONE) {+      /* RR not shutting down. Mimic the RR's policy state */+      grpc_connectivity_state_set(exec_ctx, &p->state_tracker, rrcd->state,+                                  error, ""rr_connectivity_changed"");+      /* resubscribe */+      grpc_lb_policy_notify_on_state_change(exec_ctx, p->rr_policy,+                                            &rrcd->state, &rrcd->on_change);+    } else { /* error */+      gpr_free(rrcd);+    }+  }+  GRPC_ERROR_UNREF(error);+}++static void add_pending_pick(pending_pick **root, grpc_polling_entity *pollent,+                             grpc_metadata_batch *initial_metadata,+                             uint32_t initial_metadata_flags,+                             grpc_connected_subchannel **target,+                             grpc_closure *on_complete) {+  pending_pick *pp = gpr_malloc(sizeof(*pp));+  memset(pp, 0, sizeof(pending_pick));+  memset(&pp->wrapped_on_complete_arg, 0, sizeof(wrapped_rr_closure_arg));+  pp->next = *root;+  pp->pollent = pollent;+  pp->target = target;+  pp->initial_metadata = initial_metadata;+  pp->initial_metadata_flags = initial_metadata_flags;+  pp->wrapped_on_complete_arg.wrapped_closure = on_complete;+  grpc_closure_init(&pp->wrapped_on_complete, wrapped_rr_closure,+                    &pp->wrapped_on_complete_arg);+  *root = pp;+}++static void add_pending_ping(pending_ping **root, grpc_closure *notify) {+  pending_ping *pping = gpr_malloc(sizeof(*pping));+  memset(pping, 0, sizeof(pending_ping));+  memset(&pping->wrapped_notify_arg, 0, sizeof(wrapped_rr_closure_arg));+  pping->next = *root;+  grpc_closure_init(&pping->wrapped_notify, wrapped_rr_closure,+                    &pping->wrapped_notify_arg);+  pping->wrapped_notify_arg.wrapped_closure = notify;+  *root = pping;+}++static void lb_client_data_destroy(lb_client_data *lbcd);++static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  GPR_ASSERT(lbcd->lb_call);+  grpc_call_error call_error;+  grpc_op ops[1];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &lbcd->initial_metadata_recv;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  call_error = grpc_call_start_batch_and_execute(+      exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->md_rcvd);+  GPR_ASSERT(GRPC_CALL_OK == call_error);+}++static void md_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  GPR_ASSERT(lbcd->lb_call);+  grpc_call_error call_error;+  grpc_op ops[1];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;++  op->op = GRPC_OP_SEND_MESSAGE;+  op->data.send_message = lbcd->request_payload;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  call_error = grpc_call_start_batch_and_execute(+      exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->req_sent);+  GPR_ASSERT(GRPC_CALL_OK == call_error);+}++static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  grpc_call_error call_error;++  grpc_op ops[1];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;++  op->op = GRPC_OP_RECV_MESSAGE;+  op->data.recv_message = &lbcd->response_payload;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  call_error = grpc_call_start_batch_and_execute(+      exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->res_rcvd);+  GPR_ASSERT(GRPC_CALL_OK == call_error);+}++static void res_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  grpc_op ops[2];+  memset(ops, 0, sizeof(ops));+  grpc_op *op = ops;+  if (lbcd->response_payload != NULL) {+    /* Received data from the LB server. Look inside lbcd->response_payload, for+     * a serverlist. */+    grpc_byte_buffer_reader bbr;+    grpc_byte_buffer_reader_init(&bbr, lbcd->response_payload);+    gpr_slice response_slice = grpc_byte_buffer_reader_readall(&bbr);+    grpc_byte_buffer_destroy(lbcd->response_payload);+    grpc_grpclb_serverlist *serverlist =+        grpc_grpclb_response_parse_serverlist(response_slice);+    if (serverlist != NULL) {+      gpr_slice_unref(response_slice);+      if (grpc_lb_glb_trace) {+        gpr_log(GPR_INFO, ""Serverlist with %zu servers received"",+                serverlist->num_servers);+      }++      /* update serverlist */+      if (serverlist->num_servers > 0) {+        if (grpc_grpclb_serverlist_equals(lbcd->p->serverlist, serverlist)) {+          if (grpc_lb_glb_trace) {+            gpr_log(GPR_INFO,+                    ""Incoming server list identical to current, ignoring."");+          }+        } else { /* new serverlist */+          if (lbcd->p->serverlist != NULL) {+            /* dispose of the old serverlist */+            grpc_grpclb_destroy_serverlist(lbcd->p->serverlist);+          }+          /* and update the copy in the glb_lb_policy instance */+          lbcd->p->serverlist = serverlist;+        }+        if (lbcd->p->rr_policy == NULL) {+          /* initial ""handover"", in this case from a null RR policy, meaning+           * it'll just create the first RR policy instance */+          rr_handover(exec_ctx, lbcd->p, error);+        } else {+          /* unref the RR policy, eventually leading to its substitution with a+           * new one constructed from the received serverlist (see+           * rr_connectivity_changed) */+          GRPC_LB_POLICY_UNREF(exec_ctx, lbcd->p->rr_policy,+                               ""serverlist_received"");+        }+      } else {+        if (grpc_lb_glb_trace) {+          gpr_log(GPR_INFO,+                  ""Received empty server list. Picks will stay pending until a ""+                  ""response with > 0 servers is received"");+        }+      }++      /* keep listening for serverlist updates */+      op->op = GRPC_OP_RECV_MESSAGE;+      op->data.recv_message = &lbcd->response_payload;+      op->flags = 0;+      op->reserved = NULL;+      op++;+      const grpc_call_error call_error = grpc_call_start_batch_and_execute(+          exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops),+          &lbcd->res_rcvd); /* loop */+      GPR_ASSERT(GRPC_CALL_OK == call_error);+      return;+    }++    GPR_ASSERT(serverlist == NULL);+    gpr_log(GPR_ERROR, ""Invalid LB response received: '%s'"",+            gpr_dump_slice(response_slice, GPR_DUMP_ASCII));+    gpr_slice_unref(response_slice);++    /* Disconnect from server returning invalid response. */+    op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+    op->flags = 0;+    op->reserved = NULL;+    op++;+    grpc_call_error call_error = grpc_call_start_batch_and_execute(+        exec_ctx, lbcd->lb_call, ops, (size_t)(op - ops), &lbcd->close_sent);+    GPR_ASSERT(GRPC_CALL_OK == call_error);+  }+  /* empty payload: call cancelled by server. Cleanups happening in+   * srv_status_rcvd_cb */+}++static void close_sent_cb(grpc_exec_ctx *exec_ctx, void *arg,+                          grpc_error *error) {+  if (grpc_lb_glb_trace) {+    gpr_log(GPR_INFO,+            ""Close from LB client sent. Waiting from server status now"");+  }+}++static void query_for_backends(grpc_exec_ctx *exec_ctx, glb_lb_policy *p);+static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  lb_client_data *lbcd = arg;+  glb_lb_policy *p = lbcd->p;+  if (grpc_lb_glb_trace) {+    gpr_log(GPR_INFO,+            ""status from lb server received. Status = %d, Details = '%s', ""+            ""Capaticy ""+            ""= %zu"",+            lbcd->status, lbcd->status_details, lbcd->status_details_capacity);+  }++  grpc_call_destroy(lbcd->lb_call);+  lb_client_data_destroy(lbcd);+  p->lbcd = NULL;+  /* TODO(dgq): deal with stream termination properly (fire up another one? fail+   * the original call?) */+}++static lb_client_data *lb_client_data_create(glb_lb_policy *p) {+  lb_client_data *lbcd = gpr_malloc(sizeof(lb_client_data));+  memset(lbcd, 0, sizeof(lb_client_data));++  gpr_mu_init(&lbcd->mu);+  grpc_closure_init(&lbcd->md_sent, md_sent_cb, lbcd);++  grpc_closure_init(&lbcd->md_rcvd, md_recv_cb, lbcd);+  grpc_closure_init(&lbcd->req_sent, req_sent_cb, lbcd);+  grpc_closure_init(&lbcd->res_rcvd, res_rcvd_cb, lbcd);+  grpc_closure_init(&lbcd->close_sent, close_sent_cb, lbcd);+  grpc_closure_init(&lbcd->srv_status_rcvd, srv_status_rcvd_cb, lbcd);++  /* TODO(dgq): get the deadline from the client config instead of fabricating+   * one here. */+  lbcd->deadline = gpr_time_add(gpr_now(GPR_CLOCK_MONOTONIC),+                                gpr_time_from_seconds(3, GPR_TIMESPAN));++  lbcd->lb_call = grpc_channel_create_pollset_set_call(+      p->lb_channel, NULL, GRPC_PROPAGATE_DEFAULTS, p->base.interested_parties,+      ""/BalanceLoad"", NULL, /* FIXME(dgq): which ""host"" value to use? */+      lbcd->deadline, NULL);++  grpc_metadata_array_init(&lbcd->initial_metadata_recv);+  grpc_metadata_array_init(&lbcd->trailing_metadata_recv);++  grpc_grpclb_request *request = grpc_grpclb_request_create(+      ""load.balanced.service.name""); /* FIXME(dgq): get the name of the load","When gRPC-LB is in use, name resolution should return the name of the load balancers at the same time that it returns the addresses.  This should probably be plumbed through the resolver API.I'm fine with leaving this for a separate PR, as long as we make sure it gets done.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6915,72656103,2016-07-28T16:32:52Z,src/cpp/common/channel_filter.h,"@@ -0,0 +1,373 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc++/impl/codegen/config.h>+#include <grpc/census.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>++#include <functional>+#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/security/context/security_context.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""src/core/lib/transport/metadata_batch.h""++///+/// An interface to define filters.+///+/// To define a filter, implement a subclass of each of \c CallData and+/// \c ChannelData. Then register the filter using something like this:+/// \code{.cpp}+///   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+///       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);+/// \endcode+///++namespace grpc {++/// A C++ wrapper for the \c grpc_metadata_batch struct.+class MetadataBatch {+ public:+  explicit MetadataBatch(grpc_metadata_batch *batch) : batch_(batch) {}++  grpc_metadata_batch *batch() const { return batch_; }++  // Adds metadata and returns the newly allocated storage.+  // The caller takes ownership of the result, which must exist for the+  // lifetime of the gRPC call.+  grpc_linked_mdelem *AddMetadata(const string &key, const string &value);++  class const_iterator : public std::iterator<std::bidirectional_iterator_tag,+                                              const grpc_mdelem> {+   public:+    const grpc_mdelem &operator*() const { return *elem_->md; }+    const grpc_mdelem *operator->() const { return elem_->md; }++    const_iterator &operator++() {+      elem_ = elem_->next;+      return *this;+    }+    const_iterator operator++(int) {+      const_iterator tmp(*this);+      operator++();+      return tmp;+    }+    const_iterator &operator--() {+      elem_ = elem_->prev;+      return *this;+    }+    const_iterator operator--(int) {+      const_iterator tmp(*this);+      operator--();+      return tmp;+    }++    bool operator==(const const_iterator &other) const {+      return elem_ == other.elem_;+    }+    bool operator!=(const const_iterator &other) const {+      return elem_ != other.elem_;+    }++   private:+    friend class MetadataBatch;+    explicit const_iterator(grpc_linked_mdelem *elem) : elem_(elem) {}++    grpc_linked_mdelem *elem_;+  };++  const_iterator begin() const { return const_iterator(batch_->list.head); }+  const_iterator end() const { return const_iterator(nullptr); }++ private:+  grpc_metadata_batch *batch_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_op struct.+class TransportOp {+ public:+  explicit TransportOp(grpc_transport_op *op) : op_(op) {}++  grpc_transport_op *op() const { return op_; }++  // TODO(roth): Add a C++ wrapper for grpc_error?+  grpc_error *disconnect_with_error() const {+    return op_->disconnect_with_error;+  }+  bool send_goaway() const { return op_->send_goaway; }++  // TODO(roth): Add methods for additional fields as needed.++ private:+  grpc_transport_op *op_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_stream_op struct.+class TransportStreamOp {+ public:+  explicit TransportStreamOp(grpc_transport_stream_op *op)+      : op_(op),+        send_initial_metadata_(op->send_initial_metadata),","The goal here is to provide a more C++-like API for accessing metadata.  Thus, the member variables are C++ MetadataBatch objects, which are wrapped around the corresponding C grpc_metadata_batch structs.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6915,72656114,2016-07-28T16:32:55Z,src/cpp/common/channel_filter.h,"@@ -0,0 +1,373 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc++/impl/codegen/config.h>+#include <grpc/census.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>++#include <functional>+#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/security/context/security_context.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""src/core/lib/transport/metadata_batch.h""++///+/// An interface to define filters.+///+/// To define a filter, implement a subclass of each of \c CallData and+/// \c ChannelData. Then register the filter using something like this:+/// \code{.cpp}+///   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+///       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);+/// \endcode+///++namespace grpc {++/// A C++ wrapper for the \c grpc_metadata_batch struct.+class MetadataBatch {+ public:+  explicit MetadataBatch(grpc_metadata_batch *batch) : batch_(batch) {}++  grpc_metadata_batch *batch() const { return batch_; }++  // Adds metadata and returns the newly allocated storage.+  // The caller takes ownership of the result, which must exist for the+  // lifetime of the gRPC call.+  grpc_linked_mdelem *AddMetadata(const string &key, const string &value);++  class const_iterator : public std::iterator<std::bidirectional_iterator_tag,+                                              const grpc_mdelem> {+   public:+    const grpc_mdelem &operator*() const { return *elem_->md; }+    const grpc_mdelem *operator->() const { return elem_->md; }++    const_iterator &operator++() {+      elem_ = elem_->next;+      return *this;+    }+    const_iterator operator++(int) {+      const_iterator tmp(*this);+      operator++();+      return tmp;+    }+    const_iterator &operator--() {+      elem_ = elem_->prev;+      return *this;+    }+    const_iterator operator--(int) {+      const_iterator tmp(*this);+      operator--();+      return tmp;+    }++    bool operator==(const const_iterator &other) const {+      return elem_ == other.elem_;+    }+    bool operator!=(const const_iterator &other) const {+      return elem_ != other.elem_;+    }++   private:+    friend class MetadataBatch;+    explicit const_iterator(grpc_linked_mdelem *elem) : elem_(elem) {}++    grpc_linked_mdelem *elem_;+  };++  const_iterator begin() const { return const_iterator(batch_->list.head); }+  const_iterator end() const { return const_iterator(nullptr); }++ private:+  grpc_metadata_batch *batch_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_op struct.+class TransportOp {+ public:+  explicit TransportOp(grpc_transport_op *op) : op_(op) {}++  grpc_transport_op *op() const { return op_; }++  // TODO(roth): Add a C++ wrapper for grpc_error?+  grpc_error *disconnect_with_error() const {+    return op_->disconnect_with_error;+  }+  bool send_goaway() const { return op_->send_goaway; }++  // TODO(roth): Add methods for additional fields as needed.++ private:+  grpc_transport_op *op_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_stream_op struct.+class TransportStreamOp {+ public:+  explicit TransportStreamOp(grpc_transport_stream_op *op)+      : op_(op),+        send_initial_metadata_(op->send_initial_metadata),+        send_trailing_metadata_(op->send_trailing_metadata),+        recv_initial_metadata_(op->recv_initial_metadata),+        recv_trailing_metadata_(op->recv_trailing_metadata) {}++  grpc_transport_stream_op *op() const { return op_; }++  grpc_closure *on_complete() const { return op_->on_complete; }+  void set_on_complete(grpc_closure *closure) { op_->on_complete = closure; }++  MetadataBatch *send_initial_metadata() {+    return op_->send_initial_metadata == nullptr ? nullptr+                                                 : &send_initial_metadata_;","As I mentioned above, the goal here is to provide a more idiomatic C++ API for accessing metadata.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/6915,72656143,2016-07-28T16:33:06Z,src/cpp/common/channel_filter.h,"@@ -0,0 +1,373 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_CHANNEL_FILTER_H+#define GRPCXX_CHANNEL_FILTER_H++#include <grpc++/impl/codegen/config.h>+#include <grpc/census.h>+#include <grpc/grpc.h>+#include <grpc/impl/codegen/alloc.h>++#include <functional>+#include <vector>++#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/security/context/security_context.h""+#include ""src/core/lib/surface/channel_init.h""+#include ""src/core/lib/transport/metadata_batch.h""++///+/// An interface to define filters.+///+/// To define a filter, implement a subclass of each of \c CallData and+/// \c ChannelData. Then register the filter using something like this:+/// \code{.cpp}+///   RegisterChannelFilter<MyChannelDataSubclass, MyCallDataSubclass>(+///       ""name-of-filter"", GRPC_SERVER_CHANNEL, INT_MAX, nullptr);+/// \endcode+///++namespace grpc {++/// A C++ wrapper for the \c grpc_metadata_batch struct.+class MetadataBatch {+ public:+  explicit MetadataBatch(grpc_metadata_batch *batch) : batch_(batch) {}++  grpc_metadata_batch *batch() const { return batch_; }++  // Adds metadata and returns the newly allocated storage.+  // The caller takes ownership of the result, which must exist for the+  // lifetime of the gRPC call.+  grpc_linked_mdelem *AddMetadata(const string &key, const string &value);++  class const_iterator : public std::iterator<std::bidirectional_iterator_tag,+                                              const grpc_mdelem> {+   public:+    const grpc_mdelem &operator*() const { return *elem_->md; }+    const grpc_mdelem *operator->() const { return elem_->md; }++    const_iterator &operator++() {+      elem_ = elem_->next;+      return *this;+    }+    const_iterator operator++(int) {+      const_iterator tmp(*this);+      operator++();+      return tmp;+    }+    const_iterator &operator--() {+      elem_ = elem_->prev;+      return *this;+    }+    const_iterator operator--(int) {+      const_iterator tmp(*this);+      operator--();+      return tmp;+    }++    bool operator==(const const_iterator &other) const {+      return elem_ == other.elem_;+    }+    bool operator!=(const const_iterator &other) const {+      return elem_ != other.elem_;+    }++   private:+    friend class MetadataBatch;+    explicit const_iterator(grpc_linked_mdelem *elem) : elem_(elem) {}++    grpc_linked_mdelem *elem_;+  };++  const_iterator begin() const { return const_iterator(batch_->list.head); }+  const_iterator end() const { return const_iterator(nullptr); }++ private:+  grpc_metadata_batch *batch_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_op struct.+class TransportOp {+ public:+  explicit TransportOp(grpc_transport_op *op) : op_(op) {}++  grpc_transport_op *op() const { return op_; }++  // TODO(roth): Add a C++ wrapper for grpc_error?+  grpc_error *disconnect_with_error() const {+    return op_->disconnect_with_error;+  }+  bool send_goaway() const { return op_->send_goaway; }++  // TODO(roth): Add methods for additional fields as needed.++ private:+  grpc_transport_op *op_;  // Not owned.+};++/// A C++ wrapper for the \c grpc_transport_stream_op struct.+class TransportStreamOp {+ public:+  explicit TransportStreamOp(grpc_transport_stream_op *op)+      : op_(op),+        send_initial_metadata_(op->send_initial_metadata),+        send_trailing_metadata_(op->send_trailing_metadata),+        recv_initial_metadata_(op->recv_initial_metadata),+        recv_trailing_metadata_(op->recv_trailing_metadata) {}++  grpc_transport_stream_op *op() const { return op_; }++  grpc_closure *on_complete() const { return op_->on_complete; }+  void set_on_complete(grpc_closure *closure) { op_->on_complete = closure; }++  MetadataBatch *send_initial_metadata() {+    return op_->send_initial_metadata == nullptr ? nullptr+                                                 : &send_initial_metadata_;+  }+  MetadataBatch *send_trailing_metadata() {+    return op_->send_trailing_metadata == nullptr ? nullptr+                                                  : &send_trailing_metadata_;+  }+  MetadataBatch *recv_initial_metadata() {+    return op_->recv_initial_metadata == nullptr ? nullptr+                                                 : &recv_initial_metadata_;+  }+  MetadataBatch *recv_trailing_metadata() {+    return op_->recv_trailing_metadata == nullptr ? nullptr+                                                  : &recv_trailing_metadata_;+  }++  uint32_t *send_initial_metadata_flags() const {+    return &op_->send_initial_metadata_flags;+  }++  grpc_closure *recv_initial_metadata_ready() const {+    return op_->recv_initial_metadata_ready;+  }+  void set_recv_initial_metadata_ready(grpc_closure *closure) {+    op_->recv_initial_metadata_ready = closure;+  }++  grpc_byte_stream *send_message() const { return op_->send_message; }+  void set_send_message(grpc_byte_stream *send_message) {+    op_->send_message = send_message;+  }++  // To be called only on clients and servers, respectively.+  grpc_client_security_context *client_security_context() const {+    return (grpc_client_security_context *)op_->context[GRPC_CONTEXT_SECURITY]+        .value;+  }+  grpc_server_security_context *server_security_context() const {+    return (grpc_server_security_context *)op_->context[GRPC_CONTEXT_SECURITY]+        .value;+  }++  census_context *get_census_context() const {+    return (census_context *)op_->context[GRPC_CONTEXT_TRACING].value;+  }++ private:+  grpc_transport_stream_op *op_;  // Not owned.+  MetadataBatch send_initial_metadata_;+  MetadataBatch send_trailing_metadata_;+  MetadataBatch recv_initial_metadata_;+  MetadataBatch recv_trailing_metadata_;+};++/// Represents channel data.+class ChannelData {+ public:+  virtual ~ChannelData() {+    if (peer_) gpr_free((void *)peer_);+  }++  // Caller does NOT take ownership of result.+  const char *peer() const { return peer_; }++  // TODO(roth): Find a way to avoid passing elem into these methods.+  virtual void StartTransportOp(grpc_exec_ctx *exec_ctx,+                                grpc_channel_element *elem, TransportOp *op);++ protected:+  /// Takes ownership of \a peer.+  ChannelData(const grpc_channel_args &args, const char *peer) : peer_(peer) {}++ private:+  const char *peer_;+};++/// Represents call data.+class CallData {+ public:+  virtual ~CallData() {}++  virtual grpc_error *Init() { return GRPC_ERROR_NONE; }++  // TODO(roth): Find a way to avoid passing elem into these methods.++  virtual void StartTransportStreamOp(grpc_exec_ctx *exec_ctx,+                                      grpc_call_element *elem,+                                      TransportStreamOp *op);++  virtual void SetPollsetOrPollsetSet(grpc_exec_ctx *exec_ctx,+                                      grpc_call_element *elem,+                                      grpc_polling_entity *pollent);++  virtual char *GetPeer(grpc_exec_ctx *exec_ctx, grpc_call_element *elem);++ protected:+  explicit CallData(const ChannelData &) {}+};++namespace internal {++// Defines static members for passing to C core.+template <typename ChannelDataType, typename CallDataType>+class ChannelFilter GRPC_FINAL {+ public:+  static const size_t channel_data_size = sizeof(ChannelDataType);+",Added a comment saying that the members of this class correspond to those of the C grpc_channel_filter struct.,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7538,72724827,2016-07-29T00:06:27Z,src/python/grpcio/grpc/_cython/_cygrpc/call.pyx.pxi,"@@ -106,6 +107,8 @@ cdef class Call:   def __dealloc__(self):     if self.c_call != NULL:       grpc_call_destroy(self.c_call)+    grpc_shutdown()","Interesting...I just looked at the code here https://github.com/grpc/grpc/blob/master/src/core/lib/surface/init.cI'm guessing that if this approach ""solves"" memory leaks that were present because of PyPy garbage collection, it is only working because g_initializations == 0 never occurs after this change.  In which case, we could accomplish the same thing by just never calling `grpc_shutdown()`.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6924,72734245,2016-07-29T02:22:08Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle+ * state, \a query_for_backends() is called. It creates an instance of \a+ * lb_client_data, an internal struct meant to contain the data associated with+ * the internal communication with the LB server. This instance is created via+ * \a lb_client_data_create(). There, the call over lb_channel to pick-first+ * from {a1..an} is created, the \a LoadBalancingRequest message is assembled+ * and all necessary callbacks for the progress of the internal call configured.+ *+ * Back in \a query_for_backends(), the internal *streaming* call to the LB+ * server (whichever address from {a1..an} pick-first chose) is kicked off.+ * It'll progress over the callbacks configured in \a lb_client_data_create()+ * (see the field docstrings of \a lb_client_data for more details).+ *+ * If the call fails with UNIMPLEMENTED, the original call will also fail.+ * There's a misconfiguration somewhere: at least one of {a1..an} isn't a LB+ * server, which contradicts the LB bit being set. If the internal call times+ * out, the usual behavior of pick-first applies, continuing to pick from the+ * list {a1..an}.+ *+ * Upon sucesss, a \a LoadBalancingResponse is expected in \a res_rcvd_cb. An+ * invalid one results in the termination of the streaming call. A new streaming+ * call should be created if possible, failing the original call otherwise.+ * For a valid \a LoadBalancingResponse, the server list of actual backends is+ * extracted. A Round Robin policy will be created from this list. There are two+ * possible scenarios:+ *+ * 1. This is the first server list received. There was no previous instance of+ *    the Round Robin policy. \a rr_handover() will instantiate the RR policy+ *    and perform all the pending operations over it.+ * 2. There's already a RR policy instance active. We need to introduce the new+ *    one build from the new serverlist, but taking care not to disrupt the+ *    operations in progress over the old RR instance. This is done by+ *    decreasing the reference count on the old policy. The moment no more+ *    references are held on the old RR policy, it'll be destroyed and \a+ *    rr_connectivity_changed notified with a \a GRPC_CHANNEL_SHUTDOWN state.+ *    At this point we can transition to a new RR instance safely, which is done+ *    once again via \a rr_handover().+ *+ *+ * Once a RR policy instance is in place (and getting updated as described),+ * calls to for a pick, a ping or a cancellation will be serviced right away by+ * forwarding them to the RR instance. Any time there's no RR policy available+ * (ie, right after the creation of the gRPCLB policy, if an empty serverlist+ * is received, etc), pick/ping requests are added to a list of pending+ * picks/pings to be flushed and serviced as part of \a rr_handover() the moment+ * the RR policy instance becomes available.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md for the+ * high level design and details. */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).+ */++#include <string.h>++#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/client_channel_factory.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/parse_address.h""+#include ""src/core/ext/lb_policy/grpclb/grpclb.h""+#include ""src/core/ext/lb_policy/grpclb/load_balancer_api.h""+#include ""src/core/lib/iomgr/sockaddr_utils.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/call.h""+#include ""src/core/lib/surface/channel.h""++int grpc_lb_glb_trace = 0;++typedef struct wrapped_rr_closure_arg {+  /* the original closure. Usually a on_complete/notify cb for pick() and ping()+   * calls against the internal RR instance, respectively. */+  grpc_closure *wrapped_closure;++  /* The RR instance related to the closure */+  grpc_lb_policy *rr_policy;++  /* when not NULL, represents a pending_{pick,ping} node to be freed upon+   * closure execution */+  void *owning_pending_node; /* to be freed if not NULL */+} wrapped_rr_closure_arg;++/* The \a on_complete closure passed as part of the pick requires keeping a+ * reference to its associated round robin instance. We wrap this closure in+ * order to unref the round robin instance upon its invocation */+static void wrapped_rr_closure(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  wrapped_rr_closure_arg *wc_arg = arg;+  if (wc_arg->rr_policy != NULL) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Unreffing RR (0x%"" PRIxPTR "")"",+              (intptr_t)wc_arg->rr_policy);+    }+    GRPC_LB_POLICY_UNREF(exec_ctx, wc_arg->rr_policy, ""wrapped_rr_closure"");+  }+  GPR_ASSERT(wc_arg->wrapped_closure != NULL);+  grpc_exec_ctx_sched(exec_ctx, wc_arg->wrapped_closure, error, NULL);+  gpr_free(wc_arg->owning_pending_node);+}++/* Linked list of pending pick requests. It stores all information needed to+ * eventually call (Round Robin's) pick() on them. They mainly stay pending+ * waiting for the RR policy to be created/updated.+ *+ * One particularity is the wrapping of the user-provided \a on_complete closure+ * (in \a wrapped_on_complete and \a wrapped_on_complete_arg). This is needed in+ * order to correctly unref the RR policy instance upon completion of the pick.+ * See \a wrapped_rr_closure for details. */+typedef struct pending_pick {+  struct pending_pick *next;++  /* polling entity for the pick()'s async notification */+  grpc_polling_entity *pollent;++  /* the initial metadata for the pick. See grpc_lb_policy_pick() */+  grpc_metadata_batch *initial_metadata;++  /* bitmask passed to pick() and used for selective cancelling. See+   * grpc_lb_policy_cancel_picks() */+  uint32_t initial_metadata_flags;++  /* output argument where to store the pick()ed connected subchannel, or NULL+   * upon error. */+  grpc_connected_subchannel **target;++  /* a closure wrapping the original on_complete one to be invoked once the+   * pick() has completed (regardless of success) */+  grpc_closure wrapped_on_complete;++  /* args for wrapped_on_complete */+  wrapped_rr_closure_arg wrapped_on_complete_arg;+} pending_pick;++/* Same as the \a pending_pick struct but for ping operations */+typedef struct pending_ping {+  struct pending_ping *next;++  /* a closure wrapping the original on_complete one to be invoked once the+   * ping() has completed (regardless of success) */+  grpc_closure wrapped_notify;++  /* args for wrapped_notify */+  wrapped_rr_closure_arg wrapped_notify_arg;+} pending_ping;++typedef struct glb_lb_policy glb_lb_policy;++/* Used internally for the client call to the LB */+typedef struct lb_client_data {+  gpr_mu mu;++  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once initial metadata's been received */+  grpc_closure md_rcvd;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;++  /* After the client has sent a close to the LB server */+  grpc_closure close_sent;++  /* ... and the status from the LB server has been received */+  grpc_closure srv_status_rcvd;++  grpc_call *lb_call;    /* streaming call to the LB server, */+  gpr_timespec deadline; /* for the streaming call to the LB server */++  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */+  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */++  /* what's being sent to the LB server. Note that its value may vary if the LB+   * server indicates a redirect. */+  grpc_byte_buffer *request_payload;++  /* response from the LB server, if any. Processed in res_rcvd_cb() */+  grpc_byte_buffer *response_payload;++  /* the call's status and status detailset in srv_status_rcvd_cb() */+  grpc_status_code status;+  char *status_details;+  size_t status_details_capacity;++  /* pointer back to the enclosing policy */+  glb_lb_policy *p;+} lb_client_data;++/* Keeps track and reacts to changes in connectivity of the RR instance */+typedef struct rr_connectivity_data {+  grpc_closure on_change;+  grpc_connectivity_state state;+  glb_lb_policy *p;+} rr_connectivity_data;++struct glb_lb_policy {+  /** base policy: must be first */+  grpc_lb_policy base;++  /** mutex protecting remaining members */+  gpr_mu mu;++  grpc_client_channel_factory *cc_factory;++  /** for communicating with the LB server */+  grpc_channel *lb_channel;++  /** the RR policy to use of the backend servers returned by the LB server */+  grpc_lb_policy *rr_policy;++  bool started_picking;++  /** our connectivity state tracker */+  grpc_connectivity_state_tracker state_tracker;++  /** stores the deserialized response from the LB. May be NULL until one such+   * response has arrived. */+  grpc_grpclb_serverlist *serverlist;++  /** list of picks that are waiting on RR's policy connectivity */+  pending_pick *pending_picks;++  /** list of pings that are waiting on RR's policy connectivity */+  pending_ping *pending_pings;++  /** client data associated with the LB server communication */+  lb_client_data *lbcd;++  /** for tracking of the RR connectivity */+  rr_connectivity_data *rr_connectivity;++  /* a wrapped (see ...) on-complete closure for readily available RR picks */+  grpc_closure wrapped_on_complete;++  /* arguments for the wrapped_on_complete closure */+  wrapped_rr_closure_arg wc_arg;+};++static void rr_handover(grpc_exec_ctx *exec_ctx, glb_lb_policy *p,+                        grpc_error *error);+static void rr_connectivity_changed(grpc_exec_ctx *exec_ctx, void *arg,+                                    grpc_error *error) {+  rr_connectivity_data *rrcd = arg;+  glb_lb_policy *p = rrcd->p;+  if (rrcd->state == GRPC_CHANNEL_SHUTDOWN) {+    if (p->serverlist != NULL) {+      /* a RR policy is shutting down but there's a serverlist available ->+       * perform a handover */+      rr_handover(exec_ctx, p, error);+    } else {+      /* shutting down and no new serverlist available. Bail out. */+      gpr_free(rrcd);+    }+  } else {+    if (error == GRPC_ERROR_NONE) {+      /* RR not shutting down. Mimic the RR's policy state */+      grpc_connectivity_state_set(exec_ctx, &p->state_tracker, rrcd->state,+                                  error, ""rr_connectivity_changed"");+      /* resubscribe */+      grpc_lb_policy_notify_on_state_change(exec_ctx, p->rr_policy,+                                            &rrcd->state, &rrcd->on_change);+    } else { /* error */+      gpr_free(rrcd);+    }+  }+  GRPC_ERROR_UNREF(error);+}++static void add_pending_pick(pending_pick **root, grpc_polling_entity *pollent,+                             grpc_metadata_batch *initial_metadata,+                             uint32_t initial_metadata_flags,+                             grpc_connected_subchannel **target,+                             grpc_closure *on_complete) {+  pending_pick *pp = gpr_malloc(sizeof(*pp));+  memset(pp, 0, sizeof(pending_pick));+  memset(&pp->wrapped_on_complete_arg, 0, sizeof(wrapped_rr_closure_arg));+  pp->next = *root;+  pp->pollent = pollent;+  pp->target = target;+  pp->initial_metadata = initial_metadata;+  pp->initial_metadata_flags = initial_metadata_flags;+  pp->wrapped_on_complete_arg.wrapped_closure = on_complete;+  grpc_closure_init(&pp->wrapped_on_complete, wrapped_rr_closure,+                    &pp->wrapped_on_complete_arg);+  *root = pp;+}++static void add_pending_ping(pending_ping **root, grpc_closure *notify) {+  pending_ping *pping = gpr_malloc(sizeof(*pping));+  memset(pping, 0, sizeof(pending_ping));+  memset(&pping->wrapped_notify_arg, 0, sizeof(wrapped_rr_closure_arg));+  pping->next = *root;+  grpc_closure_init(&pping->wrapped_notify, wrapped_rr_closure,+                    &pping->wrapped_notify_arg);+  pping->wrapped_notify_arg.wrapped_closure = notify;+  *root = pping;+}++static void lb_client_data_destroy(lb_client_data *lbcd);++static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  lb_client_data *lbcd = arg;+  GPR_ASSERT(lbcd->lb_call);+  grpc_call_error call_error;",yeah... this is a testament to how long this has been under development. We couldn't do that when all the core was C89.Fixed in some obvious places. I'm sure there are still some others that could be declared-initialized in C99 style.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6924,72734285,2016-07-29T02:22:52Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -0,0 +1,1003 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/** Implementation of the gRPC LB policy.+ *+ * This policy takes as input a set of resolved addresses {a1..an} for which the+ * LB set was set (it's the resolver's responsibility to ensure this). That is+ * to say, {a1..an} represent a collection of LB servers.+ *+ * An internal channel (\a glb_lb_policy.lb_channel) is created over {a1..an}.+ * This channel behaves just like a regular channel. In particular, the+ * constructed URI over the addresses a1..an will use the default pick first+ * policy to select from this list of LB server backends.+ *+ * The first time the policy is requested a pick, a ping or to exit the idle+ * state, \a query_for_backends() is called. It creates an instance of \a+ * lb_client_data, an internal struct meant to contain the data associated with+ * the internal communication with the LB server. This instance is created via+ * \a lb_client_data_create(). There, the call over lb_channel to pick-first+ * from {a1..an} is created, the \a LoadBalancingRequest message is assembled+ * and all necessary callbacks for the progress of the internal call configured.+ *+ * Back in \a query_for_backends(), the internal *streaming* call to the LB+ * server (whichever address from {a1..an} pick-first chose) is kicked off.+ * It'll progress over the callbacks configured in \a lb_client_data_create()+ * (see the field docstrings of \a lb_client_data for more details).+ *+ * If the call fails with UNIMPLEMENTED, the original call will also fail.+ * There's a misconfiguration somewhere: at least one of {a1..an} isn't a LB+ * server, which contradicts the LB bit being set. If the internal call times+ * out, the usual behavior of pick-first applies, continuing to pick from the+ * list {a1..an}.+ *+ * Upon sucesss, a \a LoadBalancingResponse is expected in \a res_rcvd_cb. An+ * invalid one results in the termination of the streaming call. A new streaming+ * call should be created if possible, failing the original call otherwise.+ * For a valid \a LoadBalancingResponse, the server list of actual backends is+ * extracted. A Round Robin policy will be created from this list. There are two+ * possible scenarios:+ *+ * 1. This is the first server list received. There was no previous instance of+ *    the Round Robin policy. \a rr_handover() will instantiate the RR policy+ *    and perform all the pending operations over it.+ * 2. There's already a RR policy instance active. We need to introduce the new+ *    one build from the new serverlist, but taking care not to disrupt the+ *    operations in progress over the old RR instance. This is done by+ *    decreasing the reference count on the old policy. The moment no more+ *    references are held on the old RR policy, it'll be destroyed and \a+ *    rr_connectivity_changed notified with a \a GRPC_CHANNEL_SHUTDOWN state.+ *    At this point we can transition to a new RR instance safely, which is done+ *    once again via \a rr_handover().+ *+ *+ * Once a RR policy instance is in place (and getting updated as described),+ * calls to for a pick, a ping or a cancellation will be serviced right away by+ * forwarding them to the RR instance. Any time there's no RR policy available+ * (ie, right after the creation of the gRPCLB policy, if an empty serverlist+ * is received, etc), pick/ping requests are added to a list of pending+ * picks/pings to be flushed and serviced as part of \a rr_handover() the moment+ * the RR policy instance becomes available.+ *+ * \see https://github.com/grpc/grpc/blob/master/doc/load-balancing.md for the+ * high level design and details. */++/* TODO(dgq):+ * - Implement LB service forwarding (point 2c. in the doc's diagram).+ */++#include <string.h>++#include <grpc/byte_buffer_reader.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/client_channel_factory.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/parse_address.h""+#include ""src/core/ext/lb_policy/grpclb/grpclb.h""+#include ""src/core/ext/lb_policy/grpclb/load_balancer_api.h""+#include ""src/core/lib/iomgr/sockaddr_utils.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/surface/call.h""+#include ""src/core/lib/surface/channel.h""++int grpc_lb_glb_trace = 0;++typedef struct wrapped_rr_closure_arg {+  /* the original closure. Usually a on_complete/notify cb for pick() and ping()+   * calls against the internal RR instance, respectively. */+  grpc_closure *wrapped_closure;++  /* The RR instance related to the closure */+  grpc_lb_policy *rr_policy;++  /* when not NULL, represents a pending_{pick,ping} node to be freed upon+   * closure execution */+  void *owning_pending_node; /* to be freed if not NULL */+} wrapped_rr_closure_arg;++/* The \a on_complete closure passed as part of the pick requires keeping a+ * reference to its associated round robin instance. We wrap this closure in+ * order to unref the round robin instance upon its invocation */+static void wrapped_rr_closure(grpc_exec_ctx *exec_ctx, void *arg,+                               grpc_error *error) {+  wrapped_rr_closure_arg *wc_arg = arg;+  if (wc_arg->rr_policy != NULL) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Unreffing RR (0x%"" PRIxPTR "")"",+              (intptr_t)wc_arg->rr_policy);+    }+    GRPC_LB_POLICY_UNREF(exec_ctx, wc_arg->rr_policy, ""wrapped_rr_closure"");+  }+  GPR_ASSERT(wc_arg->wrapped_closure != NULL);+  grpc_exec_ctx_sched(exec_ctx, wc_arg->wrapped_closure, error, NULL);+  gpr_free(wc_arg->owning_pending_node);+}++/* Linked list of pending pick requests. It stores all information needed to+ * eventually call (Round Robin's) pick() on them. They mainly stay pending+ * waiting for the RR policy to be created/updated.+ *+ * One particularity is the wrapping of the user-provided \a on_complete closure+ * (in \a wrapped_on_complete and \a wrapped_on_complete_arg). This is needed in+ * order to correctly unref the RR policy instance upon completion of the pick.+ * See \a wrapped_rr_closure for details. */+typedef struct pending_pick {+  struct pending_pick *next;++  /* polling entity for the pick()'s async notification */+  grpc_polling_entity *pollent;++  /* the initial metadata for the pick. See grpc_lb_policy_pick() */+  grpc_metadata_batch *initial_metadata;++  /* bitmask passed to pick() and used for selective cancelling. See+   * grpc_lb_policy_cancel_picks() */+  uint32_t initial_metadata_flags;++  /* output argument where to store the pick()ed connected subchannel, or NULL+   * upon error. */+  grpc_connected_subchannel **target;++  /* a closure wrapping the original on_complete one to be invoked once the+   * pick() has completed (regardless of success) */+  grpc_closure wrapped_on_complete;++  /* args for wrapped_on_complete */+  wrapped_rr_closure_arg wrapped_on_complete_arg;+} pending_pick;++/* Same as the \a pending_pick struct but for ping operations */+typedef struct pending_ping {+  struct pending_ping *next;++  /* a closure wrapping the original on_complete one to be invoked once the+   * ping() has completed (regardless of success) */+  grpc_closure wrapped_notify;++  /* args for wrapped_notify */+  wrapped_rr_closure_arg wrapped_notify_arg;+} pending_ping;++typedef struct glb_lb_policy glb_lb_policy;++/* Used internally for the client call to the LB */+typedef struct lb_client_data {+  gpr_mu mu;++  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once initial metadata's been received */+  grpc_closure md_rcvd;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;++  /* After the client has sent a close to the LB server */+  grpc_closure close_sent;++  /* ... and the status from the LB server has been received */+  grpc_closure srv_status_rcvd;++  grpc_call *lb_call;    /* streaming call to the LB server, */+  gpr_timespec deadline; /* for the streaming call to the LB server */++  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */+  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */++  /* what's being sent to the LB server. Note that its value may vary if the LB+   * server indicates a redirect. */+  grpc_byte_buffer *request_payload;++  /* response from the LB server, if any. Processed in res_rcvd_cb() */+  grpc_byte_buffer *response_payload;++  /* the call's status and status detailset in srv_status_rcvd_cb() */+  grpc_status_code status;+  char *status_details;+  size_t status_details_capacity;++  /* pointer back to the enclosing policy */+  glb_lb_policy *p;","true... when there's a single author to a large chunk of code, one becomes used to one own's idiosyncrasies and these cryptic names still make sense (for a while! I've been bitten by no understanding my own crappy names hehe).Fixed, hopefully. ",
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/7566,72743842,2016-07-29T05:41:39Z,src/php/ext/grpc/server_credentials.c,"@@ -92,27 +93,91 @@ zval *grpc_php_wrap_server_credentials(grpc_server_credentials  */",Please update the comments as the parameters and types changed,
11674202,stanley-cheung,https://api.github.com/repos/grpc/grpc/pulls/7566,72747271,2016-07-29T06:36:00Z,src/php/tests/unit_tests/ServerCredentialsTest.php,"@@ -0,0 +1,130 @@+<?php+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+class ServerCredentialsTest extends PHPUnit_Framework_TestCase+{+    public function setUp()+    {+        $this->ca_data =+            file_get_contents(dirname(__FILE__).'/../data/ca.pem');+        $this->key_data =+            file_get_contents(dirname(__FILE__).'/../data/server1.key');+        $this->pem_data =+            file_get_contents(dirname(__FILE__).'/../data/server1.pem');+    }++    public function tearDown()+    {+    }++    public function testCreateSsl()+    {+        // accepts a string and array+        $server_creds = Grpc\ServerCredentials::createSsl($this->ca_data,",Should we separate these out into different testXXX methods? They should be as independent from each other as possible,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/6924,72864397,2016-07-29T21:35:06Z,test/cpp/grpclb/grpclb_test.cc,"@@ -0,0 +1,688 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <cstdarg>+#include <cstring>+#include <string>+#include <cstdint>+#include <cinttypes>++extern ""C"" {+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>+#include <grpc/support/sync.h>+#include <grpc/support/thd.h>+#include <grpc/support/time.h>++#include ""src/core/ext/client_config/client_channel.h""+#include ""src/core/lib/channel/channel_stack.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/support/tmpfile.h""+#include ""src/core/lib/surface/channel.h""+#include ""src/core/lib/surface/server.h""+#include ""test/core/end2end/cq_verifier.h""+#include ""test/core/util/port.h""+#include ""test/core/util/test_config.h""+}++#include ""src/proto/grpc/lb/v1/load_balancer.pb.h""++#define NUM_BACKENDS 4++// TODO(dgq): Other scenarios in need of testing:+// - Send an empty serverlist update and verify that the client request blocks+//   until a new serverlist with actual contents is available.+// - Send identical serverlist update+// - Test reception of invalid serverlist+// - Test pinging+// - Test against a non-LB server. That server should return UNIMPLEMENTED and+//   the call should fail.+// - Random LB server closing the stream unexpectedly.++namespace grpc {+namespace {++typedef struct client_fixture {+  grpc_channel *client;+  char *server_uri;+  grpc_completion_queue *cq;+} client_fixture;++typedef struct server_fixture {+  grpc_server *server;+  grpc_call *server_call;+  grpc_completion_queue *cq;+  char *servers_hostport;+  int port;+  gpr_thd_id tid;+  int num_calls_serviced;+} server_fixture;++typedef struct test_fixture {+  server_fixture lb_server;+  server_fixture lb_backends[NUM_BACKENDS];+  client_fixture client;+  int lb_server_update_delay_ms;+} test_fixture;++static gpr_timespec n_seconds_time(int n) {+  return GRPC_TIMEOUT_SECONDS_TO_DEADLINE(n);",Because copy-pasted at an early stage when brain-cache capacity is at a premium.Fixed.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7580,72893027,2016-07-30T19:36:13Z,tools/run_tests/build_csharp_coreclr.sh,"@@ -35,4 +35,4 @@ cd $(dirname $0)/../../src/csharp # TODO(jtattermusch): introduce caching dotnet restore . -dotnet build -f netstandard1.5 --configuration $MSBUILD_CONFIG '**/project.json'","Unfortunately, yes.   This command should be is ""build all projects for coreCLR"", that used to be simple because all coreCLR targets used to be netstandard1.5. Now some of them are netcoreapp1.0 (executables) and some of them are netstandard1.5 (libraries). And I didn't want to manually list all projects because that is error prone.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7580,72895132,2016-07-30T22:30:36Z,templates/src/csharp/Grpc.Core.Tests/project.json.template,"@@ -12,12 +12,13 @@     },     ""frameworks"": {       ""net45"": { },-      ""netstandard1.5"": {+      ""netcoreapp1.0"": {         ""imports"": [           ""portable-net45""         ],         ""dependencies"": {-          ""NETStandard.Library"": ""1.5.0-rc2-24027""+          ""Microsoft.NETCore.App"": ""1.0.0"",+          ""NETStandard.Library"": ""1.6.0""","just a last couple things, since Microsoft.NETCore.App brings it in, I think we can drop the NETStandard.Library dependency?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7580,72895784,2016-07-30T23:46:29Z,templates/src/csharp/Grpc.Core.Tests/project.json.template,"@@ -12,12 +12,13 @@     },     ""frameworks"": {       ""net45"": { },-      ""netstandard1.5"": {+      ""netcoreapp1.0"": {         ""imports"": [           ""portable-net45""         ],         ""dependencies"": {-          ""NETStandard.Library"": ""1.5.0-rc2-24027""+          ""Microsoft.NETCore.App"": ""1.0.0"",+          ""NETStandard.Library"": ""1.6.0""","*on second thought, I still think that this NETStandard.Library dependency is now a noop, but it should be forced to be updated to whatever version the Grpc.Core and Microsoft.NETCore.App are using anyways...",
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,72924623,2016-08-01T05:07:21Z,build.yaml,"@@ -1021,6 +1029,7 @@ libs:   - grpc++_codegen_base_src   - grpc++_codegen_proto   - grpc++_config_proto+  - thrift_util",open for suggestions to include thrift to dependency tree,
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,72925609,2016-08-01T05:31:02Z,build.yaml,"@@ -1021,6 +1029,7 @@ libs:   - grpc++_codegen_base_src   - grpc++_codegen_proto   - grpc++_config_proto+  - thrift_util","So far, there are no tests for thrift. This dependency on thrift will not effect any C/C++ builds as long as these files thrift_utils.h , thrift_serializer.h , thrift_serializer_inl.h are present in include/grpc++/impl/codegen.  There are cpp examples which can be used to test the integration. install thrift from third_party/thrift and run example in tutorial/cpp.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,72930610,2016-08-01T06:53:10Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,148 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++ #ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+ #define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <memory>+#include <string>++#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <grpc/impl/codegen/byte_buffer.h>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;+using std::shared_ptr;+++template <typename Dummy, typename P>+class ThriftSerializer {+public:+  ThriftSerializer()+  : prepared_ (false)+  , lastDeserialized_ (false)+  , serializeVersion_ (false) {}++  /**+   * Serialize the passed type into the internal buffer+   * and returns a pointer to internal buffer and its size+   *+   */+  template <typename T>+  void serialize(const T& fields, const uint8_t** serializedBuffer,+      size_t* serializedLen);++  /**+   * Serialize the passed type into the byte buffer+   */+  template <typename T>+  void serialize(const T& fields, grpc_byte_buffer** bp);++  /**+   * Deserialize the passed char array into  the passed type, returns the number+   * of bytes that have been consumed from the passed string.+   */+  template <typename T>+  uint32_t deserialize(const uint8_t* serializedBuffer, size_t length,+      T* fields);++  /**+   * Deserialize the passed byte buffer to passed type, returns the number+   * of bytes consumed from byte buffer+   */+  template <typename T>+  uint32_t deserialize(grpc_byte_buffer* buffer, T* msg);++  void setSerializeVersion(bool value);++  virtual ~ThriftSerializer() {}+++  /**+   * Set the container size limit to deserialize+   * This function should be called after buffer_ is initialized+   */+  void setContainerSizeLimit(int32_t container_limit) {+    if (!prepared_) {+      prepare();+    }+    protocol_->setContainerSizeLimit(container_limit);+  }++  /**+   * Set the string size limit to deserialize+   * This function should be called after buffer_ is initialized+   */+  void setStringSizeLimit(int32_t string_limit) {+    if (!prepared_) {+      prepare();+    }+    protocol_->setStringSizeLimit(string_limit);+  }+++  private:+    void prepare();++  private:+    typedef P Protocol;+    bool prepared_;+    bool lastDeserialized_;+    boost::shared_ptr<TMemoryBuffer> buffer_;+    shared_ptr<Protocol> protocol_;+    bool serializeVersion_;+}; // ThriftSerializer++template <typename Dummy = void>+struct ThriftSerializerBinary : public ThriftSerializer<Dummy, TBinaryProtocolT<TBufferBase, TNetworkBigEndian> > {};","A little confused here - why is this a template if it only exists fully-specialized, and why is this inheritance at all? Isn't this `typedef ThriftSerializer<void, TBinaryProtocolT<TBufferBase, TNetworkBigEndian>> ThriftSerializerBinary;` ? That also allows you to mark the template above as GRPC_FINAL and not use any virtual destructor.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,72930872,2016-08-01T06:56:31Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,148 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++ #ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+ #define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <memory>+#include <string>++#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <grpc/impl/codegen/byte_buffer.h>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;+using std::shared_ptr;+++template <typename Dummy, typename P>+class ThriftSerializer {+public:+  ThriftSerializer()+  : prepared_ (false)+  , lastDeserialized_ (false)+  , serializeVersion_ (false) {}++  /**+   * Serialize the passed type into the internal buffer+   * and returns a pointer to internal buffer and its size+   *+   */+  template <typename T>+  void serialize(const T& fields, const uint8_t** serializedBuffer,+      size_t* serializedLen);++  /**+   * Serialize the passed type into the byte buffer+   */+  template <typename T>+  void serialize(const T& fields, grpc_byte_buffer** bp);++  /**+   * Deserialize the passed char array into  the passed type, returns the number+   * of bytes that have been consumed from the passed string.+   */+  template <typename T>+  uint32_t deserialize(const uint8_t* serializedBuffer, size_t length,+      T* fields);++  /**+   * Deserialize the passed byte buffer to passed type, returns the number+   * of bytes consumed from byte buffer+   */+  template <typename T>+  uint32_t deserialize(grpc_byte_buffer* buffer, T* msg);++  void setSerializeVersion(bool value);++  virtual ~ThriftSerializer() {}+++  /**+   * Set the container size limit to deserialize+   * This function should be called after buffer_ is initialized+   */+  void setContainerSizeLimit(int32_t container_limit) {+    if (!prepared_) {+      prepare();+    }+    protocol_->setContainerSizeLimit(container_limit);+  }++  /**+   * Set the string size limit to deserialize+   * This function should be called after buffer_ is initialized+   */+  void setStringSizeLimit(int32_t string_limit) {+    if (!prepared_) {+      prepare();+    }+    protocol_->setStringSizeLimit(string_limit);+  }+++  private:+    void prepare();++  private:+    typedef P Protocol;+    bool prepared_;+    bool lastDeserialized_;+    boost::shared_ptr<TMemoryBuffer> buffer_;+    shared_ptr<Protocol> protocol_;+    bool serializeVersion_;+}; // ThriftSerializer++template <typename Dummy = void>+struct ThriftSerializerBinary : public ThriftSerializer<Dummy, TBinaryProtocolT<TBufferBase, TNetworkBigEndian> > {};+++template <typename Dummy = void>+struct ThriftSerializerCompact : public ThriftSerializer<Dummy, TCompactProtocolT<TBufferBase> >{ };++}}} // namespace apache::thrift::util++#include <grpc++/impl/codegen/thrift_serializer_inl.h>","Additionally, I question the reason for the existence of thrift_serializer_inl.h ; the file doesn't have that much content, and the content would become even less if it was actually integrated into the classes directly (no need to have repeated template declarations, etc).",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,72931050,2016-08-01T06:58:34Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,148 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++ #ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+ #define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <memory>+#include <string>++#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <grpc/impl/codegen/byte_buffer.h>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;+using std::shared_ptr;+++template <typename Dummy, typename P>+class ThriftSerializer {+public:+  ThriftSerializer()+  : prepared_ (false)+  , lastDeserialized_ (false)+  , serializeVersion_ (false) {}++  /**+   * Serialize the passed type into the internal buffer+   * and returns a pointer to internal buffer and its size+   *+   */+  template <typename T>+  void serialize(const T& fields, const uint8_t** serializedBuffer,+      size_t* serializedLen);++  /**+   * Serialize the passed type into the byte buffer+   */+  template <typename T>+  void serialize(const T& fields, grpc_byte_buffer** bp);++  /**+   * Deserialize the passed char array into  the passed type, returns the number+   * of bytes that have been consumed from the passed string.+   */+  template <typename T>+  uint32_t deserialize(const uint8_t* serializedBuffer, size_t length,+      T* fields);++  /**+   * Deserialize the passed byte buffer to passed type, returns the number+   * of bytes consumed from byte buffer+   */+  template <typename T>+  uint32_t deserialize(grpc_byte_buffer* buffer, T* msg);++  void setSerializeVersion(bool value);++  virtual ~ThriftSerializer() {}+++  /**+   * Set the container size limit to deserialize+   * This function should be called after buffer_ is initialized+   */+  void setContainerSizeLimit(int32_t container_limit) {+    if (!prepared_) {+      prepare();+    }+    protocol_->setContainerSizeLimit(container_limit);+  }++  /**+   * Set the string size limit to deserialize+   * This function should be called after buffer_ is initialized+   */+  void setStringSizeLimit(int32_t string_limit) {+    if (!prepared_) {+      prepare();+    }+    protocol_->setStringSizeLimit(string_limit);+  }+++  private:+    void prepare();++  private:+    typedef P Protocol;+    bool prepared_;+    bool lastDeserialized_;","C/C++ variable names should be snake_case (so, of course, class member variable names would be snake_case_) .",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,72931276,2016-08-01T07:01:37Z,include/grpc++/impl/codegen/thrift_serializer_inl.h,"@@ -0,0 +1,169 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++ #ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_INL_H+ #define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_INL_H+","After reading this, I'm more convinced that these should be integrated into the template declarations. This is far below the surface anyway, and it's a lot easier to understand the code integrated than having to scroll back and forth between the class and declarations like this.",
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/7448,73006682,2016-08-01T16:15:56Z,examples/objective-c/route_guide/RouteGuide.podspec,"@@ -60,4 +56,11 @@ Pod::Spec.new do |s|     ss.dependency ""gRPC-ProtoRPC""     ss.dependency ""#{s.name}/Messages""   end++  s.pod_target_xcconfig = {+    # This is needed by all pods that depend on Protobuf:+    'GCC_PREPROCESSOR_DEFINITIONS' => '$(inherited) GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS=1',+    # This is needed by all pods that depend on gRPC-RxLibrary:+    'CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES' => 'YES',","As we talked about last week, it is a bit strange if we require any customer who uses our library (like RouteGuide here) to include such a line :)  It LGTM as a temporary fix.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7554,73055635,2016-08-01T21:23:19Z,src/objective-c/tests/Podfile,"@@ -91,13 +82,23 @@ post_install do |installer|     target.build_configurations.each do |config|       config.build_settings['GCC_TREAT_WARNINGS_AS_ERRORS'] = 'YES'     end-    if target.name == 'gRPC-Core' or target.name == 'gRPC-Core.default-Cronet-Interface-Cronet-Tests'+    if target.name == 'gRPC-Core' or target.name == 'gRPC-Core.default-Cronet-Implementation-Cronet-Interface-Tests' or target.name == 'gRPC-Core.default-Cronet-Implementation'","Including the comment will prevent people from going: ""Huh? Do we have more than one pod that starts with gRPC-Core?"". Plus it'll help debug things if Cocoapods changes that naming in the future, by explaining what our intention was.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/7594,73229914,2016-08-02T20:23:41Z,tools/grift/grpc_plugins_generator.patch,"@@ -0,0 +1,2417 @@+From 0894590b5020c38106d4ebb2291994668c64f9dd Mon Sep 17 00:00:00 2001","I don't think this is a bad interim solution, yet ideally, we would submit them upstream. It would quickly become un-maintainable however if this isn't pushed upstream, that is.",
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,73231810,2016-08-02T20:34:52Z,tools/grift/grpc_plugins_generator.patch,"@@ -0,0 +1,2417 @@+From 0894590b5020c38106d4ebb2291994668c64f9dd Mon Sep 17 00:00:00 2001","I think we cant submit it to upstream. Maybe we can fork apache thrift togoogle/grift and apply these changes. grift will be the submodule.On Tue, Aug 2, 2016 at 1:24 PM, Nicolas Noble notifications@github.comwrote:> In tools/grift/grpc_plugins_generator.patch> https://github.com/grpc/grpc/pull/7594#discussion_r73229914:> > > @@ -0,0 +1,2417 @@> > +From 0894590b5020c38106d4ebb2291994668c64f9dd Mon Sep 17 00:00:00 2001> > I don't think this is a bad interim solution, yet ideally, we would submit> them upstream. It would quickly become un-maintainable however if this> isn't pushed upstream, that is.> > —> You are receiving this because you were mentioned.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7594/files/dd7a2a35e23042413c232ea9f00a4b7dbbce5648#r73229914,> or mute the thread> https://github.com/notifications/unsubscribe-auth/ASfuImYF97g5NVIdvBzHVvASY3R6zaAyks5qb6dhgaJpZM4JZPv_> .",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,73327050,2016-08-03T12:06:59Z,tools/grift/grpc_plugins_generator.patch,"@@ -0,0 +1,2417 @@+From 0894590b5020c38106d4ebb2291994668c64f9dd Mon Sep 17 00:00:00 2001","@nicolasnoble 's suggestion is the right approach : let's do the patch as an interim solution to get something usable and then figure out how to send it upstream after some time and use. I think Nico is trying to make sure that we can use this code longer term as thrift itself gets upgrades. Our team has upstreamed changes to other submodules in the past when it became useful to do so (e.g., google/protobuf#1692)",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,73327564,2016-08-03T12:11:15Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,217 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++ #ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+ #define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <memory>+#include <string>+#include <stdexcept>+#include <grpc/impl/codegen/byte_buffer.h>+#include <grpc/impl/codegen/byte_buffer_reader.h>+#include <grpc/impl/codegen/slice.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/protocol/TProtocolException.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TMessageType;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;++template <typename Dummy, typename Protocol> class ThriftSerializer {+public:+  ThriftSerializer()+      : prepared_ (false)+      , last_deserialized_ (false)+      , serialize_version_ (false) {}++  virtual ~ThriftSerializer() {}++  // Serialize the passed type into the internal buffer+  // and returns a pointer to internal buffer and its size+  template <typename T> void Serialize(const T& fields, const uint8_t** serializedBuffer,+      size_t* serializedLen) {+     // prepare or reset buffer+    if (!prepared_ || last_deserialized_) {+      prepare();+    } else {+      buffer_->resetBuffer();+    }+    last_deserialized_ = false;++    // if required serialize protocol version+    if (serialize_version_) {+      protocol_->writeMessageBegin("""", TMessageType(0), 0);+    }++    // serilaize fields into buffer+    fields.write(protocol_.get());++    // write the end of message+    if (serialize_version_) {+      protocol_->writeMessageEnd();+    }++    uint8_t* byteBuffer;+    uint32_t byteBufferSize;+    buffer_->getBuffer(&byteBuffer, &byteBufferSize);+    *serializedBuffer = byteBuffer;+    *serializedLen = byteBufferSize; +  }++  // Serialize the passed type into the byte buffer+  template <typename T> void Serialize(const T& fields, grpc_byte_buffer** bp) {++    const uint8_t* byteBuffer;+    size_t byteBufferSize;++    Serialize(fields, &byteBuffer, &byteBufferSize);++    gpr_slice slice = gpr_slice_from_copied_buffer((char*)byteBuffer,byteBufferSize);","`reinterpret_cast<char*>(byteBuffer)`. Of course, the snake_case rule applies to variables in functions also, not just class members, so `reinterpret_cast<char*>(byte_buffer)`",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7625,73386447,2016-08-03T18:00:57Z,src/python/grpcio_tests/tests/unit/_channel_connectivity_test.py,"@@ -32,12 +32,12 @@ import threading import time import unittest-from concurrent import futures  import grpc from grpc import _channel from grpc import _server from tests.unit.framework.common import test_constants+from tests.unit._thread_pool import RecordingThreadPool","[Import only packages and modules (mostly modules), not classes, functions, or other elements of modules.](https://google.github.io/styleguide/pyguide.html?showone=Imports#Imports)",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7625,73386919,2016-08-03T18:03:36Z,src/python/grpcio_tests/tests/unit/_thread_pool.py,"@@ -0,0 +1,47 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent import futures+++class RecordingThreadPool(futures.ThreadPoolExecutor):+  """"""+  Subclasses ThreadPoolExecutor and adds property to check if the pool was ever used","Both the opening and closing triple-quote should be on the single summary line (there's an example [here](https://google.github.io/styleguide/pyguide.html?showone=Comments#Comments)).Drop ""Subclasses ThreadPoolExecutor""; the list of a class' superclasses is already part of its user-facing API.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7625,73387726,2016-08-03T18:07:40Z,src/python/grpcio_tests/tests/unit/_thread_pool.py,"@@ -0,0 +1,47 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent import futures+++class RecordingThreadPool(futures.ThreadPoolExecutor):+  """"""+  Subclasses ThreadPoolExecutor and adds property to check if the pool was ever used+  """"""+  def __init__(self, max_workers):+    self._was_used = False+    super(RecordingThreadPool, self).__init__(max_workers)",The call to the superclass' constructor should always be the first executable statement of a subclass' constructor unless there's some thoroughly-commented reason for that not to be the case.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7625,73388375,2016-08-03T18:10:50Z,src/python/grpcio_tests/tests/unit/_thread_pool.py,"@@ -0,0 +1,47 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent import futures+++class RecordingThreadPool(futures.ThreadPoolExecutor):",I strongly suspect that this class should subclass `futures.Executor` and merely have a `futures.ThreadPoolExecutor` rather than subclass `futures.ThreadPoolExecutor`.,
6081171,thunderboltsid,https://api.github.com/repos/grpc/grpc/pulls/7625,73390383,2016-08-03T18:19:47Z,src/python/grpcio_tests/tests/unit/_thread_pool.py,"@@ -0,0 +1,47 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent import futures+++class RecordingThreadPool(futures.ThreadPoolExecutor):",Interesting. We want it to behave like a `futures.ThreadPoolExecutor` except for the added property.  Is there  a specific reasoning behind subclassing it form `futures.Executor` and not `futures.ThreadPoolExecutor`?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7625,73391298,2016-08-03T18:23:58Z,src/python/grpcio_tests/tests/unit/_thread_pool.py,"@@ -0,0 +1,47 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent import futures+++class RecordingThreadPool(futures.ThreadPoolExecutor):+  """"""+  Subclasses ThreadPoolExecutor and adds property to check if the pool was ever used+  """"""+  def __init__(self, max_workers):+    self._was_used = False+    super(RecordingThreadPool, self).__init__(max_workers)",It assures the reader/future maintainer that nothing going on in the subclass constructor is _required_ for superclass construction.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7625,73391845,2016-08-03T18:26:27Z,src/python/grpcio_tests/tests/unit/_thread_pool.py,"@@ -0,0 +1,47 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++from concurrent import futures+++class RecordingThreadPool(futures.ThreadPoolExecutor):","[Avoid implementation inheritance](https://www.youtube.com/watch?v=3MNVP9-hglc).Also consider that this subclass doesn't do all it claims to do because it doesn't override the `map` method inherited from `ThreadPoolExecutor`. Right now that's a silent defect, but by inheriting from the abstract class it becomes a module-load-time error.",
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/7475,73410175,2016-08-03T20:06:05Z,gRPC-ProtoRPC.podspec,"@@ -61,7 +61,7 @@ Pod::Spec.new do |s|    s.dependency 'gRPC', version   s.dependency 'gRPC-RxLibrary', version-  s.dependency 'Protobuf', '~> 3.0.0-beta-3.1'+  s.dependency 'Protobuf', '~> 3.0'",The template for this file seems no longer exists. Update the comments at the beginning of this file?,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7630,73439128,2016-08-03T23:20:47Z,examples/ruby/grpc-demo.gemspec,"@@ -3,7 +3,7 @@  Gem::Specification.new do |s|   s.name          = 'grpc-demo'-  s.version       = '0.11.0'","Since this is on the v1.0.x branch, we should probably update this version and the dependency to 1.0.0.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7633,73450156,2016-08-04T01:25:13Z,tools/run_tests/run_tests.py,"@@ -471,36 +471,38 @@ def _get_pythons(self, args):       bits = '32'     else:       bits = '64'+     if os.name == 'nt':       shell = ['bash']       builder = [os.path.abspath('tools/run_tests/build_python_msys2.sh')]       builder_prefix_arguments = ['MINGW{}'.format(bits)]       venv_relative_python = ['Scripts/python.exe']       toolchain = ['mingw32']-      python_pattern_function = lambda major, minor, bits: (-          '/c/Python{major}{minor}/python.exe'.format(major=major, minor=minor, bits=bits)-	  if bits == '64' else-	  '/c/Python{major}{minor}_{bits}bits/python.exe'.format(-              major=major, minor=minor, bits=bits))     else:       shell = []       builder = [os.path.abspath('tools/run_tests/build_python.sh')]       builder_prefix_arguments = []       venv_relative_python = ['bin/python']       toolchain = ['unix']-      # Bit-ness is handled by the test machine's environment-      python_pattern_function = lambda major, minor, bits: 'python{major}.{minor}'.format(major=major, minor=minor)+     runner = [os.path.abspath('tools/run_tests/run_python.sh')]-    python_config_generator = lambda name, major, minor, bits: PythonConfig(-        name,-        shell + builder + builder_prefix_arguments-	    + [python_pattern_function(major=major, minor=minor, bits=bits)]-	    + [name] + venv_relative_python + toolchain,-        shell + runner + [os.path.join(name, venv_relative_python[0])])-    python27_config = python_config_generator(name='py27', major='2', minor='7', bits=bits)-    python34_config = python_config_generator(name='py34', major='3', minor='4', bits=bits)-    python35_config = python_config_generator(name='py35', major='3', minor='5', bits=bits)-    python36_config = python_config_generator(name='py36', major='3', minor='6', bits=bits)++    config_args = {",Why not use `collections.namedtuple` to define a private helper class for joining together these fellow-traveling values?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,73456787,2016-08-04T03:13:12Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,223 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+#define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <grpc/impl/codegen/byte_buffer.h>+#include <grpc/impl/codegen/byte_buffer_reader.h>+#include <grpc/impl/codegen/slice.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/protocol/TProtocolException.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <boost/make_shared.hpp>+#include <memory>+#include <stdexcept>+#include <string>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TMessageType;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;++template <typename Dummy, typename Protocol>+class ThriftSerializer {+ public:+  ThriftSerializer()+      : prepared_(false),+        last_deserialized_(false),+        serialize_version_(false) {}++  virtual ~ThriftSerializer() {}++  // Serialize the passed type into the internal buffer+  // and returns a pointer to internal buffer and its size+  template <typename T>+  void Serialize(const T& fields, const uint8_t** serialized_buffer,+                 size_t* serialized_len) {+    // prepare or reset buffer+    if (!prepared_ || last_deserialized_) {+      prepare();+    } else {+      buffer_->resetBuffer();+    }+    last_deserialized_ = false;++    // if required serialize protocol version+    if (serialize_version_) {+      protocol_->writeMessageBegin("""", TMessageType(0), 0);+    }++    // serialize fields into buffer+    fields.write(protocol_.get());++    // write the end of message+    if (serialize_version_) {+      protocol_->writeMessageEnd();+    }++    uint8_t* byte_buffer;+    uint32_t byte_buffer_size;+    buffer_->getBuffer(&byte_buffer, &byte_buffer_size);+    *serialized_buffer = byte_buffer;+    *serialized_len = byte_buffer_size;+  }++  // Serialize the passed type into the byte buffer+  template <typename T>+  void Serialize(const T& fields, grpc_byte_buffer** bp) {+    const uint8_t* byte_buffer;+    size_t byte_buffer_size;++    Serialize(fields, &byte_buffer, &byte_buffer_size);++    gpr_slice slice =+        gpr_slice_from_copied_buffer((char*)byte_buffer, byte_buffer_size);","You need to use back-quotes around code expressions in Markdown. Additionally, you can't reinterpret away const. So, it should be `reinterpret_cast<const char *>(byte_buffer)`. FWIW, that's a benefit of C++ casts is that it prevents us from accidentally casting away the wrong characteristic. It's why we should switch to them everywhere.",
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,73460228,2016-08-04T04:17:25Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,223 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+#define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <grpc/impl/codegen/byte_buffer.h>+#include <grpc/impl/codegen/byte_buffer_reader.h>+#include <grpc/impl/codegen/slice.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/protocol/TProtocolException.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <boost/make_shared.hpp>+#include <memory>+#include <stdexcept>+#include <string>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TMessageType;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;++template <typename Dummy, typename Protocol>+class ThriftSerializer {+ public:+  ThriftSerializer()+      : prepared_(false),+        last_deserialized_(false),+        serialize_version_(false) {}++  virtual ~ThriftSerializer() {}++  // Serialize the passed type into the internal buffer+  // and returns a pointer to internal buffer and its size+  template <typename T>+  void Serialize(const T& fields, const uint8_t** serialized_buffer,+                 size_t* serialized_len) {+    // prepare or reset buffer+    if (!prepared_ || last_deserialized_) {+      prepare();+    } else {+      buffer_->resetBuffer();+    }+    last_deserialized_ = false;++    // if required serialize protocol version+    if (serialize_version_) {+      protocol_->writeMessageBegin("""", TMessageType(0), 0);+    }++    // serialize fields into buffer+    fields.write(protocol_.get());++    // write the end of message+    if (serialize_version_) {+      protocol_->writeMessageEnd();+    }++    uint8_t* byte_buffer;+    uint32_t byte_buffer_size;+    buffer_->getBuffer(&byte_buffer, &byte_buffer_size);+    *serialized_buffer = byte_buffer;+    *serialized_len = byte_buffer_size;+  }++  // Serialize the passed type into the byte buffer+  template <typename T>+  void Serialize(const T& fields, grpc_byte_buffer** bp) {+    const uint8_t* byte_buffer;+    size_t byte_buffer_size;++    Serialize(fields, &byte_buffer, &byte_buffer_size);++    gpr_slice slice =+        gpr_slice_from_copied_buffer((char*)byte_buffer, byte_buffer_size);++    *bp = grpc_raw_byte_buffer_create(&slice, 1);++    gpr_slice_unref(slice);+  }++  // Deserialize the passed char array into  the passed type, returns the number+  // of bytes that have been consumed from the passed string.+  template <typename T>+  uint32_t Deserialize(const uint8_t* serialized_buffer, size_t length,+                       T* fields) {+    // prepare buffer if necessary+    if (!prepared_) {+      prepare();+    }+    last_deserialized_ = true;++    // reset buffer transport+    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);","Thats github fault for not showing asterisk over there. There is anasteriskOn Wed, Aug 3, 2016 at 9:14 PM, Paul Grosu notifications@github.com wrote:> In include/grpc++/impl/codegen/thrift_serializer.h> https://github.com/grpc/grpc/pull/7594#discussion_r73460045:> > > -    gpr_slice_unref(slice);> > -  }> >   +> > -  // Deserialize the passed char array into  the passed type, returns the number> > -  // of bytes that have been consumed from the passed string.> > -  template <typename T>> > -  uint32_t Deserialize(const uint8_t\* serialized_buffer, size_t length,> > -                       T\* fields) {> > -    // prepare buffer if necessary> > -    if (!prepared_) {> > -      prepare();> > -    }> > -    last_deserialized_ = true;> >   +> > -    // reset buffer transport> > -    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);> > Don't you need an asterisk too since it's a pointer, like this:> > <const uint8_t *>> > —> You are receiving this because you were mentioned.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7594/files/2e698457f370091111d0fe620bad306c743a3548#r73460045,> or mute the thread> https://github.com/notifications/unsubscribe-auth/ASfuIqsNp-cIO7p63jesvWOksWW7vBvTks5qcWcYgaJpZM4JZPv_> .",
6555937,pgrosu,https://api.github.com/repos/grpc/grpc/pulls/7594,73462103,2016-08-04T04:53:38Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,223 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+#define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <grpc/impl/codegen/byte_buffer.h>+#include <grpc/impl/codegen/byte_buffer_reader.h>+#include <grpc/impl/codegen/slice.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/protocol/TProtocolException.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <boost/make_shared.hpp>+#include <memory>+#include <stdexcept>+#include <string>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TMessageType;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;++template <typename Dummy, typename Protocol>+class ThriftSerializer {+ public:+  ThriftSerializer()+      : prepared_(false),+        last_deserialized_(false),+        serialize_version_(false) {}++  virtual ~ThriftSerializer() {}++  // Serialize the passed type into the internal buffer+  // and returns a pointer to internal buffer and its size+  template <typename T>+  void Serialize(const T& fields, const uint8_t** serialized_buffer,+                 size_t* serialized_len) {+    // prepare or reset buffer+    if (!prepared_ || last_deserialized_) {+      prepare();+    } else {+      buffer_->resetBuffer();+    }+    last_deserialized_ = false;++    // if required serialize protocol version+    if (serialize_version_) {+      protocol_->writeMessageBegin("""", TMessageType(0), 0);+    }++    // serialize fields into buffer+    fields.write(protocol_.get());++    // write the end of message+    if (serialize_version_) {+      protocol_->writeMessageEnd();+    }++    uint8_t* byte_buffer;+    uint32_t byte_buffer_size;+    buffer_->getBuffer(&byte_buffer, &byte_buffer_size);+    *serialized_buffer = byte_buffer;+    *serialized_len = byte_buffer_size;+  }++  // Serialize the passed type into the byte buffer+  template <typename T>+  void Serialize(const T& fields, grpc_byte_buffer** bp) {+    const uint8_t* byte_buffer;+    size_t byte_buffer_size;++    Serialize(fields, &byte_buffer, &byte_buffer_size);++    gpr_slice slice =+        gpr_slice_from_copied_buffer((char*)byte_buffer, byte_buffer_size);++    *bp = grpc_raw_byte_buffer_create(&slice, 1);++    gpr_slice_unref(slice);+  }++  // Deserialize the passed char array into  the passed type, returns the number+  // of bytes that have been consumed from the passed string.+  template <typename T>+  uint32_t Deserialize(const uint8_t* serialized_buffer, size_t length,+                       T* fields) {+    // prepare buffer if necessary+    if (!prepared_) {+      prepare();+    }+    last_deserialized_ = true;++    // reset buffer transport+    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);","I'm looking at the [TBufferTransports.h](https://github.com/apache/thrift/blob/aadcf34cbf643b5eff1c771047a05a4c77be9d9e/lib/cpp/src/thrift/transport/TBufferTransports.h) source code, and I'm only seeing these `resetBuffer` definitions for the `TMemoryBuffer` class:```void resetBuffer() {...}void resetBuffer(uint8_t* buf, uint32_t sz, MemoryPolicy policy = OBSERVE) {...}void resetBuffer(uint32_t sz) {...}```So you might need to cast it explicitly to match the second one.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7594,73531176,2016-08-04T14:22:17Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,223 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+#define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <grpc/impl/codegen/byte_buffer.h>+#include <grpc/impl/codegen/byte_buffer_reader.h>+#include <grpc/impl/codegen/slice.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/protocol/TProtocolException.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <boost/make_shared.hpp>+#include <memory>+#include <stdexcept>+#include <string>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TMessageType;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;++template <typename Dummy, typename Protocol>+class ThriftSerializer {+ public:+  ThriftSerializer()+      : prepared_(false),+        last_deserialized_(false),+        serialize_version_(false) {}++  virtual ~ThriftSerializer() {}++  // Serialize the passed type into the internal buffer+  // and returns a pointer to internal buffer and its size+  template <typename T>+  void Serialize(const T& fields, const uint8_t** serialized_buffer,+                 size_t* serialized_len) {+    // prepare or reset buffer+    if (!prepared_ || last_deserialized_) {+      prepare();+    } else {+      buffer_->resetBuffer();+    }+    last_deserialized_ = false;++    // if required serialize protocol version+    if (serialize_version_) {+      protocol_->writeMessageBegin("""", TMessageType(0), 0);+    }++    // serialize fields into buffer+    fields.write(protocol_.get());++    // write the end of message+    if (serialize_version_) {+      protocol_->writeMessageEnd();+    }++    uint8_t* byte_buffer;+    uint32_t byte_buffer_size;+    buffer_->getBuffer(&byte_buffer, &byte_buffer_size);+    *serialized_buffer = byte_buffer;+    *serialized_len = byte_buffer_size;+  }++  // Serialize the passed type into the byte buffer+  template <typename T>+  void Serialize(const T& fields, grpc_byte_buffer** bp) {+    const uint8_t* byte_buffer;+    size_t byte_buffer_size;++    Serialize(fields, &byte_buffer, &byte_buffer_size);++    gpr_slice slice =+        gpr_slice_from_copied_buffer((char*)byte_buffer, byte_buffer_size);++    *bp = grpc_raw_byte_buffer_create(&slice, 1);++    gpr_slice_unref(slice);+  }++  // Deserialize the passed char array into  the passed type, returns the number+  // of bytes that have been consumed from the passed string.+  template <typename T>+  uint32_t Deserialize(const uint8_t* serialized_buffer, size_t length,+                       T* fields) {+    // prepare buffer if necessary+    if (!prepared_) {+      prepare();+    }+    last_deserialized_ = true;++    // reset buffer transport+    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);","It's not that. In this case, you're trying to convert from a const to a non-const. So you should be using a const-cast to strip the const-ness. `const_cast<uint8_t*>(serialized_buffer)` . That said, why is this situation arising? Why does Deserialize have a const argument for something that will actually get changed? If the underlying contents will get changed, it should most probably never be passed in as a const anyway. Although the const_cast will solve the compiler issue, it is technically undefined behavior to modify a const object through a non-const. That is even the current situation with your C-style cast. Again, an argument for using C++ casts everywhere since the specific goal of the casting is made clear, enabling us to question the underlying decisions.",
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,73532408,2016-08-04T14:28:29Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -0,0 +1,223 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H+#define GRPCXX_IMPL_CODEGEN_THRIFT_SERIALIZER_H++#include <grpc/impl/codegen/byte_buffer.h>+#include <grpc/impl/codegen/byte_buffer_reader.h>+#include <grpc/impl/codegen/slice.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <thrift/protocol/TBinaryProtocol.h>+#include <thrift/protocol/TCompactProtocol.h>+#include <thrift/protocol/TProtocolException.h>+#include <thrift/transport/TBufferTransports.h>+#include <thrift/transport/TTransportUtils.h>+#include <boost/make_shared.hpp>+#include <memory>+#include <stdexcept>+#include <string>++namespace apache {+namespace thrift {+namespace util {++using apache::thrift::protocol::TBinaryProtocolT;+using apache::thrift::protocol::TCompactProtocolT;+using apache::thrift::protocol::TMessageType;+using apache::thrift::protocol::TNetworkBigEndian;+using apache::thrift::transport::TMemoryBuffer;+using apache::thrift::transport::TBufferBase;+using apache::thrift::transport::TTransport;++template <typename Dummy, typename Protocol>+class ThriftSerializer {+ public:+  ThriftSerializer()+      : prepared_(false),+        last_deserialized_(false),+        serialize_version_(false) {}++  virtual ~ThriftSerializer() {}++  // Serialize the passed type into the internal buffer+  // and returns a pointer to internal buffer and its size+  template <typename T>+  void Serialize(const T& fields, const uint8_t** serialized_buffer,+                 size_t* serialized_len) {+    // prepare or reset buffer+    if (!prepared_ || last_deserialized_) {+      prepare();+    } else {+      buffer_->resetBuffer();+    }+    last_deserialized_ = false;++    // if required serialize protocol version+    if (serialize_version_) {+      protocol_->writeMessageBegin("""", TMessageType(0), 0);+    }++    // serialize fields into buffer+    fields.write(protocol_.get());++    // write the end of message+    if (serialize_version_) {+      protocol_->writeMessageEnd();+    }++    uint8_t* byte_buffer;+    uint32_t byte_buffer_size;+    buffer_->getBuffer(&byte_buffer, &byte_buffer_size);+    *serialized_buffer = byte_buffer;+    *serialized_len = byte_buffer_size;+  }++  // Serialize the passed type into the byte buffer+  template <typename T>+  void Serialize(const T& fields, grpc_byte_buffer** bp) {+    const uint8_t* byte_buffer;+    size_t byte_buffer_size;++    Serialize(fields, &byte_buffer, &byte_buffer_size);++    gpr_slice slice =+        gpr_slice_from_copied_buffer((char*)byte_buffer, byte_buffer_size);++    *bp = grpc_raw_byte_buffer_create(&slice, 1);++    gpr_slice_unref(slice);+  }++  // Deserialize the passed char array into  the passed type, returns the number+  // of bytes that have been consumed from the passed string.+  template <typename T>+  uint32_t Deserialize(const uint8_t* serialized_buffer, size_t length,+                       T* fields) {+    // prepare buffer if necessary+    if (!prepared_) {+      prepare();+    }+    last_deserialized_ = true;++    // reset buffer transport+    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);","It's const pointer . We are not changing the memory location but the valueat that memory location.On Thursday, August 4, 2016, Vijay Pai notifications@github.com wrote:> In include/grpc++/impl/codegen/thrift_serializer.h> https://github.com/grpc/grpc/pull/7594#discussion_r73531176:> > > -    gpr_slice_unref(slice);> > -  }> >   +> > -  // Deserialize the passed char array into  the passed type, returns the number> > -  // of bytes that have been consumed from the passed string.> > -  template <typename T>> > -  uint32_t Deserialize(const uint8_t\* serialized_buffer, size_t length,> > -                       T\* fields) {> > -    // prepare buffer if necessary> > -    if (!prepared_) {> > -      prepare();> > -    }> > -    last_deserialized_ = true;> >   +> > -    // reset buffer transport> > -    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);> > It's not that. In this case, you're trying to convert from a const to a> non-const. So you should be using a const-cast to strip the const-ness. const_cast<uint8_t> *> . That said, why is this situation arising? Why does Deserialize have> a const argument for something that will actually get changed?> > —> You are receiving this because you were mentioned.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7594/files/2e698457f370091111d0fe620bad306c743a3548#r73531176,> or mute the thread> https://github.com/notifications/unsubscribe-auth/ASfuIgQefAryTLjxPpDePDSNk7zMMEHPks5qcfWugaJpZM4JZPv_> .",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7633,73582812,2016-08-04T19:00:18Z,tools/run_tests/run_tests.py,"@@ -471,36 +514,44 @@ def _get_pythons(self, args):       bits = '32'     else:       bits = '64'+     if os.name == 'nt':       shell = ['bash']       builder = [os.path.abspath('tools/run_tests/build_python_msys2.sh')]       builder_prefix_arguments = ['MINGW{}'.format(bits)]       venv_relative_python = ['Scripts/python.exe']       toolchain = ['mingw32']-      python_pattern_function = lambda major, minor, bits: (-          '/c/Python{major}{minor}/python.exe'.format(major=major, minor=minor, bits=bits)-	  if bits == '64' else-	  '/c/Python{major}{minor}_{bits}bits/python.exe'.format(-              major=major, minor=minor, bits=bits))     else:       shell = []       builder = [os.path.abspath('tools/run_tests/build_python.sh')]       builder_prefix_arguments = []       venv_relative_python = ['bin/python']       toolchain = ['unix']-      # Bit-ness is handled by the test machine's environment-      python_pattern_function = lambda major, minor, bits: 'python{major}.{minor}'.format(major=major, minor=minor)+     runner = [os.path.abspath('tools/run_tests/run_python.sh')]-    python_config_generator = lambda name, major, minor, bits: PythonConfig(-        name,-        shell + builder + builder_prefix_arguments-	    + [python_pattern_function(major=major, minor=minor, bits=bits)]-	    + [name] + venv_relative_python + toolchain,-        shell + runner + [os.path.join(name, venv_relative_python[0])])-    python27_config = python_config_generator(name='py27', major='2', minor='7', bits=bits)-    python34_config = python_config_generator(name='py34', major='3', minor='4', bits=bits)-    python35_config = python_config_generator(name='py35', major='3', minor='5', bits=bits)-    python36_config = python_config_generator(name='py36', major='3', minor='6', bits=bits)+    _ConfigVars = collections.namedtuple('_ConfigVars', ['shell', 'builder',","If you were to write a doc string for `_python_config_generator` (no need to since it's private and simple, but... if you _were_ to write a doc string for it), it would describe the type of its `config_args` parameter (that should probably be renamed to `config_vars`?) as `_ConfigVars`. So since `_python_config_generator` has a _semantic_ dependency on `_ConfigVars`, `_ConfigVars` should be defined earlier in the file than (""above"") `_python_config_generator`.",
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,73623764,2016-08-05T00:02:36Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -131,12 +131,12 @@ class ThriftSerializer {     last_deserialized_ = true;      // reset buffer transport-    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);+    buffer_->resetBuffer(const_cast<uint8_t*>(serialized_buffer), length);      // read the protocol version if necessary     if (serialize_version_) {       std::string name = """";-      TMessageType mt = (TMessageType)0;+      TMessageType mt = static_cast<TMessageType>(0);","TMessageType is an enumOn Thu, Aug 4, 2016 at 4:58 PM, Vijay Pai notifications@github.com wrote:> In include/grpc++/impl/codegen/thrift_serializer.h> https://github.com/grpc/grpc/pull/7594#discussion_r73623386:> > > ```> >  // read the protocol version if necessary> >  if (serialize_version_) {> >    std::string name = """";> > ```> > -      TMessageType mt = (TMessageType)0;> > -      TMessageType mt = static_cast<TMessageType>(0);> > So what makes the static_cast acceptable? What are the valid constructors> for this type?> > —> You are receiving this because you were mentioned.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7594/files/2e698457f370091111d0fe620bad306c743a3548..76db7f9a7cdf6b5fd6706037c72de1dd131b181e#r73623386,> or mute the thread> https://github.com/notifications/unsubscribe-auth/ASfuIloGDTy0d6Gy5H6kKkShklOADqqpks5qcnyVgaJpZM4JZPv_> .",
19394082,chedetinaveen,https://api.github.com/repos/grpc/grpc/pulls/7594,73624618,2016-08-05T00:12:33Z,include/grpc++/impl/codegen/thrift_serializer.h,"@@ -131,12 +131,12 @@ class ThriftSerializer {     last_deserialized_ = true;      // reset buffer transport-    buffer_->resetBuffer((uint8_t*)serialized_buffer, length);+    buffer_->resetBuffer(const_cast<uint8_t*>(serialized_buffer), length);      // read the protocol version if necessary     if (serialize_version_) {       std::string name = """";-      TMessageType mt = (TMessageType)0;+      TMessageType mt = static_cast<TMessageType>(0);","serialization version doesn't have any Message Type that is why it is setto  0.On Thu, Aug 4, 2016 at 5:03 PM, Vijay Pai notifications@github.com wrote:> In include/grpc++/impl/codegen/thrift_serializer.h> https://github.com/grpc/grpc/pull/7594#discussion_r73623829:> > > ```> >  // read the protocol version if necessary> >  if (serialize_version_) {> >    std::string name = """";> > ```> > -      TMessageType mt = (TMessageType)0;> > -      TMessageType mt = static_cast<TMessageType>(0);> > But then why aren't you using the actual enum typename rather than a> static cast from an int?> > —> You are receiving this because you were mentioned.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7594/files/2e698457f370091111d0fe620bad306c743a3548..76db7f9a7cdf6b5fd6706037c72de1dd131b181e#r73623829,> or mute the thread> https://github.com/notifications/unsubscribe-auth/ASfuIpZ8JE-GXPQCyLb81_LebwjNg9I3ks5qcn3cgaJpZM4JZPv_> .",
9046588,louiscryan,https://api.github.com/repos/grpc/grpc/pulls/4955,74171469,2016-08-10T01:03:47Z,doc/http-grpc-status-mapping.md,"@@ -0,0 +1,30 @@+# HTTP to gRPC Status Code Mapping++Since intermediaries are a common part of HTTP infrastructure some responses to+gRPC requests may be received that do not include the grpc-status header. In+some cases mapping error codes from an intermediary allows the gRPC client to+behave more appropriately to the error situation without overloading the+semantics of either error code.++This table is to be used _only_ for clients that received a response that did+not include grpc-status. If grpc-status was provided, it _must_ be used. Servers+_must not_ use this table to determine an HTTP status code to use; the mappings+are neither symmetric nor 1-to-1.++| HTTP Status Code           | gRPC Status Code   |+|----------------------------|--------------------|+| 400 Bad Request            | INTERNAL           |",More potential mappings407 Proxy Authentication Required UNAUTHENTICATED500 Internal Server Error - INTERNALbut otherwise this list looks fine to me,
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/4955,74278490,2016-08-10T16:23:25Z,doc/http-grpc-status-mapping.md,"@@ -0,0 +1,30 @@+# HTTP to gRPC Status Code Mapping++Since intermediaries are a common part of HTTP infrastructure some responses to+gRPC requests may be received that do not include the grpc-status header. In+some cases mapping error codes from an intermediary allows the gRPC client to+behave more appropriately to the error situation without overloading the+semantics of either error code.++This table is to be used _only_ for clients that received a response that did+not include grpc-status. If grpc-status was provided, it _must_ be used. Servers+_must not_ use this table to determine an HTTP status code to use; the mappings+are neither symmetric nor 1-to-1.++| HTTP Status Code           | gRPC Status Code   |+|----------------------------|--------------------|+| 400 Bad Request            | INTERNAL           |","407 seems a bit strange, given that we don't currently support client-side proxies. It also might be confusing as UNAUTHENTICATED because clients would generally assume that the end-server failed the request and probably wouldn't notice the Proxy-Authenticate. There are subtleties, so I think I'd favor leaving it off for the moment.500 seems more appropriate as UNKNOWN. Most commonly that is due to an exception on the server, which we would generally convert to UNKNOWN since it is in a different ""error space.""",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/7696,74322489,2016-08-10T20:22:26Z,Makefile,"@@ -2285,28 +2278,6 @@ install-certs: etc/roots.pem 	$(Q) $(INSTALL) -d $(prefix)/share/grpc 	$(Q) $(INSTALL) etc/roots.pem $(prefix)/share/grpc/roots.pem -verify-install:","You removed the ""verify-install"" target, but forgot to remove the dependency on that target later.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7611,74451335,2016-08-11T16:03:13Z,src/core/ext/client_config/http_connect_handshaker.c,"@@ -0,0 +1,248 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/ext/client_config/http_connect_handshaker.h""++#include <string.h>++#include <grpc/impl/codegen/alloc.h>+#include <grpc/impl/codegen/log.h>+#include <grpc/impl/codegen/slice_buffer.h>+#include <grpc/support/string_util.h>++#include ""src/core/lib/http/format_request.h""+#include ""src/core/lib/http/parser.h""+#include ""src/core/lib/iomgr/timer.h""++typedef struct http_connect_handshaker {+  // Base class.  Must be first.+  grpc_handshaker base;++  char* proxy_server;+  char* server_name;++  // State saved while performing the handshake.+  grpc_endpoint* endpoint;+  grpc_channel_args* args;+  grpc_handshaker_done_cb cb;+  void* user_data;++  // Objects for processing the HTTP CONNECT request and response.+  gpr_slice_buffer write_buffer;+  gpr_slice_buffer* read_buffer;","It's not constructed or destroyed by this object, but it is actually owned by it (at least transitively).  This field is set to the read buffer passed in to the handshaker, which we take ownership of and then pass through to the result callback (which may chain to the next handshaker).  See PR #7640 for details.I've added a brief comment indicating this.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7293,74510164,2016-08-11T21:49:13Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -428,14 +454,24 @@ def op_is_done       @op_notifier.notify(self)     end +    # Add to the metadata that will be sent from the server.+    # Fails if metadata has already been sent.+    # Unused by client calls.+    def merge_metadata_to_send(new_metadata = {})+      @send_initial_md_mutex.synchronize do+        fail('cant change metadata after already sent') if @metadata_sent",You should make the same change here as in `send_initial_metadata`,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7293,74510278,2016-08-11T21:50:08Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -187,7 +201,7 @@ def finished     # @param marshalled [false, true] indicates if the object is already     # marshalled.     def remote_send(req, marshalled = false)-      # TODO(murgatroid99): ensure metadata was sent+      send_initial_metadata unless @metadata_sent","Since we check `@metadata_sent` under the mutex, I don't think it makes sense to check it again here or in other places where `send_initial_metadata` is called. It's a minor optimization, and it can still race.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/7660,74633181,2016-08-12T17:56:54Z,test/distrib/csharp/DistribTest/DistribTest.csproj,"@@ -51,65 +53,49 @@     <ErrorReport>prompt</ErrorReport>     <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>     <Prefer32Bit>true</Prefer32Bit>+    <WarningLevel>4</WarningLevel>   </PropertyGroup>   <ItemGroup>-    <Reference Include=""BouncyCastle.Crypto"">-      <HintPath>..\packages\BouncyCastle.1.7.0\lib\Net40-Client\BouncyCastle.Crypto.dll</HintPath>-    </Reference>-    <Reference Include=""Google.Apis.Auth"">-      <HintPath>..\packages\Google.Apis.Auth.1.9.3\lib\net40\Google.Apis.Auth.dll</HintPath>-    </Reference>-    <Reference Include=""Google.Apis.Auth.PlatformServices"">-      <HintPath>..\packages\Google.Apis.Auth.1.9.3\lib\net40\Google.Apis.Auth.PlatformServices.dll</HintPath>-    </Reference>-    <Reference Include=""Google.Apis.Core"">-      <HintPath>..\packages\Google.Apis.Core.1.9.3\lib\portable-net40+sl50+win+wpa81+wp80\Google.Apis.Core.dll</HintPath>-    </Reference>     <Reference Include=""Grpc.Auth"">       <HintPath>..\packages\Grpc.Auth.__GRPC_NUGET_VERSION__\lib\net45\Grpc.Auth.dll</HintPath>     </Reference>     <Reference Include=""Grpc.Core"">       <HintPath>..\packages\Grpc.Core.__GRPC_NUGET_VERSION__\lib\net45\Grpc.Core.dll</HintPath>     </Reference>-    <Reference Include=""Microsoft.Threading.Tasks"">-      <HintPath>..\packages\Microsoft.Bcl.Async.1.0.168\lib\net40\Microsoft.Threading.Tasks.dll</HintPath>-    </Reference>-    <Reference Include=""Microsoft.Threading.Tasks.Extensions"">-      <HintPath>..\packages\Microsoft.Bcl.Async.1.0.168\lib\net40\Microsoft.Threading.Tasks.Extensions.dll</HintPath>-    </Reference>-    <Reference Include=""Microsoft.Threading.Tasks.Extensions.Desktop"">-      <HintPath>..\packages\Microsoft.Bcl.Async.1.0.168\lib\net40\Microsoft.Threading.Tasks.Extensions.Desktop.dll</HintPath>-    </Reference>-    <Reference Include=""Newtonsoft.Json, Version=7.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL"">-      <SpecificVersion>False</SpecificVersion>-      <HintPath>..\packages\Newtonsoft.Json.7.0.1\lib\net45\Newtonsoft.Json.dll</HintPath>-    </Reference>     <Reference Include=""System"" />     <Reference Include=""System.Core"" />     <Reference Include=""System.Interactive.Async"">       <HintPath>..\packages\Ix-Async.1.2.3\lib\net45\System.Interactive.Async.dll</HintPath>","Thanks for fixing up this file @jtattermusch. This is probably outside the scope of this PR now, but while this is file is getting cleaned up, I think we should also update Ix-Async.1.2.3 to System.Interactive.Async.3.0.0 (the latest grpc dependency)? Or this could be done in a separate PR...",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7616,74986414,2016-08-16T17:56:49Z,test/core/end2end/cq_verifier.c,"@@ -71,17 +70,16 @@ typedef struct expectation { struct cq_verifier {   /* bound completion queue */   grpc_completion_queue *cq;-  /* the root/sentinal expectation */-  expectation expect;+  /* expectation list */+  expectation *first_expectation;+  expectation *last_expectation;","When adding new expectations to the list, we always add them at the end.  Having a pointer to the last element of the list makes this a bit more efficient, since otherwise we'd have to iterate through the list to find the last element.I suppose efficiency doesn't really matter here, since (a) this is just test code, and (b) I suspect we don't have any tests where the number of expectations is large.  So if you'd prefer, I can eliminate last_expectation and change the add() function to iterate to the end of the list.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7713,75023382,2016-08-16T21:24:43Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable+#define CRONET_LOG(...)                          \+  {                                              \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  }++/* TODO (makdharma): Hook up into the wider tracing mechanism */ int grpc_cronet_trace = 1; -// Cronet transport object+enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled};++/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; -typedef struct stream_obj stream_obj;+  /* Used for executing callbacks for ops */+  grpc_exec_ctx exec_ctx;",No.https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/exec_ctx.h#L61,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75024296,2016-08-16T21:30:03Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable+#define CRONET_LOG(...)                          \+  {                                              \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  }++/* TODO (makdharma): Hook up into the wider tracing mechanism */ int grpc_cronet_trace = 1; -// Cronet transport object+enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};","Is it ok for `ACTION_TAKEN_WITH_CALLBACK` to be the default? It'll be assigned the value of 0, and we usually memset data structures to zero. Perhaps an uninitialized value would make sense, but I don't know enough about where this enum is used.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75039462,2016-08-16T23:25:41Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable+#define CRONET_LOG(...)                          \+  {                                              \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  }++/* TODO (makdharma): Hook up into the wider tracing mechanism */ int grpc_cronet_trace = 1; -// Cronet transport object+enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled};++/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; -typedef struct stream_obj stream_obj;+  /* Used for executing callbacks for ops */+  grpc_exec_ctx exec_ctx;+  /* Stream level state. Some state will be tracked both at stream and stream_op+   * level */+  struct op_state state; -static void next_send_step(stream_obj *s);-static void next_recv_step(stream_obj *s, enum e_caller caller);+  /* OP storage */+  struct op_storage storage; -static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                                   grpc_stream *gs, grpc_pollset *pollset) {}+  /* Mutex to protect storage */+  gpr_mu mu;+};+typedef struct stream_obj stream_obj; -static void set_pollset_set_do_nothing(grpc_exec_ctx *exec_ctx,-                                       grpc_transport *gt, grpc_stream *gs,-                                       grpc_pollset_set *pollset_set) {}+static enum OP_RESULT execute_stream_op(struct op_and_state *oas); -static void enqueue_callbacks(grpc_closure *callback_list[]) {-  grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;-  if (callback_list[0]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[0], GRPC_ERROR_NONE, NULL);-    callback_list[0] = NULL;+/*+  Add a new stream op to op storage.+*/+static void add_to_storage(struct stream_obj *s, grpc_transport_stream_op *op) {+  gpr_mu_lock(&s->mu);+  struct op_storage *storage = &s->storage;+  /* add new op at the beginning of the linked list. The memory is freed+  in remove_from_storage */+  struct op_and_state *new_op = gpr_malloc(sizeof(struct op_and_state));+  memcpy(&new_op->op, op, sizeof(grpc_transport_stream_op));+  memset(&new_op->state, 0, sizeof(new_op->state));+  new_op->s = s;+  new_op->done = false;+  new_op->next = storage->head;+  storage->head = new_op;+  storage->num_pending_ops++;+  CRONET_LOG(GPR_DEBUG, ""adding new op %p. %d in the queue."", new_op,+             storage->num_pending_ops);+  gpr_mu_unlock(&s->mu);+}++/*+  Traverse the linked list and delete op and free memory+*/+static void remove_from_storage(struct stream_obj *s,","I assume this function is called from within a locked section for `s`. In that case, we usually append `_locked` at the end of the function name to indicate we are assuming that locking precondition.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75041821,2016-08-16T23:49:07Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable-int grpc_cronet_trace = 1;+#define CRONET_LOG(...)                          \+  do {                                           \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  } while (0)++/* TODO (makdharma): Hook up into the wider tracing mechanism */+int grpc_cronet_trace = 0;++enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled}; -// Cronet transport object+/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; +  /* Stream level state. Some state will be tracked both at stream and stream_op+   * level */+  struct op_state state;++  /* OP storage */+  struct op_storage storage;++  /* Mutex to protect storage */+  gpr_mu mu;+}; typedef struct stream_obj stream_obj; -static void next_send_step(stream_obj *s);-static void next_recv_step(stream_obj *s, enum e_caller caller);+static enum OP_RESULT execute_stream_op(grpc_exec_ctx *exec_ctx,+                                        struct op_and_state *oas); -static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                                   grpc_stream *gs, grpc_pollset *pollset) {}+/*+  Add a new stream op to op storage.+*/+static void add_to_storage(struct stream_obj *s, grpc_transport_stream_op *op) {+  gpr_mu_lock(&s->mu);+  struct op_storage *storage = &s->storage;+  /* add new op at the beginning of the linked list. The memory is freed+  in remove_from_storage */+  struct op_and_state *new_op = gpr_malloc(sizeof(struct op_and_state));+  memcpy(&new_op->op, op, sizeof(grpc_transport_stream_op));+  memset(&new_op->state, 0, sizeof(new_op->state));+  new_op->s = s;+  new_op->done = false;+  new_op->next = storage->head;+  storage->head = new_op;+  storage->num_pending_ops++;+  CRONET_LOG(GPR_DEBUG, ""adding new op %p. %d in the queue."", new_op,+             storage->num_pending_ops);+  gpr_mu_unlock(&s->mu);+} -static void set_pollset_set_do_nothing(grpc_exec_ctx *exec_ctx,-                                       grpc_transport *gt, grpc_stream *gs,-                                       grpc_pollset_set *pollset_set) {}+/*+  Traverse the linked list and delete op and free memory+*/+static void remove_from_storage(struct stream_obj *s,+                                struct op_and_state *oas) {+  struct op_and_state *curr;+  if (s->storage.head == NULL || oas == NULL) {+    return;+  }+  if (s->storage.head == oas) {+    s->storage.head = oas->next;+    gpr_free(oas);+    s->storage.num_pending_ops--;+    CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+               s->storage.num_pending_ops);+  } else {+    for (curr = s->storage.head; curr != NULL; curr = curr->next) {+      if (curr->next == oas) {+        curr->next = oas->next;+        s->storage.num_pending_ops--;+        CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+                   s->storage.num_pending_ops);+        gpr_free(oas);+        break;+      } else if (curr->next == NULL) {+        CRONET_LOG(GPR_ERROR, ""Reached end of LL and did not find op to free"");+      }+    }+  }+} -static void enqueue_callbacks(grpc_closure *callback_list[]) {+/*+  Cycle through ops and try to take next action. Break when either+  an action with callback is taken, or no action is possible.+  This can be executed from the Cronet network thread via cronet callback+  or on the application supplied thread via the perform_stream_op function.+*/+static void execute_from_storage(stream_obj *s) {   grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;-  if (callback_list[0]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[0], GRPC_ERROR_NONE, NULL);-    callback_list[0] = NULL;-  }-  if (callback_list[1]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[1], GRPC_ERROR_NONE, NULL);-    callback_list[1] = NULL;+  gpr_mu_lock(&s->mu);+  for (struct op_and_state *curr = s->storage.head; curr != NULL;) {+    CRONET_LOG(GPR_DEBUG, ""calling op at %p. done = %d"", curr, curr->done);+    GPR_ASSERT(curr->done == 0);+    enum OP_RESULT result = execute_stream_op(&exec_ctx, curr);+    CRONET_LOG(GPR_DEBUG, ""execute_stream_op[%p] returns %s"", curr,+               op_result_string[result]);+    /* if this op is done, then remove it and free memory */+    if (curr->done) {+      struct op_and_state *next = curr->next;+      remove_from_storage(s, curr);+      curr = next;+    }+    /* continue processing the same op if ACTION_TAKEN_WITHOUT_CALLBACK */+    if (result == NO_ACTION_POSSIBLE) {+      curr = curr->next;+    } else if (result == ACTION_TAKEN_WITH_CALLBACK) {+      break;+    }   }+  gpr_mu_unlock(&s->mu);   grpc_exec_ctx_finish(&exec_ctx); } -static void on_canceled(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_canceled %p"", stream);+/*+  Cronet callback+*/+static void on_failed(cronet_bidirectional_stream *stream, int net_error) {+  CRONET_LOG(GPR_DEBUG, ""on_failed(%p, %d)"", stream, net_error);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_FAILED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;+  }+  execute_from_storage(s); } -static void on_failed(cronet_bidirectional_stream *stream, int net_error) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_failed %p, error = %d"", stream, net_error);+/*+  Cronet callback+*/+static void on_canceled(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""on_canceled(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_CANCELED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;+  }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_succeeded(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_succeeded %p"", stream);+  CRONET_LOG(GPR_DEBUG, ""on_succeeded(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_SUCCEEDED] = true;+  s->cbs = NULL;+  execute_from_storage(s);+}++/*+  Cronet callback+*/+static void on_request_headers_sent(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""W: on_request_headers_sent(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  s->state.state_op_done[OP_SEND_INITIAL_METADATA] = true;+  s->state.state_callback_received[OP_SEND_INITIAL_METADATA] = true;+  /* Free the memory allocated for headers */+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  execute_from_storage(s); } -static void on_response_trailers_received(+/*+  Cronet callback+*/+static void on_response_headers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *trailers) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_trailers_received"");-  }+    const cronet_bidirectional_stream_header_array *headers,+    const char *negotiated_protocol) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_headers_received(%p, %p, %s)"", stream,+             headers, negotiated_protocol);   stream_obj *s = (stream_obj *)stream->annotation;--  memset(&s->imb, 0, sizeof(s->imb));-  grpc_chttp2_incoming_metadata_buffer_init(&s->imb);+  memset(&s->state.rs.initial_metadata, 0,+         sizeof(s->state.rs.initial_metadata));+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.initial_metadata);   unsigned int i = 0;-  for (i = 0; i < trailers->count; i++) {+  for (i = 0; i < headers->count; i++) {     grpc_chttp2_incoming_metadata_buffer_add(-        &s->imb, grpc_mdelem_from_metadata_strings(-                     grpc_mdstr_from_string(trailers->headers[i].key),-                     grpc_mdstr_from_string(trailers->headers[i].value)));+        &s->state.rs.initial_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(headers->headers[i].key),+            grpc_mdstr_from_string(headers->headers[i].value)));   }-  s->response_trailers_received = true;-  next_recv_step(s, ON_RESPONSE_TRAILERS_RECEIVED);+  s->state.state_callback_received[OP_RECV_INITIAL_METADATA] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_write_completed(cronet_bidirectional_stream *stream,                                const char *data) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_write_completed"");-  }   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_MESSAGE]);-  s->cronet_send_state = CRONET_WRITE_COMPLETED;-  next_send_step(s);-}--static void process_recv_message(stream_obj *s, const uint8_t *recv_data) {-  gpr_slice read_data_slice = gpr_slice_malloc((uint32_t)s->total_read_bytes);-  uint8_t *dst_p = GPR_SLICE_START_PTR(read_data_slice);-  if (s->total_read_bytes > 0) {-    // Only copy if there is non-zero number of bytes-    memcpy(dst_p, recv_data, (size_t)s->total_read_bytes);-    gpr_slice_buffer_add(&s->read_slice_buffer, read_data_slice);+  CRONET_LOG(GPR_DEBUG, ""W: on_write_completed(%p, %s)"", stream, data);+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }-  grpc_slice_buffer_stream_init(&s->sbs, &s->read_slice_buffer, 0);-  *s->recv_message = (grpc_byte_buffer *)&s->sbs;-}--static int parse_grpc_header(const uint8_t *data) {-  const uint8_t *p = data + 1;-  int length = 0;-  length |= ((uint8_t)*p++) << 24;-  length |= ((uint8_t)*p++) << 16;-  length |= ((uint8_t)*p++) << 8;-  length |= ((uint8_t)*p++);-  return length;+  s->state.state_callback_received[OP_SEND_MESSAGE] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_read_completed(cronet_bidirectional_stream *stream, char *data,                               int count) {   stream_obj *s = (stream_obj *)stream->annotation;-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_read_completed count=%d, total=%d, remaining=%d"",-            count, s->total_read_bytes, s->remaining_read_bytes);-  }+  CRONET_LOG(GPR_DEBUG, ""R: on_read_completed(%p, %p, %d)"", stream, data,+             count);+  s->state.state_callback_received[OP_RECV_MESSAGE] = true;   if (count > 0) {-    GPR_ASSERT(s->recv_message);-    s->remaining_read_bytes -= count;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.received_bytes += count;+    s->state.rs.remaining_bytes -= count;+    if (s->state.rs.remaining_bytes > 0) {+      CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_read(%p)"", s->cbs);+      s->state.state_op_done[OP_READ_REQ_MADE] = true;+      cronet_bidirectional_stream_read(+          s->cbs, s->state.rs.read_buffer + s->state.rs.received_bytes,+          s->state.rs.remaining_bytes);+    } else {+      execute_from_storage(s);+    }   } else {-    s->read_closed = true;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.read_stream_closed = true;+    execute_from_storage(s);   } } -static void on_response_headers_received(+/*+  Cronet callback+*/+static void on_response_trailers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *headers,-    const char *negotiated_protocol) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_headers_received"");-  }-  stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_RECV_INITIAL_METADATA]);-  s->response_headers_received = true;-  next_recv_step(s, ON_RESPONSE_HEADERS_RECEIVED);-}--static void on_request_headers_sent(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_request_headers_sent"");-  }+    const cronet_bidirectional_stream_header_array *trailers) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_trailers_received(%p,%p)"", stream,+             trailers);   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_INITIAL_METADATA]);-  s->cronet_send_state = CRONET_SEND_HEADER;-  next_send_step(s);-}--// Callback function pointers (invoked by cronet in response to events)-static cronet_bidirectional_stream_callback callbacks = {-    on_request_headers_sent,-    on_response_headers_received,-    on_read_completed,-    on_write_completed,-    on_response_trailers_received,-    on_succeeded,-    on_failed,-    on_canceled};--static void invoke_closing_callback(stream_obj *s) {-  grpc_chttp2_incoming_metadata_buffer_publish(&s->imb,-                                               s->recv_trailing_metadata);-  if (s->callback_list[CB_RECV_TRAILING_METADATA]) {-    enqueue_callbacks(s->callback_list[CB_RECV_TRAILING_METADATA]);-  }-}--static void set_recv_state(stream_obj *s, enum recv_state state) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""next_state = %s"", recv_state_name[state]);-  }-  s->cronet_recv_state = state;-}--// This is invoked from perform_stream_op, and all on_xxxx callbacks.-static void next_recv_step(stream_obj *s, enum e_caller caller) {-  gpr_mu_lock(&s->recv_mu);-  switch (s->cronet_recv_state) {-    case CRONET_RECV_IDLE:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_IDLE"");-      }-      if (caller == PERFORM_STREAM_OP ||-          caller == ON_RESPONSE_HEADERS_RECEIVED) {-        if (s->read_closed && s->response_trailers_received) {-          invoke_closing_callback(s);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else if (s->response_headers_received == true &&-                   s->read_requested == true) {-          set_recv_state(s, CRONET_RECV_READ_LENGTH);-          s->total_read_bytes = s->remaining_read_bytes =-              GRPC_HEADER_SIZE_IN_BYTES;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(s->cbs, s->read_buffer,-                                           s->remaining_read_bytes);-        }-      }-      break;-    case CRONET_RECV_READ_LENGTH:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_LENGTH"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->read_closed) {-          invoke_closing_callback(s);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else {-          GPR_ASSERT(s->remaining_read_bytes == 0);-          set_recv_state(s, CRONET_RECV_READ_DATA);-          s->total_read_bytes = s->remaining_read_bytes =-              parse_grpc_header((const uint8_t *)s->read_buffer);-          s->read_buffer =-              gpr_realloc(s->read_buffer, (uint32_t)s->remaining_read_bytes);-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          if (s->remaining_read_bytes > 0) {-            cronet_bidirectional_stream_read(s->cbs, (char *)s->read_buffer,-                                             s->remaining_read_bytes);-          } else {-            // Calling the closing callback directly since this is a 0 byte read-            // for an empty message.-            process_recv_message(s, NULL);-            enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-            invoke_closing_callback(s);-            set_recv_state(s, CRONET_RECV_CLOSED);-          }-        }-      }-      break;-    case CRONET_RECV_READ_DATA:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_DATA"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->remaining_read_bytes > 0) {-          int offset = s->total_read_bytes - s->remaining_read_bytes;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(-              s->cbs, (char *)s->read_buffer + offset, s->remaining_read_bytes);-        } else {-          gpr_slice_buffer_init(&s->read_slice_buffer);-          uint8_t *p = (uint8_t *)s->read_buffer;-          process_recv_message(s, p);-          set_recv_state(s, CRONET_RECV_IDLE);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-        }-      }-      break;-    case CRONET_RECV_CLOSED:-      break;-    default:-      GPR_ASSERT(0);  // Should not reach here-      break;+  memset(&s->state.rs.trailing_metadata, 0,+         sizeof(s->state.rs.trailing_metadata));+  s->state.rs.trailing_metadata_valid = false;+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.trailing_metadata);+  unsigned int i = 0;+  for (i = 0; i < trailers->count; i++) {+    CRONET_LOG(GPR_DEBUG, ""trailer key=%s, value=%s"", trailers->headers[i].key,+               trailers->headers[i].value);+    grpc_chttp2_incoming_metadata_buffer_add(+        &s->state.rs.trailing_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(trailers->headers[i].key),+            grpc_mdstr_from_string(trailers->headers[i].value)));+    s->state.rs.trailing_metadata_valid = true;   }-  gpr_mu_unlock(&s->recv_mu);+  s->state.state_callback_received[OP_RECV_TRAILING_METADATA] = true;+  execute_from_storage(s); } -// This function takes the data from s->write_slice_buffer and assembles into-// a contiguous byte stream with 5 byte gRPC header prepended.-static void create_grpc_frame(stream_obj *s) {-  gpr_slice slice = gpr_slice_buffer_take_first(&s->write_slice_buffer);-  uint8_t *raw_data = GPR_SLICE_START_PTR(slice);+/*+ Utility function that takes the data from s->write_slice_buffer and assembles+ into a contiguous byte stream with 5 byte gRPC header prepended.+*/+static void create_grpc_frame(gpr_slice_buffer *write_slice_buffer,+                              char **pp_write_buffer,+                              int *p_write_buffer_size) {+  gpr_slice slice = gpr_slice_buffer_take_first(write_slice_buffer);   size_t length = GPR_SLICE_LENGTH(slice);-  s->write_buffer_size = length + GRPC_HEADER_SIZE_IN_BYTES;-  s->write_buffer = gpr_realloc(s->write_buffer, s->write_buffer_size);-  uint8_t *p = (uint8_t *)s->write_buffer;-  // Append 5 byte header+  *p_write_buffer_size = (int)length + GRPC_HEADER_SIZE_IN_BYTES;+  /* This is freed in the on_write_completed callback */+  char *write_buffer = gpr_malloc(length + GRPC_HEADER_SIZE_IN_BYTES);+  *pp_write_buffer = write_buffer;+  uint8_t *p = (uint8_t *)write_buffer;+  /* Append 5 byte header */   *p++ = 0;   *p++ = (uint8_t)(length >> 24);   *p++ = (uint8_t)(length >> 16);   *p++ = (uint8_t)(length >> 8);   *p++ = (uint8_t)(length);-  // append actual data-  memcpy(p, raw_data, length);+  /* append actual data */+  memcpy(p, GPR_SLICE_START_PTR(slice), length); } -static void do_write(stream_obj *s) {-  gpr_slice_buffer *sb = &s->write_slice_buffer;-  GPR_ASSERT(sb->count <= 1);-  if (sb->count > 0) {-    create_grpc_frame(s);-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""W: cronet_bidirectional_stream_write"");-    }-    cronet_bidirectional_stream_write(s->cbs, s->write_buffer,-                                      (int)s->write_buffer_size, false);-  }-}--//-static void next_send_step(stream_obj *s) {-  switch (s->cronet_send_state) {-    case CRONET_SEND_IDLE:-      GPR_ASSERT(-          s->cbs);  // cronet_bidirectional_stream is not initialized yet.-      s->cronet_send_state = CRONET_REQ_STARTED;-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_bidirectional_stream_start to %s"", s->url);-      }-      cronet_bidirectional_stream_start(s->cbs, s->url, 0, ""POST"",-                                        &s->header_array, false);-      // we no longer need the memory that was allocated earlier.-      gpr_free(s->header_array.headers);-      break;-    case CRONET_SEND_HEADER:-      do_write(s);-      s->cronet_send_state = CRONET_WRITE;-      break;-    case CRONET_WRITE_COMPLETED:-      do_write(s);-      break;-    default:-      GPR_ASSERT(0);-      break;-  }-}--static void convert_metadata_to_cronet_headers(grpc_linked_mdelem *head,-                                               const char *host,-                                               stream_obj *s) {+/*+ Convert metadata in a format that Cronet can consume+*/+static void convert_metadata_to_cronet_headers(+    grpc_linked_mdelem *head, const char *host, char **pp_url,+    cronet_bidirectional_stream_header **pp_headers, size_t *p_num_headers) {   grpc_linked_mdelem *curr = head;-  // Walk the linked list and get number of header fields+  /* Walk the linked list and get number of header fields */   uint32_t num_headers_available = 0;   while (curr != NULL) {     curr = curr->next;     num_headers_available++;   }-  // Allocate enough memory-  s->headers = (cronet_bidirectional_stream_header *)gpr_malloc(-      sizeof(cronet_bidirectional_stream_header) * num_headers_available);--  // Walk the linked list again, this time copying the header fields.-  // s->num_headers-  // can be less than num_headers_available, as some headers are not used for-  // cronet+  /* Allocate enough memory. It is freed in the on_request_headers_sent callback+   */+  cronet_bidirectional_stream_header *headers =+      (cronet_bidirectional_stream_header *)gpr_malloc(+          sizeof(cronet_bidirectional_stream_header) * num_headers_available);+  *pp_headers = headers;++  /* Walk the linked list again, this time copying the header fields.","could both traversals be combined? walking a linked list is horrible for performance, you trash the caches. This is probably more of a concern on a mobile decide with smaller caches.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75042115,2016-08-16T23:52:13Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable-int grpc_cronet_trace = 1;+#define CRONET_LOG(...)                          \+  do {                                           \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  } while (0)++/* TODO (makdharma): Hook up into the wider tracing mechanism */+int grpc_cronet_trace = 0;++enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled}; -// Cronet transport object+/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; +  /* Stream level state. Some state will be tracked both at stream and stream_op+   * level */+  struct op_state state;++  /* OP storage */+  struct op_storage storage;++  /* Mutex to protect storage */+  gpr_mu mu;+}; typedef struct stream_obj stream_obj; -static void next_send_step(stream_obj *s);-static void next_recv_step(stream_obj *s, enum e_caller caller);+static enum OP_RESULT execute_stream_op(grpc_exec_ctx *exec_ctx,+                                        struct op_and_state *oas); -static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                                   grpc_stream *gs, grpc_pollset *pollset) {}+/*+  Add a new stream op to op storage.+*/+static void add_to_storage(struct stream_obj *s, grpc_transport_stream_op *op) {+  gpr_mu_lock(&s->mu);+  struct op_storage *storage = &s->storage;+  /* add new op at the beginning of the linked list. The memory is freed+  in remove_from_storage */+  struct op_and_state *new_op = gpr_malloc(sizeof(struct op_and_state));+  memcpy(&new_op->op, op, sizeof(grpc_transport_stream_op));+  memset(&new_op->state, 0, sizeof(new_op->state));+  new_op->s = s;+  new_op->done = false;+  new_op->next = storage->head;+  storage->head = new_op;+  storage->num_pending_ops++;+  CRONET_LOG(GPR_DEBUG, ""adding new op %p. %d in the queue."", new_op,+             storage->num_pending_ops);+  gpr_mu_unlock(&s->mu);+} -static void set_pollset_set_do_nothing(grpc_exec_ctx *exec_ctx,-                                       grpc_transport *gt, grpc_stream *gs,-                                       grpc_pollset_set *pollset_set) {}+/*+  Traverse the linked list and delete op and free memory+*/+static void remove_from_storage(struct stream_obj *s,+                                struct op_and_state *oas) {+  struct op_and_state *curr;+  if (s->storage.head == NULL || oas == NULL) {+    return;+  }+  if (s->storage.head == oas) {+    s->storage.head = oas->next;+    gpr_free(oas);+    s->storage.num_pending_ops--;+    CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+               s->storage.num_pending_ops);+  } else {+    for (curr = s->storage.head; curr != NULL; curr = curr->next) {+      if (curr->next == oas) {+        curr->next = oas->next;+        s->storage.num_pending_ops--;+        CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+                   s->storage.num_pending_ops);+        gpr_free(oas);+        break;+      } else if (curr->next == NULL) {+        CRONET_LOG(GPR_ERROR, ""Reached end of LL and did not find op to free"");+      }+    }+  }+} -static void enqueue_callbacks(grpc_closure *callback_list[]) {+/*+  Cycle through ops and try to take next action. Break when either+  an action with callback is taken, or no action is possible.+  This can be executed from the Cronet network thread via cronet callback+  or on the application supplied thread via the perform_stream_op function.+*/+static void execute_from_storage(stream_obj *s) {   grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;-  if (callback_list[0]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[0], GRPC_ERROR_NONE, NULL);-    callback_list[0] = NULL;-  }-  if (callback_list[1]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[1], GRPC_ERROR_NONE, NULL);-    callback_list[1] = NULL;+  gpr_mu_lock(&s->mu);+  for (struct op_and_state *curr = s->storage.head; curr != NULL;) {+    CRONET_LOG(GPR_DEBUG, ""calling op at %p. done = %d"", curr, curr->done);+    GPR_ASSERT(curr->done == 0);+    enum OP_RESULT result = execute_stream_op(&exec_ctx, curr);+    CRONET_LOG(GPR_DEBUG, ""execute_stream_op[%p] returns %s"", curr,+               op_result_string[result]);+    /* if this op is done, then remove it and free memory */+    if (curr->done) {+      struct op_and_state *next = curr->next;+      remove_from_storage(s, curr);+      curr = next;+    }+    /* continue processing the same op if ACTION_TAKEN_WITHOUT_CALLBACK */+    if (result == NO_ACTION_POSSIBLE) {+      curr = curr->next;+    } else if (result == ACTION_TAKEN_WITH_CALLBACK) {+      break;+    }   }+  gpr_mu_unlock(&s->mu);   grpc_exec_ctx_finish(&exec_ctx); } -static void on_canceled(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_canceled %p"", stream);+/*+  Cronet callback+*/+static void on_failed(cronet_bidirectional_stream *stream, int net_error) {+  CRONET_LOG(GPR_DEBUG, ""on_failed(%p, %d)"", stream, net_error);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_FAILED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;+  }+  execute_from_storage(s); } -static void on_failed(cronet_bidirectional_stream *stream, int net_error) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_failed %p, error = %d"", stream, net_error);+/*+  Cronet callback+*/+static void on_canceled(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""on_canceled(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_CANCELED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;+  }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_succeeded(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_succeeded %p"", stream);+  CRONET_LOG(GPR_DEBUG, ""on_succeeded(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_SUCCEEDED] = true;+  s->cbs = NULL;+  execute_from_storage(s);+}++/*+  Cronet callback+*/+static void on_request_headers_sent(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""W: on_request_headers_sent(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  s->state.state_op_done[OP_SEND_INITIAL_METADATA] = true;+  s->state.state_callback_received[OP_SEND_INITIAL_METADATA] = true;+  /* Free the memory allocated for headers */+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  execute_from_storage(s); } -static void on_response_trailers_received(+/*+  Cronet callback+*/+static void on_response_headers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *trailers) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_trailers_received"");-  }+    const cronet_bidirectional_stream_header_array *headers,+    const char *negotiated_protocol) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_headers_received(%p, %p, %s)"", stream,+             headers, negotiated_protocol);   stream_obj *s = (stream_obj *)stream->annotation;--  memset(&s->imb, 0, sizeof(s->imb));-  grpc_chttp2_incoming_metadata_buffer_init(&s->imb);+  memset(&s->state.rs.initial_metadata, 0,+         sizeof(s->state.rs.initial_metadata));+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.initial_metadata);   unsigned int i = 0;-  for (i = 0; i < trailers->count; i++) {+  for (i = 0; i < headers->count; i++) {     grpc_chttp2_incoming_metadata_buffer_add(-        &s->imb, grpc_mdelem_from_metadata_strings(-                     grpc_mdstr_from_string(trailers->headers[i].key),-                     grpc_mdstr_from_string(trailers->headers[i].value)));+        &s->state.rs.initial_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(headers->headers[i].key),+            grpc_mdstr_from_string(headers->headers[i].value)));   }-  s->response_trailers_received = true;-  next_recv_step(s, ON_RESPONSE_TRAILERS_RECEIVED);+  s->state.state_callback_received[OP_RECV_INITIAL_METADATA] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_write_completed(cronet_bidirectional_stream *stream,                                const char *data) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_write_completed"");-  }   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_MESSAGE]);-  s->cronet_send_state = CRONET_WRITE_COMPLETED;-  next_send_step(s);-}--static void process_recv_message(stream_obj *s, const uint8_t *recv_data) {-  gpr_slice read_data_slice = gpr_slice_malloc((uint32_t)s->total_read_bytes);-  uint8_t *dst_p = GPR_SLICE_START_PTR(read_data_slice);-  if (s->total_read_bytes > 0) {-    // Only copy if there is non-zero number of bytes-    memcpy(dst_p, recv_data, (size_t)s->total_read_bytes);-    gpr_slice_buffer_add(&s->read_slice_buffer, read_data_slice);+  CRONET_LOG(GPR_DEBUG, ""W: on_write_completed(%p, %s)"", stream, data);+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }-  grpc_slice_buffer_stream_init(&s->sbs, &s->read_slice_buffer, 0);-  *s->recv_message = (grpc_byte_buffer *)&s->sbs;-}--static int parse_grpc_header(const uint8_t *data) {-  const uint8_t *p = data + 1;-  int length = 0;-  length |= ((uint8_t)*p++) << 24;-  length |= ((uint8_t)*p++) << 16;-  length |= ((uint8_t)*p++) << 8;-  length |= ((uint8_t)*p++);-  return length;+  s->state.state_callback_received[OP_SEND_MESSAGE] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_read_completed(cronet_bidirectional_stream *stream, char *data,                               int count) {   stream_obj *s = (stream_obj *)stream->annotation;-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_read_completed count=%d, total=%d, remaining=%d"",-            count, s->total_read_bytes, s->remaining_read_bytes);-  }+  CRONET_LOG(GPR_DEBUG, ""R: on_read_completed(%p, %p, %d)"", stream, data,+             count);+  s->state.state_callback_received[OP_RECV_MESSAGE] = true;   if (count > 0) {-    GPR_ASSERT(s->recv_message);-    s->remaining_read_bytes -= count;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.received_bytes += count;+    s->state.rs.remaining_bytes -= count;+    if (s->state.rs.remaining_bytes > 0) {+      CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_read(%p)"", s->cbs);+      s->state.state_op_done[OP_READ_REQ_MADE] = true;+      cronet_bidirectional_stream_read(+          s->cbs, s->state.rs.read_buffer + s->state.rs.received_bytes,+          s->state.rs.remaining_bytes);+    } else {+      execute_from_storage(s);+    }   } else {-    s->read_closed = true;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.read_stream_closed = true;+    execute_from_storage(s);   } } -static void on_response_headers_received(+/*+  Cronet callback+*/+static void on_response_trailers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *headers,-    const char *negotiated_protocol) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_headers_received"");-  }-  stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_RECV_INITIAL_METADATA]);-  s->response_headers_received = true;-  next_recv_step(s, ON_RESPONSE_HEADERS_RECEIVED);-}--static void on_request_headers_sent(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_request_headers_sent"");-  }+    const cronet_bidirectional_stream_header_array *trailers) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_trailers_received(%p,%p)"", stream,+             trailers);   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_INITIAL_METADATA]);-  s->cronet_send_state = CRONET_SEND_HEADER;-  next_send_step(s);-}--// Callback function pointers (invoked by cronet in response to events)-static cronet_bidirectional_stream_callback callbacks = {-    on_request_headers_sent,-    on_response_headers_received,-    on_read_completed,-    on_write_completed,-    on_response_trailers_received,-    on_succeeded,-    on_failed,-    on_canceled};--static void invoke_closing_callback(stream_obj *s) {-  grpc_chttp2_incoming_metadata_buffer_publish(&s->imb,-                                               s->recv_trailing_metadata);-  if (s->callback_list[CB_RECV_TRAILING_METADATA]) {-    enqueue_callbacks(s->callback_list[CB_RECV_TRAILING_METADATA]);-  }-}--static void set_recv_state(stream_obj *s, enum recv_state state) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""next_state = %s"", recv_state_name[state]);-  }-  s->cronet_recv_state = state;-}--// This is invoked from perform_stream_op, and all on_xxxx callbacks.-static void next_recv_step(stream_obj *s, enum e_caller caller) {-  gpr_mu_lock(&s->recv_mu);-  switch (s->cronet_recv_state) {-    case CRONET_RECV_IDLE:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_IDLE"");-      }-      if (caller == PERFORM_STREAM_OP ||-          caller == ON_RESPONSE_HEADERS_RECEIVED) {-        if (s->read_closed && s->response_trailers_received) {-          invoke_closing_callback(s);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else if (s->response_headers_received == true &&-                   s->read_requested == true) {-          set_recv_state(s, CRONET_RECV_READ_LENGTH);-          s->total_read_bytes = s->remaining_read_bytes =-              GRPC_HEADER_SIZE_IN_BYTES;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(s->cbs, s->read_buffer,-                                           s->remaining_read_bytes);-        }-      }-      break;-    case CRONET_RECV_READ_LENGTH:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_LENGTH"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->read_closed) {-          invoke_closing_callback(s);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else {-          GPR_ASSERT(s->remaining_read_bytes == 0);-          set_recv_state(s, CRONET_RECV_READ_DATA);-          s->total_read_bytes = s->remaining_read_bytes =-              parse_grpc_header((const uint8_t *)s->read_buffer);-          s->read_buffer =-              gpr_realloc(s->read_buffer, (uint32_t)s->remaining_read_bytes);-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          if (s->remaining_read_bytes > 0) {-            cronet_bidirectional_stream_read(s->cbs, (char *)s->read_buffer,-                                             s->remaining_read_bytes);-          } else {-            // Calling the closing callback directly since this is a 0 byte read-            // for an empty message.-            process_recv_message(s, NULL);-            enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-            invoke_closing_callback(s);-            set_recv_state(s, CRONET_RECV_CLOSED);-          }-        }-      }-      break;-    case CRONET_RECV_READ_DATA:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_DATA"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->remaining_read_bytes > 0) {-          int offset = s->total_read_bytes - s->remaining_read_bytes;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(-              s->cbs, (char *)s->read_buffer + offset, s->remaining_read_bytes);-        } else {-          gpr_slice_buffer_init(&s->read_slice_buffer);-          uint8_t *p = (uint8_t *)s->read_buffer;-          process_recv_message(s, p);-          set_recv_state(s, CRONET_RECV_IDLE);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-        }-      }-      break;-    case CRONET_RECV_CLOSED:-      break;-    default:-      GPR_ASSERT(0);  // Should not reach here-      break;+  memset(&s->state.rs.trailing_metadata, 0,+         sizeof(s->state.rs.trailing_metadata));+  s->state.rs.trailing_metadata_valid = false;+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.trailing_metadata);+  unsigned int i = 0;+  for (i = 0; i < trailers->count; i++) {+    CRONET_LOG(GPR_DEBUG, ""trailer key=%s, value=%s"", trailers->headers[i].key,+               trailers->headers[i].value);+    grpc_chttp2_incoming_metadata_buffer_add(+        &s->state.rs.trailing_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(trailers->headers[i].key),+            grpc_mdstr_from_string(trailers->headers[i].value)));+    s->state.rs.trailing_metadata_valid = true;   }-  gpr_mu_unlock(&s->recv_mu);+  s->state.state_callback_received[OP_RECV_TRAILING_METADATA] = true;+  execute_from_storage(s); } -// This function takes the data from s->write_slice_buffer and assembles into-// a contiguous byte stream with 5 byte gRPC header prepended.-static void create_grpc_frame(stream_obj *s) {-  gpr_slice slice = gpr_slice_buffer_take_first(&s->write_slice_buffer);-  uint8_t *raw_data = GPR_SLICE_START_PTR(slice);+/*+ Utility function that takes the data from s->write_slice_buffer and assembles+ into a contiguous byte stream with 5 byte gRPC header prepended.+*/+static void create_grpc_frame(gpr_slice_buffer *write_slice_buffer,+                              char **pp_write_buffer,+                              int *p_write_buffer_size) {+  gpr_slice slice = gpr_slice_buffer_take_first(write_slice_buffer);   size_t length = GPR_SLICE_LENGTH(slice);-  s->write_buffer_size = length + GRPC_HEADER_SIZE_IN_BYTES;-  s->write_buffer = gpr_realloc(s->write_buffer, s->write_buffer_size);-  uint8_t *p = (uint8_t *)s->write_buffer;-  // Append 5 byte header+  *p_write_buffer_size = (int)length + GRPC_HEADER_SIZE_IN_BYTES;+  /* This is freed in the on_write_completed callback */+  char *write_buffer = gpr_malloc(length + GRPC_HEADER_SIZE_IN_BYTES);+  *pp_write_buffer = write_buffer;+  uint8_t *p = (uint8_t *)write_buffer;+  /* Append 5 byte header */   *p++ = 0;   *p++ = (uint8_t)(length >> 24);   *p++ = (uint8_t)(length >> 16);   *p++ = (uint8_t)(length >> 8);   *p++ = (uint8_t)(length);-  // append actual data-  memcpy(p, raw_data, length);+  /* append actual data */+  memcpy(p, GPR_SLICE_START_PTR(slice), length); } -static void do_write(stream_obj *s) {-  gpr_slice_buffer *sb = &s->write_slice_buffer;-  GPR_ASSERT(sb->count <= 1);-  if (sb->count > 0) {-    create_grpc_frame(s);-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""W: cronet_bidirectional_stream_write"");-    }-    cronet_bidirectional_stream_write(s->cbs, s->write_buffer,-                                      (int)s->write_buffer_size, false);-  }-}--//-static void next_send_step(stream_obj *s) {-  switch (s->cronet_send_state) {-    case CRONET_SEND_IDLE:-      GPR_ASSERT(-          s->cbs);  // cronet_bidirectional_stream is not initialized yet.-      s->cronet_send_state = CRONET_REQ_STARTED;-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_bidirectional_stream_start to %s"", s->url);-      }-      cronet_bidirectional_stream_start(s->cbs, s->url, 0, ""POST"",-                                        &s->header_array, false);-      // we no longer need the memory that was allocated earlier.-      gpr_free(s->header_array.headers);-      break;-    case CRONET_SEND_HEADER:-      do_write(s);-      s->cronet_send_state = CRONET_WRITE;-      break;-    case CRONET_WRITE_COMPLETED:-      do_write(s);-      break;-    default:-      GPR_ASSERT(0);-      break;-  }-}--static void convert_metadata_to_cronet_headers(grpc_linked_mdelem *head,-                                               const char *host,-                                               stream_obj *s) {+/*+ Convert metadata in a format that Cronet can consume+*/+static void convert_metadata_to_cronet_headers(+    grpc_linked_mdelem *head, const char *host, char **pp_url,+    cronet_bidirectional_stream_header **pp_headers, size_t *p_num_headers) {   grpc_linked_mdelem *curr = head;-  // Walk the linked list and get number of header fields+  /* Walk the linked list and get number of header fields */   uint32_t num_headers_available = 0;   while (curr != NULL) {     curr = curr->next;     num_headers_available++;   }-  // Allocate enough memory-  s->headers = (cronet_bidirectional_stream_header *)gpr_malloc(-      sizeof(cronet_bidirectional_stream_header) * num_headers_available);--  // Walk the linked list again, this time copying the header fields.-  // s->num_headers-  // can be less than num_headers_available, as some headers are not used for-  // cronet+  /* Allocate enough memory. It is freed in the on_request_headers_sent callback+   */+  cronet_bidirectional_stream_header *headers =+      (cronet_bidirectional_stream_header *)gpr_malloc(+          sizeof(cronet_bidirectional_stream_header) * num_headers_available);+  *pp_headers = headers;++  /* Walk the linked list again, this time copying the header fields.+    s->num_headers can be less than num_headers_available, as some headers+    are not used for cronet+   */   curr = head;-  s->num_headers = 0;-  while (s->num_headers < num_headers_available) {+  int num_headers = 0;+  while (num_headers < num_headers_available) {     grpc_mdelem *mdelem = curr->md;     curr = curr->next;     const char *key = grpc_mdstr_as_c_string(mdelem->key);",The right (performant) way to compare metadata keys is to compare them against the corresponding entry in `static_metadata.h`. For example: https://github.com/grpc/grpc/blob/master/src/core/lib/channel/compress_filter.c#L90 That's O(1) cost on an already hot cache line.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75044224,2016-08-17T00:14:44Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable-int grpc_cronet_trace = 1;+#define CRONET_LOG(...)                          \+  do {                                           \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  } while (0)++/* TODO (makdharma): Hook up into the wider tracing mechanism */+int grpc_cronet_trace = 0;++enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled}; -// Cronet transport object+/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; +  /* Stream level state. Some state will be tracked both at stream and stream_op+   * level */+  struct op_state state;++  /* OP storage */+  struct op_storage storage;++  /* Mutex to protect storage */+  gpr_mu mu;+}; typedef struct stream_obj stream_obj; -static void next_send_step(stream_obj *s);-static void next_recv_step(stream_obj *s, enum e_caller caller);+static enum OP_RESULT execute_stream_op(grpc_exec_ctx *exec_ctx,+                                        struct op_and_state *oas); -static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                                   grpc_stream *gs, grpc_pollset *pollset) {}+/*+  Add a new stream op to op storage.+*/+static void add_to_storage(struct stream_obj *s, grpc_transport_stream_op *op) {+  gpr_mu_lock(&s->mu);+  struct op_storage *storage = &s->storage;+  /* add new op at the beginning of the linked list. The memory is freed+  in remove_from_storage */+  struct op_and_state *new_op = gpr_malloc(sizeof(struct op_and_state));+  memcpy(&new_op->op, op, sizeof(grpc_transport_stream_op));+  memset(&new_op->state, 0, sizeof(new_op->state));+  new_op->s = s;+  new_op->done = false;+  new_op->next = storage->head;+  storage->head = new_op;+  storage->num_pending_ops++;+  CRONET_LOG(GPR_DEBUG, ""adding new op %p. %d in the queue."", new_op,+             storage->num_pending_ops);+  gpr_mu_unlock(&s->mu);+} -static void set_pollset_set_do_nothing(grpc_exec_ctx *exec_ctx,-                                       grpc_transport *gt, grpc_stream *gs,-                                       grpc_pollset_set *pollset_set) {}+/*+  Traverse the linked list and delete op and free memory+*/+static void remove_from_storage(struct stream_obj *s,+                                struct op_and_state *oas) {+  struct op_and_state *curr;+  if (s->storage.head == NULL || oas == NULL) {+    return;+  }+  if (s->storage.head == oas) {+    s->storage.head = oas->next;+    gpr_free(oas);+    s->storage.num_pending_ops--;+    CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+               s->storage.num_pending_ops);+  } else {+    for (curr = s->storage.head; curr != NULL; curr = curr->next) {+      if (curr->next == oas) {+        curr->next = oas->next;+        s->storage.num_pending_ops--;+        CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+                   s->storage.num_pending_ops);+        gpr_free(oas);+        break;+      } else if (curr->next == NULL) {+        CRONET_LOG(GPR_ERROR, ""Reached end of LL and did not find op to free"");+      }+    }+  }+} -static void enqueue_callbacks(grpc_closure *callback_list[]) {+/*+  Cycle through ops and try to take next action. Break when either+  an action with callback is taken, or no action is possible.+  This can be executed from the Cronet network thread via cronet callback+  or on the application supplied thread via the perform_stream_op function.+*/+static void execute_from_storage(stream_obj *s) {   grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;-  if (callback_list[0]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[0], GRPC_ERROR_NONE, NULL);-    callback_list[0] = NULL;-  }-  if (callback_list[1]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[1], GRPC_ERROR_NONE, NULL);-    callback_list[1] = NULL;+  gpr_mu_lock(&s->mu);+  for (struct op_and_state *curr = s->storage.head; curr != NULL;) {+    CRONET_LOG(GPR_DEBUG, ""calling op at %p. done = %d"", curr, curr->done);+    GPR_ASSERT(curr->done == 0);+    enum OP_RESULT result = execute_stream_op(&exec_ctx, curr);+    CRONET_LOG(GPR_DEBUG, ""execute_stream_op[%p] returns %s"", curr,+               op_result_string[result]);+    /* if this op is done, then remove it and free memory */+    if (curr->done) {+      struct op_and_state *next = curr->next;+      remove_from_storage(s, curr);+      curr = next;+    }+    /* continue processing the same op if ACTION_TAKEN_WITHOUT_CALLBACK */+    if (result == NO_ACTION_POSSIBLE) {+      curr = curr->next;+    } else if (result == ACTION_TAKEN_WITH_CALLBACK) {+      break;+    }   }+  gpr_mu_unlock(&s->mu);   grpc_exec_ctx_finish(&exec_ctx); } -static void on_canceled(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_canceled %p"", stream);+/*+  Cronet callback+*/+static void on_failed(cronet_bidirectional_stream *stream, int net_error) {+  CRONET_LOG(GPR_DEBUG, ""on_failed(%p, %d)"", stream, net_error);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_FAILED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;+  }+  execute_from_storage(s); } -static void on_failed(cronet_bidirectional_stream *stream, int net_error) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_failed %p, error = %d"", stream, net_error);+/*+  Cronet callback+*/+static void on_canceled(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""on_canceled(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_CANCELED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;+  }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_succeeded(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_succeeded %p"", stream);+  CRONET_LOG(GPR_DEBUG, ""on_succeeded(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_SUCCEEDED] = true;+  s->cbs = NULL;+  execute_from_storage(s);+}++/*+  Cronet callback+*/+static void on_request_headers_sent(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""W: on_request_headers_sent(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  s->state.state_op_done[OP_SEND_INITIAL_METADATA] = true;+  s->state.state_callback_received[OP_SEND_INITIAL_METADATA] = true;+  /* Free the memory allocated for headers */+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  execute_from_storage(s); } -static void on_response_trailers_received(+/*+  Cronet callback+*/+static void on_response_headers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *trailers) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_trailers_received"");-  }+    const cronet_bidirectional_stream_header_array *headers,+    const char *negotiated_protocol) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_headers_received(%p, %p, %s)"", stream,+             headers, negotiated_protocol);   stream_obj *s = (stream_obj *)stream->annotation;--  memset(&s->imb, 0, sizeof(s->imb));-  grpc_chttp2_incoming_metadata_buffer_init(&s->imb);+  memset(&s->state.rs.initial_metadata, 0,+         sizeof(s->state.rs.initial_metadata));+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.initial_metadata);   unsigned int i = 0;-  for (i = 0; i < trailers->count; i++) {+  for (i = 0; i < headers->count; i++) {     grpc_chttp2_incoming_metadata_buffer_add(-        &s->imb, grpc_mdelem_from_metadata_strings(-                     grpc_mdstr_from_string(trailers->headers[i].key),-                     grpc_mdstr_from_string(trailers->headers[i].value)));+        &s->state.rs.initial_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(headers->headers[i].key),+            grpc_mdstr_from_string(headers->headers[i].value)));   }-  s->response_trailers_received = true;-  next_recv_step(s, ON_RESPONSE_TRAILERS_RECEIVED);+  s->state.state_callback_received[OP_RECV_INITIAL_METADATA] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_write_completed(cronet_bidirectional_stream *stream,                                const char *data) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_write_completed"");-  }   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_MESSAGE]);-  s->cronet_send_state = CRONET_WRITE_COMPLETED;-  next_send_step(s);-}--static void process_recv_message(stream_obj *s, const uint8_t *recv_data) {-  gpr_slice read_data_slice = gpr_slice_malloc((uint32_t)s->total_read_bytes);-  uint8_t *dst_p = GPR_SLICE_START_PTR(read_data_slice);-  if (s->total_read_bytes > 0) {-    // Only copy if there is non-zero number of bytes-    memcpy(dst_p, recv_data, (size_t)s->total_read_bytes);-    gpr_slice_buffer_add(&s->read_slice_buffer, read_data_slice);+  CRONET_LOG(GPR_DEBUG, ""W: on_write_completed(%p, %s)"", stream, data);+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }-  grpc_slice_buffer_stream_init(&s->sbs, &s->read_slice_buffer, 0);-  *s->recv_message = (grpc_byte_buffer *)&s->sbs;-}--static int parse_grpc_header(const uint8_t *data) {-  const uint8_t *p = data + 1;-  int length = 0;-  length |= ((uint8_t)*p++) << 24;-  length |= ((uint8_t)*p++) << 16;-  length |= ((uint8_t)*p++) << 8;-  length |= ((uint8_t)*p++);-  return length;+  s->state.state_callback_received[OP_SEND_MESSAGE] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_read_completed(cronet_bidirectional_stream *stream, char *data,                               int count) {   stream_obj *s = (stream_obj *)stream->annotation;-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_read_completed count=%d, total=%d, remaining=%d"",-            count, s->total_read_bytes, s->remaining_read_bytes);-  }+  CRONET_LOG(GPR_DEBUG, ""R: on_read_completed(%p, %p, %d)"", stream, data,+             count);+  s->state.state_callback_received[OP_RECV_MESSAGE] = true;   if (count > 0) {-    GPR_ASSERT(s->recv_message);-    s->remaining_read_bytes -= count;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.received_bytes += count;+    s->state.rs.remaining_bytes -= count;+    if (s->state.rs.remaining_bytes > 0) {+      CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_read(%p)"", s->cbs);+      s->state.state_op_done[OP_READ_REQ_MADE] = true;+      cronet_bidirectional_stream_read(+          s->cbs, s->state.rs.read_buffer + s->state.rs.received_bytes,+          s->state.rs.remaining_bytes);+    } else {+      execute_from_storage(s);+    }   } else {-    s->read_closed = true;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.read_stream_closed = true;+    execute_from_storage(s);   } } -static void on_response_headers_received(+/*+  Cronet callback+*/+static void on_response_trailers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *headers,-    const char *negotiated_protocol) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_headers_received"");-  }-  stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_RECV_INITIAL_METADATA]);-  s->response_headers_received = true;-  next_recv_step(s, ON_RESPONSE_HEADERS_RECEIVED);-}--static void on_request_headers_sent(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_request_headers_sent"");-  }+    const cronet_bidirectional_stream_header_array *trailers) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_trailers_received(%p,%p)"", stream,+             trailers);   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_INITIAL_METADATA]);-  s->cronet_send_state = CRONET_SEND_HEADER;-  next_send_step(s);-}--// Callback function pointers (invoked by cronet in response to events)-static cronet_bidirectional_stream_callback callbacks = {-    on_request_headers_sent,-    on_response_headers_received,-    on_read_completed,-    on_write_completed,-    on_response_trailers_received,-    on_succeeded,-    on_failed,-    on_canceled};--static void invoke_closing_callback(stream_obj *s) {-  grpc_chttp2_incoming_metadata_buffer_publish(&s->imb,-                                               s->recv_trailing_metadata);-  if (s->callback_list[CB_RECV_TRAILING_METADATA]) {-    enqueue_callbacks(s->callback_list[CB_RECV_TRAILING_METADATA]);-  }-}--static void set_recv_state(stream_obj *s, enum recv_state state) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""next_state = %s"", recv_state_name[state]);-  }-  s->cronet_recv_state = state;-}--// This is invoked from perform_stream_op, and all on_xxxx callbacks.-static void next_recv_step(stream_obj *s, enum e_caller caller) {-  gpr_mu_lock(&s->recv_mu);-  switch (s->cronet_recv_state) {-    case CRONET_RECV_IDLE:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_IDLE"");-      }-      if (caller == PERFORM_STREAM_OP ||-          caller == ON_RESPONSE_HEADERS_RECEIVED) {-        if (s->read_closed && s->response_trailers_received) {-          invoke_closing_callback(s);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else if (s->response_headers_received == true &&-                   s->read_requested == true) {-          set_recv_state(s, CRONET_RECV_READ_LENGTH);-          s->total_read_bytes = s->remaining_read_bytes =-              GRPC_HEADER_SIZE_IN_BYTES;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(s->cbs, s->read_buffer,-                                           s->remaining_read_bytes);-        }-      }-      break;-    case CRONET_RECV_READ_LENGTH:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_LENGTH"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->read_closed) {-          invoke_closing_callback(s);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else {-          GPR_ASSERT(s->remaining_read_bytes == 0);-          set_recv_state(s, CRONET_RECV_READ_DATA);-          s->total_read_bytes = s->remaining_read_bytes =-              parse_grpc_header((const uint8_t *)s->read_buffer);-          s->read_buffer =-              gpr_realloc(s->read_buffer, (uint32_t)s->remaining_read_bytes);-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          if (s->remaining_read_bytes > 0) {-            cronet_bidirectional_stream_read(s->cbs, (char *)s->read_buffer,-                                             s->remaining_read_bytes);-          } else {-            // Calling the closing callback directly since this is a 0 byte read-            // for an empty message.-            process_recv_message(s, NULL);-            enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-            invoke_closing_callback(s);-            set_recv_state(s, CRONET_RECV_CLOSED);-          }-        }-      }-      break;-    case CRONET_RECV_READ_DATA:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_DATA"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->remaining_read_bytes > 0) {-          int offset = s->total_read_bytes - s->remaining_read_bytes;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(-              s->cbs, (char *)s->read_buffer + offset, s->remaining_read_bytes);-        } else {-          gpr_slice_buffer_init(&s->read_slice_buffer);-          uint8_t *p = (uint8_t *)s->read_buffer;-          process_recv_message(s, p);-          set_recv_state(s, CRONET_RECV_IDLE);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-        }-      }-      break;-    case CRONET_RECV_CLOSED:-      break;-    default:-      GPR_ASSERT(0);  // Should not reach here-      break;+  memset(&s->state.rs.trailing_metadata, 0,+         sizeof(s->state.rs.trailing_metadata));+  s->state.rs.trailing_metadata_valid = false;+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.trailing_metadata);+  unsigned int i = 0;+  for (i = 0; i < trailers->count; i++) {+    CRONET_LOG(GPR_DEBUG, ""trailer key=%s, value=%s"", trailers->headers[i].key,+               trailers->headers[i].value);+    grpc_chttp2_incoming_metadata_buffer_add(+        &s->state.rs.trailing_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(trailers->headers[i].key),+            grpc_mdstr_from_string(trailers->headers[i].value)));+    s->state.rs.trailing_metadata_valid = true;   }-  gpr_mu_unlock(&s->recv_mu);+  s->state.state_callback_received[OP_RECV_TRAILING_METADATA] = true;+  execute_from_storage(s); } -// This function takes the data from s->write_slice_buffer and assembles into-// a contiguous byte stream with 5 byte gRPC header prepended.-static void create_grpc_frame(stream_obj *s) {-  gpr_slice slice = gpr_slice_buffer_take_first(&s->write_slice_buffer);-  uint8_t *raw_data = GPR_SLICE_START_PTR(slice);+/*+ Utility function that takes the data from s->write_slice_buffer and assembles+ into a contiguous byte stream with 5 byte gRPC header prepended.+*/+static void create_grpc_frame(gpr_slice_buffer *write_slice_buffer,+                              char **pp_write_buffer,+                              int *p_write_buffer_size) {+  gpr_slice slice = gpr_slice_buffer_take_first(write_slice_buffer);   size_t length = GPR_SLICE_LENGTH(slice);-  s->write_buffer_size = length + GRPC_HEADER_SIZE_IN_BYTES;-  s->write_buffer = gpr_realloc(s->write_buffer, s->write_buffer_size);-  uint8_t *p = (uint8_t *)s->write_buffer;-  // Append 5 byte header+  *p_write_buffer_size = (int)length + GRPC_HEADER_SIZE_IN_BYTES;+  /* This is freed in the on_write_completed callback */+  char *write_buffer = gpr_malloc(length + GRPC_HEADER_SIZE_IN_BYTES);+  *pp_write_buffer = write_buffer;+  uint8_t *p = (uint8_t *)write_buffer;+  /* Append 5 byte header */   *p++ = 0;   *p++ = (uint8_t)(length >> 24);   *p++ = (uint8_t)(length >> 16);   *p++ = (uint8_t)(length >> 8);   *p++ = (uint8_t)(length);-  // append actual data-  memcpy(p, raw_data, length);+  /* append actual data */+  memcpy(p, GPR_SLICE_START_PTR(slice), length); } -static void do_write(stream_obj *s) {-  gpr_slice_buffer *sb = &s->write_slice_buffer;-  GPR_ASSERT(sb->count <= 1);-  if (sb->count > 0) {-    create_grpc_frame(s);-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""W: cronet_bidirectional_stream_write"");-    }-    cronet_bidirectional_stream_write(s->cbs, s->write_buffer,-                                      (int)s->write_buffer_size, false);-  }-}--//-static void next_send_step(stream_obj *s) {-  switch (s->cronet_send_state) {-    case CRONET_SEND_IDLE:-      GPR_ASSERT(-          s->cbs);  // cronet_bidirectional_stream is not initialized yet.-      s->cronet_send_state = CRONET_REQ_STARTED;-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_bidirectional_stream_start to %s"", s->url);-      }-      cronet_bidirectional_stream_start(s->cbs, s->url, 0, ""POST"",-                                        &s->header_array, false);-      // we no longer need the memory that was allocated earlier.-      gpr_free(s->header_array.headers);-      break;-    case CRONET_SEND_HEADER:-      do_write(s);-      s->cronet_send_state = CRONET_WRITE;-      break;-    case CRONET_WRITE_COMPLETED:-      do_write(s);-      break;-    default:-      GPR_ASSERT(0);-      break;-  }-}--static void convert_metadata_to_cronet_headers(grpc_linked_mdelem *head,-                                               const char *host,-                                               stream_obj *s) {+/*+ Convert metadata in a format that Cronet can consume+*/+static void convert_metadata_to_cronet_headers(+    grpc_linked_mdelem *head, const char *host, char **pp_url,+    cronet_bidirectional_stream_header **pp_headers, size_t *p_num_headers) {   grpc_linked_mdelem *curr = head;-  // Walk the linked list and get number of header fields+  /* Walk the linked list and get number of header fields */   uint32_t num_headers_available = 0;   while (curr != NULL) {     curr = curr->next;     num_headers_available++;   }-  // Allocate enough memory-  s->headers = (cronet_bidirectional_stream_header *)gpr_malloc(-      sizeof(cronet_bidirectional_stream_header) * num_headers_available);--  // Walk the linked list again, this time copying the header fields.-  // s->num_headers-  // can be less than num_headers_available, as some headers are not used for-  // cronet+  /* Allocate enough memory. It is freed in the on_request_headers_sent callback+   */+  cronet_bidirectional_stream_header *headers =+      (cronet_bidirectional_stream_header *)gpr_malloc(+          sizeof(cronet_bidirectional_stream_header) * num_headers_available);+  *pp_headers = headers;++  /* Walk the linked list again, this time copying the header fields.+    s->num_headers can be less than num_headers_available, as some headers+    are not used for cronet+   */   curr = head;-  s->num_headers = 0;-  while (s->num_headers < num_headers_available) {+  int num_headers = 0;+  while (num_headers < num_headers_available) {     grpc_mdelem *mdelem = curr->md;     curr = curr->next;     const char *key = grpc_mdstr_as_c_string(mdelem->key);     const char *value = grpc_mdstr_as_c_string(mdelem->value);     if (strcmp(key, "":scheme"") == 0 || strcmp(key, "":method"") == 0 ||         strcmp(key, "":authority"") == 0) {-      // Cronet populates these fields on its own.+      /* Cronet populates these fields on its own */       continue;     }     if (strcmp(key, "":path"") == 0) {-      // Create URL by appending :path value to the hostname-      gpr_asprintf(&s->url, ""https://%s%s"", host, value);-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""extracted URL = %s"", s->url);-      }+      /* Create URL by appending :path value to the hostname */+      gpr_asprintf(pp_url, ""https://%s%s"", host, value);       continue;     }-    s->headers[s->num_headers].key = key;-    s->headers[s->num_headers].value = value;-    s->num_headers++;+    CRONET_LOG(GPR_DEBUG, ""header %s = %s"", key, value);+    headers[num_headers].key = key;+    headers[num_headers].value = value;+    num_headers++;     if (curr == NULL) {       break;     }   }+  *p_num_headers = num_headers; } -static void perform_stream_op(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                              grpc_stream *gs, grpc_transport_stream_op *op) {-  grpc_cronet_transport *ct = (grpc_cronet_transport *)gt;-  GPR_ASSERT(ct->engine);-  stream_obj *s = (stream_obj *)gs;-  if (op->recv_trailing_metadata) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG,-              ""perform_stream_op - recv_trailing_metadata: on_complete=%p"",-              op->on_complete);-    }-    s->recv_trailing_metadata = op->recv_trailing_metadata;-    GPR_ASSERT(!s->callback_list[CB_RECV_TRAILING_METADATA][0]);-    s->callback_list[CB_RECV_TRAILING_METADATA][0] = op->on_complete;-  }-  if (op->recv_message) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""perform_stream_op - recv_message: on_complete=%p"",-              op->on_complete);+static int parse_grpc_header(const uint8_t *data) {+  const uint8_t *p = data + 1;+  int length = 0;+  length |= ((uint8_t)*p++) << 24;+  length |= ((uint8_t)*p++) << 16;+  length |= ((uint8_t)*p++) << 8;+  length |= ((uint8_t)*p++);+  return length;+}++/*+  Op Execution: Decide if one of the actions contained in the stream op can be+  executed. This is the heart of the state machine.+*/+static bool op_can_be_run(grpc_transport_stream_op *curr_op,+                          struct op_state *stream_state,+                          struct op_state *op_state, enum OP_ID op_id) {+  bool result = true;+  /* When call is canceled, every op can be run, except under following+  conditions+  */+  if (stream_state->state_op_done[OP_CANCEL_ERROR] ||",style: i'd extract the body of the if condition into a bool variable like `is_cancelled_or_failed`. I think it improves readability.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75046601,2016-08-17T00:42:36Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable-int grpc_cronet_trace = 1;+#define CRONET_LOG(...)                          \+  do {                                           \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  } while (0)++/* TODO (makdharma): Hook up into the wider tracing mechanism */+int grpc_cronet_trace = 0;++enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled}; -// Cronet transport object+/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; +  /* Stream level state. Some state will be tracked both at stream and stream_op+   * level */+  struct op_state state;++  /* OP storage */+  struct op_storage storage;++  /* Mutex to protect storage */+  gpr_mu mu;+}; typedef struct stream_obj stream_obj; -static void next_send_step(stream_obj *s);-static void next_recv_step(stream_obj *s, enum e_caller caller);+static enum OP_RESULT execute_stream_op(grpc_exec_ctx *exec_ctx,+                                        struct op_and_state *oas); -static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                                   grpc_stream *gs, grpc_pollset *pollset) {}+/*+  Add a new stream op to op storage.+*/+static void add_to_storage(struct stream_obj *s, grpc_transport_stream_op *op) {+  gpr_mu_lock(&s->mu);+  struct op_storage *storage = &s->storage;+  /* add new op at the beginning of the linked list. The memory is freed+  in remove_from_storage */+  struct op_and_state *new_op = gpr_malloc(sizeof(struct op_and_state));+  memcpy(&new_op->op, op, sizeof(grpc_transport_stream_op));+  memset(&new_op->state, 0, sizeof(new_op->state));+  new_op->s = s;+  new_op->done = false;+  new_op->next = storage->head;+  storage->head = new_op;+  storage->num_pending_ops++;+  CRONET_LOG(GPR_DEBUG, ""adding new op %p. %d in the queue."", new_op,+             storage->num_pending_ops);+  gpr_mu_unlock(&s->mu);+} -static void set_pollset_set_do_nothing(grpc_exec_ctx *exec_ctx,-                                       grpc_transport *gt, grpc_stream *gs,-                                       grpc_pollset_set *pollset_set) {}+/*+  Traverse the linked list and delete op and free memory+*/+static void remove_from_storage(struct stream_obj *s,+                                struct op_and_state *oas) {+  struct op_and_state *curr;+  if (s->storage.head == NULL || oas == NULL) {+    return;+  }+  if (s->storage.head == oas) {+    s->storage.head = oas->next;+    gpr_free(oas);+    s->storage.num_pending_ops--;+    CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+               s->storage.num_pending_ops);+  } else {+    for (curr = s->storage.head; curr != NULL; curr = curr->next) {+      if (curr->next == oas) {+        curr->next = oas->next;+        s->storage.num_pending_ops--;+        CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+                   s->storage.num_pending_ops);+        gpr_free(oas);+        break;+      } else if (curr->next == NULL) {+        CRONET_LOG(GPR_ERROR, ""Reached end of LL and did not find op to free"");+      }+    }+  }+} -static void enqueue_callbacks(grpc_closure *callback_list[]) {+/*+  Cycle through ops and try to take next action. Break when either+  an action with callback is taken, or no action is possible.+  This can be executed from the Cronet network thread via cronet callback+  or on the application supplied thread via the perform_stream_op function.+*/+static void execute_from_storage(stream_obj *s) {   grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;-  if (callback_list[0]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[0], GRPC_ERROR_NONE, NULL);-    callback_list[0] = NULL;-  }-  if (callback_list[1]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[1], GRPC_ERROR_NONE, NULL);-    callback_list[1] = NULL;+  gpr_mu_lock(&s->mu);+  for (struct op_and_state *curr = s->storage.head; curr != NULL;) {+    CRONET_LOG(GPR_DEBUG, ""calling op at %p. done = %d"", curr, curr->done);+    GPR_ASSERT(curr->done == 0);+    enum OP_RESULT result = execute_stream_op(&exec_ctx, curr);+    CRONET_LOG(GPR_DEBUG, ""execute_stream_op[%p] returns %s"", curr,+               op_result_string[result]);+    /* if this op is done, then remove it and free memory */+    if (curr->done) {+      struct op_and_state *next = curr->next;+      remove_from_storage(s, curr);+      curr = next;+    }+    /* continue processing the same op if ACTION_TAKEN_WITHOUT_CALLBACK */+    if (result == NO_ACTION_POSSIBLE) {+      curr = curr->next;+    } else if (result == ACTION_TAKEN_WITH_CALLBACK) {+      break;+    }   }+  gpr_mu_unlock(&s->mu);   grpc_exec_ctx_finish(&exec_ctx); } -static void on_canceled(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_canceled %p"", stream);+/*+  Cronet callback+*/+static void on_failed(cronet_bidirectional_stream *stream, int net_error) {+  CRONET_LOG(GPR_DEBUG, ""on_failed(%p, %d)"", stream, net_error);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_FAILED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;+  }+  execute_from_storage(s); } -static void on_failed(cronet_bidirectional_stream *stream, int net_error) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_failed %p, error = %d"", stream, net_error);+/*+  Cronet callback+*/+static void on_canceled(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""on_canceled(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_CANCELED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;+  }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_succeeded(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_succeeded %p"", stream);+  CRONET_LOG(GPR_DEBUG, ""on_succeeded(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_SUCCEEDED] = true;+  s->cbs = NULL;+  execute_from_storage(s);+}++/*+  Cronet callback+*/+static void on_request_headers_sent(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""W: on_request_headers_sent(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  s->state.state_op_done[OP_SEND_INITIAL_METADATA] = true;+  s->state.state_callback_received[OP_SEND_INITIAL_METADATA] = true;+  /* Free the memory allocated for headers */+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  execute_from_storage(s); } -static void on_response_trailers_received(+/*+  Cronet callback+*/+static void on_response_headers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *trailers) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_trailers_received"");-  }+    const cronet_bidirectional_stream_header_array *headers,+    const char *negotiated_protocol) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_headers_received(%p, %p, %s)"", stream,+             headers, negotiated_protocol);   stream_obj *s = (stream_obj *)stream->annotation;--  memset(&s->imb, 0, sizeof(s->imb));-  grpc_chttp2_incoming_metadata_buffer_init(&s->imb);+  memset(&s->state.rs.initial_metadata, 0,+         sizeof(s->state.rs.initial_metadata));+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.initial_metadata);   unsigned int i = 0;-  for (i = 0; i < trailers->count; i++) {+  for (i = 0; i < headers->count; i++) {     grpc_chttp2_incoming_metadata_buffer_add(-        &s->imb, grpc_mdelem_from_metadata_strings(-                     grpc_mdstr_from_string(trailers->headers[i].key),-                     grpc_mdstr_from_string(trailers->headers[i].value)));+        &s->state.rs.initial_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(headers->headers[i].key),+            grpc_mdstr_from_string(headers->headers[i].value)));   }-  s->response_trailers_received = true;-  next_recv_step(s, ON_RESPONSE_TRAILERS_RECEIVED);+  s->state.state_callback_received[OP_RECV_INITIAL_METADATA] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_write_completed(cronet_bidirectional_stream *stream,                                const char *data) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_write_completed"");-  }   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_MESSAGE]);-  s->cronet_send_state = CRONET_WRITE_COMPLETED;-  next_send_step(s);-}--static void process_recv_message(stream_obj *s, const uint8_t *recv_data) {-  gpr_slice read_data_slice = gpr_slice_malloc((uint32_t)s->total_read_bytes);-  uint8_t *dst_p = GPR_SLICE_START_PTR(read_data_slice);-  if (s->total_read_bytes > 0) {-    // Only copy if there is non-zero number of bytes-    memcpy(dst_p, recv_data, (size_t)s->total_read_bytes);-    gpr_slice_buffer_add(&s->read_slice_buffer, read_data_slice);+  CRONET_LOG(GPR_DEBUG, ""W: on_write_completed(%p, %s)"", stream, data);+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }-  grpc_slice_buffer_stream_init(&s->sbs, &s->read_slice_buffer, 0);-  *s->recv_message = (grpc_byte_buffer *)&s->sbs;-}--static int parse_grpc_header(const uint8_t *data) {-  const uint8_t *p = data + 1;-  int length = 0;-  length |= ((uint8_t)*p++) << 24;-  length |= ((uint8_t)*p++) << 16;-  length |= ((uint8_t)*p++) << 8;-  length |= ((uint8_t)*p++);-  return length;+  s->state.state_callback_received[OP_SEND_MESSAGE] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_read_completed(cronet_bidirectional_stream *stream, char *data,                               int count) {   stream_obj *s = (stream_obj *)stream->annotation;-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_read_completed count=%d, total=%d, remaining=%d"",-            count, s->total_read_bytes, s->remaining_read_bytes);-  }+  CRONET_LOG(GPR_DEBUG, ""R: on_read_completed(%p, %p, %d)"", stream, data,+             count);+  s->state.state_callback_received[OP_RECV_MESSAGE] = true;   if (count > 0) {-    GPR_ASSERT(s->recv_message);-    s->remaining_read_bytes -= count;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.received_bytes += count;+    s->state.rs.remaining_bytes -= count;+    if (s->state.rs.remaining_bytes > 0) {+      CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_read(%p)"", s->cbs);+      s->state.state_op_done[OP_READ_REQ_MADE] = true;+      cronet_bidirectional_stream_read(+          s->cbs, s->state.rs.read_buffer + s->state.rs.received_bytes,+          s->state.rs.remaining_bytes);+    } else {+      execute_from_storage(s);+    }   } else {-    s->read_closed = true;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.read_stream_closed = true;+    execute_from_storage(s);   } } -static void on_response_headers_received(+/*+  Cronet callback+*/+static void on_response_trailers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *headers,-    const char *negotiated_protocol) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_headers_received"");-  }-  stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_RECV_INITIAL_METADATA]);-  s->response_headers_received = true;-  next_recv_step(s, ON_RESPONSE_HEADERS_RECEIVED);-}--static void on_request_headers_sent(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_request_headers_sent"");-  }+    const cronet_bidirectional_stream_header_array *trailers) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_trailers_received(%p,%p)"", stream,+             trailers);   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_INITIAL_METADATA]);-  s->cronet_send_state = CRONET_SEND_HEADER;-  next_send_step(s);-}--// Callback function pointers (invoked by cronet in response to events)-static cronet_bidirectional_stream_callback callbacks = {-    on_request_headers_sent,-    on_response_headers_received,-    on_read_completed,-    on_write_completed,-    on_response_trailers_received,-    on_succeeded,-    on_failed,-    on_canceled};--static void invoke_closing_callback(stream_obj *s) {-  grpc_chttp2_incoming_metadata_buffer_publish(&s->imb,-                                               s->recv_trailing_metadata);-  if (s->callback_list[CB_RECV_TRAILING_METADATA]) {-    enqueue_callbacks(s->callback_list[CB_RECV_TRAILING_METADATA]);-  }-}--static void set_recv_state(stream_obj *s, enum recv_state state) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""next_state = %s"", recv_state_name[state]);-  }-  s->cronet_recv_state = state;-}--// This is invoked from perform_stream_op, and all on_xxxx callbacks.-static void next_recv_step(stream_obj *s, enum e_caller caller) {-  gpr_mu_lock(&s->recv_mu);-  switch (s->cronet_recv_state) {-    case CRONET_RECV_IDLE:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_IDLE"");-      }-      if (caller == PERFORM_STREAM_OP ||-          caller == ON_RESPONSE_HEADERS_RECEIVED) {-        if (s->read_closed && s->response_trailers_received) {-          invoke_closing_callback(s);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else if (s->response_headers_received == true &&-                   s->read_requested == true) {-          set_recv_state(s, CRONET_RECV_READ_LENGTH);-          s->total_read_bytes = s->remaining_read_bytes =-              GRPC_HEADER_SIZE_IN_BYTES;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(s->cbs, s->read_buffer,-                                           s->remaining_read_bytes);-        }-      }-      break;-    case CRONET_RECV_READ_LENGTH:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_LENGTH"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->read_closed) {-          invoke_closing_callback(s);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else {-          GPR_ASSERT(s->remaining_read_bytes == 0);-          set_recv_state(s, CRONET_RECV_READ_DATA);-          s->total_read_bytes = s->remaining_read_bytes =-              parse_grpc_header((const uint8_t *)s->read_buffer);-          s->read_buffer =-              gpr_realloc(s->read_buffer, (uint32_t)s->remaining_read_bytes);-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          if (s->remaining_read_bytes > 0) {-            cronet_bidirectional_stream_read(s->cbs, (char *)s->read_buffer,-                                             s->remaining_read_bytes);-          } else {-            // Calling the closing callback directly since this is a 0 byte read-            // for an empty message.-            process_recv_message(s, NULL);-            enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-            invoke_closing_callback(s);-            set_recv_state(s, CRONET_RECV_CLOSED);-          }-        }-      }-      break;-    case CRONET_RECV_READ_DATA:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_DATA"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->remaining_read_bytes > 0) {-          int offset = s->total_read_bytes - s->remaining_read_bytes;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(-              s->cbs, (char *)s->read_buffer + offset, s->remaining_read_bytes);-        } else {-          gpr_slice_buffer_init(&s->read_slice_buffer);-          uint8_t *p = (uint8_t *)s->read_buffer;-          process_recv_message(s, p);-          set_recv_state(s, CRONET_RECV_IDLE);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-        }-      }-      break;-    case CRONET_RECV_CLOSED:-      break;-    default:-      GPR_ASSERT(0);  // Should not reach here-      break;+  memset(&s->state.rs.trailing_metadata, 0,+         sizeof(s->state.rs.trailing_metadata));+  s->state.rs.trailing_metadata_valid = false;+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.trailing_metadata);+  unsigned int i = 0;+  for (i = 0; i < trailers->count; i++) {+    CRONET_LOG(GPR_DEBUG, ""trailer key=%s, value=%s"", trailers->headers[i].key,+               trailers->headers[i].value);+    grpc_chttp2_incoming_metadata_buffer_add(+        &s->state.rs.trailing_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(trailers->headers[i].key),+            grpc_mdstr_from_string(trailers->headers[i].value)));+    s->state.rs.trailing_metadata_valid = true;   }-  gpr_mu_unlock(&s->recv_mu);+  s->state.state_callback_received[OP_RECV_TRAILING_METADATA] = true;+  execute_from_storage(s); } -// This function takes the data from s->write_slice_buffer and assembles into-// a contiguous byte stream with 5 byte gRPC header prepended.-static void create_grpc_frame(stream_obj *s) {-  gpr_slice slice = gpr_slice_buffer_take_first(&s->write_slice_buffer);-  uint8_t *raw_data = GPR_SLICE_START_PTR(slice);+/*+ Utility function that takes the data from s->write_slice_buffer and assembles+ into a contiguous byte stream with 5 byte gRPC header prepended.+*/+static void create_grpc_frame(gpr_slice_buffer *write_slice_buffer,+                              char **pp_write_buffer,+                              int *p_write_buffer_size) {+  gpr_slice slice = gpr_slice_buffer_take_first(write_slice_buffer);   size_t length = GPR_SLICE_LENGTH(slice);-  s->write_buffer_size = length + GRPC_HEADER_SIZE_IN_BYTES;-  s->write_buffer = gpr_realloc(s->write_buffer, s->write_buffer_size);-  uint8_t *p = (uint8_t *)s->write_buffer;-  // Append 5 byte header+  *p_write_buffer_size = (int)length + GRPC_HEADER_SIZE_IN_BYTES;+  /* This is freed in the on_write_completed callback */+  char *write_buffer = gpr_malloc(length + GRPC_HEADER_SIZE_IN_BYTES);+  *pp_write_buffer = write_buffer;+  uint8_t *p = (uint8_t *)write_buffer;+  /* Append 5 byte header */   *p++ = 0;   *p++ = (uint8_t)(length >> 24);   *p++ = (uint8_t)(length >> 16);   *p++ = (uint8_t)(length >> 8);   *p++ = (uint8_t)(length);-  // append actual data-  memcpy(p, raw_data, length);+  /* append actual data */+  memcpy(p, GPR_SLICE_START_PTR(slice), length); } -static void do_write(stream_obj *s) {-  gpr_slice_buffer *sb = &s->write_slice_buffer;-  GPR_ASSERT(sb->count <= 1);-  if (sb->count > 0) {-    create_grpc_frame(s);-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""W: cronet_bidirectional_stream_write"");-    }-    cronet_bidirectional_stream_write(s->cbs, s->write_buffer,-                                      (int)s->write_buffer_size, false);-  }-}--//-static void next_send_step(stream_obj *s) {-  switch (s->cronet_send_state) {-    case CRONET_SEND_IDLE:-      GPR_ASSERT(-          s->cbs);  // cronet_bidirectional_stream is not initialized yet.-      s->cronet_send_state = CRONET_REQ_STARTED;-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_bidirectional_stream_start to %s"", s->url);-      }-      cronet_bidirectional_stream_start(s->cbs, s->url, 0, ""POST"",-                                        &s->header_array, false);-      // we no longer need the memory that was allocated earlier.-      gpr_free(s->header_array.headers);-      break;-    case CRONET_SEND_HEADER:-      do_write(s);-      s->cronet_send_state = CRONET_WRITE;-      break;-    case CRONET_WRITE_COMPLETED:-      do_write(s);-      break;-    default:-      GPR_ASSERT(0);-      break;-  }-}--static void convert_metadata_to_cronet_headers(grpc_linked_mdelem *head,-                                               const char *host,-                                               stream_obj *s) {+/*+ Convert metadata in a format that Cronet can consume+*/+static void convert_metadata_to_cronet_headers(+    grpc_linked_mdelem *head, const char *host, char **pp_url,+    cronet_bidirectional_stream_header **pp_headers, size_t *p_num_headers) {   grpc_linked_mdelem *curr = head;-  // Walk the linked list and get number of header fields+  /* Walk the linked list and get number of header fields */   uint32_t num_headers_available = 0;   while (curr != NULL) {     curr = curr->next;     num_headers_available++;   }-  // Allocate enough memory-  s->headers = (cronet_bidirectional_stream_header *)gpr_malloc(-      sizeof(cronet_bidirectional_stream_header) * num_headers_available);--  // Walk the linked list again, this time copying the header fields.-  // s->num_headers-  // can be less than num_headers_available, as some headers are not used for-  // cronet+  /* Allocate enough memory. It is freed in the on_request_headers_sent callback+   */+  cronet_bidirectional_stream_header *headers =+      (cronet_bidirectional_stream_header *)gpr_malloc(+          sizeof(cronet_bidirectional_stream_header) * num_headers_available);+  *pp_headers = headers;++  /* Walk the linked list again, this time copying the header fields.+    s->num_headers can be less than num_headers_available, as some headers+    are not used for cronet+   */   curr = head;-  s->num_headers = 0;-  while (s->num_headers < num_headers_available) {+  int num_headers = 0;+  while (num_headers < num_headers_available) {     grpc_mdelem *mdelem = curr->md;     curr = curr->next;     const char *key = grpc_mdstr_as_c_string(mdelem->key);     const char *value = grpc_mdstr_as_c_string(mdelem->value);     if (strcmp(key, "":scheme"") == 0 || strcmp(key, "":method"") == 0 ||         strcmp(key, "":authority"") == 0) {-      // Cronet populates these fields on its own.+      /* Cronet populates these fields on its own */       continue;     }     if (strcmp(key, "":path"") == 0) {-      // Create URL by appending :path value to the hostname-      gpr_asprintf(&s->url, ""https://%s%s"", host, value);-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""extracted URL = %s"", s->url);-      }+      /* Create URL by appending :path value to the hostname */+      gpr_asprintf(pp_url, ""https://%s%s"", host, value);       continue;     }-    s->headers[s->num_headers].key = key;-    s->headers[s->num_headers].value = value;-    s->num_headers++;+    CRONET_LOG(GPR_DEBUG, ""header %s = %s"", key, value);+    headers[num_headers].key = key;+    headers[num_headers].value = value;+    num_headers++;     if (curr == NULL) {       break;     }   }+  *p_num_headers = num_headers; } -static void perform_stream_op(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                              grpc_stream *gs, grpc_transport_stream_op *op) {-  grpc_cronet_transport *ct = (grpc_cronet_transport *)gt;-  GPR_ASSERT(ct->engine);-  stream_obj *s = (stream_obj *)gs;-  if (op->recv_trailing_metadata) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG,-              ""perform_stream_op - recv_trailing_metadata: on_complete=%p"",-              op->on_complete);-    }-    s->recv_trailing_metadata = op->recv_trailing_metadata;-    GPR_ASSERT(!s->callback_list[CB_RECV_TRAILING_METADATA][0]);-    s->callback_list[CB_RECV_TRAILING_METADATA][0] = op->on_complete;-  }-  if (op->recv_message) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""perform_stream_op - recv_message: on_complete=%p"",-              op->on_complete);+static int parse_grpc_header(const uint8_t *data) {+  const uint8_t *p = data + 1;+  int length = 0;+  length |= ((uint8_t)*p++) << 24;+  length |= ((uint8_t)*p++) << 16;+  length |= ((uint8_t)*p++) << 8;+  length |= ((uint8_t)*p++);+  return length;+}++/*+  Op Execution: Decide if one of the actions contained in the stream op can be+  executed. This is the heart of the state machine.+*/+static bool op_can_be_run(grpc_transport_stream_op *curr_op,+                          struct op_state *stream_state,+                          struct op_state *op_state, enum OP_ID op_id) {+  bool result = true;+  /* When call is canceled, every op can be run, except under following+  conditions+  */+  if (stream_state->state_op_done[OP_CANCEL_ERROR] ||+      stream_state->state_callback_received[OP_FAILED]) {+    if (op_id == OP_SEND_INITIAL_METADATA) result = false;",This would function needs to be refactored into a state machine or something along those lines to make it more sane and readable. As it stands it looks difficult to maintain. TODO (provided it gets done :)) is fine to get things moving in the short term though.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7713,75047350,2016-08-17T00:51:21Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -51,612 +51,918 @@  #define GRPC_HEADER_SIZE_IN_BYTES 5 -// Global flag that gets set with GRPC_TRACE env variable-int grpc_cronet_trace = 1;+#define CRONET_LOG(...)                          \+  do {                                           \+    if (grpc_cronet_trace) gpr_log(__VA_ARGS__); \+  } while (0)++/* TODO (makdharma): Hook up into the wider tracing mechanism */+int grpc_cronet_trace = 0;++enum OP_RESULT {+  ACTION_TAKEN_WITH_CALLBACK,+  ACTION_TAKEN_NO_CALLBACK,+  NO_ACTION_POSSIBLE+};++/* Used for printing debug */+const char *op_result_string[] = {""ACTION_TAKEN_WITH_CALLBACK"",+                                  ""ACTION_TAKEN_NO_CALLBACK"",+                                  ""NO_ACTION_POSSIBLE""};++enum OP_ID {+  OP_SEND_INITIAL_METADATA = 0,+  OP_SEND_MESSAGE,+  OP_SEND_TRAILING_METADATA,+  OP_RECV_MESSAGE,+  OP_RECV_INITIAL_METADATA,+  OP_RECV_TRAILING_METADATA,+  OP_CANCEL_ERROR,+  OP_ON_COMPLETE,+  OP_FAILED,+  OP_SUCCEEDED,+  OP_CANCELED,+  OP_RECV_MESSAGE_AND_ON_COMPLETE,+  OP_READ_REQ_MADE,+  OP_NUM_OPS+};++const char *op_id_string[] = {""OP_SEND_INITIAL_METADATA"",+                              ""OP_SEND_MESSAGE"",+                              ""OP_SEND_TRAILING_METADATA"",+                              ""OP_RECV_MESSAGE"",+                              ""OP_RECV_INITIAL_METADATA"",+                              ""OP_RECV_TRAILING_METADATA"",+                              ""OP_CANCEL_ERROR"",+                              ""OP_ON_COMPLETE"",+                              ""OP_FAILED"",+                              ""OP_SUCCEEDED"",+                              ""OP_CANCELED"",+                              ""OP_RECV_MESSAGE_AND_ON_COMPLETE"",+                              ""OP_READ_REQ_MADE"",+                              ""OP_NUM_OPS""};++/* Cronet callbacks */++static void on_request_headers_sent(cronet_bidirectional_stream *);+static void on_response_headers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *, const char *);+static void on_write_completed(cronet_bidirectional_stream *, const char *);+static void on_read_completed(cronet_bidirectional_stream *, char *, int);+static void on_response_trailers_received(+    cronet_bidirectional_stream *,+    const cronet_bidirectional_stream_header_array *);+static void on_succeeded(cronet_bidirectional_stream *);+static void on_failed(cronet_bidirectional_stream *, int);+static void on_canceled(cronet_bidirectional_stream *);+static cronet_bidirectional_stream_callback cronet_callbacks = {+    on_request_headers_sent,+    on_response_headers_received,+    on_read_completed,+    on_write_completed,+    on_response_trailers_received,+    on_succeeded,+    on_failed,+    on_canceled}; -// Cronet transport object+/* Cronet transport object */ struct grpc_cronet_transport {   grpc_transport base; /* must be first element in this structure */   cronet_engine *engine;   char *host; };- typedef struct grpc_cronet_transport grpc_cronet_transport; -enum send_state {-  CRONET_SEND_IDLE = 0,-  CRONET_REQ_STARTED,-  CRONET_SEND_HEADER,-  CRONET_WRITE,-  CRONET_WRITE_COMPLETED,+struct read_state {+  /* vars to store data coming from server */+  char *read_buffer;+  bool length_field_received;+  int received_bytes;+  int remaining_bytes;+  int length_field;+  char grpc_header_bytes[GRPC_HEADER_SIZE_IN_BYTES];+  char *payload_field;+  bool read_stream_closed;++  /* vars for holding data destined for the application */+  struct grpc_slice_buffer_stream sbs;+  gpr_slice_buffer read_slice_buffer;++  /* vars for trailing metadata */+  grpc_chttp2_incoming_metadata_buffer trailing_metadata;+  bool trailing_metadata_valid;++  /* vars for initial metadata */+  grpc_chttp2_incoming_metadata_buffer initial_metadata; }; -enum recv_state {-  CRONET_RECV_IDLE = 0,-  CRONET_RECV_READ_LENGTH,-  CRONET_RECV_READ_DATA,-  CRONET_RECV_CLOSED,+struct write_state {+  char *write_buffer; }; -static const char *recv_state_name[] = {-    ""CRONET_RECV_IDLE"", ""CRONET_RECV_READ_LENGTH"", ""CRONET_RECV_READ_DATA,"",-    ""CRONET_RECV_CLOSED""};+/* track state of one stream op */+struct op_state {+  bool state_op_done[OP_NUM_OPS];+  bool state_callback_received[OP_NUM_OPS];+  /* data structure for storing data coming from server */+  struct read_state rs;+  /* data structure for storing data going to the server */+  struct write_state ws;+}; -// Enum that identifies calling function.-enum e_caller {-  PERFORM_STREAM_OP,-  ON_READ_COMPLETE,-  ON_RESPONSE_HEADERS_RECEIVED,-  ON_RESPONSE_TRAILERS_RECEIVED+struct op_and_state {+  grpc_transport_stream_op op;+  struct op_state state;+  bool done;+  struct stream_obj *s;      /* Pointer back to the stream object */+  struct op_and_state *next; /* next op_and_state in the linked list */ }; -enum callback_id {-  CB_SEND_INITIAL_METADATA = 0,-  CB_SEND_MESSAGE,-  CB_SEND_TRAILING_METADATA,-  CB_RECV_MESSAGE,-  CB_RECV_INITIAL_METADATA,-  CB_RECV_TRAILING_METADATA,-  CB_NUM_CALLBACKS+struct op_storage {+  int num_pending_ops;+  struct op_and_state *head; };  struct stream_obj {-  // we store received bytes here as they trickle in.-  gpr_slice_buffer write_slice_buffer;+  struct op_and_state *oas;+  grpc_transport_stream_op *curr_op;+  grpc_cronet_transport curr_ct;+  grpc_stream *curr_gs;   cronet_bidirectional_stream *cbs;-  gpr_slice slice;-  gpr_slice_buffer read_slice_buffer;-  struct grpc_slice_buffer_stream sbs;-  char *read_buffer;-  int remaining_read_bytes;-  int total_read_bytes;--  char *write_buffer;-  size_t write_buffer_size;--  // Hold the URL-  char *url;--  bool response_headers_received;-  bool read_requested;-  bool response_trailers_received;-  bool read_closed;--  // Recv message stuff-  grpc_byte_buffer **recv_message;-  // Initial metadata stuff-  grpc_metadata_batch *recv_initial_metadata;-  // Trailing metadata stuff-  grpc_metadata_batch *recv_trailing_metadata;-  grpc_chttp2_incoming_metadata_buffer imb;--  // This mutex protects receive state machine execution-  gpr_mu recv_mu;-  // we can queue up up to 2 callbacks for each OP-  grpc_closure *callback_list[CB_NUM_CALLBACKS][2];--  // storage for header-  cronet_bidirectional_stream_header *headers;-  uint32_t num_headers;   cronet_bidirectional_stream_header_array header_array;-  // state tracking-  enum recv_state cronet_recv_state;-  enum send_state cronet_send_state;-}; +  /* Stream level state. Some state will be tracked both at stream and stream_op+   * level */+  struct op_state state;++  /* OP storage */+  struct op_storage storage;++  /* Mutex to protect storage */+  gpr_mu mu;+}; typedef struct stream_obj stream_obj; -static void next_send_step(stream_obj *s);-static void next_recv_step(stream_obj *s, enum e_caller caller);+static enum OP_RESULT execute_stream_op(grpc_exec_ctx *exec_ctx,+                                        struct op_and_state *oas); -static void set_pollset_do_nothing(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                                   grpc_stream *gs, grpc_pollset *pollset) {}+/*+  Add a new stream op to op storage.+*/+static void add_to_storage(struct stream_obj *s, grpc_transport_stream_op *op) {+  gpr_mu_lock(&s->mu);+  struct op_storage *storage = &s->storage;+  /* add new op at the beginning of the linked list. The memory is freed+  in remove_from_storage */+  struct op_and_state *new_op = gpr_malloc(sizeof(struct op_and_state));+  memcpy(&new_op->op, op, sizeof(grpc_transport_stream_op));+  memset(&new_op->state, 0, sizeof(new_op->state));+  new_op->s = s;+  new_op->done = false;+  new_op->next = storage->head;+  storage->head = new_op;+  storage->num_pending_ops++;+  CRONET_LOG(GPR_DEBUG, ""adding new op %p. %d in the queue."", new_op,+             storage->num_pending_ops);+  gpr_mu_unlock(&s->mu);+} -static void set_pollset_set_do_nothing(grpc_exec_ctx *exec_ctx,-                                       grpc_transport *gt, grpc_stream *gs,-                                       grpc_pollset_set *pollset_set) {}+/*+  Traverse the linked list and delete op and free memory+*/+static void remove_from_storage(struct stream_obj *s,+                                struct op_and_state *oas) {+  struct op_and_state *curr;+  if (s->storage.head == NULL || oas == NULL) {+    return;+  }+  if (s->storage.head == oas) {+    s->storage.head = oas->next;+    gpr_free(oas);+    s->storage.num_pending_ops--;+    CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+               s->storage.num_pending_ops);+  } else {+    for (curr = s->storage.head; curr != NULL; curr = curr->next) {+      if (curr->next == oas) {+        curr->next = oas->next;+        s->storage.num_pending_ops--;+        CRONET_LOG(GPR_DEBUG, ""Freed %p. Now %d in the queue"", oas,+                   s->storage.num_pending_ops);+        gpr_free(oas);+        break;+      } else if (curr->next == NULL) {+        CRONET_LOG(GPR_ERROR, ""Reached end of LL and did not find op to free"");+      }+    }+  }+} -static void enqueue_callbacks(grpc_closure *callback_list[]) {+/*+  Cycle through ops and try to take next action. Break when either+  an action with callback is taken, or no action is possible.+  This can be executed from the Cronet network thread via cronet callback+  or on the application supplied thread via the perform_stream_op function.+*/+static void execute_from_storage(stream_obj *s) {   grpc_exec_ctx exec_ctx = GRPC_EXEC_CTX_INIT;-  if (callback_list[0]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[0], GRPC_ERROR_NONE, NULL);-    callback_list[0] = NULL;-  }-  if (callback_list[1]) {-    grpc_exec_ctx_sched(&exec_ctx, callback_list[1], GRPC_ERROR_NONE, NULL);-    callback_list[1] = NULL;+  gpr_mu_lock(&s->mu);+  for (struct op_and_state *curr = s->storage.head; curr != NULL;) {+    CRONET_LOG(GPR_DEBUG, ""calling op at %p. done = %d"", curr, curr->done);+    GPR_ASSERT(curr->done == 0);+    enum OP_RESULT result = execute_stream_op(&exec_ctx, curr);+    CRONET_LOG(GPR_DEBUG, ""execute_stream_op[%p] returns %s"", curr,+               op_result_string[result]);+    /* if this op is done, then remove it and free memory */+    if (curr->done) {+      struct op_and_state *next = curr->next;+      remove_from_storage(s, curr);+      curr = next;+    }+    /* continue processing the same op if ACTION_TAKEN_WITHOUT_CALLBACK */+    if (result == NO_ACTION_POSSIBLE) {+      curr = curr->next;+    } else if (result == ACTION_TAKEN_WITH_CALLBACK) {+      break;+    }   }+  gpr_mu_unlock(&s->mu);   grpc_exec_ctx_finish(&exec_ctx); } -static void on_canceled(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_canceled %p"", stream);+/*+  Cronet callback+*/+static void on_failed(cronet_bidirectional_stream *stream, int net_error) {+  CRONET_LOG(GPR_DEBUG, ""on_failed(%p, %d)"", stream, net_error);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_FAILED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;+  }+  execute_from_storage(s); } -static void on_failed(cronet_bidirectional_stream *stream, int net_error) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_failed %p, error = %d"", stream, net_error);+/*+  Cronet callback+*/+static void on_canceled(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""on_canceled(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_CANCELED] = true;+  s->cbs = NULL;+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;+  }+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_succeeded(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""on_succeeded %p"", stream);+  CRONET_LOG(GPR_DEBUG, ""on_succeeded(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  cronet_bidirectional_stream_destroy(s->cbs);+  s->state.state_callback_received[OP_SUCCEEDED] = true;+  s->cbs = NULL;+  execute_from_storage(s);+}++/*+  Cronet callback+*/+static void on_request_headers_sent(cronet_bidirectional_stream *stream) {+  CRONET_LOG(GPR_DEBUG, ""W: on_request_headers_sent(%p)"", stream);+  stream_obj *s = (stream_obj *)stream->annotation;+  s->state.state_op_done[OP_SEND_INITIAL_METADATA] = true;+  s->state.state_callback_received[OP_SEND_INITIAL_METADATA] = true;+  /* Free the memory allocated for headers */+  if (s->header_array.headers) {+    gpr_free(s->header_array.headers);+    s->header_array.headers = NULL;   }+  execute_from_storage(s); } -static void on_response_trailers_received(+/*+  Cronet callback+*/+static void on_response_headers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *trailers) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_trailers_received"");-  }+    const cronet_bidirectional_stream_header_array *headers,+    const char *negotiated_protocol) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_headers_received(%p, %p, %s)"", stream,+             headers, negotiated_protocol);   stream_obj *s = (stream_obj *)stream->annotation;--  memset(&s->imb, 0, sizeof(s->imb));-  grpc_chttp2_incoming_metadata_buffer_init(&s->imb);+  memset(&s->state.rs.initial_metadata, 0,+         sizeof(s->state.rs.initial_metadata));+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.initial_metadata);   unsigned int i = 0;-  for (i = 0; i < trailers->count; i++) {+  for (i = 0; i < headers->count; i++) {     grpc_chttp2_incoming_metadata_buffer_add(-        &s->imb, grpc_mdelem_from_metadata_strings(-                     grpc_mdstr_from_string(trailers->headers[i].key),-                     grpc_mdstr_from_string(trailers->headers[i].value)));+        &s->state.rs.initial_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(headers->headers[i].key),+            grpc_mdstr_from_string(headers->headers[i].value)));   }-  s->response_trailers_received = true;-  next_recv_step(s, ON_RESPONSE_TRAILERS_RECEIVED);+  s->state.state_callback_received[OP_RECV_INITIAL_METADATA] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_write_completed(cronet_bidirectional_stream *stream,                                const char *data) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_write_completed"");-  }   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_MESSAGE]);-  s->cronet_send_state = CRONET_WRITE_COMPLETED;-  next_send_step(s);-}--static void process_recv_message(stream_obj *s, const uint8_t *recv_data) {-  gpr_slice read_data_slice = gpr_slice_malloc((uint32_t)s->total_read_bytes);-  uint8_t *dst_p = GPR_SLICE_START_PTR(read_data_slice);-  if (s->total_read_bytes > 0) {-    // Only copy if there is non-zero number of bytes-    memcpy(dst_p, recv_data, (size_t)s->total_read_bytes);-    gpr_slice_buffer_add(&s->read_slice_buffer, read_data_slice);+  CRONET_LOG(GPR_DEBUG, ""W: on_write_completed(%p, %s)"", stream, data);+  if (s->state.ws.write_buffer) {+    gpr_free(s->state.ws.write_buffer);+    s->state.ws.write_buffer = NULL;   }-  grpc_slice_buffer_stream_init(&s->sbs, &s->read_slice_buffer, 0);-  *s->recv_message = (grpc_byte_buffer *)&s->sbs;-}--static int parse_grpc_header(const uint8_t *data) {-  const uint8_t *p = data + 1;-  int length = 0;-  length |= ((uint8_t)*p++) << 24;-  length |= ((uint8_t)*p++) << 16;-  length |= ((uint8_t)*p++) << 8;-  length |= ((uint8_t)*p++);-  return length;+  s->state.state_callback_received[OP_SEND_MESSAGE] = true;+  execute_from_storage(s); } +/*+  Cronet callback+*/ static void on_read_completed(cronet_bidirectional_stream *stream, char *data,                               int count) {   stream_obj *s = (stream_obj *)stream->annotation;-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_read_completed count=%d, total=%d, remaining=%d"",-            count, s->total_read_bytes, s->remaining_read_bytes);-  }+  CRONET_LOG(GPR_DEBUG, ""R: on_read_completed(%p, %p, %d)"", stream, data,+             count);+  s->state.state_callback_received[OP_RECV_MESSAGE] = true;   if (count > 0) {-    GPR_ASSERT(s->recv_message);-    s->remaining_read_bytes -= count;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.received_bytes += count;+    s->state.rs.remaining_bytes -= count;+    if (s->state.rs.remaining_bytes > 0) {+      CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_read(%p)"", s->cbs);+      s->state.state_op_done[OP_READ_REQ_MADE] = true;+      cronet_bidirectional_stream_read(+          s->cbs, s->state.rs.read_buffer + s->state.rs.received_bytes,+          s->state.rs.remaining_bytes);+    } else {+      execute_from_storage(s);+    }   } else {-    s->read_closed = true;-    next_recv_step(s, ON_READ_COMPLETE);+    s->state.rs.read_stream_closed = true;+    execute_from_storage(s);   } } -static void on_response_headers_received(+/*+  Cronet callback+*/+static void on_response_trailers_received(     cronet_bidirectional_stream *stream,-    const cronet_bidirectional_stream_header_array *headers,-    const char *negotiated_protocol) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""R: on_response_headers_received"");-  }-  stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_RECV_INITIAL_METADATA]);-  s->response_headers_received = true;-  next_recv_step(s, ON_RESPONSE_HEADERS_RECEIVED);-}--static void on_request_headers_sent(cronet_bidirectional_stream *stream) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""W: on_request_headers_sent"");-  }+    const cronet_bidirectional_stream_header_array *trailers) {+  CRONET_LOG(GPR_DEBUG, ""R: on_response_trailers_received(%p,%p)"", stream,+             trailers);   stream_obj *s = (stream_obj *)stream->annotation;-  enqueue_callbacks(s->callback_list[CB_SEND_INITIAL_METADATA]);-  s->cronet_send_state = CRONET_SEND_HEADER;-  next_send_step(s);-}--// Callback function pointers (invoked by cronet in response to events)-static cronet_bidirectional_stream_callback callbacks = {-    on_request_headers_sent,-    on_response_headers_received,-    on_read_completed,-    on_write_completed,-    on_response_trailers_received,-    on_succeeded,-    on_failed,-    on_canceled};--static void invoke_closing_callback(stream_obj *s) {-  grpc_chttp2_incoming_metadata_buffer_publish(&s->imb,-                                               s->recv_trailing_metadata);-  if (s->callback_list[CB_RECV_TRAILING_METADATA]) {-    enqueue_callbacks(s->callback_list[CB_RECV_TRAILING_METADATA]);-  }-}--static void set_recv_state(stream_obj *s, enum recv_state state) {-  if (grpc_cronet_trace) {-    gpr_log(GPR_DEBUG, ""next_state = %s"", recv_state_name[state]);-  }-  s->cronet_recv_state = state;-}--// This is invoked from perform_stream_op, and all on_xxxx callbacks.-static void next_recv_step(stream_obj *s, enum e_caller caller) {-  gpr_mu_lock(&s->recv_mu);-  switch (s->cronet_recv_state) {-    case CRONET_RECV_IDLE:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_IDLE"");-      }-      if (caller == PERFORM_STREAM_OP ||-          caller == ON_RESPONSE_HEADERS_RECEIVED) {-        if (s->read_closed && s->response_trailers_received) {-          invoke_closing_callback(s);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else if (s->response_headers_received == true &&-                   s->read_requested == true) {-          set_recv_state(s, CRONET_RECV_READ_LENGTH);-          s->total_read_bytes = s->remaining_read_bytes =-              GRPC_HEADER_SIZE_IN_BYTES;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(s->cbs, s->read_buffer,-                                           s->remaining_read_bytes);-        }-      }-      break;-    case CRONET_RECV_READ_LENGTH:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_LENGTH"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->read_closed) {-          invoke_closing_callback(s);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-          set_recv_state(s, CRONET_RECV_CLOSED);-        } else {-          GPR_ASSERT(s->remaining_read_bytes == 0);-          set_recv_state(s, CRONET_RECV_READ_DATA);-          s->total_read_bytes = s->remaining_read_bytes =-              parse_grpc_header((const uint8_t *)s->read_buffer);-          s->read_buffer =-              gpr_realloc(s->read_buffer, (uint32_t)s->remaining_read_bytes);-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          if (s->remaining_read_bytes > 0) {-            cronet_bidirectional_stream_read(s->cbs, (char *)s->read_buffer,-                                             s->remaining_read_bytes);-          } else {-            // Calling the closing callback directly since this is a 0 byte read-            // for an empty message.-            process_recv_message(s, NULL);-            enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-            invoke_closing_callback(s);-            set_recv_state(s, CRONET_RECV_CLOSED);-          }-        }-      }-      break;-    case CRONET_RECV_READ_DATA:-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_recv_state = CRONET_RECV_READ_DATA"");-      }-      if (caller == ON_READ_COMPLETE) {-        if (s->remaining_read_bytes > 0) {-          int offset = s->total_read_bytes - s->remaining_read_bytes;-          GPR_ASSERT(s->read_buffer);-          if (grpc_cronet_trace) {-            gpr_log(GPR_DEBUG, ""R: cronet_bidirectional_stream_read()"");-          }-          cronet_bidirectional_stream_read(-              s->cbs, (char *)s->read_buffer + offset, s->remaining_read_bytes);-        } else {-          gpr_slice_buffer_init(&s->read_slice_buffer);-          uint8_t *p = (uint8_t *)s->read_buffer;-          process_recv_message(s, p);-          set_recv_state(s, CRONET_RECV_IDLE);-          enqueue_callbacks(s->callback_list[CB_RECV_MESSAGE]);-        }-      }-      break;-    case CRONET_RECV_CLOSED:-      break;-    default:-      GPR_ASSERT(0);  // Should not reach here-      break;+  memset(&s->state.rs.trailing_metadata, 0,+         sizeof(s->state.rs.trailing_metadata));+  s->state.rs.trailing_metadata_valid = false;+  grpc_chttp2_incoming_metadata_buffer_init(&s->state.rs.trailing_metadata);+  unsigned int i = 0;+  for (i = 0; i < trailers->count; i++) {+    CRONET_LOG(GPR_DEBUG, ""trailer key=%s, value=%s"", trailers->headers[i].key,+               trailers->headers[i].value);+    grpc_chttp2_incoming_metadata_buffer_add(+        &s->state.rs.trailing_metadata,+        grpc_mdelem_from_metadata_strings(+            grpc_mdstr_from_string(trailers->headers[i].key),+            grpc_mdstr_from_string(trailers->headers[i].value)));+    s->state.rs.trailing_metadata_valid = true;   }-  gpr_mu_unlock(&s->recv_mu);+  s->state.state_callback_received[OP_RECV_TRAILING_METADATA] = true;+  execute_from_storage(s); } -// This function takes the data from s->write_slice_buffer and assembles into-// a contiguous byte stream with 5 byte gRPC header prepended.-static void create_grpc_frame(stream_obj *s) {-  gpr_slice slice = gpr_slice_buffer_take_first(&s->write_slice_buffer);-  uint8_t *raw_data = GPR_SLICE_START_PTR(slice);+/*+ Utility function that takes the data from s->write_slice_buffer and assembles+ into a contiguous byte stream with 5 byte gRPC header prepended.+*/+static void create_grpc_frame(gpr_slice_buffer *write_slice_buffer,+                              char **pp_write_buffer,+                              int *p_write_buffer_size) {+  gpr_slice slice = gpr_slice_buffer_take_first(write_slice_buffer);   size_t length = GPR_SLICE_LENGTH(slice);-  s->write_buffer_size = length + GRPC_HEADER_SIZE_IN_BYTES;-  s->write_buffer = gpr_realloc(s->write_buffer, s->write_buffer_size);-  uint8_t *p = (uint8_t *)s->write_buffer;-  // Append 5 byte header+  *p_write_buffer_size = (int)length + GRPC_HEADER_SIZE_IN_BYTES;+  /* This is freed in the on_write_completed callback */+  char *write_buffer = gpr_malloc(length + GRPC_HEADER_SIZE_IN_BYTES);+  *pp_write_buffer = write_buffer;+  uint8_t *p = (uint8_t *)write_buffer;+  /* Append 5 byte header */   *p++ = 0;   *p++ = (uint8_t)(length >> 24);   *p++ = (uint8_t)(length >> 16);   *p++ = (uint8_t)(length >> 8);   *p++ = (uint8_t)(length);-  // append actual data-  memcpy(p, raw_data, length);+  /* append actual data */+  memcpy(p, GPR_SLICE_START_PTR(slice), length); } -static void do_write(stream_obj *s) {-  gpr_slice_buffer *sb = &s->write_slice_buffer;-  GPR_ASSERT(sb->count <= 1);-  if (sb->count > 0) {-    create_grpc_frame(s);-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""W: cronet_bidirectional_stream_write"");-    }-    cronet_bidirectional_stream_write(s->cbs, s->write_buffer,-                                      (int)s->write_buffer_size, false);-  }-}--//-static void next_send_step(stream_obj *s) {-  switch (s->cronet_send_state) {-    case CRONET_SEND_IDLE:-      GPR_ASSERT(-          s->cbs);  // cronet_bidirectional_stream is not initialized yet.-      s->cronet_send_state = CRONET_REQ_STARTED;-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_bidirectional_stream_start to %s"", s->url);-      }-      cronet_bidirectional_stream_start(s->cbs, s->url, 0, ""POST"",-                                        &s->header_array, false);-      // we no longer need the memory that was allocated earlier.-      gpr_free(s->header_array.headers);-      break;-    case CRONET_SEND_HEADER:-      do_write(s);-      s->cronet_send_state = CRONET_WRITE;-      break;-    case CRONET_WRITE_COMPLETED:-      do_write(s);-      break;-    default:-      GPR_ASSERT(0);-      break;-  }-}--static void convert_metadata_to_cronet_headers(grpc_linked_mdelem *head,-                                               const char *host,-                                               stream_obj *s) {+/*+ Convert metadata in a format that Cronet can consume+*/+static void convert_metadata_to_cronet_headers(+    grpc_linked_mdelem *head, const char *host, char **pp_url,+    cronet_bidirectional_stream_header **pp_headers, size_t *p_num_headers) {   grpc_linked_mdelem *curr = head;-  // Walk the linked list and get number of header fields+  /* Walk the linked list and get number of header fields */   uint32_t num_headers_available = 0;   while (curr != NULL) {     curr = curr->next;     num_headers_available++;   }-  // Allocate enough memory-  s->headers = (cronet_bidirectional_stream_header *)gpr_malloc(-      sizeof(cronet_bidirectional_stream_header) * num_headers_available);--  // Walk the linked list again, this time copying the header fields.-  // s->num_headers-  // can be less than num_headers_available, as some headers are not used for-  // cronet+  /* Allocate enough memory. It is freed in the on_request_headers_sent callback+   */+  cronet_bidirectional_stream_header *headers =+      (cronet_bidirectional_stream_header *)gpr_malloc(+          sizeof(cronet_bidirectional_stream_header) * num_headers_available);+  *pp_headers = headers;++  /* Walk the linked list again, this time copying the header fields.+    s->num_headers can be less than num_headers_available, as some headers+    are not used for cronet+   */   curr = head;-  s->num_headers = 0;-  while (s->num_headers < num_headers_available) {+  int num_headers = 0;+  while (num_headers < num_headers_available) {     grpc_mdelem *mdelem = curr->md;     curr = curr->next;     const char *key = grpc_mdstr_as_c_string(mdelem->key);     const char *value = grpc_mdstr_as_c_string(mdelem->value);     if (strcmp(key, "":scheme"") == 0 || strcmp(key, "":method"") == 0 ||         strcmp(key, "":authority"") == 0) {-      // Cronet populates these fields on its own.+      /* Cronet populates these fields on its own */       continue;     }     if (strcmp(key, "":path"") == 0) {-      // Create URL by appending :path value to the hostname-      gpr_asprintf(&s->url, ""https://%s%s"", host, value);-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""extracted URL = %s"", s->url);-      }+      /* Create URL by appending :path value to the hostname */+      gpr_asprintf(pp_url, ""https://%s%s"", host, value);       continue;     }-    s->headers[s->num_headers].key = key;-    s->headers[s->num_headers].value = value;-    s->num_headers++;+    CRONET_LOG(GPR_DEBUG, ""header %s = %s"", key, value);+    headers[num_headers].key = key;+    headers[num_headers].value = value;+    num_headers++;     if (curr == NULL) {       break;     }   }+  *p_num_headers = num_headers; } -static void perform_stream_op(grpc_exec_ctx *exec_ctx, grpc_transport *gt,-                              grpc_stream *gs, grpc_transport_stream_op *op) {-  grpc_cronet_transport *ct = (grpc_cronet_transport *)gt;-  GPR_ASSERT(ct->engine);-  stream_obj *s = (stream_obj *)gs;-  if (op->recv_trailing_metadata) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG,-              ""perform_stream_op - recv_trailing_metadata: on_complete=%p"",-              op->on_complete);-    }-    s->recv_trailing_metadata = op->recv_trailing_metadata;-    GPR_ASSERT(!s->callback_list[CB_RECV_TRAILING_METADATA][0]);-    s->callback_list[CB_RECV_TRAILING_METADATA][0] = op->on_complete;-  }-  if (op->recv_message) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""perform_stream_op - recv_message: on_complete=%p"",-              op->on_complete);+static int parse_grpc_header(const uint8_t *data) {+  const uint8_t *p = data + 1;+  int length = 0;+  length |= ((uint8_t)*p++) << 24;+  length |= ((uint8_t)*p++) << 16;+  length |= ((uint8_t)*p++) << 8;+  length |= ((uint8_t)*p++);+  return length;+}++/*+  Op Execution: Decide if one of the actions contained in the stream op can be+  executed. This is the heart of the state machine.+*/+static bool op_can_be_run(grpc_transport_stream_op *curr_op,+                          struct op_state *stream_state,+                          struct op_state *op_state, enum OP_ID op_id) {+  bool result = true;+  /* When call is canceled, every op can be run, except under following+  conditions+  */+  if (stream_state->state_op_done[OP_CANCEL_ERROR] ||+      stream_state->state_callback_received[OP_FAILED]) {+    if (op_id == OP_SEND_INITIAL_METADATA) result = false;+    if (op_id == OP_SEND_MESSAGE) result = false;+    if (op_id == OP_SEND_TRAILING_METADATA) result = false;+    if (op_id == OP_CANCEL_ERROR) result = false;+    /* already executed */+    if (op_id == OP_RECV_INITIAL_METADATA &&+        stream_state->state_op_done[OP_RECV_INITIAL_METADATA])+      result = false;+    if (op_id == OP_RECV_MESSAGE &&+        stream_state->state_op_done[OP_RECV_MESSAGE])+      result = false;+    if (op_id == OP_RECV_TRAILING_METADATA &&+        stream_state->state_op_done[OP_RECV_TRAILING_METADATA])+      result = false;+  } else if (op_id == OP_SEND_INITIAL_METADATA) {+    /* already executed */+    if (stream_state->state_op_done[OP_SEND_INITIAL_METADATA]) result = false;+  } else if (op_id == OP_RECV_INITIAL_METADATA) {+    /* already executed */+    if (stream_state->state_op_done[OP_RECV_INITIAL_METADATA]) result = false;+    /* we haven't sent headers yet. */+    else if (!stream_state->state_callback_received[OP_SEND_INITIAL_METADATA])+      result = false;+    /* we haven't received headers yet. */+    else if (!stream_state->state_callback_received[OP_RECV_INITIAL_METADATA])+      result = false;+  } else if (op_id == OP_SEND_MESSAGE) {+    /* already executed (note we're checking op specific state, not stream+     state) */+    if (op_state->state_op_done[OP_SEND_MESSAGE]) result = false;+    /* we haven't sent headers yet. */+    else if (!stream_state->state_callback_received[OP_SEND_INITIAL_METADATA])+      result = false;+  } else if (op_id == OP_RECV_MESSAGE) {+    /* already executed */+    if (op_state->state_op_done[OP_RECV_MESSAGE]) result = false;+    /* we haven't received headers yet. */+    else if (!stream_state->state_callback_received[OP_RECV_INITIAL_METADATA])+      result = false;+  } else if (op_id == OP_RECV_TRAILING_METADATA) {+    /* already executed */+    if (stream_state->state_op_done[OP_RECV_TRAILING_METADATA]) result = false;+    /* we have asked for but haven't received message yet. */+    else if (stream_state->state_op_done[OP_READ_REQ_MADE] &&+             !stream_state->state_op_done[OP_RECV_MESSAGE])+      result = false;+    /* we haven't received trailers  yet. */+    else if (!stream_state->state_callback_received[OP_RECV_TRAILING_METADATA])+      result = false;+    /* we haven't received on_succeeded  yet. */+    else if (!stream_state->state_callback_received[OP_SUCCEEDED])+      result = false;+  } else if (op_id == OP_SEND_TRAILING_METADATA) {+    /* already executed */+    if (stream_state->state_op_done[OP_SEND_TRAILING_METADATA]) result = false;+    /* we haven't sent initial metadata yet */+    else if (!stream_state->state_callback_received[OP_SEND_INITIAL_METADATA])+      result = false;+    /* we haven't sent message yet */+    else if (curr_op->send_message &&+             !stream_state->state_op_done[OP_SEND_MESSAGE])+      result = false;+    /* we haven't got on_write_completed for the send yet */+    else if (stream_state->state_op_done[OP_SEND_MESSAGE] &&+             !stream_state->state_callback_received[OP_SEND_MESSAGE])+      result = false;+  } else if (op_id == OP_CANCEL_ERROR) {+    /* already executed */+    if (stream_state->state_op_done[OP_CANCEL_ERROR]) result = false;+  } else if (op_id == OP_ON_COMPLETE) {+    /* already executed (note we're checking op specific state, not stream+    state) */+    if (op_state->state_op_done[OP_ON_COMPLETE]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;     }-    s->recv_message = (grpc_byte_buffer **)op->recv_message;-    GPR_ASSERT(!s->callback_list[CB_RECV_MESSAGE][0]);-    GPR_ASSERT(!s->callback_list[CB_RECV_MESSAGE][1]);-    s->callback_list[CB_RECV_MESSAGE][0] = op->recv_message_ready;-    s->callback_list[CB_RECV_MESSAGE][1] = op->on_complete;-    s->read_requested = true;-    next_recv_step(s, PERFORM_STREAM_OP);-  }-  if (op->recv_initial_metadata) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""perform_stream_op - recv_initial_metadata:=%p"",-              op->on_complete);+    /* Check if every op that was asked for is done. */+    else if (curr_op->send_initial_metadata &&+             !stream_state->state_callback_received[OP_SEND_INITIAL_METADATA]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;+    } else if (curr_op->send_message &&+               !op_state->state_op_done[OP_SEND_MESSAGE]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;+    } else if (curr_op->send_message &&+               !stream_state->state_callback_received[OP_SEND_MESSAGE]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;+    } else if (curr_op->send_trailing_metadata &&+               !stream_state->state_op_done[OP_SEND_TRAILING_METADATA]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;+    } else if (curr_op->recv_initial_metadata &&+               !stream_state->state_op_done[OP_RECV_INITIAL_METADATA]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;+    } else if (curr_op->recv_message &&+               !stream_state->state_op_done[OP_RECV_MESSAGE]) {+      CRONET_LOG(GPR_DEBUG, ""Because"");+      result = false;+    } else if (curr_op->recv_trailing_metadata) {+      /* We aren't done with trailing metadata yet */+      if (!stream_state->state_op_done[OP_RECV_TRAILING_METADATA]) {+        CRONET_LOG(GPR_DEBUG, ""Because"");+        result = false;+      }+      /* We've asked for actual message in an earlier op, and it hasn't been+        delivered yet. */+      else if (stream_state->state_op_done[OP_READ_REQ_MADE]) {+        /* If this op is not the one asking for read, (which means some earlier+          op has asked), and the read hasn't been delivered. */+        if (!curr_op->recv_message &&+            !stream_state->state_callback_received[OP_SUCCEEDED]) {+          CRONET_LOG(GPR_DEBUG, ""Because"");+          result = false;+        }+      }     }-    s->recv_initial_metadata = op->recv_initial_metadata;-    GPR_ASSERT(!s->callback_list[CB_RECV_INITIAL_METADATA][0]);-    GPR_ASSERT(!s->callback_list[CB_RECV_INITIAL_METADATA][1]);-    s->callback_list[CB_RECV_INITIAL_METADATA][0] =-        op->recv_initial_metadata_ready;-    s->callback_list[CB_RECV_INITIAL_METADATA][1] = op->on_complete;+    /* We should see at least one on_write_completed for the trailers that we+      sent */+    else if (curr_op->send_trailing_metadata &&+             !stream_state->state_callback_received[OP_SEND_MESSAGE])+      result = false;   }-  if (op->send_initial_metadata) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG,-              ""perform_stream_op - send_initial_metadata: on_complete=%p"",-              op->on_complete);+  CRONET_LOG(GPR_DEBUG, ""op_can_be_run %s : %s"", op_id_string[op_id],+             result ? ""YES"" : ""NO"");+  return result;+}++static enum OP_RESULT execute_stream_op(grpc_exec_ctx *exec_ctx,+                                        struct op_and_state *oas) {+  grpc_transport_stream_op *stream_op = &oas->op;+  struct stream_obj *s = oas->s;+  struct op_state *stream_state = &s->state;+  enum OP_RESULT result = NO_ACTION_POSSIBLE;+  if (stream_op->send_initial_metadata &&+      op_can_be_run(stream_op, stream_state, &oas->state,+                    OP_SEND_INITIAL_METADATA)) {+    CRONET_LOG(GPR_DEBUG, ""running: %p OP_SEND_INITIAL_METADATA"", oas);+    /* This OP is the beginning. Reset various states */+    memset(&s->header_array, 0, sizeof(s->header_array));+    memset(&stream_state->rs, 0, sizeof(stream_state->rs));+    memset(&stream_state->ws, 0, sizeof(stream_state->ws));+    memset(stream_state->state_op_done, 0, sizeof(stream_state->state_op_done));+    memset(stream_state->state_callback_received, 0,+           sizeof(stream_state->state_callback_received));+    /* Start new cronet stream. It is destroyed in on_succeeded, on_canceled,+     * on_failed */+    GPR_ASSERT(s->cbs == NULL);+    s->cbs = cronet_bidirectional_stream_create(s->curr_ct.engine, s->curr_gs,+                                                &cronet_callbacks);+    CRONET_LOG(GPR_DEBUG, ""%p = cronet_bidirectional_stream_create()"", s->cbs);+    char *url;+    s->header_array.headers = NULL;+    convert_metadata_to_cronet_headers(+        stream_op->send_initial_metadata->list.head, s->curr_ct.host, &url,+        &s->header_array.headers, &s->header_array.count);+    s->header_array.capacity = s->header_array.count;+    CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_start(%p, %s)"", s->cbs,+               url);+    cronet_bidirectional_stream_start(s->cbs, url, 0, ""POST"", &s->header_array,+                                      false);+    stream_state->state_op_done[OP_SEND_INITIAL_METADATA] = true;+    result = ACTION_TAKEN_WITH_CALLBACK;+  } else if (stream_op->recv_initial_metadata &&+             op_can_be_run(stream_op, stream_state, &oas->state,+                           OP_RECV_INITIAL_METADATA)) {+    CRONET_LOG(GPR_DEBUG, ""running: %p  OP_RECV_INITIAL_METADATA"", oas);+    if (!stream_state->state_op_done[OP_CANCEL_ERROR]) {+      grpc_chttp2_incoming_metadata_buffer_publish(+          &oas->s->state.rs.initial_metadata, stream_op->recv_initial_metadata);+      grpc_exec_ctx_sched(exec_ctx, stream_op->recv_initial_metadata_ready,+                          GRPC_ERROR_NONE, NULL);+    } else {+      grpc_exec_ctx_sched(exec_ctx, stream_op->recv_initial_metadata_ready,+                          GRPC_ERROR_CANCELLED, NULL);     }-    s->num_headers = 0;-    convert_metadata_to_cronet_headers(op->send_initial_metadata->list.head,-                                       ct->host, s);-    s->header_array.count = s->num_headers;-    s->header_array.capacity = s->num_headers;-    s->header_array.headers = s->headers;-    GPR_ASSERT(!s->callback_list[CB_SEND_INITIAL_METADATA][0]);-    s->callback_list[CB_SEND_INITIAL_METADATA][0] = op->on_complete;-  }-  if (op->send_message) {-    if (grpc_cronet_trace) {-      gpr_log(GPR_DEBUG, ""perform_stream_op - send_message: on_complete=%p"",-              op->on_complete);+    stream_state->state_op_done[OP_RECV_INITIAL_METADATA] = true;+    result = ACTION_TAKEN_NO_CALLBACK;+  } else if (stream_op->send_message &&+             op_can_be_run(stream_op, stream_state, &oas->state,+                           OP_SEND_MESSAGE)) {+    CRONET_LOG(GPR_DEBUG, ""running: %p  OP_SEND_MESSAGE"", oas);+    gpr_slice_buffer write_slice_buffer;+    gpr_slice slice;+    gpr_slice_buffer_init(&write_slice_buffer);+    grpc_byte_stream_next(NULL, stream_op->send_message, &slice,+                          stream_op->send_message->length, NULL);+    /* Check that compression flag is OFF. We don't support compression yet. */+    GPR_ASSERT(stream_op->send_message->flags == 0);+    gpr_slice_buffer_add(&write_slice_buffer, slice);+    GPR_ASSERT(write_slice_buffer.count ==+               1); /* Empty request not handled yet */+    if (write_slice_buffer.count > 0) {+      int write_buffer_size;+      create_grpc_frame(&write_slice_buffer, &stream_state->ws.write_buffer,+                        &write_buffer_size);+      CRONET_LOG(GPR_DEBUG, ""cronet_bidirectional_stream_write (%p, %p)"",+                 s->cbs, stream_state->ws.write_buffer);+      stream_state->state_callback_received[OP_SEND_MESSAGE] = false;+      cronet_bidirectional_stream_write(s->cbs, stream_state->ws.write_buffer,+                                        write_buffer_size, false);+      result = ACTION_TAKEN_WITH_CALLBACK;     }-    grpc_byte_stream_next(exec_ctx, op->send_message, &s->slice,-                          op->send_message->length, NULL);-    // Check that compression flag is not ON. We don't support compression yet.-    // TODO (makdharma): add compression support-    GPR_ASSERT(op->send_message->flags == 0);-    gpr_slice_buffer_add(&s->write_slice_buffer, s->slice);-    if (s->cbs == NULL) {-      if (grpc_cronet_trace) {-        gpr_log(GPR_DEBUG, ""cronet_bidirectional_stream_create"");+    stream_state->state_op_done[OP_SEND_MESSAGE] = true;+    oas->state.state_op_done[OP_SEND_MESSAGE] = true;+  } else if (stream_op->recv_message &&+             op_can_be_run(stream_op, stream_state, &oas->state,+                           OP_RECV_MESSAGE)) {+    CRONET_LOG(GPR_DEBUG, ""running: %p  OP_RECV_MESSAGE"", oas);+    if (stream_state->state_op_done[OP_CANCEL_ERROR]) {+      grpc_exec_ctx_sched(exec_ctx, stream_op->recv_message_ready,+                          GRPC_ERROR_CANCELLED, NULL);+      stream_state->state_op_done[OP_RECV_MESSAGE] = true;+    } else if (stream_state->rs.read_stream_closed == true) {+      /* No more data will be received */+      CRONET_LOG(GPR_DEBUG, ""read stream closed"");+      grpc_exec_ctx_sched(exec_ctx, stream_op->recv_message_ready,+                          GRPC_ERROR_NONE, NULL);+      stream_state->state_op_done[OP_RECV_MESSAGE] = true;+      oas->state.state_op_done[OP_RECV_MESSAGE] = true;+    } else if (stream_state->rs.length_field_received == false) {",These very long bodies of ifs and elses should probably be refactored into their own static functions to help with readability.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7616,75313578,2016-08-18T14:05:41Z,test/core/end2end/cq_verifier.c,"@@ -71,17 +70,16 @@ typedef struct expectation { struct cq_verifier {   /* bound completion queue */   grpc_completion_queue *cq;-  /* the root/sentinal expectation */-  expectation expect;+  /* expectation list */+  expectation *first_expectation;+  expectation *last_expectation;","No worries.It just occurred to me that there's not actually any reason we need to add the expectations to the end of the list, since the code that looks at the expectations doesn't care what order they're in.  So I've eliminated last_expectation and changed the code to add expectations to the start of the list instead.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7773,75347450,2016-08-18T17:04:59Z,src/cpp/util/byte_buffer.cc,"@@ -95,4 +102,10 @@ ByteBuffer& ByteBuffer::operator=(const ByteBuffer& buf) {   return *this; } +void ByteBuffer::Swap(ByteBuffer* other) {+  grpc_byte_buffer* tmp = other->buffer_;+  other->buffer_ = this->buffer_;","Yeah, I like an explanation wherever I see ""this"". There is at least 1 casewhere it's needed: template disambiguation. Aside from that, I tend tothink it's confusing. Will send a follow-on PR.On Thu, Aug 18, 2016 at 9:53 AM Mark D. Roth notifications@github.comwrote:> In src/cpp/util/byte_buffer.cc> https://github.com/grpc/grpc/pull/7773#discussion_r75345611:> > > @@ -95,4 +102,10 @@ ByteBuffer& ByteBuffer::operator=(const ByteBuffer& buf) {> >    return *this;> >  }> > > > +void ByteBuffer::Swap(ByteBuffer\* other) {> > -  grpc_byte_buffer\* tmp = other->buffer_;> > -  other->buffer_ = this->buffer_;> > Yeah, that shouldn't be necessary. I copied that from the internal CL and> didn't notice it before I merged. Feel free to send me a PR to fix it if it> bothers you.> > —> You are receiving this because you commented.> > Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7773/files/2665bdd6d29ec2515946ac629002c04c23a50bfa#r75345611,> or mute the thread> https://github.com/notifications/unsubscribe-auth/AIdEkJjQ_u_jjjlxxCjykq9s5ni2gIUZks5qhI4VgaJpZM4Jnln5> .",
10168793,m3bm3b,https://api.github.com/repos/grpc/grpc/pulls/7773,75352851,2016-08-18T17:36:39Z,src/cpp/util/byte_buffer.cc,"@@ -95,4 +102,10 @@ ByteBuffer& ByteBuffer::operator=(const ByteBuffer& buf) {   return *this; } +void ByteBuffer::Swap(ByteBuffer* other) {+  grpc_byte_buffer* tmp = other->buffer_;+  other->buffer_ = this->buffer_;","For the record, the reason I used ""this"" was to contrast with ""other"".When a method is accessing the fields of multiple instances, I find ithelps readability to make the instance explicit. Especially so when theinstances are used symmetrically, as theyare here:  that is,  x.Swap(y)  is equivalent to y.Swap(x).But of course, you should do whatever you feel makes it easier for you tounderstand.Thanks for taking the change.On 18 August 2016 at 10:05, Vijay Pai notifications@github.com wrote:> In src/cpp/util/byte_buffer.cc> https://github.com/grpc/grpc/pull/7773#discussion_r75347450:> > > @@ -95,4 +102,10 @@ ByteBuffer& ByteBuffer::operator=(const ByteBuffer& buf) {> >    return *this;> >  }> > > > +void ByteBuffer::Swap(ByteBuffer\* other) {> > -  grpc_byte_buffer\* tmp = other->buffer_;> > -  other->buffer_ = this->buffer_;> > Yeah, I like an explanation wherever I see ""this"". There is at least 1> case where it's needed: template disambiguation. Aside from that, I tend to> think it's confusing. Will send a follow-on PR.> … <#m_7421317622789186882_>> On Thu, Aug 18, 2016 at 9:53 AM Mark D. Roth **_@**_.***> wrote: In> src/cpp/util/byte_buffer.cc <#7773 (comment)> https://github.com/grpc/grpc/pull/7773#discussion_r75345611>: > @@> -95,4 +102,10 @@ ByteBuffer& ByteBuffer::operator=(const ByteBuffer& buf) {> > > return _this; > } > > +void ByteBuffer::Swap(ByteBuffer_ other) { > +> > grpc_byte_buffer\* tmp = other->buffer_; > + other->buffer_ = this->buffer_;> > Yeah, that shouldn't be necessary. I copied that from the internal CL and> > didn't notice it before I merged. Feel free to send me a PR to fix it if it> > bothers you. — You are receiving this because you commented. Reply to this> > email directly, view it on GitHub <https://github.com/grpc/grpc/> > pull/7773/files/2665bdd6d29ec2515946ac629002c04c23a50bfa#r75345611>, or> > mute the thread <https://github.com/notifications/unsubscribe-> > auth/AIdEkJjQ_u_jjjlxxCjykq9s5ni2gIUZks5qhI4VgaJpZM4Jnln5> .> > —> You are receiving this because you were mentioned.> Reply to this email directly, view it on GitHub> https://github.com/grpc/grpc/pull/7773/files/2665bdd6d29ec2515946ac629002c04c23a50bfa#r75347450,> or mute the thread> https://github.com/notifications/unsubscribe-auth/AJsp2RswEortmBMhcnJUiU02vgfYJT5bks5qhJDRgaJpZM4Jnln5> .",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7784,75399113,2016-08-18T22:11:44Z,examples/objective-c/auth_sample/AuthTestService.podspec,"@@ -14,7 +14,7 @@ Pod::Spec.new do |s|   src = ""../../protos""    # Run protoc with the Objective-C and gRPC plugins to generate protocol messages and gRPC clients.-  s.dependency ""!ProtoCompiler-gRPCPlugin"", ""~> 1.0.0-pre1.2""+  s.dependency ""!ProtoCompiler-gRPCPlugin"", ""~> 1.0""","For Cocoapods, `~> a.b.c.d` means ""version `a.b.c.x` for the biggest `x >= d`"". I.e. it only advances the right-most number.Semantic versioning says changes in the minor version number (the second number) are backwards-compatible, so the proper way to use semantic versioning with Cocoapods is `~> x.y`.For the prerelease versions, though, `1.0.0-anything` is < `1.0`, so we were forced to specify the whole thing.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7846,75939189,2016-08-23T19:58:58Z,include/grpc/impl/codegen/grpc_types.h,"@@ -127,7 +127,11 @@ typedef struct {     connection. Int valued. */ #define GRPC_ARG_MAX_CONCURRENT_STREAMS ""grpc.max_concurrent_streams"" /** Maximum message length that the channel can receive. Int valued, bytes. */-#define GRPC_ARG_MAX_MESSAGE_LENGTH ""grpc.max_message_length""+#define GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH ""grpc.max_receive_message_length""","Question: Is it okay to change the value of this parameter?  I've added a `#define' to provide API backward-compatibility, but changing the string here affects ABI compatibility.  I'm not sure how big of an issue that is.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/7842,75943170,2016-08-23T20:21:51Z,include/grpc++/impl/codegen/client_context.h,"@@ -307,6 +307,12 @@ class ClientContext {   };   static void SetGlobalCallbacks(GlobalCallbacks* callbacks); +  // Should be used for framework-level extensions only.+  // Applications never need to call this method.+  grpc_call* c_call() const {","In C we can easily extend the call API by exposing such a method:```grpc_my_extension* grpc_call_get_my_extension(grpc_call* call);```In C++, the `Server/ClientContext` is a class which is much harder to extend. @ctiller and I discussed this already. We _could_ have added a macro in the class definition but that felt really yucky. This alternative solution will allow us to do something like:```grpc::MyExtension* GetMyExtensionFromServerContext(grpc::ServerContext* ctx);```which seems better overall.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/7912,76667987,2016-08-29T19:09:58Z,build.yaml,"@@ -7,6 +7,7 @@ settings:   '#3': Use ""-preN"" suffixes to identify pre-release versions   '#4': Per-language overrides are possible with (eg) ruby_version tag here   '#5': See the expand_version.py for all the quirks here+  g_stands_for: good",This is temporary. In another release we'll use 'great',
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7862,76848930,2016-08-30T18:11:36Z,src/core/lib/channel/http_client_filter.c,"@@ -134,17 +150,57 @@ static void hc_mutate_op(grpc_call_element *elem,   /* grab pointers to our data from the call element */   call_data *calld = elem->call_data;   channel_data *channeld = elem->channel_data;++  /* Decide which HTTP VERB to use */+  grpc_mdelem *method = GRPC_MDELEM_METHOD_POST;+  if (op->send_initial_metadata != NULL && (op->send_initial_metadata_flags &",Comment that we need both send initial metadata and the first send in the same batch (for now) to enable GET,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7862,76849415,2016-08-30T18:13:56Z,src/core/lib/channel/http_client_filter.c,"@@ -134,17 +150,57 @@ static void hc_mutate_op(grpc_call_element *elem,   /* grab pointers to our data from the call element */   call_data *calld = elem->call_data;   channel_data *channeld = elem->channel_data;++  /* Decide which HTTP VERB to use */+  grpc_mdelem *method = GRPC_MDELEM_METHOD_POST;+  if (op->send_initial_metadata != NULL && (op->send_initial_metadata_flags &+       GRPC_INITIAL_METADATA_CACHEABLE_REQUEST) &&+      op->send_message != NULL &&+      op->send_message->length < channeld->max_payload_size_for_get) {+    method = GRPC_MDELEM_METHOD_GET;+  } else if (op->send_initial_metadata_flags &+             GRPC_INITIAL_METADATA_IDEMPOTENT_REQUEST) {+    method = GRPC_MDELEM_METHOD_PUT;+  }++  if (method == GRPC_MDELEM_METHOD_GET) {+    gpr_slice slice;+    gpr_slice_buffer slices;+    gpr_slice_buffer_init(&slices);+    /* allocate memory to hold the entire payload */+    calld->payload_bytes = gpr_malloc(op->send_message->length);+    GPR_ASSERT(calld->payload_bytes);+    uint8_t *wrptr = calld->payload_bytes;++    /* copy payload from slices into payload_bytes. It gets freed in+     * op_complete*/+    while (grpc_byte_stream_next(NULL, op->send_message, &slice, ~(size_t)0,","Bad usage of grpc_byte_stream_next.```/* returns 1 if the bytes are available immediately (in which case * on_complete will not be called), 0 if the bytes will be available * asynchronously. * * max_size_hint can be set as a hint as to the maximum number * of bytes that would be acceptable to read. * * once a slice is returned into *slice, it is owned by the caller. */int grpc_byte_stream_next(grpc_exec_ctx *exec_ctx,                          grpc_byte_stream *byte_stream, gpr_slice *slice,                          size_t max_size_hint, grpc_closure *on_complete);```This needs a closure chain to allow asynchronous fetching of the bytes. Not doing so leaves us with a time-bomb.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7279,76869644,2016-08-30T20:09:54Z,src/core/lib/iomgr/combiner.c,"@@ -0,0 +1,288 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/lib/iomgr/combiner.h""++#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>++#include ""src/core/lib/iomgr/workqueue.h""+#include ""src/core/lib/profiling/timers.h""++int grpc_combiner_trace = 0;++#define GRPC_COMBINER_TRACE(fn) \+  do {                          \+    if (grpc_combiner_trace) {  \+      fn;                       \+    }                           \+  } while (0)++struct grpc_combiner {+  grpc_workqueue *optional_workqueue;+  gpr_mpscq queue;+  // state is:+  // lower bit - zero if orphaned+  // other bits - number of items queued on the lock+  gpr_atm state;+  bool take_async_break_before_final_list;+  grpc_closure_list final_list;+  grpc_closure continue_finishing;+};++grpc_combiner *grpc_combiner_create(grpc_workqueue *optional_workqueue) {+  grpc_combiner *lock = gpr_malloc(sizeof(*lock));+  lock->optional_workqueue = optional_workqueue;+  gpr_atm_no_barrier_store(&lock->state, 1);+  gpr_mpscq_init(&lock->queue);+  lock->take_async_break_before_final_list = false;+  grpc_closure_list_init(&lock->final_list);+  GRPC_COMBINER_TRACE(gpr_log(GPR_DEBUG, ""C:%p create"", lock));+  return lock;+}++static void really_destroy(grpc_exec_ctx *exec_ctx, grpc_combiner *lock) {+  GRPC_COMBINER_TRACE(gpr_log(GPR_DEBUG, ""C:%p really_destroy"", lock));+  GPR_ASSERT(gpr_atm_no_barrier_load(&lock->state) == 0);+  gpr_mpscq_destroy(&lock->queue);+  GRPC_WORKQUEUE_UNREF(exec_ctx, lock->optional_workqueue, ""combiner"");+  gpr_free(lock);+}++void grpc_combiner_destroy(grpc_exec_ctx *exec_ctx, grpc_combiner *lock) {+  gpr_atm old_state = gpr_atm_full_fetch_add(&lock->state, -1);+  GRPC_COMBINER_TRACE(gpr_log(+      GPR_DEBUG, ""C:%p really_destroy old_state=%"" PRIdPTR, lock, old_state));+  if (old_state == 1) {+    really_destroy(exec_ctx, lock);+  }+}++static bool maybe_finish_one(grpc_exec_ctx *exec_ctx, grpc_combiner *lock);+static void finish(grpc_exec_ctx *exec_ctx, grpc_combiner *lock);++static void continue_finishing_mainline(grpc_exec_ctx *exec_ctx, void *arg,+                                        grpc_error *error) {+  GPR_TIMER_BEGIN(""combiner.continue_executing_mainline"", 0);+  grpc_combiner *lock = arg;+  GRPC_COMBINER_TRACE(+      gpr_log(GPR_DEBUG, ""C:%p continue_finishing_mainline"", lock));+  GPR_ASSERT(exec_ctx->active_combiner == NULL);+  exec_ctx->active_combiner = lock;+  if (maybe_finish_one(exec_ctx, lock)) finish(exec_ctx, lock);+  GPR_ASSERT(exec_ctx->active_combiner == lock);+  exec_ctx->active_combiner = NULL;+  GPR_TIMER_END(""combiner.continue_executing_mainline"", 0);+}++static void execute_final(grpc_exec_ctx *exec_ctx, grpc_combiner *lock) {+  GPR_TIMER_BEGIN(""combiner.execute_final"", 0);+  grpc_closure *c = lock->final_list.head;+  GPR_ASSERT(c != NULL);+  grpc_closure_list_init(&lock->final_list);+  lock->take_async_break_before_final_list = false;+  int loops = 0;+  while (c != NULL) {+    GRPC_COMBINER_TRACE(+        gpr_log(GPR_DEBUG, ""C:%p execute_final[%d] c=%p"", lock, loops, c));+    grpc_closure *next = c->next_data.next;+    grpc_error *error = c->error;+    c->cb(exec_ctx, c->cb_arg, error);+    GRPC_ERROR_UNREF(error);+    c = next;+    loops++;+  }+  GPR_TIMER_END(""combiner.execute_final"", 0);+}++static void continue_executing_final(grpc_exec_ctx *exec_ctx, void *arg,+                                     grpc_error *error) {+  GPR_TIMER_BEGIN(""combiner.continue_executing_final"", 0);+  grpc_combiner *lock = arg;+  GRPC_COMBINER_TRACE(+      gpr_log(GPR_DEBUG, ""C:%p continue_executing_final"", lock));+  GPR_ASSERT(exec_ctx->active_combiner == NULL);+  exec_ctx->active_combiner = lock;+  // quick peek to see if new things have turned up on the queue: if so, go back+  // to executing them before the final list+  if ((gpr_atm_acq_load(&lock->state) >> 1) > 1) {+    if (maybe_finish_one(exec_ctx, lock)) finish(exec_ctx, lock);+  } else {+    execute_final(exec_ctx, lock);+    finish(exec_ctx, lock);+  }+  GPR_ASSERT(exec_ctx->active_combiner == lock);+  exec_ctx->active_combiner = NULL;+  GPR_TIMER_END(""combiner.continue_executing_final"", 0);+}++static bool start_execute_final(grpc_exec_ctx *exec_ctx, grpc_combiner *lock) {+  GPR_TIMER_BEGIN(""combiner.start_execute_final"", 0);+  GPR_ASSERT(exec_ctx->active_combiner == lock);+  GRPC_COMBINER_TRACE(+      gpr_log(GPR_DEBUG,+              ""C:%p start_execute_final take_async_break_before_final_list=%d"",+              lock, lock->take_async_break_before_final_list));+  if (lock->take_async_break_before_final_list) {+    grpc_closure_init(&lock->continue_finishing, continue_executing_final,+                      lock);+    grpc_exec_ctx_sched(exec_ctx, &lock->continue_finishing, GRPC_ERROR_NONE,+                        GRPC_WORKQUEUE_REF(lock->optional_workqueue, ""sched""));+    GPR_TIMER_END(""combiner.start_execute_final"", 0);+    return false;+  } else {+    execute_final(exec_ctx, lock);+    GPR_TIMER_END(""combiner.start_execute_final"", 0);+    return true;+  }+}++static bool maybe_finish_one(grpc_exec_ctx *exec_ctx, grpc_combiner *lock) {+  GPR_TIMER_BEGIN(""combiner.maybe_finish_one"", 0);+  gpr_mpscq_node *n = gpr_mpscq_pop(&lock->queue);+  GRPC_COMBINER_TRACE(+      gpr_log(GPR_DEBUG, ""C:%p maybe_finish_one n=%p"", lock, n));+  GPR_ASSERT(exec_ctx->active_combiner == lock);+  if (n == NULL) {+    // queue is in an inconsistant state: use this as a cue that we should","First, spelling.Second, inconsistent sounds scary, like we're violating an invariant. Is this really an invariant? It's more like a known transient condition due to conservatively setting one variable atomically before setting a different one, right?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7933,76880351,2016-08-30T21:14:28Z,tools/run_tests/run_tests.py,"@@ -884,6 +884,38 @@ def runs_per_test_type(arg_str):         msg = '\'{}\' is not a positive integer or \'inf\''.format(arg_str)         raise argparse.ArgumentTypeError(msg) +_COMPILER_CHOICES = ['default',","Never write a list literal when a tuple literal will do, especially for a constant.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7279,76918603,2016-08-31T03:22:36Z,src/core/lib/support/mpscq.h,"@@ -0,0 +1,65 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_LIB_SUPPORT_MPSCQ_H+#define GRPC_CORE_LIB_SUPPORT_MPSCQ_H++#include <grpc/support/atm.h>+#include <stddef.h>++// Multiple-producer single-consumer lock free queue, based upon the+// implementation from Dmitry Vyukov here:+// http://www.1024cores.net/home/lock-free-algorithms/queues/intrusive-mpsc-node-based-queue++// List node (include this in a data structure and dangle the rest of the+// interesting bits off the end)","I think the above comment isn't quite right. The interesting bits (the actual contents) are in the struct that contains the list node, correct? Maybe it should say it that way?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7279,76919922,2016-08-31T03:39:25Z,test/core/support/mpscq_test.c,"@@ -0,0 +1,124 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/lib/support/mpscq.h""++#include <stdlib.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/thd.h>+#include <grpc/support/useful.h>+#include ""test/core/util/test_config.h""++typedef struct test_node {+  gpr_mpscq_node node;+  size_t i;+  size_t *ctr;+} test_node;++static test_node *new_node(size_t i, size_t *ctr) {+  test_node *n = gpr_malloc(sizeof(test_node));+  n->i = i;+  n->ctr = ctr;+  return n;+}++static void test_serial(void) {+  gpr_log(GPR_DEBUG, ""test_serial"");+  gpr_mpscq q;+  gpr_mpscq_init(&q);+  for (size_t i = 0; i < 10000000; i++) {+    gpr_mpscq_push(&q, &new_node(i, NULL)->node);+  }+  for (size_t i = 0; i < 10000000; i++) {+    test_node *n = (test_node *)gpr_mpscq_pop(&q);+    GPR_ASSERT(n);+    GPR_ASSERT(n->i == i);+    gpr_free(n);+  }+}++typedef struct {+  size_t ctr;+  gpr_mpscq *q;+} thd_args;++#define THREAD_ITERATIONS 100000++static void test_thread(void *args) {+  thd_args *a = args;+  for (size_t i = 1; i <= THREAD_ITERATIONS; i++) {+    gpr_mpscq_push(a->q, &new_node(i, &a->ctr)->node);+  }+}++static void test_mt(void) {+  gpr_log(GPR_DEBUG, ""test_mt"");+  gpr_thd_id thds[100];+  thd_args ta[GPR_ARRAY_SIZE(thds)];+  gpr_mpscq q;+  gpr_mpscq_init(&q);+  for (size_t i = 0; i < GPR_ARRAY_SIZE(thds); i++) {+    gpr_thd_options options = gpr_thd_options_default();+    gpr_thd_options_set_joinable(&options);+    ta[i].ctr = 0;+    ta[i].q = &q;+    GPR_ASSERT(gpr_thd_new(&thds[i], test_thread, &ta[i], &options));+  }+  size_t num_done = 0;+  size_t spins = 0;+  while (num_done != GPR_ARRAY_SIZE(thds)) {+    gpr_mpscq_node *n;+    while ((n = gpr_mpscq_pop(&q)) == NULL) {+      spins++;+    }+    test_node *tn = (test_node *)n;+    GPR_ASSERT(*tn->ctr == tn->i - 1);+    *tn->ctr = tn->i;+    if (tn->i == THREAD_ITERATIONS) num_done++;+    gpr_free(tn);+  }+  gpr_log(GPR_DEBUG, ""spins: %"" PRIdPTR, spins);+  for (size_t i = 0; i < GPR_ARRAY_SIZE(thds); i++) {+    gpr_thd_join(thds[i]);+  }+  gpr_mpscq_destroy(&q);+}","This test is very cool but may be a little narrow. It should instead have N popping threads, but they lock each other out so that only 1 can consume at a time. That maintains the meaning of mpsc and also represents how it actually gets used in core since the particular thread going in for work will change over time. That should hopefully make any data races or bad assumptions more evident.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7279,76921659,2016-08-31T04:09:38Z,test/core/support/mpscq_test.c,"@@ -0,0 +1,124 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/lib/support/mpscq.h""++#include <stdlib.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/thd.h>+#include <grpc/support/useful.h>+#include ""test/core/util/test_config.h""++typedef struct test_node {+  gpr_mpscq_node node;+  size_t i;+  size_t *ctr;+} test_node;++static test_node *new_node(size_t i, size_t *ctr) {+  test_node *n = gpr_malloc(sizeof(test_node));+  n->i = i;+  n->ctr = ctr;+  return n;+}++static void test_serial(void) {+  gpr_log(GPR_DEBUG, ""test_serial"");+  gpr_mpscq q;+  gpr_mpscq_init(&q);+  for (size_t i = 0; i < 10000000; i++) {+    gpr_mpscq_push(&q, &new_node(i, NULL)->node);+  }+  for (size_t i = 0; i < 10000000; i++) {+    test_node *n = (test_node *)gpr_mpscq_pop(&q);+    GPR_ASSERT(n);+    GPR_ASSERT(n->i == i);+    gpr_free(n);+  }+}++typedef struct {+  size_t ctr;+  gpr_mpscq *q;+} thd_args;++#define THREAD_ITERATIONS 100000++static void test_thread(void *args) {+  thd_args *a = args;+  for (size_t i = 1; i <= THREAD_ITERATIONS; i++) {+    gpr_mpscq_push(a->q, &new_node(i, &a->ctr)->node);+  }+}++static void test_mt(void) {+  gpr_log(GPR_DEBUG, ""test_mt"");+  gpr_thd_id thds[100];+  thd_args ta[GPR_ARRAY_SIZE(thds)];+  gpr_mpscq q;+  gpr_mpscq_init(&q);+  for (size_t i = 0; i < GPR_ARRAY_SIZE(thds); i++) {+    gpr_thd_options options = gpr_thd_options_default();+    gpr_thd_options_set_joinable(&options);+    ta[i].ctr = 0;+    ta[i].q = &q;+    GPR_ASSERT(gpr_thd_new(&thds[i], test_thread, &ta[i], &options));+  }+  size_t num_done = 0;+  size_t spins = 0;+  while (num_done != GPR_ARRAY_SIZE(thds)) {+    gpr_mpscq_node *n;+    while ((n = gpr_mpscq_pop(&q)) == NULL) {+      spins++;+    }+    test_node *tn = (test_node *)n;+    GPR_ASSERT(*tn->ctr == tn->i - 1);+    *tn->ctr = tn->i;+    if (tn->i == THREAD_ITERATIONS) num_done++;+    gpr_free(tn);+  }+  gpr_log(GPR_DEBUG, ""spins: %"" PRIdPTR, spins);+  for (size_t i = 0; i < GPR_ARRAY_SIZE(thds); i++) {+    gpr_thd_join(thds[i]);+  }+  gpr_mpscq_destroy(&q);+}","Added suggested test.Also extended things to have all push/pop threads initially wait on a gpr_event, which should help ensure that we get some contention on the queue (instead of accidentally finishing all the pushes before popping can begin).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7943,77078752,2016-08-31T21:39:42Z,src/core/ext/client_config/client_channel.c,"@@ -33,6 +33,7 @@  #include ""src/core/ext/client_config/client_channel.h""",For late night debugging sanity:Can we add some 3+ line comments on where the call_data and where the channel_data parts of the file are?I'm thinking:``` c/************************************************************************* * CHANNEL-WIDE FUNCTIONS *//************************************************************************* * PER-CALL FUNCTIONS */```,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7862,77079944,2016-08-31T21:47:17Z,src/core/lib/channel/http_client_filter.c,"@@ -129,22 +166,105 @@ static grpc_mdelem *client_strip_filter(void *user_data, grpc_mdelem *md) {   return md; } -static void hc_mutate_op(grpc_call_element *elem,+static void continue_send_message(grpc_exec_ctx *exec_ctx,+                                  grpc_call_element *elem) {+  call_data *calld = elem->call_data;+  uint8_t *wrptr = calld->payload_bytes;+  while (grpc_byte_stream_next(exec_ctx, calld->send_op.send_message,+                               &calld->incoming_slice, ~(size_t)0,+                               &calld->got_slice)) {+    memcpy(wrptr, GPR_SLICE_START_PTR(calld->incoming_slice),+           GPR_SLICE_LENGTH(calld->incoming_slice));+    wrptr += GPR_SLICE_LENGTH(calld->incoming_slice);+    gpr_slice_buffer_add(&calld->slices, calld->incoming_slice);+    if (calld->send_length == calld->slices.length) {+      calld->send_message_blocked = false;+      break;+    }+  }+}++static void got_slice(grpc_exec_ctx *exec_ctx, void *elemp, grpc_error *error) {+  grpc_call_element *elem = elemp;+  call_data *calld = elem->call_data;+  calld->send_message_blocked = false;+  gpr_slice_buffer_add(&calld->slices, calld->incoming_slice);+  if (calld->send_length == calld->slices.length) {+    /* Pass down the original send_message op that was blocked.*/+    grpc_slice_buffer_stream_init(&calld->replacement_stream, &calld->slices,+                                  calld->send_flags);+    calld->send_op.send_message = &calld->replacement_stream.base;+    calld->post_send = calld->send_op.on_complete;+    calld->send_op.on_complete = &calld->send_done;+    grpc_call_next_op(exec_ctx, elem, &calld->send_op);+  } else {+    continue_send_message(exec_ctx, elem);+  }+}++static void hc_mutate_op(grpc_exec_ctx *exec_ctx, grpc_call_element *elem,                          grpc_transport_stream_op *op) {   /* grab pointers to our data from the call element */   call_data *calld = elem->call_data;   channel_data *channeld = elem->channel_data;++  /* Decide which HTTP VERB to use. We use GET if the request is marked+  cacheable, and the operation contains both initial metadata and send message,+  and the payload is below the size threshold, and all the data+  for this request is immediately available. */+  grpc_mdelem *method = GRPC_MDELEM_METHOD_POST;","This whole block (up until line 261) could probably go into an `if (op->send_initial_metadata)` right?That way we'd skip doing some complicated processing on other code paths (like, say, recv_initial_metadata)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7943,77196048,2016-09-01T15:25:04Z,src/core/ext/client_config/client_channel.c,"@@ -33,6 +33,7 @@  #include ""src/core/ext/client_config/client_channel.h""","Done.  I also moved some code around within the file so that the channel code and call code was cleanly separated.I also did some additional clean-up, including:- changed function names such that members of the filter struct are prefixed with `cc_` but nothing else is- changed type of second parameter of pick_subchannel() function from `void *` to `grpc_call_element *`- eliminated the pick_subchannel member of the call_data struct, since we can now directly call the local static function without requiring a layer of indirection",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7926,77240557,2016-09-01T19:44:37Z,src/python/grpcio/grpc/__init__.py,"@@ -1219,12 +1219,14 @@ def server(thread_pool, handlers=None):       only handlers the server will use to service RPCs; other handlers may       later be added by calling add_generic_rpc_handlers any time before the       returned Server is started.+    args: A grpc._cython.ChannelArgs to be used to provide configuration options","grpc._cython.ChannelArgs is an internal class.  Could you change this type (and name) to match the options parameter on client side channel creation (i.e `secure_channel()`), and do the needed conversion in src/python/grpcio/grpc/_server.py ?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7279,77381471,2016-09-02T17:18:47Z,src/core/lib/iomgr/combiner.c,"@@ -204,6 +206,9 @@ static void finish(grpc_exec_ctx *exec_ctx, grpc_combiner *lock) {                                 ""C:%p finish[%d] old_state=%"" PRIdPTR, lock,                                 loops, old_state));     switch (old_state) {+      default:+        // we have multiple queued work items: just continue executing them+        break;",Or anywhere else in the chain that's most readable...,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7861,77475014,2016-09-05T06:26:48Z,src/csharp/Grpc.Core/GrpcOperationFailedException.cs,"@@ -0,0 +1,19 @@+﻿using System;+namespace Grpc.Core+{+    public class GrpcOperationFailedException : InvalidOperationException","FTR, we actually uses to have a similar exception type in a way earlier version of gRPC C# (pre-alpha), but then got rid of it.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7991,77718382,2016-09-06T21:02:28Z,src/core/lib/iomgr/resolve_address.h,"@@ -43,6 +44,7 @@ typedef struct {   char addr[GRPC_MAX_SOCKADDR_SIZE];   size_t len;+  bool is_balancer;","I'd prefer us moving this up one level.iomgr/resolve_address.h is a low level wrapper around whatever name resolution facility the operating system has.We're now introducing a new type, which has some metadata about the address stored also. I'm not sure that information belongs in iomgr at all, and would prefer to see it carried in some other data structure, and from some other module.Proposal: in client_config/, add a grpc_address type:```struct grpc_address {  bool is_balancer;  grpc_resolved_address sockaddr;  };```",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/7973,77720074,2016-09-06T21:11:47Z,src/core/ext/census/trace_context.h,"@@ -0,0 +1,50 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_CENSUS_TRACE_CONTEXT_H+#define GRPC_CORE_EXT_CENSUS_TRACE_CONTEXT_H++#include ""src/core/ext/census/gen/trace_context.pb.h""++/* Data from trace context ctxt is encoded to buffer with a+   max length of size.  The resulting number of bytes encoded is+   written to msg_length. */+bool encode_trace_context(google_trace_TraceContext *ctxt, uint8_t *buffer,","I think it would be better as:// Encode a trace context into proto format, into the buffer provided. On success, returns the number of bytes// consumed in buffer. On failure, returns 0.size_t encode_trace_context(google_trace_TraceContext *ctxt, uint8_t *buffer, size_t buf_size);Also consider providing a constant to make the callers (who needs to allocate the buffer) life easier. E.g.// Maximum number of bytes required to encode a TraceContext#define TRACE_MAX_CONTEXT_SIZE 31(if you did this, you could also consider removing the buf_size parameter, and just stating in the function documentation that the buffer size must be at least this many bytes)",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7986,77779346,2016-09-07T08:28:06Z,src/csharp/Grpc.IntegrationTesting/Grpc.IntegrationTesting.csproj,"@@ -63,17 +57,38 @@     <Reference Include=""nunitlite"">       <HintPath>..\packages\NUnitLite.3.2.0\lib\net45\nunitlite.dll</HintPath>     </Reference>+    <Reference Include=""CommandLineParser.Unofficial"">+      <HintPath>..\packages\CommandLineParser.Unofficial.2.0.275\lib\net45\CommandLineParser.Unofficial.dll</HintPath>+    </Reference>+    <Reference Include=""log4net"">+      <HintPath>..\packages\log4net.2.0.3\lib\net40-full\log4net.dll</HintPath>+    </Reference>     <Reference Include=""Google.Apis.Core"">-      <HintPath>..\packages\Google.Apis.Core.1.15.0\lib\net45\Google.Apis.Core.dll</HintPath>+      <HintPath>..\packages\Google.Apis.Core.1.16.0\lib\net45\Google.Apis.Core.dll</HintPath>+    </Reference>+    <Reference Include=""Zlib.Portable"">+      <HintPath>..\packages\Zlib.Portable.Signed.1.11.0\lib\portable-net4+sl5+wp8+win8+wpa81+MonoTouch+MonoAndroid\Zlib.Portable.dll</HintPath>","This is a new dependency of Google.Apis.*. The older versions of nuget (pre dotnet CLI) are a bit stupid and they unpack all the transitive dependencies to the project. So it looks like I added Zlib myself, but instead the IDE adds it for you. The line is correct.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/7973,77866067,2016-09-07T17:15:59Z,src/core/ext/census/trace_context.h,"@@ -0,0 +1,58 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++/* Functions for manipulating trace contexts as defined in+   src/proto/census/trace.proto */+#ifndef GRPC_CORE_EXT_CENSUS_TRACE_CONTEXT_H+#define GRPC_CORE_EXT_CENSUS_TRACE_CONTEXT_H++#include ""src/core/ext/census/gen/trace_context.pb.h""++// Maximum number of bytes required to encode a TraceContext+#define TRACE_MAX_CONTEXT_SIZE 31++/* Encode a trace context (ctxt) in proto format to the buffer provided.  The+size of buffer must be at least TRACE_MAX_CONTEXT_SIZE.  On success, returns the+number of bytes consumed in buffer in msg_length. On failure, returns 0 in+msg_length. */+bool encode_trace_context(google_trace_TraceContext *ctxt, uint8_t *buffer,+                          const size_t size, size_t *msg_length);","Arg naming: it's not clear that size corresponds to buffer - buf_size would be better; maybe also consider 'n' (analogous to memcpy usage/naming). It's not clear what ""message"" is referred to in msg_length - encoded_length might be better - although as mentioned above, I think it can be eliminated completely.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/7973,77868433,2016-09-07T17:29:58Z,test/core/census/trace_context_test.c,"@@ -0,0 +1,198 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <stdio.h>+#include <stdlib.h>+#include ""src/core/ext/census/base_resources.h""+#include ""src/core/ext/census/resource.h""+#include ""test/core/util/test_config.h""++#include ""src/core/ext/census/gen/trace_context.pb.h""+#include ""src/core/ext/census/trace_context.h""+#include ""third_party/nanopb/pb_decode.h""+#include ""third_party/nanopb/pb_encode.h""++#define BUF_SIZE 512++// Encodes a proto-encoded TraceContext (ctxt1) to a buffer, and then decodes it+// to a second TraceContext (ctxt2).  Validates that the resulting TraceContext+// has a span_id, trace_id, and that the values are equal to those in initial+// TraceContext.+bool validate_encode_decode_context(google_trace_TraceContext *ctxt1,+                                    uint8_t *buffer, size_t buf_size) {+  google_trace_TraceContext ctxt2 = google_trace_TraceContext_init_zero;+  size_t msg_length;++  if (!encode_trace_context(ctxt1, buffer, buf_size, &msg_length)) {+    return false;+  }++  if (!decode_trace_context(&ctxt2, buffer, msg_length)) {+    return false;+  }++  if (!ctxt2.has_trace_id || !ctxt2.has_span_id) {+    return false;+  }++  GPR_ASSERT(ctxt1->trace_id.hi == ctxt2.trace_id.hi &&+             ctxt1->trace_id.lo == ctxt2.trace_id.lo &&+             ctxt1->span_id == ctxt2.span_id);","This should probably have another condition ""(ctxt1->has_is_sampled == ctxt2->has_is_sampled && (ctxt1->has_is_sampled ? ctxt1->is_sampled == ctxt2->is_sampled : true))or something like that",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/7973,77895257,2016-09-07T20:16:01Z,test/core/census/trace_context_test.c,"@@ -0,0 +1,198 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <stdio.h>+#include <stdlib.h>+#include ""src/core/ext/census/base_resources.h""+#include ""src/core/ext/census/resource.h""+#include ""test/core/util/test_config.h""++#include ""src/core/ext/census/gen/trace_context.pb.h""+#include ""src/core/ext/census/trace_context.h""+#include ""third_party/nanopb/pb_decode.h""+#include ""third_party/nanopb/pb_encode.h""++#define BUF_SIZE 512++// Encodes a proto-encoded TraceContext (ctxt1) to a buffer, and then decodes it+// to a second TraceContext (ctxt2).  Validates that the resulting TraceContext+// has a span_id, trace_id, and that the values are equal to those in initial+// TraceContext.+bool validate_encode_decode_context(google_trace_TraceContext *ctxt1,+                                    uint8_t *buffer, size_t buf_size) {+  google_trace_TraceContext ctxt2 = google_trace_TraceContext_init_zero;+  size_t msg_length;++  if (!encode_trace_context(ctxt1, buffer, buf_size, &msg_length)) {+    return false;+  }++  if (!decode_trace_context(&ctxt2, buffer, msg_length)) {+    return false;+  }++  if (!ctxt2.has_trace_id || !ctxt2.has_span_id) {+    return false;+  }++  GPR_ASSERT(ctxt1->trace_id.hi == ctxt2.trace_id.hi &&+             ctxt1->trace_id.lo == ctxt2.trace_id.lo &&+             ctxt1->span_id == ctxt2.span_id);++  return true;+}++// Decodes and proto-encoded TraceContext from a buffer.+bool validate_decode_context(google_trace_TraceContext *ctxt, uint8_t *buffer,+                             size_t msg_length) {+  // validate the decoding of a context written to buffer+  if (!decode_trace_context(ctxt, buffer, msg_length)) {+    return false;+  }++  if (!ctxt->has_trace_id || !ctxt->has_span_id) {+    return false;+  }++  return true;+}++// Read an encoded trace context from a file.  Validates that the decoding+// gives the expected result (succeed).+static void read_context_from_file(google_trace_TraceContext *ctxt,+                                   const char *file, const bool succeed) {+  uint8_t buffer[BUF_SIZE];+  FILE *input = fopen(file, ""rb"");+  GPR_ASSERT(input != NULL);+  size_t nbytes = fread(buffer, 1, BUF_SIZE, input);+  GPR_ASSERT(nbytes < BUF_SIZE && feof(input) && !ferror(input));+  bool res = validate_decode_context(ctxt, buffer, nbytes);+  GPR_ASSERT(res == succeed);+  GPR_ASSERT(fclose(input) == 0);+}++// Test full proto-buffer+static void test_full() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_full.pb"", true);+}++// Test empty proto-buffer+static void test_empty() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_empty.pb"",+                         false);+}++// Test proto-buffer with only trace_id+static void test_trace_only() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_trace_only.pb"",+                         false);+}++// Test proto-buffer with only span_id+static void test_span_only() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_span_only.pb"",+                         false);+}++// Test proto-buffer without is_sampled value+static void test_no_sample() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_no_sample.pb"",+                         true);+  GPR_ASSERT(ctxt.has_is_sampled == false && ctxt.is_sampled == false);+}++static void test_encode_decode() {+  uint8_t buffer[BUF_SIZE] = {0};++  google_trace_TraceContext ctxt1 = google_trace_TraceContext_init_zero;+  ctxt1.has_trace_id = true;+  ctxt1.trace_id.has_hi = true;+  ctxt1.trace_id.has_lo = true;+  ctxt1.trace_id.lo = 1;+  ctxt1.trace_id.hi = 2;+  ctxt1.has_span_id = true;+  ctxt1.span_id = 3;+  validate_encode_decode_context(&ctxt1, buffer, sizeof(buffer));++  google_trace_TraceContext ctxt2 = google_trace_TraceContext_init_zero;+  ctxt2.has_trace_id = true;+  ctxt2.trace_id.has_hi = false;+  ctxt2.trace_id.has_lo = false;+  ctxt2.has_span_id = true;+  validate_encode_decode_context(&ctxt2, buffer, sizeof(buffer));+}++// Test a corrupted proto-buffer+static void test_corrupt() {+  uint8_t buffer[BUF_SIZE] = {0};+  google_trace_TraceContext ctxt1 = google_trace_TraceContext_init_zero;+  size_t msg_length;++  ctxt1.has_trace_id = true;+  ctxt1.trace_id.has_hi = true;+  ctxt1.trace_id.has_lo = true;+  ctxt1.trace_id.lo = 1;+  ctxt1.trace_id.hi = 2;+  ctxt1.has_span_id = true;+  ctxt1.span_id = 3;+  encode_trace_context(&ctxt1, buffer, sizeof(buffer), &msg_length);++  // corrupt some bytes+  buffer[1] = 255;","probably better, something likebuffer[0] = 147;because: (a) it is possible (although not probable) that span_id could be encoded first, in which case 255 would be a valid value for the second byte and (b) 147 = 0 1100 111 = field number 12 (too high), wire type 7 (invalid) so it is guaranteed to give you a 'bad' proto.",
6879942,Vizerai,https://api.github.com/repos/grpc/grpc/pulls/7973,77916715,2016-09-07T22:32:09Z,test/core/census/trace_context_test.c,"@@ -0,0 +1,198 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/census.h>+#include <grpc/support/log.h>+#include <grpc/support/port_platform.h>+#include <grpc/support/useful.h>+#include <stdbool.h>+#include <stdio.h>+#include <stdlib.h>+#include ""src/core/ext/census/base_resources.h""+#include ""src/core/ext/census/resource.h""+#include ""test/core/util/test_config.h""++#include ""src/core/ext/census/gen/trace_context.pb.h""+#include ""src/core/ext/census/trace_context.h""+#include ""third_party/nanopb/pb_decode.h""+#include ""third_party/nanopb/pb_encode.h""++#define BUF_SIZE 512++// Encodes a proto-encoded TraceContext (ctxt1) to a buffer, and then decodes it+// to a second TraceContext (ctxt2).  Validates that the resulting TraceContext+// has a span_id, trace_id, and that the values are equal to those in initial+// TraceContext.+bool validate_encode_decode_context(google_trace_TraceContext *ctxt1,+                                    uint8_t *buffer, size_t buf_size) {+  google_trace_TraceContext ctxt2 = google_trace_TraceContext_init_zero;+  size_t msg_length;++  if (!encode_trace_context(ctxt1, buffer, buf_size, &msg_length)) {+    return false;+  }++  if (!decode_trace_context(&ctxt2, buffer, msg_length)) {+    return false;+  }++  if (!ctxt2.has_trace_id || !ctxt2.has_span_id) {+    return false;+  }++  GPR_ASSERT(ctxt1->trace_id.hi == ctxt2.trace_id.hi &&+             ctxt1->trace_id.lo == ctxt2.trace_id.lo &&+             ctxt1->span_id == ctxt2.span_id);++  return true;+}++// Decodes and proto-encoded TraceContext from a buffer.+bool validate_decode_context(google_trace_TraceContext *ctxt, uint8_t *buffer,+                             size_t msg_length) {+  // validate the decoding of a context written to buffer+  if (!decode_trace_context(ctxt, buffer, msg_length)) {+    return false;+  }++  if (!ctxt->has_trace_id || !ctxt->has_span_id) {+    return false;+  }++  return true;+}++// Read an encoded trace context from a file.  Validates that the decoding+// gives the expected result (succeed).+static void read_context_from_file(google_trace_TraceContext *ctxt,+                                   const char *file, const bool succeed) {+  uint8_t buffer[BUF_SIZE];+  FILE *input = fopen(file, ""rb"");+  GPR_ASSERT(input != NULL);+  size_t nbytes = fread(buffer, 1, BUF_SIZE, input);+  GPR_ASSERT(nbytes < BUF_SIZE && feof(input) && !ferror(input));+  bool res = validate_decode_context(ctxt, buffer, nbytes);+  GPR_ASSERT(res == succeed);+  GPR_ASSERT(fclose(input) == 0);+}++// Test full proto-buffer+static void test_full() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_full.pb"", true);+}++// Test empty proto-buffer+static void test_empty() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_empty.pb"",+                         false);+}++// Test proto-buffer with only trace_id+static void test_trace_only() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_trace_only.pb"",+                         false);+}++// Test proto-buffer with only span_id+static void test_span_only() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_span_only.pb"",+                         false);+}++// Test proto-buffer without is_sampled value+static void test_no_sample() {+  google_trace_TraceContext ctxt = google_trace_TraceContext_init_zero;+  read_context_from_file(&ctxt, ""test/core/census/data/context_no_sample.pb"",+                         true);+  GPR_ASSERT(ctxt.has_is_sampled == false && ctxt.is_sampled == false);+}++static void test_encode_decode() {+  uint8_t buffer[BUF_SIZE] = {0};++  google_trace_TraceContext ctxt1 = google_trace_TraceContext_init_zero;+  ctxt1.has_trace_id = true;+  ctxt1.trace_id.has_hi = true;+  ctxt1.trace_id.has_lo = true;+  ctxt1.trace_id.lo = 1;+  ctxt1.trace_id.hi = 2;+  ctxt1.has_span_id = true;+  ctxt1.span_id = 3;+  validate_encode_decode_context(&ctxt1, buffer, sizeof(buffer));++  google_trace_TraceContext ctxt2 = google_trace_TraceContext_init_zero;+  ctxt2.has_trace_id = true;+  ctxt2.trace_id.has_hi = false;+  ctxt2.trace_id.has_lo = false;+  ctxt2.has_span_id = true;+  validate_encode_decode_context(&ctxt2, buffer, sizeof(buffer));+}++// Test a corrupted proto-buffer+static void test_corrupt() {+  uint8_t buffer[BUF_SIZE] = {0};+  google_trace_TraceContext ctxt1 = google_trace_TraceContext_init_zero;+  size_t msg_length;++  ctxt1.has_trace_id = true;+  ctxt1.trace_id.has_hi = true;+  ctxt1.trace_id.has_lo = true;+  ctxt1.trace_id.lo = 1;+  ctxt1.trace_id.hi = 2;+  ctxt1.has_span_id = true;+  ctxt1.span_id = 3;+  encode_trace_context(&ctxt1, buffer, sizeof(buffer), &msg_length);++  // corrupt some bytes+  buffer[1] = 255;","I've changed it to buffer[0] = 255This gives: TraceContext decoding failed: invalid wire_type147 = 1001 0011The leading 2 bits (10) don't correspond to anything (only 00 and 01 are valid here).The next 2 bits (01) correspond to field type PB_HTYPE_OPTIONAL.The low order nibble (0011) corresponds to PB_LTYPE_FIXED32 for the field data.I tested both 19 (0001 0011), 23 (0001 0111), and 31 (0001 1111) and they all pass, so it seems the high order bits are where it looks for invalid wire type.  Although 147 does give invalid wire type, it is due to the high order 1.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8026,77926457,2016-09-07T23:59:22Z,src/compiler/python_generator.cc,"@@ -230,8 +230,10 @@ static void PrintAllComments(const DescriptorType* desc, Printer* printer) {  bool PrintBetaServicer(const ServiceDescriptor* service, Printer* out) {   out->Print(""\n\n"");-  out->Print(""class Beta$Service$Servicer(object):\n"", ""Service"",-             service->name());+  out->Print(""class Beta$Service$Servicer(object):\n""+    ""\""\""\""The Beta API is deprecated post the 14.0.x branch. It is ""","Let's say ""is deprecated for gRPC Python 0.15.0 and later"". Can we also say something like ""This [class, function] was generated only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0""? Can we put in newlines so the generated text doesn't run off the (generated) page?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8022,77926976,2016-09-08T00:04:32Z,src/python/grpcio/grpc/__init__.py,"@@ -649,6 +649,10 @@ def unary_unary(      Args:       method: The name of the RPC method.+      request_serializer: Optional method for serializing the request+      message. Request goes unserialized in case None is passed.","Indent another two spaces when continuing a parameter description to a new line; it should be easy to count the number of arguments to the behavior by counting the number of lines indented merely two spaces relative to ""Args:"".",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8022,77927517,2016-09-08T00:10:31Z,src/python/grpcio/grpc/__init__.py,"@@ -649,6 +649,10 @@ def unary_unary(      Args:       method: The name of the RPC method.+      request_serializer: Optional method for serializing the request","When describing a behavior type, be clear about its parameter types and return types. In this case we should say something like ""an optional behavior taking a request and returning the byte string that is the serialization of the request or None if the application uses byte strings for requests"". But I'm having trouble expressing something reasonably short, clear to all programmers, and not insultingly obvious to most programmers. :-P",
6879942,Vizerai,https://api.github.com/repos/grpc/grpc/pulls/8031,78083691,2016-09-08T20:34:33Z,src/core/ext/census/trace_context.c,"@@ -0,0 +1,86 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/ext/census/trace_context.h""++#include <grpc/census.h>+#include <grpc/support/log.h>+#include <stdbool.h>++#include ""third_party/nanopb/pb_decode.h""+#include ""third_party/nanopb/pb_encode.h""++// This function assumes the TraceContext is valid.+size_t encode_trace_context(google_trace_TraceContext *ctxt, uint8_t *buffer,+                            const size_t buf_size) {+  // Create a stream that will write to our buffer.+  pb_ostream_t stream = pb_ostream_from_buffer(buffer, buf_size);++  // encode message+  bool status = pb_encode(&stream, google_trace_TraceContext_fields, ctxt);+  size_t nbytes = stream.bytes_written;++  if (!status) {+    gpr_log(GPR_DEBUG, ""TraceContext encoding failed: %s"",+            PB_GET_ERROR(&stream));+    nbytes = 0;+  }++  return nbytes;+}++bool decode_trace_context(google_trace_TraceContext *ctxt, uint8_t *buffer,+                          const size_t nbytes) {+  // Create a stream that reads nbytes from the buffer.+  pb_istream_t stream = pb_istream_from_buffer(buffer, nbytes);++  // decode message+  bool status = pb_decode(&stream, google_trace_TraceContext_fields, ctxt);++  if (!status) {+    gpr_log(GPR_DEBUG, ""TraceContext decoding failed: %s"",+            PB_GET_ERROR(&stream));+  }","It directly returns false in those conditions now, and returns true at the end of the function.",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/7933,78102165,2016-09-08T22:38:36Z,tools/run_tests/run_tests.py,"@@ -884,6 +884,42 @@ def runs_per_test_type(arg_str):         msg = '\'{}\' is not a positive integer or \'inf\''.format(arg_str)         raise argparse.ArgumentTypeError(msg) +_COMPILER_CHOICES = ('default',+                     'gcc4.4', 'gcc4.6', 'gcc4.9', 'gcc5.3',+                     'clang3.4', 'clang3.5', 'clang3.6', 'clang3.7',+                     'vs2010', 'vs2013', 'vs2015',+                     'python2.7', 'python3.4',+                     'node0.12', 'node4', 'node5',+                     'coreclr',)+++def _is_travis_enabled():+  for arg in sys.argv:+    if arg == ""--travis"" or arg == ""-t"":+      return True+  return False+++# TODO (https://github./grpc/grpc/issues/7934): This workaround would not+# have been necessary if the testing infrastructure provided provisions for+# supporting different configurations for different branches on the repository.+# Remove this workaround once test infrastructure supports configurations for+# different branches.+def _compiler_choices(compiler):+  if _is_travis_enabled():+    if compiler in _COMPILER_CHOICES:+      return compiler+    else:+      return 'python2.7'","So, this is a bit more complex than that, because this should be used by more than just Python.We rather need to return ""none"" or ""freepass"" or ""void"" or whatever wording you think is appropriate. Then later, in the _build_and_run function, we need to check for this, and build nothing and test nothing, but return a valid status code, and an empty junit test file (the xml_report basically).",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8050,78203888,2016-09-09T15:53:25Z,doc/environment_variables.md,"@@ -0,0 +1,61 @@+gRPC environment variables+--------------------------++gRPC C core based implementations (those contained in this repository) expose+some configuration as environment variables that can be set.++* GRPC_ABORT_ON_LEAKS+  A debugging aid to cause a call to abort() when gRPC objects are leaked past+  grpc_shutdown()++* GRPC_GOOGLE_CREDENTIALS_ENV_VAR+  The path to find the credentials to use when Google credentials are created++* GRPC_SSL_CIPHER_SUITES+  A colon separated list of cipher suites to use with OpenSSL++* GRPC_POLL_STRATEGY [posix-style environments only]+  Declares which polling engines to try when starting gRPC.+  This is a comma-separated list of engines, which are tried in priority order+  first -> last.+  Available polling engines include:+  - epoll (linux-only) - a polling engine based around the epoll family of+    system calls+  - poll - a portable polling engine based around poll(), intended to be a+    fallback engine when nothing better exists+  - legacy - the (deprecated) original polling engine for gRPC++* GRPC_TRACE+  A comma separated list of tracers that provide additional insight into how+  gRPC C core is processing requests via debug logs. Available tracers include:",I wonder how to deal with updates to this list. Perhaps have a special tag inside a comment (I believe markdown uses html syntax for those) and a corresponding sanity script to remind ourselves to update this list if new tracers are added? Borderline overengineering though.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78208729,2016-09-09T16:25:17Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -279,58 +285,84 @@ struct rr_connectivity_data {   glb_lb_policy *glb_policy; }; +static bool process_serverlist(const grpc_grpclb_server *server,","If I'm reading the code right, this function actually processes a single entry in the serverlist, not the whole serverlist.  Perhaps call it something like `extract_server_address()` instead?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8048,78321006,2016-09-12T06:41:47Z,src/csharp/Grpc.IntegrationTesting.Client/project.json,"@@ -13,8 +13,10 @@           ""includeFiles"": [ ""../Grpc.Core/Version.cs"" ]         },         ""copyToOutput"": {-          ""include"": ""data/*"",","I think it makes sense how this would not work with dotnet cli, as it looks to bet trying to copy the data/ directory from the separate project, Grpc.IntegrationTesting, but it seems strange how this works with xbuild.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/7892,78422816,2016-09-12T18:02:17Z,test/cpp/util/grpc_tool.cc,"@@ -257,6 +260,105 @@ bool GrpcTool::Help(int argc, const char** argv, const CliCredentials cred,   return true; } +bool GrpcTool::ListServices(int argc, const char** argv,+                            const CliCredentials cred,+                            GrpcToolOutputCallback callback) {+  CommandUsage(+      ""List services\n""+      ""  grpc_cli ls <address> [<service>[/<method>]]\n""+      ""    <address>                ; host:port\n""+      ""    <service>                ; Exported service name\n""+      ""    <method>                 ; Method name\n""+      ""    --l                      ; Use a long listing format\n""+      ""    --outfile                ; Output filename (defaults to stdout)\n"" ++      cred.GetCredentialUsage());++  grpc::string server_address(argv[0]);+  std::shared_ptr<grpc::Channel> channel =+      grpc::CreateChannel(server_address, cred.GetCredentials());+  grpc::ProtoReflectionDescriptorDatabase desc_db(channel);+  grpc::protobuf::DescriptorPool desc_pool(&desc_db);++  std::vector<grpc::string> service_list;+  if (!desc_db.GetServices(&service_list)) {+    return false;+  }++  // If no service is specified, dump the list of services.+  grpc::string output;+  if (argc < 2) {+    // List all services, if --l is passed, then include full description,+    // otherwise include a summarized list only.+    if (FLAGS_l) {+      output = DescribeServiceList(service_list, desc_pool);+    } else {+      for (auto const& service : service_list) {",Better not use this: https://github.com/grpc/grpc/blob/master/doc/cpp-style-guide.md,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/7279,78496764,2016-09-13T04:59:33Z,src/core/lib/support/mpscq.c,"@@ -0,0 +1,80 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/lib/support/mpscq.h""++#include <grpc/support/log.h>++void gpr_mpscq_init(gpr_mpscq *q) {+  gpr_atm_no_barrier_store(&q->head, (gpr_atm)&q->stub);+  q->tail = &q->stub;+  gpr_atm_no_barrier_store(&q->stub.next, 0);+}++void gpr_mpscq_destroy(gpr_mpscq *q) {+  GPR_ASSERT(gpr_atm_no_barrier_load(&q->head) == (gpr_atm)&q->stub);+  GPR_ASSERT(q->tail == &q->stub);+}++void gpr_mpscq_push(gpr_mpscq *q, gpr_mpscq_node *n) {+  gpr_atm_no_barrier_store(&n->next, 0);+  gpr_mpscq_node *prev =+      (gpr_mpscq_node *)gpr_atm_full_xchg(&q->head, (gpr_atm)n);+  gpr_atm_rel_store(&prev->next, (gpr_atm)n);","I now understand why my previous comment here was incorrect. (It was changed and then reverted anyway after triggering a tsan-reported race, so it was ineffectual.) I was assuming stronger semantics for ""full"" than what ""full"" actually has. I was assuming that ""full"" would provide sequential consistency for that operation. What it actually provides is just acquire and release semantics. So, the store part of the xchg is ordered after all previous stores, but there is no guarantee that it is ordered before any later stores. As a result, the previous store in the xchg is indeed not ordered before the store on `&prev->next` , so a release store is appropriate in this line.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7746,78500381,2016-09-13T05:59:06Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -398,8 +432,8 @@ static void rr_connectivity_changed(grpc_exec_ctx *exec_ctx, void *arg,     if (error == GRPC_ERROR_NONE) {       /* RR not shutting down. Mimic the RR's policy state */       grpc_connectivity_state_set(exec_ctx, &glb_policy->state_tracker,-                                  rr_conn_data->state, error,-                                  ""rr_connectivity_changed"");+                                  rr_conn_data->state, GRPC_ERROR_REF(error),",True. I left it there for consistency with the pattern.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7746,78500504,2016-09-13T06:00:59Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -279,58 +285,84 @@ struct rr_connectivity_data {   glb_lb_policy *glb_policy; }; +static bool process_serverlist(const grpc_grpclb_server *server,",The function as been completely rewritten and now does process the whole serverlist.,
150108,hsaliak,https://api.github.com/repos/grpc/grpc/pulls/8071,78601283,2016-09-13T17:01:22Z,doc/server_reflection_tutorial.md,"@@ -0,0 +1,190 @@+# gRPC Server Reflection Tutorial++gRPC Server Reflection provides information about publicly-accessible gRPC+services on a server, and assists clients in runtime to construct RPC+requests/responses without precompiled service information. It has been+supported by gRPC CLI, which could be used to introspect server protos and+send/receive test RPCs.++## Eanble Server Reflection++### Enable server reflection in C++ servers++C++ Server Reflection is offered as an add-on library, `libgrpc++_reflction`.",is an add-on library..,
150108,hsaliak,https://api.github.com/repos/grpc/grpc/pulls/8071,78601666,2016-09-13T17:03:30Z,doc/server_reflection_tutorial.md,"@@ -0,0 +1,190 @@+# gRPC Server Reflection Tutorial++gRPC Server Reflection provides information about publicly-accessible gRPC+services on a server, and assists clients in runtime to construct RPC+requests/responses without precompiled service information. It has been+supported by gRPC CLI, which could be used to introspect server protos and+send/receive test RPCs.++## Eanble Server Reflection++### Enable server reflection in C++ servers++C++ Server Reflection is offered as an add-on library, `libgrpc++_reflction`.+To enable C++ server reflection, you can simply link this library to your server+binary.++Some platforms (e.g. Ubuntu 11.10 onwards) only link in libraries that directly+contain symbols used by the application. On these platforms, LD flag+`--no-as-needed` is needed for for dynamic linking and `--whole-archive` is+needed for for static linking.++Here is an [example](examples/cpp/helloworld/Makefile#L37#L45) for enabling c+++server reflection on Linux and MacOS.++## Test services using Server Reflection++gRPC Server Reflection has been supported by gRPC CLI. After enabling Server+Reflection in a server application, you can use gRPC CLI to test its services.++Instructions on how to use gRPC CLI can be found at+[command_line_tool.md](doc/command_line_tool.md), or using `grpc_cli help`+command.++Here we use `examples/cpp/helloworld` as an example to show the use of gRPC+Server Reflection and gRPC CLI. First, we need to build gRPC CLI and setup an+example server with Server Reflection enabled.++- Setup an example server++  Server Reflection has already been enabled in the+  [Makefile](examples/cpp/helloworld/Makefile) of the helloworld example. We can+  simply make it and run the greeter_server.++  ```sh+  $ make -C examples/cpp/helloworld+  $ examples/cpp/helloworld/greeter_server &+  ```++- Build gRPC CLI++  ```sh+  make grpc_cli+  ```++### List services++`grpc_cli ls` command can list services and methods exposed at a given port",command lists services and method exposed..,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78602573,2016-09-13T17:08:40Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,16 +47,25 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; -typedef struct grpc_lb_policy_address_token {-  uint8_t *token;-  size_t token_size;-} grpc_lb_policy_address_token;+/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not \a NULL, is opaque and meant to be consumed by the gRPC+ * LB policy. Anywhere else, refer to the functions in \a+ * grpc_lb_policy_user_data_vtable to operate with it */+typedef struct grpc_lb_address {+  grpc_resolved_address *resolved_address;+  void *user_data;+} grpc_lb_address;++/** Functions acting upon the opaque \a grpc_lb_address.user_data */+typedef struct grpc_lb_policy_user_data_vtable {+  void *(*copy)(void *);+  void (*destroy)(void *);+} grpc_lb_policy_user_data_vtable;  typedef struct grpc_lb_policy_args {-  grpc_resolved_addresses *addresses;-  /* If not NULL, array of load balancing tokens associated with \a addresses,-   * on a 1:1 correspondence. Some indices may be NULL for missing tokens. */-  grpc_lb_policy_address_token *tokens;+  grpc_lb_address *lb_addresses;","The name `lb_addresses` implies that these are balancer addresses, when in fact they may be either balancer addresses or backend addresses (or, in the future, some combination of the two).  How about renaming this to just `addresses`?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78602589,2016-09-13T17:08:45Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -285,37 +329,90 @@ struct rr_connectivity_data {   glb_lb_policy *glb_policy; }; -static bool process_serverlist(const grpc_grpclb_server *server,-                               struct sockaddr_storage *sa, size_t *sa_len) {-  if (server->port >> 16 != 0) {-    gpr_log(GPR_ERROR, ""Invalid port '%d'."", server->port);-    return false;+/* populate \a addresses according to \a serverlist. Returns the number of+ * addresses successfully parsed and added to \a addresses */+static size_t process_serverlist(const grpc_grpclb_serverlist *serverlist,+                                 grpc_lb_address **lb_addresses) {+  size_t num_valid = 0;+  /* first pass: count how many are valid in order to allocate the necessary+   * memory in a single block */+  for (size_t i = 0; i < serverlist->num_servers; ++i) {+    const grpc_grpclb_server *server = serverlist->servers[i];+    const grpc_grpclb_ip_address *ip = &server->ip_address;++    if (server->port >> 16 != 0) {+      gpr_log(GPR_ERROR,+              ""Invalid port '%d' at index %zu of serverlist. Ignoring."",+              server->port, i);+      continue;+    }++    if (ip->size != 4 && ip->size != 16) {+      gpr_log(GPR_ERROR,+              ""Expected IP to be 4 or 16 bytes, got %d at index %zu of ""+              ""serverlist. Ignoring"",+              ip->size, i);+      continue;+    }+    ++num_valid;   }-  const uint16_t netorder_port = htons((uint16_t)server->port);-  /* the addresses are given in binary format (a in(6)_addr struct) in-   * server->ip_address.bytes. */-  const grpc_grpclb_ip_address *ip = &server->ip_address;-  *sa_len = 0;-  if (ip->size == 4) {-    struct sockaddr_in *addr4 = (struct sockaddr_in *)sa;-    *sa_len = sizeof(struct sockaddr_in);-    memset(addr4, 0, *sa_len);-    addr4->sin_family = AF_INET;-    memcpy(&addr4->sin_addr, ip->bytes, ip->size);-    addr4->sin_port = netorder_port;-  } else if (ip->size == 6) {-    struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)sa;-    *sa_len = sizeof(struct sockaddr_in6);-    memset(addr6, 0, *sa_len);-    addr6->sin6_family = AF_INET;-    memcpy(&addr6->sin6_addr, ip->bytes, ip->size);-    addr6->sin6_port = netorder_port;-  } else {-    gpr_log(GPR_ERROR, ""Expected IP to be 4 or 16 bytes. Got %d."", ip->size);-    return false;+  if (num_valid == 0) {+    return 0;   }-  GPR_ASSERT(*sa_len > 0);-  return true;++  /* allocate the memory block for the ""resolved"" addresses. */+  grpc_resolved_address *r_addrs_memblock =+      gpr_malloc(sizeof(grpc_resolved_address) * num_valid);+  memset(r_addrs_memblock, 0, sizeof(grpc_resolved_address) * num_valid);+  grpc_lb_address *lb_addrs = gpr_malloc(sizeof(grpc_lb_address) * num_valid);+  memset(lb_addrs, 0, sizeof(grpc_lb_address) * num_valid);++  /* second pass: actually populate the addresses and LB tokens (aka user data+   * to the outside world) to be read by the RR policy during its creation */+  for (size_t i = 0; i < num_valid; ++i) {","The loop above that sets `num_valid` skips invalid entries, which could be anywhere in the array.  However, this loop assumes that the valid entries are all at the start of the array, which seems wrong.  (For example, if serverlist contains 3 entries and the middle one is invalid, this loop will grab the first two, when it should actually grab the first and last entries.)",
150108,hsaliak,https://api.github.com/repos/grpc/grpc/pulls/8071,78603020,2016-09-13T17:11:00Z,doc/server_reflection_tutorial.md,"@@ -0,0 +1,190 @@+# gRPC Server Reflection Tutorial++gRPC Server Reflection provides information about publicly-accessible gRPC+services on a server, and assists clients in runtime to construct RPC+requests/responses without precompiled service information. It has been+supported by gRPC CLI, which could be used to introspect server protos and+send/receive test RPCs.++## Eanble Server Reflection++### Enable server reflection in C++ servers++C++ Server Reflection is offered as an add-on library, `libgrpc++_reflction`.+To enable C++ server reflection, you can simply link this library to your server+binary.++Some platforms (e.g. Ubuntu 11.10 onwards) only link in libraries that directly+contain symbols used by the application. On these platforms, LD flag+`--no-as-needed` is needed for for dynamic linking and `--whole-archive` is+needed for for static linking.++Here is an [example](examples/cpp/helloworld/Makefile#L37#L45) for enabling c++",This leads to a dead link.Perhaps change this line to:This [Makefile](..) demonstrates enabling C++ server reflection on Linux and MacOS.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78606531,2016-09-13T17:31:05Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,8 +47,25 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; +/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not \a NULL, is opaque and meant to be consumed by the gRPC+ * LB policy. Anywhere else, refer to the functions in \a+ * grpc_lb_policy_user_data_vtable to operate with it */+typedef struct grpc_lb_address {+  grpc_resolved_address *resolved_address;+  void *user_data;+} grpc_lb_address;++/** Functions acting upon the opaque \a grpc_lb_address.user_data */+typedef struct grpc_lb_policy_user_data_vtable {","It looks like this vtable is only needed because we're requiring the LB policy to do memory management for the user data.  Instead, how about if we make it the caller's responsibility to do that, so that the LB policy only needs to return the right pointer?In other words, in the gRPC-LB policy, when we pass in the user_data to the RR policy, the user data can be a pointer to the right LB token, which is owned by the gRPC-LB policy.  That way, the RR policy doesn't need to do any copying or destroying; it can simply pass back the pointer to the LB token associated with whichever address it chooses.I suspect that this approach would both simplify this API and would minimize the code changes needed to the RR code.  What do you think?",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/8071,78618638,2016-09-13T18:37:38Z,doc/server_reflection_tutorial.md,"@@ -0,0 +1,190 @@+# gRPC Server Reflection Tutorial++gRPC Server Reflection provides information about publicly-accessible gRPC+services on a server, and assists clients in runtime to construct RPC+requests/responses without precompiled service information. It has been+supported by gRPC CLI, which could be used to introspect server protos and+send/receive test RPCs.++## Eanble Server Reflection++### Enable server reflection in C++ servers++C++ Server Reflection is offered as an add-on library, `libgrpc++_reflction`.+To enable C++ server reflection, you can simply link this library to your server+binary.++Some platforms (e.g. Ubuntu 11.10 onwards) only link in libraries that directly+contain symbols used by the application. On these platforms, LD flag+`--no-as-needed` is needed for for dynamic linking and `--whole-archive` is+needed for for static linking.++Here is an [example](examples/cpp/helloworld/Makefile#L37#L45) for enabling c+++server reflection on Linux and MacOS.++## Test services using Server Reflection++gRPC Server Reflection has been supported by gRPC CLI. After enabling Server+Reflection in a server application, you can use gRPC CLI to test its services.++Instructions on how to use gRPC CLI can be found at+[command_line_tool.md](doc/command_line_tool.md), or using `grpc_cli help`+command.++Here we use `examples/cpp/helloworld` as an example to show the use of gRPC+Server Reflection and gRPC CLI. First, we need to build gRPC CLI and setup an+example server with Server Reflection enabled.++- Setup an example server++  Server Reflection has already been enabled in the+  [Makefile](examples/cpp/helloworld/Makefile) of the helloworld example. We can+  simply make it and run the greeter_server.++  ```sh+  $ make -C examples/cpp/helloworld+  $ examples/cpp/helloworld/greeter_server &+  ```++- Build gRPC CLI++  ```sh+  make grpc_cli+  ```++### List services++`grpc_cli ls` command can list services and methods exposed at a given port++- List all the services exposed at a given port++  ```sh+  $ bins/opt/grpc_cli ls localhost:50051","It might not be good to add `bins/opt/` to $PATH, as this folder contains all the test binaries and will be deleted by `make clean`. Once the command line tool is mature enough, we can consider to move its binary to grpc's root folder or install it with `make install`. Before this, we may recommend users to `cd` into `bins/opt/`, and the prefix will no longer be needed in the rest of the tutorial. ",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7746,78656487,2016-09-13T22:27:41Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,8 +47,25 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; +/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not \a NULL, is opaque and meant to be consumed by the gRPC+ * LB policy. Anywhere else, refer to the functions in \a+ * grpc_lb_policy_user_data_vtable to operate with it */+typedef struct grpc_lb_address {+  grpc_resolved_address *resolved_address;+  void *user_data;+} grpc_lb_address;++/** Functions acting upon the opaque \a grpc_lb_address.user_data */+typedef struct grpc_lb_policy_user_data_vtable {","The vtable approach was introduced when user_data wasn't an mdelem but something with a more complex structure. Long story short, your suggestion is perfect for the time being. If we ever need something more complex/flexible -like the vtable-, we can always make (re)introduce it later. Done.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8084,78672151,2016-09-14T01:03:22Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -252,18 +259,30 @@ protected Exception TryDeserialize(byte[] payload, out TRead msg)         /// </summary>         protected void HandleSendFinished(bool success)         {+            bool delayCompletion = false;             TaskCompletionSource<object> origTcs = null;             lock (myLock)             {                 origTcs = streamingWriteTcs;                 streamingWriteTcs = null; +                if (!success && !finished && IsClient)+                {+                    // We should be setting this only once per call, following writes will be short circuited.+                    GrpcPreconditions.CheckState (delayedStreamingWriteTcs == null);+                    delayedStreamingWriteTcs = origTcs;+                    delayCompletion = true;+                }+                 ReleaseResourcesIfPossible();             }              if (!success)             {-                origTcs.SetException(new InvalidOperationException(""Send failed""));+                if (!delayCompletion)+                {+                    origTcs.SetException(IsClient ? GetRpcExceptionClientOnly() : new IOException(""Error sending from server.""));","So we only fill in the exception for the SendMessageTask here if the final call completion handler has already been ran through, meaning the GetRpcExceptionClientOnly will always be able to fill in with a non-null FinalStatus? Maybe use a sort of invariant if so? Got caught here for a little bit with the delayCompletion flag",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777253,2016-09-14T15:51:00Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -285,37 +329,90 @@ struct rr_connectivity_data {   glb_lb_policy *glb_policy; }; -static bool process_serverlist(const grpc_grpclb_server *server,-                               struct sockaddr_storage *sa, size_t *sa_len) {-  if (server->port >> 16 != 0) {-    gpr_log(GPR_ERROR, ""Invalid port '%d'."", server->port);-    return false;+/* populate \a addresses according to \a serverlist. Returns the number of+ * addresses successfully parsed and added to \a addresses */+static size_t process_serverlist(const grpc_grpclb_serverlist *serverlist,+                                 grpc_lb_address **lb_addresses) {+  size_t num_valid = 0;+  /* first pass: count how many are valid in order to allocate the necessary+   * memory in a single block */+  for (size_t i = 0; i < serverlist->num_servers; ++i) {+    const grpc_grpclb_server *server = serverlist->servers[i];+    const grpc_grpclb_ip_address *ip = &server->ip_address;++    if (server->port >> 16 != 0) {+      gpr_log(GPR_ERROR,+              ""Invalid port '%d' at index %zu of serverlist. Ignoring."",+              server->port, i);+      continue;+    }++    if (ip->size != 4 && ip->size != 16) {+      gpr_log(GPR_ERROR,+              ""Expected IP to be 4 or 16 bytes, got %d at index %zu of ""+              ""serverlist. Ignoring"",+              ip->size, i);+      continue;+    }+    ++num_valid;   }-  const uint16_t netorder_port = htons((uint16_t)server->port);-  /* the addresses are given in binary format (a in(6)_addr struct) in-   * server->ip_address.bytes. */-  const grpc_grpclb_ip_address *ip = &server->ip_address;-  *sa_len = 0;-  if (ip->size == 4) {-    struct sockaddr_in *addr4 = (struct sockaddr_in *)sa;-    *sa_len = sizeof(struct sockaddr_in);-    memset(addr4, 0, *sa_len);-    addr4->sin_family = AF_INET;-    memcpy(&addr4->sin_addr, ip->bytes, ip->size);-    addr4->sin_port = netorder_port;-  } else if (ip->size == 6) {-    struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)sa;-    *sa_len = sizeof(struct sockaddr_in6);-    memset(addr6, 0, *sa_len);-    addr6->sin6_family = AF_INET;-    memcpy(&addr6->sin6_addr, ip->bytes, ip->size);-    addr6->sin6_port = netorder_port;-  } else {-    gpr_log(GPR_ERROR, ""Expected IP to be 4 or 16 bytes. Got %d."", ip->size);-    return false;+  if (num_valid == 0) {+    return 0;   }-  GPR_ASSERT(*sa_len > 0);-  return true;++  /* allocate the memory block for the ""resolved"" addresses. */+  grpc_resolved_address *r_addrs_memblock =+      gpr_malloc(sizeof(grpc_resolved_address) * num_valid);+  memset(r_addrs_memblock, 0, sizeof(grpc_resolved_address) * num_valid);+  grpc_lb_address *lb_addrs = gpr_malloc(sizeof(grpc_lb_address) * num_valid);+  memset(lb_addrs, 0, sizeof(grpc_lb_address) * num_valid);++  /* second pass: actually populate the addresses and LB tokens (aka user data+   * to the outside world) to be read by the RR policy during its creation */+  for (size_t i = 0; i < num_valid; ++i) {","I think this loop is still not quite right.  There are two problems with it.First, it's only iterating until `num_valid`, but we actually need to go all the way up to `serverlist->num_servers`, since the invalid entries may not be at the end of the list.Second, although it's skipping invalid entries, it's using the same index in both the source and destination arrays.  This means that if there are 3 entries and the middle one is not valid, we will attempt to set indexes 0 and 2 instead of 1 and 0 (which will exceed the bounds of the array, since we're only allocating `num_valid` entries).  I think that you need to use `num_processed` instead of `i` to index both `lb_addrs` and `r_addrs_memblock`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777296,2016-09-14T15:51:13Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -423,19 +443,27 @@ static grpc_lb_policy *create_rr(grpc_exec_ctx *exec_ctx,   grpc_lb_policy_args args;   memset(&args, 0, sizeof(args));   args.client_channel_factory = glb_policy->cc_factory;-  args.num_addresses = process_serverlist(serverlist, &args.lb_addresses);-  args.user_data_vtable.copy = user_data_copy;-  args.user_data_vtable.destroy = user_data_destroy;+  const size_t num_ok_addresses =+      process_serverlist(serverlist, &args.lb_addresses);+  args.num_addresses = num_ok_addresses;    grpc_lb_policy *rr = grpc_lb_policy_create(exec_ctx, ""round_robin"", &args);++  glb_policy->num_ok_serverlist_addresses = num_ok_addresses;+  if (glb_policy->lb_addresses != NULL) {+    /* dispose of the previous version */+    for (size_t i = 0; i < num_ok_addresses; ++i) {","Shouldn't this use the original value of `glb_policy->num_ok_serverlist_addresses`, since the old and new sets of addresses might be different sizes?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777311,2016-09-14T15:51:17Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -601,6 +629,11 @@ static void glb_destroy(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol) {     grpc_grpclb_destroy_serverlist(glb_policy->serverlist);   }   gpr_mu_destroy(&glb_policy->mu);++  for (size_t i = 0; i < glb_policy->num_ok_serverlist_addresses; ++i) {","Looks like we've got this same code in two different places.  How about creating a `lb_addrs_destroy()` helper function to avoid the duplication?This would probably also allow you to inline the code that's currently in `user_data_destroy()`, which would eliminate the need for that function.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777331,2016-09-14T15:51:23Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -762,9 +795,9 @@ static int glb_pick(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol,       GRPC_LB_POLICY_UNREF(exec_ctx, glb_policy->wc_arg.rr_policy, ""glb_pick"");        /* add the load reporting initial metadata */-      initial_metadata_add_lb_token(pick_args->initial_metadata,-                                    pick_args->lb_token_mdelem_storage,-                                    glb_policy->wc_arg.lb_token);+      initial_metadata_add_lb_token(+          pick_args->initial_metadata, pick_args->lb_token_mdelem_storage,+          user_data_copy(glb_policy->wc_arg.lb_token));","It looks like this is the only place that we're calling `user_data_copy()`, so we can probably inline that code here and eliminate the function.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777452,2016-09-14T15:51:52Z,src/core/ext/client_config/lb_policy.h,"@@ -124,26 +138,36 @@ void grpc_lb_policy_weak_unref(grpc_exec_ctx *exec_ctx, grpc_lb_policy *policy); void grpc_lb_policy_init(grpc_lb_policy *policy,                          const grpc_lb_policy_vtable *vtable); -/** Given initial metadata in \a initial_metadata, find an appropriate-    target for this rpc, and 'return' it by calling \a on_complete after setting-    \a target.-    Picking can be asynchronous. Any IO should be done under \a pollent. */+/** Find an appropriate target for this call, based on \a pick_args.+    Picking can be synchronous or asynchronous. In the synchronous case, when a+    pick is readily available, it'll be returned in \a target and a non-zero+    value will be returned.+    In the asynchronous case, zero is returned and \a on_complete will be called+    once \a target and \a user_data have been set. Any IO should be done under+   \a+    pick_args->pollent.+    The opaque \a user_data output argument corresponds to information that may+    need be propagated from the LB policy. It may be NULL.+    Errors are signaled by receiving a NULL \a *target. */ int grpc_lb_policy_pick(grpc_exec_ctx *exec_ctx, grpc_lb_policy *policy,","Not directly related to this PR (and should probably be fixed separately, since this one is already big enough), but this function can probably be changed to return a `bool`.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777469,2016-09-14T15:51:57Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,8 +47,24 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; +/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not \a NULL, is opaque and meant to be consumed by the gRPC+ * LB policy. Anywhere else, refer to the functions in \a+ * grpc_lb_policy_user_data_vtable to operate with it */+typedef struct grpc_lb_address {+  grpc_resolved_address *resolved_address;+  void *user_data;","Please document the fact that not all LB policies support user data.Also, please add a check to both grpclb.c and pick_first.c to ensure that this is set to NULL, so that callers don't accidentally try passing user data in to those policies.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777481,2016-09-14T15:52:01Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,8 +47,25 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; +/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not \a NULL, is opaque and meant to be consumed by the gRPC+ * LB policy. Anywhere else, refer to the functions in \a+ * grpc_lb_policy_user_data_vtable to operate with it */+typedef struct grpc_lb_address {+  grpc_resolved_address *resolved_address;+  void *user_data;+} grpc_lb_address;++/** Functions acting upon the opaque \a grpc_lb_address.user_data */+typedef struct grpc_lb_policy_user_data_vtable {","Thanks, this looks much cleaner!It looks like we still need to remove the `grpc_lb_policy_user_data_vtable` type definition itself.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78777575,2016-09-14T15:52:34Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -595,12 +636,14 @@ static grpc_lb_policy *round_robin_create(grpc_exec_ctx *exec_ctx,       sd->policy = p;       sd->index = subchannel_idx;       sd->subchannel = subchannel;+      sd->user_data = p->user_data[i];       ++subchannel_idx;       grpc_closure_init(&sd->connectivity_changed_closure,                         rr_connectivity_changed, sd);     }   }   if (subchannel_idx == 0) {+    /* couldn't create any subchannel. Bail out */     gpr_free(p->subchannels);",Do we need to free `p->user_data` here as well?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7970,78784347,2016-09-14T16:28:32Z,test/core/end2end/invalid_call_argument_test.c,"@@ -304,6 +304,11 @@ static void test_receive_initial_metadata_twice_at_client() {   grpc_op *op;   prepare_test(1);   op = g_state.ops;+  op->op = GRPC_OP_SEND_INITIAL_METADATA;","I'd like to avoid this if possible.What about adding deadline to grpc_call_element_args: the client would be able to configure the deadline at call-stack construction time, meaning it wouldn't need to receive a send initial metadata, meaning that this change would be unnecessary.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7746,78803885,2016-09-14T18:10:58Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -762,9 +795,9 @@ static int glb_pick(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol,       GRPC_LB_POLICY_UNREF(exec_ctx, glb_policy->wc_arg.rr_policy, ""glb_pick"");        /* add the load reporting initial metadata */-      initial_metadata_add_lb_token(pick_args->initial_metadata,-                                    pick_args->lb_token_mdelem_storage,-                                    glb_policy->wc_arg.lb_token);+      initial_metadata_add_lb_token(","I've changed the processing of serverlist to ensure there's always a token for all valid addresses. Otherwise, we log an error and use the empty token for that address (the load reporting protocol supports this). There's then an assert in `initial_metadata_add_lb_token` to ""enforce"" this.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/8101,78856741,2016-09-14T22:35:51Z,test/cpp/interop/interop_server.cc,"@@ -152,6 +153,16 @@ class TestServiceImpl : public TestService::Service {     return Status::OK;   } +  // Response contains current timestamp. We ignore everything in the request.+  Status CacheableUnaryCall(ServerContext* context, const SimpleRequest* request,+                   SimpleResponse* response) {+    gpr_timespec ts = gpr_now(GPR_CLOCK_REALTIME);+    std::string timestamp = std::to_string(ts.tv_nsec);+    response->mutable_payload()->set_body(timestamp.c_str(), timestamp.size());+    context->AddInitialMetadata(""Cache-Control"", ""max-age=100000, public"");","As implemented, this can cause flakiness, if the cached response is quite old already on the first request and expires for before the second. Maybe reduce the max-age to a minute or similar and have each client specify something unique (maybe random number) in the request? There should also probably be something in the response so that clients can verify the initial request was un-cached, since there could be a bug where all requests to the same URL were cached independent of the request (say, if the Vary header was missing).",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7860,78870324,2016-09-15T00:30:47Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -226,6 +226,23 @@ def send_status(code = OK, details = '', assert_finished = false,       nil     end +    def server_unary_response(req, marshalled: false, trailing_metadata: {},+                              code: Core::StatusCodes::OK, details: 'OK')+      @send_initial_md_mutex.synchronize do+        ops = {}+        ops[SEND_INITIAL_METADATA] = @metadata_to_send unless @metadata_sent+        @metadata_sent = true unless @metadata_sent","You don't need the ""unless"" here. `@metadata_sent` should be true after this line, one way or the other.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/7860,78870493,2016-09-15T00:32:49Z,src/ruby/lib/grpc/generic/active_call.rb,"@@ -226,6 +226,23 @@ def send_status(code = OK, details = '', assert_finished = false,       nil     end +    def server_unary_response(req, marshalled: false, trailing_metadata: {},+                              code: Core::StatusCodes::OK, details: 'OK')","What is the point of the `marshalled` argument? I don't see any changes that use it, and I wouldn't expect users to pre-marshal data before passing it to us.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7846,78883286,2016-09-15T03:06:45Z,include/grpc++/server_builder.h,"@@ -78,12 +78,23 @@ class ServerBuilder {   /// Only matches requests with :authority \a host   ServerBuilder& RegisterService(const grpc::string& host, Service* service); -  /// Set max message size in bytes.-  ServerBuilder& SetMaxMessageSize(int max_message_size) {-    max_message_size_ = max_message_size;+  /// Set max receive message size in bytes.+  ServerBuilder& SetMaxReceiveMessageSize(int max_receive_message_size) {+    max_receive_message_size_ = max_receive_message_size;+    return *this;+  }++  /// Set max send message size in bytes.+  ServerBuilder& SetMaxSendMessageSize(int max_send_message_size) {+    max_send_message_size_ = max_send_message_size;     return *this;   } +  /// For backward compatibility.",We may want to add a `\deprecated` in here (viz. https://www.stack.nl/~dimitri/doxygen/manual/commands.html#cmddeprecated),
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7846,78883360,2016-09-15T03:07:43Z,include/grpc/impl/codegen/grpc_types.h,"@@ -127,7 +127,11 @@ typedef struct {     connection. Int valued. */ #define GRPC_ARG_MAX_CONCURRENT_STREAMS ""grpc.max_concurrent_streams"" /** Maximum message length that the channel can receive. Int valued, bytes. */-#define GRPC_ARG_MAX_MESSAGE_LENGTH ""grpc.max_message_length""+#define GRPC_ARG_MAX_RECEIVE_MESSAGE_LENGTH ""grpc.max_receive_message_length""+/** Backward compatibility. */",`\deprecated`?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7846,78883462,2016-09-15T03:09:13Z,src/core/lib/channel/channel_args.h,"@@ -89,4 +89,12 @@ uint32_t grpc_channel_args_compression_algorithm_get_states( int grpc_channel_args_compare(const grpc_channel_args *a,                               const grpc_channel_args *b); +/** Returns the value of \a arg, subject to the contraints in \a options. */","This comment seems misplaced: as is, it's documenting the `grpc_integer_options` enum instead of the `grpc_channel_arg_get_integer` function.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8102,78887122,2016-09-15T04:09:44Z,src/ruby/ext/grpc/rb_call_credentials.c,"@@ -86,19 +86,16 @@ static VALUE grpc_rb_call_credentials_callback_rescue(VALUE args,       rb_funcall(exception_object, rb_intern(""backtrace""), 0),       rb_intern(""join""),       1, rb_str_new2(""\n\tfrom ""));-  VALUE rb_exception_info = rb_funcall(exception_object, rb_intern(""to_s""), 0);-  const char *exception_classname = rb_obj_classname(exception_object);+  VALUE rb_exception_info = rb_funcall(exception_object, rb_intern(""inspect""), 0);   (void)args;-  gpr_log(GPR_INFO, ""Call credentials callback failed: %s: %s\n%s"",-          exception_classname, StringValueCStr(rb_exception_info),+  gpr_log(GPR_INFO, ""Call credentials callback failed: %s\n%s"",+          StringValueCStr(rb_exception_info),           StringValueCStr(backtrace));   rb_hash_aset(result, rb_str_new2(""metadata""), Qnil);-  /* Currently only gives the exception class name. It should be possible get-     more details */   rb_hash_aset(result, rb_str_new2(""status""),-               INT2NUM(GRPC_STATUS_PERMISSION_DENIED));+               INT2NUM(GRPC_STATUS_UNAVAILABLE));","It looks like `on_credentials_metadata`, which I believe is the actual function for the `grpc_credentials_plugin_metadata_cb` callback, in https://github.com/grpc/grpc/blob/master/src/core/lib/security/transport/client_auth_filter,always bubbles up UNAUTHENTICATED as long as status passed to it isn't OK.Was thinking the status application passed would be the result status for the call, but is this actual behavior the expectation? cc @ctiller",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8084,78931510,2016-09-15T10:19:54Z,src/csharp/Grpc.Core/Internal/AsyncCallBase.cs,"@@ -252,18 +259,30 @@ protected Exception TryDeserialize(byte[] payload, out TRead msg)         /// </summary>         protected void HandleSendFinished(bool success)         {+            bool delayCompletion = false;             TaskCompletionSource<object> origTcs = null;             lock (myLock)             {                 origTcs = streamingWriteTcs;                 streamingWriteTcs = null; +                if (!success && !finished && IsClient)+                {+                    // We should be setting this only once per call, following writes will be short circuited.+                    GrpcPreconditions.CheckState (delayedStreamingWriteTcs == null);+                    delayedStreamingWriteTcs = origTcs;+                    delayCompletion = true;+                }+                 ReleaseResourcesIfPossible();             }              if (!success)             {-                origTcs.SetException(new InvalidOperationException(""Send failed""));+                if (!delayCompletion)+                {+                    origTcs.SetException(IsClient ? GetRpcExceptionClientOnly() : new IOException(""Error sending from server.""));","Yes, you understand that correctly, but you are right that the code was a bit cryptic. I tried to improved that by adding a precondition and some comments.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78984886,2016-09-15T15:00:55Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,8 +47,19 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; +/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not NULL, contains opaque data meant to be consumed by the+ * gRPC LB policy. Note that no all LB policies support \a user_data as input.+ * Those who don't will simply ignore it and will correspondingly return NULL in",This seems misleading.  The pick_first and grpclb policies won't just ignore the user data; they will crash if the value is non-NULL.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,78985658,2016-09-15T15:04:09Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -251,6 +280,8 @@ static void rr_destroy(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol) {     gpr_free(elem);     elem = tmp;   }++  gpr_free(p->user_data);","Since we don't own the user data, we should not be freeing it here.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/7746,78991290,2016-09-15T15:26:05Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -251,6 +280,8 @@ static void rr_destroy(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol) {     gpr_free(elem);     elem = tmp;   }++  gpr_free(p->user_data);","Ah! The misleading naming of variables... the RR policy _does_ own that, which is not the user_data itself but an array of pointers to hold the actual not-owned user_data pointers. I've renamed the variable.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7746,79009168,2016-09-15T16:43:36Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -47,8 +47,19 @@ struct grpc_lb_policy_factory {   const grpc_lb_policy_factory_vtable *vtable; }; +/** A resolved address alongside any LB related information associated with it.+ * \a user_data, if not NULL, contains opaque data meant to be consumed by the+ * gRPC LB policy. Note that no all LB policies support \a user_data as input.+ * Those who don't will simply ignore it and will correspondingly return NULL in","Good question.  Here are my thoughts.In general, I agree that crashing is a bad idea.  In fact, I suspect that we over-use asserts in gRPC in general, and we should probably make an effort to stop doing that.  From the application author's perspective, it's extremely poor behavior on the part of a library to crash the whole process instead of returning some indication of an error to the caller.In general, I also don't think it's a good idea to silently ignore input, since that can cause confusion that may be hard to debug.  I think it's better to indicate a failure somehow, so that the caller immediately knows there's a problem.So, in principle, my ideal choice would be to somehow return an error to the caller.  However, in this particular case, I'm not sure if that's really the best behavior.  Do we really want to fail to create the LB policy just because the caller passes in user data that we don't know how to propagate?  I would certainly not want to accidentally cause a situation where (e.g.) a resolver provides user data but happens to choose an LB policy that doesn't support user data, thus causing RPCs to fail.Without more than one specific use-case of how callers might want to use the user data, it's hard to say what the best behavior is for the general case.  For example, if we knew that any caller that passes in user data will not be able to function correctly if the user data is not returned with the pick, then it's probably reasonable to fail at LB policy construction if the policy doesn't support user data, because we know that we won't be able to do what the caller wants.  However, if it's possible that the caller will be able to function in some sort of fall-back way without the user data, then the right thing is probably to proceed anyway.I think we're going to have to continue evaluating this as we find more use-cases in the future.  For now, I propose that we log an error instead of crashing in LB policy instantiation.  This is far from ideal, but it will prevent us from accidentally crashing if an unexpected LB policy is chosen, and it will provide at least some indication of the problem to a developer trying to implement a new resolver or LB policy.Hmmm... I just had another thought here that might avoid this problem entirely.  What if we created a map in the grpclb policy that maps the backend address to the LB token.  Then, when the RR policy returns the subchannel, we check to see what backend address the subchannel is for, and we look up the LB token for that address in our map.  That way, we could completely avoid adding the user data to the LB policy API, which would eliminate this entire problem.  What do you think?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8108,79014177,2016-09-15T17:08:28Z,tools/run_tests/run_performance_tests.py,"@@ -411,42 +423,31 @@ def finish_qps_workers(jobs):   build_local = True build_on_remote_hosts(remote_hosts, languages=[str(l) for l in languages], build_local=build_local) -qpsworker_jobs = start_qpsworkers(languages, args.remote_worker_host)--# TODO(jtattermusch): see https://github.com/grpc/grpc/issues/6174-time.sleep(5)+qpsworker_jobs = create_qpsworkers(languages, args.remote_worker_host)  # get list of worker addresses for each language.-worker_addresses = dict([(str(language), []) for language in languages])+workers_by_lang = dict([(str(language), []) for language in languages]) for job in qpsworker_jobs:-  worker_addresses[str(job.language)].append(job.host_and_port)--try:-  scenarios = create_scenarios(languages,-                               workers_by_lang=worker_addresses,-                               remote_host=args.remote_driver_host,-                               regex=args.regex,-                               category=args.category,-                               bq_result_table=args.bq_result_table,-                               netperf=args.netperf,-                               netperf_hosts=args.remote_worker_host)--  if not scenarios:-    raise Exception('No scenarios to run')--  jobset.message('START', 'Running scenarios.', do_newline=True)-  num_failures, _ = jobset.run(-      scenarios, newline_on_success=True, maxjobs=1)-  if num_failures == 0:-    jobset.message('SUCCESS',-                   'All scenarios finished successfully.',-                   do_newline=True)-  else:-    jobset.message('FAILED', 'Some of the scenarios failed.',-                   do_newline=True)-    sys.exit(1)-except:-  traceback.print_exc()-  raise-finally:-  finish_qps_workers(qpsworker_jobs)+  workers_by_lang[str(job.language)].append(job)++scenarios = create_scenarios(languages,+                           workers_by_lang=workers_by_lang,+                           remote_host=args.remote_driver_host,+                           regex=args.regex,+                           category=args.category,+                           bq_result_table=args.bq_result_table,+                           netperf=args.netperf,+                           netperf_hosts=args.remote_worker_host)++if not scenarios:+  raise Exception('No scenarios to run')++for scenario in scenarios:+  try:","This try block used to be connected to an except, but no longer. Any reason? Was it not actually used?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8033,79078267,2016-09-15T22:46:42Z,src/compiler/python_generator.cc,"@@ -232,10 +232,14 @@ static void PrintAllComments(const DescriptorType* desc, Printer* printer) { bool PrintBetaServicer(const ServiceDescriptor* service,                        Printer* out) {   out->Print(""\n\n"");-  out->Print(""class Beta$Service$Servicer(object):\n"", ""Service"",-             service->name());+  out->Print(""class Beta$Service$Servicer(object):\n"",",The changes on these two lines (and on similar lines elsewhere) appear to have no effect and are unrelated to the semantic change of this commit. Accidental edits?,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/7846,79096664,2016-09-16T01:59:48Z,doc/core/pending_api_cleanups.md,"@@ -0,0 +1,15 @@+There are times when we make changes that include a temporary shim for","Why bump the _minor_ version number when making breaking changes, instead of the major number as semantic versioning requires? That messes with users of dependency managers that understand semantic versioning.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8050,79136195,2016-09-16T09:35:31Z,doc/environment_variables.md,"@@ -0,0 +1,64 @@+gRPC environment variables+--------------------------++gRPC C core based implementations (those contained in this repository) expose+some configuration as environment variables that can be set.++* GRPC_ABORT_ON_LEAKS+  A debugging aid to cause a call to abort() when gRPC objects are leaked past+  grpc_shutdown(). Set to 1 to cause the abort, if unset or 0 it does not+  abort the process.++* GRPC_GOOGLE_CREDENTIALS_ENV_VAR","Ok, I found it:https://github.com/grpc/grpc/blob/dde6dfbb0bd1dfb3deac0b4f703d63528e1dc798/include/grpc/grpc_security_constants.h#L57:-)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7846,79181888,2016-09-16T14:34:48Z,doc/core/pending_api_cleanups.md,"@@ -0,0 +1,15 @@+There are times when we make changes that include a temporary shim for",Whoops -- that was a brain-fart on my part.  Fixed.,
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/8113,79209178,2016-09-16T16:56:47Z,test/cpp/end2end/end2end_test.cc,"@@ -1322,6 +1333,40 @@ TEST_P(SecureEnd2endTest, OverridePerCallCredentials) {   EXPECT_TRUE(s.ok()); } +TEST_P(SecureEnd2endTest, AuthMetadataPluginKeyFailure) {+  ResetStub();+  EchoRequest request;+  EchoResponse response;+  ClientContext context;+  context.set_credentials(+      MetadataCredentialsFromPlugin(std::unique_ptr<MetadataCredentialsPlugin>(+          new TestMetadataCredentialsPlugin(+              TestMetadataCredentialsPlugin::kBadMetadataKey,+              ""Does not matter, will fail the key is invalid."", false, true))));+  request.set_message(""Hello"");++  Status s = stub_->Echo(&context, request, &response);+  EXPECT_FALSE(s.ok());+  EXPECT_EQ(s.error_code(), StatusCode::UNAUTHENTICATED);+}++TEST_P(SecureEnd2endTest, AuthMetadataPluginValueFailure) {+  ResetStub();+  EchoRequest request;+  EchoResponse response;+  ClientContext context;+  context.set_credentials(+      MetadataCredentialsFromPlugin(std::unique_ptr<MetadataCredentialsPlugin>(+          new TestMetadataCredentialsPlugin(+              TestMetadataCredentialsPlugin::kGoodMetadataKey,+              ""With binary \n data"", false, true))));",I didn't know that `\n` was considered as binary data. Maybe just for headers though. Maybe add a comment.,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/8113,79214748,2016-09-16T17:30:09Z,test/cpp/end2end/end2end_test.cc,"@@ -1322,6 +1333,40 @@ TEST_P(SecureEnd2endTest, OverridePerCallCredentials) {   EXPECT_TRUE(s.ok()); } +TEST_P(SecureEnd2endTest, AuthMetadataPluginKeyFailure) {+  ResetStub();+  EchoRequest request;+  EchoResponse response;+  ClientContext context;+  context.set_credentials(+      MetadataCredentialsFromPlugin(std::unique_ptr<MetadataCredentialsPlugin>(+          new TestMetadataCredentialsPlugin(+              TestMetadataCredentialsPlugin::kBadMetadataKey,+              ""Does not matter, will fail the key is invalid."", false, true))));+  request.set_message(""Hello"");++  Status s = stub_->Echo(&context, request, &response);+  EXPECT_FALSE(s.ok());+  EXPECT_EQ(s.error_code(), StatusCode::UNAUTHENTICATED);+}++TEST_P(SecureEnd2endTest, AuthMetadataPluginValueFailure) {+  ResetStub();+  EchoRequest request;+  EchoResponse response;+  ClientContext context;+  context.set_credentials(+      MetadataCredentialsFromPlugin(std::unique_ptr<MetadataCredentialsPlugin>(+          new TestMetadataCredentialsPlugin(+              TestMetadataCredentialsPlugin::kGoodMetadataKey,+              ""With binary \n data"", false, true))));",Updated the metadata message a bit :),
6081171,thunderboltsid,https://api.github.com/repos/grpc/grpc/pulls/8033,79275680,2016-09-17T04:03:44Z,src/compiler/python_generator.cc,"@@ -232,10 +232,14 @@ static void PrintAllComments(const DescriptorType* desc, Printer* printer) { bool PrintBetaServicer(const ServiceDescriptor* service,                        Printer* out) {   out->Print(""\n\n"");-  out->Print(""class Beta$Service$Servicer(object):\n"", ""Service"",-             service->name());+  out->Print(""class Beta$Service$Servicer(object):\n"",","Yes, accidental edits. Fixed.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8137,79426100,2016-09-19T16:05:33Z,src/python/grpcio/grpc/_channel.py,"@@ -843,17 +843,11 @@ def _unsubscribe(state, callback):  def _options(options):   if options is None:",Favor```if <condition>:  return <first expression>else:  return <second expression>```over```if <condition>:  <name> = <first expression>else:  <name> = <second expression>return <name>```.(Also avoid reassigning behavior parameters when you can.),
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/8125,79453519,2016-09-19T18:10:03Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -96,6 +96,10 @@  * - Implement LB service forwarding (point 2c. in the doc's diagram).  */ +/* We currently need this at the top of the file if we import some iomgr","Don't we have the same restriction with Windows headers ? At the end, libuv trying to be a crossplatform library will have the same limitation as the whole set of platforms it supports, including Windows.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/8125,79459540,2016-09-19T18:38:29Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -96,6 +96,10 @@  * - Implement LB service forwarding (point 2c. in the doc's diagram).  */ +/* We currently need this at the top of the file if we import some iomgr","At Craig's suggestion, I am currently attempting to minimize the use of platform-specific headers by modifying APIs to use platform-independent types where possible.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8033,79530044,2016-09-20T03:14:37Z,src/compiler/python_generator.cc,"@@ -236,6 +236,10 @@ bool PrintBetaServicer(const ServiceDescriptor* service,              service->name());   {     IndentScope raii_class_indent(out);+    out->Print(""\""\""\""The Beta API is deprecated for 0.15.0 and later.\n""+    ""\nIt is recommended to use the GA API for all further purposes. This\n""","Here and below, after ""the GA API"", please add a parenthetical phrase explaining what the GA API is to the user who may not have heard the term before. Something like `(the classes and functions in this file without ""beta"" in their names)`? Any thoughts on wordsmithing that?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/7933,79530914,2016-09-20T03:28:31Z,tools/run_tests/run_tests.py,"@@ -155,6 +155,8 @@ def configure(self, config, args):                                                                        self.args.compiler)    def test_specs(self):+    if self.args.compiler == 'freepass' and self.args.travis:+      return []","In nearly every other code review these days I say ""never write a list where a tuple will do"".This file might just have to wait, it might look weird to be inconsistent and it's much too much of a change to make in the same pull request as something semantically unrelated.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8049,79670429,2016-09-20T17:45:14Z,src/core/ext/client_config/lb_policy_factory.h,"@@ -82,9 +87,12 @@ void grpc_lb_addresses_destroy(grpc_lb_addresses *addresses,                                void (*user_data_destroy)(void *));  /** Arguments passed to LB policies. */+/* TODO(roth, ctiller): Consider replacing this struct with+   grpc_channel_args.  See comment in resolver_result.h for details. */ typedef struct grpc_lb_policy_args {   grpc_lb_addresses *addresses;   grpc_client_channel_factory *client_channel_factory;+  grpc_channel_args *additional_args;","I added a comment explaining that it's for passing in implementation-specific parameters to the LB policy.  But since we don't actually have any use-cases for this yet, I don't have an example to add.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8158,79953499,2016-09-21T23:17:41Z,src/csharp/Grpc.Core/Internal/UnmanagedLibrary.cs,"@@ -215,5 +223,19 @@ private static class Mono             [DllImport(""__Internal"")]             internal static extern IntPtr dlsym(IntPtr handle, string symbol);         }++        /// <summary>+        /// Similarly as for Mono on Linux, we load symbols for+        /// dlopen and dlsym from the ""libcoreclr.so"",+        /// to avoid the dependency on libc-dev Linux.+        /// </summary>+        private static class CoreCLR+        {+            [DllImport(""libcoreclr.so"")]+            internal static extern IntPtr dlopen(string filename, int flags);","we only load using netcore library when running netcore on linux, not on windows as well correct?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8158,79988840,2016-09-22T07:44:18Z,src/csharp/Grpc.Core/Internal/UnmanagedLibrary.cs,"@@ -215,5 +223,19 @@ private static class Mono             [DllImport(""__Internal"")]             internal static extern IntPtr dlsym(IntPtr handle, string symbol);         }++        /// <summary>+        /// Similarly as for Mono on Linux, we load symbols for+        /// dlopen and dlsym from the ""libcoreclr.so"",+        /// to avoid the dependency on libc-dev Linux.+        /// </summary>+        private static class CoreCLR+        {+            [DllImport(""libcoreclr.so"")]+            internal static extern IntPtr dlopen(string filename, int flags);","Yes, that's right. On windows we are using LoadLibrary and on mac we are using dlopen from libSystem.dylib (all macs have that library installed).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8163,79995010,2016-09-22T08:29:52Z,src/php/README.md,"@@ -98,44 +128,48 @@ $ ./bin/run_tests.sh  ## Generated Code Tests -This section specifies the prerequisites for running the generated code tests, as well as how to run the tests themselves.+This section specifies the prerequisites for running the generated code tests,+as well as how to run the tests themselves.  ### Composer -If you don't have it already, install `composer` to pull in some runtime dependencies based on the `composer.json` file.+Install the runtime dependencies via `composer install`.  ```sh-$ curl -sS https://getcomposer.org/installer | php-$ sudo mv composer.phar /usr/local/bin/composer- $ cd grpc/src/php $ composer install ```  ### Protobuf compiler -Again if you don't have it already, you need to install the protobuf compiler `protoc`, version 3.0.0+.+Again if you don't have it already, you need to install the protobuf compiler+`protoc`, version 3.1.0-alpha-1+. -If you compiled the gRPC C core library from source above, the `protoc` binary should have been installed as well. If it hasn't been installed, you can run the following commands to install it.+If `protoc` hasn't been installed, you can run the following commands to+install it.  ```sh $ cd grpc/third_party/protobuf-$ sudo make install   # 'make' should have been run by core grpc+$ ./autogen.sh && ./configure && make+$ sudo make install ``` -Alternatively, you can download `protoc` binaries from [the protocol buffers Github repository](https://github.com/google/protobuf/releases).+Alternatively, you can download the `protoc` binaries from+[the protocol buffers Github repository](https://github.com/google/protobuf/releases).+ +### PHP Protoc Plugin -### PHP protobuf compiler+You need to install the gRPC PHP protoc plugin to generate the client stub+classes. -You need to install `protoc-gen-php` to generate stub class `.php` files from service definition `.proto` files.+Note: You don't need to do this if you had compiled the gRPC C core from+source, i.e. if you had run `make` from the root directory from this repo.  ```sh-$ git clone https://github.com/stanley-cheung/Protobuf-PHP-$ cd Protobuf-PHP-$ gem install rake ronn-$ rake pear:package version=1.0-$ sudo pear install Protobuf-1.0.tgz+$ git clone https://github.com/grpc/grpc+$ make plugins+$ sudo make install-plugins","Same as above, eventually there should be a package that provides protoc and plugins (once you install here, there's no way of uninstalling and that's really bad).",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8163,79995560,2016-09-22T08:33:24Z,src/php/bin/generate_proto_php.sh,"@@ -28,13 +28,32 @@ # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. - set +e-cd $(dirname $0)+cd $(dirname $0)/../../..++protoc --proto_path=src/proto/math \+       --php_out=src/php/tests/generated_code \+       --grpc_out=src/php/tests/generated_code \+       --plugin=protoc-gen-grpc=$(which grpc_php_plugin) \+       src/proto/math/math.proto -gen_code='../tests/generated_code'-interop='../tests/interop'+# replace the Empty message with EmptyMessage+# because Empty is a PHP reserved word",Actually at some point the protoc for PHP should be clever enough and have a list of reserved words and alter the names in the generated code so they don't collide. (Empty becomes `Empty_` or so). Is there a plan for that?,
6081171,thunderboltsid,https://api.github.com/repos/grpc/grpc/pulls/8033,80117288,2016-09-22T19:25:20Z,src/compiler/python_generator.cc,"@@ -236,6 +236,10 @@ bool PrintBetaServicer(const ServiceDescriptor* service,              service->name());   {     IndentScope raii_class_indent(out);+    out->Print(""\""\""\""The Beta API is deprecated for 0.15.0 and later.\n""+    ""\nIt is recommended to use the GA API for all further purposes. This\n""","""classes and functions in this file not marked beta"" is a bit better. Take a look now.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8182,80202474,2016-09-23T08:35:35Z,tools/run_tests/dockerize/docker_run_tests.sh,"@@ -42,7 +42,11 @@ export PATH=$PATH:/usr/bin/llvm-symbolizer chown $(whoami) $XDG_CACHE_HOME  mkdir -p /var/local/git-git clone --recursive /var/local/jenkins/grpc /var/local/git/grpc+git clone /var/local/jenkins/grpc /var/local/git/grpc++# clone gRPC submodules","I think adding an explanatory comment would be useful for future generations.`# clone gRPC submodules, use data from locally cloned submodules where possible'",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8182,80203523,2016-09-23T08:42:36Z,tools/run_tests/dockerize/docker_run_tests.sh,"@@ -42,7 +42,11 @@ export PATH=$PATH:/usr/bin/llvm-symbolizer chown $(whoami) $XDG_CACHE_HOME  mkdir -p /var/local/git-git clone --recursive /var/local/jenkins/grpc /var/local/git/grpc+git clone /var/local/jenkins/grpc /var/local/git/grpc++# clone gRPC submodules+(cd /var/local/git/grpc/ && exec git submodule | awk '{ system(""git submodule \","What's here seems to be working but there seems to be some unnecessary complexity (the exec command), awk system, etc. I see they are there for a reason but it makes me wonder  - and others will probably wonder too, especially if they don't know what the idea behind this command ishow about```# clone each submodule using a local reference repo to avoid downloading entire submodules from github each timegit submodule foreach 'cd /var/local/jenkins/grpc && git submodule update --init --reference ../../jenkins/grpc/${name} ${name}'```",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8182,80430180,2016-09-26T08:46:13Z,test/distrib/cpp/run_distrib_test.sh,"@@ -30,9 +30,14 @@  set -ex -git clone --recursive $EXTERNAL_GIT_ROOT+git clone $EXTERNAL_GIT_ROOT cd grpc +# clone gRPC submodules, use data from locally cloned submodules where possible+git submodule update --init --recursive --reference $EXTERNAL_GIT_SUBMODULES_ROOT+# if local gRPC submodules clone fails, clone via network","if local submodules clone fails, wouldn't that terminate the script because of `set -ex` above?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8182,80432250,2016-09-26T08:57:45Z,tools/dockerfile/grpc_scan_build/Dockerfile,"@@ -41,6 +41,19 @@ RUN git clone --recursive https://github.com/grpc/grpc.git EXPOSE 8181  CMD \+  # creating a repository for gRPC submodules for local cloning+  # this list should be updated when the list of submodules for gRPC changes+  mkdir grpc-submodules && cd grpc-submodules && \","Another problem is you are manually listing all the submodules here. The day we add a new submodule, there's a very high chance we will forget to manually update the list.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/7771,80519519,2016-09-26T16:50:46Z,src/core/ext/client_config/client_channel.c,"@@ -769,13 +770,14 @@ void grpc_client_channel_set_resolver(grpc_exec_ctx *exec_ctx,   GPR_ASSERT(!chand->resolver);   chand->resolver = resolver;   GRPC_RESOLVER_REF(resolver, ""channel"");-  if (!grpc_closure_list_empty(chand->waiting_for_config_closures) ||-      chand->exit_idle_when_lb_policy_arrives) {-    chand->started_resolving = true;-    GRPC_CHANNEL_STACK_REF(chand->owning_stack, ""resolver"");-    grpc_resolver_next(exec_ctx, resolver, &chand->resolver_result,-                       &chand->on_resolver_result_changed);-  }+  // TODO(zyc): check if the following part is needed",If it's not we should refactor it as an `ASSERT(!previous_condition)`,
13909816,daniel-j-born,https://api.github.com/repos/grpc/grpc/pulls/8073,80590807,2016-09-26T22:50:51Z,src/core/lib/iomgr/tcp_server_posix.c,"@@ -736,18 +745,21 @@ void grpc_tcp_server_shutdown_starting_add(grpc_tcp_server *s,  void grpc_tcp_server_unref(grpc_exec_ctx *exec_ctx, grpc_tcp_server *s) {   if (gpr_unref(&s->refs)) {-    /* Complete shutdown_starting work before destroying. */     grpc_exec_ctx local_exec_ctx = GRPC_EXEC_CTX_INIT;+    bool finish_ctx = false;+    /* FIXME: API allows a NULL exec_ctx, although this might cause us to delete","There were some test cases that passed NULL, but they are gone now, so I'll remove it from the API.There is some vendor-specific code that passes NULL. Did you ever consider having exec_ctx come from thread-local data rather than a parameter to every function?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/7933,80903925,2016-09-28T12:31:46Z,tools/run_tests/run_tests.py,"@@ -878,6 +957,43 @@ def runs_per_test_type(arg_str):         msg = '\'{}\' is not a positive integer or \'inf\''.format(arg_str)         raise argparse.ArgumentTypeError(msg) +_COMPILER_CHOICES = ('default',+                     'gcc4.4', 'gcc4.6', 'gcc4.9', 'gcc5.3',+                     'clang3.4', 'clang3.5', 'clang3.6', 'clang3.7',+                     'vs2010', 'vs2013', 'vs2015',+                     'python2.7', 'python3.4',+                     'node0.12', 'node4', 'node5',+                     'coreclr',+                     _FREE_PASS,)+++def _is_travis_enabled():","ok, just noticed this function. really dirty. Arguments are already being parsed by argparse and we should really stick with that.What you could do:just accept anything as --compiler value (and perhaps add list of allowed values to the help string), and right after parsing cmdline arguments with argparse, evaluate if compiler value is supported (while looking at args.travis value).That would also help you get rid of the _compiler_choices function which is a bit confusing anyway.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/8101,80950654,2016-09-28T15:49:24Z,test/cpp/interop/interop_server.cc,"@@ -152,6 +153,16 @@ class TestServiceImpl : public TestService::Service {     return Status::OK;   } +  // Response contains current timestamp. We ignore everything in the request.+  Status CacheableUnaryCall(ServerContext* context, const SimpleRequest* request,+                   SimpleResponse* response) {+    gpr_timespec ts = gpr_now(GPR_CLOCK_REALTIME);+    std::string timestamp = std::to_string(ts.tv_nsec);+    response->mutable_payload()->set_body(timestamp.c_str(), timestamp.size());+    context->AddInitialMetadata(""cache-control"", ""max-age=100000, public"");","Should we just set a max age of 60 seconds, or similar? Why cache it so long?",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/8101,80952312,2016-09-28T15:56:24Z,src/proto/grpc/testing/test.proto,"@@ -47,6 +47,11 @@ service TestService {   // One request followed by one response.   rpc UnaryCall(SimpleRequest) returns (SimpleResponse); +  // One request followed by one response. Response has cache control+  // headers set such that a caching HTTP proxy (such as GFE) can+  // satisfy subsequent requests.+  rpc CacheableUnaryCall(SimpleRequest) returns (SimpleResponse);","Since this isn't defining itself as being cachable, I guess you should add a section (marked as temporary) to the client spec saying to enable caching for the request?",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/8101,80977510,2016-09-28T17:50:45Z,src/proto/grpc/testing/test.proto,"@@ -47,6 +47,11 @@ service TestService {   // One request followed by one response.   rpc UnaryCall(SimpleRequest) returns (SimpleResponse); +  // One request followed by one response. Response has cache control+  // headers set such that a caching HTTP proxy (such as GFE) can+  // satisfy subsequent requests.+  rpc CacheableUnaryCall(SimpleRequest) returns (SimpleResponse);","It doesn't have any option on it to define it as safe/cachable. Since that is missing, manually specifying in the test seems required. We should specify that, although we should probably note that it is temporary until this proto is fixed.",
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/8101,80978528,2016-09-28T17:55:05Z,doc/interop-test-descriptions.md,"@@ -965,13 +969,12 @@ for the `SimpleRequest.response_type`. If the server does not support the ### CacheableUnaryCall  Server gets the default SimpleRequest proto as the request. The content of the-request are ignored. It returns the SimpleResponse proto with the payload set -to current timestamp string.  In addition it adds+request is ignored. It returns the SimpleResponse proto with the payload set+to current timestamp.  The timestamp is an integer representing current time","""integer"" is still ambiguous, since it is encoded as bytes. If binary, is it big- or little-endian? If not binary, is it ASCII hex, or decimal? If the format doesn't matter, just say the server needs to be consistent.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/8228,81012502,2016-09-28T20:43:05Z,src/core/lib/iomgr/tcp_posix.c,"@@ -204,10 +204,16 @@ static void tcp_continue_read(grpc_exec_ctx *exec_ctx, grpc_tcp *tcp) {   msg.msg_name = NULL;   msg.msg_namelen = 0;   msg.msg_iov = iov;+#ifndef __hpux","Please do not have code in different branches of an `#ifdef` or only partly within an `#ifdef` within a single C file. If you need multiple implementations of a single piece of functionality, put them in different conditionally compiled C files. This file is an example of that, as compared with `tcp_windows.c`.Also, don't use `__hpux` for this check. Instead, define a constant in `port_platform.h` like `GPR_HPUX_POSIX_SOCKET` to check.In addition, please avoid using `#ifndef`. Instead, define an additional constant to indicate that we should use the non-HP-UX implementation.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8008,81163033,2016-09-29T15:23:30Z,src/core/lib/iomgr/combiner.c,"@@ -51,24 +51,53 @@ int grpc_combiner_trace = 0;   } while (0)  struct grpc_combiner {+  grpc_combiner *next_combiner_on_this_exec_ctx;   grpc_workqueue *optional_workqueue;   gpr_mpscq queue;   // state is:   // lower bit - zero if orphaned   // other bits - number of items queued on the lock   gpr_atm state;-  bool take_async_break_before_final_list;+  // number of elements in the list that are covered by a poller: if >0, we can+  // offload safely+  gpr_atm covered_by_poller;+  bool time_to_execute_final_list;+  bool final_list_covered_by_poller;   grpc_closure_list final_list;-  grpc_closure continue_finishing;+  grpc_closure offload; }; +static void offload(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);++typedef struct {+  grpc_error *error;+  bool covered_by_poller;+} error_data;++static uintptr_t pack_error_data(error_data d) {+  return ((uintptr_t)d.error) | (d.covered_by_poller ? 1 : 0);","I know that we use these constructs a lot, but is there a point when this will come back to bite us (or maybe byte us) in some portability or other context that we don't have to worry about? Should we start a separate markdown list of hackish constructs for future reference?",
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/8223,81281058,2016-09-30T05:44:01Z,src/objective-c/GRPCClient/GRPCCall.h,"@@ -155,6 +155,19 @@ typedef NS_ENUM(NSUInteger, GRPCErrorCode) { };  /**+ * Flags for options of a gRPC call+ *+ */+typedef NS_OPTIONS(NSUInteger, GRPCCallFlags) {+  /** Signal that the call is idempotent */+  GRPCFlagIdempotentRequest = 0x00000010,+  /** Signal that the call should not return UNAVAILABLE before it has started */+  GRPCFlagIgnoreConnectivity = 0x00000020,",Not sure if this is true. I think it is client side that uses these flags and include them in the initial metadata header,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8248,81350414,2016-09-30T14:34:14Z,src/core/ext/client_config/http_connect_handshaker.h,"@@ -34,14 +34,20 @@ #ifndef GRPC_CORE_EXT_CLIENT_CONFIG_HTTP_CONNECT_HANDSHAKER_H #define GRPC_CORE_EXT_CLIENT_CONFIG_HTTP_CONNECT_HANDSHAKER_H +#include <stdbool.h>+ #include ""src/core/lib/channel/handshaker.h"" -/// Does NOT take ownership of \a proxy_server or \a server_name.-grpc_handshaker* grpc_http_connect_handshaker_create(const char* proxy_server,-                                                     const char* server_name);+/// Does NOT take ownership of \a server_name or \a authority. These two+/// arguments will be the same most of the time except for load balanced","I don't think that we've yet agreed exactly how we'll handle load-balanced connections via a proxy.  I'd like to conclude that discussion and come to agreement on a design before we start adding parameters to support one particular solution.That having been said, you are certainly correct that the Host: header should be set to the server name in most cases.  So for now, let's just make that change, and we can deal with the rest once we've resolved the open issues about load-balancing via proxies.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8008,81350555,2016-09-30T14:34:56Z,src/core/lib/surface/call.c,"@@ -1038,9 +1039,14 @@ static void finish_batch_completion(grpc_exec_ctx *exec_ctx, void *user_data, static void post_batch_completion(grpc_exec_ctx *exec_ctx,                                   batch_control *bctl) {   grpc_call *call = bctl->call;+  grpc_error *error = bctl->error;+  if (bctl->recv_final_op) {+    GRPC_ERROR_UNREF(error);+    error = GRPC_ERROR_NONE;+  }   if (bctl->is_notify_tag_closure) {     /* unrefs bctl->error */-    grpc_exec_ctx_sched(exec_ctx, bctl->notify_tag, bctl->error, NULL);+    grpc_closure_run(exec_ctx, bctl->notify_tag, error);","closure_run is new, and its use is replicated around a bunch in this PR. This branch ('direct-calls') gets its name from closure_run's use. There's some locality advantages from bringing the chaining together (not a big surprise). What was a surprise is that most uses of exec_ctx_sched were from closures themselves, which are ('by definition') safe points for executing closures. So... small win from just executing stuff. We get a bigger win because since combiner locks execute closures, and they ALSO execute them from safe points, by directly executing the closure, we avoid having to fiddle with the combiner lock state (by leaving it and falling back to the execution context), and so we make combiner locks a lot more of a win.Anyway, once this code drops, the advice changes from 'always use exec_ctx_sched' to 'use closure_run whenever you're at a provable safe point in the code, and use exec_ctx_sched at all other times'.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8223,81393868,2016-09-30T18:33:28Z,src/objective-c/GRPCClient/GRPCCall.h,"@@ -155,6 +155,19 @@ typedef NS_ENUM(NSUInteger, GRPCErrorCode) { };  /**+ * Flags for options of a gRPC call+ *+ */+typedef NS_OPTIONS(NSUInteger, GRPCCallFlags) {+  /** Signal that the call is idempotent */+  GRPCFlagIdempotentRequest = 0x00000010,+  /** Signal that the call should not return UNAVAILABLE before it has started */+  GRPCFlagIgnoreConnectivity = 0x00000020,+  /** Signal that the call is cacheable. GRPC is free to use GET verb */+  GRPCFlagCacheableRequest = 0x00000040,","> when it is set ""idempotent"" is automatically considered setIs it?> there might be other flags in the future that are orthogonal to these two flagsWe won't need to expose those future flags to the user as part of the same `int`, so that shouldn't be a problem. Think of it this other way:This is essentially a way to tell the library whether to use `POST`, `PUT`, or `GET` as an HTTP verb for this method. If we were exposing it that way, as a ""verb"" parameter for which the user can provide one of those values, we would never consider adding other stuff like ""ignore connectivity"" to the same parameter. It would be unnatural and unnecessary (nothing forces you to cram two different things in the same parameter). And we'd never think of exposing the verbs as a bitmask, rather as an enum: Otherwise if in the future gRPC wanted to use `DELETE` too, you'd end up with a comment saying ""only 1 bit of this mask can be set"".(That's in general what I meant with designing the feature from the user perspective, instead of just exposing what the C library does. The C layer has language constraints that we don't have, and we have requirements of usability and intuitiveness that the C layer doesn't have.)Another possible design with HTTP verbs would be letting the user set the `@"":method""` `requestHeader` of a call. If you started with a design like that, you'd never end up with a bitmask to represent the verb.Now I'm not saying at all that we should expose to the user that this corresponds to an HTTP verb. The point is that what we want to do is attach a three-valued property to a gRPC method. Exposing that as a four-valued property of every call leaves the user prone to mistakes.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8223,81476181,2016-10-02T19:26:54Z,src/objective-c/GRPCClient/GRPCCall.h,"@@ -155,6 +155,18 @@ typedef NS_ENUM(NSUInteger, GRPCErrorCode) { };  /**+ * Flags for options of a gRPC call+ *+ */+typedef NS_ENUM(NSUInteger, GRPCCallAttr) {","s/Call/Method/, as it applies to methodsAttr: The convention for Objective-C naming is to [not abbreviate things](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingBasics.html#//apple_ref/doc/uid/20001281-1001751), so this would be Attribute. It's a long word, though, and vague (in the sense that all properties of something are attributes); so maybe you'd prefer something like Safety or Potency?",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8223,81476855,2016-10-02T20:05:49Z,src/objective-c/GRPCClient/GRPCCall.m,"@@ -106,6 +107,33 @@ @implementation GRPCCall { // TODO(jcanizales): If grpc_init is idempotent, this should be changed from load to initialize. + (void)load {   grpc_init();+  callFlags = [NSMutableDictionary dictionary];+}+++ (void)setCallAttribute:(GRPCCallAttr)callAttr host:(NSString *)host path:(NSString *)path {+  NSString *hostAndPath = [NSString stringWithFormat:@""%@%@"", host, path];+  switch (callAttr) {+    case GRPCCallAttrDefault:+      callFlags[hostAndPath] = @0;+      break;+    case GRPCCallAttrIdempotentRequest:+      callFlags[hostAndPath] = @GRPC_INITIAL_METADATA_IDEMPOTENT_REQUEST;+      break;+    case GRPCCallAttrCacheableRequest:+      callFlags[hostAndPath] = @GRPC_INITIAL_METADATA_CACHEABLE_REQUEST;+      break;+    default:+      break;+  }+}+++ (uint32_t)getCallFlag:(NSString *)host path:(NSString *)path {","`callFlagsForHost: path:`. With `getCallFlag:`, the parameter would be understood to be a flag. And methods should only start with ""get"" [if they return values indirectly via pointers passed as arguments](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html).",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8223,81480943,2016-10-02T23:42:30Z,src/objective-c/GRPCClient/GRPCCall.h,"@@ -155,6 +155,18 @@ typedef NS_ENUM(NSUInteger, GRPCErrorCode) { };  /**+ * Flags for options of a gRPC call","I'm not sure I support binding gRPC semantics to HTTP directly. There's very real possibilities of non-HTTP transports existing in the future, and with them we might explore different semantics.Better to outline what things mean for gRPC here.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8089,81580353,2016-10-03T15:56:19Z,include/grpc/impl/codegen/grpc_types.h,"@@ -380,7 +405,8 @@ typedef struct grpc_op {     } reserved;     struct {       size_t count;-      grpc_metadata *metadata;+      grpc_mdelem **metadata;+      grpc_linked_mdelem *metadata_storage;",metadata contains the same data as metadata_storage.It would seem worthwhile to find a way to unify these.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8253,81645485,2016-10-03T21:36:16Z,src/core/ext/client_config/client_channel.c,"@@ -602,9 +602,11 @@ static bool pick_subchannel(grpc_exec_ctx *exec_ctx, grpc_call_element *elem,     int r;     GRPC_LB_POLICY_REF(lb_policy, ""pick_subchannel"");     gpr_mu_unlock(&chand->mu);-    const grpc_lb_policy_pick_args inputs = {calld->pollent, initial_metadata,-                                             initial_metadata_flags,-                                             &calld->lb_token_mdelem};+    // TODO(dgq): use deadline for service config instead of inf_future for the","I'm not sure what you mean by ""deadline for service config"".  Let's just say something like ""Make this deadline configurable somehow"".",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/8246,81648070,2016-10-03T21:52:29Z,setup.py,"@@ -211,15 +211,19 @@ def cython_extensions_and_necessity():     'sphinx_rtd_theme>=0.1.8',     'six>=1.10', )-if BUILD_WITH_CYTHON:-  sys.stderr.write(-    ""You requested a Cython build via GRPC_PYTHON_BUILD_WITH_CYTHON, ""-    ""but do not have Cython installed. We won't stop you from using ""-    ""other commands, but the extension files will fail to build.\n"")-elif need_cython:-  sys.stderr.write(-      'We could not find Cython. Setup may take 10-20 minutes.\n')-  SETUP_REQUIRES += ('cython>=0.23',)++try:+  import Cython+except ImportError:+  if BUILD_WITH_CYTHON:+    sys.stderr.write(+      ""You requested a Cython build via GRPC_PYTHON_BUILD_WITH_CYTHON, ""+      ""but do not have Cython installed. We won't stop you from using ""+      ""other commands, but the extension files will fail to build.\n"")+  elif need_cython:+    sys.stderr.write(+        'We could not find Cython. Setup may take 10-20 minutes.\n')+    SETUP_REQUIRES += ('cython>=0.23',)","I'm almost inclined to avoid adding a setup dependency on cython.  Setup dependencies don't support wheels, and because there is no binary Cython egg, this forces the setup dependency to be built from source.  Whereas a setup dependency requires ~10 minutes to set up, recommending the user pip install Cython takes ~5 seconds.I figured I'd float the suggestion here.",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/7771,81655531,2016-10-03T22:41:24Z,src/core/ext/client_config/client_channel.c,"@@ -769,13 +770,14 @@ void grpc_client_channel_set_resolver(grpc_exec_ctx *exec_ctx,   GPR_ASSERT(!chand->resolver);   chand->resolver = resolver;   GRPC_RESOLVER_REF(resolver, ""channel"");-  if (!grpc_closure_list_empty(chand->waiting_for_config_closures) ||-      chand->exit_idle_when_lb_policy_arrives) {-    chand->started_resolving = true;-    GRPC_CHANNEL_STACK_REF(chand->owning_stack, ""resolver"");-    grpc_resolver_next(exec_ctx, resolver, &chand->resolver_result,-                       &chand->on_resolver_result_changed);-  }+  // TODO(zyc): check if the following part is needed",Many thanks for your reviews!Refactored as `ASSERT(!previous_condition)`,
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/8246,81670886,2016-10-04T01:00:39Z,src/compiler/python_generator.cc,"@@ -173,11 +116,62 @@ grpc::string ModuleAlias(const grpc::string& filename) {   return module_name; } -bool GetModuleAndMessagePath(const Descriptor* type,-                             const ServiceDescriptor* service,-                             grpc::string* out) {+// Tucks all generator state in an anonymous namespace away from+// PythonGrpcGenerator and the header file, mostly to encourage future changes+// to not require updates to the grpcio-tools C++ code part. Assumes that it is+// only ever used from a single thread.+struct PrivateGenerator {+  const GeneratorConfiguration& config;+  const FileDescriptor *file;++  bool split_pb2_grpc;",The naming of this variable is somewhat misleading.  What do you think of append_to_protobuf/append_to_pb2?I initially assumed this was a settable flag indicating if the grpc stuff should be in a separate file.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8246,82023520,2016-10-05T17:15:27Z,src/compiler/python_generator.cc,"@@ -646,42 +644,149 @@ bool PrintPreamble(const FileDescriptor* file,   out->Print(       ""from grpc.framework.interfaces.face import utilities as ""       ""face_utilities\n"");+  if (split_pb2_grpc) {+    out->Print(""\n"");+    // BEEEEEEES.+    for (int i = 0; i < file->service_count(); ++i) {+      const ServiceDescriptor *service = file->service(i);+      for (int j = 0; j < service->method_count(); ++j) {+        const MethodDescriptor *method = service->method(j);+        const Descriptor *types[2] = {method->input_type(), method->output_type()};+        for (int k = 0; k < 2; ++k) {+          const Descriptor *type = types[k];+          grpc::string type_file_name = type->file()->name();+          grpc::string module_name = ModuleName(type_file_name);+          grpc::string module_alias = ModuleAlias(type_file_name);+          out->Print(""import $ModuleName$ as $ModuleAlias$\n"", ""ModuleName"", module_name, ""ModuleAlias"", module_alias);+        }+      }+    }+  }   return true; } -}  // namespace+bool PrivateGenerator::PrintPreambledGAServices() {+  if (!PrintPreamble()) {+    return false;+  }+  grpc::string package = file->package();+  if (!package.empty()) {+    package = package.append(""."");+  }+  for (int i = 0; i < file->service_count(); ++i) {+    const ServiceDescriptor *service = file->service(i);+    grpc::string package_qualified_service_name = package + service->name();+    if (!(PrintStub(package_qualified_service_name, service) &&+          PrintServicer(service) &&+          PrintAddServicerToServer(package_qualified_service_name, service))) {+      return false;+    }+  }+  return true;+} -pair<bool, grpc::string> GetServices(const FileDescriptor* file,-                                     const GeneratorConfiguration& config) {+bool PrivateGenerator::PrintBetaServices() {+  grpc::string package = file->package();+  if (!package.empty()) {+    package = package.append(""."");+  }+  for (int i = 0; i < file->service_count(); ++i) {+    const ServiceDescriptor *service = file->service(i);+    grpc::string package_qualified_service_name = package + service->name();+    if (!(PrintBetaServicer(service) && PrintBetaStub(service) &&+          PrintBetaServerFactory(package_qualified_service_name, service) &&+          PrintBetaStubFactory(package_qualified_service_name, service))) {+      return false;+    }+  }+  return true;+}++pair<bool, grpc::string> PrivateGenerator::GetGrpcServices() {   grpc::string output;   {     // Scope the output stream so it closes and finalizes output to the string.     StringOutputStream output_stream(&output);-    Printer out(&output_stream, '$');-    if (!PrintPreamble(file, config, &out)) {-      return make_pair(false, """");-    }-    auto package = file->package();-    if (!package.empty()) {-      package = package.append(""."");-    }-    for (int i = 0; i < file->service_count(); ++i) {-      auto service = file->service(i);-      auto package_qualified_service_name = package + service->name();-      if (!(PrintStub(package_qualified_service_name, service, &out) &&-            PrintServicer(service, &out) &&-            PrintAddServicerToServer(package_qualified_service_name, service,-                                     &out) &&-            PrintBetaServicer(service, &out) && PrintBetaStub(service, &out) &&-            PrintBetaServerFactory(package_qualified_service_name, service,-                                   &out) &&-            PrintBetaStubFactory(package_qualified_service_name, service,-                                 &out))) {+    Printer out_printer(&output_stream, '$');+    out = &out_printer;++    if (split_pb2_grpc) {+      if (!PrintPreambledGAServices()) {         return make_pair(false, """");       }+    } else {+      out->Print(""try:\n"");+      {+        IndentScope raii_dict_try_indent(out);+        if (!PrintPreambledGAServices()) {+          return make_pair(false, """");+        }+        if (!PrintBetaServices()) {+          return make_pair(false, """");+        }+      }+      out->Print(""except ImportError:\n"");+      {+        IndentScope raii_dict_except_indent(out);+        out->Print(""pass"");+      }     }   }   return make_pair(true, std::move(output)); } +}  // namespace++GeneratorConfiguration::GeneratorConfiguration()+    : grpc_package_root(""grpc""), beta_package_root(""grpc.beta"") {}++PythonGrpcGenerator::PythonGrpcGenerator(const GeneratorConfiguration& config)+    : config_(config) {}++PythonGrpcGenerator::~PythonGrpcGenerator() {}++bool PythonGrpcGenerator::Generate(const FileDescriptor* file,+                                   const grpc::string& parameter,+                                   GeneratorContext* context,+                                   grpc::string* error) const {+  // Get output file name.+  grpc::string pb2_file_name;+  grpc::string grpc_file_name;+  static const int proto_suffix_length = strlen("".proto"");+  if (file->name().size() > static_cast<size_t>(proto_suffix_length) &&+      file->name().find_last_of("".proto"") == file->name().size() - 1) {+    grpc::string base = file->name().substr(+        0, file->name().size() - proto_suffix_length);+    pb2_file_name = base + ""_pb2.py"";+    grpc_file_name = base + ""_pb2_grpc.py"";+  } else {+    *error = ""Invalid proto file name. Proto file must end with .proto"";+    return false;+  }++  PrivateGenerator generator(config_, file);++  std::unique_ptr<ZeroCopyOutputStream> pb2_output(+      context->OpenForAppend(pb2_file_name));+  std::unique_ptr<ZeroCopyOutputStream> grpc_output(+      context->Open(grpc_file_name));+  CodedOutputStream pb2_coded_out(pb2_output.get());+  CodedOutputStream grpc_coded_out(grpc_output.get());+  bool success = false;+  grpc::string pb2_code;+  grpc::string grpc_code;+  generator.split_pb2_grpc = false;",The need for statefulness still isn't yet clear to me - why isn't this shaped like```success = write_one_point_oh_pb2_grpc_elements(pb2_out)if (success) {  success = write_ga_elements(pb2_grpc_out)  if (success) {    <WriteRaw calls>    return true;  }}return false;```with```def write_beta_elements(<parameters>):  <body>def write_ga_elements(<parameters>):  <body>def write_one_point_oh_pb2_grpc_elements(<parameters>):  <write try: and disclaimer>  write_ga_elements(<parameters>)  write_beta_elements(<parameters>)  <write except: and pass>```having already been defined in the file?,
21180148,soltanmm-google,https://api.github.com/repos/grpc/grpc/pulls/8246,82059924,2016-10-05T20:13:58Z,src/python/grpcio_tests/setup.py,"@@ -80,8 +80,8 @@         'credentials/server1.key',         'credentials/server1.pem',     ],-    'tests.protoc_plugin': [-        'protoc_plugin_test.proto',","I don't believe the file exists in our code-base anymore. I think it was split up at some point into the multiple proto files under `grpcio_tests/src/tests/protoc_plugin/protos`. Furthermore, those files that it was split up into are handled by the setuptools custom command as opposed to needing to be available on installation, so they never needed to be added back to the package data. OTOH, the `split_test.proto` _does_ because we need to use the old-style test of invoking `protoc` on it at test time in order to use the split-up-the-generated-source-between-multiple-directories-and-generate-arbitrary-trash approach.",
21180148,soltanmm-google,https://api.github.com/repos/grpc/grpc/pulls/8246,82062217,2016-10-05T20:24:47Z,src/compiler/python_generator.cc,"@@ -646,42 +644,149 @@ bool PrintPreamble(const FileDescriptor* file,   out->Print(       ""from grpc.framework.interfaces.face import utilities as ""       ""face_utilities\n"");+  if (split_pb2_grpc) {+    out->Print(""\n"");+    // BEEEEEEES.+    for (int i = 0; i < file->service_count(); ++i) {+      const ServiceDescriptor *service = file->service(i);+      for (int j = 0; j < service->method_count(); ++j) {+        const MethodDescriptor *method = service->method(j);+        const Descriptor *types[2] = {method->input_type(), method->output_type()};+        for (int k = 0; k < 2; ++k) {+          const Descriptor *type = types[k];+          grpc::string type_file_name = type->file()->name();+          grpc::string module_name = ModuleName(type_file_name);+          grpc::string module_alias = ModuleAlias(type_file_name);+          out->Print(""import $ModuleName$ as $ModuleAlias$\n"", ""ModuleName"", module_name, ""ModuleAlias"", module_alias);+        }+      }+    }+  }   return true; } -}  // namespace+bool PrivateGenerator::PrintPreambledGAServices() {+  if (!PrintPreamble()) {+    return false;+  }+  grpc::string package = file->package();+  if (!package.empty()) {+    package = package.append(""."");+  }+  for (int i = 0; i < file->service_count(); ++i) {+    const ServiceDescriptor *service = file->service(i);+    grpc::string package_qualified_service_name = package + service->name();+    if (!(PrintStub(package_qualified_service_name, service) &&+          PrintServicer(service) &&+          PrintAddServicerToServer(package_qualified_service_name, service))) {+      return false;+    }+  }+  return true;+} -pair<bool, grpc::string> GetServices(const FileDescriptor* file,-                                     const GeneratorConfiguration& config) {+bool PrivateGenerator::PrintBetaServices() {+  grpc::string package = file->package();+  if (!package.empty()) {+    package = package.append(""."");+  }+  for (int i = 0; i < file->service_count(); ++i) {+    const ServiceDescriptor *service = file->service(i);+    grpc::string package_qualified_service_name = package + service->name();+    if (!(PrintBetaServicer(service) && PrintBetaStub(service) &&+          PrintBetaServerFactory(package_qualified_service_name, service) &&+          PrintBetaStubFactory(package_qualified_service_name, service))) {+      return false;+    }+  }+  return true;+}++pair<bool, grpc::string> PrivateGenerator::GetGrpcServices() {   grpc::string output;   {     // Scope the output stream so it closes and finalizes output to the string.     StringOutputStream output_stream(&output);-    Printer out(&output_stream, '$');-    if (!PrintPreamble(file, config, &out)) {-      return make_pair(false, """");-    }-    auto package = file->package();-    if (!package.empty()) {-      package = package.append(""."");-    }-    for (int i = 0; i < file->service_count(); ++i) {-      auto service = file->service(i);-      auto package_qualified_service_name = package + service->name();-      if (!(PrintStub(package_qualified_service_name, service, &out) &&-            PrintServicer(service, &out) &&-            PrintAddServicerToServer(package_qualified_service_name, service,-                                     &out) &&-            PrintBetaServicer(service, &out) && PrintBetaStub(service, &out) &&-            PrintBetaServerFactory(package_qualified_service_name, service,-                                   &out) &&-            PrintBetaStubFactory(package_qualified_service_name, service,-                                 &out))) {+    Printer out_printer(&output_stream, '$');+    out = &out_printer;++    if (split_pb2_grpc) {+      if (!PrintPreambledGAServices()) {         return make_pair(false, """");       }+    } else {+      out->Print(""try:\n"");+      {+        IndentScope raii_dict_try_indent(out);+        if (!PrintPreambledGAServices()) {+          return make_pair(false, """");+        }+        if (!PrintBetaServices()) {+          return make_pair(false, """");+        }+      }+      out->Print(""except ImportError:\n"");+      {+        IndentScope raii_dict_except_indent(out);+        out->Print(""pass"");+      }     }   }   return make_pair(true, std::move(output)); } +}  // namespace++GeneratorConfiguration::GeneratorConfiguration()+    : grpc_package_root(""grpc""), beta_package_root(""grpc.beta"") {}++PythonGrpcGenerator::PythonGrpcGenerator(const GeneratorConfiguration& config)+    : config_(config) {}++PythonGrpcGenerator::~PythonGrpcGenerator() {}++bool PythonGrpcGenerator::Generate(const FileDescriptor* file,+                                   const grpc::string& parameter,+                                   GeneratorContext* context,+                                   grpc::string* error) const {+  // Get output file name.+  grpc::string pb2_file_name;+  grpc::string grpc_file_name;+  static const int proto_suffix_length = strlen("".proto"");+  if (file->name().size() > static_cast<size_t>(proto_suffix_length) &&+      file->name().find_last_of("".proto"") == file->name().size() - 1) {+    grpc::string base = file->name().substr(+        0, file->name().size() - proto_suffix_length);+    pb2_file_name = base + ""_pb2.py"";+    grpc_file_name = base + ""_pb2_grpc.py"";+  } else {+    *error = ""Invalid proto file name. Proto file must end with .proto"";+    return false;+  }++  PrivateGenerator generator(config_, file);++  std::unique_ptr<ZeroCopyOutputStream> pb2_output(+      context->OpenForAppend(pb2_file_name));+  std::unique_ptr<ZeroCopyOutputStream> grpc_output(+      context->Open(grpc_file_name));+  CodedOutputStream pb2_coded_out(pb2_output.get());+  CodedOutputStream grpc_coded_out(grpc_output.get());+  bool success = false;+  grpc::string pb2_code;+  grpc::string grpc_code;+  generator.split_pb2_grpc = false;","Oh, right: https://github.com/grpc/grpc/pull/8246/files/066fffe0a05401b13b62ed9587ec93d85dca4a66#diff-d5adca4a2d1e65549a73db695e0db419R187Because there's a lot of shared code between the two up to one tiny difference towards the end and by my not wanting to use lambdas (to make it easier to get to C++98 compatibility) passing around behavior becomes difficult. So instead I used a flag. Totally open to a different strategy (that preferably doesn't involve adding many new declarations).",
21180148,soltanmm-google,https://api.github.com/repos/grpc/grpc/pulls/8246,82063156,2016-10-05T20:29:21Z,src/compiler/python_generator.cc,"@@ -173,11 +116,62 @@ grpc::string ModuleAlias(const grpc::string& filename) {   return module_name; } -bool GetModuleAndMessagePath(const Descriptor* type,-                             const ServiceDescriptor* service,-                             grpc::string* out) {+// Tucks all generator state in an anonymous namespace away from+// PythonGrpcGenerator and the header file, mostly to encourage future changes+// to not require updates to the grpcio-tools C++ code part. Assumes that it is+// only ever used from a single thread.+struct PrivateGenerator {+  const GeneratorConfiguration& config;+  const FileDescriptor *file;++  bool split_pb2_grpc;","`split` is an ambiguous word here, yes... I'm lukewarm towards `append_to_*`, because inserting at module scope as we do is basically the same as appending. The variable might disappear in another pass, though, so I'ma defer thinking of a new name to a later point in review.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8295,82139889,2016-10-06T08:32:45Z,tools/run_tests/filter_pull_request_tests.py,"@@ -0,0 +1,95 @@+#!/usr/bin/env python2.7+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Filter out tests based on file differences compared to grpc:master""""""++from subprocess import call, check_output++# triggers to skip c++ tests+run_cpp_starts_with_triggers = ('src/core',+			        'src/cpp',+			        'test/core',+			        'test/cpp')+++def _get_changed_files():+  """"""+  Get list of changed files between current branch and gRPC master branch+  """"""+  # git fetch might need to be called on Jenkins slave+  # todo(mattkwong): remove or uncomment below after seeing if Jenkins needs this+  # call(['git', 'fetch'])+  # this also collects files that are changed in the repo but not updated in the branch+  return check_output([""git"", ""diff"", ""--name-only"", ""..origin/master""]).split()","dangerous to hardcode origin/master (people might as well merge into v1.0.x or any other branch in which case this gives them wrong results).Quoting @nicolasnoble  from an e-mail thread_So after digging a bit, the proper way to do the check is using the command git merge-base. That's what github uses to find the common root between a pull request's branch and its target branch.Something along these lines basically:git diff `git merge-base $ghprbTargetBranch HEAD` HEAD --summaryFrom here we should be able to figure out properly the same list of changes github displays on a pull request._",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8295,82147110,2016-10-06T09:15:31Z,tools/run_tests/filter_pull_request_tests.py,"@@ -0,0 +1,95 @@+#!/usr/bin/env python2.7+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Filter out tests based on file differences compared to grpc:master""""""++from subprocess import call, check_output++# triggers to skip c++ tests+run_cpp_starts_with_triggers = ('src/core',","Brainstorming:perhaps we could divide up the repo logically into several ""components"". Be default, all files are in the default ""affects everything"" component (test scripts and src/core definitely need to be in the default component).Then you could specify that src/cpp only triggers c++ tests (not core)src/csharp only triggers C#src/python only triggers  pythonso we could start with ""components"" named after languages ""c++"", ""csharp"", ""python""...  and mark the targets in run_tests_matrix.py accordingly. From the diff, you compute a list of affected components and that gives you what to run (and of course run everything if you've touched in the default component)I think this is in agreement with that @ctiller  has suggested in an e-mail thread.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8313,82298984,2016-10-06T22:28:23Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,103 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_bool(","Let's go ahead and make this a string right away - defaulting to empty, and able to be set to ""offered_load"".In the future I can envisage wanting to alter different values to find the load we want: number of channels, outstanding requests per channel, etc...We don't have to implement multiple things yet, but since this parameter will start showing up in shell scripts, I'd like to be a little forward thinking with how we define it.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8313,82299320,2016-10-06T22:30:28Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,103 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_bool(+    search, false,+    ""Search for the offered_load value that achieves targeted cpu load"");+DEFINE_double(initial_offered_load, 1000.0,+              ""Set up for intial offered load to start the search"");+DEFINE_double(targeted_cpu_load, 99.0, ""Targeted cpu load"");+DEFINE_double(precision, 500, ""Final search result precision"");",What units is this parameter?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8313,82299372,2016-10-06T22:30:42Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,103 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_bool(+    search, false,+    ""Search for the offered_load value that achieves targeted cpu load"");+DEFINE_double(initial_offered_load, 1000.0,+              ""Set up for intial offered load to start the search"");+DEFINE_double(targeted_cpu_load, 99.0, ""Targeted cpu load"");",What units is this parameter,
426013,lyuxuan,https://api.github.com/repos/grpc/grpc/pulls/8313,82316575,2016-10-07T01:23:42Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,103 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_bool(+    search, false,+    ""Search for the offered_load value that achieves targeted cpu load"");+DEFINE_double(initial_offered_load, 1000.0,+              ""Set up for intial offered load to start the search"");+DEFINE_double(targeted_cpu_load, 99.0, ""Targeted cpu load"");+DEFINE_double(precision, 500, ""Final search result precision"");  namespace grpc { namespace testing { +static std::unique_ptr<ScenarioResult> RunAndReport(const Scenario& scenario,+                                                    bool* success) {+  std::cerr << ""RUNNING SCENARIO: "" << scenario.name() << ""\n"";+  auto result =+      RunScenario(scenario.client_config(), scenario.num_clients(),+                  scenario.server_config(), scenario.num_servers(),+                  scenario.warmup_seconds(), scenario.benchmark_seconds(),+                  scenario.spawn_local_worker_count());++  // Amend the result with scenario config. Eventually we should adjust+  // RunScenario contract so we don't need to touch the result here.+  result->mutable_scenario()->CopyFrom(scenario);++  GetReporter()->ReportQPS(*result);+  GetReporter()->ReportQPSPerCore(*result);+  GetReporter()->ReportLatency(*result);+  GetReporter()->ReportTimes(*result);+  GetReporter()->ReportCpuUsage(*result);++  for (int i = 0; *success && i < result->client_success_size(); i++) {+    *success = result->client_success(i);+  }+  for (int i = 0; *success && i < result->server_success_size(); i++) {+    *success = result->server_success(i);+  }++  return result;+}++static double GetCpuLoad(Scenario* scenario, double offered_load,+                         bool* success) {+  scenario->mutable_client_config()+      ->mutable_load_params()+      ->mutable_poisson()+      ->set_offered_load(offered_load);+  auto result = RunAndReport(*scenario, success);+  return result->summary().server_cpu_usage();+}++static double BinarySearch(Scenario* scenario, double targeted_cpu_load,+                           double low, double high, bool* success) {+  while (low <= high - FLAGS_precision) {+    double mid = low + (high - low) / 2;+    double current_cpu_load = GetCpuLoad(scenario, mid, success);+    gpr_log(GPR_DEBUG, ""Binary Search: current_offered_load %.0f"", mid);+    if (!*success) {+      gpr_log(GPR_ERROR, ""Client/Server Failure"");+      break;+    }+    if (targeted_cpu_load < current_cpu_load) {+      high = mid - 1;",+1/-1 is really for integer parameter type. I figured that using FLAGS_precision instead may be better.,
21180148,soltanmm-google,https://api.github.com/repos/grpc/grpc/pulls/8246,82692501,2016-10-10T22:10:03Z,src/compiler/python_generator.cc,"@@ -173,11 +116,62 @@ grpc::string ModuleAlias(const grpc::string& filename) {   return module_name; } -bool GetModuleAndMessagePath(const Descriptor* type,-                             const ServiceDescriptor* service,-                             grpc::string* out) {+// Tucks all generator state in an anonymous namespace away from+// PythonGrpcGenerator and the header file, mostly to encourage future changes+// to not require updates to the grpcio-tools C++ code part. Assumes that it is+// only ever used from a single thread.+struct PrivateGenerator {","It is encouraged (at least internally) for wannabe-'module'-private function decldefs, and not explicitly banned for data decldefs. Since I interpret style guides as black-lists rather than white-lists by default, I take that as it being okay.",
21225679,gcasto,https://api.github.com/repos/grpc/grpc/pulls/8281,82700402,2016-10-10T23:17:32Z,src/cpp/client/cronet_credentials.cc,"@@ -0,0 +1,39 @@+#include <grpc++/security/credentials.h>++#include <grpc/grpc_cronet.h>+#include <grpc++/channel.h>+#include <grpc++/support/channel_arguments.h>+#include ""src/cpp/client/create_channel_internal.h""++namespace grpc {++class CronetChannelCredentialsImpl GRPC_FINAL : public ChannelCredentials {+ public:+  CronetChannelCredentialsImpl(void* engine)+      : engine_(engine) {}++  std::shared_ptr<grpc::Channel> CreateChannel(+      const string& target, const grpc::ChannelArguments& args) GRPC_OVERRIDE {+    grpc_channel_args channel_args;+    args.SetChannelArgs(&channel_args);+    return CreateChannelInternal(+        """",+        grpc_cronet_secure_channel_create(+            engine_, target.c_str(), &channel_args, nullptr));+  }++  // TODO(gcasto): Should this derive from SecureChannelCredentials?","To clarify, I assume that you mean that the it's similar to Unsecure in that it shouldn't actually derive from SecureChannelCredentials, not that it's actually insecure (e.g. doesn't use HTTPS)?I'll remove the comment.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,82726546,2016-10-11T05:30:09Z,src/core/ext/client_config/client_channel.c,"@@ -624,18 +658,29 @@ static bool pick_subchannel(grpc_exec_ctx *exec_ctx, grpc_call_element *elem,   GPR_ASSERT(error == GRPC_ERROR_NONE);   if (chand->lb_policy != NULL) {     grpc_lb_policy *lb_policy = chand->lb_policy;-    int r;     GRPC_LB_POLICY_REF(lb_policy, ""pick_subchannel"");     gpr_mu_unlock(&chand->mu);+    // If the application explicitly set wait_for_ready, use that.+    // Otherwise, if the service config specified a value for this+    // method, use that.+    if ((initial_metadata_flags &","I find the body of the `if` difficult to parse. The comment above helps, but I suggest extracting the components of the `if` into separate boolean variables. E.g.```const bool wait_for_ready_explicitly_set = initial_metadata_flags & GRPC_INITIAL_METADATA_WAIT_FOR_READY_EXPLICITLY_SET;const bool call_wait_for_ready_set  = calld->wait_for_ready_from_service_config != WAIT_FOR_READY_UNSET;if (wait_for_ready_explicitly_set && call_wait_for_ready_set) { ... }```... with hopefully better bool variable names :)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7771,82856121,2016-10-11T18:18:26Z,src/core/ext/resolver/dns/c_ares/dns_resolver_ares.c,"@@ -0,0 +1,351 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/http_connect_handshaker.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/resolver_registry.h""+#include ""src/core/ext/resolver/dns/c_ares/grpc_ares_wrapper.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/iomgr/timer.h""+#include ""src/core/lib/support/backoff.h""+#include ""src/core/lib/support/string.h""++#define BACKOFF_MULTIPLIER 1.6+#define BACKOFF_JITTER 0.2+#define BACKOFF_MIN_SECONDS 1+#define BACKOFF_MAX_SECONDS 120++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;",I think this isn't necessary.  The grpc_resolver base class takes care of refcounting.  (I removed this from all other resolvers in #8267.),
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7771,82859939,2016-10-11T18:36:55Z,src/core/ext/resolver/dns/c_ares/dns_resolver_ares.c,"@@ -0,0 +1,351 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/http_connect_handshaker.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/resolver_registry.h""+#include ""src/core/ext/resolver/dns/c_ares/grpc_ares_wrapper.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/iomgr/timer.h""+#include ""src/core/lib/support/backoff.h""+#include ""src/core/lib/support/string.h""++#define BACKOFF_MULTIPLIER 1.6+#define BACKOFF_JITTER 0.2+#define BACKOFF_MIN_SECONDS 1+#define BACKOFF_MAX_SECONDS 120++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;+  /** target name */+  char *target_name;+  /** name to resolve (usually the same as target_name) */+  char *name_to_resolve;+  /** default port to use */+  char *default_port;+  /** load balancing policy name */+  char *lb_policy_name;++  /** mutex guarding the rest of the state */+  gpr_mu mu;+  /** are we currently resolving? */+  bool resolving;+  /** which version of the result have we published? */+  int published_version;+  /** which version of the result is current? */+  int resolved_version;+  /** pending next completion, or NULL */+  grpc_closure *next_completion;+  /** target result address for next completion */+  grpc_resolver_result **target_result;+  /** current (fully resolved) result */+  grpc_resolver_result *resolved_result;+  /** retry timer */+  bool have_retry_timer;+  grpc_timer retry_timer;+  /** retry backoff state */+  gpr_backoff backoff_state;++  /** currently resolving addresses */+  grpc_resolved_addresses *addresses;++  grpc_polling_entity *pollent;+} dns_resolver;++static void dns_destroy(grpc_exec_ctx *exec_ctx, grpc_resolver *r);","It seems unwise to use the same function names here as in the existing DNS resolver implementation.  I realize that these are static functions, so there will be no linker conflict, but it might cause human confusion when debugging.  How about renaming them (e.g., change ""dns"" to ""ares"")?",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/7664,82880392,2016-10-11T20:22:31Z,src/core/lib/iomgr/ev_poll_cv_posix.c,"@@ -0,0 +1,297 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>++#ifdef GPR_POSIX_SOCKET++#include ""src/core/lib/iomgr/ev_poll_cv_posix.h""++#include <errno.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/sync.h>+#include <grpc/support/thd.h>+#include <grpc/support/time.h>+#include <grpc/support/useful.h>++#include ""src/core/lib/iomgr/ev_poll_posix.h""+#include ""src/core/lib/iomgr/wakeup_fd_posix.h""++#define POLL_PERIOD_MS 1000+#define DEFAULT_TABLE_SIZE 16++typedef enum status_t { INPROGRESS, COMPLETED, CANCELLED } status_t;++typedef struct poll_args {+  gpr_refcount refcount;+  gpr_cv* cv;+  struct pollfd* fds;+  nfds_t nfds;+  int timeout;+  int retval;+  int err;+  status_t status;+} poll_args;++cv_fd_table g_cvfds;++static void decref_poll_args(poll_args* args) {+  if (gpr_unref(&args->refcount)) {+    gpr_free(args->fds);+    gpr_cv_destroy(args->cv);+    gpr_free(args->cv);+    gpr_free(args);+  }+}++// Poll in a background thread+static void run_poll(void* arg) {+  int timeout, retval;+  poll_args* pargs = (poll_args*)arg;+  while (pargs->status == INPROGRESS) {+    if (pargs->timeout < 0) {+      timeout = POLL_PERIOD_MS;+    } else {+      timeout = GPR_MIN(POLL_PERIOD_MS, pargs->timeout);+      pargs->timeout -= timeout;+    }+    retval = g_cvfds.poll(pargs->fds, pargs->nfds, timeout);+    if (retval != 0 || pargs->timeout == 0) {+      pargs->retval = retval;+      pargs->err = errno;+      break;+    }+  }+  gpr_mu_lock(&g_cvfds.mu);+  if (pargs->status == INPROGRESS) {+    // Signal main thread that the poll completed+    pargs->status = COMPLETED;+    gpr_cv_signal(pargs->cv);+  }+  decref_poll_args(pargs);+  g_cvfds.pollcount--;+  if (g_cvfds.shutdown && g_cvfds.pollcount == 0) {+    gpr_cv_signal(&g_cvfds.shutdown_complete);+  }+  gpr_mu_unlock(&g_cvfds.mu);+}++// This function overrides poll() to handle condition variable wakeup fds+static int cvfd_poll(struct pollfd* fds, nfds_t nfds, int timeout) {+  unsigned int i;+  int res, idx;+  gpr_cv* pollcv;+  cv_node *cvn, *prev;+  nfds_t nsockfds = 0;+  gpr_thd_id t_id;+  gpr_thd_options opt;+  poll_args* pargs = NULL;+  gpr_mu_lock(&g_cvfds.mu);+  pollcv = gpr_malloc(sizeof(gpr_cv));+  gpr_cv_init(pollcv);+  for (i = 0; i < nfds; i++) {+    fds[i].revents = 0;+    if (fds[i].fd < 0 && (fds[i].events & POLLIN)) {+      idx = FD_TO_IDX(fds[i].fd);+      cvn = gpr_malloc(sizeof(cv_node));+      cvn->cv = pollcv;+      cvn->next = g_cvfds.cvfds[idx].cvs;+      g_cvfds.cvfds[idx].cvs = cvn;+      // We should return immediately if there are pending events,+      // but we still need to call poll() to check for socket events+      if (g_cvfds.cvfds[idx].is_set) {+        timeout = 0;+      }+    } else if (fds[i].fd >= 0) {+      nsockfds++;+    }+  }++  if (nsockfds > 0) {+    pargs = gpr_malloc(sizeof(struct poll_args));+    // Both the main thread and calling thread get a reference+    gpr_ref_init(&pargs->refcount, 2);+    pargs->cv = pollcv;+    pargs->fds = gpr_malloc(sizeof(struct pollfd) * nsockfds);+    pargs->nfds = nsockfds;+    pargs->timeout = timeout;+    pargs->retval = 0;+    pargs->err = 0;+    pargs->status = INPROGRESS;+    idx = 0;+    for (i = 0; i < nfds; i++) {+      if (fds[i].fd >= 0) {+        pargs->fds[idx].fd = fds[i].fd;+        pargs->fds[idx].events = fds[i].events;+        pargs->fds[idx].revents = 0;+        idx++;+      }+    }+    g_cvfds.pollcount++;+    opt = gpr_thd_options_default();+    gpr_thd_options_set_detached(&opt);+    gpr_thd_new(&t_id, &run_poll, pargs, &opt);+    // We want the poll() thread to trigger the deadline, so wait forever here+    gpr_cv_wait(pollcv, &g_cvfds.mu, gpr_inf_future(GPR_CLOCK_MONOTONIC));+    if (pargs->status == COMPLETED) {+      res = pargs->retval;+      errno = pargs->err;+    } else {+      res = 0;+      errno = 0;+      pargs->status = CANCELLED;+    }+  } else {+    gpr_timespec deadline = gpr_now(GPR_CLOCK_REALTIME);+    deadline =+        gpr_time_add(deadline, gpr_time_from_millis(timeout, GPR_TIMESPAN));+    gpr_cv_wait(pollcv, &g_cvfds.mu, deadline);+    res = 0;+  }++  idx = 0;+  for (i = 0; i < nfds; i++) {+    if (fds[i].fd < 0 && (fds[i].events & POLLIN)) {+      cvn = g_cvfds.cvfds[FD_TO_IDX(fds[i].fd)].cvs;+      prev = NULL;+      while (cvn->cv != pollcv) {+        prev = cvn;+        cvn = cvn->next;+        GPR_ASSERT(cvn);+      }+      if (!prev) {+        g_cvfds.cvfds[FD_TO_IDX(fds[i].fd)].cvs = cvn->next;+      } else {+        prev->next = cvn->next;+      }+      gpr_free(cvn);++      if (g_cvfds.cvfds[FD_TO_IDX(fds[i].fd)].is_set) {+        fds[i].revents = POLLIN;+        if (res >= 0) res++;+      }+    } else if (fds[i].fd >= 0 && pargs->status == COMPLETED) {+      fds[i].revents = pargs->fds[idx].revents;+      idx++;+    }+  }++  if (pargs) {+    decref_poll_args(pargs);+  } else {+    gpr_cv_destroy(pollcv);+    gpr_free(pollcv);+  }+  gpr_mu_unlock(&g_cvfds.mu);++  return res;+}++static void grpc_global_cv_fd_table_init() {+  gpr_mu_init(&g_cvfds.mu);+  gpr_mu_lock(&g_cvfds.mu);+  gpr_cv_init(&g_cvfds.shutdown_complete);+  g_cvfds.shutdown = 0;+  g_cvfds.pollcount = 0;+  g_cvfds.size = DEFAULT_TABLE_SIZE;+  g_cvfds.cvfds = gpr_malloc(sizeof(fd_node) * DEFAULT_TABLE_SIZE);+  g_cvfds.free_fds = NULL;+  for (int i = 0; i < DEFAULT_TABLE_SIZE; i++) {+    g_cvfds.cvfds[i].is_set = 0;+    g_cvfds.cvfds[i].cvs = NULL;+    g_cvfds.cvfds[i].next_free = g_cvfds.free_fds;+    g_cvfds.free_fds = &g_cvfds.cvfds[i];+  }+  // Override the poll function with one that supports cvfds+  g_cvfds.poll = grpc_poll_function;+  grpc_poll_function = &cvfd_poll;+  gpr_mu_unlock(&g_cvfds.mu);+}++static void grpc_global_cv_fd_table_shutdown() {+  gpr_mu_lock(&g_cvfds.mu);+  g_cvfds.shutdown = 1;+  // Attempt to wait for all abandoned poll() threads to terminate+  // Not doing so will result in reported memory leaks+  if (g_cvfds.pollcount > 0) {+    int res = gpr_cv_wait(&g_cvfds.shutdown_complete, &g_cvfds.mu,+                          gpr_time_add(gpr_now(GPR_CLOCK_REALTIME),+                                       gpr_time_from_seconds(3, GPR_TIMESPAN)));+    GPR_ASSERT(res == 0);+  }+  gpr_cv_destroy(&g_cvfds.shutdown_complete);+  grpc_poll_function = g_cvfds.poll;+  gpr_free(g_cvfds.cvfds);+  gpr_mu_unlock(&g_cvfds.mu);+  gpr_mu_destroy(&g_cvfds.mu);+}++/*******************************************************************************+ * event engine binding+ */++static const grpc_event_engine_vtable* ev_poll_vtable;+static grpc_event_engine_vtable vtable;++static void shutdown_engine(void) {+  ev_poll_vtable->shutdown_engine();+  grpc_global_cv_fd_table_shutdown();+}++const grpc_event_engine_vtable* grpc_init_poll_cv_posix(void) {+  int has_wakeup_fd = grpc_has_wakeup_fd;+  int allow_specialized_wakeup_fd = grpc_allow_specialized_wakeup_fd;+  int allow_pipe_wakeup_fd = grpc_allow_pipe_wakeup_fd;+  grpc_global_cv_fd_table_init();+  grpc_allow_specialized_wakeup_fd = 0;+  grpc_allow_pipe_wakeup_fd = 0;+  grpc_wakeup_fd_global_init();+  grpc_has_wakeup_fd = 1;","I agree that this needs some cleanup.  If I understand your suggestion correctly, we won't be able to select ""poll-cv"" as our polling engine, which will make running exhaustive tests more difficult.I've attempted to clean up this setup while leaving poll-cv as an independent poller. ",
21180148,soltanmm-google,https://api.github.com/repos/grpc/grpc/pulls/8347,82904908,2016-10-11T22:43:06Z,src/python/grpcio/support.py,"@@ -44,8 +44,10 @@ int main(int argc, char **argv) { return 0; } """""" C_PYTHON_DEV_ERROR_MESSAGE = """"""-Could not find <Python.h>. This could mean the following:-  * You're on Ubuntu and haven't `apt-get install`ed `python-dev`.+Could not find <python.h>. This could mean the following:+  * You're on Ubuntu and haven't `apt-get install python-dev`.","Given that you're changing the part-of-speech of the command, mind fixing the `haven't` to `haven't run`?~~<sup>EDIT: I'm bad at verb conjugation.</sup>~~<sup>EDIT EDIT: I'm really bad at verb conjugation.</sup>",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/7771,82910422,2016-10-11T23:27:52Z,src/core/ext/resolver/dns/c_ares/dns_resolver_ares.c,"@@ -0,0 +1,351 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc/support/port_platform.h>+#include <string.h>++#include <grpc/support/alloc.h>+#include <grpc/support/host_port.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_config/http_connect_handshaker.h""+#include ""src/core/ext/client_config/lb_policy_registry.h""+#include ""src/core/ext/client_config/resolver_registry.h""+#include ""src/core/ext/resolver/dns/c_ares/grpc_ares_wrapper.h""+#include ""src/core/lib/iomgr/resolve_address.h""+#include ""src/core/lib/iomgr/timer.h""+#include ""src/core/lib/support/backoff.h""+#include ""src/core/lib/support/string.h""++#define BACKOFF_MULTIPLIER 1.6+#define BACKOFF_JITTER 0.2+#define BACKOFF_MIN_SECONDS 1+#define BACKOFF_MAX_SECONDS 120++typedef struct {+  /** base class: must be first */+  grpc_resolver base;+  /** refcount */+  gpr_refcount refs;+  /** target name */+  char *target_name;+  /** name to resolve (usually the same as target_name) */+  char *name_to_resolve;+  /** default port to use */+  char *default_port;+  /** load balancing policy name */+  char *lb_policy_name;++  /** mutex guarding the rest of the state */+  gpr_mu mu;+  /** are we currently resolving? */+  bool resolving;+  /** which version of the result have we published? */+  int published_version;+  /** which version of the result is current? */+  int resolved_version;+  /** pending next completion, or NULL */+  grpc_closure *next_completion;+  /** target result address for next completion */+  grpc_resolver_result **target_result;+  /** current (fully resolved) result */+  grpc_resolver_result *resolved_result;+  /** retry timer */+  bool have_retry_timer;+  grpc_timer retry_timer;+  /** retry backoff state */+  gpr_backoff backoff_state;++  /** currently resolving addresses */+  grpc_resolved_addresses *addresses;++  grpc_polling_entity *pollent;+} dns_resolver;++static void dns_destroy(grpc_exec_ctx *exec_ctx, grpc_resolver *r);","Renamed as ""dns_ares_"" (as ""ares_"" prefix is used by the c-ares library)",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,82920250,2016-10-12T01:05:04Z,src/core/ext/client_config/method_config.h,"@@ -0,0 +1,99 @@+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#ifndef GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H+#define GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H++#include <stdbool.h>++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/transport/hashtable.h""+#include ""src/core/lib/transport/metadata.h""++/// Per-method configuration.+typedef struct grpc_method_config grpc_method_config;++/// Any parameter may be NULL to indicate that the value is unset.","while the semantics of most arguments are clear, could you expand the docstring for `wait_for_ready`? While described somewhere else, I think it'd be good to reiterate here what it means.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,82920517,2016-10-12T01:06:56Z,src/core/ext/client_config/method_config.h,"@@ -0,0 +1,99 @@+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#ifndef GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H+#define GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H++#include <stdbool.h>++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/transport/hashtable.h""+#include ""src/core/lib/transport/metadata.h""++/// Per-method configuration.+typedef struct grpc_method_config grpc_method_config;++/// Any parameter may be NULL to indicate that the value is unset.+grpc_method_config* grpc_method_config_create(+    bool* wait_for_ready, gpr_timespec* timeout,+    int32_t* max_request_message_bytes, int32_t* max_response_message_bytes);++grpc_method_config* grpc_method_config_ref(grpc_method_config* method_config);+void grpc_method_config_unref(grpc_method_config* method_config);++int grpc_method_config_cmp(const grpc_method_config* method_config1,+                           const grpc_method_config* method_config2);++/// These methods return NULL if the requested field is unset.+/// The caller does NOT take ownership of the result.+const bool* grpc_method_config_get_wait_for_ready(+    const grpc_method_config* method_config);+const gpr_timespec* grpc_method_config_get_timeout(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_request_message_bytes(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_response_message_bytes(+    const grpc_method_config* method_config);++/// A table of method configs.+typedef grpc_hash_table grpc_method_config_table;++typedef struct grpc_method_config_table_entry {+  /// The name is of one of the following forms:+  ///   service/method -- specifies exact service and method name+  ///   service/*      -- matches all methods for the specified service",out of curiosity: do we want to support any more complex globbing or (gasp) regular expressions for this syntax?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,82920586,2016-10-12T01:07:46Z,src/core/ext/client_config/method_config.h,"@@ -0,0 +1,99 @@+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#ifndef GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H+#define GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H++#include <stdbool.h>++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/transport/hashtable.h""+#include ""src/core/lib/transport/metadata.h""++/// Per-method configuration.+typedef struct grpc_method_config grpc_method_config;++/// Any parameter may be NULL to indicate that the value is unset.+grpc_method_config* grpc_method_config_create(+    bool* wait_for_ready, gpr_timespec* timeout,+    int32_t* max_request_message_bytes, int32_t* max_response_message_bytes);++grpc_method_config* grpc_method_config_ref(grpc_method_config* method_config);+void grpc_method_config_unref(grpc_method_config* method_config);++int grpc_method_config_cmp(const grpc_method_config* method_config1,+                           const grpc_method_config* method_config2);++/// These methods return NULL if the requested field is unset.+/// The caller does NOT take ownership of the result.+const bool* grpc_method_config_get_wait_for_ready(+    const grpc_method_config* method_config);+const gpr_timespec* grpc_method_config_get_timeout(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_request_message_bytes(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_response_message_bytes(+    const grpc_method_config* method_config);++/// A table of method configs.+typedef grpc_hash_table grpc_method_config_table;++typedef struct grpc_method_config_table_entry {+  /// The name is of one of the following forms:+  ///   service/method -- specifies exact service and method name+  ///   service/*      -- matches all methods for the specified service+  grpc_mdstr* method_name;+  grpc_method_config* method_config;+} grpc_method_config_table_entry;++/// Takes new references to all keys and values in \a entries.+grpc_method_config_table* grpc_method_config_table_create(+    size_t num_entries, grpc_method_config_table_entry* entries);++grpc_method_config_table* grpc_method_config_table_ref(+    grpc_method_config_table* table);+void grpc_method_config_table_unref(grpc_method_config_table* table);++int grpc_method_config_table_cmp(const grpc_method_config_table* table1,",comparison semantics?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,82920695,2016-10-12T01:09:03Z,src/core/ext/client_config/method_config.h,"@@ -0,0 +1,99 @@+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#ifndef GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H+#define GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H++#include <stdbool.h>++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/transport/hashtable.h""+#include ""src/core/lib/transport/metadata.h""++/// Per-method configuration.+typedef struct grpc_method_config grpc_method_config;++/// Any parameter may be NULL to indicate that the value is unset.+grpc_method_config* grpc_method_config_create(+    bool* wait_for_ready, gpr_timespec* timeout,+    int32_t* max_request_message_bytes, int32_t* max_response_message_bytes);++grpc_method_config* grpc_method_config_ref(grpc_method_config* method_config);+void grpc_method_config_unref(grpc_method_config* method_config);++int grpc_method_config_cmp(const grpc_method_config* method_config1,+                           const grpc_method_config* method_config2);++/// These methods return NULL if the requested field is unset.+/// The caller does NOT take ownership of the result.+const bool* grpc_method_config_get_wait_for_ready(+    const grpc_method_config* method_config);+const gpr_timespec* grpc_method_config_get_timeout(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_request_message_bytes(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_response_message_bytes(+    const grpc_method_config* method_config);++/// A table of method configs.+typedef grpc_hash_table grpc_method_config_table;++typedef struct grpc_method_config_table_entry {+  /// The name is of one of the following forms:+  ///   service/method -- specifies exact service and method name+  ///   service/*      -- matches all methods for the specified service+  grpc_mdstr* method_name;+  grpc_method_config* method_config;+} grpc_method_config_table_entry;++/// Takes new references to all keys and values in \a entries.+grpc_method_config_table* grpc_method_config_table_create(+    size_t num_entries, grpc_method_config_table_entry* entries);++grpc_method_config_table* grpc_method_config_table_ref(+    grpc_method_config_table* table);+void grpc_method_config_table_unref(grpc_method_config_table* table);++int grpc_method_config_table_cmp(const grpc_method_config_table* table1,+                                 const grpc_method_config_table* table2);++/// Returns NULL if the method has no config.+/// Caller does NOT own a reference to the result.","you talk of ""method"" in the docstring but the argument is named ""path"". We may want to either expand on the docstring (also adding an example of how a method/path looks like) or make the naming consistent.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8295,83011086,2016-10-12T14:01:27Z,tools/run_tests/filter_pull_request_tests.py,"@@ -0,0 +1,253 @@+#!/usr/bin/env python2.7+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Filter out tests based on file differences compared to merge target branch""""""++from subprocess import call, check_output++# Whitelist for all tests+# If whitelist item should only trigger some tests, the item should be+# added to this list and the trigger list of tests that should be run","I don't like the fact that if you add something to the list here, the tests won't run unless you add it to a list in a different place.perhaps ```{     'test/core': [ CORE_TESTS, ...],    'src/cpp': [ CPP_TESTS, .... ],    'summerofcode': [ ],    'doc': [],}```is more comprehensible and it is obvious which items don't trigger any tests and which ones do.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/7771,83014609,2016-10-12T14:17:03Z,src/core/ext/resolver/dns/c_ares/dns_resolver_ares.c,"@@ -92,24 +88,27 @@ typedef struct {   grpc_polling_entity *pollent; } dns_resolver; -static void dns_destroy(grpc_exec_ctx *exec_ctx, grpc_resolver *r);+static void dns_ares_destroy(grpc_exec_ctx *exec_ctx, grpc_resolver *r); -static void dns_start_resolving_locked(grpc_exec_ctx *exec_ctx,-                                       dns_resolver *r);-static void dns_maybe_finish_next_locked(grpc_exec_ctx *exec_ctx,-                                         dns_resolver *r);+static void dns_ares_start_resolving_locked(grpc_exec_ctx *exec_ctx,+                                            dns_resolver *r);+static void dns_ares_maybe_finish_next_locked(grpc_exec_ctx *exec_ctx,+                                              dns_resolver *r); -static void dns_shutdown(grpc_exec_ctx *exec_ctx, grpc_resolver *r);-static void dns_channel_saw_error(grpc_exec_ctx *exec_ctx, grpc_resolver *r);-static void dns_next(grpc_exec_ctx *exec_ctx, grpc_resolver *r,-                     grpc_polling_entity *pollent,-                     grpc_resolver_result **target_result,-                     grpc_closure *on_complete);+static void dns_ares_shutdown(grpc_exec_ctx *exec_ctx, grpc_resolver *r);+static void dns_ares_channel_saw_error(grpc_exec_ctx *exec_ctx,+                                       grpc_resolver *r);+static void dns_ares_next(grpc_exec_ctx *exec_ctx, grpc_resolver *r,+                          grpc_polling_entity *pollent,+                          grpc_resolver_result **target_result,+                          grpc_closure *on_complete);  static const grpc_resolver_vtable dns_resolver_vtable = {","For consistency, I suggest renaming this to dns_ares_\* as well.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8295,83014815,2016-10-12T14:17:48Z,tools/run_tests/filter_pull_request_tests.py,"@@ -0,0 +1,253 @@+#!/usr/bin/env python2.7+# Copyright 2015, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Filter out tests based on file differences compared to merge target branch""""""++from subprocess import call, check_output++# Whitelist for all tests+# If whitelist item should only trigger some tests, the item should be+# added to this list and the trigger list of tests that should be run+starts_with_whitelist = ['templates/',+                         'doc/',+                         'examples/',+                         'summerofcode/',+                         'src/cpp',+                         'src/csharp',+                         'src/node',+                         'src/objective-c',+                         'src/php',+                         'src/python',+                         'src/ruby',+                         'test/core',+                         'test/cpp',+                         'test/distrib/cpp',+                         'test/distrib/csharp',+                         'test/distrib/node',+                         'test/distrib/php',+                         'test/distrib/python',+                         'test/distrib/ruby']+				   +ends_with_whitelist = ['README.md',+                       'LICENSE']++# Triggers for core tests+core_starts_with_triggers = ['test/core']++# Triggers for c++ tests+cpp_starts_with_triggers = ['src/cpp',+                            'test/cpp',+                            'test/distrib/cpp']++# Triggers for c# tests+csharp_starts_with_triggers = ['src/csharp',+                               'test/distrib/csharp']++# Triggers for node tests+node_starts_with_triggers = ['src/node',+                             'test/distrib/node']++# Triggers for objective-c tests+objc_starts_with_triggers = ['src/objective-c']++# Triggers for php tests+php_starts_with_triggers = ['src/php',+                            'test/distrib/php']++# Triggers for python tests+python_starts_with_triggers = ['src/python',+                               'test/distrib/python']++# Triggers for ruby tests+ruby_starts_with_triggers = ['src/ruby',+                            'test/distrib/ruby']+++def _filter_whitelist(whitelist, triggers):+  """"""+  Removes triggers from whitelist+  :param whitelist: list to remove values from+  :param triggers: list of values to remove from whitelist+  :return: filtered whitelist+  """"""+  filtered_whitelist = list(whitelist)+  for trigger in triggers:+    if trigger in filtered_whitelist:+      filtered_whitelist.remove(trigger)+    else:+      """"""+      If the trigger is not found in the whitelist, then there is likely+      a mistake in the whitelist or trigger list, which needs to be addressed+      to not wrongly skip tests+      """"""+      print(""ERROR: '%s' trigger not in whitelist. Please fix this!"" % trigger)+  return filtered_whitelist+++def _get_changed_files(base_branch):+  """"""+  Get list of changed files between current branch and base of target merge branch+  """"""+  # git fetch might need to be called on Jenkins slave+  # todo(mattkwong): remove or uncomment below after seeing if Jenkins needs this+  # call(['git', 'fetch'])++  # get file changes between branch and merge-base of specified branch+  # not combined to be Windows friendly+  base_commit = check_output([""git"", ""merge-base"", base_branch, ""HEAD""]).rstrip()+  return check_output([""git"", ""diff"", base_commit, ""--name-only""]).splitlines()+++def _can_skip_tests(file_names, starts_with_whitelist=[], ends_with_whitelist=[]):+  """"""+  Determines if tests are skippable based on if all file names do not match+  any begin or end triggers+  :param file_names: list of changed files generated by _get_changed_files()+  :param starts_with_triggers: tuple of strings to match with beginning of file names+  :param ends_with_triggers: tuple of strings to match with end of file names+  :return: safe to skip tests+  """"""+  # convert lists to tuple to pass into str.startswith() and str.endswith()+  starts_with_whitelist = tuple(starts_with_whitelist)+  ends_with_whitelist = tuple(ends_with_whitelist)+  for file_name in file_names:+    if starts_with_whitelist and not file_name.startswith(starts_with_whitelist) and \+       ends_with_whitelist and not file_name.endswith(ends_with_whitelist):+         return False+  return True+++def _remove_irrelevant_tests(tests, tag):+  """"""+  Filters out tests by config or language - will not remove sanitizer tests+  :param tests: list of all tests generated by run_tests_matrix.py+  :param tag: string representing language or config to filter - ""_(language)_"" or ""_(config)""+  :return: list of relevant tests+  """"""+  # todo(mattkwong): find a more reliable way to filter tests - don't use shortname+  return [test for test in tests if+          tag not in test.shortname or+          '_msan' in test.shortname or+          '_asan' in test.shortname or+          '_tsan' in test.shortname]+++def _remove_irrelevant_sanitizer_tests(tests, language_tag=""""):+  """"""+  Filters out sanitizer tests - can specify a language to filter - this should be c++ only+  :param tests: list of all tests generated by run_tests_matrix.py+  :param language_tag: string specifying a language from which to filter sanitizer tests - ""_(language)_""+  :return: list of relevant tests+  """"""+  if language_tag:+    return [test for test in tests if not language_tag in test.shortname and+            not '_asan' in test.shortname and+            not '_msan' in test.shortname and+            not '_tsan' in test.shortname]+  else:+    return [test for test in tests if+            '_asan' not in test.shortname and+            '_msan' not in test.shortname and+            '_tsan' not in test.shortname]++def filter_tests(tests, base_branch):+  """"""+  Filters out tests that are safe to ignore+  :param tests: list of all tests generated by run_tests_matrix.py+  :return: list of relevant tests+  """"""+  print(""Finding file differences between %s repo and current branch..."" % base_branch)+  changed_files = _get_changed_files(base_branch)+  for changed_file in changed_files:+    print(changed_file)++  # Filter core tests+  skip_core = _can_skip_tests(changed_files,+                              starts_with_whitelist=_filter_whitelist(starts_with_whitelist, core_starts_with_triggers),+                              ends_with_whitelist=ends_with_whitelist)+  if skip_core:+    tests = _remove_irrelevant_tests(tests, '_c_')++  # Filter c++ tests+  skip_cpp = _can_skip_tests(changed_files,","the skip_X part is very repetitive and at some point, wrong triggers will be used for a wrong language.```skip_cpp = _can_skip_tests(  /* one day you'll see this */ core_starts_with_triggers)```I'd suggest defining and object/class for each test category (core, cpp, ...) and  then ```for  testsuite in  [CPP_TESTS, CORE_TESTS, ....]:  can_skip = can_skip_tests( ....)  tests = remove_irrelevant_tests( )```",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8303,83019764,2016-10-12T14:39:15Z,src/core/ext/client_config/method_config.h,"@@ -0,0 +1,99 @@+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#ifndef GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H+#define GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H++#include <stdbool.h>++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/transport/hashtable.h""+#include ""src/core/lib/transport/metadata.h""++/// Per-method configuration.+typedef struct grpc_method_config grpc_method_config;++/// Any parameter may be NULL to indicate that the value is unset.",Added comments documenting all parameters.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8303,83023438,2016-10-12T14:54:06Z,src/core/ext/client_config/method_config.h,"@@ -0,0 +1,99 @@+//+// Copyright 2016, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#ifndef GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H+#define GRPC_CORE_EXT_CLIENT_CONFIG_METHOD_CONFIG_H++#include <stdbool.h>++#include <grpc/impl/codegen/gpr_types.h>+#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/transport/hashtable.h""+#include ""src/core/lib/transport/metadata.h""++/// Per-method configuration.+typedef struct grpc_method_config grpc_method_config;++/// Any parameter may be NULL to indicate that the value is unset.+grpc_method_config* grpc_method_config_create(+    bool* wait_for_ready, gpr_timespec* timeout,+    int32_t* max_request_message_bytes, int32_t* max_response_message_bytes);++grpc_method_config* grpc_method_config_ref(grpc_method_config* method_config);+void grpc_method_config_unref(grpc_method_config* method_config);++int grpc_method_config_cmp(const grpc_method_config* method_config1,+                           const grpc_method_config* method_config2);++/// These methods return NULL if the requested field is unset.+/// The caller does NOT take ownership of the result.+const bool* grpc_method_config_get_wait_for_ready(+    const grpc_method_config* method_config);+const gpr_timespec* grpc_method_config_get_timeout(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_request_message_bytes(+    const grpc_method_config* method_config);+const int32_t* grpc_method_config_get_max_response_message_bytes(+    const grpc_method_config* method_config);++/// A table of method configs.+typedef grpc_hash_table grpc_method_config_table;++typedef struct grpc_method_config_table_entry {+  /// The name is of one of the following forms:+  ///   service/method -- specifies exact service and method name+  ///   service/*      -- matches all methods for the specified service","No, for efficiency reasons, we don't want to provide more complex matching.We need to be able to look up the method config as we're executing each individual call, which means that it's on the fast path, so it needs to be very efficient.  Ideally, I would like it to be only a single hash lookup based on the request's path (which is the exact service and method name).  However, we want to provide a way for the service config to set a default for all methods for a given service, so we had to provide at least a basic wildcarding mechanism.  At worst, this makes it two hash lookups -- if the exact match fails, we replace the ""method"" part of the path with ""*"" and try again.  But a more complicated matching mechanism would require a lot more than two hash lookups, which would be a lot less efficient.Even having two hash lookups is not ideal, and there may be some cases where we can avoid it.  For example, @ctiller tells me that C++ clients pre-register the full set of method names for a given service.  We could use that list to proactively expand wildcards -- i.e., if there is an entry of the form ""/service/*"", we could automatically expand that to an entry for every individual method name, so that the initial exact-match hash lookup will always succeed, thus eliminating the need for a second lookup.  But that's an optimization that we can add later.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,83046555,2016-10-12T16:37:32Z,src/core/lib/transport/hashtable.h,"@@ -0,0 +1,83 @@+/*+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ */++#ifndef GRPC_CORE_LIB_TRANSPORT_HASHTABLE_H+#define GRPC_CORE_LIB_TRANSPORT_HASHTABLE_H++#include ""src/core/lib/transport/metadata.h""++/** Hash table implementation.+ *+ * This implementation uses open addressing+ * (https://en.wikipedia.org/wiki/Open_addressing) with quadratic+ * probing (https://en.wikipedia.org/wiki/Quadratic_probing).+ * This means that the hash table is of fixed size and cannot contain","This sentence makes it sound like the fixed size is a consequence of the addressing or the probing strategy. One can have an arbitrarily large hashtable with open addressing, provided the buckets are allowed to grow.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8303,83046965,2016-10-12T16:39:28Z,src/core/lib/transport/hashtable.h,"@@ -0,0 +1,83 @@+/*+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ */++#ifndef GRPC_CORE_LIB_TRANSPORT_HASHTABLE_H+#define GRPC_CORE_LIB_TRANSPORT_HASHTABLE_H++#include ""src/core/lib/transport/metadata.h""++/** Hash table implementation.+ *+ * This implementation uses open addressing+ * (https://en.wikipedia.org/wiki/Open_addressing) with quadratic+ * probing (https://en.wikipedia.org/wiki/Quadratic_probing).+ * This means that the hash table is of fixed size and cannot contain+ * more than that number of elements.+ *+ * The keys are grpc_mdstr objects.  The values are arbitrary pointers+ * with a common vtable.+ *+ * Hash tables are intentionally immutable, to avoid the need for locking.+ */++typedef struct grpc_hash_table grpc_hash_table;++typedef struct grpc_hash_table_vtable {+  void (*destroy_value)(void* value);+  void* (*copy_value)(void* value);+  int (*compare_value)(void* value1, void* value2);+} grpc_hash_table_vtable;++typedef struct grpc_hash_table_entry {+  grpc_mdstr* key;+  void* value; /* Must not be NULL. */+  const grpc_hash_table_vtable* vtable;+} grpc_hash_table_entry;++/** Creates a new hash table of containing \a entries, which is an array+    of length \a num_entries.+    Creates its own copy of all keys and values from \a entries. */+grpc_hash_table* grpc_hash_table_create(size_t num_entries,+                                        grpc_hash_table_entry* entries);++grpc_hash_table* grpc_hash_table_ref(grpc_hash_table* table);+/** Returns 1 when \a table is destroyed. */+int grpc_hash_table_unref(grpc_hash_table* table);++/** Returns the value from \a table associated with \a key.+    Returns NULL if \a key is not found. */+void* grpc_hash_table_get(const grpc_hash_table* table, const grpc_mdstr* key);++/** Compares two hash tables. */",mention that the semantics are undefined on purpose,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8303,83070341,2016-10-12T18:34:20Z,src/core/lib/channel/message_size_filter.c,"@@ -155,11 +186,22 @@ static void init_channel_elem(grpc_exec_ctx* exec_ctx,           grpc_channel_arg_get_integer(&args->channel_args->args[i], options);     }   }+  // Get method config table from channel args.+  const grpc_arg* channel_arg =+      grpc_channel_args_find(args->channel_args, GRPC_ARG_SERVICE_CONFIG);+  if (channel_arg != NULL) {+    GPR_ASSERT(channel_arg->type == GRPC_ARG_POINTER);+    chand->method_config_table = grpc_method_config_table_ref(+        (grpc_method_config_table*)channel_arg->value.pointer.p);","It's not used for the method config, it's used for the method config **table** -- i.e., the set of all method configs, which is essentially the full set of things in the service config.  (The only exception is the LB policy name, which we could make part of this same arg if we wanted.  In fact, we might wind up doing that as part of the work to replace grpc_resolver_result with grpc_channel_args, as per the TODO in resolver_result.h.)",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8269,83125597,2016-10-13T00:24:17Z,src/cpp/rpcmanager/grpc_rpc_manager.cc,"@@ -0,0 +1,186 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc++/impl/sync.h>+#include <grpc++/impl/thd.h>+#include <grpc/support/log.h>+#include <climits>++#include ""src/cpp/rpcmanager/grpc_rpc_manager.h""++namespace grpc {++GrpcRpcManager::GrpcRpcManagerThread::GrpcRpcManagerThread(",Let's rename this to something nicer?class PollingThreadPool?grpc::PollingThreadPool looks nicer than grpc::GrpcRpcManager (too stuttery!),
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/8269,83299170,2016-10-13T20:01:24Z,src/cpp/rpcmanager/grpc_rpc_manager.cc,"@@ -0,0 +1,186 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc++/impl/sync.h>+#include <grpc++/impl/thd.h>+#include <grpc/support/log.h>+#include <climits>++#include ""src/cpp/rpcmanager/grpc_rpc_manager.h""++namespace grpc {++GrpcRpcManager::GrpcRpcManagerThread::GrpcRpcManagerThread(","Yeah, I wasn't too comfortable with the name either - but was too lazy to change it :).Since these threads do more than just 'polling', how about I call it something like `GrpcThread{Pool, Manager}` ?",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8269,83299982,2016-10-13T20:06:03Z,src/cpp/rpcmanager/grpc_rpc_manager.cc,"@@ -0,0 +1,186 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc++/impl/sync.h>+#include <grpc++/impl/thd.h>+#include <grpc/support/log.h>+#include <climits>++#include ""src/cpp/rpcmanager/grpc_rpc_manager.h""++namespace grpc {++GrpcRpcManager::GrpcRpcManagerThread::GrpcRpcManagerThread(",I'm actually against Grpc being part of the name (grpc::GrpcXXX just leaves a bad taste for me due to the repeated information).ThreadPool doesn't capture the important distinction of this type (that it does polling). No objection ThreadManager. PollingExecutor?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8367,83334142,2016-10-13T23:29:20Z,src/python/grpcio_tests/tests/reflection/_reflection_servicer_test.py,"@@ -0,0 +1,185 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Tests of grpc.reflection.v1alpha.reflection.""""""++import unittest++import grpc+from grpc.framework.foundation import logging_pool+from grpc.reflection.v1alpha import reflection+from grpc.reflection.v1alpha import reflection_pb2++from google.protobuf import descriptor_pool+from google.protobuf import descriptor_pb2++from src.proto.grpc.testing.proto2 import empty2_extensions_pb2+from src.proto.grpc.testing import empty_pb2+from tests.unit.framework.common import test_constants++_EMPTY_PROTO_FILE_NAME = 'src/proto/grpc/testing/empty.proto'+_EMPTY_PROTO_SYMBOL_NAME = 'grpc.testing.Empty'+_SERVICE_NAMES = [","Never write a list literal where a tuple literal will do, especially for a constant. Will a tuple literal do here?(And elsewhere throughout this file?)",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8367,83358688,2016-10-14T05:09:23Z,src/python/grpcio_reflection/grpc/reflection/v1alpha/reflection.py,"@@ -0,0 +1,142 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Reference implementation for reflection in gRPC Python.""""""++import threading++import grpc+from google.protobuf import descriptor_pb2+from google.protobuf import descriptor_pool++from grpc.reflection.v1alpha import reflection_pb2++_POOL = descriptor_pool.Default()++def _not_found_error():+  return reflection_pb2.ServerReflectionResponse(+      error_response=reflection_pb2.ErrorResponse(+          error_code=grpc.StatusCode.NOT_FOUND.value[0],+          error_message=grpc.StatusCode.NOT_FOUND.value[1].encode(),+      )+  )++def _file_descriptor_response(descriptor):+  proto = descriptor_pb2.FileDescriptorProto()+  descriptor.CopyToProto(proto)+  serialized_proto = proto.SerializeToString()+  return reflection_pb2.ServerReflectionResponse(+      file_descriptor_response=reflection_pb2.FileDescriptorResponse(+        file_descriptor_proto=(serialized_proto,)+      ),+  )+++class ReflectionServicer(reflection_pb2.ServerReflectionServicer):+  """"""Servicer handling RPCs for service statuses.""""""++  def __init__(self, service_names, pool=_POOL):","`pool=None` here, and then `self._pool = _POOL if pool is None else pool` in the body. As currently drafted this is an abstraction violation because the private constant is exposed as the default value of a keyword parameter of a public behavior.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8372,83438979,2016-10-14T14:58:12Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -158,6 +158,12 @@ typedef struct wrapped_rr_closure_arg {   /* when not NULL, represents a pending_{pick,ping} node to be freed upon    * closure execution */   void *owning_pending_node; /* to be freed if not NULL */++  /* Pointer ot heap memory if the closure and its argument were allocated+   * dynamically outside of a pending pick. It'll be NULL otherwise.+   *+   * TODO(dgq): This is by no means pretty. */+  void *closure_mem_or_null;","Here's an alternative suggestion that might be cleaner: Store the closure in wrapped_rr_closure_arg.  That way, we never have to free it at all, because it will be freed when wrapped_rr_closure_arg is.  This also avoids the duplication in the existing code where we currently store a closure in each of pending_pick and pending_ping.",
21180148,soltanmm-google,https://api.github.com/repos/grpc/grpc/pulls/8367,83491059,2016-10-14T19:59:30Z,src/python/grpcio_reflection/grpc/reflection/v1alpha/reflection.py,"@@ -0,0 +1,142 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Reference implementation for reflection in gRPC Python.""""""++import threading++import grpc+from google.protobuf import descriptor_pb2+from google.protobuf import descriptor_pool++from grpc.reflection.v1alpha import reflection_pb2++_POOL = descriptor_pool.Default()++def _not_found_error():+  return reflection_pb2.ServerReflectionResponse(+      error_response=reflection_pb2.ErrorResponse(+          error_code=grpc.StatusCode.NOT_FOUND.value[0],+          error_message=grpc.StatusCode.NOT_FOUND.value[1].encode(),+      )+  )++def _file_descriptor_response(descriptor):+  proto = descriptor_pb2.FileDescriptorProto()+  descriptor.CopyToProto(proto)+  serialized_proto = proto.SerializeToString()+  return reflection_pb2.ServerReflectionResponse(+      file_descriptor_response=reflection_pb2.FileDescriptorResponse(+        file_descriptor_proto=(serialized_proto,)+      ),+  )+++class ReflectionServicer(reflection_pb2.ServerReflectionServicer):+  """"""Servicer handling RPCs for service statuses.""""""++  def __init__(self, service_names, pool=_POOL):+    """"""Constructor.++    Args:+      service_names: Iterable of fully-qualified service names available.+    """"""+    self._service_names = list(service_names)+    self._pool = pool++  def _file_by_filename(self, filename):+    try:+      descriptor = self._pool.FindFileByName(filename)+    except KeyError:+      return _not_found_error()+    return _file_descriptor_response(descriptor)","TIL: Python has constructs that encourage the use of exceptions as a by-design branching mechanism.... And then I remember that iteration is stopped by an exception that isn't an exception. Yeah, okay, Python. You, uh... keep doing you. Yep.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8303,83491611,2016-10-14T20:03:00Z,test/core/end2end/fixtures/h2_ssl_cert.c,"@@ -154,39 +154,41 @@ SERVER_INIT(GRPC_SSL_REQUEST_AND_REQUIRE_CLIENT_CERTIFICATE_AND_VERIFY)  typedef enum { NONE, SELF_SIGNED, SIGNED, BAD_CERT_PAIR } certtype; -#define CLIENT_INIT(cert_type)                                               \-  static void CLIENT_INIT_NAME(cert_type)(grpc_end2end_test_fixture * f,     \-                                          grpc_channel_args * client_args) { \-    grpc_channel_credentials *ssl_creds = NULL;                              \-    grpc_ssl_pem_key_cert_pair self_signed_client_key_cert_pair = {          \-        test_self_signed_client_key, test_self_signed_client_cert};          \-    grpc_ssl_pem_key_cert_pair signed_client_key_cert_pair = {               \-        test_signed_client_key, test_signed_client_cert};                    \-    grpc_ssl_pem_key_cert_pair bad_client_key_cert_pair = {                  \-        test_self_signed_client_key, test_signed_client_cert};               \-    grpc_ssl_pem_key_cert_pair *key_cert_pair = NULL;                        \-    switch (cert_type) {                                                     \-      case SELF_SIGNED:                                                      \-        key_cert_pair = &self_signed_client_key_cert_pair;                   \-        break;                                                               \-      case SIGNED:                                                           \-        key_cert_pair = &signed_client_key_cert_pair;                        \-        break;                                                               \-      case BAD_CERT_PAIR:                                                    \-        key_cert_pair = &bad_client_key_cert_pair;                           \-        break;                                                               \-      default:                                                               \-        break;                                                               \-    }                                                                        \-    ssl_creds =                                                              \-        grpc_ssl_credentials_create(test_root_cert, key_cert_pair, NULL);    \-    grpc_arg ssl_name_override = {GRPC_ARG_STRING,                           \-                                  GRPC_SSL_TARGET_NAME_OVERRIDE_ARG,         \-                                  {""foo.test.google.fr""}};                   \-    grpc_channel_args *new_client_args =                                     \-        grpc_channel_args_copy_and_add(client_args, &ssl_name_override, 1);  \-    chttp2_init_client_secure_fullstack(f, new_client_args, ssl_creds);      \-    grpc_channel_args_destroy(new_client_args);                              \+#define CLIENT_INIT(cert_type)                                              \","I agree that it's ugly, but I'd rather not make this PR any bigger, so I'm going to defer this for now.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8372,83496609,2016-10-14T20:36:00Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -474,29 +460,29 @@ static void rr_handover(grpc_exec_ctx *exec_ctx, glb_lb_policy *glb_policy,     glb_policy->pending_picks = pp->next;     GRPC_LB_POLICY_REF(glb_policy->rr_policy, ""rr_handover_pending_pick"");     pp->wrapped_on_complete_arg.rr_policy = glb_policy->rr_policy;+    pp->wrapped_on_complete_arg.free_when_done = pp;","heh, I was making this change in parallel before reading your comment, same thoughts. Done.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8367,83502347,2016-10-14T21:11:58Z,src/python/grpcio_reflection/grpc/reflection/v1alpha/reflection.py,"@@ -0,0 +1,142 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Reference implementation for reflection in gRPC Python.""""""++import threading++import grpc+from google.protobuf import descriptor_pb2+from google.protobuf import descriptor_pool++from grpc.reflection.v1alpha import reflection_pb2++_POOL = descriptor_pool.Default()++def _not_found_error():+  return reflection_pb2.ServerReflectionResponse(+      error_response=reflection_pb2.ErrorResponse(+          error_code=grpc.StatusCode.NOT_FOUND.value[0],+          error_message=grpc.StatusCode.NOT_FOUND.value[1].encode(),+      )+  )++def _file_descriptor_response(descriptor):+  proto = descriptor_pb2.FileDescriptorProto()+  descriptor.CopyToProto(proto)+  serialized_proto = proto.SerializeToString()+  return reflection_pb2.ServerReflectionResponse(+      file_descriptor_response=reflection_pb2.FileDescriptorResponse(+        file_descriptor_proto=(serialized_proto,)+      ),+  )+++class ReflectionServicer(reflection_pb2.ServerReflectionServicer):+  """"""Servicer handling RPCs for service statuses.""""""++  def __init__(self, service_names, pool=_POOL):","Reasonable Pythonistas go back and forth on this but I've found the ""support the 'user passes `None` as a way of explicitly asking for whatever is the default' use case"" side more persuasive. Another way of expressing it is as a choice between ""if you don't pass this parameter, a default value of `<literal value>` will be used"" and ""if you don't pass this parameter, some default value will be used but we aren't promising what that is; if you really care about the value you must explicitly pass it"". Always favor making the minimal promise.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8371,83729846,2016-10-17T20:45:03Z,include/grpc++/test/server_context_test_spouse.h,"@@ -0,0 +1,67 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPCXX_TEST_SERVER_CONTEXT_TEST_SPOUSE_H+#define GRPCXX_TEST_SERVER_CONTEXT_TEST_SPOUSE_H++#include <map>++#include <grpc++/server_context.h>++namespace grpc {+namespace testing {++// A test-only class to access private members and methods of ServerContext.+class ServerContextTestSpouse {+ public:+  explicit ServerContextTestSpouse(ServerContext* ctx) : ctx_(ctx) {}++  // Inject fake client metadata to the ServerContext. The test spouse must be","rather than ""fake"", how about saying ""Inject client metadata for the test"" instead. The ""fake"" part made it confusing when I first read it.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,83790948,2016-10-18T06:50:22Z,include/grpc++/server.h,"@@ -105,18 +107,41 @@ class Server GRPC_FINAL : public ServerInterface, private GrpcLibraryCodegen {   class AsyncRequest;   class ShutdownRequest; +  /// SyncRequestThreadManager is an implementation of ThreadManager. This class+  /// is responsible for polling for incoming RPCs and calling the RPC handlers.+  /// This is only used in case of a Sync server (i.e a server exposing a sync+  /// interface)+  class SyncRequestThreadManager;+   class UnimplementedAsyncRequestContext;   class UnimplementedAsyncRequest;   class UnimplementedAsyncResponse;    /// Server constructors. To be used by \a ServerBuilder only.   ///-  /// \param thread_pool The threadpool instance to use for call processing.-  /// \param thread_pool_owned Does the server own the \a thread_pool instance?-  /// \param max_receive_message_size Maximum message length that the channel-  /// can receive.-  Server(ThreadPoolInterface* thread_pool, bool thread_pool_owned,-         int max_receive_message_size, ChannelArguments* args);+  /// \param sync_server_cqs The completion queues to use if the server is a+  /// synchronous server (or a hybrid server). The server polls for new RPCs on+  /// these queues+  ///+  /// \param max_message_size Maximum message length that the channel can+  /// receive.+  ///+  /// \param args The channel args+  ///+  /// \param min_pollers The minimum number of polling threads per server","Suggest a reordering of these parameters, since some are applicable to all servers and some are only applicable to sync API servers, but they are intermixed.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,83792743,2016-10-18T07:05:37Z,src/cpp/server/server_builder.cc,"@@ -178,27 +190,84 @@ std::unique_ptr<Server> ServerBuilder::BuildAndStart() {     args.SetInt(GRPC_COMPRESSION_CHANNEL_DEFAULT_ALGORITHM,                 maybe_default_compression_algorithm_.algorithm);   }-  std::unique_ptr<Server> server(new Server(thread_pool.release(), true,-                                            max_receive_message_size_, &args));++  // == Determine if the server has any syncrhonous methods ==+  bool has_sync_methods = false;+  for (auto it = services_.begin(); it != services_.end(); ++it) {+    if ((*it)->service->has_synchronous_methods()) {+      has_sync_methods = true;+      break;+    }+  }++  if (!has_sync_methods) {+    for (auto plugin = plugins_.begin(); plugin != plugins_.end(); plugin++) {+      if ((*plugin)->has_sync_methods()) {+        has_sync_methods = true;+        break;+      }+    }+  }++  // If this is a Sync server, i.e a server expositing sync API, then the server+  // needs to create some completion queues to listen for incoming requests.+  // 'sync_server_cqs' are those internal completion queues.+  //+  // This is different from the completion queues added to the server via+  // ServerBuilder's AddCompletionQueue() method (those completion queues+  // are in 'cqs_' member variable of ServerBuilder object)+  std::shared_ptr<std::vector<std::unique_ptr<ServerCompletionQueue>>>+      sync_server_cqs(+          new std::vector<std::unique_ptr<ServerCompletionQueue>>());","See above comments about `shared_ptr`, but if there is an unavoidable reason to do this, please use `std::make_shared`. It won't have a performance effect in this case, but let's get in that code hygiene habit. Suggest checking for other uses of this anti-pattern as a future PR.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,83793918,2016-10-18T07:16:41Z,src/cpp/thread_manager/thread_manager.h,"@@ -0,0 +1,158 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CPP_THREAD_MANAGER_H+#define GRPC_INTERNAL_CPP_THREAD_MANAGER_H++#include <list>+#include <memory>++#include <grpc++/impl/sync.h>+#include <grpc++/impl/thd.h>++namespace grpc {++class ThreadManager {","I question the use of inheritance as a design choice here. In the overall motif of prefer composition over inheritance, it seems like the same effects sought here could be achieved by composition instead. The `ThreadManager` itself actually has a lot of defined functions and member variables, very few virtual methods, only 1 derived class at the current time, no protected methods, and no places where the `ThreadManager` pointer is being used to refer to a derived class ; in fact, the Server explicitly points to the derived class and is only meaningful as such. If it must be kept this way, please rename to `ThreadManagerInterface` to be consistent with other uses throughout the code.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,83794446,2016-10-18T07:21:18Z,src/cpp/server/server_cc.cc,"@@ -275,33 +242,144 @@ class Server::SyncRequest GRPC_FINAL : public CompletionQueueTag {   grpc_completion_queue* cq_; }; +// Implementation of ThreadManager. Each instance of SyncRequestThreadManager+// manages a pool of threads that poll for incoming Sync RPCs and call the+// appropriate RPC handlers+class Server::SyncRequestThreadManager : public ThreadManager {","I have a more detailed comment below, but essentially I argue that this should be done via composition and not inheritance since it doesn't have the smell of inheritance at all.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,83795520,2016-10-18T07:30:11Z,build.yaml,"@@ -715,6 +715,7 @@ filegroups:   - src/cpp/common/channel_filter.h   - src/cpp/server/dynamic_thread_pool.h   - src/cpp/server/thread_pool_interface.h","Why isn't thread_pool_interface.h (and related files) being deleted in this PR and from build.yaml, if the concept is indeed being deprecated?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,83798722,2016-10-18T07:51:55Z,src/cpp/thread_manager/thread_manager.cc,"@@ -0,0 +1,185 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <grpc++/impl/sync.h>+#include <grpc++/impl/thd.h>+#include <grpc/support/log.h>+#include <climits>++#include ""src/cpp/thread_manager/thread_manager.h""++namespace grpc {++ThreadManager::WorkerThread::WorkerThread(ThreadManager* thd_mgr)+    : thd_mgr_(thd_mgr),+      thd_(new std::thread(&ThreadManager::WorkerThread::Run, this)) {}++void ThreadManager::WorkerThread::Run() {+  thd_mgr_->MainWorkLoop();+  thd_mgr_->MarkAsCompleted(this);+}++ThreadManager::WorkerThread::~WorkerThread() {+  thd_->join();+  thd_.reset();+}++ThreadManager::ThreadManager(int min_pollers, int max_pollers)+    : shutdown_(false),+      num_pollers_(0),+      min_pollers_(min_pollers),+      max_pollers_(max_pollers == -1 ? INT_MAX : max_pollers),+      num_threads_(0) {}++ThreadManager::~ThreadManager() {+  {+    std::unique_lock<grpc::mutex> lock(mu_);+    GPR_ASSERT(num_threads_ == 0);+  }++  CleanupCompletedThreads();+}++void ThreadManager::Wait() {+  std::unique_lock<grpc::mutex> lock(mu_);+  while (num_threads_ != 0) {+    shutdown_cv_.wait(lock);+  }+}++void ThreadManager::Shutdown() {+  std::unique_lock<grpc::mutex> lock(mu_);+  shutdown_ = true;+}++bool ThreadManager::IsShutdown() {+  std::unique_lock<grpc::mutex> lock(mu_);+  return shutdown_;+}++void ThreadManager::MarkAsCompleted(WorkerThread* thd) {+  {+    std::unique_lock<grpc::mutex> list_lock(list_mu_);+    completed_threads_.push_back(thd);+  }++  grpc::unique_lock<grpc::mutex> lock(mu_);+  num_threads_--;+  if (num_threads_ == 0) {+    shutdown_cv_.notify_one();+  }+}++void ThreadManager::CleanupCompletedThreads() {+  std::unique_lock<grpc::mutex> lock(list_mu_);+  for (auto thd = completed_threads_.begin(); thd != completed_threads_.end();+       thd = completed_threads_.erase(thd)) {+    delete *thd;+  }+}++void ThreadManager::Initialize() {+  for (int i = 0; i < min_pollers_; i++) {+    MaybeCreatePoller();+  }+}++// If the number of pollers (i.e threads currently blocked in PollForWork()) is+// less than max threshold (i.e max_pollers_) and the total number of threads is+// below the maximum threshold, we can let the current thread continue as poller+bool ThreadManager::MaybeContinueAsPoller() {+  std::unique_lock<grpc::mutex> lock(mu_);+  if (shutdown_ || num_pollers_ > max_pollers_) {+    return false;+  }++  num_pollers_++;+  return true;+}++// Create a new poller if the current number of pollers i.e num_pollers_ (i.e+// threads currently blocked in PollForWork()) is below the threshold (i.e+// min_pollers_) and the total number of threads is below the maximum threshold+void ThreadManager::MaybeCreatePoller() {+  grpc::unique_lock<grpc::mutex> lock(mu_);+  if (!shutdown_ && num_pollers_ < min_pollers_) {+    num_pollers_++;+    num_threads_++;++    // Create a new thread (which ends up calling the MainWorkLoop() function+    new WorkerThread(this);+  }+}++void ThreadManager::MainWorkLoop() {","Morally speaking, MainWorkLoop belongs to a WorkerThread, though the functions that it invokes (like MaybeContinueAsPoller and MaybeCreatePoller) belong to the ThreadManager. Would you consider moving this method to the WorkerThread class and then having it invoke `thd_mgr_->Maybe..` as needed?",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/8269,83961565,2016-10-18T22:10:19Z,include/grpc++/server.h,"@@ -105,18 +107,41 @@ class Server GRPC_FINAL : public ServerInterface, private GrpcLibraryCodegen {   class AsyncRequest;   class ShutdownRequest; +  /// SyncRequestThreadManager is an implementation of ThreadManager. This class+  /// is responsible for polling for incoming RPCs and calling the RPC handlers.+  /// This is only used in case of a Sync server (i.e a server exposing a sync+  /// interface)+  class SyncRequestThreadManager;+   class UnimplementedAsyncRequestContext;   class UnimplementedAsyncRequest;   class UnimplementedAsyncResponse;    /// Server constructors. To be used by \a ServerBuilder only.   ///-  /// \param thread_pool The threadpool instance to use for call processing.-  /// \param thread_pool_owned Does the server own the \a thread_pool instance?-  /// \param max_receive_message_size Maximum message length that the channel-  /// can receive.-  Server(ThreadPoolInterface* thread_pool, bool thread_pool_owned,-         int max_receive_message_size, ChannelArguments* args);+  /// \param sync_server_cqs The completion queues to use if the server is a+  /// synchronous server (or a hybrid server). The server polls for new RPCs on+  /// these queues+  ///+  /// \param max_message_size Maximum message length that the channel can+  /// receive.+  ///+  /// \param args The channel args+  ///+  /// \param min_pollers The minimum number of polling threads per server+  /// completion queue (in param sync_server_cqs) to use for listening to+  /// incoming requests (used only in case of sync server)+  ///+  /// \param max_pollers The maximum number of polling threads per server+  /// completion queue (in param sync_server_cqs) to use for listening to+  /// incoming requests (used only in case of sync server)+  ///+  /// \param sync_cq_timeout_msec The timeout to use when calling AsyncNext() on+  /// server completion queues passed via sync_server_cqs param.+  Server(std::shared_ptr<std::vector<std::unique_ptr<ServerCompletionQueue>>>+             sync_server_cqs,","Yes, it ideally should be a `unique_ptr` but I needed to to use `sync_server_cqs` after creating `Server` object in server builder (see the code below).```  // Register all the completion queues with the server. i.e  //  1. sync_server_cqs: internal completion queues created IF this is a sync  //     server  //  2. cqs_: Completion queues added via AddCompletionQueue() call  // All sync cqs (if any) are frequently polled by ThreadManager  int num_frequently_polled_cqs = sync_server_cqs->size();  for (auto it = sync_server_cqs->begin(); it != sync_server_cqs->end(); ++it) {    grpc_server_register_completion_queue(server->server_, (*it)->cq(),                                          nullptr);  }```I cannot move this code to before creating `Server` object because I need `server->server_`.I could move a few things around to make this happen (like moving the `grpc_server_register_completion_queue` calls to inside `Server` class or maybe have a member variable in `Server` class for  `sync_server_cqs_` and add an accessor)  but it just felt like making this `shared_ptr` would keep things simple. ",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8303,83961758,2016-10-18T22:11:32Z,src/core/ext/client_config/method_config.c,"@@ -0,0 +1,296 @@+//+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#include ""src/core/ext/client_config/method_config.h""++#include <string.h>++#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>+#include <grpc/support/time.h>++#include ""src/core/lib/transport/mdstr_hash_table.h""+#include ""src/core/lib/transport/metadata.h""++//+// grpc_method_config+//++// bool vtable++static void* bool_copy(void* valuep) {+  bool value = *(bool*)valuep;+  bool* new_value = gpr_malloc(sizeof(bool));+  *new_value = value;+  return new_value;+}++static int bool_cmp(void* v1, void* v2) {+  bool b1 = *(bool*)v1;+  bool b2 = *(bool*)v2;+  if (!b1 && b2) return -1;+  if (b1 && !b2) return 1;+  return 0;+}++static grpc_mdstr_hash_table_vtable bool_vtable = {gpr_free, bool_copy,+                                                   bool_cmp};++// timespec vtable++static void* timespec_copy(void* valuep) {+  gpr_timespec value = *(gpr_timespec*)valuep;+  gpr_timespec* new_value = gpr_malloc(sizeof(gpr_timespec));+  *new_value = value;+  return new_value;+}++static int timespec_cmp(void* v1, void* v2) {+  return gpr_time_cmp(*(gpr_timespec*)v1, *(gpr_timespec*)v2);+}++static grpc_mdstr_hash_table_vtable timespec_vtable = {gpr_free, timespec_copy,+                                                       timespec_cmp};++// int32 vtable++static void* int32_copy(void* valuep) {+  int32_t value = *(int32_t*)valuep;+  int32_t* new_value = gpr_malloc(sizeof(int32_t));+  *new_value = value;+  return new_value;+}++static int int32_cmp(void* v1, void* v2) {+  int32_t i1 = *(int32_t*)v1;+  int32_t i2 = *(int32_t*)v2;+  if (i1 < i2) return -1;+  if (i1 > i2) return 1;+  return 0;+}++static grpc_mdstr_hash_table_vtable int32_vtable = {gpr_free, int32_copy,+                                                    int32_cmp};++// Hash table keys.+#define GRPC_METHOD_CONFIG_WAIT_FOR_READY ""grpc.wait_for_ready""  // bool+#define GRPC_METHOD_CONFIG_TIMEOUT ""grpc.timeout""                // gpr_timespec+#define GRPC_METHOD_CONFIG_MAX_REQUEST_MESSAGE_BYTES \+  ""grpc.max_request_message_bytes""  // int32+#define GRPC_METHOD_CONFIG_MAX_RESPONSE_MESSAGE_BYTES \+  ""grpc.max_response_message_bytes""  // int32++struct grpc_method_config {+  grpc_mdstr_hash_table* table;+  grpc_mdstr* wait_for_ready_key;+  grpc_mdstr* timeout_key;+  grpc_mdstr* max_request_message_bytes_key;+  grpc_mdstr* max_response_message_bytes_key;+};++grpc_method_config* grpc_method_config_create(+    bool* wait_for_ready, gpr_timespec* timeout,+    int32_t* max_request_message_bytes, int32_t* max_response_message_bytes) {+  grpc_method_config* method_config = gpr_malloc(sizeof(grpc_method_config));+  memset(method_config, 0, sizeof(grpc_method_config));+  method_config->wait_for_ready_key =+      grpc_mdstr_from_string(GRPC_METHOD_CONFIG_WAIT_FOR_READY);+  method_config->timeout_key =+      grpc_mdstr_from_string(GRPC_METHOD_CONFIG_TIMEOUT);+  method_config->max_request_message_bytes_key =+      grpc_mdstr_from_string(GRPC_METHOD_CONFIG_MAX_REQUEST_MESSAGE_BYTES);+  method_config->max_response_message_bytes_key =+      grpc_mdstr_from_string(GRPC_METHOD_CONFIG_MAX_RESPONSE_MESSAGE_BYTES);+  grpc_mdstr_hash_table_entry entries[4];+  size_t num_entries = 0;+  if (wait_for_ready != NULL) {+    entries[num_entries].key = method_config->wait_for_ready_key;+    entries[num_entries].value = wait_for_ready;+    entries[num_entries].vtable = &bool_vtable;+    ++num_entries;+  }+  if (timeout != NULL) {+    entries[num_entries].key = method_config->timeout_key;+    entries[num_entries].value = timeout;+    entries[num_entries].vtable = &timespec_vtable;+    ++num_entries;+  }+  if (max_request_message_bytes != NULL) {+    entries[num_entries].key = method_config->max_request_message_bytes_key;+    entries[num_entries].value = max_request_message_bytes;+    entries[num_entries].vtable = &int32_vtable;+    ++num_entries;+  }+  if (max_response_message_bytes != NULL) {+    entries[num_entries].key = method_config->max_response_message_bytes_key;+    entries[num_entries].value = max_response_message_bytes;+    entries[num_entries].vtable = &int32_vtable;+    ++num_entries;+  }+  method_config->table = grpc_mdstr_hash_table_create(num_entries, entries);+  return method_config;+}++grpc_method_config* grpc_method_config_ref(grpc_method_config* method_config) {+  grpc_mdstr_hash_table_ref(method_config->table);+  return method_config;+}++void grpc_method_config_unref(grpc_method_config* method_config) {+  if (grpc_mdstr_hash_table_unref(method_config->table)) {+    GRPC_MDSTR_UNREF(method_config->wait_for_ready_key);+    GRPC_MDSTR_UNREF(method_config->timeout_key);+    GRPC_MDSTR_UNREF(method_config->max_request_message_bytes_key);+    GRPC_MDSTR_UNREF(method_config->max_response_message_bytes_key);+    gpr_free(method_config);+  }+}++int grpc_method_config_cmp(const grpc_method_config* method_config1,+                           const grpc_method_config* method_config2) {+  return grpc_mdstr_hash_table_cmp(method_config1->table,+                                   method_config2->table);+}++const bool* grpc_method_config_get_wait_for_ready(+    const grpc_method_config* method_config) {+  return grpc_mdstr_hash_table_get(method_config->table,+                                   method_config->wait_for_ready_key);+}++const gpr_timespec* grpc_method_config_get_timeout(+    const grpc_method_config* method_config) {+  return grpc_mdstr_hash_table_get(method_config->table,+                                   method_config->timeout_key);+}++const int32_t* grpc_method_config_get_max_request_message_bytes(","Missed something in the initial review.We should probably have a dual structure here: method_config for passing in parameters, and a second hash table of (method name --> (max, min request message bytes)) and store that second hash table directly on the filter to avoid this secondary hash lookup on the fast path.Happy for this to be a future change (and I might even take it on if/when the time comes), but it will need to happen eventually.",
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/8269,83962428,2016-10-18T22:15:50Z,build.yaml,"@@ -715,6 +715,7 @@ filegroups:   - src/cpp/common/channel_filter.h   - src/cpp/server/dynamic_thread_pool.h   - src/cpp/server/thread_pool_interface.h",`secure_server_credentials.h` uses threadpool interface in `AuthMetadataProcessorAsyncWrapper`. I am not sure what that code does though. Did not look at it in detail.,
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/8269,83967209,2016-10-18T22:48:06Z,src/cpp/thread_manager/thread_manager.h,"@@ -0,0 +1,158 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_INTERNAL_CPP_THREAD_MANAGER_H+#define GRPC_INTERNAL_CPP_THREAD_MANAGER_H++#include <list>+#include <memory>++#include <grpc++/impl/sync.h>+#include <grpc++/impl/thd.h>++namespace grpc {++class ThreadManager {","I expect to find more use-cases for `ThreadManager` interface like using this on the client side  (and the interface will change/evolve a little).  This is the main reason for keeping this separate from having server-specific logic baked in.With the above in mind, I reasoned about things the following way:-  `ThreadManager` is a component that manages a bunch of worker threads each doing `PollForWork()` and `DoWork()` . ""Work"" can be anything and defined/implemented by concrete sub classes.- So `SyncRequestManager` _is a_ `ThreadManager` that has specific implementation for `PollForWork()` and `DoWork()` related to polling for incoming requests and handling them.- Grpc sync server _has a_ bunch of sync request managers one for each completion queue.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8397,84005684,2016-10-19T06:46:53Z,tools/run_tests/run_performance_tests.py,"@@ -450,15 +451,21 @@ def finish_qps_workers(jobs): if not scenarios:   raise Exception('No scenarios to run') +num_failures = 0 for scenario in scenarios:   if args.dry_run:     print(scenario.name)   else:     try:       for worker in scenario.workers:         worker.start()-      jobset.run([scenario.jobspec,-                  create_quit_jobspec(scenario.workers, remote_host=args.remote_driver_host)],-                 newline_on_success=True, maxjobs=1)+      jobset_failures, _ = jobset.run([scenario.jobspec,+                                 create_quit_jobspec(scenario.workers, remote_host=args.remote_driver_host)],+                                 newline_on_success=True, maxjobs=1)+      num_failures += jobset_failures     finally:-      finish_qps_workers(scenario.workers)+      # Consider jobs that need to be killed as failures+      num_failures += finish_qps_workers(scenario.workers)++if num_failures > 0:+  raise Exception('Failures occured')",nit: you can do sys.exit here without printing a useless stack trace.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8246,84179075,2016-10-19T22:13:59Z,src/compiler/python_generator.cc,"@@ -646,42 +644,149 @@ bool PrintPreamble(const FileDescriptor* file,   out->Print(       ""from grpc.framework.interfaces.face import utilities as ""       ""face_utilities\n"");+  if (split_pb2_grpc) {+    out->Print(""\n"");+    // BEEEEEEES.+    for (int i = 0; i < file->service_count(); ++i) {+      const ServiceDescriptor *service = file->service(i);+      for (int j = 0; j < service->method_count(); ++j) {+        const MethodDescriptor *method = service->method(j);+        const Descriptor *types[2] = {method->input_type(), method->output_type()};+        for (int k = 0; k < 2; ++k) {+          const Descriptor *type = types[k];+          grpc::string type_file_name = type->file()->name();+          grpc::string module_name = ModuleName(type_file_name);+          grpc::string module_alias = ModuleAlias(type_file_name);+          out->Print(""import $ModuleName$ as $ModuleAlias$\n"", ""ModuleName"", module_name, ""ModuleAlias"", module_alias);+        }+      }+    }+  }   return true; } -}  // namespace+bool PrivateGenerator::PrintPreambledGAServices() {+  if (!PrintPreamble()) {+    return false;+  }+  grpc::string package = file->package();+  if (!package.empty()) {+    package = package.append(""."");+  }+  for (int i = 0; i < file->service_count(); ++i) {+    const ServiceDescriptor *service = file->service(i);+    grpc::string package_qualified_service_name = package + service->name();+    if (!(PrintStub(package_qualified_service_name, service) &&+          PrintServicer(service) &&+          PrintAddServicerToServer(package_qualified_service_name, service))) {+      return false;+    }+  }+  return true;+} -pair<bool, grpc::string> GetServices(const FileDescriptor* file,-                                     const GeneratorConfiguration& config) {+bool PrivateGenerator::PrintBetaServices() {+  grpc::string package = file->package();+  if (!package.empty()) {+    package = package.append(""."");+  }+  for (int i = 0; i < file->service_count(); ++i) {+    const ServiceDescriptor *service = file->service(i);+    grpc::string package_qualified_service_name = package + service->name();+    if (!(PrintBetaServicer(service) && PrintBetaStub(service) &&+          PrintBetaServerFactory(package_qualified_service_name, service) &&+          PrintBetaStubFactory(package_qualified_service_name, service))) {+      return false;+    }+  }+  return true;+}++pair<bool, grpc::string> PrivateGenerator::GetGrpcServices() {   grpc::string output;   {     // Scope the output stream so it closes and finalizes output to the string.     StringOutputStream output_stream(&output);-    Printer out(&output_stream, '$');-    if (!PrintPreamble(file, config, &out)) {-      return make_pair(false, """");-    }-    auto package = file->package();-    if (!package.empty()) {-      package = package.append(""."");-    }-    for (int i = 0; i < file->service_count(); ++i) {-      auto service = file->service(i);-      auto package_qualified_service_name = package + service->name();-      if (!(PrintStub(package_qualified_service_name, service, &out) &&-            PrintServicer(service, &out) &&-            PrintAddServicerToServer(package_qualified_service_name, service,-                                     &out) &&-            PrintBetaServicer(service, &out) && PrintBetaStub(service, &out) &&-            PrintBetaServerFactory(package_qualified_service_name, service,-                                   &out) &&-            PrintBetaStubFactory(package_qualified_service_name, service,-                                 &out))) {+    Printer out_printer(&output_stream, '$');+    out = &out_printer;++    if (split_pb2_grpc) {+      if (!PrintPreambledGAServices()) {         return make_pair(false, """");       }+    } else {+      out->Print(""try:\n"");+      {+        IndentScope raii_dict_try_indent(out);+        if (!PrintPreambledGAServices()) {+          return make_pair(false, """");+        }+        if (!PrintBetaServices()) {+          return make_pair(false, """");+        }+      }+      out->Print(""except ImportError:\n"");+      {+        IndentScope raii_dict_except_indent(out);+        out->Print(""pass"");+      }     }   }   return make_pair(true, std::move(output)); } +}  // namespace++GeneratorConfiguration::GeneratorConfiguration()+    : grpc_package_root(""grpc""), beta_package_root(""grpc.beta"") {}++PythonGrpcGenerator::PythonGrpcGenerator(const GeneratorConfiguration& config)+    : config_(config) {}++PythonGrpcGenerator::~PythonGrpcGenerator() {}++bool PythonGrpcGenerator::Generate(const FileDescriptor* file,+                                   const grpc::string& parameter,+                                   GeneratorContext* context,+                                   grpc::string* error) const {+  // Get output file name.+  grpc::string pb2_file_name;+  grpc::string grpc_file_name;+  static const int proto_suffix_length = strlen("".proto"");+  if (file->name().size() > static_cast<size_t>(proto_suffix_length) &&+      file->name().find_last_of("".proto"") == file->name().size() - 1) {+    grpc::string base = file->name().substr(+        0, file->name().size() - proto_suffix_length);+    pb2_file_name = base + ""_pb2.py"";+    grpc_file_name = base + ""_pb2_grpc.py"";+  } else {+    *error = ""Invalid proto file name. Proto file must end with .proto"";+    return false;+  }++  PrivateGenerator generator(config_, file);++  std::unique_ptr<ZeroCopyOutputStream> pb2_output(+      context->OpenForAppend(pb2_file_name));+  std::unique_ptr<ZeroCopyOutputStream> grpc_output(+      context->Open(grpc_file_name));+  CodedOutputStream pb2_coded_out(pb2_output.get());+  CodedOutputStream grpc_coded_out(grpc_output.get());+  bool success = false;+  grpc::string pb2_code;+  grpc::string grpc_code;+  generator.split_pb2_grpc = false;","So why does it need to be a member of a struct rather than a parameter passed through those layers of method calls?Oh, I think I see what's confusing me: the struct itself. If this were Python, I'd climb up on my pedestal and/or high horse and say ""the class seems to be only instantiated once, it's needlessly mutable, it looks like a lot could be stripped out of its body, and it doesn't define a type of larger interest; I'm not sure its existence is justified"". Here in C++ I feel the same classophobia, but don't feel that I have the authority to actually do anything about it. 😛  Plus the struct and everything in it are all private anyway? Well... okay. The mutation thing sticks out as a little weird -```generator(config, file);generator.generate_in_pb2_grpc = false;generator.GetGrpcServices();generator.generate_in_pb2_grpc = true;generator.GetGrpcServices();```(roughly) rather than```generator(config, file, false);generator.GetGrpcServices();generator(config, file, true);generator.GetGrpcServices();```or```generator(config, file);generator.GetGrpcServices(false);generator.GetGrpcServices(true);```, but... if we want to say that it's just my reading, that's fine.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8246,84179240,2016-10-19T22:15:12Z,src/compiler/python_generator.cc,"@@ -66,66 +68,11 @@ using std::vector;  namespace grpc_python_generator { -GeneratorConfiguration::GeneratorConfiguration()-    : grpc_package_root(""grpc""), beta_package_root(""grpc.beta"") {}--PythonGrpcGenerator::PythonGrpcGenerator(const GeneratorConfiguration& config)-    : config_(config) {}--PythonGrpcGenerator::~PythonGrpcGenerator() {}--bool PythonGrpcGenerator::Generate(const FileDescriptor* file,-                                   const grpc::string& parameter,-                                   GeneratorContext* context,-                                   grpc::string* error) const {-  // Get output file name.-  grpc::string file_name;-  static const int proto_suffix_length = strlen("".proto"");-  if (file->name().size() > static_cast<size_t>(proto_suffix_length) &&-      file->name().find_last_of("".proto"") == file->name().size() - 1) {-    file_name =-        file->name().substr(0, file->name().size() - proto_suffix_length) +-        ""_pb2.py"";-  } else {-    *error = ""Invalid proto file name. Proto file must end with .proto"";-    return false;-  }--  std::unique_ptr<ZeroCopyOutputStream> output(-      context->OpenForInsert(file_name, ""module_scope""));-  CodedOutputStream coded_out(output.get());-  bool success = false;-  grpc::string code = """";-  tie(success, code) = grpc_python_generator::GetServices(file, config_);-  if (success) {-    coded_out.WriteRaw(code.data(), code.size());-    return true;-  } else {-    return false;-  }-}- namespace {-//////////////////////////////////-// BEGIN FORMATTING BOILERPLATE //-//////////////////////////////////--// Converts an initializer list of the form { key0, value0, key1, value1, ... }-// into a map of key* to value*. Is merely a readability helper for later code.-map<grpc::string, grpc::string> ListToDict(-    const initializer_list<grpc::string>& values) {-  assert(values.size() % 2 == 0);-  map<grpc::string, grpc::string> value_map;-  auto value_iter = values.begin();-  for (unsigned i = 0; i < values.size() / 2; ++i) {-    grpc::string key = *value_iter;-    ++value_iter;-    grpc::string value = *value_iter;-    value_map[key] = value;-    ++value_iter;-  }-  return value_map;-}++typedef vector<const Descriptor*> DescriptorVector;","These look like virtuous, but independent, improvements - can they be made in a separate change?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8401,84313073,2016-10-20T15:44:42Z,tools/run_tests/filter_pull_request_tests.py,"@@ -56,46 +54,75 @@ def add_trigger(self, trigger):     """"""     self.triggers.append(trigger) + # Create test suites-_core_test_suite = TestSuite(['_c_'])-_cpp_test_suite = TestSuite(['_c++_'])-_csharp_test_suite = TestSuite(['_csharp_'])-_node_test_suite = TestSuite(['_node_'])-_objc_test_suite = TestSuite(['_objc_'])-_php_test_suite = TestSuite(['_php_', '_php7_'])-_python_test_suite = TestSuite(['_python_'])-_ruby_test_suite = TestSuite(['_ruby'])-_all_test_suites = [_core_test_suite, _cpp_test_suite, _csharp_test_suite,-                    _node_test_suite, _objc_test_suite, _php_test_suite,-                    _python_test_suite, _ruby_test_suite]+_SANITY_TEST_SUITE = TestSuite(['sanity'])+_CORE_TEST_SUITE = TestSuite(['c'])+_CPP_TEST_SUITE = TestSuite(['c++'])+_CSHARP_TEST_SUITE = TestSuite(['csharp'])+_NODE_TEST_SUITE = TestSuite(['node'])+_OBJC_TEST_SUITE = TestSuite(['objc'])+_PHP_TEST_SUITE = TestSuite(['php', 'php7'])+_PYTHON_TEST_SUITE = TestSuite(['python'])+_RUBY_TEST_SUITE = TestSuite(['ruby'])+_LINUX_TEST_SUITE = TestSuite(['linux'])+_WINDOWS_TEST_SUITE = TestSuite(['windows'])+_MACOS_TEST_SUITE = TestSuite(['macos'])+_ALL_TEST_SUITES = [_SANITY_TEST_SUITE, _CORE_TEST_SUITE, _CPP_TEST_SUITE,+                    _CSHARP_TEST_SUITE, _NODE_TEST_SUITE, _OBJC_TEST_SUITE,+                    _PHP_TEST_SUITE, _PYTHON_TEST_SUITE, _RUBY_TEST_SUITE,+                    _LINUX_TEST_SUITE, _WINDOWS_TEST_SUITE, _MACOS_TEST_SUITE]  # Dictionary of whitelistable files where the key is a regex matching changed files # and the value is a list of tests that should be run. An empty list means that # the changed files should not trigger any tests. Any changed file that does not # match any of these regexes will trigger all tests _WHITELIST_DICT = {","nit: we could add a comment with warning that ""ONLY CHANGE THE WHITELIST IF YOU KNOW WHAT YOU ARE DOING (and think twice in any case). Bad changes can result in skipping large portion of gRPC tests and breaking our code without noticing it.""Fine to add this comment later.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,84321000,2016-10-20T16:19:40Z,test/cpp/thread_manager/thread_manager_test.cc,"@@ -0,0 +1,131 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *is % allowed in string+ */++#include <atomic>+#include <memory>+#include <string>++#include <gflags/gflags.h>+#include <grpc++/grpc++.h>+#include <grpc/support/log.h>++#include ""test/cpp/util/test_config.h""++class ThreadManagerTest GRPC_FINAL : public grpc::ThreadManager {+ public:+  ThreadManagerTest()+      : ThreadManager(kMinPollers, kMaxPollers),+        num_do_work_(0),+        num_poll_for_work_(0),+        num_work_found_(0) {}++  grpc::ThreadManager::WorkStatus PollForWork(void **tag,+                                              bool *ok) GRPC_OVERRIDE;+  void DoWork(void *tag, bool ok) GRPC_OVERRIDE;+  void PerformTest();++ private:+  void SleepForMs(int sleep_time_ms);++  static const int kMinPollers = 2;+  static const int kMaxPollers = 10;++  static const int kPollingTimeoutMsec = 10;+  static const int kDoWorkDurationMsec = 1;++  // PollForWork will return SHUTDOWN after these many number of invocations+  static const int kMaxNumPollForWork = 50;++  std::atomic_int num_do_work_;        // Number of calls to DoWork+  std::atomic_int num_poll_for_work_;  // Number of calls to PollForWork+  std::atomic_int num_work_found_;  // Number of times WORK_FOUND was returned+};++void ThreadManagerTest::SleepForMs(int duration_ms) {+  gpr_timespec sleep_time =+      gpr_time_add(gpr_now(GPR_CLOCK_REALTIME),+                   gpr_time_from_millis(duration_ms, GPR_TIMESPAN));+  gpr_sleep_until(sleep_time);+}++grpc::ThreadManager::WorkStatus ThreadManagerTest::PollForWork(void **tag,+                                                               bool *ok) {+  int call_num = num_poll_for_work_.fetch_add(1);++  if (call_num >= kMaxNumPollForWork) {+    ThreadManager::Shutdown();",Why not just `Shutdown` ? Prefixing with the class name makes it seem like a static function or a call to the parent class's version of a virtual function.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8441,84385715,2016-10-20T22:06:27Z,src/objective-c/GRPCClient/private/GRPCConnectivityMonitor.m,"@@ -129,6 +130,13 @@ - (nullable instancetype)initWithReachability:(nullable SCNetworkReachabilityRef   if ((self = [super init])) {     _reachabilityRef = CFRetain(reachability);     _queue = dispatch_get_main_queue();+    SCNetworkReachabilityFlags flags;+    if (SCNetworkReachabilityGetFlags(_reachabilityRef, &flags)) {+      _previousReachabilityFlags =+          [[GRPCReachabilityFlags alloc] initWithFlags:flags];+    } else {+      _previousReachabilityFlags = 0;","`nil`, it's a pointer :) if the compiler didn't complain, the compiler is bad.",
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/8441,84392900,2016-10-20T23:00:17Z,src/objective-c/GRPCClient/private/GRPCHost.m,"@@ -98,6 +100,16 @@ - (nullable instancetype)initWithAddress:(NSString *)address {       _address = address;       _secure = YES;       kHostCache[address] = self;++      if (!connectivityMonitor) {+        connectivityMonitor =+            [GRPCConnectivityMonitor monitorWithHost:hostURL.host];","Yea. I think the host name does not matters here and assuming all the host names have the same reachability (we talked about this yesterday I remember). I don't need ReachabilityRef to all the hosts. As long as there is at least one host cached, I'm gonna need one ReachabilityRef to flush the channel.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8441,84395942,2016-10-20T23:27:55Z,src/objective-c/GRPCClient/private/GRPCReachabilityFlagNames.xmacro.h,"@@ -65,3 +65,4 @@ GRPC_XMACRO_ITEM(interventionRequired, InterventionRequired) GRPC_XMACRO_ITEM(connectionOnDemand, ConnectionOnDemand) GRPC_XMACRO_ITEM(isLocalAddress, IsLocalAddress) GRPC_XMACRO_ITEM(isDirect, IsDirect)+GRPC_XMACRO_ITEM(isWWAN, IsWWAN)","I'd suggest renaming that one to `isWWAN`, so next time someone goes looking for it it's easier to spot.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84409802,2016-10-21T02:18:57Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -291,36 +315,89 @@ def _empty_stream(stub):   def _status_code_and_message(stub):-  message = 'test status message'-  code = 2-  status = grpc.StatusCode.UNKNOWN # code = 2+  # Function wide constants+  _MESSAGE = 'test status message'+  _CODE = 2+  _STATUS = grpc.StatusCode.UNKNOWN # code = 2++  def ValidateStatusCodeAndMessage(response):",I think it's worth pulling this behavior out to module-scope even if it means adding another parameter or two.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84409863,2016-10-21T02:20:06Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -291,36 +315,89 @@ def _empty_stream(stub):   def _status_code_and_message(stub):-  message = 'test status message'-  code = 2-  status = grpc.StatusCode.UNKNOWN # code = 2+  # Function wide constants+  _MESSAGE = 'test status message'+  _CODE = 2+  _STATUS = grpc.StatusCode.UNKNOWN # code = 2++  def ValidateStatusCodeAndMessage(response):",I don't think that `response` is a good name for this parameter because the type according to which you are using it is `grpc.Call` (right?). `response` is a name usually reserved for deserialized response message values.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84409980,2016-10-21T02:21:40Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -291,36 +315,89 @@ def _empty_stream(stub):   def _status_code_and_message(stub):-  message = 'test status message'-  code = 2-  status = grpc.StatusCode.UNKNOWN # code = 2+  # Function wide constants+  _MESSAGE = 'test status message'+  _CODE = 2+  _STATUS = grpc.StatusCode.UNKNOWN # code = 2++  def ValidateStatusCodeAndMessage(response):+    if response.code() != _STATUS:+      raise ValueError(+        'expected code %s, got %s' % (_STATUS, response.code()))+    elif response.details() != _MESSAGE:+      raise ValueError(+        'expected message %s, got %s' % (_MESSAGE, response.details()))++  # Test with a UnaryCall   request = messages_pb2.SimpleRequest(       response_type=messages_pb2.COMPRESSABLE,       response_size=1,       payload=messages_pb2.Payload(body=b'\x00'),-      response_status=messages_pb2.EchoStatus(code=code, message=message)+      response_status=messages_pb2.EchoStatus(code=_CODE, message=_MESSAGE)   )   response_future = stub.UnaryCall.future(request)+  ValidateStatusCodeAndMessage(response_future)++  # Test with a FullDuplexCall+  with _Pipe() as pipe:+    response_iterator = stub.FullDuplexCall(pipe)+    request = messages_pb2.StreamingOutputCallRequest(+        response_type=messages_pb2.COMPRESSABLE,+        response_parameters=(+            messages_pb2.ResponseParameters(size=1),),+        payload=messages_pb2.Payload(body=b'\x00'),+        response_status=messages_pb2.EchoStatus(code=_CODE, message=_MESSAGE))+    pipe.add(request)   # sends the initial request.+  # Dropping out of with block closes the pipe+  ValidateStatusCodeAndMessage(response_iterator)+++def _unimplemented_method(stub):+  status = grpc.StatusCode.UNIMPLEMENTED+  response_future = stub.UnimplementedCall.future(empty_pb2.Empty())   if response_future.code() != status:     raise ValueError(       'expected code %s, got %s' % (status, response_future.code()))-  elif response_future.details() != message:-    raise ValueError(-      'expected message %s, got %s' % (message, response_future.details())) -  request = messages_pb2.StreamingOutputCallRequest(+def _custom_metadata(stub):+  # Function wide constants+  _INITIAL_METADATA_VALUE = ""test_initial_metadata_value""+  _TRAILING_METADATA_VALUE = ""\x0a\x0b\x0a\x0b\x0a\x0b""+  _METADATA = [+      (_INITIAL_METADATA_KEY, _INITIAL_METADATA_VALUE),+      (_TRAILING_METADATA_KEY, _TRAILING_METADATA_VALUE)]++  def ValidateMetadata(response):+    initial_metadata = dict(response.initial_metadata())+    if initial_metadata[_INITIAL_METADATA_KEY] != _INITIAL_METADATA_VALUE:+      raise ValueError(+        'expected initial metadata %s, got %s' % (+            _INITIAL_METADATA_VALUE, initial_metadata[_INITIAL_METADATA_KEY]))+    trailing_metadata = dict(response.trailing_metadata())+    if trailing_metadata[_TRAILING_METADATA_KEY] != _TRAILING_METADATA_VALUE:+      raise ValueError(+        'expected trailing metadata %s, got %s' % (+            _TRAILING_METADATA_VALUE, initial_metadata[_TRAILING_METADATA_KEY]))++  # Testing with UnaryCall+  request = messages_pb2.SimpleRequest(       response_type=messages_pb2.COMPRESSABLE,-      response_parameters=(-          messages_pb2.ResponseParameters(size=1),),-      response_status=messages_pb2.EchoStatus(code=code, message=message))-  response_iterator = stub.StreamingOutputCall(request)-  if response_future.code() != status:-    raise ValueError(-      'expected code %s, got %s' % (status, response_iterator.code()))-  elif response_future.details() != message:-    raise ValueError(-      'expected message %s, got %s' % (message, response_iterator.details()))+      response_size=1,+      payload=messages_pb2.Payload(body=b'\x00'))+  response_future = stub.UnaryCall.future(request, metadata=_METADATA)+  ValidateMetadata(response_future) +  # Testing with FullDuplexCall+  with _Pipe() as pipe:+    response_iterator = stub.FullDuplexCall(pipe, metadata=_METADATA)+    request = messages_pb2.StreamingOutputCallRequest(+        response_type=messages_pb2.COMPRESSABLE,+        response_parameters=(+            messages_pb2.ResponseParameters(size=1),))+    pipe.add(request)   # Sends the request+    next(response_iterator)    # Causes server to send trailing","""trailing"" isn't a noun, as we use the term throughout the codebase - do you mean ""trailing metadata""?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8438,84444256,2016-10-21T09:08:50Z,src/csharp/Grpc.Core/Metadata.cs,"@@ -128,55 +141,85 @@ public void RemoveAt(int index)             }         } +        /// <summary>+        /// <see cref=""IList.Add""/>+        /// </summary>         public void Add(Metadata.Entry item)         {             GrpcPreconditions.CheckNotNull(item);             CheckWriteable();             entries.Add(item);         } +        /// <summary>+        /// <see cref=""IList.Add""/>+        /// </summary>         public void Add(string key, string value)         {             Add(new Entry(key, value));         } +        /// <summary>+        /// <see cref=""IList.Add""/>+        /// </summary>         public void Add(string key, byte[] valueBytes)         {             Add(new Entry(key, valueBytes));         } +        /// <summary>+        /// <see cref=""IList.Clear""/>+        /// </summary>         public void Clear()         {             CheckWriteable();             entries.Clear();         } +        /// <summary>+        /// <see cref=""IList.Contains""/>+        /// </summary>         public bool Contains(Metadata.Entry item)         {             return entries.Contains(item);         } +        /// <summary>+        /// <see cref=""IList""/>+        /// </summary>         public void CopyTo(Metadata.Entry[] array, int arrayIndex)","Updated the cref to just point to IList<T> everywhere. The comments are useless anyway, pretty much every C# developer is familiar with IList interface. Adding them just to silence the compiler warnings.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8397,84455250,2016-10-21T10:23:12Z,tools/run_tests/run_performance_tests.py,"@@ -450,15 +452,23 @@ def finish_qps_workers(jobs): if not scenarios:   raise Exception('No scenarios to run') +total_scenario_failures = 0+total_jobs_killed = 0 for scenario in scenarios:   if args.dry_run:     print(scenario.name)   else:     try:       for worker in scenario.workers:         worker.start()-      jobset.run([scenario.jobspec,-                  create_quit_jobspec(scenario.workers, remote_host=args.remote_driver_host)],-                 newline_on_success=True, maxjobs=1)+      scenario_failures, _ = jobset.run([scenario.jobspec,+                                 create_quit_jobspec(scenario.workers, remote_host=args.remote_driver_host)],+                                 newline_on_success=True, maxjobs=1)+      total_scenario_failures += scenario_failures     finally:-      finish_qps_workers(scenario.workers)+      # Consider jobs that need to be killed as failures+      total_jobs_killed += finish_qps_workers(scenario.workers)++if num_failures > 0:+  print(str(total_scenario_failures) + "" scenarios failed and "" + str(total_jobs_killed) + "" jobs killed"")","nit:`print (""%s scenarios failed and %s qps worker jobs killed"" % (total_scenario_failures, total_jobs_killed))`  is much better in python. There's also a new syntax for doing this (preferred by some).nit : ""jobs killed"" is a bit ambiguous. You are talking about  qps worker jobs here but the scenarios are also jobs.Feel free to merge and address this later.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8313,84528597,2016-10-21T19:10:55Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,107 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_string(search_param, """",+              ""The parameter, whose value is to be searched for to achieve ""+              ""targeted cpu load"");","Very cool, could you give in the comment a list of valid search_param values?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8313,84528931,2016-10-21T19:14:02Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,107 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_string(search_param, """",+              ""The parameter, whose value is to be searched for to achieve ""+              ""targeted cpu load"");+DEFINE_double(+    initial_search_value, 0.0,+    ""initial parameter value to start the search with (i.e. lower bound)"");+DEFINE_double(targeted_cpu_load, 70.0,+              ""Targeted cpu load (unit: %, range [0,100])"");+DEFINE_double(precision, 1,+              ""Threshold for the search range, below which will end the ""+              ""search. Also defines each stride of the search."");  namespace grpc { namespace testing { +static std::unique_ptr<ScenarioResult> RunAndReport(const Scenario& scenario,+                                                    bool* success) {+  std::cerr << ""RUNNING SCENARIO: "" << scenario.name() << ""\n"";+  auto result =+      RunScenario(scenario.client_config(), scenario.num_clients(),+                  scenario.server_config(), scenario.num_servers(),+                  scenario.warmup_seconds(), scenario.benchmark_seconds(),+                  scenario.spawn_local_worker_count());++  // Amend the result with scenario config. Eventually we should adjust+  // RunScenario contract so we don't need to touch the result here.+  result->mutable_scenario()->CopyFrom(scenario);++  GetReporter()->ReportQPS(*result);+  GetReporter()->ReportQPSPerCore(*result);+  GetReporter()->ReportLatency(*result);+  GetReporter()->ReportTimes(*result);+  GetReporter()->ReportCpuUsage(*result);++  for (int i = 0; *success && i < result->client_success_size(); i++) {+    *success = result->client_success(i);+  }+  for (int i = 0; *success && i < result->server_success_size(); i++) {+    *success = result->server_success(i);+  }++  return result;+}++static double GetCpuLoad(Scenario* scenario, double offered_load,+                         bool* success) {+  scenario->mutable_client_config()+      ->mutable_load_params()+      ->mutable_poisson()+      ->set_offered_load(offered_load);+  auto result = RunAndReport(*scenario, success);+  return result->summary().server_cpu_usage();+}++static double BinarySearch(Scenario* scenario, double targeted_cpu_load,+                           double low, double high, bool* success) {+  while (low <= high - FLAGS_precision) {+    double mid = low + (high - low) / 2;+    double current_cpu_load = GetCpuLoad(scenario, mid, success);+    gpr_log(GPR_DEBUG, ""Binary Search: current_offered_load %.0f"", mid);+    if (!*success) {+      gpr_log(GPR_ERROR, ""Client/Server Failure"");+      break;+    }+    if (targeted_cpu_load < current_cpu_load) {+      high = mid - FLAGS_precision;+    } else if (targeted_cpu_load > current_cpu_load) {+      low = mid + FLAGS_precision;+    } else {+      high = mid - FLAGS_precision;","Isn't this the end condition, essentially, since you hit the nail on the head? Why not just get out with the value mid?",
426013,lyuxuan,https://api.github.com/repos/grpc/grpc/pulls/8313,84566889,2016-10-22T01:23:07Z,test/cpp/qps/qps_json_driver.cc,"@@ -49,10 +49,107 @@ DEFINE_string(scenarios_file, """", DEFINE_string(scenarios_json, """",               ""JSON string containing an array of Scenario objects""); DEFINE_bool(quit, false, ""Quit the workers"");+DEFINE_string(search_param, """",+              ""The parameter, whose value is to be searched for to achieve ""+              ""targeted cpu load"");+DEFINE_double(+    initial_search_value, 0.0,+    ""initial parameter value to start the search with (i.e. lower bound)"");+DEFINE_double(targeted_cpu_load, 70.0,+              ""Targeted cpu load (unit: %, range [0,100])"");+DEFINE_double(precision, 1,+              ""Threshold for the search range, below which will end the ""+              ""search. Also defines each stride of the search."");  namespace grpc { namespace testing { +static std::unique_ptr<ScenarioResult> RunAndReport(const Scenario& scenario,+                                                    bool* success) {+  std::cerr << ""RUNNING SCENARIO: "" << scenario.name() << ""\n"";+  auto result =+      RunScenario(scenario.client_config(), scenario.num_clients(),+                  scenario.server_config(), scenario.num_servers(),+                  scenario.warmup_seconds(), scenario.benchmark_seconds(),+                  scenario.spawn_local_worker_count());++  // Amend the result with scenario config. Eventually we should adjust+  // RunScenario contract so we don't need to touch the result here.+  result->mutable_scenario()->CopyFrom(scenario);++  GetReporter()->ReportQPS(*result);+  GetReporter()->ReportQPSPerCore(*result);+  GetReporter()->ReportLatency(*result);+  GetReporter()->ReportTimes(*result);+  GetReporter()->ReportCpuUsage(*result);++  for (int i = 0; *success && i < result->client_success_size(); i++) {+    *success = result->client_success(i);+  }+  for (int i = 0; *success && i < result->server_success_size(); i++) {+    *success = result->server_success(i);+  }++  return result;+}++static double GetCpuLoad(Scenario* scenario, double offered_load,+                         bool* success) {+  scenario->mutable_client_config()+      ->mutable_load_params()+      ->mutable_poisson()+      ->set_offered_load(offered_load);+  auto result = RunAndReport(*scenario, success);+  return result->summary().server_cpu_usage();+}++static double BinarySearch(Scenario* scenario, double targeted_cpu_load,+                           double low, double high, bool* success) {+  while (low <= high - FLAGS_precision) {",I added a new parameter called error_tolerance (a ratio).,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8396,84640533,2016-10-24T08:30:21Z,src/csharp/Grpc.Core/Server.cs,"@@ -325,25 +344,41 @@ private void DisposeHandle()             {","Well, not really. When an exception is thrown, HandleCallAsync eats the exception in the catch block and continues normally. So what I'm currently doing is safe I believe.On the other hand, you're right that adding the finally block is probably more readable and maintainable for the future, so I will change that in a followup PR.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8429,84731251,2016-10-24T16:50:10Z,src/core/ext/client_channel/client_channel.c,"@@ -60,6 +60,50 @@  /* Client channel implementation */ +typedef enum {",Add a big ol' block comment:``` /*************************************************************************   * METHOD-CONFIG TABLE   */```,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8462,84835469,2016-10-25T06:00:39Z,src/core/ext/client_channel/lb_policy_factory.h,"@@ -59,19 +59,27 @@ typedef struct grpc_lb_address {   void *user_data; } grpc_lb_address; +typedef struct grpc_lb_user_data_vtable {+  void *(*copy)(void *);+  void (*destroy)(void *);+  int (*cmp)(void *, void *);+} grpc_lb_user_data_vtable;+ typedef struct grpc_lb_addresses {   size_t num_addresses;   grpc_lb_address *addresses;+  const grpc_lb_user_data_vtable *user_data_vtable; } grpc_lb_addresses;  /** Returns a grpc_addresses struct with enough space for- * \a num_addresses addresses. */-grpc_lb_addresses *grpc_lb_addresses_create(size_t num_addresses);+    \a num_addresses addresses.  The \a user_data_vtable argument may be+    NULL if no user data will be added. */+grpc_lb_addresses *grpc_lb_addresses_create(+    size_t num_addresses, const grpc_lb_user_data_vtable *user_data_vtable);  /** Creates a copy of \a addresses.  If \a user_data_copy is not NULL,",Docstring is outdated. `user_data_copy` is gone.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8462,84835678,2016-10-25T06:03:21Z,src/core/ext/client_channel/lb_policy_factory.h,"@@ -81,20 +89,22 @@ void grpc_lb_addresses_set_address(grpc_lb_addresses *addresses, size_t index,                                    bool is_balancer, char *balancer_name,                                    void *user_data); +/** Compares \a addresses1 and \a addresses2. */+int grpc_lb_addresses_cmp(const grpc_lb_addresses *addresses1,+                          const grpc_lb_addresses *addresses2);+ /** Destroys \a addresses.  If \a user_data_destroy is not NULL, it will","Ditto, `user_data_destroy` is no more.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8462,84919877,2016-10-25T14:46:39Z,src/core/ext/resolver/dns/native/dns_resolver.c,"@@ -71,9 +72,9 @@ typedef struct {   /** pending next completion, or NULL */   grpc_closure *next_completion;   /** target result address for next completion */-  grpc_resolver_result **target_result;+  grpc_channel_args **target_result;","As per my previous comment, I think ""result"" is still a fine term here.  The fact that the data type of the result has changed doesn't mean that this isn't still the resolver's result.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84929657,2016-10-25T15:25:41Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def MaybeEchoMetaData(context):","Prefer PEP-8 names; should this be `_maybe_echo_metadata`? (And do the same for every behavior name introduced in this change that is free to be changed; some are not because they must match what's found in the `.proto` file.)Also in gRPC vocabulary ""metadata"" is one word, so no need for capital letter or underscore to separate ""meta"" from ""data"".",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8489,84936885,2016-10-25T15:55:11Z,src/core/ext/transport/chttp2/transport/chttp2_transport.c,"@@ -851,63 +851,60 @@ static bool contains_non_ok_status(grpc_metadata_batch *batch) {   return false; } -static void add_fetched_slice_locked(grpc_exec_ctx *exec_ctx,-                                     grpc_chttp2_transport *t,-                                     grpc_chttp2_stream *s);+typedef enum { CONTINUE_FETCHING, FINISHED_SLICE } continue_fetching_phase;  static void continue_fetching_send_locked(grpc_exec_ctx *exec_ctx,                                           grpc_chttp2_transport *t,-                                          grpc_chttp2_stream *s) {-  if (s->fetching_send_message == NULL) {-    /* Stream was cancelled before message fetch completed */-    abort(); /* TODO(ctiller): what cleanup here? */-    return;-  }-  if (s->fetched_send_message_length == s->fetching_send_message->length) {-    int64_t notify_offset = s->next_message_end_offset;-    if (notify_offset <= s->flow_controlled_bytes_written) {-      grpc_chttp2_complete_closure_step(-          exec_ctx, t, s, &s->fetching_send_message_finished, GRPC_ERROR_NONE,-          ""fetching_send_message_finished"");-    } else {-      grpc_chttp2_write_cb *cb = t->write_cb_pool;-      if (cb == NULL) {-        cb = gpr_malloc(sizeof(*cb));+                                          grpc_chttp2_stream *s,+                                          continue_fetching_phase phase) {+  if (phase == FINISHED_SLICE) goto finished_slice;","A goto that jumps into the middle of a loop makes me cringe.  I can think of two possible alternatives.First, we can keep `add_fetched_slice_locked()`, but have it be called only from `continue_fetching_send_locked()`, thus avoiding stack growth with each step of the recursion.  That would look like this:```static void add_fetched_slice_locked(grpc_exec_ctx *exec_ctx,       ￼                                     grpc_chttp2_transport *t,                                            grpc_chttp2_stream *s) {         s->fetched_send_message_length +=           (uint32_t)GPR_SLICE_LENGTH(s->fetching_slice);          gpr_slice_buffer_add(&s->flow_controlled_buffer, s->fetching_slice);        if (s->id != 0) {         grpc_chttp2_become_writable(exec_ctx, t, s, true, ""op.send_message"");         }}static void continue_fetching_send_locked(grpc_exec_ctx *exec_ctx,                                          grpc_chttp2_transport *t,                                          grpc_chttp2_stream *s,                                          continue_fetching_phase phase) {  if (phase == FINISHED_SLICE) add_fetched_slice_locked(exec_ctx, t, s);  while (true) {    if (s->fetching_send_message == NULL) {      /* Stream was cancelled before message fetch completed */      abort(); /* TODO(ctiller): what cleanup here? */      return;  /* early out */    }    if (s->fetched_send_message_length == s->fetching_send_message->length) {      int64_t notify_offset = s->next_message_end_offset;      if (notify_offset <= s->flow_controlled_bytes_written) {        grpc_chttp2_complete_closure_step(            exec_ctx, t, s, &s->fetching_send_message_finished, GRPC_ERROR_NONE,            ""fetching_send_message_finished"");      } else {        grpc_chttp2_write_cb *cb = t->write_cb_pool;        if (cb == NULL) {          cb = gpr_malloc(sizeof(*cb));        } else {          t->write_cb_pool = cb->next;        }        cb->call_at_byte = notify_offset;        cb->closure = s->fetching_send_message_finished;        s->fetching_send_message_finished = NULL;        cb->next = s->on_write_finished_cbs;        s->on_write_finished_cbs = cb;      }      s->fetching_send_message = NULL;      return; /* early out */    } else if (grpc_byte_stream_next(exec_ctx, s->fetching_send_message,                                     &s->fetching_slice, UINT32_MAX,                                     &s->complete_fetch)) {      add_fetched_slice_locked(exec_ctx, t, s);    }  }}```The other option is to keep everything inside of `continue_fetching_send_locked()`, but add some state in the loop body:```while (true) {  if (phase == CONTINUE_FETCHING) {    if (s->fetching_send_message == NULL) {      /* Stream was cancelled before message fetch completed */      abort(); /* TODO(ctiller): what cleanup here? */      return;  /* early out */    }    if (s->fetched_send_message_length == s->fetching_send_message->length) {      int64_t notify_offset = s->next_message_end_offset;      if (notify_offset <= s->flow_controlled_bytes_written) {        grpc_chttp2_complete_closure_step(            exec_ctx, t, s, &s->fetching_send_message_finished, GRPC_ERROR_NONE,            ""fetching_send_message_finished"");      } else {        grpc_chttp2_write_cb *cb = t->write_cb_pool;        if (cb == NULL) {          cb = gpr_malloc(sizeof(*cb));        } else {          t->write_cb_pool = cb->next;        }        cb->call_at_byte = notify_offset;        cb->closure = s->fetching_send_message_finished;        s->fetching_send_message_finished = NULL;        cb->next = s->on_write_finished_cbs;        s->on_write_finished_cbs = cb;      }      s->fetching_send_message = NULL;      return; /* early out */    }  }  if (phase == FINISHED_SLICE ||      grpc_byte_stream_next(exec_ctx, s->fetching_send_message,                            &s->fetching_slice, UINT32_MAX,                            &s->complete_fetch)) {    s->fetched_send_message_length +=        (uint32_t)GPR_SLICE_LENGTH(s->fetching_slice);    gpr_slice_buffer_add(&s->flow_controlled_buffer, s->fetching_slice);    if (s->id != 0) {      grpc_chttp2_become_writable(exec_ctx, t, s, true, ""op.send_message"");    }    phase = CONTINUE_FETCHING;  // Reset phase for next iteration.  }}```I personally prefer the first option.  What do you think?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84961637,2016-10-25T17:53:15Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -355,60 +355,61 @@ def _status_code_and_message(stub):         response_status=messages_pb2.EchoStatus(code=code, message=details))     pipe.add(request)   # sends the initial request.   # Dropping out of with block closes the pipe-  ValidateStatusCodeAndDetails(response_iterator, status, details)+  _validate_status_code_and_details(response_iterator, status, details)  -# NOTE: the stub for this function is a TestService.+# NOTE(ncteisen): the stub for this function is a TestService. def _unimplemented_method(stub):   response_future = stub.UnimplementedCall.future(empty_pb2.Empty())-  ExpectStatusCode(response_future, grpc.StatusCode.UNIMPLEMENTED)+  _expect_status_code(response_future, grpc.StatusCode.UNIMPLEMENTED)  -# NOTE: the stub for this function is an UnimplementedService.+# NOTE(ncteisen): the stub for this function is an UnimplementedService. def _unimplemented_service(stub):   response_future = stub.UnimplementedCall.future(empty_pb2.Empty())-  ExpectStatusCode(response_future, grpc.StatusCode.UNIMPLEMENTED)+  _expect_status_code(response_future, grpc.StatusCode.UNIMPLEMENTED)   def _custom_metadata(stub):   # Function wide constants-  _INITIAL_METADATA_VALUE = ""test_initial_metadata_value""-  _TRAILING_METADATA_VALUE = ""\x0a\x0b\x0a\x0b\x0a\x0b""-  _METADATA = [-      (_INITIAL_METADATA_KEY, _INITIAL_METADATA_VALUE),-      (_TRAILING_METADATA_KEY, _TRAILING_METADATA_VALUE)]--  def ValidateMetadata(response):+  initial_metadata_value = ""test_initial_metadata_value""+  trailing_metadata_value = ""\x0a\x0b\x0a\x0b\x0a\x0b""+  metadata = [",Never write a list literal where a tuple literal will do - will a tuple literal do here?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84979799,2016-10-25T19:17:30Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def _maybe_echo_metadata(context):",The type of this parameter appears to be `grpc.ServicerContext`; how about naming the parameter `servicer_context`?,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8269,84979833,2016-10-25T19:17:43Z,test/cpp/thread_manager/thread_manager_test.cc,"@@ -91,7 +91,7 @@ grpc::ThreadManager::WorkStatus ThreadManagerTest::PollForWork(void **tag,   // Simulate ""polling for work"" by sleeping for sometime   SleepForMs(kPollingTimeoutMsec); -  *tag = nullptr;+  *tag = NULL;",Can you list the error that you got here? I think it's really inadvisable to use NULL in lieu of nullptr since NULL technically isn't a pointer and this is likely to choke some other compiler version.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84979903,2016-10-25T19:18:08Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def _maybe_echo_metadata(context):+  metadata = dict(context.invocation_metadata())",Call this `invocation_metadata` rather than the more easily-confused-with-other-things unqualified `metadata`?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84980012,2016-10-25T19:18:54Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def _maybe_echo_metadata(context):+  metadata = dict(context.invocation_metadata())+  if _INITIAL_METADATA_KEY in metadata:+    initial_metadata = (","In orthodox gRPC vocabulary, this single key-value pair is a metadatum, not metadata.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84980058,2016-10-25T19:19:13Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def _maybe_echo_metadata(context):+  metadata = dict(context.invocation_metadata())+  if _INITIAL_METADATA_KEY in metadata:+    initial_metadata = (+        _INITIAL_METADATA_KEY, metadata[_INITIAL_METADATA_KEY])+    # Send initial metadata expects a list of tuples+    context.send_initial_metadata([initial_metadata])",Never write a list literal where a tuple literal will do.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84980211,2016-10-25T19:20:07Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def _maybe_echo_metadata(context):+  metadata = dict(context.invocation_metadata())+  if _INITIAL_METADATA_KEY in metadata:+    initial_metadata = (+        _INITIAL_METADATA_KEY, metadata[_INITIAL_METADATA_KEY])+    # Send initial metadata expects a list of tuples+    context.send_initial_metadata([initial_metadata])+  if _TRAILING_METADATA_KEY in metadata:+    trailing_metadata = (+      _TRAILING_METADATA_KEY, metadata[_TRAILING_METADATA_KEY])+    # Set trailing metadata expects a list of tuples+    context.set_trailing_metadata([trailing_metadata])",Never write a list literal where a tuple literal will do.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84980379,2016-10-25T19:21:03Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,48 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++# If the request came with metadata in the context, this+# helper function will copy it to the returned metadata.+def _maybe_echo_metadata(context):+  metadata = dict(context.invocation_metadata())+  if _INITIAL_METADATA_KEY in metadata:+    initial_metadata = (+        _INITIAL_METADATA_KEY, metadata[_INITIAL_METADATA_KEY])+    # Send initial metadata expects a list of tuples+    context.send_initial_metadata([initial_metadata])+  if _TRAILING_METADATA_KEY in metadata:+    trailing_metadata = (+      _TRAILING_METADATA_KEY, metadata[_TRAILING_METADATA_KEY])+    # Set trailing metadata expects a list of tuples+    context.set_trailing_metadata([trailing_metadata])++# If the request asks for a particular status code and details, this helper+# sets those values. It returns true if a status code was requested, because+# the server does not continue processing in that case+def _maybe_echo_status_and_message(request, context):","If the type of this second parameter is `grpc.ServicerContext`, go ahead and give the parameter a name that reminds the reader of that.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84981554,2016-10-25T19:26:50Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -291,36 +329,87 @@ def _empty_stream(stub):   def _status_code_and_message(stub):-  message = 'test status message'+  # Function wide constants+  details = 'test status message'   code = 2   status = grpc.StatusCode.UNKNOWN # code = 2++  # Test with a UnaryCall   request = messages_pb2.SimpleRequest(       response_type=messages_pb2.COMPRESSABLE,       response_size=1,       payload=messages_pb2.Payload(body=b'\x00'),-      response_status=messages_pb2.EchoStatus(code=code, message=message)+      response_status=messages_pb2.EchoStatus(code=code, message=details)   )   response_future = stub.UnaryCall.future(request)-  if response_future.code() != status:-    raise ValueError(-      'expected code %s, got %s' % (status, response_future.code()))-  elif response_future.details() != message:-    raise ValueError(-      'expected message %s, got %s' % (message, response_future.details()))+  _validate_status_code_and_details(response_future, status, details) -  request = messages_pb2.StreamingOutputCallRequest(+  # Test with a FullDuplexCall+  with _Pipe() as pipe:+    response_iterator = stub.FullDuplexCall(pipe)+    request = messages_pb2.StreamingOutputCallRequest(+        response_type=messages_pb2.COMPRESSABLE,+        response_parameters=(+            messages_pb2.ResponseParameters(size=1),),+        payload=messages_pb2.Payload(body=b'\x00'),+        response_status=messages_pb2.EchoStatus(code=code, message=details))+    pipe.add(request)   # sends the initial request.+  # Dropping out of with block closes the pipe+  _validate_status_code_and_details(response_iterator, status, details)+++# NOTE(ncteisen): the stub for this function is a TestService.",If this `NOTE` is specifying the type of the function's parameter... just write a proper doc string? A behavior's doc string is the proper place to describe the type of its parameters.,
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/8449,84987975,2016-10-25T20:01:38Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -291,36 +329,87 @@ def _empty_stream(stub):   def _status_code_and_message(stub):-  message = 'test status message'+  # Function wide constants+  details = 'test status message'   code = 2   status = grpc.StatusCode.UNKNOWN # code = 2++  # Test with a UnaryCall   request = messages_pb2.SimpleRequest(       response_type=messages_pb2.COMPRESSABLE,       response_size=1,       payload=messages_pb2.Payload(body=b'\x00'),-      response_status=messages_pb2.EchoStatus(code=code, message=message)+      response_status=messages_pb2.EchoStatus(code=code, message=details)   )   response_future = stub.UnaryCall.future(request)-  if response_future.code() != status:-    raise ValueError(-      'expected code %s, got %s' % (status, response_future.code()))-  elif response_future.details() != message:-    raise ValueError(-      'expected message %s, got %s' % (message, response_future.details()))+  _validate_status_code_and_details(response_future, status, details) -  request = messages_pb2.StreamingOutputCallRequest(+  # Test with a FullDuplexCall+  with _Pipe() as pipe:+    response_iterator = stub.FullDuplexCall(pipe)+    request = messages_pb2.StreamingOutputCallRequest(+        response_type=messages_pb2.COMPRESSABLE,+        response_parameters=(+            messages_pb2.ResponseParameters(size=1),),+        payload=messages_pb2.Payload(body=b'\x00'),+        response_status=messages_pb2.EchoStatus(code=code, message=details))+    pipe.add(request)   # sends the initial request.+  # Dropping out of with block closes the pipe+  _validate_status_code_and_details(response_iterator, status, details)+++# NOTE(ncteisen): the stub for this function is a TestService.",I think I can make this clear by naming the stub parameter test_service_stub,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8482,84989277,2016-10-25T20:08:35Z,include/grpc++/impl/codegen/call.h,"@@ -94,11 +95,65 @@ inline grpc_metadata* FillMetadataArray(   return metadata_array; } +/// Per-message options for all operation types+class MessageOptions {+ public:+  MessageOptions()+      : msg_deadline_(+            g_core_codegen_interface->gpr_inf_future(GPR_CLOCK_REALTIME)) {}+  gpr_timespec deadline() const { return msg_deadline_; }+  template <class T>+  void set_deadline(const T& deadline) {","In the case of this API, where the timeout is purely a local matter (i.e., it's not going to be propagated through a chain of RPCs), would it make sense to use timeout semantics instead of deadline semantics?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84989485,2016-10-25T20:09:46Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,45 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++def _maybe_echo_metadata(servicer_context):+  """"""Copies metadata from request to response if it is present.""""""+  invocation_metadata = dict(servicer_context.invocation_metadata())+  if _INITIAL_METADATA_KEY in invocation_metadata:+    initial_metadatum = (+        _INITIAL_METADATA_KEY, invocation_metadata[_INITIAL_METADATA_KEY])+    # Send initial metadata expects a list of tuples","You're not yet giving it a list of tuples; you're giving it a tuple wrapped inside parentheses. I think what you want on the next line is `servicer_context.send_initial_metadata((initial_metadatum,))`?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8449,84999701,2016-10-25T21:00:02Z,src/python/grpcio_tests/tests/interop/methods.py,"@@ -44,25 +44,45 @@ from src.proto.grpc.testing import messages_pb2 from src.proto.grpc.testing import test_pb2 +_INITIAL_METADATA_KEY = ""x-grpc-test-echo-initial""+_TRAILING_METADATA_KEY = ""x-grpc-test-echo-trailing-bin""++def _maybe_echo_metadata(servicer_context):+  """"""Copies metadata from request to response if it is present.""""""+  invocation_metadata = dict(servicer_context.invocation_metadata())+  if _INITIAL_METADATA_KEY in invocation_metadata:+    initial_metadatum = (+        _INITIAL_METADATA_KEY, invocation_metadata[_INITIAL_METADATA_KEY])+    # Send initial metadata expects a list of tuples",Drop this incorrect comment; `send_initial_metadata` requires merely [a sequence of metadatums](https://github.com/grpc/grpc/blob/5098508d2d41a116113f7e333c516cd9ef34a943/src/python/grpcio/commands.py#L84).,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8482,85389955,2016-10-27T17:42:22Z,include/grpc++/impl/codegen/call.h,"@@ -94,11 +95,65 @@ inline grpc_metadata* FillMetadataArray(   return metadata_array; } +/// Per-message options for all operation types+class MessageOptions {+ public:+  MessageOptions()+      : msg_deadline_(+            g_core_codegen_interface->gpr_inf_future(GPR_CLOCK_REALTIME)) {}+  gpr_timespec deadline() const { return msg_deadline_; }+  template <class T>+  void set_deadline(const T& deadline) {","It doesn't get propagated through a chain of RPCs, but it does have to get passed through multiple layers of the stack and will trigger asynchronously (by materializing an alarm at the appropriate time that pushes a ""quell"" op). Unless there's a strong reason otherwise, I feel that consistency weighs in favor of a deadline.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8474,85525276,2016-10-28T13:01:51Z,src/csharp/Grpc.Core/Internal/AsyncCall.cs,"@@ -510,6 +510,7 @@ private void HandleFinished(bool success, ClientSideStatus receivedStatus)              lock (myLock)             {+                readingDone = true;","The problem with doing just this is (as indicated by tests):1. in ReadMessageInternalAsync() we are using readingDone and relying on streamingReadTcs being populated (once the stream has finished, we keep returning the result of the last read).2. if there's a read already in flight (read has started but the op hasn't finished yet), we have an issue - we would need believe that that read is going to end up with ""null"" message and the call would be disposed on receiving that, but technically, that's not guaranteed and we could receive a message (and in that case we would keep delivering the same message over and over).So, I think these can be fixed, but you probably need to do a few more adjustments.Suggestions worth trying:1. if   streamingReadTcs == null (no read in flight), assign a new TCS and populate it with .SetResult(default(TResponse)).2. if a read is in flight, let it finish - there's a very good chance it's going to be a null message and if so problem solved) - if the received message is non-null, things become pretty tricky because theoretically you could still receive another message from C core (i'll have to check if that's the case actually), so you should not cut off the stream (actually could a problem in case 1 as well).",
7281574,nicolasnoble,https://api.github.com/repos/grpc/grpc/pulls/8461,85577244,2016-10-28T17:43:57Z,tools/run_tests/filter_pull_request_tests.py,"@@ -77,6 +77,7 @@ def add_trigger(self, trigger): # and the value is a list of tests that should be run. An empty list means that # the changed files should not trigger any tests. Any changed file that does not # match any of these regexes will trigger all tests+# DO NOT CHANGE THIS UNLESS YOU KNOW WHAT YOU ARE DOING (be careful even if you do) _WHITELIST_DICT = {","@ctiller this whitelist, basically.",
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8561,85608155,2016-10-28T20:51:34Z,src/objective-c/GRPCClient/GRPCCall+ChannelCredentials.h,"@@ -33,26 +33,24 @@  #import ""GRPCCall.h"" -/** Helpers for setting TLS Trusted Roots, Client Certificates, and Private Key- */+/** Helpers for setting TLS Trusted Roots, Client Certificates, and Private Key */ @interface GRPCCall (ChannelCredentials)  /**- * Use the provided @c pemRootCert as the set of trusted root Certificate- * Authorities for @c host.+ * Use the provided @c pemRootCert as the set of trusted root Certificate Authorities for @c host.  */ + (BOOL)setTLSPEMRootCerts:(nullable NSString *)pemRootCert                    forHost:(nonnull NSString *)host-                     error:(NSError *_Nullable *_Nullable)errorPtr;+                     error:(NSError * _Nullable * _Nullable)errorPtr;","Is the plan to try, after this, another run of clang-format with adjusted configuration? Some of the format fixes were pretty good.Or I guess it's better to run it on commit, as we discussed, and only on modified lines. That way when we detect a ""bad"" format correction we can go back to the configuration and fix it. One by one instead of all of them together. Then we can always run it on all files later in the future, when we're more confident with the tool.",
8228229,kkm000,https://api.github.com/repos/grpc/grpc/pulls/8474,85632404,2016-10-29T02:47:09Z,src/csharp/Grpc.Core/Internal/AsyncCall.cs,"@@ -510,6 +510,7 @@ private void HandleFinished(bool success, ClientSideStatus receivedStatus)              lock (myLock)             {+                readingDone = true;","Thanks Jan, the description of C behavior is very helpful as well! Let me see what else can be done here.The scenario of early disposal in general seems reasonable to me: no API expects programs to read open files to the end before closing, or reading sockets till the other end closes, and that should not be the case with the gRPC stream as well. So I am not sure that throwing away messages sent by the server should be a concern as long as the client explicitly expressed disinterest in these. My main concern here is getting the cancellation right, without leaking resources, calling disposed callbacks from native code and reporting nonsensical errors. Are we on the same page? Am I understanding the issue, and the whole of it?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85759930,2016-10-31T15:15:38Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -255,9 +261,15 @@ static void remove_disconnected_sc_locked(round_robin_lb_policy *p, static void rr_destroy(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol) {   round_robin_lb_policy *p = (round_robin_lb_policy *)pol;   ready_list *elem;++  if (grpc_lb_round_robin_trace) {+    gpr_log(GPR_DEBUG, ""Destroying Round Robin policy at %p"", (void*)pol);+  }+   for (size_t i = 0; i < p->num_subchannels; i++) {     subchannel_data *sd = p->subchannels[i];-    GRPC_SUBCHANNEL_UNREF(exec_ctx, sd->subchannel, ""round_robin"");+    GRPC_SUBCHANNEL_UNREF(exec_ctx, sd->subchannel, ""round_robin_destroy"");+    sd->user_data_vtable.destroy(sd->user_data);",What if there is no user data or user data vtable?  Should probably only do this if user_data != NULL.,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85775096,2016-10-31T16:20:49Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -296,20 +300,53 @@ typedef struct glb_lb_policy {    * response has arrived. */   grpc_grpclb_serverlist *serverlist; -  /** addresses from \a serverlist */-  grpc_lb_addresses *addresses;-   /** list of picks that are waiting on RR's policy connectivity */   pending_pick *pending_picks;    /** list of pings that are waiting on RR's policy connectivity */   pending_ping *pending_pings; -  /** client data associated with the LB server communication */-  struct lb_client_data *lb_client;+  bool shutting_down;++  /************************************************************/+  /*  client data associated with the LB server communication */+  /************************************************************/+  /* called once initial metadata's been sent */+  grpc_closure md_sent;++  /* called once the LoadBalanceRequest has been sent to the LB server. See+   * src/proto/grpc/.../load_balancer.proto */+  grpc_closure req_sent;++  /* A response from the LB server has been received (or error). Process it */+  grpc_closure res_rcvd;","A few naming suggestions:- Please prefix all of the fields that were formerly in the `lb_client_data` struct with `lb_`, so that it's clear which ones are related to communication with the LB.- Please avoid abbreviations (e.g., prefer `lb_response_received()` to `res_rcvd()`).- I suggest using the same name for each closure and the corresponding callback function.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85776030,2016-10-31T16:25:14Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -916,250 +950,181 @@ static void glb_notify_on_state_change(grpc_exec_ctx *exec_ctx,   gpr_mu_unlock(&glb_policy->mu); } -/*- * lb_client_data- *- * Used internally for the client call to the LB */-typedef struct lb_client_data {-  gpr_mu mu;--  /* called once initial metadata's been sent */-  grpc_closure md_sent;--  /* called once the LoadBalanceRequest has been sent to the LB server. See-   * src/proto/grpc/.../load_balancer.proto */-  grpc_closure req_sent;--  /* A response from the LB server has been received (or error). Process it */-  grpc_closure res_rcvd;--  /* After the client has sent a close to the LB server */-  grpc_closure close_sent;--  /* ... and the status from the LB server has been received */-  grpc_closure srv_status_rcvd;--  grpc_call *lb_call;    /* streaming call to the LB server, */-  gpr_timespec deadline; /* for the streaming call to the LB server */--  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */-  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */--  /* what's being sent to the LB server. Note that its value may vary if the LB-   * server indicates a redirect. */-  grpc_byte_buffer *request_payload;--  /* response from the LB server, if any. Processed in res_recv_cb() */-  grpc_byte_buffer *response_payload;--  /* the call's status and status detailset in srv_status_rcvd_cb() */-  grpc_status_code status;-  char *status_details;-  size_t status_details_capacity;--  /* pointer back to the enclosing policy */-  glb_lb_policy *glb_policy;-} lb_client_data;--static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void close_sent_cb(grpc_exec_ctx *exec_ctx, void *arg,-                          grpc_error *error); static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,                                grpc_error *error);--static lb_client_data *lb_client_data_create(glb_lb_policy *glb_policy) {+static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);+static void lb_client_init(glb_lb_policy *glb_policy) {   GPR_ASSERT(glb_policy->server_name != NULL);   GPR_ASSERT(glb_policy->server_name[0] != '\0'); -  lb_client_data *lb_client = gpr_malloc(sizeof(lb_client_data));-  memset(lb_client, 0, sizeof(lb_client_data));--  gpr_mu_init(&lb_client->mu);-  grpc_closure_init(&lb_client->md_sent, md_sent_cb, lb_client);--  grpc_closure_init(&lb_client->req_sent, req_sent_cb, lb_client);-  grpc_closure_init(&lb_client->res_rcvd, res_recv_cb, lb_client);-  grpc_closure_init(&lb_client->close_sent, close_sent_cb, lb_client);-  grpc_closure_init(&lb_client->srv_status_rcvd, srv_status_rcvd_cb, lb_client);--  lb_client->deadline = glb_policy->deadline;-   /* Note the following LB call progresses every time there's activity in \a    * glb_policy->base.interested_parties, which is comprised of the polling    * entities from \a client_channel. */-  lb_client->lb_call = grpc_channel_create_pollset_set_call(+  glb_policy->lb_call = grpc_channel_create_pollset_set_call(       glb_policy->lb_channel, NULL, GRPC_PROPAGATE_DEFAULTS,       glb_policy->base.interested_parties,       ""/grpc.lb.v1.LoadBalancer/BalanceLoad"", glb_policy->server_name,-      lb_client->deadline, NULL);+      glb_policy->deadline, NULL); -  grpc_metadata_array_init(&lb_client->initial_metadata_recv);-  grpc_metadata_array_init(&lb_client->trailing_metadata_recv);+  grpc_metadata_array_init(&glb_policy->initial_metadata_recv);+  grpc_metadata_array_init(&glb_policy->trailing_metadata_recv);    grpc_grpclb_request *request =       grpc_grpclb_request_create(glb_policy->server_name);   gpr_slice request_payload_slice = grpc_grpclb_request_encode(request);-  lb_client->request_payload =+  glb_policy->request_payload =       grpc_raw_byte_buffer_create(&request_payload_slice, 1);   gpr_slice_unref(request_payload_slice);   grpc_grpclb_request_destroy(request); -  lb_client->status_details = NULL;-  lb_client->status_details_capacity = 0;-  lb_client->glb_policy = glb_policy;-  return lb_client;+  glb_policy->lb_call_status_details = NULL;+  glb_policy->lb_call_status_details_capacity = 0;++  grpc_closure_init(&glb_policy->srv_status_rcvd, srv_status_rcvd_cb,+                    glb_policy);+  grpc_closure_init(&glb_policy->res_rcvd, res_recv_cb, glb_policy);++  gpr_backoff_init(&glb_policy->lb_call_backoff_state, BACKOFF_MULTIPLIER,+                   BACKOFF_JITTER, BACKOFF_MIN_SECONDS * 1000,+                   BACKOFF_MAX_SECONDS * 1000); } -static void lb_client_data_destroy(lb_client_data *lb_client) {-  grpc_call_destroy(lb_client->lb_call);-  grpc_metadata_array_destroy(&lb_client->initial_metadata_recv);-  grpc_metadata_array_destroy(&lb_client->trailing_metadata_recv);+static void lb_client_destroy(glb_lb_policy *glb_policy) {+  GPR_ASSERT(glb_policy->lb_call != NULL);+  grpc_call_destroy(glb_policy->lb_call);+  glb_policy->lb_call = NULL; -  grpc_byte_buffer_destroy(lb_client->request_payload);+  grpc_metadata_array_destroy(&glb_policy->initial_metadata_recv);+  grpc_metadata_array_destroy(&glb_policy->trailing_metadata_recv); -  gpr_free(lb_client->status_details);-  gpr_mu_destroy(&lb_client->mu);-  gpr_free(lb_client);-}-static grpc_call *lb_client_data_get_call(lb_client_data *lb_client) {-  return lb_client->lb_call;+  grpc_byte_buffer_destroy(glb_policy->request_payload);+  gpr_free(glb_policy->lb_call_status_details); }  /*  * Auxiliary functions and LB client callbacks.  */-static void query_for_backends(grpc_exec_ctx *exec_ctx,-                               glb_lb_policy *glb_policy) {+static void query_for_backends_locked(grpc_exec_ctx *exec_ctx,+                                      glb_lb_policy *glb_policy) {   GPR_ASSERT(glb_policy->lb_channel != NULL);+  GRPC_LB_POLICY_WEAK_REF(&glb_policy->base, ""query_for_backends_locked"");+  lb_client_init(glb_policy);++  if (grpc_lb_glb_trace) {+    gpr_log(GPR_INFO, ""Query for backends (grpclb: %p, lb_call: %p)"",+            (void *)glb_policy, (void *)glb_policy->lb_call);+  }+  GPR_ASSERT(glb_policy->lb_call != NULL); -  glb_policy->lb_client = lb_client_data_create(glb_policy);   grpc_call_error call_error;-  grpc_op ops[1];+  grpc_op ops[4];   memset(ops, 0, sizeof(ops));+   grpc_op *op = ops;   op->op = GRPC_OP_SEND_INITIAL_METADATA;   op->data.send_initial_metadata.count = 0;   op->flags = 0;   op->reserved = NULL;   op++;-  call_error = grpc_call_start_batch_and_execute(-      exec_ctx, glb_policy->lb_client->lb_call, ops, (size_t)(op - ops),-      &glb_policy->lb_client->md_sent);-  GPR_ASSERT(GRPC_CALL_OK == call_error); -  op = ops;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata =-      &glb_policy->lb_client->trailing_metadata_recv;-  op->data.recv_status_on_client.status = &glb_policy->lb_client->status;-  op->data.recv_status_on_client.status_details =-      &glb_policy->lb_client->status_details;-  op->data.recv_status_on_client.status_details_capacity =-      &glb_policy->lb_client->status_details_capacity;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &glb_policy->initial_metadata_recv;   op->flags = 0;   op->reserved = NULL;   op++;-  call_error = grpc_call_start_batch_and_execute(-      exec_ctx, glb_policy->lb_client->lb_call, ops, (size_t)(op - ops),-      &glb_policy->lb_client->srv_status_rcvd);-  GPR_ASSERT(GRPC_CALL_OK == call_error);-}--static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {-  lb_client_data *lb_client = arg;-  GPR_ASSERT(lb_client->lb_call);-  grpc_op ops[1];-  memset(ops, 0, sizeof(ops));-  grpc_op *op = ops; +  GPR_ASSERT(glb_policy->request_payload != NULL);   op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message = lb_client->request_payload;+  op->data.send_message = glb_policy->request_payload;   op->flags = 0;   op->reserved = NULL;   op++;-  grpc_call_error call_error = grpc_call_start_batch_and_execute(-      exec_ctx, lb_client->lb_call, ops, (size_t)(op - ops),-      &lb_client->req_sent);-  GPR_ASSERT(GRPC_CALL_OK == call_error);-} -static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {-  lb_client_data *lb_client = arg;-  GPR_ASSERT(lb_client->lb_call);--  grpc_op ops[2];-  memset(ops, 0, sizeof(ops));-  grpc_op *op = ops;--  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata = &lb_client->initial_metadata_recv;+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.trailing_metadata =+      &glb_policy->trailing_metadata_recv;+  op->data.recv_status_on_client.status = &glb_policy->lb_call_status;+  op->data.recv_status_on_client.status_details =+      &glb_policy->lb_call_status_details;+  op->data.recv_status_on_client.status_details_capacity =+      &glb_policy->lb_call_status_details_capacity;   op->flags = 0;   op->reserved = NULL;   op++;+  call_error = grpc_call_start_batch_and_execute(exec_ctx, glb_policy->lb_call,+                                                 ops, (size_t)(op - ops),+                                                 &glb_policy->srv_status_rcvd);+  GPR_ASSERT(GRPC_CALL_OK == call_error); +  op = ops;   op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message = &lb_client->response_payload;+  op->data.recv_message = &glb_policy->response_payload;   op->flags = 0;   op->reserved = NULL;   op++;-  grpc_call_error call_error = grpc_call_start_batch_and_execute(-      exec_ctx, lb_client->lb_call, ops, (size_t)(op - ops),-      &lb_client->res_rcvd);+  call_error = grpc_call_start_batch_and_execute(exec_ctx, glb_policy->lb_call,+                                                 ops, (size_t)(op - ops),+                                                 &glb_policy->res_rcvd);   GPR_ASSERT(GRPC_CALL_OK == call_error); }  static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {-  lb_client_data *lb_client = arg;+  glb_lb_policy *glb_policy = arg;+   grpc_op ops[2];   memset(ops, 0, sizeof(ops));   grpc_op *op = ops;-  if (lb_client->response_payload != NULL) {+  if (glb_policy->response_payload != NULL) {+    gpr_backoff_reset(&glb_policy->lb_call_backoff_state);     /* Received data from the LB server. Look inside-     * lb_client->response_payload, for a serverlist. */+     * glb_policy->response_payload, for a serverlist. */     grpc_byte_buffer_reader bbr;-    grpc_byte_buffer_reader_init(&bbr, lb_client->response_payload);+    grpc_byte_buffer_reader_init(&bbr, glb_policy->response_payload);     gpr_slice response_slice = grpc_byte_buffer_reader_readall(&bbr);-    grpc_byte_buffer_destroy(lb_client->response_payload);+    grpc_byte_buffer_destroy(glb_policy->response_payload);     grpc_grpclb_serverlist *serverlist =         grpc_grpclb_response_parse_serverlist(response_slice);     if (serverlist != NULL) {+      GPR_ASSERT(glb_policy->lb_call != NULL);       gpr_slice_unref(response_slice);       if (grpc_lb_glb_trace) {         gpr_log(GPR_INFO, ""Serverlist with %lu servers received"",                 (unsigned long)serverlist->num_servers);+        /* TODO(dgq): this needs to work with ipv6. */","Can we re-use the code from `process_serverlist()` for this, so that we don't have to maintain similar code twice?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85776312,2016-10-31T16:26:31Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -916,250 +950,181 @@ static void glb_notify_on_state_change(grpc_exec_ctx *exec_ctx,   gpr_mu_unlock(&glb_policy->mu); } -/*- * lb_client_data- *- * Used internally for the client call to the LB */-typedef struct lb_client_data {-  gpr_mu mu;--  /* called once initial metadata's been sent */-  grpc_closure md_sent;--  /* called once the LoadBalanceRequest has been sent to the LB server. See-   * src/proto/grpc/.../load_balancer.proto */-  grpc_closure req_sent;--  /* A response from the LB server has been received (or error). Process it */-  grpc_closure res_rcvd;--  /* After the client has sent a close to the LB server */-  grpc_closure close_sent;--  /* ... and the status from the LB server has been received */-  grpc_closure srv_status_rcvd;--  grpc_call *lb_call;    /* streaming call to the LB server, */-  gpr_timespec deadline; /* for the streaming call to the LB server */--  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */-  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */--  /* what's being sent to the LB server. Note that its value may vary if the LB-   * server indicates a redirect. */-  grpc_byte_buffer *request_payload;--  /* response from the LB server, if any. Processed in res_recv_cb() */-  grpc_byte_buffer *response_payload;--  /* the call's status and status detailset in srv_status_rcvd_cb() */-  grpc_status_code status;-  char *status_details;-  size_t status_details_capacity;--  /* pointer back to the enclosing policy */-  glb_lb_policy *glb_policy;-} lb_client_data;--static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void close_sent_cb(grpc_exec_ctx *exec_ctx, void *arg,-                          grpc_error *error); static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,                                grpc_error *error);--static lb_client_data *lb_client_data_create(glb_lb_policy *glb_policy) {+static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);+static void lb_client_init(glb_lb_policy *glb_policy) {   GPR_ASSERT(glb_policy->server_name != NULL);   GPR_ASSERT(glb_policy->server_name[0] != '\0'); -  lb_client_data *lb_client = gpr_malloc(sizeof(lb_client_data));-  memset(lb_client, 0, sizeof(lb_client_data));--  gpr_mu_init(&lb_client->mu);-  grpc_closure_init(&lb_client->md_sent, md_sent_cb, lb_client);--  grpc_closure_init(&lb_client->req_sent, req_sent_cb, lb_client);-  grpc_closure_init(&lb_client->res_rcvd, res_recv_cb, lb_client);-  grpc_closure_init(&lb_client->close_sent, close_sent_cb, lb_client);-  grpc_closure_init(&lb_client->srv_status_rcvd, srv_status_rcvd_cb, lb_client);--  lb_client->deadline = glb_policy->deadline;-   /* Note the following LB call progresses every time there's activity in \a    * glb_policy->base.interested_parties, which is comprised of the polling    * entities from \a client_channel. */-  lb_client->lb_call = grpc_channel_create_pollset_set_call(+  glb_policy->lb_call = grpc_channel_create_pollset_set_call(       glb_policy->lb_channel, NULL, GRPC_PROPAGATE_DEFAULTS,       glb_policy->base.interested_parties,       ""/grpc.lb.v1.LoadBalancer/BalanceLoad"", glb_policy->server_name,-      lb_client->deadline, NULL);+      glb_policy->deadline, NULL); -  grpc_metadata_array_init(&lb_client->initial_metadata_recv);-  grpc_metadata_array_init(&lb_client->trailing_metadata_recv);+  grpc_metadata_array_init(&glb_policy->initial_metadata_recv);+  grpc_metadata_array_init(&glb_policy->trailing_metadata_recv);    grpc_grpclb_request *request =       grpc_grpclb_request_create(glb_policy->server_name);   gpr_slice request_payload_slice = grpc_grpclb_request_encode(request);-  lb_client->request_payload =+  glb_policy->request_payload =       grpc_raw_byte_buffer_create(&request_payload_slice, 1);   gpr_slice_unref(request_payload_slice);   grpc_grpclb_request_destroy(request); -  lb_client->status_details = NULL;-  lb_client->status_details_capacity = 0;-  lb_client->glb_policy = glb_policy;-  return lb_client;+  glb_policy->lb_call_status_details = NULL;+  glb_policy->lb_call_status_details_capacity = 0;++  grpc_closure_init(&glb_policy->srv_status_rcvd, srv_status_rcvd_cb,+                    glb_policy);+  grpc_closure_init(&glb_policy->res_rcvd, res_recv_cb, glb_policy);++  gpr_backoff_init(&glb_policy->lb_call_backoff_state, BACKOFF_MULTIPLIER,+                   BACKOFF_JITTER, BACKOFF_MIN_SECONDS * 1000,+                   BACKOFF_MAX_SECONDS * 1000); } -static void lb_client_data_destroy(lb_client_data *lb_client) {-  grpc_call_destroy(lb_client->lb_call);-  grpc_metadata_array_destroy(&lb_client->initial_metadata_recv);-  grpc_metadata_array_destroy(&lb_client->trailing_metadata_recv);+static void lb_client_destroy(glb_lb_policy *glb_policy) {+  GPR_ASSERT(glb_policy->lb_call != NULL);+  grpc_call_destroy(glb_policy->lb_call);+  glb_policy->lb_call = NULL; -  grpc_byte_buffer_destroy(lb_client->request_payload);+  grpc_metadata_array_destroy(&glb_policy->initial_metadata_recv);+  grpc_metadata_array_destroy(&glb_policy->trailing_metadata_recv); -  gpr_free(lb_client->status_details);-  gpr_mu_destroy(&lb_client->mu);-  gpr_free(lb_client);-}-static grpc_call *lb_client_data_get_call(lb_client_data *lb_client) {-  return lb_client->lb_call;+  grpc_byte_buffer_destroy(glb_policy->request_payload);+  gpr_free(glb_policy->lb_call_status_details); }  /*  * Auxiliary functions and LB client callbacks.  */-static void query_for_backends(grpc_exec_ctx *exec_ctx,-                               glb_lb_policy *glb_policy) {+static void query_for_backends_locked(grpc_exec_ctx *exec_ctx,+                                      glb_lb_policy *glb_policy) {   GPR_ASSERT(glb_policy->lb_channel != NULL);+  GRPC_LB_POLICY_WEAK_REF(&glb_policy->base, ""query_for_backends_locked"");+  lb_client_init(glb_policy);++  if (grpc_lb_glb_trace) {+    gpr_log(GPR_INFO, ""Query for backends (grpclb: %p, lb_call: %p)"",+            (void *)glb_policy, (void *)glb_policy->lb_call);+  }+  GPR_ASSERT(glb_policy->lb_call != NULL); -  glb_policy->lb_client = lb_client_data_create(glb_policy);   grpc_call_error call_error;-  grpc_op ops[1];+  grpc_op ops[4];   memset(ops, 0, sizeof(ops));+   grpc_op *op = ops;   op->op = GRPC_OP_SEND_INITIAL_METADATA;   op->data.send_initial_metadata.count = 0;   op->flags = 0;   op->reserved = NULL;   op++;-  call_error = grpc_call_start_batch_and_execute(-      exec_ctx, glb_policy->lb_client->lb_call, ops, (size_t)(op - ops),-      &glb_policy->lb_client->md_sent);-  GPR_ASSERT(GRPC_CALL_OK == call_error); -  op = ops;-  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;-  op->data.recv_status_on_client.trailing_metadata =-      &glb_policy->lb_client->trailing_metadata_recv;-  op->data.recv_status_on_client.status = &glb_policy->lb_client->status;-  op->data.recv_status_on_client.status_details =-      &glb_policy->lb_client->status_details;-  op->data.recv_status_on_client.status_details_capacity =-      &glb_policy->lb_client->status_details_capacity;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &glb_policy->initial_metadata_recv;   op->flags = 0;   op->reserved = NULL;   op++;-  call_error = grpc_call_start_batch_and_execute(-      exec_ctx, glb_policy->lb_client->lb_call, ops, (size_t)(op - ops),-      &glb_policy->lb_client->srv_status_rcvd);-  GPR_ASSERT(GRPC_CALL_OK == call_error);-}--static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {-  lb_client_data *lb_client = arg;-  GPR_ASSERT(lb_client->lb_call);-  grpc_op ops[1];-  memset(ops, 0, sizeof(ops));-  grpc_op *op = ops; +  GPR_ASSERT(glb_policy->request_payload != NULL);   op->op = GRPC_OP_SEND_MESSAGE;-  op->data.send_message = lb_client->request_payload;+  op->data.send_message = glb_policy->request_payload;   op->flags = 0;   op->reserved = NULL;   op++;-  grpc_call_error call_error = grpc_call_start_batch_and_execute(-      exec_ctx, lb_client->lb_call, ops, (size_t)(op - ops),-      &lb_client->req_sent);-  GPR_ASSERT(GRPC_CALL_OK == call_error);-} -static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {-  lb_client_data *lb_client = arg;-  GPR_ASSERT(lb_client->lb_call);--  grpc_op ops[2];-  memset(ops, 0, sizeof(ops));-  grpc_op *op = ops;--  op->op = GRPC_OP_RECV_INITIAL_METADATA;-  op->data.recv_initial_metadata = &lb_client->initial_metadata_recv;+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.trailing_metadata =+      &glb_policy->trailing_metadata_recv;+  op->data.recv_status_on_client.status = &glb_policy->lb_call_status;+  op->data.recv_status_on_client.status_details =+      &glb_policy->lb_call_status_details;+  op->data.recv_status_on_client.status_details_capacity =+      &glb_policy->lb_call_status_details_capacity;   op->flags = 0;   op->reserved = NULL;   op++;+  call_error = grpc_call_start_batch_and_execute(exec_ctx, glb_policy->lb_call,+                                                 ops, (size_t)(op - ops),+                                                 &glb_policy->srv_status_rcvd);+  GPR_ASSERT(GRPC_CALL_OK == call_error); +  op = ops;   op->op = GRPC_OP_RECV_MESSAGE;-  op->data.recv_message = &lb_client->response_payload;+  op->data.recv_message = &glb_policy->response_payload;   op->flags = 0;   op->reserved = NULL;   op++;-  grpc_call_error call_error = grpc_call_start_batch_and_execute(-      exec_ctx, lb_client->lb_call, ops, (size_t)(op - ops),-      &lb_client->res_rcvd);+  call_error = grpc_call_start_batch_and_execute(exec_ctx, glb_policy->lb_call,+                                                 ops, (size_t)(op - ops),+                                                 &glb_policy->res_rcvd);   GPR_ASSERT(GRPC_CALL_OK == call_error); }  static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {-  lb_client_data *lb_client = arg;+  glb_lb_policy *glb_policy = arg;+   grpc_op ops[2];   memset(ops, 0, sizeof(ops));   grpc_op *op = ops;-  if (lb_client->response_payload != NULL) {+  if (glb_policy->response_payload != NULL) {+    gpr_backoff_reset(&glb_policy->lb_call_backoff_state);     /* Received data from the LB server. Look inside-     * lb_client->response_payload, for a serverlist. */+     * glb_policy->response_payload, for a serverlist. */     grpc_byte_buffer_reader bbr;-    grpc_byte_buffer_reader_init(&bbr, lb_client->response_payload);+    grpc_byte_buffer_reader_init(&bbr, glb_policy->response_payload);     gpr_slice response_slice = grpc_byte_buffer_reader_readall(&bbr);-    grpc_byte_buffer_destroy(lb_client->response_payload);+    grpc_byte_buffer_destroy(glb_policy->response_payload);     grpc_grpclb_serverlist *serverlist =         grpc_grpclb_response_parse_serverlist(response_slice);     if (serverlist != NULL) {+      GPR_ASSERT(glb_policy->lb_call != NULL);       gpr_slice_unref(response_slice);       if (grpc_lb_glb_trace) {         gpr_log(GPR_INFO, ""Serverlist with %lu servers received"",                 (unsigned long)serverlist->num_servers);+        /* TODO(dgq): this needs to work with ipv6. */+        for (size_t i = 0; i < serverlist->num_servers; ++i) {",Do we really want to do this unconditionally?  Or would it make sense to wrap this loop in a `if (grpc_lb_glb_trace) {...}`?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85778345,2016-10-31T16:35:44Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -916,250 +950,181 @@ static void glb_notify_on_state_change(grpc_exec_ctx *exec_ctx,   gpr_mu_unlock(&glb_policy->mu); } -/*- * lb_client_data- *- * Used internally for the client call to the LB */-typedef struct lb_client_data {-  gpr_mu mu;--  /* called once initial metadata's been sent */-  grpc_closure md_sent;--  /* called once the LoadBalanceRequest has been sent to the LB server. See-   * src/proto/grpc/.../load_balancer.proto */-  grpc_closure req_sent;--  /* A response from the LB server has been received (or error). Process it */-  grpc_closure res_rcvd;--  /* After the client has sent a close to the LB server */-  grpc_closure close_sent;--  /* ... and the status from the LB server has been received */-  grpc_closure srv_status_rcvd;--  grpc_call *lb_call;    /* streaming call to the LB server, */-  gpr_timespec deadline; /* for the streaming call to the LB server */--  grpc_metadata_array initial_metadata_recv;  /* initial MD from LB server */-  grpc_metadata_array trailing_metadata_recv; /* trailing MD from LB server */--  /* what's being sent to the LB server. Note that its value may vary if the LB-   * server indicates a redirect. */-  grpc_byte_buffer *request_payload;--  /* response from the LB server, if any. Processed in res_recv_cb() */-  grpc_byte_buffer *response_payload;--  /* the call's status and status detailset in srv_status_rcvd_cb() */-  grpc_status_code status;-  char *status_details;-  size_t status_details_capacity;--  /* pointer back to the enclosing policy */-  glb_lb_policy *glb_policy;-} lb_client_data;--static void md_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void req_sent_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);-static void close_sent_cb(grpc_exec_ctx *exec_ctx, void *arg,-                          grpc_error *error); static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,                                grpc_error *error);--static lb_client_data *lb_client_data_create(glb_lb_policy *glb_policy) {+static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error);+static void lb_client_init(glb_lb_policy *glb_policy) {   GPR_ASSERT(glb_policy->server_name != NULL);   GPR_ASSERT(glb_policy->server_name[0] != '\0'); -  lb_client_data *lb_client = gpr_malloc(sizeof(lb_client_data));-  memset(lb_client, 0, sizeof(lb_client_data));--  gpr_mu_init(&lb_client->mu);-  grpc_closure_init(&lb_client->md_sent, md_sent_cb, lb_client);--  grpc_closure_init(&lb_client->req_sent, req_sent_cb, lb_client);-  grpc_closure_init(&lb_client->res_rcvd, res_recv_cb, lb_client);-  grpc_closure_init(&lb_client->close_sent, close_sent_cb, lb_client);-  grpc_closure_init(&lb_client->srv_status_rcvd, srv_status_rcvd_cb, lb_client);--  lb_client->deadline = glb_policy->deadline;-   /* Note the following LB call progresses every time there's activity in \a    * glb_policy->base.interested_parties, which is comprised of the polling    * entities from \a client_channel. */-  lb_client->lb_call = grpc_channel_create_pollset_set_call(+  glb_policy->lb_call = grpc_channel_create_pollset_set_call(       glb_policy->lb_channel, NULL, GRPC_PROPAGATE_DEFAULTS,       glb_policy->base.interested_parties,       ""/grpc.lb.v1.LoadBalancer/BalanceLoad"", glb_policy->server_name,-      lb_client->deadline, NULL);+      glb_policy->deadline, NULL); -  grpc_metadata_array_init(&lb_client->initial_metadata_recv);-  grpc_metadata_array_init(&lb_client->trailing_metadata_recv);+  grpc_metadata_array_init(&glb_policy->initial_metadata_recv);+  grpc_metadata_array_init(&glb_policy->trailing_metadata_recv);    grpc_grpclb_request *request =       grpc_grpclb_request_create(glb_policy->server_name);   gpr_slice request_payload_slice = grpc_grpclb_request_encode(request);-  lb_client->request_payload =+  glb_policy->request_payload =       grpc_raw_byte_buffer_create(&request_payload_slice, 1);   gpr_slice_unref(request_payload_slice);   grpc_grpclb_request_destroy(request); -  lb_client->status_details = NULL;-  lb_client->status_details_capacity = 0;-  lb_client->glb_policy = glb_policy;-  return lb_client;+  glb_policy->lb_call_status_details = NULL;+  glb_policy->lb_call_status_details_capacity = 0;++  grpc_closure_init(&glb_policy->srv_status_rcvd, srv_status_rcvd_cb,+                    glb_policy);+  grpc_closure_init(&glb_policy->res_rcvd, res_recv_cb, glb_policy);++  gpr_backoff_init(&glb_policy->lb_call_backoff_state, BACKOFF_MULTIPLIER,+                   BACKOFF_JITTER, BACKOFF_MIN_SECONDS * 1000,+                   BACKOFF_MAX_SECONDS * 1000); } -static void lb_client_data_destroy(lb_client_data *lb_client) {-  grpc_call_destroy(lb_client->lb_call);-  grpc_metadata_array_destroy(&lb_client->initial_metadata_recv);-  grpc_metadata_array_destroy(&lb_client->trailing_metadata_recv);+static void lb_client_destroy(glb_lb_policy *glb_policy) {+  GPR_ASSERT(glb_policy->lb_call != NULL);+  grpc_call_destroy(glb_policy->lb_call);+  glb_policy->lb_call = NULL; -  grpc_byte_buffer_destroy(lb_client->request_payload);+  grpc_metadata_array_destroy(&glb_policy->initial_metadata_recv);+  grpc_metadata_array_destroy(&glb_policy->trailing_metadata_recv); -  gpr_free(lb_client->status_details);-  gpr_mu_destroy(&lb_client->mu);-  gpr_free(lb_client);-}-static grpc_call *lb_client_data_get_call(lb_client_data *lb_client) {-  return lb_client->lb_call;+  grpc_byte_buffer_destroy(glb_policy->request_payload);+  gpr_free(glb_policy->lb_call_status_details); }  /*  * Auxiliary functions and LB client callbacks.  */-static void query_for_backends(grpc_exec_ctx *exec_ctx,-                               glb_lb_policy *glb_policy) {+static void query_for_backends_locked(grpc_exec_ctx *exec_ctx,+                                      glb_lb_policy *glb_policy) {   GPR_ASSERT(glb_policy->lb_channel != NULL);+  GRPC_LB_POLICY_WEAK_REF(&glb_policy->base, ""query_for_backends_locked"");","How do the semantics of weak refs differ from normal refs, and why are we using them here?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85779981,2016-10-31T16:43:01Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -1185,42 +1150,105 @@ static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {     gpr_log(GPR_ERROR, ""Invalid LB response received: '%s'"",             gpr_dump_slice(response_slice, GPR_DUMP_ASCII));     gpr_slice_unref(response_slice);--    /* Disconnect from server returning invalid response. */-    op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-    op->flags = 0;-    op->reserved = NULL;-    op++;-    grpc_call_error call_error = grpc_call_start_batch_and_execute(-        exec_ctx, lb_client->lb_call, ops, (size_t)(op - ops),-        &lb_client->close_sent);-    GPR_ASSERT(GRPC_CALL_OK == call_error);+    grpc_call_cancel(glb_policy->lb_call, NULL);+    /* srv_status_rcvd_cb will pick up the cancellation and clean up */   }-  /* empty payload: call cancelled by server. Cleanups happening in-   * srv_status_rcvd_cb */+  /* else, empty payload: call cancelled by server. */+  grpc_metadata_array_destroy(&glb_policy->initial_metadata_recv); } -static void close_sent_cb(grpc_exec_ctx *exec_ctx, void *arg,-                          grpc_error *error) {-  if (grpc_lb_glb_trace) {-    gpr_log(GPR_INFO,-            ""Close from LB client sent. Waiting from server status now"");+static void lb_call_on_retry_timer(grpc_exec_ctx *exec_ctx, void *arg,+                                   grpc_error *error) {+  glb_lb_policy *glb_policy = arg;+  gpr_mu_lock(&glb_policy->mu);++  if (!glb_policy->shutting_down) {+    if (grpc_lb_glb_trace) {+      gpr_log(GPR_INFO, ""Restaring call to LB server (grpclb %p)"",+              (void *)glb_policy);+    }+    GPR_ASSERT(glb_policy->lb_call == NULL);+    query_for_backends_locked(exec_ctx, glb_policy);   }+  gpr_mu_unlock(&glb_policy->mu);++  GRPC_LB_POLICY_WEAK_UNREF(exec_ctx, &glb_policy->base,+                            ""grpclb_on_retry_timer""); }  static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,                                grpc_error *error) {-  lb_client_data *lb_client = arg;+  glb_lb_policy *glb_policy = arg;+  gpr_mu_lock(&glb_policy->mu);++  GPR_ASSERT(glb_policy->lb_call != NULL);+   if (grpc_lb_glb_trace) {-    gpr_log(GPR_INFO,-            ""status from lb server received. Status = %d, Details = '%s', ""-            ""Capacity ""-            ""= %lu"",-            lb_client->status, lb_client->status_details,-            (unsigned long)lb_client->status_details_capacity);+    gpr_log(GPR_DEBUG,+            ""Status from LB server received. Status = %d, Details = '%s', ""+            ""(call: %p)"",+            glb_policy->lb_call_status, glb_policy->lb_call_status_details,+            (void *)glb_policy->lb_call);+  }++  if (glb_policy->lb_call_status == GRPC_STATUS_UNIMPLEMENTED) {+    char *failing_server = grpc_call_get_peer(glb_policy->lb_call);+    char *error_desc;+    gpr_asprintf(&error_desc, ""Invalid LB server '%s'"", failing_server);+    gpr_free(failing_server);+    /* flush pending ops */+    pending_pick *pp;+    while ((pp = glb_policy->pending_picks)) {+      glb_policy->pending_picks = pp->next;+      if (grpc_lb_glb_trace) {+        gpr_log(GPR_INFO, ""Cancelling pending pick: %s"", error_desc);","For requests with wait_for_ready=false (the default), do we actually want to cancel the picks?  Shouldn't the picks stay pending until either we successfully retry the LB request or the calls' deadlines expire?  Or is the pick retries for us by the client_channel code?",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/8572,85856486,2016-10-31T23:52:45Z,src/core/lib/iomgr/port.h,"@@ -36,6 +36,9 @@ #ifndef GRPC_CORE_LIB_IOMGR_PORT_H #define GRPC_CORE_LIB_IOMGR_PORT_H +#define MAX_WRITE_IOVEC 1000+#define GRPC_TCP_CONN_REQUEST_MAX SOMAXCONN","Instead of defining these here, define them in the relevant C files, conditional on the system.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8568,85876642,2016-11-01T05:19:07Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -1185,42 +1150,105 @@ static void res_recv_cb(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {     gpr_log(GPR_ERROR, ""Invalid LB response received: '%s'"",             gpr_dump_slice(response_slice, GPR_DUMP_ASCII));     gpr_slice_unref(response_slice);--    /* Disconnect from server returning invalid response. */-    op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;-    op->flags = 0;-    op->reserved = NULL;-    op++;-    grpc_call_error call_error = grpc_call_start_batch_and_execute(-        exec_ctx, lb_client->lb_call, ops, (size_t)(op - ops),-        &lb_client->close_sent);-    GPR_ASSERT(GRPC_CALL_OK == call_error);+    grpc_call_cancel(glb_policy->lb_call, NULL);","Actually, I don't think we want to cancel/close. That'd only result in a retry and reconnection to the same channel, which, by the pick first policy, would likely end up at the same server. I've changed to code to log and ignore. Do you think more drastic measures are necessary? Such as eliminating the server that returned the invalid serverlist and recreating the channel.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85945990,2016-11-01T15:02:21Z,src/core/ext/lb_policy/round_robin/round_robin.c,"@@ -269,7 +269,9 @@ static void rr_destroy(grpc_exec_ctx *exec_ctx, grpc_lb_policy *pol) {   for (size_t i = 0; i < p->num_subchannels; i++) {     subchannel_data *sd = p->subchannels[i];     GRPC_SUBCHANNEL_UNREF(exec_ctx, sd->subchannel, ""round_robin_destroy"");-    sd->user_data_vtable.destroy(sd->user_data);+    if (sd->user_data_vtable != NULL) {","I would check `sd->user_data` instead of `sd->user_data_vtable`.  The vtable is guaranteed to be non-NULL if the user_data is non-NULL (see https://github.com/grpc/grpc/blob/master/src/core/ext/client_channel/lb_policy_factory.c#L75), but what we really care about here is whether the user_data is non-NULL.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8568,85993115,2016-11-01T18:27:50Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -1191,40 +1188,11 @@ static void srv_status_rcvd_cb(grpc_exec_ctx *exec_ctx, void *arg,             (void *)glb_policy->lb_call);   } -  if (glb_policy->lb_call_status == GRPC_STATUS_UNIMPLEMENTED) {-    char *failing_server = grpc_call_get_peer(glb_policy->lb_call);-    char *error_desc;-    gpr_asprintf(&error_desc, ""Invalid LB server '%s'"", failing_server);-    gpr_free(failing_server);-    /* flush pending ops */-    pending_pick *pp;-    while ((pp = glb_policy->pending_picks)) {-      glb_policy->pending_picks = pp->next;-      if (grpc_lb_glb_trace) {-        gpr_log(GPR_INFO, ""Cancelling pending pick: %s"", error_desc);-      }-      grpc_exec_ctx_sched(exec_ctx,-                          &pp->wrapped_on_complete_arg.wrapper_closure,-                          GRPC_ERROR_CREATE(error_desc), NULL);-    }--    pending_ping *pping;-    while ((pping = glb_policy->pending_pings)) {-      glb_policy->pending_pings = pping->next;-      if (grpc_lb_glb_trace) {-        gpr_log(GPR_INFO, ""Cancelling pending ping: %s"", error_desc);-      }-      grpc_exec_ctx_sched(exec_ctx, &pping->wrapped_notify_arg.wrapper_closure,-                          GRPC_ERROR_CREATE(error_desc), NULL);-    }-    gpr_free(error_desc);-  }-   const bool was_cancelled =       (glb_policy->lb_call_status == GRPC_STATUS_CANCELLED);    /* We need to performe cleanups no matter what. */-  lb_client_destroy(glb_policy);+  lb_call_destroy(glb_policy);    if (!glb_policy->shutting_down) {     GPR_ASSERT(!was_cancelled);","Removing the assertion is good, but my broader question here still stands: If the LB server shuts down, shouldn't we go back and pick a new one?  Or will the client continue to try to use the bad server forever?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8588,86046364,2016-11-01T23:22:29Z,src/core/lib/iomgr/tcp_uv.c,"@@ -1,35 +1,35 @@ /*- *- * Copyright 2016, Google Inc.- * All rights reserved.- *- * Redistribution and use in source and binary forms, with or without- * modification, are permitted provided that the following conditions are- * met:- *- *     * Redistributions of source code must retain the above copyright- * notice, this list of conditions and the following disclaimer.- *     * Redistributions in binary form must reproduce the above- * copyright notice, this list of conditions and the following disclaimer- * in the documentation and/or other materials provided with the- * distribution.- *     * Neither the name of Google Inc. nor the names of its- * contributors may be used to endorse or promote products derived from- * this software without specific prior written permission.- *- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS- * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.- *- */+*",this whole block looks like an accidental whitespace/formatting change.,
2811396,ejona86,https://api.github.com/repos/grpc/grpc/pulls/4955,86230484,2016-11-02T20:04:04Z,doc/http-grpc-status-mapping.md,"@@ -0,0 +1,30 @@+# HTTP to gRPC Status Code Mapping++Since intermediaries are a common part of HTTP infrastructure some responses to+gRPC requests may be received that do not include the grpc-status header. In+some cases mapping error codes from an intermediary allows the gRPC client to+behave more appropriately to the error situation without overloading the+semantics of either error code.++This table is to be used _only_ for clients that received a response that did+not include grpc-status. If grpc-status was provided, it _must_ be used. Servers+_must not_ use this table to determine an HTTP status code to use; the mappings+are neither symmetric nor 1-to-1.++| HTTP Status Code           | gRPC Status Code   |+|----------------------------|--------------------|+| 400 Bad Request            | INTERNAL           |+| 401 Unauthorized           | UNAUTHENTICATED    |+| 403 Forbidden              | PERMISSION\_DENIED |+| 404 Not Found              | UNIMPLEMENTED      |+| 429 Too Many Requests      | UNAVAILABLE        |","`UNAVAILABLE` is ""most likely a transient condition, which can be corrected by retrying with a backoff."" Whereas `RESOURCE_EXHAUSTED` commonly requires service-specific handling to resolve, like when out of disk quota (or even rate limiting). So while, yes, `RESOURCE_EXHAUSTED` could maybe also work, client handling here should be identical to `UNAVAILABLE`. It also still follows the `UNAVAILABLE` semantics, especially when considering the litmus test provided in `FAILED_PRECONDITION`.For things like this, I'm happy these mappings aren't set in stone and we can change them. I could completely believe it was a mistake.",
9152787,malexzx,https://api.github.com/repos/grpc/grpc/pulls/8572,86286346,2016-11-03T04:58:17Z,templates/Makefile.template,"@@ -1503,11 +1515,17 @@   ifeq ($(SYSTEM),Darwin)   	$(Q) ${ld} ${ldflags} -L$(LIBDIR)/$(CONFIG) -install_name $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION).$(SHARED_EXT) -dynamiclib -o ${out_libbase}.$(SHARED_EXT) ${common}${libs}   else+  ifeq ($(SYSTEM),HP-UX)+  	$(Q) ${ld} ${ldflags} -L$(LIBDIR)/$(CONFIG) -Wl,-E -Wl,+s -Wl,+b,/usr/local/lib -shared -o ${out_libbase}.$(SHARED_EXT) ${common}${libs}","HPUX ld relevant flags:- -E    Mark all symbols defined by a program for export to shared libraries.- +s    Indicate that at run-time, the dynamic loader can use the      environment variables SHLIB_PATH and LD_LIBRARY_PATH to locate shared libraries.- +b path_list    Specify a colon-separated list of directories to be searched at program run-time to locate shared libraries needed by the executable output file.",
9152787,malexzx,https://api.github.com/repos/grpc/grpc/pulls/8572,86301163,2016-11-03T08:43:01Z,src/core/lib/iomgr/resolve_address.h,"@@ -41,7 +41,7 @@  typedef struct {   char addr[GRPC_MAX_SOCKADDR_SIZE];-  size_t len;+  uint32_t len;","I'm doing change size_t to uint32_t change because it make possible to minimal code change.Without it, pointer arithmetic lost value on big endian.`(int *)&addr.len <-- size_t`Opposite, is correctly handling, if len fits within 4 bytes.`(socklen_t *)&len <- uint32_t`Then trying with size_t, it needs to define temporary variable.Then trying to signed type. It break succesfull comparisions in GPR_ASSERT's.Maybe need to change this to unsined int? I'm think so 4 bytes type is enought for that purpose.test.c```#include <stdio.h>#include <sys/socket.h>void test(int *i, socklen_t *s){  printf(""i=%d s=%d\n"", *i, *s);}int main(int ac, char *av[]){ socklen_t a = 1; unsigned int i = 10; test((int *)&i, (socklen_t*)&i); test((int *)&a, (socklen_t*)&a); return 0;}```BIG_ENDIAN: only two combinations worki=10 s=314336i=0 s=1LITTLE_ENDIAN: portable in any directioni=10 s=10i=1 s=1",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8617,86479915,2016-11-04T02:26:12Z,src/core/lib/transport/service_config.c,"@@ -0,0 +1,217 @@+//+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#include ""src/core/lib/transport/service_config.h""++#include <string.h>++#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/transport/mdstr_hash_table.h""++struct grpc_service_config {","could you document the fields? Or at least rename `string` to something more meaningful (`field_name`, `key`?). Ditto for `json`. What does the json data represent?",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8617,86480434,2016-11-04T02:33:47Z,src/core/lib/transport/service_config.c,"@@ -0,0 +1,217 @@+//+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#include ""src/core/lib/transport/service_config.h""++#include <string.h>++#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/transport/mdstr_hash_table.h""++struct grpc_service_config {+  char* string;+  grpc_json* json;+};++grpc_service_config* grpc_service_config_create(const char* json_string) {+  grpc_service_config* service_config = gpr_malloc(sizeof(*service_config));+  service_config->string = gpr_strdup(json_string);+  service_config->json = grpc_json_parse_string(service_config->string);+  return service_config;+}++void grpc_service_config_destroy(grpc_service_config* service_config) {+  grpc_json_destroy(service_config->json);+  gpr_free(service_config->string);+  gpr_free(service_config);+}++const char* grpc_service_config_get_lb_policy_name(+    const grpc_service_config* service_config) {+  const grpc_json* json = service_config->json;+  if (json->type != GRPC_JSON_OBJECT || json->key != NULL) return NULL;+  const char* lb_policy_name = NULL;+  for (grpc_json* field = json->child; field != NULL; field = field->next) {+    if (field->key == NULL) return NULL;+    if (strcmp(field->key, ""lb_policy_name"") == 0) {+      if (lb_policy_name != NULL) return NULL;  // Duplicate.+      if (field->type != GRPC_JSON_STRING) return NULL;+      lb_policy_name = field->value;+    }+  }+  return lb_policy_name;+}++// Returns the number of names specified in the method config \a json.+static size_t count_names_in_method_config_json(grpc_json* json) {+  size_t num_names = 0;+  for (grpc_json* field = json->child; field != NULL; field = field->next) {+    if (field->key != NULL && strcmp(field->key, ""name"") == 0) ++num_names;+  }+  return num_names;+}++// Returns a path string for the name specified by \a json.+// Returns NULL on error.  Caller takes ownership of result.+static char* parse_json_method_name(grpc_json* json) {+  if (json->type != GRPC_JSON_OBJECT) return NULL;+  const char* service_name = NULL;+  const char* method_name = NULL;+  for (grpc_json* child = json->child; child != NULL; child = child->next) {+    if (child->key == NULL) return NULL;+    if (child->type != GRPC_JSON_STRING) return NULL;+    if (strcmp(child->key, ""service"") == 0) {+      if (service_name != NULL) return NULL;  // Duplicate.+      if (child->value == NULL) return NULL;+      service_name = child->value;+    } else if (strcmp(child->key, ""method"") == 0) {+      if (method_name != NULL) return NULL;  // Duplicate.+      if (child->value == NULL) return NULL;+      method_name = child->value;+    }+  }+  if (service_name == NULL) return NULL;  // Required field.+  char* path;+  gpr_asprintf(&path, ""/%s/%s"", service_name,+               method_name == NULL ? ""*"" : method_name);+  return path;+}++// Parses the method config from \a json.  Adds an entry to \a entries for+// each name found, incrementing \a idx for each entry added.","The semantics of the return value are not specified, and the name of the bool variable returned doesn't help either.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8632,86482517,2016-11-04T03:00:07Z,src/ruby/spec/generic/rpc_server_pool_spec.rb,"@@ -114,17 +130,17 @@    describe '#start' do     it 'runs pre-scheduled jobs' do","But this test is no longer about pre-scheduled jobs, correct? In fact, the concept is now meaningless (and maybe always was). How about just dropping this test or changing it to something else",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8623,86552792,2016-11-04T14:12:36Z,src/compiler/cpp_generator.cc,"@@ -84,8 +84,8 @@ void PrintIncludes(Printer *printer, const std::vector<grpc::string> &headers,     }   } -  for (auto i = headers.begin(); i != headers.end(); i++) {-    vars[""h""] = *i;+  for (auto i : headers) {","Suggest using `const auto&` here, to avoid an unnecessary copy.  Same thing in all range-based for loops.Also suggest renaming this variable from `i` to `header`, since it's no longer an iterator.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8618,86567624,2016-11-04T15:20:41Z,include/grpc/grpc.h,"@@ -237,6 +237,10 @@ GRPCAPI struct census_context *grpc_census_call_get_context(grpc_call *call);     created for. */ GRPCAPI char *grpc_channel_get_target(grpc_channel *channel); +/** Request info about the channel. */","Done.I've also changed the parameter to be const, to make it clear that it's not modified by the call.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8617,86577055,2016-11-04T16:01:57Z,src/core/lib/transport/service_config.c,"@@ -0,0 +1,217 @@+//+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+//++#include ""src/core/lib/transport/service_config.h""++#include <string.h>++#include <grpc/impl/codegen/grpc_types.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/string_util.h>++#include ""src/core/lib/json/json.h""+#include ""src/core/lib/support/string.h""+#include ""src/core/lib/transport/mdstr_hash_table.h""++struct grpc_service_config {+  char* string;+  grpc_json* json;+};++grpc_service_config* grpc_service_config_create(const char* json_string) {","Yes, we could do that.  However, that would require exposing the definition of `grpc_service_config`, so it would no longer be opaque.  Given that the heap allocation in these cases are not on the fast path, it doesn't seem worth the trade-off.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8461,86750421,2016-11-07T10:45:42Z,tools/run_tests/filter_pull_request_tests.py,"@@ -104,7 +105,7 @@ def add_trigger(self, trigger):   'config\.m4$': [_PHP_TEST_SUITE],   'CONTRIBUTING\.md$': [],   'Gemfile$': [_RUBY_TEST_SUITE],-  'grpc.def$': [_WINDOWS_TEST_SUITE],+  'grpc\.def$': [_WINDOWS_TEST_SUITE],   'grpc\.gemspec$': [_RUBY_TEST_SUITE],","One case that these definitions are missing is when someone manually updates files that are supposed to be autogenerated.  (e.g.  files under /vsprojects).  In that case, sanity tests won't run, yet from my experience people often forget that some files are generated and update them manually - and we want to prevent that from happening.You probably need to add sanity test run for all updates to generated files (which is somewhat tricky, because there is a lot of them and more can be added later - without having a way to enumerate them, we might need to just add _SANITY_TEST_SUITE to all whitelist entries)E.g.`'^vsprojects/': [_WINDOWS_TEST_SUITE, _SANITY_TEST_SUITE],`Actually, I don't understand why sanity takes such long time to run - I think we should be running it as often as possible.",
22083734,matt-kwong,https://api.github.com/repos/grpc/grpc/pulls/8461,86852902,2016-11-07T19:44:52Z,tools/run_tests/filter_pull_request_tests.py,"@@ -104,7 +105,7 @@ def add_trigger(self, trigger):   'config\.m4$': [_PHP_TEST_SUITE],   'CONTRIBUTING\.md$': [],   'Gemfile$': [_RUBY_TEST_SUITE],-  'grpc.def$': [_WINDOWS_TEST_SUITE],+  'grpc\.def$': [_WINDOWS_TEST_SUITE],   'grpc\.gemspec$': [_RUBY_TEST_SUITE],","In that case, would it be best to just remove skipping sanity tests completely to be safe? RIght now, the bottleneck for pull request tests are interop and performance, so we could worry about sanity tests taking too long when the basic tests become the bottleneck.Edit: From looking at the check_copyright.py test in the sanity suite affecting files in almost all directories, I'm more inclined to never skip sanity tests.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/8572,86883951,2016-11-07T22:25:33Z,INSTALL.md,"@@ -107,3 +114,27 @@ This approach requires having [msys2](https://msys2.github.io/) installed.   generate ""projects"" for your compiler. - Build with your compiler of choice. The generated build files should have the   protobuf3 dependency baked in.+++###HP-UX++- Export folowing variables:+```+DEP_FLAGS=” -I/usr/local/include ”+DEP_LDFLAGS=” -L/usr/local/lib ”+CFG_FLAGS=” -mlp64 -gdwarf-2 -D_INCLUDE_STDC__SOURCE_199901 -D_REENTRANT -D_INCLUDE_XOPEN_SOURCE_EXTENDED \+          -D_INCLUDE_HPUX_SOURCE \+          -D_INCLUDE_XOPEN_SOURCE_520 \","This is not what I meant by my previous comments. If a flag is required in general for compiling on HP-UX, it belongs in the Makefile. Any other defines (the `-D` flags) almost definitely belong in the HP-UX branch of port_platform.h.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/8572,86884252,2016-11-07T22:26:56Z,INSTALL.md,"@@ -107,3 +114,27 @@ This approach requires having [msys2](https://msys2.github.io/) installed.   generate ""projects"" for your compiler. - Build with your compiler of choice. The generated build files should have the   protobuf3 dependency baked in.+++###HP-UX++- Export folowing variables:+```+DEP_FLAGS=” -I/usr/local/include ”+DEP_LDFLAGS=” -L/usr/local/lib ”","Are these flags really needed in general for compiling gRPC on HP-UX? If so, they belong in the Makefile. If not, they don't belong at all.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/8572,86884585,2016-11-07T22:29:00Z,include/grpc/support/endian.h,"@@ -0,0 +1,62 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_SUPPORT_ENDIAN_H+#define GRPC_SUPPORT_ENDIAN_H++#include <grpc/support/port_platform.h>++/* Only for HPUX now */+#ifdef GPR_HPUX+#define GPR_BIG_ENDIAN+#else",Defining `GPR_BIG_ENDIAN` vs `GPR_LITTLE_ENDIAN` belongs in port_platform.h,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8461,86953525,2016-11-08T09:41:44Z,tools/run_tests/filter_pull_request_tests.py,"@@ -104,7 +105,7 @@ def add_trigger(self, trigger):   'config\.m4$': [_PHP_TEST_SUITE],   'CONTRIBUTING\.md$': [],   'Gemfile$': [_RUBY_TEST_SUITE],-  'grpc.def$': [_WINDOWS_TEST_SUITE],+  'grpc\.def$': [_WINDOWS_TEST_SUITE],   'grpc\.gemspec$': [_RUBY_TEST_SUITE],","yes, avoiding skipping sanity tests completely makes sense, good idea.I'd argue that seeing the results from basic tests as quickly as possible is still useful regardless of how long interop and performance tests take. But for now, what you are saying makes sense and we can postpone optimizing sanity tests until it starts to bother us.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8700,87307884,2016-11-10T00:27:58Z,src/csharp/Grpc.IntegrationTesting/MetadataCredentialsTest.cs,"@@ -103,6 +103,33 @@ public void MetadataCredentials_PerCall()             client.UnaryCall(new SimpleRequest { }, new CallOptions(credentials: callCredentials));         } +        [Test]+        public void MetadataCredentials_InterceptorLeavesMetadataEmpty()+        {+            var channelCredentials = ChannelCredentials.Create(TestCredentials.CreateSslCredentials(),+                CallCredentials.FromInterceptor(new AsyncAuthInterceptor((context, metadata) => TaskUtils.CompletedTask)));+            channel = new Channel(Host, server.Ports.Single().BoundPort, channelCredentials, options);+            client = new TestService.TestServiceClient(channel);++            var ex = Assert.Throws<RpcException>(() => client.UnaryCall(new SimpleRequest { }));+            Assert.AreEqual(StatusCode.Unknown, ex.Status.StatusCode);","not sure why this is expected to be `StatusCode.Unknown`. I would think `plugin_md_request_metadata_ready` should see there's no metadata, and run the callback with `GRPC_CREDENTIALS_OK`?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8713,87446952,2016-11-10T17:42:46Z,src/csharp/Grpc.Core/Internal/GrpcThreadPool.cs,"@@ -82,7 +85,8 @@ public void Start()                  for (int i = 0; i < poolSize; i++)                 {-                    threads.Add(CreateAndStartThread(i));+                    var optionalProfiler = i < threadProfilers.Count ? threadProfilers[0] : null;","not sure exactly where `threadProfilers` are set, it looks like the list of `threadProfilers` should be empty at this point? And should each thread be getting `threadProfilers[i]`?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8713,87469091,2016-11-10T19:34:56Z,src/csharp/Grpc.Core/Internal/GrpcThreadPool.cs,"@@ -82,7 +85,8 @@ public void Start()                  for (int i = 0; i < poolSize; i++)                 {-                    threads.Add(CreateAndStartThread(i));+                    var optionalProfiler = i < threadProfilers.Count ? threadProfilers[0] : null;","The idea is that if you want to enable profiling, you only need to edit one line of code by adding a profiler to the list of profilers (and usually it's enough to add profiler just for the first thread - other thread yield similar results and processing the dump doesn't take that much time.I am aware this can be considered a bit dirty, but currently it's the easiest way to achieve what I need and when disabled it has no performance/memory impact (and the complexity increase is negligible). Please let me know what your opinion is.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8707,87686554,2016-11-12T04:31:15Z,src/python/grpcio/grpc/_server.py,"@@ -672,41 +677,44 @@ def _serve(state):             return  -def _stop(state, grace):-  with state.lock:-    if state.stage is _ServerStage.STOPPED:-      shutdown_event = threading.Event()-      shutdown_event.set()-      return shutdown_event-    else:-      if state.stage is _ServerStage.STARTED:-        state.server.shutdown(state.completion_queue, _SHUTDOWN_TAG)+def _stop(state, grace, shutdown_handler_grace):+  shutdown_event = threading.Event()++  def cancel_all_calls_after_grace():+    do_shutdown = False","Please favor```if <condition>:  <name> = <expression>else:  <name> = <other expression>```over```<name> = <other expression>if <condition>:  <name> = <expression>```. Here, the general form particularizes to```<*no* assignment of do_shutdown>with state.lock:  if <one condition>:    <statements that return>  elif <another condition>:    <statements that don't return>    do_shutdown = True  else:    do_shutdown = False```.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8699,87965576,2016-11-15T08:15:46Z,tools/run_tests/run_performance_tests.py,"@@ -80,24 +85,34 @@ def kill(self):       self._job = None  -def create_qpsworker_job(language, shortname=None,-                         port=10000, remote_host=None):-  cmdline = language.worker_cmdline() + ['--driver_port=%s' % port]+def create_qpsworker_job(language, shortname=None, port=10000, remote_host=None, perf_cmd=None):+  cmdline = (language.worker_cmdline() + ['--driver_port=%s' % port])+   if remote_host:-    user_at_host = '%s@%s' % (_REMOTE_HOST_USERNAME, remote_host)-    cmdline = ['ssh',-               str(user_at_host),-               'cd ~/performance_workspace/grpc/ && %s' % ' '.join(cmdline)]     host_and_port='%s:%s' % (remote_host, port)   else:     host_and_port='localhost:%s' % port +  perf_data_base_name = None+  if perf_cmd:+    perf_data_base_name = '%s-%s' % (host_and_port, shortname)+    # specify -o output file so perf.data gets collected when worker stopped+    cmdline = perf_cmd + ('-o %s-perf.data' % perf_data_base_name).split(' ') + cmdline","nit:   ['-o', '%s-perf.data' % perf_data_base_name] instead of splitting?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8742,88057297,2016-11-15T16:39:25Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):-  """"""An implementation of arbitrarily many RPC methods.""""""+  """"""An implementation of arbitrarily many RPC methods.+  Attributes:+    service_names (optional):  If specified, it is an iterable of strings",(I wrote this comment two weeks ago but since it reflects my overall feelings I'm sharing it even though it no longer applies to this code.)Never define a type that may-or-may-not have an attribute. Use `None`-or-not-`None`-ness instead. Attribute access on an object known to be of the type that defines the attribute should always be a safe operation; attribute access should only need to be guarded when it is done as a proxy for dynamic type inspection.,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8699,88064265,2016-11-15T17:08:15Z,tools/run_tests/performance/process_local_perf_reports.sh,"@@ -0,0 +1,13 @@+mkdir -p $OUTPUT_DIR++PERF_DATA_FILE=${PERF_BASE_NAME}-perf.data+PERF_SCRIPT_OUTPUT=${PERF_BASE_NAME}-out.perf++# Generate text output from profiles+perf report -i $PERF_DATA_FILE  -v > ${OUTPUT_DIR}/${OUTPUT_FILENAME}.txt++# Generate Flame graphs+echo ""running perf script on $PERF_DATA_FILE""+perf script -i $PERF_DATA_FILE > $PERF_SCRIPT_OUTPUT++~/FlameGraph/stackcollapse-perf.pl --kernel $PERF_SCRIPT_OUTPUT | ~/FlameGraph/flamegraph.pl --color=java --hash > ${OUTPUT_DIR}/${OUTPUT_FILENAME}.svg","The FlamgeGraph is a git repo clone from http://www.brendangregg.com/flamegraphs.html.It doesn't need to be on the workers though necessarily, it actually would just need to be on the driver machine. I was thinking that it could just be added to the driver/master host procedure. Should it be added to the worker script too?",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8699,88073590,2016-11-15T17:52:44Z,tools/run_tests/run_performance_tests.py,"@@ -57,15 +59,18 @@  _REMOTE_HOST_USERNAME = 'jenkins' +_PERF_REPORT_OUTPUT_DIR = 'perf_reports'+  class QpsWorkerJob:   """"""Encapsulates a qps worker server job."""""" -  def __init__(self, spec, language, host_and_port):+  def __init__(self, spec, language, host_and_port, perf_data_base_name=None):","realized this might be confusing, with it being unrelated to a data base, but just referring to the base name of the ""perf.data"" file. Renamed to `perf_file_base_name`, open to change though.",
7704407,a-teammate,https://api.github.com/repos/grpc/grpc/pulls/7813,88110899,2016-11-15T20:55:41Z,CMakeLists.txt,"@@ -46,113 +46,108 @@ set(PACKAGE_VERSION   ""1.1.0-dev"") set(PACKAGE_STRING    ""${PACKAGE_NAME} ${PACKAGE_VERSION}"") set(PACKAGE_TARNAME   ""${PACKAGE_NAME}-${PACKAGE_VERSION}"") set(PACKAGE_BUGREPORT ""https://github.com/grpc/grpc/issues/"")+ project(${PACKAGE_NAME} C CXX) -if (NOT MSVC)-  set(gRPC_INSTALL ON CACHE BOOL ""Generate installation target"")-else()-  set(gRPC_INSTALL OFF CACHE BOOL ""Generate installation target"")-endif() -set(gRPC_ZLIB_PROVIDER ""module"" CACHE STRING ""Provider of zlib library"")-set_property(CACHE gRPC_ZLIB_PROVIDER PROPERTY STRINGS ""module"" ""package"")+function(JOIN VALUES GLUE OUTPUT)+  string (REGEX REPLACE ""([^\\]|^);"" ""\\1${GLUE}"" _TMP_STR ""${VALUES}"")+  string (REGEX REPLACE ""[\\](.)"" ""\\1"" _TMP_STR ""${_TMP_STR}"") #fixes escaping+  set (${OUTPUT} ""${_TMP_STR}"" PARENT_SCOPE)+endfunction() -set(gRPC_SSL_PROVIDER ""module"" CACHE STRING ""Provider of ssl library"")-set_property(CACHE gRPC_SSL_PROVIDER PROPERTY STRINGS ""module"" ""package"") -set(gRPC_PROTOBUF_PROVIDER ""module"" CACHE STRING ""Provider of protobuf library"")-set_property(CACHE gRPC_PROTOBUF_PROVIDER PROPERTY STRINGS ""module"" ""package"")+include(CheckFunctionExists) -set(gRPC_USE_PROTO_LITE OFF CACHE BOOL ""Use the protobuf-lite library"")+CHECK_FUNCTION_EXISTS(pow HAS_POW)+if(NOT HAS_POW)+  list(APPEND CMAKE_REQUIRED_INCLUDES math.h)+  list(APPEND CMAKE_REQUIRED_LIBRARIES m)+  list(APPEND CMAKE_REQUIRED_LIBRARIES m)+  CHECK_FUNCTION_EXISTS(pow HAS_POW_INCLUDED) -if (MSVC)-  add_definitions( -D_WIN32_WINNT=0x600 )+  if(HAS_POW_INCLUDED)+    set(libMath m)+  else()+    message(FATAL_ERROR ""No pow() found"")+  endif() endif() -if (gRPC_USE_PROTO_LITE)-  set(_gRPC_PROTOBUF_LIBRARY_NAME ""libprotobuf-lite"")-  add_definitions(""-DGRPC_USE_PROTO_LITE"")+if (NOT MSVC)+  set(gRPC_INSTALL ON CACHE BOOL ""Generate installation target"") else()-  set(_gRPC_PROTOBUF_LIBRARY_NAME ""libprotobuf"")+  set(gRPC_INSTALL OFF CACHE BOOL ""Generate installation target"") endif() -if(""${gRPC_ZLIB_PROVIDER}"" STREQUAL ""module"")-  if(NOT ZLIB_ROOT_DIR)+if (MSVC)+  add_definitions( -D_WIN32_WINNT=0x600 )+endif()++find_package(ZLIB)+if (NOT ZLIB_FOUND)+  if (NOT ZLIB_ROOT_DIR)     set(ZLIB_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party/zlib)   endif()-  set(ZLIB_INCLUDE_DIR ""${ZLIB_ROOT_DIR}"")-  if(EXISTS ""${ZLIB_ROOT_DIR}/CMakeLists.txt"")-      add_subdirectory(${ZLIB_ROOT_DIR} third_party/zlib)-      if(TARGET zlibstatic)-          set(_gRPC_ZLIB_LIBRARIES zlibstatic)-      endif()+  set(ZLIB_INCLUDE_DIRS ""${ZLIB_ROOT_DIR}"")++  if (EXISTS ""${ZLIB_ROOT_DIR}/CMakeLists.txt"")+    add_subdirectory(${ZLIB_ROOT_DIR} third_party/zlib)++    if (TARGET zlibstatic)+      set(ZLIB_LIBRARIES zlibstatic)+    endif()   else()-      message(WARNING ""gRPC_ZLIB_PROVIDER is \""module\"" but ZLIB_ROOT_DIR is wrong"")+    message(FATAL ""Zlib not found"")   endif()-elseif(""${gRPC_ZLIB_PROVIDER}"" STREQUAL ""package"")-  find_package(ZLIB)-  if(TARGET ZLIB::ZLIB)-    set(_gRPC_ZLIB_LIBRARIES ZLIB::ZLIB)+endif()++find_package(OpenSSL)+if (NOT OPENSSL_FOUND)+  if (NOT BORINGSSL_ROOT_DIR)+      set(BORINGSSL_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party/boringssl)+  endif()+  set(OPENSSL_INCLUDE_DIR ""${BORINGSSL_ROOT_DIR}"")++  if (EXISTS ""${BORINGSSL_ROOT_DIR}/CMakeLists.txt"")+    add_subdirectory(${BORINGSSL_ROOT_DIR} third_party/boringssl)++    if (TARGET ssl)+      set(OPENSSL_LIBRARIES ssl)+    endif()+  else()+    message(FATAL ""OpenSSL or BoringSSL not found"")   endif()-  set(_gRPC_FIND_ZLIB ""if(NOT ZLIB_FOUND)\n  find_package(ZLIB)\nendif()"") endif() -if(""${gRPC_PROTOBUF_PROVIDER}"" STREQUAL ""module"")-  # Building the protobuf tests require gmock what is not part of a standard protobuf checkout.-  # Disable them unless they are explicitly requested from the cmake command line (when we assume-  # gmock is downloaded to the right location inside protobuf).-  if(NOT protobuf_BUILD_TESTS)-    set(protobuf_BUILD_TESTS OFF CACHE BOOL ""Build protobuf tests"")+find_package(Protobuf)+if (NOT Protobuf_FOUND)+  if (NOT Protobuf_BUILD_TESTS)+    set(Protobuf_BUILD_TESTS OFF CACHE BOOL ""Build protobuf tests"")   endif()-  if(NOT PROTOBUF_ROOT_DIR)++  if (NOT PROTOBUF_ROOT_DIR)     set(PROTOBUF_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party/protobuf)   endif()-  if(EXISTS ""${PROTOBUF_ROOT_DIR}/cmake/CMakeLists.txt"")+  set(Protobuf_INCLUDE_DIRS ""${PROTOBUF_ROOT_DIR}"")++  if (EXISTS ""${PROTOBUF_ROOT_DIR}/cmake/CMakeLists.txt"")     set(protobuf_MSVC_STATIC_RUNTIME OFF CACHE BOOL ""Link static runtime libraries"")     add_subdirectory(${PROTOBUF_ROOT_DIR}/cmake third_party/protobuf)-    if(TARGET ${_gRPC_PROTOBUF_LIBRARY_NAME})-      set(_gRPC_PROTOBUF_LIBRARIES ${_gRPC_PROTOBUF_LIBRARY_NAME})-    endif()-    if(TARGET libprotoc)-      set(_gRPC_PROTOBUF_PROTOC_LIBRARIES libprotoc)-    endif()-  else()-      message(WARNING ""gRPC_PROTOBUF_PROVIDER is \""module\"" but PROTOBUF_ROOT_DIR is wrong"")-  endif()-elseif(""${gRPC_PROTOBUF_PROVIDER}"" STREQUAL ""package"")-  find_package(protobuf CONFIG)-  if(protobuf_FOUND)-    if(TARGET protobuf::${_gRPC_PROTOBUF_LIBRARY_NAME})-      set(_gRPC_PROTOBUF_LIBRARIES protobuf::${_gRPC_PROTOBUF_LIBRARY_NAME})++    if (TARGET libprotobuf)+      set(Protobuf_LIBRARIES libprotobuf)     endif()-    if(TARGET protobuf::libprotoc)-      set(_gRPC_PROTOBUF_PROTOC_LIBRARIES protobuf::libprotoc)++    if (TARGET libprotobuf-lite)+      set(Protobuf_LITE_LIBRARIES libprotobuf-lite)     endif()-    set(_gRPC_FIND_PROTOBUF ""if(NOT protobuf_FOUND)\n  find_package(protobuf CONFIG)\nendif()"")-  else()-    find_package(Protobuf MODULE)-    set(_gRPC_FIND_PROTOBUF ""if(NOT Protobuf_FOUND)\n  find_package(Protobuf)\nendif()"")-  endif()-endif() -if(""${gRPC_SSL_PROVIDER}"" STREQUAL ""module"")-  if(NOT BORINGSSL_ROOT_DIR)-    set(BORINGSSL_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/third_party/boringssl)-  endif()-  if(EXISTS ""${BORINGSSL_ROOT_DIR}/CMakeLists.txt"")-    add_subdirectory(${BORINGSSL_ROOT_DIR} third_party/boringssl)-    if(TARGET ssl)-      set(_gRPC_SSL_LIBRARIES ssl)+    if (TARGET libprotoc)","please use always the namespaced name you get when using find_package(Protobuf) (and friends):what you do currently is hardcoding the library names of the dependency, this should be avoided (otherwise you couldn't change the dependencies library names without changing grpcs cmake files as well).instead use find_package + ""protobuf::libprotoc"" like it has been before.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8768,88444356,2016-11-17T12:45:17Z,tools/jenkins/run_full_performance.sh,"@@ -52,4 +52,12 @@ tools/run_tests/run_performance_tests.py \     --remote_worker_host grpc-performance-server-32core grpc-performance-client-32core grpc-performance-client2-32core \     || EXIT_CODE=1 +# selected scenarios on Windows","Currently making it run as a part of a different job is problematic because when the data is stored to bigquery, the name of the jenkins job is stored as one of the fields.Our dashboard then includes jobName as part of the queries that are used to render the charts.Example:```SELECT    ...FROM    [grpc-testing:performance_test.performance_experiment]WHERE    metadata.created >= DATE_ADD(CURRENT_TIMESTAMP(), -1, ""WEEK"") AND    metadata.jobName = ""gRPC_performance_experiment"" AND   ...```",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8768,88444596,2016-11-17T12:47:15Z,tools/jenkins/run_full_performance.sh,"@@ -52,4 +52,12 @@ tools/run_tests/run_performance_tests.py \     --remote_worker_host grpc-performance-server-32core grpc-performance-client-32core grpc-performance-client2-32core \     || EXIT_CODE=1 +# selected scenarios on Windows","I think it should be safe to run windows benchmarks as part of the main benchmarking job. (it's the list item to run, so if it fails, previous measurement will be uploaded anyway)",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8699,88446869,2016-11-17T13:02:52Z,tools/run_tests/run_performance_tests.py,"@@ -471,11 +540,26 @@ def finish_qps_workers(jobs):     finally:       # Consider qps workers that need to be killed as failures       qps_workers_killed += finish_qps_workers(scenario.workers)+      if perf_cmd and scenario_failures == 0:",why do this in the finally block? 1. you are generating the flamegraph only if there were no scenario failures anyway.2. throwing in the finally block is not a good practice in general (in case there was and exception in the try block it eats it a throws a different one instead of it)just run your code in the try block or after the entire try-finally.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8699,88447298,2016-11-17T13:05:30Z,tools/run_tests/run_performance_tests.py,"@@ -433,7 +493,13 @@ def finish_qps_workers(jobs): if not args.dry_run:   build_on_remote_hosts(remote_hosts, languages=[str(l) for l in languages], build_local=build_local) -qpsworker_jobs = create_qpsworkers(languages, args.remote_worker_host)+perf_cmd = None+if args.perf_args:+  # Expect /usr/bin/perf to be installed here, as is usual+  perf_cmd = ['/usr/bin/perf'] +  perf_cmd.extend(args.perf_args.split(' '))","if I put two spaces in the perf_args, will that result in and empty items in the list after splitting?  this is a bit errorprone",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8789,88692196,2016-11-18T16:43:08Z,src/core/ext/client_channel/resolver.h,"@@ -36,13 +36,15 @@  #include ""src/core/ext/client_channel/subchannel.h"" #include ""src/core/lib/iomgr/iomgr.h""+#include ""src/core/lib/iomgr/pollset_set.h""  typedef struct grpc_resolver grpc_resolver; typedef struct grpc_resolver_vtable grpc_resolver_vtable;  /** \a grpc_resolver provides \a grpc_channel_args objects to its caller */ struct grpc_resolver {   const grpc_resolver_vtable *vtable;+  grpc_pollset_set *pollset_set;","Adding this as a member of the `grpc_resolver` struct seems a bit sub-optimal, since not all resolvers will need it.  Instead, how about adding it to the `grpc_resolver_args` struct (in resolver_factory.h) and as a parameter to `grpc_resolver_create()`, and then having the resolver factory's `create_resolver()` method populate it as needed in the resolver implementation's struct?  (This would require merging #8795, which I just sent you.)",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8787,88713760,2016-11-18T18:40:34Z,src/core/ext/lb_policy/grpclb/grpclb.c,"@@ -610,28 +708,35 @@ static void rr_handover_locked(grpc_exec_ctx *exec_ctx,  static void glb_rr_connectivity_changed(grpc_exec_ctx *exec_ctx, void *arg,                                         grpc_error *error) {-  /* If shutdown or error free the arg. Rely on the rest of the code to set the-   * right grpclb status. */-  rr_connectivity_data *rr_conn_data = arg;-  glb_lb_policy *glb_policy = rr_conn_data->glb_policy;-  gpr_mu_lock(&glb_policy->mu);+  rr_connectivity_data *rr_connectivity = arg;+  glb_lb_policy *glb_policy = rr_connectivity->glb_policy; -  if (rr_conn_data->state != GRPC_CHANNEL_SHUTDOWN &&-      !glb_policy->shutting_down) {-    /* RR not shutting down. Mimic the RR's policy state */-    grpc_connectivity_state_set(exec_ctx, &glb_policy->state_tracker,-                                rr_conn_data->state, GRPC_ERROR_REF(error),-                                ""rr_connectivity_cb"");-    /* resubscribe. Reuse the ""rr_connectivity_cb"" weak ref. */+  gpr_mu_lock(&glb_policy->mu);+  const bool shutting_down = glb_policy->shutting_down;+  grpc_lb_policy *maybe_unref = NULL;+  GRPC_ERROR_REF(error);","This follows the pattern of similar functions such as `pf_connectivity_changed` (https://github.com/grpc/grpc/blob/master/src/core/ext/lb_policy/pick_first/pick_first.c#L259), whereby a ref is kept for the duration of the function/callback. This is due to the ownership rules in iomgr/error.h, which don't guarantee that a callback owns the error instance it receives. The ref is taken to ensure the `error` doesn't disappear mid-function.",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/8789,88747008,2016-11-18T21:54:30Z,src/core/ext/client_channel/resolver.h,"@@ -36,13 +36,15 @@  #include ""src/core/ext/client_channel/subchannel.h"" #include ""src/core/lib/iomgr/iomgr.h""+#include ""src/core/lib/iomgr/pollset_set.h""  typedef struct grpc_resolver grpc_resolver; typedef struct grpc_resolver_vtable grpc_resolver_vtable;  /** \a grpc_resolver provides \a grpc_channel_args objects to its caller */ struct grpc_resolver {   const grpc_resolver_vtable *vtable;+  grpc_pollset_set *pollset_set;","#8795 looks awesome! That makes it possible to add `grpc_pollset_set` as a parameter to `grpc_resolver_create()`, as the resolver will only be instantiated inside client_channel.c.Will wait for #8795 to be merged.",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8834,89235702,2016-11-22T23:50:54Z,src/boringssl/gen_build_yaml.py,"@@ -164,5 +164,10 @@ def WriteFiles(self, files, asm_outputs):    print yaml.dump(g.yaml) +except OSError as err:+  type, value, traceback = sys.exc_info()+  raise RuntimeError, (","Instead of creating a new exception, you could recycle the original one after attaching your message. For example:```except OSError as err:  if not err.args:      err.args=('',)  err.args = err.args + 'Y U NO GO IN PATH'   raise````raise` on its own will re-throw the caught exception.",
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/8834,89244150,2016-11-23T01:18:51Z,src/boringssl/gen_build_yaml.py,"@@ -164,5 +164,10 @@ def WriteFiles(self, files, asm_outputs):    print yaml.dump(g.yaml) +except OSError as err:+  type, value, traceback = sys.exc_info()+  raise RuntimeError, (","The only problem with that is that when the exception crashes the program, it only prints `OSError: [Errno 2] No such file or directory`The other solution I was thinking of was to add the more verbose error message by calling sys.stderr.write with a custom message, then letting the original exception continue.",
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8866,89837840,2016-11-28T17:46:16Z,test/core/end2end/tests/filter_latency.c,"@@ -226,25 +226,30 @@ static void test_request(grpc_end2end_test_config config) {   grpc_call_destroy(s);   grpc_call_destroy(c); -  const gpr_timespec end_time = gpr_now(GPR_CLOCK_MONOTONIC);-  const gpr_timespec max_latency = gpr_time_sub(end_time, start_time);--  gpr_mu_lock(&g_mu);-  GPR_ASSERT(gpr_time_cmp(max_latency, g_client_latency) >= 0);-  GPR_ASSERT(gpr_time_cmp(gpr_time_0(GPR_TIMESPAN), g_client_latency) < 0);-  GPR_ASSERT(gpr_time_cmp(max_latency, g_server_latency) >= 0);-  GPR_ASSERT(gpr_time_cmp(gpr_time_0(GPR_TIMESPAN), g_server_latency) < 0);-  // Server latency should always be smaller than client latency.-  GPR_ASSERT(gpr_time_cmp(g_server_latency, g_client_latency) < 0);-  gpr_mu_unlock(&g_mu);-   cq_verifier_destroy(cqv);    grpc_byte_buffer_destroy(request_payload);   grpc_byte_buffer_destroy(request_payload_recv);    end_test(&f);   config.tear_down_data(&f);++  const gpr_timespec end_time = gpr_now(GPR_CLOCK_MONOTONIC);+  const gpr_timespec max_latency = gpr_time_sub(end_time, start_time);++  // Perform checks after test tear-down+  // Guards against the case that there's outstanding channel-related work on a+  // call prior to verification+  gpr_mu_lock(&g_mu);+  GPR_ASSERT(gpr_time_cmp(max_latency, g_client_latency) >= 0);+  GPR_ASSERT(gpr_time_cmp(gpr_time_0(GPR_TIMESPAN), g_client_latency) <= 0);+  GPR_ASSERT(gpr_time_cmp(max_latency, g_server_latency) >= 0);+  GPR_ASSERT(gpr_time_cmp(gpr_time_0(GPR_TIMESPAN), g_server_latency) <= 0);+  // Server latency should always be smaller than client latency, however since+  // we only calculate latency at destruction time, and that might mean that we+  // need to wait for an outstanding write, this isn't verifiable right now.","Yeah I might have been too exact here: honestly I'm not sure of the root cause, but it's certainly true that the server *can* hold onto the call for longer than it takes to respond to the client.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8857,89863658,2016-11-28T19:35:03Z,src/csharp/Grpc.Reflection/ReflectionServiceImpl.cs,"@@ -0,0 +1,174 @@+﻿#region Copyright notice and license+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#endregion++using System;+using System.Collections.Generic;+using System.Linq;+using System.Text;+using System.Threading.Tasks;++using Grpc.Core;+using Grpc.Core.Utils;+using Grpc.Reflection.V1Alpha;+using Google.Protobuf.Reflection;++namespace Grpc.Reflection+{+    /// <summary>+    /// Implementation of server reflection service.+    /// </summary>+    public class ReflectionServiceImpl : Grpc.Reflection.V1Alpha.ServerReflection.ServerReflectionBase+    {+        readonly List<string> services;+        readonly SymbolRegistry symbolRegistry;++        /// <summary>+        /// Creates a new instance of <c>ReflectionServiceIml</c>.+        /// </summary>+        public ReflectionServiceImpl(IEnumerable<string> services, SymbolRegistry symbolRegistry)+        {+            this.services = new List<string>(services);+            this.symbolRegistry = symbolRegistry;+        }++        /// <summary>+        /// Creates a new instance of <c>ReflectionServiceIml</c>.+        /// </summary>+        public ReflectionServiceImpl(IEnumerable<ServiceDescriptor> serviceDescriptors)+        {+            this.services = new List<string>(serviceDescriptors.Select((serviceDescriptor) => serviceDescriptor.FullName));+            this.symbolRegistry = SymbolRegistry.FromFiles(serviceDescriptors.Select((serviceDescriptor) => serviceDescriptor.File));+        }++        /// <summary>+        /// Creates a new instance of <c>ReflectionServiceIml</c>.+        /// </summary>+        public ReflectionServiceImpl(params ServiceDescriptor[] serviceDescriptors) : this((IEnumerable<ServiceDescriptor>) serviceDescriptors)+        {+        }++        public override async Task ServerReflectionInfo(IAsyncStreamReader<ServerReflectionRequest> requestStream, IServerStreamWriter<ServerReflectionResponse> responseStream, ServerCallContext context)+        {+            while (await requestStream.MoveNext())+            {+                var response = ProcessRequest(requestStream.Current);+                await responseStream.WriteAsync(response);+            }+        }++        ServerReflectionResponse ProcessRequest(ServerReflectionRequest request)+        {+            switch (request.MessageRequestCase)+            {+                case ServerReflectionRequest.MessageRequestOneofCase.FileByFilename:+                    return FileByFilename(request.FileByFilename);+                case ServerReflectionRequest.MessageRequestOneofCase.FileContainingSymbol:+                    return FileContainingSymbol(request.FileContainingSymbol);+                case ServerReflectionRequest.MessageRequestOneofCase.ListServices:+                    return ListServices();+                case ServerReflectionRequest.MessageRequestOneofCase.AllExtensionNumbersOfType:+                case ServerReflectionRequest.MessageRequestOneofCase.FileContainingExtension:+                default:+                    return CreateErrorResponse(StatusCode.Unimplemented, ""Request type not supported by C# reflection service."");+            }+        }++        ServerReflectionResponse FileByFilename(string filename)+        {+            FileDescriptor file = symbolRegistry.FileByName(filename);+            if (file == null)+            {+                // TODO(jtattermusch): what is the right response when file is not found?+                return CreateErrorResponse(StatusCode.NotFound, ""File descriptor not found."");+            }++            var transitiveDependencies = new HashSet<FileDescriptor>();+            CollectTransitiveDependencies(file, transitiveDependencies);++            return new ServerReflectionResponse+            {+                FileDescriptorResponse = new FileDescriptorResponse { FileDescriptorProto = { transitiveDependencies.Select((d) => d.SerializedData) } }+            };+        }++        ServerReflectionResponse FileContainingSymbol(string symbol)+        {+            FileDescriptor file = symbolRegistry.FileContainingSymbol(symbol);+            if (file == null)+            {+                // TODO(jtattermusch): what is the right response when symbol is not found?+                return CreateErrorResponse(StatusCode.NotFound, ""Symbol not found."");+            }++            var transitiveDependencies = new HashSet<FileDescriptor>();+            CollectTransitiveDependencies(file, transitiveDependencies);++            return new ServerReflectionResponse+            {+                FileDescriptorResponse = new FileDescriptorResponse { FileDescriptorProto = { transitiveDependencies.Select((d) => d.SerializedData) } }+            };+        }++        ServerReflectionResponse ListServices()+        {+            var serviceResponses = new ListServiceResponse();+            foreach (string serviceName in services)+            {+                serviceResponses.Service.Add(new ServiceResponse { Name = serviceName });+            }++            return new ServerReflectionResponse+            {+                ListServicesResponse = serviceResponses+            };+        }++        ServerReflectionResponse CreateErrorResponse(StatusCode status, string message)+        {+            return new ServerReflectionResponse+            {+                ErrorResponse = new ErrorResponse { ErrorCode = (int) status, ErrorMessage = message }+            };+        }++        void CollectTransitiveDependencies(FileDescriptor descriptor, HashSet<FileDescriptor> pool)",there can't be any circular dependencies here right? Maybe we could have a comment or assert for it?,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8790,89866116,2016-11-28T19:43:12Z,src/objective-c/GRPCClient/private/GRPCWrappedCall.m,"@@ -112,7 +112,7 @@ - (instancetype)initWithMessage:(NSData *)message handler:(void (^)())handler { }  - (void)dealloc {-  gpr_free(_op.data.send_message);+  grpc_slice_buffer_destroy(_op.data.send_message);","`_op.data.send_message` needs to be a `grpc_byte_buffer`. Looking at [its definition](https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/grpc_types.h#L55), the slice buffer is encapsulated within it. So I assume [`grpc_byte_buffer_destroy`](https://github.com/grpc/grpc/blob/master/include/grpc/byte_buffer.h#L70) will take care of it, and is the right choice here.",
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/8819,89891273,2016-11-28T21:43:21Z,test/cpp/interop/stress_test.cc,"@@ -340,12 +293,7 @@ int main(int argc, char** argv) {          channel_idx++) {       gpr_log(GPR_INFO, ""Starting test with %s channel_idx=%d.."", it->c_str(),               channel_idx);-      std::shared_ptr<grpc::Channel> channel;-      if (FLAGS_use_tls) {-        channel = grpc::testing::CreateChannelForTestCase(FLAGS_test_case);-      } else {-        channel = grpc::CreateChannel(*it, grpc::InsecureChannelCredentials());-      }+      std::shared_ptr<grpc::Channel> channel = grpc::CreateTestChannel(*it, FLAGS_server_host_override, FLAGS_use_tls, !FLAGS_use_test_ca);",I think this line is too long,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/8857,89893146,2016-11-28T21:52:43Z,src/csharp/Grpc.Reflection/ReflectionServiceImpl.cs,"@@ -0,0 +1,174 @@+﻿#region Copyright notice and license+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#endregion++using System;+using System.Collections.Generic;+using System.Linq;+using System.Text;+using System.Threading.Tasks;++using Grpc.Core;+using Grpc.Core.Utils;+using Grpc.Reflection.V1Alpha;+using Google.Protobuf.Reflection;++namespace Grpc.Reflection+{+    /// <summary>+    /// Implementation of server reflection service.+    /// </summary>+    public class ReflectionServiceImpl : Grpc.Reflection.V1Alpha.ServerReflection.ServerReflectionBase+    {+        readonly List<string> services;+        readonly SymbolRegistry symbolRegistry;++        /// <summary>+        /// Creates a new instance of <c>ReflectionServiceIml</c>.+        /// </summary>+        public ReflectionServiceImpl(IEnumerable<string> services, SymbolRegistry symbolRegistry)+        {+            this.services = new List<string>(services);+            this.symbolRegistry = symbolRegistry;+        }++        /// <summary>+        /// Creates a new instance of <c>ReflectionServiceIml</c>.+        /// </summary>+        public ReflectionServiceImpl(IEnumerable<ServiceDescriptor> serviceDescriptors)+        {+            this.services = new List<string>(serviceDescriptors.Select((serviceDescriptor) => serviceDescriptor.FullName));+            this.symbolRegistry = SymbolRegistry.FromFiles(serviceDescriptors.Select((serviceDescriptor) => serviceDescriptor.File));+        }++        /// <summary>+        /// Creates a new instance of <c>ReflectionServiceIml</c>.+        /// </summary>+        public ReflectionServiceImpl(params ServiceDescriptor[] serviceDescriptors) : this((IEnumerable<ServiceDescriptor>) serviceDescriptors)+        {+        }++        public override async Task ServerReflectionInfo(IAsyncStreamReader<ServerReflectionRequest> requestStream, IServerStreamWriter<ServerReflectionResponse> responseStream, ServerCallContext context)+        {+            while (await requestStream.MoveNext())+            {+                var response = ProcessRequest(requestStream.Current);+                await responseStream.WriteAsync(response);+            }+        }++        ServerReflectionResponse ProcessRequest(ServerReflectionRequest request)+        {+            switch (request.MessageRequestCase)+            {+                case ServerReflectionRequest.MessageRequestOneofCase.FileByFilename:+                    return FileByFilename(request.FileByFilename);+                case ServerReflectionRequest.MessageRequestOneofCase.FileContainingSymbol:+                    return FileContainingSymbol(request.FileContainingSymbol);+                case ServerReflectionRequest.MessageRequestOneofCase.ListServices:+                    return ListServices();+                case ServerReflectionRequest.MessageRequestOneofCase.AllExtensionNumbersOfType:+                case ServerReflectionRequest.MessageRequestOneofCase.FileContainingExtension:+                default:+                    return CreateErrorResponse(StatusCode.Unimplemented, ""Request type not supported by C# reflection service."");+            }+        }++        ServerReflectionResponse FileByFilename(string filename)+        {+            FileDescriptor file = symbolRegistry.FileByName(filename);+            if (file == null)+            {+                // TODO(jtattermusch): what is the right response when file is not found?+                return CreateErrorResponse(StatusCode.NotFound, ""File descriptor not found."");+            }++            var transitiveDependencies = new HashSet<FileDescriptor>();+            CollectTransitiveDependencies(file, transitiveDependencies);++            return new ServerReflectionResponse+            {+                FileDescriptorResponse = new FileDescriptorResponse { FileDescriptorProto = { transitiveDependencies.Select((d) => d.SerializedData) } }+            };+        }++        ServerReflectionResponse FileContainingSymbol(string symbol)+        {+            FileDescriptor file = symbolRegistry.FileContainingSymbol(symbol);+            if (file == null)+            {+                // TODO(jtattermusch): what is the right response when symbol is not found?+                return CreateErrorResponse(StatusCode.NotFound, ""Symbol not found."");+            }++            var transitiveDependencies = new HashSet<FileDescriptor>();+            CollectTransitiveDependencies(file, transitiveDependencies);++            return new ServerReflectionResponse+            {+                FileDescriptorResponse = new FileDescriptorResponse { FileDescriptorProto = { transitiveDependencies.Select((d) => d.SerializedData) } }+            };+        }++        ServerReflectionResponse ListServices()+        {+            var serviceResponses = new ListServiceResponse();+            foreach (string serviceName in services)+            {+                serviceResponses.Service.Add(new ServiceResponse { Name = serviceName });+            }++            return new ServerReflectionResponse+            {+                ListServicesResponse = serviceResponses+            };+        }++        ServerReflectionResponse CreateErrorResponse(StatusCode status, string message)+        {+            return new ServerReflectionResponse+            {+                ErrorResponse = new ErrorResponse { ErrorCode = (int) status, ErrorMessage = message }+            };+        }++        void CollectTransitiveDependencies(FileDescriptor descriptor, HashSet<FileDescriptor> pool)","Relies on proto FileDescriptor dependencies not allowed to be circular? Probably is well known, but maybe comment/assert for it?",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8857,90070178,2016-11-29T18:15:17Z,src/csharp/Grpc.Reflection.Tests/SymbolRegistryTest.cs,"@@ -0,0 +1,63 @@+﻿#region Copyright notice and license+// Copyright 2015, Google Inc.+// All rights reserved.+//+// Redistribution and use in source and binary forms, with or without+// modification, are permitted provided that the following conditions are+// met:+//+//     * Redistributions of source code must retain the above copyright+// notice, this list of conditions and the following disclaimer.+//     * Redistributions in binary form must reproduce the above+// copyright notice, this list of conditions and the following disclaimer+// in the documentation and/or other materials provided with the+// distribution.+//     * Neither the name of Google Inc. nor the names of its+// contributors may be used to endorse or promote products derived from+// this software without specific prior written permission.+//+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+// ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#endregion++using Grpc.Reflection;+using Grpc.Reflection.V1Alpha;+using NUnit.Framework;+++namespace Grpc.Reflection.Tests+{+    /// <summary>+    /// Tests for ReflectionServiceImpl+    /// </summary>+    public class SymbolRegistryTest+    {+        SymbolRegistry registry = SymbolRegistry.FromFiles(new[] { ReflectionReflection.Descriptor, Google.Protobuf.WellKnownTypes.Duration.Descriptor.File });++        [Test]+        public void FileByName()+        {+            Assert.AreSame(Google.Protobuf.WellKnownTypes.Duration.Descriptor.File, registry.FileByName(""google/protobuf/duration.proto""));+            Assert.IsNull(registry.FileByName(""somepackage/nonexistent.proto""));+        }++        [Test]+        public void FileContainingSymbol()+        {+            Assert.AreSame(Google.Protobuf.WellKnownTypes.Duration.Descriptor.File, registry.FileContainingSymbol(""google.protobuf.Duration""));",Yes. Explanation: FooReflection is a class generated for every .proto file (and provides access to the file desriptor).Alternative way is to access the message descriptor for a message type (Duration.Descriptor is a message descriptor) and lookup the file descriptor that contains is (the `.File` part),
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/8782,90127528,2016-11-29T22:17:59Z,src/core/ext/client_channel/http_connect_handshaker.c,"@@ -83,65 +94,108 @@ static void http_connect_handshaker_unref(http_connect_handshaker* handshaker) {   } } -// Callback invoked when deadline is exceeded.-static void on_timeout(grpc_exec_ctx* exec_ctx, void* arg, grpc_error* error) {-  http_connect_handshaker* handshaker = arg;-  if (error == GRPC_ERROR_NONE) {  // Timer fired, rather than being cancelled.-    grpc_endpoint_shutdown(exec_ctx, handshaker->endpoint);-  }-  http_connect_handshaker_unref(handshaker);+// Set args fields to NULL, saving the endpoint and read buffer for+// later destruction.+static void cleanup_args_for_failure_locked(+    http_connect_handshaker* handshaker) {+  handshaker->endpoint_to_destroy = handshaker->args->endpoint;+  handshaker->args->endpoint = NULL;+  handshaker->read_buffer_to_destroy = handshaker->args->read_buffer;+  handshaker->args->read_buffer = NULL;+  grpc_channel_args_destroy(handshaker->args->args);+  handshaker->args->args = NULL; }  // Callback invoked when finished writing HTTP CONNECT request. static void on_write_done(grpc_exec_ctx* exec_ctx, void* arg,                           grpc_error* error) {   http_connect_handshaker* handshaker = arg;-  if (error != GRPC_ERROR_NONE) {-    // If the write failed, invoke the callback immediately with the error.-    handshaker->cb(exec_ctx, handshaker->endpoint, handshaker->args,-                   handshaker->read_buffer, handshaker->user_data,-                   GRPC_ERROR_REF(error));+  gpr_mu_lock(&handshaker->mu);+  if (error != GRPC_ERROR_NONE || handshaker->shutdown) {+    // If the write failed or we're shutting down, clean up and invoke the+    // callback with the error.+    if (error == GRPC_ERROR_NONE) {+      // If we were shut down after the write succeeded but before this+      // callback was invoked, we need to generate our own error.+      error = GRPC_ERROR_CREATE(""Handshaker shutdown"");+    } else {+      GRPC_ERROR_REF(error);  // Take ref for the handshake-done callback.+    }+    if (!handshaker->shutdown) {+      // TODO(ctiller): It is currently necessary to shutdown endpoints+      // before destroying them, even if we know that there are no+      // pending read/write callbacks.  This should be fixed, at which+      // point this can be removed.+      grpc_endpoint_shutdown(exec_ctx, handshaker->args->endpoint);+      // Not shutting down, so the write failed.  Clean up before+      // invoking the callback.+      cleanup_args_for_failure_locked(handshaker);+    }+    // Invoke callback.+    grpc_exec_ctx_sched(exec_ctx, handshaker->on_handshake_done, error, NULL);+    gpr_mu_unlock(&handshaker->mu);+    http_connect_handshaker_unref(exec_ctx, handshaker);   } else {     // Otherwise, read the response.-    grpc_endpoint_read(exec_ctx, handshaker->endpoint, handshaker->read_buffer,+    // The read callback inherits our ref to the handshaker.+    grpc_endpoint_read(exec_ctx, handshaker->args->endpoint,",Just making sure here that we are confident that `on_read_done` will not be called synchronously which would result in a deadlock.,
5120183,jcanizales,https://api.github.com/repos/grpc/grpc/pulls/8902,90180184,2016-11-30T07:21:48Z,src/objective-c/tests/Podfile,"@@ -86,7 +86,7 @@ post_install do |installer|     # CocoaPods creates duplicated library targets of gRPC-Core when the test targets include     # non-default subspecs of gRPC-Core. All of these library targets start with prefix 'gRPC-Core.'     # and require the same error suppresion.-    if target.name == 'gRPC-Core' or target.name.start_with?('gRPC-Core.') +    if target.name == 'gRPC-Core' or target.name.start_with?('gRPC-Core.') or target.name.start_with?('gRPC-Core-')",Simplify the whole condition to `target.name.start_with?('gRPC-Core')`?,
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8782,90270860,2016-11-30T16:32:21Z,src/core/ext/client_channel/http_connect_handshaker.c,"@@ -83,65 +94,108 @@ static void http_connect_handshaker_unref(http_connect_handshaker* handshaker) {   } } -// Callback invoked when deadline is exceeded.-static void on_timeout(grpc_exec_ctx* exec_ctx, void* arg, grpc_error* error) {-  http_connect_handshaker* handshaker = arg;-  if (error == GRPC_ERROR_NONE) {  // Timer fired, rather than being cancelled.-    grpc_endpoint_shutdown(exec_ctx, handshaker->endpoint);-  }-  http_connect_handshaker_unref(handshaker);+// Set args fields to NULL, saving the endpoint and read buffer for+// later destruction.+static void cleanup_args_for_failure_locked(+    http_connect_handshaker* handshaker) {+  handshaker->endpoint_to_destroy = handshaker->args->endpoint;+  handshaker->args->endpoint = NULL;+  handshaker->read_buffer_to_destroy = handshaker->args->read_buffer;+  handshaker->args->read_buffer = NULL;+  grpc_channel_args_destroy(handshaker->args->args);+  handshaker->args->args = NULL; }  // Callback invoked when finished writing HTTP CONNECT request. static void on_write_done(grpc_exec_ctx* exec_ctx, void* arg,                           grpc_error* error) {   http_connect_handshaker* handshaker = arg;-  if (error != GRPC_ERROR_NONE) {-    // If the write failed, invoke the callback immediately with the error.-    handshaker->cb(exec_ctx, handshaker->endpoint, handshaker->args,-                   handshaker->read_buffer, handshaker->user_data,-                   GRPC_ERROR_REF(error));+  gpr_mu_lock(&handshaker->mu);+  if (error != GRPC_ERROR_NONE || handshaker->shutdown) {+    // If the write failed or we're shutting down, clean up and invoke the+    // callback with the error.+    if (error == GRPC_ERROR_NONE) {+      // If we were shut down after the write succeeded but before this+      // callback was invoked, we need to generate our own error.+      error = GRPC_ERROR_CREATE(""Handshaker shutdown"");+    } else {+      GRPC_ERROR_REF(error);  // Take ref for the handshake-done callback.+    }+    if (!handshaker->shutdown) {+      // TODO(ctiller): It is currently necessary to shutdown endpoints+      // before destroying them, even if we know that there are no+      // pending read/write callbacks.  This should be fixed, at which+      // point this can be removed.+      grpc_endpoint_shutdown(exec_ctx, handshaker->args->endpoint);+      // Not shutting down, so the write failed.  Clean up before+      // invoking the callback.+      cleanup_args_for_failure_locked(handshaker);+    }+    // Invoke callback.+    grpc_exec_ctx_sched(exec_ctx, handshaker->on_handshake_done, error, NULL);+    gpr_mu_unlock(&handshaker->mu);+    http_connect_handshaker_unref(exec_ctx, handshaker);   } else {     // Otherwise, read the response.-    grpc_endpoint_read(exec_ctx, handshaker->endpoint, handshaker->read_buffer,+    // The read callback inherits our ref to the handshaker.+    grpc_endpoint_read(exec_ctx, handshaker->args->endpoint,","Yes, we're confident.  The whole point of scheduling callbacks via an exec_ctx is that we want to avoid exactly this type of deadlock.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8912,90324138,2016-11-30T20:46:49Z,src/core/ext/client_channel/subchannel.c,"@@ -418,6 +414,73 @@ static void on_external_state_watcher_done(grpc_exec_ctx *exec_ctx, void *arg,   follow_up->cb(exec_ctx, follow_up->cb_arg, error); } +static void on_alarm(grpc_exec_ctx *exec_ctx, void *arg, grpc_error *error) {+  grpc_subchannel *c = arg;+  gpr_mu_lock(&c->mu);+  c->have_alarm = 0;+  if (c->disconnected) {+    error = GRPC_ERROR_CREATE_REFERENCING(""Disconnected"", &error, 1);+  } else {+    GRPC_ERROR_REF(error);+  }+  if (error == GRPC_ERROR_NONE) {+    gpr_log(GPR_INFO, ""Failed to connect to channel, retrying"");+    c->next_attempt =+        gpr_backoff_step(&c->backoff_state, gpr_now(GPR_CLOCK_MONOTONIC));+    continue_connect(exec_ctx, c);+    gpr_mu_unlock(&c->mu);+  } else {+    gpr_mu_unlock(&c->mu);+    GRPC_SUBCHANNEL_WEAK_UNREF(exec_ctx, c, ""connecting"");+  }+  GRPC_ERROR_UNREF(error);+}++static void maybe_start_connecting_locked(grpc_exec_ctx *exec_ctx,+                                          grpc_subchannel *c) {+  if (c->disconnected) {+    /* Don't try to connect if we're already disconnected */+    return;+  }++  if (c->connecting) {+    /* Already connecting: don't restart */+    return;+  }++  if (GET_CONNECTED_SUBCHANNEL(c, no_barrier) != NULL) {+    /* Already connected: don't restart */+    return;+  }++  if (!grpc_connectivity_state_has_watchers(&c->state_tracker)) {+    /* Nobody is interested in connecting: so don't just yet */+    return;+  }++  c->connecting = true;+  GRPC_SUBCHANNEL_WEAK_REF(c, ""connecting"");++  gpr_timespec now = gpr_now(GPR_CLOCK_MONOTONIC);+  if (!c->backoff_begun) {+    c->backoff_begun = true;+    c->next_attempt = gpr_backoff_begin(&c->backoff_state, now);+    continue_connect(exec_ctx, c);",Suggest renaming `continue_connect()` to `continue_connect_locked()`.,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/8880,90331159,2016-11-30T21:23:20Z,test/cpp/qps/json_run_localhost.cc,"@@ -112,20 +114,25 @@ int main(int argc, char** argv) {     args.push_back(argv[i]);   } -  g_driver.reset(new SubProcess(args));+  g_driver = new SubProcess(args);   const int driver_join_status = g_driver->Join();   if (driver_join_status != 0) {     LogStatus(driver_join_status, ""driver"");   }-  for (const auto& worker : g_workers) {-    if (worker) worker->Interrupt();+  for (int i = 0; i < kNumWorkers; ++i) {+    if (g_workers[i]) g_workers[i]->Interrupt();   }-  for (const auto& worker : g_workers) {-    if (worker) {-      const int worker_status = worker->Join();++  for (int i = 0; i < kNumWorkers; ++i) {+    if (g_workers[i]) {+      const int worker_status = g_workers[i]->Join();       if (worker_status != 0) {         LogStatus(worker_status, ""worker"");       }     }   }++  delete g_driver;",More than that: you can't call malloc/free during signal handlers (or new/delete). To convince yourself of why: what happens if we get the signal during a free()? What are the guarantees about the allocators internal data structures?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8742,90350836,2016-11-30T23:13:31Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):","Rather than modifying this class in a tricky way I think we should recenter this change around a new class that looks like```pyclass ServiceRpcHandler(six.with_metaclass(abc.ABCMeta)):  def service_name(self):    # returns a string like ""my_package.my_subpackage.MyService""  def service_rpc(self, handler_call_details):    # services an RPC.```, under the banner of ""if we're going to introduce the concept of a service into the static API, let's do it plainly and simply and conventionally"". I'm open to the idea of `ServiceRpcHandler` being a subinterface of `GenericRpcHandler` but don't like the way it would force `ServiceRpcHandler.service` to have the same semantics as `GenericRpcHandler.service`.",
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/8909,90399346,2016-12-01T08:11:18Z,tools/dockerfile/push_testing_images.sh,"@@ -0,0 +1,64 @@+#!/bin/bash+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+#+# Builds selected testing docker images and pushes them to dockerhub.+# Useful for testing environments where it's impractical (or impossible)+# to rely on docker images being cached locally after they've been built+# for the first time (which might be costly especially for some images).+# NOTE: gRPC docker images intended to be used by end users are NOT+# pushed using this script (they're built automatically by dockerhub).+# This script is only for ""internal"" images we use when testing gRPC.  ++set -ex++cd $(dirname $0)/../..+git_root=$(pwd)+cd -++DOCKERHUB_ORGANIZATION=grpctesting++for DOCKERFILE_DIR in tools/dockerfile/test/fuzzer","I think eventually there's gonna be a list of N  docker images that need to be uploaded to dockerhub (and one would need to remember which ones). a few other docker images might be added to the list soonish, so I think the current approach is better. We can change it later if needed (I'm sure it's gonna evolve anyway).",
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/8915,90558207,2016-12-01T23:13:04Z,test/core/client_channel/lb_policies_test.c,"@@ -780,15 +783,21 @@ static void verify_total_carnage_round_robin(const servers_fixture *f,     }   } -  /* no server is ever available. The persistent state is TRANSIENT_FAILURE */+  /* no server is ever available. The persistent state is TRANSIENT_FAILURE. May+   * also be CONNECTING if, under load, this check took too long to run and some+   * subchannel already transitioned to retrying. */   for (size_t i = 0; i < sequences->n; i++) {     const grpc_connectivity_state actual = sequences->connectivity_states[i];-    const grpc_connectivity_state expected = GRPC_CHANNEL_TRANSIENT_FAILURE;-    if (actual != expected) {+    uint32_t expected_bitset;","Must demonstrate complexity :) JK, fair point. Done.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/8913,90957015,2016-12-05T21:17:01Z,src/core/ext/transport/chttp2/server/chttp2_server.h,"@@ -0,0 +1,79 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_SERVER_CHTTP2_SERVER_H+#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_SERVER_CHTTP2_SERVER_H++#include <grpc/impl/codegen/grpc_types.h>++#include ""src/core/lib/channel/handshaker.h""+#include ""src/core/lib/iomgr/exec_ctx.h""++/// A server handshaker factory is used to create handshakers for server+/// connections.+typedef struct grpc_chttp2_server_handshaker_factory+    grpc_chttp2_server_handshaker_factory;++typedef struct {+  void (*create_handshakers)(","Again, not sure about the `create_handshakers` semantics here. It seems to me that we could be symmetric with my suggestion on the client side and that instead of passing his `grpc_chttp2_handshaker_factory` in `grpc_chttp2_server_add_port`, we could pass a `grpc_handshake_manager_factory` which would just create `grpc_handshake_manager` objects.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8913,90981047,2016-12-05T23:32:23Z,src/core/ext/transport/chttp2/client/chttp2_connector.c,"@@ -0,0 +1,261 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""src/core/ext/transport/chttp2/client/chttp2_connector.h""++#include <grpc/grpc.h>++#include <string.h>++#include <grpc/slice_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/string_util.h>++#include ""src/core/ext/client_channel/connector.h""+#include ""src/core/ext/client_channel/http_connect_handshaker.h""+#include ""src/core/ext/transport/chttp2/transport/chttp2_transport.h""+#include ""src/core/lib/channel/channel_args.h""+#include ""src/core/lib/channel/handshaker.h""+#include ""src/core/lib/iomgr/tcp_client.h""+#include ""src/core/lib/security/transport/security_connector.h""++typedef struct {+  grpc_connector base;++  gpr_mu mu;+  gpr_refcount refs;++  bool shutdown;++  char *server_name;+  grpc_chttp2_create_handshakers_func create_handshakers;+  void *create_handshakers_user_data;++  grpc_closure *notify;+  grpc_connect_in_args args;+  grpc_connect_out_args *result;+  grpc_closure initial_string_sent;+  grpc_slice_buffer initial_string_buffer;++  grpc_endpoint *endpoint;  // Non-NULL until handshaking starts.++  grpc_closure connected;++  grpc_handshake_manager *handshake_mgr;+} chttp2_connector;++static void chttp2_connector_ref(grpc_connector *con) {+  chttp2_connector *c = (chttp2_connector *)con;+  gpr_ref(&c->refs);+}++static void chttp2_connector_unref(grpc_exec_ctx *exec_ctx,+                                   grpc_connector *con) {+  chttp2_connector *c = (chttp2_connector *)con;+  if (gpr_unref(&c->refs)) {+    /* c->initial_string_buffer does not need to be destroyed */+    gpr_mu_destroy(&c->mu);+    // If handshaking is not yet in progress, destroy the endpoint.+    // Otherwise, the handshaker will do this for us.+    if (c->endpoint != NULL) grpc_endpoint_destroy(exec_ctx, c->endpoint);+    gpr_free(c->server_name);+    gpr_free(c);+  }+}++static void chttp2_connector_shutdown(grpc_exec_ctx *exec_ctx,+                                      grpc_connector *con) {+  chttp2_connector *c = (chttp2_connector *)con;+  gpr_mu_lock(&c->mu);+  c->shutdown = true;+  if (c->handshake_mgr != NULL) {+    grpc_handshake_manager_shutdown(exec_ctx, c->handshake_mgr);+  }+  // If handshaking is not yet in progress, shutdown the endpoint.+  // Otherwise, the handshaker will do this for us.+  if (c->endpoint != NULL) grpc_endpoint_shutdown(exec_ctx, c->endpoint);+  gpr_mu_unlock(&c->mu);+}++static void on_handshake_done(grpc_exec_ctx *exec_ctx, void *arg,+                              grpc_error *error) {+  grpc_handshaker_args *args = arg;+  chttp2_connector *c = args->user_data;+  gpr_mu_lock(&c->mu);+  if (error != GRPC_ERROR_NONE || c->shutdown) {+    if (error == GRPC_ERROR_NONE) {+      error = GRPC_ERROR_CREATE(""connector shutdown"");+      // We were shut down after handshaking completed successfully, so+      // destroy the endpoint here.+      // TODO(ctiller): It is currently necessary to shutdown endpoints+      // before destroying them, even if we know that there are no+      // pending read/write callbacks.  This should be fixed, at which+      // point this can be removed.+      grpc_endpoint_shutdown(exec_ctx, args->endpoint);+      grpc_endpoint_destroy(exec_ctx, args->endpoint);+      grpc_channel_args_destroy(args->args);+      grpc_slice_buffer_destroy(args->read_buffer);+      gpr_free(args->read_buffer);+    } else {+      error = GRPC_ERROR_REF(error);+    }+    memset(c->result, 0, sizeof(*c->result));+  } else {+    c->result->transport =+        grpc_create_chttp2_transport(exec_ctx, args->args, args->endpoint, 1);+    GPR_ASSERT(c->result->transport);+    grpc_chttp2_transport_start_reading(exec_ctx, c->result->transport,+                                        args->read_buffer);+    c->result->channel_args = args->args;+  }+  grpc_closure *notify = c->notify;+  c->notify = NULL;+  grpc_exec_ctx_sched(exec_ctx, notify, error, NULL);+  grpc_handshake_manager_destroy(exec_ctx, c->handshake_mgr);+  c->handshake_mgr = NULL;+  gpr_mu_unlock(&c->mu);+  chttp2_connector_unref(exec_ctx, (grpc_connector *)c);+}++static void start_handshake_locked(grpc_exec_ctx *exec_ctx,+                                   chttp2_connector *c) {+  c->handshake_mgr = grpc_handshake_manager_create();+  char *proxy_name = grpc_get_http_proxy_server();+  if (proxy_name != NULL) {+    grpc_handshake_manager_add(+        c->handshake_mgr,+        grpc_http_connect_handshaker_create(proxy_name, c->server_name));+    gpr_free(proxy_name);+  }+  if (c->create_handshakers != NULL) {+    c->create_handshakers(exec_ctx, c->create_handshakers_user_data,+                          c->handshake_mgr);+  }+  grpc_handshake_manager_do_handshake(+      exec_ctx, c->handshake_mgr, c->endpoint, c->args.channel_args,+      c->args.deadline, NULL /* acceptor */, on_handshake_done, c);+  c->endpoint = NULL;  // Endpoint handed off to handshake manager.+}++static void on_initial_connect_string_sent(grpc_exec_ctx *exec_ctx, void *arg,+                                           grpc_error *error) {+  chttp2_connector *c = arg;+  gpr_mu_lock(&c->mu);+  if (error != GRPC_ERROR_NONE || c->shutdown) {","Ultimately, I intend to move the initial_connect_string code into its own handshaker, at which point this duplication will go away.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8913,90981336,2016-12-05T23:34:26Z,src/core/ext/transport/chttp2/client/chttp2_connector.h,"@@ -0,0 +1,52 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_CLIENT_CHTTP2_CONNECTOR_H+#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_CLIENT_CHTTP2_CONNECTOR_H++#include ""src/core/ext/client_channel/connector.h""+#include ""src/core/lib/channel/handshaker.h""+#include ""src/core/lib/iomgr/exec_ctx.h""++typedef void (*grpc_chttp2_create_handshakers_func)(","The handshakers have to be created in order to be added to the handshake manager, since it takes ownership, so I'm not sure this name is really that inaccurate.  I could see renaming it to _add_handshakers(), although I'm not sure it's worth another PR to do that at this point (although please feel free to push back if you disagree).We can't pass the handshake manager into grpc_chttp2_connector_create(), because we need to create a new handshake manager (and new handshakers) for each connection attempt.",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8913,90984579,2016-12-05T23:56:05Z,src/core/lib/security/transport/security_connector.h,"@@ -154,11 +144,10 @@ void grpc_channel_security_connector_check_call_host(     const char *host, grpc_auth_context *auth_context,     grpc_security_call_host_check_cb cb, void *user_data); -/* Handshake. */-void grpc_channel_security_connector_do_handshake(+/* Registers handshakers with \a handshake_mgr. */+void grpc_channel_security_connector_create_handshakers(","That seems a bit long.  I think I prefer the current name, but as I mentioned above, please feel free to push back if you feel strongly.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/8913,90987596,2016-12-06T00:21:17Z,src/core/ext/transport/chttp2/client/chttp2_connector.h,"@@ -0,0 +1,52 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_TRANSPORT_CHTTP2_CLIENT_CHTTP2_CONNECTOR_H+#define GRPC_CORE_EXT_TRANSPORT_CHTTP2_CLIENT_CHTTP2_CONNECTOR_H++#include ""src/core/ext/client_channel/connector.h""+#include ""src/core/lib/channel/handshaker.h""+#include ""src/core/lib/iomgr/exec_ctx.h""++typedef void (*grpc_chttp2_create_handshakers_func)(","> The handshakers have to be created in order to be added to the handshake manager, since it takes ownership, so I'm not sure this name is really that inaccurate. I could see renaming it to _add_handshakers(), although I'm not sure it's worth another PR to do that at this point (although please feel free to push back if you disagree).I actually would push for another PR ;). The way we use `_create` in all gRPC implies that you're getting a new object of this type in the function definition. This does not follow this pattern which makes reading the code a bit confusing.> We can't pass the handshake manager into grpc_chttp2_connector_create(), because we need to create a new handshake manager (and new handshakers) for each connection attempt.Good point. You *could* pass in a `grpc_handhake_manager` factory though.",
6262765,jboeuf,https://api.github.com/repos/grpc/grpc/pulls/8913,90987655,2016-12-06T00:21:52Z,src/core/lib/security/transport/security_connector.h,"@@ -106,12 +98,12 @@ void grpc_security_connector_unref(grpc_security_connector *policy); #endif  /* Check the peer. Callee takes ownership of the peer object.-   The callback will include the resulting auth_context. */+   Sets *auth_context and invokes on_peer_checked when done. */ void grpc_security_connector_check_peer(grpc_exec_ctx *exec_ctx,                                         grpc_security_connector *sc,                                         tsi_peer peer,-                                        grpc_security_peer_check_cb cb,-                                        void *user_data);+                                        grpc_auth_context **auth_context,","ah, I see. but that seems a little clumsy right? IMO, the callback should have an `grpc_auth_context*` as a parameter that the implementer of the callback takes ownership of. This way, you don't have to pass it in this function.  ",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/8913,91102242,2016-12-06T15:35:22Z,src/core/lib/security/transport/security_connector.h,"@@ -106,12 +98,12 @@ void grpc_security_connector_unref(grpc_security_connector *policy); #endif  /* Check the peer. Callee takes ownership of the peer object.-   The callback will include the resulting auth_context. */+   Sets *auth_context and invokes on_peer_checked when done. */ void grpc_security_connector_check_peer(grpc_exec_ctx *exec_ctx,                                         grpc_security_connector *sc,                                         tsi_peer peer,-                                        grpc_security_peer_check_cb cb,-                                        void *user_data);+                                        grpc_auth_context **auth_context,","The reason for doing this is that, now that we're executing the callback asynchronously via the exec_ctx, it needs to be a grpc_closure, which means that the argument is pre-bound by the caller -- there's no easy way to pass in a grpc_closure and have this function pass the grpc_auth_context directly to it when it's invoked.The alternative would be to have the caller pass in a custom callback type and make it the responsibility of the check_peer() function to invoke its own callback via the exec_ctx, which would then directly invoke the caller-supplied custom callback type.  However, that seems fairly cumbersome, and it requires more memory allocation (which is more expensive), so I prefer the approach I've chosen here.Also, this API is consistent with other uses within the C-core code base.  For example, look at grpc_tcp_client_connect() (https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/tcp_client.h#L52), which takes a grpc_endpoint** as an argument, which it fills in before calling the on_connect callback.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8742,91146315,2016-12-06T18:56:43Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):","True, but it's within reason to make the new service specification accessible with a ""rerun your code generation"" requirement? I agree that it's not as nice as a completely seamless integration but remember that the primary use case in the long view is for code generation to be integrated into [Bazel](http://www.bazel.io/) and done more or less continuously during development.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/8742,91160935,2016-12-06T20:09:38Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):","Even beyond that, I don't understand the issue with having SerivceRpcHandler have the same semantics as GenericHandler.  I think avoiding adding complexity to the API is sufficient to stick with GenericRpcHandler.",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/8742,91160975,2016-12-06T20:09:49Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):","Even beyond that, I don't understand the issue with having SerivceRpcHandler have the same semantics as GenericHandler.  I think avoiding adding complexity to the API is sufficient to stick with GenericRpcHandler.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8742,91165334,2016-12-06T20:34:52Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):","The issue is in avoiding the situation of an application creating a `ServiceRpcHandler`, registering it with a server using `add_generic_rpc_handlers`, and then the server having to do dynamic type inspection and special casing along the lines of ""well, which of the handlers just registered are `ServiceRpcHandler`s and which are merely `GenericRpcHandlers`?"" when the application had that information on its side of the API. It's been really nice that we've been able to avoid dynamic type inspection so far and I'd like to keep it up.With that pushing in the direction of a `Server.add_service_rpc_handlers` method the question of the design of the `ServiceRpcHandler` type is raised. How should it be called to service an RPC? By full-size `/my_package.my_subpackage.MyService/MyMethod` string? Or just by `MyMethod` string? Should `ServiceRpcHandler`s be free to refuse service of an RPC?I think these questions can be answered in a way that allows `ServiceRpcHandler` to inherit the `service` method from `GenericRpcHandler`. Do you foresee any problems?",
18316330,kpayson64,https://api.github.com/repos/grpc/grpc/pulls/8742,91382377,2016-12-07T20:40:39Z,src/python/grpcio/grpc/__init__.py,"@@ -833,7 +833,11 @@ class HandlerCallDetails(six.with_metaclass(abc.ABCMeta)):   class GenericRpcHandler(six.with_metaclass(abc.ABCMeta)):","I still think that type inspection is favorable over introducing API complexity.  Also, we are introducing a potential quagmire of versioning issues with generated code vs library version.  If anyone uses a newer version of grpc-tools and an older version of gRPC, they will get a bunch of weird attribute exceptions. ",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/9004,91567932,2016-12-08T17:50:24Z,src/node/index.js,"@@ -55,73 +55,60 @@ var grpc = require('./src/grpc_extension'); grpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));  /**- * Load a gRPC object from an existing ProtoBuf.Reflect object.- * @param {ProtoBuf.Reflect.Namespace} value The ProtoBuf object to load.+ * Build a gRPC object from an existing ProtoBuf.Root object.+ * @param {ProtoBuf.Root} value The ProtoBuf root object to transform.  * @param {Object=} options Options to apply to the loaded object- * @return {Object<string, *>} The resulting gRPC object+ * @return {ProtoBuf.Root} The transformed Root object.  */ exports.loadObject = function loadObject(value, options) {-  var result = {};-  if (value.className === 'Namespace') {-    _.each(value.children, function(child) {-      result[child.name] = loadObject(child, options);-    });-    return result;-  } else if (value.className === 'Service') {+  if (!value.resolved && value.resolveAll) {+    value.resolveAll();+  }++  // Protobuf.JS 6 trees don't work the same way as in ProtoBuf.JS 5.+  // Now, we can just swap out the Services in the tree.+  if (value.constructor === ProtoBuf.Service) {     return client.makeProtobufClientConstructor(value, options);-  } else if (value.className === 'Message' || value.className === 'Enum') {-    return value.build();-  } else {-    return value;   }++  if (value.nested) {+    for (let name in value.nested) {+      if (!value.nested.hasOwnProperty(name)) {+        continue;+      }+      value.nested[name] = loadObject(value.nested[name], options);+    }+  }++  return value; };  var loadObject = exports.loadObject;  /**  * Load a gRPC object from a .proto file. The options object can provide the  * following options:- * - convertFieldsToCamelCase: Loads this file with that option on protobuf.js- *   set as specified. See- *   https://github.com/dcodeIO/protobuf.js/wiki/Advanced-options for details  * - binaryAsBase64: deserialize bytes values as base64 strings instead of  *   Buffers. Defaults to false  * - longsAsStrings: deserialize long values as strings instead of objects.  *   Defaults to true- * - deprecatedArgumentOrder: Use the beta method argument order for client- *   methods, with optional arguments after the callback. Defaults to false.- *   This option is only a temporary stopgap measure to smooth an API breakage.- *   It is deprecated, and new code should not use it.- * @param {string|{root: string, file: string}} filename The file to load- * @param {string=} format The file format to expect. Must be either 'proto' or- *     'json'. Defaults to 'proto'+ * @param {string} filename The file to load  * @param {Object=} options Options to apply to the loaded file- * @return {Object<string, *>} The resulting gRPC object+ * @param {function(?Error, ProtoBuf.Root=)} callback Callback function for result.+ * @return {undefined}  */-exports.load = function load(filename, format, options) {-  if (!format) {-    format = 'proto';-  }-  var convertFieldsToCamelCaseOriginal = ProtoBuf.convertFieldsToCamelCase;-  if(options && options.hasOwnProperty('convertFieldsToCamelCase')) {-    ProtoBuf.convertFieldsToCamelCase = options.convertFieldsToCamelCase;+exports.load = function load(filename, options, callback) {",`grpc.load` cannot change from synchronous to asynchronous here. That breaks the API too badly.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,91610554,2016-12-08T21:28:28Z,src/python/grpcio/grpc/_channel.py,"@@ -99,6 +99,24 @@ def _wait_once_until(condition, until):     else:       condition.wait(timeout=remaining) +def _check_call_error(call_error, metadata=None):+  if call_error != cygrpc.CallError.ok:",Reduce the nesting by revising the control flow to be```if <one condition>:  raise <one expression>elif <another condition>:  raise <another expression>```.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,91610720,2016-12-08T21:29:21Z,src/python/grpcio/grpc/_channel.py,"@@ -99,6 +99,24 @@ def _wait_once_until(condition, until):     else:       condition.wait(timeout=remaining) +def _check_call_error(call_error, metadata=None):",Keyword arguments generally are not appropriate for private methods - make `metadata` positional?,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/9019,91669026,2016-12-09T07:20:47Z,test/core/end2end/tests/negative_deadline.c,"@@ -100,7 +100,9 @@ static void end_test(grpc_end2end_test_fixture *f) { static void simple_request_body(grpc_end2end_test_config config,                                 grpc_end2end_test_fixture f, size_t num_ops) {   grpc_call *c;-  gpr_timespec deadline = gpr_inf_past(GPR_CLOCK_REALTIME);+  gpr_timespec deadline = gpr_time_add(gpr_now(GPR_CLOCK_MONOTONIC),",Why not leave it as is since there is a new test covering the short deadline?,
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/9019,91669265,2016-12-09T07:23:29Z,test/core/end2end/tests/short_deadlines.c,"@@ -0,0 +1,200 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/byte_buffer.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpc/support/useful.h>+#include ""src/core/lib/support/string.h""+#include ""test/core/end2end/cq_verifier.h""++static void *tag(intptr_t t) { return (void *)t; }++static grpc_end2end_test_fixture begin_test(grpc_end2end_test_config config,+                                            const char *test_name,+                                            grpc_channel_args *client_args,+                                            grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  gpr_log(GPR_INFO, ""%s/%s"", test_name, config.name);+  f = config.create_fixture(client_args, server_args);+  config.init_server(&f, server_args);+  config.init_client(&f, client_args);+  return f;+}++static gpr_timespec n_seconds_time(int n) {+  return GRPC_TIMEOUT_SECONDS_TO_DEADLINE(n);+}++static gpr_timespec five_seconds_time(void) { return n_seconds_time(5); }++static void drain_cq(grpc_completion_queue *cq) {+  grpc_event ev;+  do {+    ev = grpc_completion_queue_next(cq, five_seconds_time(), NULL);+  } while (ev.type != GRPC_QUEUE_SHUTDOWN);+}++static void shutdown_server(grpc_end2end_test_fixture *f) {+  if (!f->server) return;+  grpc_server_shutdown_and_notify(f->server, f->cq, tag(1000));+  GPR_ASSERT(grpc_completion_queue_pluck(+                 f->cq, tag(1000), GRPC_TIMEOUT_SECONDS_TO_DEADLINE(5), NULL)+                 .type == GRPC_OP_COMPLETE);+  grpc_server_destroy(f->server);+  f->server = NULL;+}++static void shutdown_client(grpc_end2end_test_fixture *f) {+  if (!f->client) return;+  grpc_channel_destroy(f->client);+  f->client = NULL;+}++static void end_test(grpc_end2end_test_fixture *f) {+  shutdown_server(f);+  shutdown_client(f);++  grpc_completion_queue_shutdown(f->cq);+  drain_cq(f->cq);+  grpc_completion_queue_destroy(f->cq);+}++static void simple_request_body_with_deadline(grpc_end2end_test_config config,+                                              grpc_end2end_test_fixture f,+                                              size_t num_ops, int deadline_ms) {+  grpc_call *c;+  const gpr_timespec deadline =+      gpr_time_add(gpr_now(GPR_CLOCK_MONOTONIC),+                   gpr_time_from_millis(deadline_ms, GPR_TIMESPAN));++  cq_verifier *cqv = cq_verifier_create(f.cq);+  grpc_op ops[6];+  grpc_op *op;+  grpc_metadata_array initial_metadata_recv;+  grpc_metadata_array trailing_metadata_recv;+  grpc_status_code status;+  grpc_call_error error;+  char *details = NULL;+  size_t details_capacity = 0;++  gpr_log(GPR_DEBUG, ""test with %"" PRIuPTR "" ops, %d ms deadline"", num_ops,+          deadline_ms);++  c = grpc_channel_create_call(+      f.client, NULL, GRPC_PROPAGATE_DEFAULTS, f.cq, ""/foo"",+      get_host_override_string(""foo.test.google.fr:1234"", config), deadline,+      NULL);+  GPR_ASSERT(c);++  grpc_metadata_array_init(&initial_metadata_recv);+  grpc_metadata_array_init(&trailing_metadata_recv);++  memset(ops, 0, sizeof(ops));+  op = ops;+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;+  op->data.recv_status_on_client.status = &status;+  op->data.recv_status_on_client.status_details = &details;+  op->data.recv_status_on_client.status_details_capacity = &details_capacity;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &initial_metadata_recv;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = 0;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  GPR_ASSERT(num_ops <= (size_t)(op - ops));+  error = grpc_call_start_batch(c, ops, num_ops, tag(1), NULL);+  GPR_ASSERT(GRPC_CALL_OK == error);++  CQ_EXPECT_COMPLETION(cqv, tag(1), 1);+  cq_verify(cqv);++  if (status != GRPC_STATUS_DEADLINE_EXCEEDED) {+    gpr_log(GPR_ERROR,+            ""Expected GRPC_STATUS_DEADLINE_EXCEEDED (code %d), got code %d"",+            GRPC_STATUS_DEADLINE_EXCEEDED, status);+    abort();+  }++  gpr_free(details);+  grpc_metadata_array_destroy(&initial_metadata_recv);+  grpc_metadata_array_destroy(&trailing_metadata_recv);++  grpc_call_destroy(c);++  cq_verifier_destroy(cqv);+}++static void test_invoke_short_deadline_request(grpc_end2end_test_config config,+                                               size_t num_ops,+                                               int deadline_ms) {+  grpc_end2end_test_fixture f;++  f = begin_test(config, __func__, NULL, NULL);+  simple_request_body_with_deadline(config, f, num_ops, deadline_ms);+  end_test(&f);+  config.tear_down_data(&f);+}++void short_deadlines(grpc_end2end_test_config config) {+  size_t i;+  for (i = 1; i <= 4; i++) {+    test_invoke_short_deadline_request(config, i, 0);+    test_invoke_short_deadline_request(config, i, 1);+    test_invoke_short_deadline_request(config, i, 5);+    test_invoke_short_deadline_request(config, i, 10);+    test_invoke_short_deadline_request(config, i, 15);+    test_invoke_short_deadline_request(config, i, 30);",Is there anything to guarantee the rpc will fail with deadline exceeded (rather than succeed)?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/9019,91673179,2016-12-09T08:08:48Z,test/core/end2end/tests/short_deadlines.c,"@@ -0,0 +1,200 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/byte_buffer.h>+#include <grpc/grpc.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpc/support/useful.h>+#include ""src/core/lib/support/string.h""+#include ""test/core/end2end/cq_verifier.h""++static void *tag(intptr_t t) { return (void *)t; }++static grpc_end2end_test_fixture begin_test(grpc_end2end_test_config config,+                                            const char *test_name,+                                            grpc_channel_args *client_args,+                                            grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  gpr_log(GPR_INFO, ""%s/%s"", test_name, config.name);+  f = config.create_fixture(client_args, server_args);+  config.init_server(&f, server_args);+  config.init_client(&f, client_args);+  return f;+}++static gpr_timespec n_seconds_time(int n) {+  return GRPC_TIMEOUT_SECONDS_TO_DEADLINE(n);+}++static gpr_timespec five_seconds_time(void) { return n_seconds_time(5); }++static void drain_cq(grpc_completion_queue *cq) {+  grpc_event ev;+  do {+    ev = grpc_completion_queue_next(cq, five_seconds_time(), NULL);+  } while (ev.type != GRPC_QUEUE_SHUTDOWN);+}++static void shutdown_server(grpc_end2end_test_fixture *f) {+  if (!f->server) return;+  grpc_server_shutdown_and_notify(f->server, f->cq, tag(1000));+  GPR_ASSERT(grpc_completion_queue_pluck(+                 f->cq, tag(1000), GRPC_TIMEOUT_SECONDS_TO_DEADLINE(5), NULL)+                 .type == GRPC_OP_COMPLETE);+  grpc_server_destroy(f->server);+  f->server = NULL;+}++static void shutdown_client(grpc_end2end_test_fixture *f) {+  if (!f->client) return;+  grpc_channel_destroy(f->client);+  f->client = NULL;+}++static void end_test(grpc_end2end_test_fixture *f) {+  shutdown_server(f);+  shutdown_client(f);++  grpc_completion_queue_shutdown(f->cq);+  drain_cq(f->cq);+  grpc_completion_queue_destroy(f->cq);+}++static void simple_request_body_with_deadline(grpc_end2end_test_config config,+                                              grpc_end2end_test_fixture f,+                                              size_t num_ops, int deadline_ms) {+  grpc_call *c;+  const gpr_timespec deadline =+      gpr_time_add(gpr_now(GPR_CLOCK_MONOTONIC),+                   gpr_time_from_millis(deadline_ms, GPR_TIMESPAN));++  cq_verifier *cqv = cq_verifier_create(f.cq);+  grpc_op ops[6];+  grpc_op *op;+  grpc_metadata_array initial_metadata_recv;+  grpc_metadata_array trailing_metadata_recv;+  grpc_status_code status;+  grpc_call_error error;+  char *details = NULL;+  size_t details_capacity = 0;++  gpr_log(GPR_DEBUG, ""test with %"" PRIuPTR "" ops, %d ms deadline"", num_ops,+          deadline_ms);++  c = grpc_channel_create_call(+      f.client, NULL, GRPC_PROPAGATE_DEFAULTS, f.cq, ""/foo"",+      get_host_override_string(""foo.test.google.fr:1234"", config), deadline,+      NULL);+  GPR_ASSERT(c);++  grpc_metadata_array_init(&initial_metadata_recv);+  grpc_metadata_array_init(&trailing_metadata_recv);++  memset(ops, 0, sizeof(ops));+  op = ops;+  op->op = GRPC_OP_RECV_STATUS_ON_CLIENT;+  op->data.recv_status_on_client.trailing_metadata = &trailing_metadata_recv;+  op->data.recv_status_on_client.status = &status;+  op->data.recv_status_on_client.status_details = &details;+  op->data.recv_status_on_client.status_details_capacity = &details_capacity;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_RECV_INITIAL_METADATA;+  op->data.recv_initial_metadata = &initial_metadata_recv;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_SEND_INITIAL_METADATA;+  op->data.send_initial_metadata.count = 0;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  op->op = GRPC_OP_SEND_CLOSE_FROM_CLIENT;+  op->flags = 0;+  op->reserved = NULL;+  op++;+  GPR_ASSERT(num_ops <= (size_t)(op - ops));+  error = grpc_call_start_batch(c, ops, num_ops, tag(1), NULL);+  GPR_ASSERT(GRPC_CALL_OK == error);++  CQ_EXPECT_COMPLETION(cqv, tag(1), 1);+  cq_verify(cqv);++  if (status != GRPC_STATUS_DEADLINE_EXCEEDED) {+    gpr_log(GPR_ERROR,+            ""Expected GRPC_STATUS_DEADLINE_EXCEEDED (code %d), got code %d"",+            GRPC_STATUS_DEADLINE_EXCEEDED, status);+    abort();+  }++  gpr_free(details);+  grpc_metadata_array_destroy(&initial_metadata_recv);+  grpc_metadata_array_destroy(&trailing_metadata_recv);++  grpc_call_destroy(c);++  cq_verifier_destroy(cqv);+}++static void test_invoke_short_deadline_request(grpc_end2end_test_config config,+                                               size_t num_ops,+                                               int deadline_ms) {+  grpc_end2end_test_fixture f;++  f = begin_test(config, __func__, NULL, NULL);+  simple_request_body_with_deadline(config, f, num_ops, deadline_ms);+  end_test(&f);+  config.tear_down_data(&f);+}++void short_deadlines(grpc_end2end_test_config config) {+  size_t i;+  for (i = 1; i <= 4; i++) {+    test_invoke_short_deadline_request(config, i, 0);+    test_invoke_short_deadline_request(config, i, 1);+    test_invoke_short_deadline_request(config, i, 5);+    test_invoke_short_deadline_request(config, i, 10);+    test_invoke_short_deadline_request(config, i, 15);+    test_invoke_short_deadline_request(config, i, 30);","Ah, very good point... I'll make some changes so that the server side delays long enough.",
534887,paralin,https://api.github.com/repos/grpc/grpc/pulls/9004,91782178,2016-12-09T19:45:30Z,src/node/index.js,"@@ -55,73 +55,60 @@ var grpc = require('./src/grpc_extension'); grpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));  /**- * Load a gRPC object from an existing ProtoBuf.Reflect object.- * @param {ProtoBuf.Reflect.Namespace} value The ProtoBuf object to load.+ * Build a gRPC object from an existing ProtoBuf.Root object.+ * @param {ProtoBuf.Root} value The ProtoBuf root object to transform.  * @param {Object=} options Options to apply to the loaded object- * @return {Object<string, *>} The resulting gRPC object+ * @return {ProtoBuf.Root} The transformed Root object.  */ exports.loadObject = function loadObject(value, options) {-  var result = {};-  if (value.className === 'Namespace') {-    _.each(value.children, function(child) {-      result[child.name] = loadObject(child, options);-    });-    return result;-  } else if (value.className === 'Service') {+  if (!value.resolved && value.resolveAll) {+    value.resolveAll();+  }++  // Protobuf.JS 6 trees don't work the same way as in ProtoBuf.JS 5.+  // Now, we can just swap out the Services in the tree.+  if (value.constructor === ProtoBuf.Service) {     return client.makeProtobufClientConstructor(value, options);-  } else if (value.className === 'Message' || value.className === 'Enum') {-    return value.build();-  } else {-    return value;   }++  if (value.nested) {+    for (let name in value.nested) {+      if (!value.nested.hasOwnProperty(name)) {+        continue;+      }+      value.nested[name] = loadObject(value.nested[name], options);+    }+  }++  return value; };  var loadObject = exports.loadObject;  /**  * Load a gRPC object from a .proto file. The options object can provide the  * following options:- * - convertFieldsToCamelCase: Loads this file with that option on protobuf.js- *   set as specified. See- *   https://github.com/dcodeIO/protobuf.js/wiki/Advanced-options for details  * - binaryAsBase64: deserialize bytes values as base64 strings instead of  *   Buffers. Defaults to false  * - longsAsStrings: deserialize long values as strings instead of objects.  *   Defaults to true- * - deprecatedArgumentOrder: Use the beta method argument order for client- *   methods, with optional arguments after the callback. Defaults to false.- *   This option is only a temporary stopgap measure to smooth an API breakage.- *   It is deprecated, and new code should not use it.- * @param {string|{root: string, file: string}} filename The file to load- * @param {string=} format The file format to expect. Must be either 'proto' or- *     'json'. Defaults to 'proto'+ * @param {string} filename The file to load  * @param {Object=} options Options to apply to the loaded file- * @return {Object<string, *>} The resulting gRPC object+ * @param {function(?Error, ProtoBuf.Root=)} callback Callback function for result.+ * @return {undefined}  */-exports.load = function load(filename, format, options) {-  if (!format) {-    format = 'proto';-  }-  var convertFieldsToCamelCaseOriginal = ProtoBuf.convertFieldsToCamelCase;-  if(options && options.hasOwnProperty('convertFieldsToCamelCase')) {-    ProtoBuf.convertFieldsToCamelCase = options.convertFieldsToCamelCase;+exports.load = function load(filename, options, callback) {","@murgatroid99 noted, following the `loadSync` fix the changes seem quite minimal. The only thing that is really different is in most cases it's better to use `lookup` on the `grpc.load` result:```jsvar ro = grpc.load('myproto.proto');var serv = new (ro.lookup('mynamespace.MyService'))('localhost:5000');```You can also do this (but it's ""bad practice""):```jsvar ro = grpc.load('myproto.proto');var serv = ro.nested.mynamespace.nested.MyService('localhost:5000');```",
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/8900,91975055,2016-12-12T15:56:55Z,test/http2_test/http2_base_server.py,"@@ -0,0 +1,173 @@+import struct+import messages_pb2+import logging++from twisted.internet.protocol import Protocol+from twisted.internet import reactor+from h2.connection import H2Connection+from h2.events import RequestReceived, DataReceived, WindowUpdated, RemoteSettingsChanged, PingAcknowledged+from h2.exceptions import ProtocolError++READ_CHUNK_SIZE = 16384+GRPC_HEADER_SIZE = 5++class H2ProtocolBaseServer(Protocol):+  def __init__(self):+    self._conn = H2Connection(client_side=False)+    self._recv_buffer = {}+    self._handlers = {}+    self._handlers['ConnectionMade'] = self.on_connection_made_default+    self._handlers['DataReceived'] = self.on_data_received_default+    self._handlers['WindowUpdated'] = self.on_window_update_default+    self._handlers['RequestReceived'] = self.on_request_received_default+    self._handlers['SendDone'] = self.on_send_done_default+    self._handlers['ConnectionLost'] = self.on_connection_lost+    self._handlers['PingAcknowledged'] = self.on_ping_acknowledged_default+    self._stream_status = {}+    self._send_remaining = {}+    self._outstanding_pings = 0++  def set_handlers(self, handlers):+    self._handlers = handlers++  def connectionMade(self):+    self._handlers['ConnectionMade']()++  def connectionLost(self, reason):+    self._handlers['ConnectionLost'](reason)++  def on_connection_made_default(self):+    logging.info('Connection Made')+    self._conn.initiate_connection()+    self.transport.setTcpNoDelay(True)+    self.transport.write(self._conn.data_to_send())++  def on_connection_lost(self, reason):+    logging.info('Disconnected %s'%reason)+    reactor.callFromThread(reactor.stop)++  def dataReceived(self, data):+    try:+      events = self._conn.receive_data(data)+    except ProtocolError:+      # this try/except block catches exceptions due to race between sending+      # GOAWAY and processing a response in flight.+      return+    if self._conn.data_to_send:+      self.transport.write(self._conn.data_to_send())+    for event in events:+      if isinstance(event, RequestReceived) and self._handlers.has_key('RequestReceived'):","For this section maybe we should change the logic to be if `is instance of EventType but _handlers does not have the key`, throw an exception, or print some error.Because if we receive and event that we haven't set up a handler for, wouldn't it be better to fail than to do nothing?",
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/8900,91980259,2016-12-12T16:18:09Z,test/http2_test/test_goaway.py,"@@ -0,0 +1,48 @@+import logging+import time+import http2_base_server++class TestcaseGoaway(object):+  """""" +    This test does the following:+      Process incoming request normally, i.e. send headers, data and trailers.+      Then send a GOAWAY frame with the stream id of the processed request.+      It assert that the next request is made on a different TCP connection.+  """"""+  def __init__(self, iteration):+    self._base_server = http2_base_server.H2ProtocolBaseServer()+    self._base_server._handlers['RequestReceived'] = self.on_request_received+    self._base_server._handlers['DataReceived'] = self.on_data_received+    self._base_server._handlers['SendDone'] = self.on_send_done+    self._base_server._handlers['ConnectionLost'] = self.on_connection_lost+    self._ready_to_send = False+    self._iteration = iteration++  def get_base_server(self):+    return self._base_server++  def on_connection_lost(self, reason):+    logging.info('Disconnect received. Count %d'%self._iteration)+    # _iteration == 2 => Two different connections have been used.+    if self._iteration == 2:+      self._base_server.on_connection_lost(reason)++  def on_send_done(self, stream_id):+    self._base_server.on_send_done_default(stream_id)+    time.sleep(1)",Is this needed to avoid race conditions? Maybe add a comment rather than have the naked sleep,
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/8900,91992638,2016-12-12T17:11:27Z,test/http2_test/http2_base_server.py,"@@ -0,0 +1,173 @@+import struct+import messages_pb2+import logging++from twisted.internet.protocol import Protocol+from twisted.internet import reactor+from h2.connection import H2Connection+from h2.events import RequestReceived, DataReceived, WindowUpdated, RemoteSettingsChanged, PingAcknowledged+from h2.exceptions import ProtocolError",Ordering: h2 should come before twisted. The Python style guide also recommends avoiding importing individual classes instead of modules.,
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/8900,91994745,2016-12-12T17:21:25Z,test/http2_test/http2_base_server.py,"@@ -0,0 +1,173 @@+import struct+import messages_pb2+import logging++from twisted.internet.protocol import Protocol+from twisted.internet import reactor+from h2.connection import H2Connection+from h2.events import RequestReceived, DataReceived, WindowUpdated, RemoteSettingsChanged, PingAcknowledged+from h2.exceptions import ProtocolError++READ_CHUNK_SIZE = 16384+GRPC_HEADER_SIZE = 5++class H2ProtocolBaseServer(Protocol):+  def __init__(self):+    self._conn = H2Connection(client_side=False)+    self._recv_buffer = {}+    self._handlers = {}+    self._handlers['ConnectionMade'] = self.on_connection_made_default+    self._handlers['DataReceived'] = self.on_data_received_default+    self._handlers['WindowUpdated'] = self.on_window_update_default+    self._handlers['RequestReceived'] = self.on_request_received_default+    self._handlers['SendDone'] = self.on_send_done_default+    self._handlers['ConnectionLost'] = self.on_connection_lost+    self._handlers['PingAcknowledged'] = self.on_ping_acknowledged_default+    self._stream_status = {}+    self._send_remaining = {}+    self._outstanding_pings = 0++  def set_handlers(self, handlers):+    self._handlers = handlers++  def connectionMade(self):+    self._handlers['ConnectionMade']()++  def connectionLost(self, reason):+    self._handlers['ConnectionLost'](reason)++  def on_connection_made_default(self):+    logging.info('Connection Made')+    self._conn.initiate_connection()+    self.transport.setTcpNoDelay(True)+    self.transport.write(self._conn.data_to_send())++  def on_connection_lost(self, reason):+    logging.info('Disconnected %s'%reason)+    reactor.callFromThread(reactor.stop)++  def dataReceived(self, data):+    try:+      events = self._conn.receive_data(data)+    except ProtocolError:","Can this catch a more specific exception, like StreamClosedError from https://github.com/python-hyper/hyper-h2/blob/master/h2/exceptions.py?",
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/8900,91996420,2016-12-12T17:29:13Z,test/http2_test/http2_base_server.py,"@@ -0,0 +1,173 @@+import struct+import messages_pb2+import logging++from twisted.internet.protocol import Protocol+from twisted.internet import reactor+from h2.connection import H2Connection+from h2.events import RequestReceived, DataReceived, WindowUpdated, RemoteSettingsChanged, PingAcknowledged+from h2.exceptions import ProtocolError++READ_CHUNK_SIZE = 16384+GRPC_HEADER_SIZE = 5++class H2ProtocolBaseServer(Protocol):+  def __init__(self):+    self._conn = H2Connection(client_side=False)+    self._recv_buffer = {}+    self._handlers = {}+    self._handlers['ConnectionMade'] = self.on_connection_made_default+    self._handlers['DataReceived'] = self.on_data_received_default+    self._handlers['WindowUpdated'] = self.on_window_update_default+    self._handlers['RequestReceived'] = self.on_request_received_default+    self._handlers['SendDone'] = self.on_send_done_default+    self._handlers['ConnectionLost'] = self.on_connection_lost+    self._handlers['PingAcknowledged'] = self.on_ping_acknowledged_default+    self._stream_status = {}+    self._send_remaining = {}+    self._outstanding_pings = 0++  def set_handlers(self, handlers):+    self._handlers = handlers++  def connectionMade(self):+    self._handlers['ConnectionMade']()++  def connectionLost(self, reason):+    self._handlers['ConnectionLost'](reason)++  def on_connection_made_default(self):+    logging.info('Connection Made')+    self._conn.initiate_connection()+    self.transport.setTcpNoDelay(True)+    self.transport.write(self._conn.data_to_send())++  def on_connection_lost(self, reason):+    logging.info('Disconnected %s'%reason)+    reactor.callFromThread(reactor.stop)++  def dataReceived(self, data):+    try:+      events = self._conn.receive_data(data)+    except ProtocolError:+      # this try/except block catches exceptions due to race between sending+      # GOAWAY and processing a response in flight.+      return+    if self._conn.data_to_send:+      self.transport.write(self._conn.data_to_send())+    for event in events:+      if isinstance(event, RequestReceived) and self._handlers.has_key('RequestReceived'):+        logging.info('RequestReceived Event for stream: %d'%event.stream_id)+        self._handlers['RequestReceived'](event)+      elif isinstance(event, DataReceived) and self._handlers.has_key('DataReceived'):+        logging.info('DataReceived Event for stream: %d'%event.stream_id)+        self._handlers['DataReceived'](event)+      elif isinstance(event, WindowUpdated) and self._handlers.has_key('WindowUpdated'):+        logging.info('WindowUpdated Event for stream: %d'%event.stream_id)+        self._handlers['WindowUpdated'](event)+      elif isinstance(event, PingAcknowledged) and self._handlers.has_key('PingAcknowledged'):+        logging.info('PingAcknowledged Event')+        self._handlers['PingAcknowledged'](event)+    self.transport.write(self._conn.data_to_send())++  def on_ping_acknowledged_default(self, event):+    self._outstanding_pings -= 1++  def on_data_received_default(self, event):+    self._conn.acknowledge_received_data(len(event.data), event.stream_id)+    self._recv_buffer[event.stream_id] += event.data++  def on_request_received_default(self, event):+    self._recv_buffer[event.stream_id] = ''+    self._stream_id = event.stream_id+    self._stream_status[event.stream_id] = True+    self._conn.send_headers(+      stream_id=event.stream_id,+      headers=[+          (':status', '200'),+          ('content-type', 'application/grpc'),+          ('grpc-encoding', 'identity'),+          ('grpc-accept-encoding', 'identity,deflate,gzip'),+      ],+    )+    self.transport.write(self._conn.data_to_send())++  def on_window_update_default(self, event):+    # send pending data, if any+    self.default_send(event.stream_id)++  def send_reset_stream(self):+    self._conn.reset_stream(self._stream_id)+    self.transport.write(self._conn.data_to_send())++  def setup_send(self, data_to_send, stream_id):+    logging.info('Setting up data to send for stream_id: %d'%stream_id)+    self._send_remaining[stream_id] = len(data_to_send)+    self._send_offset = 0+    self._data_to_send = data_to_send+    self.default_send(stream_id)++  def default_send(self, stream_id):+    if not self._send_remaining.has_key(stream_id):+      # not setup to send data yet+      return++    while self._send_remaining[stream_id] > 0:+      lfcw = self._conn.local_flow_control_window(stream_id)+      if lfcw == 0:+        break+      chunk_size = min(lfcw, READ_CHUNK_SIZE)+      bytes_to_send = min(chunk_size, self._send_remaining[stream_id])+      logging.info('flow_control_window = %d. sending [%d:%d] stream_id %d'%+                    (lfcw, self._send_offset, self._send_offset + bytes_to_send,+                    stream_id))+      data = self._data_to_send[self._send_offset : self._send_offset + bytes_to_send]+      try:+        self._conn.send_data(stream_id, data, False)+      except ProtocolError:","This should probably be StreamClosedError, or else log the type of the exception.",
17325098,makdharma,https://api.github.com/repos/grpc/grpc/pulls/8900,92043268,2016-12-12T21:23:44Z,test/http2_test/http2_base_server.py,"@@ -0,0 +1,173 @@+import struct+import messages_pb2+import logging++from twisted.internet.protocol import Protocol+from twisted.internet import reactor+from h2.connection import H2Connection+from h2.events import RequestReceived, DataReceived, WindowUpdated, RemoteSettingsChanged, PingAcknowledged+from h2.exceptions import ProtocolError++READ_CHUNK_SIZE = 16384+GRPC_HEADER_SIZE = 5++class H2ProtocolBaseServer(Protocol):+  def __init__(self):+    self._conn = H2Connection(client_side=False)+    self._recv_buffer = {}+    self._handlers = {}+    self._handlers['ConnectionMade'] = self.on_connection_made_default+    self._handlers['DataReceived'] = self.on_data_received_default+    self._handlers['WindowUpdated'] = self.on_window_update_default+    self._handlers['RequestReceived'] = self.on_request_received_default+    self._handlers['SendDone'] = self.on_send_done_default+    self._handlers['ConnectionLost'] = self.on_connection_lost+    self._handlers['PingAcknowledged'] = self.on_ping_acknowledged_default+    self._stream_status = {}+    self._send_remaining = {}+    self._outstanding_pings = 0++  def set_handlers(self, handlers):+    self._handlers = handlers++  def connectionMade(self):+    self._handlers['ConnectionMade']()++  def connectionLost(self, reason):+    self._handlers['ConnectionLost'](reason)++  def on_connection_made_default(self):+    logging.info('Connection Made')+    self._conn.initiate_connection()+    self.transport.setTcpNoDelay(True)+    self.transport.write(self._conn.data_to_send())++  def on_connection_lost(self, reason):+    logging.info('Disconnected %s'%reason)+    reactor.callFromThread(reactor.stop)++  def dataReceived(self, data):+    try:+      events = self._conn.receive_data(data)+    except ProtocolError:+      # this try/except block catches exceptions due to race between sending+      # GOAWAY and processing a response in flight.+      return+    if self._conn.data_to_send:+      self.transport.write(self._conn.data_to_send())+    for event in events:+      if isinstance(event, RequestReceived) and self._handlers.has_key('RequestReceived'):+        logging.info('RequestReceived Event for stream: %d'%event.stream_id)+        self._handlers['RequestReceived'](event)+      elif isinstance(event, DataReceived) and self._handlers.has_key('DataReceived'):+        logging.info('DataReceived Event for stream: %d'%event.stream_id)+        self._handlers['DataReceived'](event)+      elif isinstance(event, WindowUpdated) and self._handlers.has_key('WindowUpdated'):+        logging.info('WindowUpdated Event for stream: %d'%event.stream_id)+        self._handlers['WindowUpdated'](event)+      elif isinstance(event, PingAcknowledged) and self._handlers.has_key('PingAcknowledged'):+        logging.info('PingAcknowledged Event')+        self._handlers['PingAcknowledged'](event)+    self.transport.write(self._conn.data_to_send())++  def on_ping_acknowledged_default(self, event):+    self._outstanding_pings -= 1++  def on_data_received_default(self, event):+    self._conn.acknowledge_received_data(len(event.data), event.stream_id)+    self._recv_buffer[event.stream_id] += event.data++  def on_request_received_default(self, event):+    self._recv_buffer[event.stream_id] = ''+    self._stream_id = event.stream_id+    self._stream_status[event.stream_id] = True+    self._conn.send_headers(+      stream_id=event.stream_id,+      headers=[+          (':status', '200'),+          ('content-type', 'application/grpc'),+          ('grpc-encoding', 'identity'),+          ('grpc-accept-encoding', 'identity,deflate,gzip'),+      ],+    )+    self.transport.write(self._conn.data_to_send())++  def on_window_update_default(self, event):+    # send pending data, if any+    self.default_send(event.stream_id)++  def send_reset_stream(self):+    self._conn.reset_stream(self._stream_id)+    self.transport.write(self._conn.data_to_send())++  def setup_send(self, data_to_send, stream_id):+    logging.info('Setting up data to send for stream_id: %d'%stream_id)+    self._send_remaining[stream_id] = len(data_to_send)+    self._send_offset = 0+    self._data_to_send = data_to_send+    self.default_send(stream_id)++  def default_send(self, stream_id):+    if not self._send_remaining.has_key(stream_id):+      # not setup to send data yet+      return++    while self._send_remaining[stream_id] > 0:+      lfcw = self._conn.local_flow_control_window(stream_id)+      if lfcw == 0:+        break+      chunk_size = min(lfcw, READ_CHUNK_SIZE)+      bytes_to_send = min(chunk_size, self._send_remaining[stream_id])+      logging.info('flow_control_window = %d. sending [%d:%d] stream_id %d'%+                    (lfcw, self._send_offset, self._send_offset + bytes_to_send,+                    stream_id))+      data = self._data_to_send[self._send_offset : self._send_offset + bytes_to_send]+      try:+        self._conn.send_data(stream_id, data, False)+      except ProtocolError:+        logging.info('Stream %d is closed'%stream_id)+        break+      self._send_remaining[stream_id] -= bytes_to_send+      self._send_offset += bytes_to_send+      if self._send_remaining[stream_id] == 0:",Not really. default_send gets called every time window_update is received. pulling it out of while loop will cause it to send trailer even when no data was sent.,
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/8900,92052641,2016-12-12T22:12:19Z,test/http2_test/test_goaway.py,"@@ -0,0 +1,48 @@+import logging+import time++import http2_base_server++class TestcaseGoaway(object):+  """""" +    This test does the following:+      Process incoming request normally, i.e. send headers, data and trailers.+      Then send a GOAWAY frame with the stream id of the processed request.+      It checks that the next request is made on a different TCP connection.+  """"""+  def __init__(self, iteration):+    self._base_server = http2_base_server.H2ProtocolBaseServer()+    self._base_server._handlers['RequestReceived'] = self.on_request_received+    self._base_server._handlers['DataReceived'] = self.on_data_received+    self._base_server._handlers['SendDone'] = self.on_send_done+    self._base_server._handlers['ConnectionLost'] = self.on_connection_lost+    self._ready_to_send = False+    self._iteration = iteration++  def get_base_server(self):+    return self._base_server++  def on_connection_lost(self, reason):+    logging.info('Disconnect received. Count %d' % self._iteration)+    # _iteration == 2 => Two different connections have been used.+    if self._iteration == 2:","After looking at the base server implementation, I think I understand what this accomplishes: if _iteration != 2, the server won't acknowledge the connection lost, and consequently the server won't be shutdown (which happens from _base_server.on_connection_lost()). This would then be regarded as a failed test.  Would it be better to ""fail fast"" here and throw an exception if _iteration != 2? Otherwise, it seems like the test runner would have to wait until the test timeouts to see that the server is still running and the test failed, if I understand how the test driver will execute.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/9004,92056793,2016-12-12T22:35:19Z,src/node/index.js,"@@ -55,73 +55,98 @@ var grpc = require('./src/grpc_extension'); grpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));  /**- * Load a gRPC object from an existing ProtoBuf.Reflect object.- * @param {ProtoBuf.Reflect.Namespace} value The ProtoBuf object to load.+ * Build a gRPC object from an existing ProtoBuf.Root object.+ * @param {ProtoBuf.Root} value The ProtoBuf root object to transform.  * @param {Object=} options Options to apply to the loaded object- * @return {Object<string, *>} The resulting gRPC object+ * @return {ProtoBuf.Root} The transformed Root object.  */ exports.loadObject = function loadObject(value, options) {-  var result = {};-  if (value.className === 'Namespace') {-    _.each(value.children, function(child) {-      result[child.name] = loadObject(child, options);-    });-    return result;-  } else if (value.className === 'Service') {-    return client.makeProtobufClientConstructor(value, options);-  } else if (value.className === 'Message' || value.className === 'Enum') {-    return value.build();-  } else {+  if (!value) {     return value;   }++  // Protobuf.JS 6 trees don't work the same way as in ProtoBuf.JS 5.+  // Now, we can just swap out the Services in the tree.+  if (value.methods && Object.keys(value.methods).length) {+    value.resolveAll();+    return client.makeProtobufClientConstructor(value, options);+  }++  if (value.nested) {+    for (let name in value.nested) {+      if (!value.nested.hasOwnProperty(name)) {+        continue;+      }+      value.nested[name] = loadObject(value.nested[name], options);+    }+  }++  return value; };  var loadObject = exports.loadObject;  /**+ * Compat: apply a ProtoBuf.JS 5 {root, file} object+ * to a ProtoBuf.Root.+ * @param {Object=} filename Filename object.+ * @param {ProtoBuf.Root=} ProtoBuf.Root to apply to.+ * @return {string} The filename to pass to ProtoBuf.load()+ */+function applyProtoRoot(filename, root) {+  if (_.isString(filename)) {+    return filename;+  }+  filename.root = path.resolve(filename.root) + '/';+  root.resolvePath = function(originPath, importPath, alreadyNormalized) {+    return ProtoBuf.util.resolvePath(filename.root,+      importPath,+      alreadyNormalized);+  };+  return filename.file;+};++/**  * Load a gRPC object from a .proto file. The options object can provide the  * following options:- * - convertFieldsToCamelCase: Loads this file with that option on protobuf.js- *   set as specified. See- *   https://github.com/dcodeIO/protobuf.js/wiki/Advanced-options for details+ * - enumsAsStrings: deserialize enum values as strings instead of numeric+ *   values. Defaults to false.+ * - longsAsStrings: deserialize long values as strings instead of objects.+ *   Defaults to true.+ * @param {string} filename The file to load+ * @param {Object=} options Options to apply to the loaded file+ * @return {ProtoBuf.Root=} ProtoBuf.Root with services filled.+ */+exports.load = function load(filename, options) {","Please do not change the signature of `grpc.load`. Even if `format` is unused, we need to keep it for API compatibility. ",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/9004,92057197,2016-12-12T22:37:43Z,src/node/src/common.js,"@@ -43,21 +43,20 @@ var _ = require('lodash');  /**  * Get a function that deserializes a specific type of protobuf.- * @param {function()} cls The constructor of the message type to deserialize- * @param {bool=} binaryAsBase64 Deserialize bytes fields as base64 strings- *     instead of Buffers. Defaults to false+ * @param {function()} cls The ProtoBuf.Type of the message type to deserialize+ * @param {bool=} enumsAsStrings Deserialize enum fields as key strings+ *     instead of numbers. Defaults to false  * @param {bool=} longsAsStrings Deserialize long values as strings instead of  *     objects. Defaults to true  * @return {function(Buffer):cls} The deserialization function  */-exports.deserializeCls = function deserializeCls(cls, binaryAsBase64,+exports.deserializeCls = function deserializeCls(cls, enumsAsStrings,                                                  longsAsStrings) {-  if (binaryAsBase64 === undefined || binaryAsBase64 === null) {-    binaryAsBase64 = false;",Why remove `binaryAsBase64`? Is this no longer an option in Protobuf.js?,
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/9004,92063794,2016-12-12T23:16:04Z,src/node/index.js,"@@ -55,73 +55,98 @@ var grpc = require('./src/grpc_extension'); grpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));  /**- * Load a gRPC object from an existing ProtoBuf.Reflect object.- * @param {ProtoBuf.Reflect.Namespace} value The ProtoBuf object to load.+ * Build a gRPC object from an existing ProtoBuf.Root object.+ * @param {ProtoBuf.Root} value The ProtoBuf root object to transform.  * @param {Object=} options Options to apply to the loaded object- * @return {Object<string, *>} The resulting gRPC object+ * @return {ProtoBuf.Root} The transformed Root object.  */ exports.loadObject = function loadObject(value, options) {-  var result = {};-  if (value.className === 'Namespace') {-    _.each(value.children, function(child) {-      result[child.name] = loadObject(child, options);-    });-    return result;-  } else if (value.className === 'Service') {-    return client.makeProtobufClientConstructor(value, options);-  } else if (value.className === 'Message' || value.className === 'Enum') {-    return value.build();-  } else {+  if (!value) {     return value;   }++  // Protobuf.JS 6 trees don't work the same way as in ProtoBuf.JS 5.+  // Now, we can just swap out the Services in the tree.+  if (value.methods && Object.keys(value.methods).length) {+    value.resolveAll();+    return client.makeProtobufClientConstructor(value, options);+  }++  if (value.nested) {+    for (let name in value.nested) {+      if (!value.nested.hasOwnProperty(name)) {+        continue;+      }+      value.nested[name] = loadObject(value.nested[name], options);+    }+  }++  return value; };  var loadObject = exports.loadObject;  /**+ * Compat: apply a ProtoBuf.JS 5 {root, file} object+ * to a ProtoBuf.Root.+ * @param {Object=} filename Filename object.+ * @param {ProtoBuf.Root=} ProtoBuf.Root to apply to.+ * @return {string} The filename to pass to ProtoBuf.load()+ */+function applyProtoRoot(filename, root) {+  if (_.isString(filename)) {+    return filename;+  }+  filename.root = path.resolve(filename.root) + '/';+  root.resolvePath = function(originPath, importPath, alreadyNormalized) {+    return ProtoBuf.util.resolvePath(filename.root,+      importPath,+      alreadyNormalized);+  };+  return filename.file;+};++/**  * Load a gRPC object from a .proto file. The options object can provide the  * following options:- * - convertFieldsToCamelCase: Loads this file with that option on protobuf.js- *   set as specified. See- *   https://github.com/dcodeIO/protobuf.js/wiki/Advanced-options for details+ * - enumsAsStrings: deserialize enum values as strings instead of numeric+ *   values. Defaults to false.+ * - longsAsStrings: deserialize long values as strings instead of objects.+ *   Defaults to true.+ * @param {string} filename The file to load+ * @param {Object=} options Options to apply to the loaded file+ * @return {ProtoBuf.Root=} ProtoBuf.Root with services filled.+ */+exports.load = function load(filename, options) {","The extra parameter is in the middle. Currently, you have to pass `format` as the second parameter and `options` as the third parameter. If you move options to the second parameter, it will behave differently. Just add a second parameter called `format`, don't use it in the function, and document it as ""unused"".",
534887,paralin,https://api.github.com/repos/grpc/grpc/pulls/9004,92064067,2016-12-12T23:17:37Z,src/node/index.js,"@@ -55,73 +55,98 @@ var grpc = require('./src/grpc_extension'); grpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));  /**- * Load a gRPC object from an existing ProtoBuf.Reflect object.- * @param {ProtoBuf.Reflect.Namespace} value The ProtoBuf object to load.+ * Build a gRPC object from an existing ProtoBuf.Root object.+ * @param {ProtoBuf.Root} value The ProtoBuf root object to transform.  * @param {Object=} options Options to apply to the loaded object- * @return {Object<string, *>} The resulting gRPC object+ * @return {ProtoBuf.Root} The transformed Root object.  */ exports.loadObject = function loadObject(value, options) {-  var result = {};-  if (value.className === 'Namespace') {-    _.each(value.children, function(child) {-      result[child.name] = loadObject(child, options);-    });-    return result;-  } else if (value.className === 'Service') {-    return client.makeProtobufClientConstructor(value, options);-  } else if (value.className === 'Message' || value.className === 'Enum') {-    return value.build();-  } else {+  if (!value) {     return value;   }++  // Protobuf.JS 6 trees don't work the same way as in ProtoBuf.JS 5.+  // Now, we can just swap out the Services in the tree.+  if (value.methods && Object.keys(value.methods).length) {+    value.resolveAll();+    return client.makeProtobufClientConstructor(value, options);+  }++  if (value.nested) {+    for (let name in value.nested) {+      if (!value.nested.hasOwnProperty(name)) {+        continue;+      }+      value.nested[name] = loadObject(value.nested[name], options);+    }+  }++  return value; };  var loadObject = exports.loadObject;  /**+ * Compat: apply a ProtoBuf.JS 5 {root, file} object+ * to a ProtoBuf.Root.+ * @param {Object=} filename Filename object.+ * @param {ProtoBuf.Root=} ProtoBuf.Root to apply to.+ * @return {string} The filename to pass to ProtoBuf.load()+ */+function applyProtoRoot(filename, root) {+  if (_.isString(filename)) {+    return filename;+  }+  filename.root = path.resolve(filename.root) + '/';+  root.resolvePath = function(originPath, importPath, alreadyNormalized) {+    return ProtoBuf.util.resolvePath(filename.root,+      importPath,+      alreadyNormalized);+  };+  return filename.file;+};++/**  * Load a gRPC object from a .proto file. The options object can provide the  * following options:- * - convertFieldsToCamelCase: Loads this file with that option on protobuf.js- *   set as specified. See- *   https://github.com/dcodeIO/protobuf.js/wiki/Advanced-options for details+ * - enumsAsStrings: deserialize enum values as strings instead of numeric+ *   values. Defaults to false.+ * - longsAsStrings: deserialize long values as strings instead of objects.+ *   Defaults to true.+ * @param {string} filename The file to load+ * @param {Object=} options Options to apply to the loaded file+ * @return {ProtoBuf.Root=} ProtoBuf.Root with services filled.+ */+exports.load = function load(filename, options) {","Ah, I had forgotten it was in the middle. Will fix. ",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8934,92213396,2016-12-13T16:54:13Z,examples/cpp/helloworld/README.md,"@@ -256,5 +256,32 @@ main loop in `HandleRpcs` to query the queue. For a working example, refer to [greeter_async_server.cc](greeter_async_server.cc).  +#### Async bi-directional streaming server/client +An asynchronous streaming server or client can read and write streaming data+from/to each other. A common theme for a server/client stream is a dedicated+thread that can callback when there is a new stream data available.","Let's change this paragraph to avoid references to callbacks (that's an application-controlled thing in gRPC and will likely be confused with API-level callbacks, as we've often seen on the forums). I would suggestBidirectional streaming RPCs allow both client and server to read and write streaming data from/to each other, and this is supported by both synchronous and asynchronous API. The asynchronous API allows these actions to take place without blocking using the completion queue, just as in the asynchronous code examples above.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8934,92216283,2016-12-13T17:06:13Z,examples/cpp/helloworld/greeter_async_bidi_client.cc,"@@ -0,0 +1,188 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#include <iostream>+#include <memory>+#include <string>+#include <thread>++#include <grpc++/grpc++.h>++#include ""hellostreamingworld.grpc.pb.h""++using grpc::Channel;+using grpc::ClientAsyncReaderWriter;+using grpc::ClientContext;+using grpc::CompletionQueue;+using grpc::Status;+using hellostreamingworld::HelloRequest;+using hellostreamingworld::HelloReply;+using hellostreamingworld::MultiGreeter;++// NOTE: This is a complex example for an asynchronous, bidirectional streaming+// client. For a simpler example, start with the+// greeter_client/greeter_async_client first.+class AsyncBidiGreeterClient {+  enum class Type { READ = 1, WRITE = 2, CONNECT = 3 };++ public:+  explicit AsyncBidiGreeterClient(std::shared_ptr<Channel> channel)+      : stub_(MultiGreeter::NewStub(channel)) {+    grpc_thread_.reset(+        new std::thread([=]() { GrpcThread(); }));+    stream_ = stub_->AsyncSayHello(&context_, &cq_,+                                   reinterpret_cast<void*>(Type::CONNECT));+  }++  // Similar to the async hello example in greeter_async_client but does not+  // wait for the response. Instead queues up a tag in the completion queue+  // that is notified when the server responds back (or when the stream is+  // closed).+  void AsyncSayHello(const std::string& user) {+    // Data we are sending to the server.+    HelloRequest request;+    request.set_name(user);++    // This is important: You can have at most one write or at most one read+    // at any given time. The throttling is performed by gRPC completion+    // queue. If you queue more than one write/read, the stream will crash.+    // Because this stream is bidirectional, you *can* have a single read+    // and a single write request queued for the same stream. Writes and reads+    // are independent of each other in terms of ordering/delivery.+    std::cout << "" ** Sending request: "" << user << std::endl;+    stream_->Write(request, reinterpret_cast<void*>(Type::WRITE));+  }++  ~AsyncBidiGreeterClient() {+    std::cout << ""Shutting down client."" << std::endl;+    grpc::Status status;+    cq_.Shutdown();+    grpc_thread_->join();+  }++ private:+  void AsyncHelloRequestNextMessage() {+    std::cout << "" ** Got response: "" << response_.message() << std::endl;++    // The tag is the link between our thread (main thread) and the completion+    // queue thread. The tag allows the completion queue to fan off+    // notification handlers for the specified read/write requests as they+    // are being processed by gRPC.+    stream_->Read(&response_, reinterpret_cast<void*>(Type::READ));+  }++  // Runs a gRPC completion-queue processing thread. Checks for 'Next' tag+  // and processes them until there are no more (or when the completion queue+  // is shutdown).+  void GrpcThread() {+    while (true) {+      void* got_tag;+      bool ok = false;+      // Block until the next result is available in the completion queue ""cq"".+      // The return value of Next should always be checked. This return value+      // tells us whether there is any kind of event or the cq_ is shutting+      // down.+      if (!cq_.Next(&got_tag, &ok)) {+        std::cerr << ""Client stream closed. Quitting"" << std::endl;+        break;+      }++      // It's important to process all tags even if the ok is false. One might+      // want to deallocate memory that has be reinterpret_cast'ed to void*+      // when the tag got initialized. For our example, we cast an int to a+      // void*, so we don't have extra memory management to take care of.+      if (ok) {+        std::cout << std::endl+                  << ""**** Processing completion queue tag "" << got_tag+                  << std::endl;+        switch (static_cast<Type>(reinterpret_cast<long>(got_tag))) {+          case Type::READ:+            std::cout << ""Read a new message."" << std::endl;+            break;+          case Type::WRITE:+            std::cout << ""Sending message (async)."" << std::endl;+            AsyncHelloRequestNextMessage();+            break;+          case Type::CONNECT:+            std::cout << ""Server connected."" << std::endl;+            break;+          default:+            std::cerr << ""Unexpected tag "" << got_tag << std::endl;+            GPR_ASSERT(false);+        }+      }+    }+  }++  // Context for the client. It could be used to convey extra information to+  // the server and/or tweak certain RPC behaviors.+  ClientContext context_;++  // The producer-consumer queue we use to communicate asynchronously with the+  // gRPC runtime.+  CompletionQueue cq_;++  // Out of the passed in Channel comes the stub, stored here, our view of the+  // server's exposed services.+  std::unique_ptr<MultiGreeter::Stub> stub_;++  // The bidirectional, asynchronous stream for sending/receiving messages.+  std::unique_ptr<ClientAsyncReaderWriter<HelloRequest, HelloReply>> stream_;++  // Allocated protobuf that holds the response. In real clients and servers,+  // the memory management would a bit more complex as the thread that fills+  // in the response should take care of concurrency as well as memory+  // management.+  HelloReply response_;++  // Thread that notifies the gRPC completion queue tags.+  std::unique_ptr<std::thread> grpc_thread_;+};++int main(int argc, char** argv) {+  AsyncBidiGreeterClient greeter(grpc::CreateChannel(+      ""localhost:50051"", grpc::InsecureChannelCredentials()));++  std::string user;+  while (true) {+    std::cout << ""Enter text (type quit to end): "";+    std::cin >> user;+    if (user == ""quit"") {","IMO, the termination condition should be EOF (or at least also EOF) as otherwise this code will loop forever if stdin runs out before quit.",
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/8900,92233800,2016-12-13T18:28:09Z,test/http2_test/http2_test_server.py,"@@ -0,0 +1,59 @@+""""""+  HTTP2 Test Server. Highly experimental work in progress.+""""""+import argparse+import logging+import twisted+import twisted.internet+import twisted.internet.endpoints+import twisted.internet.reactor++import http2_base_server+import test_goaway+import test_max_streams+import test_ping+import test_rst_after_data+import test_rst_after_header+import test_rst_during_data++_TEST_CASE_MAPPING = {+  'rst_after_header': test_rst_after_header.TestcaseRstStreamAfterHeader,+  'rst_after_data': test_rst_after_data.TestcaseRstStreamAfterData,+  'rst_during_data': test_rst_during_data.TestcaseRstStreamDuringData,+  'goaway': test_goaway.TestcaseGoaway,+  'ping': test_ping.TestcasePing,+  'max_streams': test_max_streams.TestcaseSettingsMaxStreams,+}++class H2Factory(twisted.internet.protocol.Factory):+  def __init__(self, testcase):+    logging.info('Creating H2Factory for new connection.')+    self._num_streams = 0+    self._testcase = testcase++  def buildProtocol(self, addr):+    self._num_streams += 1+    logging.info('New Connection: %d' % self._num_streams)+    if not _TEST_CASE_MAPPING.has_key(self._testcase):+      logging.error('Unknown test case: %s' % self._testcase)+      assert(0)+    else:+      t = _TEST_CASE_MAPPING[self._testcase]++    if self._testcase == 'goaway':+      return t(self._num_streams).get_base_server()+    else:+      return t().get_base_server()++if __name__ == ""__main__"":+  logging.basicConfig(format = ""%(levelname) -10s %(asctime)s %(module)s:%(lineno)s | %(message)s"", level=logging.INFO)+  parser = argparse.ArgumentParser()","I think this would be easier to use with a help message that lists the test cases. The following snippet adds help messages, and switches to --flag=value style arguments to be consistent with the existing interop test binaries. I also assigned a default value to --port - this makes things easier for me when running locally for testing. Feel free to just take the help messages if you prefer positional arguments.```if __name__ == '__main__':  logging.basicConfig(    format='%(levelname) -10s %(asctime)s %(module)s:%(lineno)s | %(message)s',     level=logging.INFO)  parser = argparse.ArgumentParser()  parser.add_argument('--test', choices=_TEST_CASE_MAPPING.keys(),     help='test case to run')  parser.add_argument('--port', type=int, default=25678,     help='port to run the server (default: 25678)')  args = parser.parse_args()  if args.test not in _TEST_CASE_MAPPING.keys():    logging.error('unknown test: %s' % args.test)  else:    endpoint = twisted.internet.endpoints.TCP4ServerEndpoint(      twisted.internet.reactor, args.port, backlog=128)    endpoint.listen(H2Factory(args.test))    twisted.internet.reactor.run()```I also added some line wrapping. I think we probably want to stay <= 80 columns, which I didn't check for when I was reviewing this yesterday.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92270874,2016-12-13T21:31:31Z,src/python/grpcio/grpc/_channel.py,"@@ -99,6 +99,22 @@ def _wait_once_until(condition, until):     else:       condition.wait(timeout=remaining) +def _check_call_error(call_error, metadata):+  if call_error == cygrpc.CallError.ok:",Why this rather than```if <one error condition>:  raise <one error>elif <another error condition>:  raise <another error>```?,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92272787,2016-12-13T21:41:20Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,169 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class RPCTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error = ValueError(""metadata was invalid: %s"" % metadata)+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(ValueError) as cm:",Avoid abbreviations for the same reason that single-letter identifiers are forbidden by the style guide. This should probably be named `exception_context`.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92273273,2016-12-13T21:43:49Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,169 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class RPCTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error = ValueError(""metadata was invalid: %s"" % metadata)+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(ValueError) as cm:+      response = multi_callable(request, metadata=metadata)+    self.assertEqual(cm.exception.message, expected_error.message)++  def testUnaryRequestBlockingUnaryResponseWithCall(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponseWithCall'),)+    expected_error = ValueError(""metadata was invalid: %s"" % metadata)+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(ValueError) as cm:+      response, call = multi_callable.with_call(request, metadata=metadata)+    self.assertEqual(cm.exception.message, expected_error.message)++  def testUnaryRequestFutureUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestFutureUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(Exception) as cm:+      response_future = multi_callable.future(request, metadata=metadata)",Pull this out of the `with` so that the test has the effect of asserting that execution of this line **does not** raise an exception.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92273350,2016-12-13T21:44:12Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,169 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class RPCTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error = ValueError(""metadata was invalid: %s"" % metadata)+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(ValueError) as cm:+      response = multi_callable(request, metadata=metadata)+    self.assertEqual(cm.exception.message, expected_error.message)++  def testUnaryRequestBlockingUnaryResponseWithCall(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponseWithCall'),)+    expected_error = ValueError(""metadata was invalid: %s"" % metadata)+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(ValueError) as cm:+      response, call = multi_callable.with_call(request, metadata=metadata)+    self.assertEqual(cm.exception.message, expected_error.message)++  def testUnaryRequestFutureUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestFutureUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    multi_callable = _unary_unary_multi_callable(self._channel)+    with self.assertRaises(Exception) as cm:",No more specific exception class? `Exception` is very broad.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92274150,2016-12-13T21:48:08Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,169 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class RPCTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error = ValueError(""metadata was invalid: %s"" % metadata)+    multi_callable = _unary_unary_multi_callable(self._channel)",Kind of an arbitrary matter of taste but consider moving the instantiation of the MultiCallable objects to `setUp` rather than having one-per-test-method:```self._unary_unary = <...>self._unary_stream = <...><...>```.,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/9098,92302456,2016-12-14T00:57:15Z,src/core/lib/channel/context.h,"@@ -47,6 +47,9 @@ typedef enum {   /// Value is a \a census_context.   GRPC_CONTEXT_TRACING, +  /// Reserved for traffic_classs_context.",classssss :),
2754995,sreecha,https://api.github.com/repos/grpc/grpc/pulls/9102,92332691,2016-12-14T07:12:17Z,src/core/lib/slice/slice_buffer.c,"@@ -44,29 +44,36 @@ #define GROW(x) (3 * (x) / 2)  static void maybe_embiggen(grpc_slice_buffer *sb) {-  if (sb->count == sb->capacity) {+  /* How many far away from sb->base_slices is sb->slices pointer */+  size_t slice_offset = (size_t)(sb->slices - sb->base_slices);+  size_t slice_count = sb->count + slice_offset;++  if (slice_count == sb->capacity) {     sb->capacity = GROW(sb->capacity);-    GPR_ASSERT(sb->capacity > sb->count);-    if (sb->slices == sb->inlined) {-      sb->slices = gpr_malloc(sb->capacity * sizeof(grpc_slice));-      memcpy(sb->slices, sb->inlined, sb->count * sizeof(grpc_slice));+    GPR_ASSERT(sb->capacity > slice_count);+    if (sb->base_slices == sb->inlined) {+      sb->base_slices = gpr_malloc(sb->capacity * sizeof(grpc_slice));+      memcpy(sb->base_slices, sb->inlined, slice_count * sizeof(grpc_slice));     } else {-      sb->slices = gpr_realloc(sb->slices, sb->capacity * sizeof(grpc_slice));+      sb->base_slices =","You mean doing the following as the very first line of the code?```if (sb->base_slices != sb->slices) {    memmove(sb->base_slices, sb->slices, sb->count * sizeof(grpc_slice));    sb->slices = sb->base_slices;}```I was not sure what the status of the `grpc_slice`s between `base_slices` and `slices`  fields (i.e do we own them or not. Looks like we no longer own them once they are given out via the `grpc_slice_buffer_take_first` function. I will look at the code a bit more, convince myself and do it)",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92495694,2016-12-14T21:42:45Z,src/python/grpcio/grpc/_channel.py,"@@ -99,6 +99,22 @@ def _wait_once_until(condition, until):     else:       condition.wait(timeout=remaining) +_INTERNAL_CALLERROR_MESSAGE = (+    'Internal gRPC CallError %d. ' +","And just plain old ordinary ""call error"" here, since what semantically matters in this user-visible (or developer-visible) string is not the specific `CallError` class name.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92496139,2016-12-14T21:44:56Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,169 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import unittest++import grpc++from tests.unit.framework.common import test_constants++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class InvalidMetadataTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')+    self._unary_unary = _unary_unary_multi_callable(self._channel)+    self._unary_stream = _unary_stream_multi_callable(self._channel)+    self._stream_unary = _stream_unary_multi_callable(self._channel)+    self._stream_stream = _stream_stream_multi_callable(self._channel)++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    with self.assertRaises(ValueError) as exception_ctx:",Avoid abbreviations as well as initialisms and acronyms - this should be `exception_context`.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92496463,2016-12-14T21:46:24Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,169 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import unittest++import grpc++from tests.unit.framework.common import test_constants++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class InvalidMetadataTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')+    self._unary_unary = _unary_unary_multi_callable(self._channel)+    self._unary_stream = _unary_stream_multi_callable(self._channel)+    self._stream_unary = _stream_unary_multi_callable(self._channel)+    self._stream_stream = _stream_stream_multi_callable(self._channel)++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    with self.assertRaises(ValueError) as exception_ctx:+      response = self._unary_unary(request, metadata=metadata)","Did you try running `pylint`? Did it alert you to this local field being assigned but never accessed?I'd say drop the field, but if you think the test is more clear with it included call it `unused_response`.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8995,92523894,2016-12-15T00:50:19Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,179 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import unittest++import grpc++from tests.unit.framework.common import test_constants++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class InvalidMetadataTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')+    self._unary_unary = _unary_unary_multi_callable(self._channel)+    self._unary_stream = _unary_stream_multi_callable(self._channel)+    self._stream_unary = _stream_unary_multi_callable(self._channel)+    self._stream_stream = _stream_stream_multi_callable(self._channel)++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    with self.assertRaises(ValueError) as exception_context:+      self._unary_unary(request, metadata=metadata)+    self.assertEqual(+        expected_error_details, exception_context.exception.message)++  def testUnaryRequestBlockingUnaryResponseWithCall(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponseWithCall'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    with self.assertRaises(ValueError) as exception_context:+      self._unary_unary.with_call(request, metadata=metadata)+    self.assertEqual(+        expected_error_details, exception_context.exception.message)++  def testUnaryRequestFutureUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestFutureUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    response_future = self._unary_unary.future(request, metadata=metadata)+    with self.assertRaises(grpc.RpcError) as exception_context:+      response_future.result()+    self.assertEqual(+        exception_context.exception.details(), expected_error_details)+    self.assertEqual(+        exception_context.exception.code(), grpc.StatusCode.INTERNAL)+    self.assertEqual(response_future.details(), expected_error_details)+    self.assertEqual(response_future.code(), grpc.StatusCode.INTERNAL)++  def testUnaryRequestStreamResponse(self):+    request = b'\x37\x58'+    metadata = (('InVaLiD', 'UnaryRequestStreamResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    response_iterator = self._unary_stream(request, metadata=metadata)+    with self.assertRaises(grpc.RpcError) as exception_context:+      tuple(response_iterator)","By changing this from `tuple` to `next` you again narrow the execution from which you are asserting that an exception must rise (from ""an exception arises from consuming the entire stream of responses (including the end-of-stream indicator)"" to ""an exception arises from consuming the very first response in the response stream"").",
17460127,y-zeng,https://api.github.com/repos/grpc/grpc/pulls/8789,92714694,2016-12-15T22:31:26Z,src/core/ext/client_channel/resolver.h,"@@ -36,13 +36,15 @@  #include ""src/core/ext/client_channel/subchannel.h"" #include ""src/core/lib/iomgr/iomgr.h""+#include ""src/core/lib/iomgr/pollset_set.h""  typedef struct grpc_resolver grpc_resolver; typedef struct grpc_resolver_vtable grpc_resolver_vtable;  /** \a grpc_resolver provides \a grpc_channel_args objects to its caller */ struct grpc_resolver {   const grpc_resolver_vtable *vtable;+  grpc_pollset_set *pollset_set;","Removed `pollset_set` from the `grpc_resolver` struct, added it as a parameter of `grpc_resolver_create()`.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/9132,92721422,2016-12-15T23:14:25Z,examples/python/multiplex/route_guide_pb2_grpc.py,"@@ -0,0 +1,121 @@+import grpc+from grpc.framework.common import cardinality+from grpc.framework.interfaces.face import utilities as face_utilities++import route_guide_pb2 as route__guide__pb2","@soltanmm-google: this is [issue 9058](https://github.com/grpc/grpc/issues/9058), right? Do we know when it might happen?@kpayson64: I'd like to move forward with this now given that I think there's a much greater difference between what's in source control now and this draft of the code than there is between this draft of the code and what users will see when the import duplication problem is fixed. Also yes to another example code update after the import duplication problem is fixed.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8693,92721713,2016-12-15T23:16:35Z,src/cpp/ext/proto_server_reflection.cc,"@@ -117,9 +117,9 @@ Status ProtoServerReflection::ListService(ServerContext* context,   if (services_ == nullptr) {     return Status(StatusCode::NOT_FOUND, ""Services not found."");   }-  for (auto it = services_->begin(); it != services_->end(); ++it) {+  for (auto value : services_) {","The semantics of the old version are best maintained, IMO, if this is `const auto& value` , since I'm not sure if the compiler will automatically set this otherwise.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8693,92721856,2016-12-15T23:17:43Z,src/cpp/server/server_builder.cc,"@@ -60,9 +60,8 @@ ServerBuilder::ServerBuilder()       resource_quota_(nullptr),       generic_service_(nullptr) {   gpr_once_init(&once_init_plugin_list, do_plugin_list_init);-  for (auto it = g_plugin_factory_list->begin();-       it != g_plugin_factory_list->end(); it++) {-    auto& factory = *it;+  for (auto value : g_plugin_factory_list) {+    auto& factory = value;",This line is no longer needed,
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/8693,92722262,2016-12-15T23:20:50Z,src/cpp/server/server_builder.cc,"@@ -180,13 +179,13 @@ ServerBuilder& ServerBuilder::AddListeningPort(  std::unique_ptr<Server> ServerBuilder::BuildAndStart() {   ChannelArguments args;-  for (auto option = options_.begin(); option != options_.end(); ++option) {-    (*option)->UpdateArguments(&args);-    (*option)->UpdatePlugins(&plugins_);+  for (auto option : options_) {",There are several other examples of the above issue that I haven't listed.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8686,92727619,2016-12-16T00:05:07Z,src/python/grpcio/grpc/_channel.py,"@@ -197,7 +198,16 @@ def _consume_request_iterator(   event_handler = _event_handler(state, call, None)    def consume_request_iterator():-    for request in request_iterator:+    while True:+      try:+        request = next(request_iterator)+      except StopIteration:+        break+      except Exception as e:+        logging.exception(""Exception iterating requests; {}"".format(e))",No need to include the exception itself in the message being logged.,
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8686,92729458,2016-12-16T00:22:27Z,src/python/grpcio_tests/tests/unit/_invocation_defects_test.py,"@@ -0,0 +1,244 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++class _Callback(object):+  def __init__(self):+    self._condition = threading.Condition()+    self._value = None+    self._called = False++  def __call__(self, value):+    with self._condition:+      self._value = value+      self._called = True+      self._condition.notify_all()++  def value(self):+    with self._condition:+      while not self._called:+        self._condition.wait()+      return self._value+++class _Handler(object):+  def __init__(self, control):+    self._control = control++  def handle_unary_unary(self, request, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return request++  def handle_unary_stream(self, request, servicer_context):+    for _ in range(test_constants.STREAM_LENGTH):+      self._control.control()+      yield request+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))++  def handle_stream_unary(self, request_iterator, servicer_context):+    if servicer_context is not None:+      servicer_context.invocation_metadata()+    self._control.control()+    response_elements = []+    for request in request_iterator:+      self._control.control()+      response_elements.append(request)+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return b''.join(response_elements)++  def handle_stream_stream(self, request_iterator, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    for request in request_iterator:+      self._control.control()+      yield request+    self._control.control()+++class _MethodHandler(grpc.RpcMethodHandler):+  def __init__(+    self, request_streaming, response_streaming, request_deserializer,+    response_serializer, unary_unary, unary_stream, stream_unary,+    stream_stream):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = request_deserializer+    self.response_serializer = response_serializer+    self.unary_unary = unary_unary+    self.unary_stream = unary_stream+    self.stream_unary = stream_unary+    self.stream_stream = stream_stream+++class _GenericHandler(grpc.GenericRpcHandler):+  def __init__(self, handler):+    self._handler = handler++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(+        False, False, None, None, self._handler.handle_unary_unary, None,+        None, None)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(+        False, True, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None,+        self._handler.handle_unary_stream, None, None)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(+        True, False, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None, None,+        self._handler.handle_stream_unary, None)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(+        True, True, None, None, None, None, None,+        self._handler.handle_stream_stream)+    else:+      return None+++class FailAfterFewIterationsCounter(object):+    def __init__(self, high):+        self._current = 0+        self._high = high++    def __iter__(self):+        return self++    def __next__(self):+        if self._current > self._high:","Change to `>=` here - it's too weird to pass something a parameter of seven, see it emit eight values, and then fail on the ninth attempt.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8686,92729574,2016-12-16T00:23:40Z,src/python/grpcio_tests/tests/unit/_invocation_defects_test.py,"@@ -0,0 +1,244 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++class _Callback(object):+  def __init__(self):+    self._condition = threading.Condition()+    self._value = None+    self._called = False++  def __call__(self, value):+    with self._condition:+      self._value = value+      self._called = True+      self._condition.notify_all()++  def value(self):+    with self._condition:+      while not self._called:+        self._condition.wait()+      return self._value+++class _Handler(object):+  def __init__(self, control):+    self._control = control++  def handle_unary_unary(self, request, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return request++  def handle_unary_stream(self, request, servicer_context):+    for _ in range(test_constants.STREAM_LENGTH):+      self._control.control()+      yield request+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))++  def handle_stream_unary(self, request_iterator, servicer_context):+    if servicer_context is not None:+      servicer_context.invocation_metadata()+    self._control.control()+    response_elements = []+    for request in request_iterator:+      self._control.control()+      response_elements.append(request)+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return b''.join(response_elements)++  def handle_stream_stream(self, request_iterator, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    for request in request_iterator:+      self._control.control()+      yield request+    self._control.control()+++class _MethodHandler(grpc.RpcMethodHandler):+  def __init__(+    self, request_streaming, response_streaming, request_deserializer,+    response_serializer, unary_unary, unary_stream, stream_unary,+    stream_stream):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = request_deserializer+    self.response_serializer = response_serializer+    self.unary_unary = unary_unary+    self.unary_stream = unary_stream+    self.stream_unary = stream_unary+    self.stream_stream = stream_stream+++class _GenericHandler(grpc.GenericRpcHandler):+  def __init__(self, handler):+    self._handler = handler++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(+        False, False, None, None, self._handler.handle_unary_unary, None,+        None, None)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(+        False, True, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None,+        self._handler.handle_unary_stream, None, None)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(+        True, False, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None, None,+        self._handler.handle_stream_unary, None)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(+        True, True, None, None, None, None, None,+        self._handler.handle_stream_stream)+    else:+      return None+++class FailAfterFewIterationsCounter(object):+    def __init__(self, high):+        self._current = 0+        self._high = high++    def __iter__(self):+        return self++    def __next__(self):+        if self._current > self._high:+            raise Exception(""This is a deliberate failure in a unit test."")+        else:+            self._current += 1+            return self._current - 1","Doesn't the return value of this method need to be a message of some sort? Not an integer, right? Should `FailAfterFewIterationsCounter` take as a construction parameter the message value to be returned form this method?A byte string?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8686,92732786,2016-12-16T00:55:03Z,src/python/grpcio_tests/tests/unit/_invocation_defects_test.py,"@@ -0,0 +1,247 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++class _Callback(object):+  def __init__(self):+    self._condition = threading.Condition()+    self._value = None+    self._called = False++  def __call__(self, value):+    with self._condition:+      self._value = value+      self._called = True+      self._condition.notify_all()++  def value(self):+    with self._condition:+      while not self._called:+        self._condition.wait()+      return self._value+++class _Handler(object):+  def __init__(self, control):+    self._control = control++  def handle_unary_unary(self, request, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return request++  def handle_unary_stream(self, request, servicer_context):+    for _ in range(test_constants.STREAM_LENGTH):+      self._control.control()+      yield request+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))++  def handle_stream_unary(self, request_iterator, servicer_context):+    if servicer_context is not None:+      servicer_context.invocation_metadata()+    self._control.control()+    response_elements = []+    for request in request_iterator:+      self._control.control()+      response_elements.append(request)+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return b''.join(response_elements)++  def handle_stream_stream(self, request_iterator, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    for request in request_iterator:+      self._control.control()+      yield request+    self._control.control()+++class _MethodHandler(grpc.RpcMethodHandler):+  def __init__(+    self, request_streaming, response_streaming, request_deserializer,+    response_serializer, unary_unary, unary_stream, stream_unary,+    stream_stream):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = request_deserializer+    self.response_serializer = response_serializer+    self.unary_unary = unary_unary+    self.unary_stream = unary_stream+    self.stream_unary = stream_unary+    self.stream_stream = stream_stream+++class _GenericHandler(grpc.GenericRpcHandler):+  def __init__(self, handler):+    self._handler = handler++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(+        False, False, None, None, self._handler.handle_unary_unary, None,+        None, None)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(+        False, True, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None,+        self._handler.handle_unary_stream, None, None)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(+        True, False, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None, None,+        self._handler.handle_stream_unary, None)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(+        True, True, None, None, None, None, None,+        self._handler.handle_stream_stream)+    else:+      return None+++class FailAfterFewIterationsCounter(object):+    def __init__(self, high, bytestring):+        self._current = 0+        self._high = high+        self._bytestring = bytestring++    def __iter__(self):+        return self++    def __next__(self):+        if self._current >= self._high:+            raise Exception(""This is a deliberate failure in a unit test."")+        else:+            self._current += 1+            return self._bytestring+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+    _UNARY_STREAM,+    request_serializer=_SERIALIZE_REQUEST,+    response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+    _STREAM_UNARY,+    request_serializer=_SERIALIZE_REQUEST,+    response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class InvocationDefectsTest(unittest.TestCase):+  def setUp(self):+    self._control = test_control.PauseFailControl()+    self._handler = _Handler(self._control)+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)++    self._server = grpc.server(self._server_pool)+    port = self._server.add_insecure_port('[::]:0')+    self._server.add_generic_rpc_handlers((_GenericHandler(self._handler),))+    self._server.start()++    self._channel = grpc.insecure_channel('localhost:%d' % port)++  def tearDown(self):+    self._server.stop(0)++  def testIterableStreamRequestBlockingUnaryResponse(self):+    requests = [b'\x07\x08' for _ in range(test_constants.STREAM_LENGTH)]+    multi_callable = _stream_unary_multi_callable(self._channel)++    with self.assertRaises(grpc.RpcError):+      response = multi_callable(+        requests,+        metadata=(('test', 'IterableStreamRequestBlockingUnaryResponse'),))++  def testIterableStreamRequestFutureUnaryResponse(self):+    requests = [b'\x07\x08' for _ in range(test_constants.STREAM_LENGTH)]+    multi_callable = _stream_unary_multi_callable(self._channel)+    response_future = multi_callable.future(+      requests,+      metadata=(+        ('test', 'IterableStreamRequestFutureUnaryResponse'),))++    with self.assertRaises(grpc.RpcError):+      response = response_future.result()++  def testIterableStreamRequestStreamResponse(self):+    requests = [b'\x77\x58' for _ in range(test_constants.STREAM_LENGTH)]+    multi_callable = _stream_stream_multi_callable(self._channel)+    response_iterator = multi_callable(+      requests,+      metadata=(('test', 'IterableStreamRequestStreamResponse'),))++    with self.assertRaises(grpc.RpcError):+      next(response_iterator)++  def testIteratorStreamRequestStreamResponse(self):+    requests_iterator = FailAfterFewIterationsCounter(+      test_constants.STREAM_LENGTH // 2, b'\x07\x08')+    multi_callable = _stream_stream_multi_callable(self._channel)+    response_iterator = multi_callable(+      requests_iterator,+      metadata=(('test', 'IteratorStreamRequestStreamResponse'),))++    with self.assertRaises(grpc.RpcError):+      for _ in range(test_constants.STREAM_LENGTH // 2):","Missing ` + 1` here. Just to go over the race condition again:* Test thread starts RPC, passing a `FailAfterFewIterationsCounter(N)` which when iterated over will emit N messages and then raise an exception when asked for the N+1th message.* Invocation-side gRPC Python spawns request-consumer thread.* Request-consumer thread consumes exactly N request values from your `FailAfterFewIterationsCounter`, sending them to the server.* Request-consumer thread is preempted.* Server responds to N request values by sending N response values.* Test thread enters `with` statement, executes entire `for` statement (which loops exactly N times), and exits `with` statement without an exception.* On exiting `with` statement without an exception, test fails.* Request consumption thread gets to run again, attempts to get N+1th request, and sees an exception raised by your `FailAfterFewIterationsCounter`.Reread the steps a few times and tell me where I'm wrong?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8686,92733373,2016-12-16T01:00:40Z,src/python/grpcio_tests/tests/unit/_invocation_defects_test.py,"@@ -0,0 +1,247 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++import itertools+import threading+import unittest+from concurrent import futures++import grpc+from grpc.framework.foundation import logging_pool++from tests.unit.framework.common import test_constants+from tests.unit.framework.common import test_control++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++class _Callback(object):+  def __init__(self):+    self._condition = threading.Condition()+    self._value = None+    self._called = False++  def __call__(self, value):+    with self._condition:+      self._value = value+      self._called = True+      self._condition.notify_all()++  def value(self):+    with self._condition:+      while not self._called:+        self._condition.wait()+      return self._value+++class _Handler(object):+  def __init__(self, control):+    self._control = control++  def handle_unary_unary(self, request, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return request++  def handle_unary_stream(self, request, servicer_context):+    for _ in range(test_constants.STREAM_LENGTH):+      self._control.control()+      yield request+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))++  def handle_stream_unary(self, request_iterator, servicer_context):+    if servicer_context is not None:+      servicer_context.invocation_metadata()+    self._control.control()+    response_elements = []+    for request in request_iterator:+      self._control.control()+      response_elements.append(request)+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    return b''.join(response_elements)++  def handle_stream_stream(self, request_iterator, servicer_context):+    self._control.control()+    if servicer_context is not None:+      servicer_context.set_trailing_metadata((('testkey', 'testvalue',),))+    for request in request_iterator:+      self._control.control()+      yield request+    self._control.control()+++class _MethodHandler(grpc.RpcMethodHandler):+  def __init__(+    self, request_streaming, response_streaming, request_deserializer,+    response_serializer, unary_unary, unary_stream, stream_unary,+    stream_stream):+    self.request_streaming = request_streaming+    self.response_streaming = response_streaming+    self.request_deserializer = request_deserializer+    self.response_serializer = response_serializer+    self.unary_unary = unary_unary+    self.unary_stream = unary_stream+    self.stream_unary = stream_unary+    self.stream_stream = stream_stream+++class _GenericHandler(grpc.GenericRpcHandler):+  def __init__(self, handler):+    self._handler = handler++  def service(self, handler_call_details):+    if handler_call_details.method == _UNARY_UNARY:+      return _MethodHandler(+        False, False, None, None, self._handler.handle_unary_unary, None,+        None, None)+    elif handler_call_details.method == _UNARY_STREAM:+      return _MethodHandler(+        False, True, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None,+        self._handler.handle_unary_stream, None, None)+    elif handler_call_details.method == _STREAM_UNARY:+      return _MethodHandler(+        True, False, _DESERIALIZE_REQUEST, _SERIALIZE_RESPONSE, None, None,+        self._handler.handle_stream_unary, None)+    elif handler_call_details.method == _STREAM_STREAM:+      return _MethodHandler(+        True, True, None, None, None, None, None,+        self._handler.handle_stream_stream)+    else:+      return None+++class FailAfterFewIterationsCounter(object):+    def __init__(self, high, bytestring):+        self._current = 0+        self._high = high+        self._bytestring = bytestring++    def __iter__(self):+        return self++    def __next__(self):+        if self._current >= self._high:+            raise Exception(""This is a deliberate failure in a unit test."")+        else:+            self._current += 1+            return self._bytestring+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+    _UNARY_STREAM,+    request_serializer=_SERIALIZE_REQUEST,+    response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+    _STREAM_UNARY,+    request_serializer=_SERIALIZE_REQUEST,+    response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class InvocationDefectsTest(unittest.TestCase):+  def setUp(self):+    self._control = test_control.PauseFailControl()+    self._handler = _Handler(self._control)+    self._server_pool = logging_pool.pool(test_constants.THREAD_CONCURRENCY)++    self._server = grpc.server(self._server_pool)+    port = self._server.add_insecure_port('[::]:0')+    self._server.add_generic_rpc_handlers((_GenericHandler(self._handler),))+    self._server.start()++    self._channel = grpc.insecure_channel('localhost:%d' % port)++  def tearDown(self):+    self._server.stop(0)++  def testIterableStreamRequestBlockingUnaryResponse(self):+    requests = [b'\x07\x08' for _ in range(test_constants.STREAM_LENGTH)]+    multi_callable = _stream_unary_multi_callable(self._channel)++    with self.assertRaises(grpc.RpcError):+      response = multi_callable(+        requests,+        metadata=(('test', 'IterableStreamRequestBlockingUnaryResponse'),))++  def testIterableStreamRequestFutureUnaryResponse(self):+    requests = [b'\x07\x08' for _ in range(test_constants.STREAM_LENGTH)]+    multi_callable = _stream_unary_multi_callable(self._channel)+    response_future = multi_callable.future(+      requests,+      metadata=(+        ('test', 'IterableStreamRequestFutureUnaryResponse'),))++    with self.assertRaises(grpc.RpcError):+      response = response_future.result()++  def testIterableStreamRequestStreamResponse(self):+    requests = [b'\x77\x58' for _ in range(test_constants.STREAM_LENGTH)]+    multi_callable = _stream_stream_multi_callable(self._channel)+    response_iterator = multi_callable(+      requests,+      metadata=(('test', 'IterableStreamRequestStreamResponse'),))++    with self.assertRaises(grpc.RpcError):+      next(response_iterator)++  def testIteratorStreamRequestStreamResponse(self):+    requests_iterator = FailAfterFewIterationsCounter(+      test_constants.STREAM_LENGTH // 2, b'\x07\x08')+    multi_callable = _stream_stream_multi_callable(self._channel)+    response_iterator = multi_callable(+      requests_iterator,+      metadata=(('test', 'IteratorStreamRequestStreamResponse'),))++    with self.assertRaises(grpc.RpcError):+      for _ in range(test_constants.STREAM_LENGTH // 2):","Or to look at the flip side:* The N+1th `next(response_iterator)` call will block until after the server has sent the N+1th response.* The server will not send the N+1th response until after it has received the N+1th request.* The client will not send the N+1th request until after it has obtained it from your `FailAfterFewIterationsCounter`.* Your `FailAfterFewIterationsCounter` will never emit the N+1th request; it will raise an exception when asked for the N+1th request.So it's those strict not-until-after (also see ""happens-before"" in the academic literature) relationships that build a wall between deterministic test runs that are guaranteed to pass and nondeterministic racy test runs that happen to pass.Any more clear when examined this way?",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/8686,92734123,2016-12-16T01:08:44Z,src/python/grpcio/grpc/_channel.py,"@@ -197,7 +198,16 @@ def _consume_request_iterator(   event_handler = _event_handler(state, call, None)    def consume_request_iterator():-    for request in request_iterator:+    while True:+      try:+        request = next(request_iterator)+      except StopIteration:+        break+      except Exception as e:+        logging.exception(""Exception iterating requests"")","Let's keep the exclamation point at the end of this message.Also: whoa, I'm a hypocrite! ☹️ The other calls to `logging.exception` throughout the codebase do include the exception in the format string. 😦My apologies for providing poor examples to follow.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/9136,92767265,2016-12-16T07:58:31Z,src/cpp/server/secure_server_credentials.cc,"@@ -103,6 +104,13 @@ void AuthMetadataProcessorAyncWrapper::InvokeProcessor(   }   auto consumed_md_data = consumed_md.empty() ? nullptr : &consumed_md[0];   auto response_md_data = response_md.empty() ? nullptr : &response_md[0];++  // Instantiate GrpcLibraryCodegen to call grpc_init()/grpc_shutdown().+  // We need this here because this whole method will be invoked asynchronously,+  // potentially after all grpc_shutdown()s have been called. Because ""cb"" below+  // is an arbitrary callback, we need to ensure it's called with the grpc+  // library properly initialized.+  GrpcLibraryCodegen init;",Is it better to make AuthMetadataProcessorAyncWrapper inherit from it?,
120217,dgquintas,https://api.github.com/repos/grpc/grpc/pulls/9136,92775695,2016-12-16T09:14:15Z,src/cpp/server/secure_server_credentials.cc,"@@ -103,6 +104,13 @@ void AuthMetadataProcessorAyncWrapper::InvokeProcessor(   }   auto consumed_md_data = consumed_md.empty() ? nullptr : &consumed_md[0];   auto response_md_data = response_md.empty() ? nullptr : &response_md[0];++  // Instantiate GrpcLibraryCodegen to call grpc_init()/grpc_shutdown().+  // We need this here because this whole method will be invoked asynchronously,+  // potentially after all grpc_shutdown()s have been called. Because ""cb"" below+  // is an arbitrary callback, we need to ensure it's called with the grpc+  // library properly initialized.+  GrpcLibraryCodegen init;","That won't help. I need to improve the comment, but what happens is that a callback can be scheduled, the instance of AuthMetadataProcessorAyncWrapper be destroyed, the callback run and kaboom. Note that there's no ""join"" method or anything similar in the thread pools used. The moment a callback is scheduled it's effectively a detached thread.In the case of the end2end test, the callback in question belongs to a straggler thread from a previous test case (it can be seen with enough logging), but it could still happen in real code based on how detached the lifetime of scheduled threads is from that of the objects doing the scheduling.A more effective way of handling this would be with reference counting, making the scheduled cb responsible for unreffing the resource (in this case, the init/shutdown)",
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/9128,92879248,2016-12-16T20:18:31Z,doc/negative-http2-interop-test-descriptions.md,"@@ -0,0 +1,193 @@+Negative HTTP/2 Interop Test Case Descriptions+=======================================++Client and server use+[test.proto](../src/proto/grpc/testing/test.proto).++Server+------+The code for the custom http2 server can be found+[here](https://github.com/grpc/grpc/tree/master/test/http2_test).+It is responsible for handling requests and sending responses, and also for +fulfilling the behavior of each particular test case.++Server should accept these arguments:+* --port=PORT+  * The port the server will run on. For example, ""8080""+* --test_case=TESTCASE+  * The name of the test case to execute. For example, ""goaway""++Client+------++Clients implement test cases that test certain functionally. Each client is+provided the test case it is expected to run as a command-line parameter. Names+should be lowercase and without spaces.++Clients should accept these arguments:+* --server_host=HOSTNAME+    * The server host to connect to. For example, ""localhost"" or ""127.0.0.1""+* --server_port=PORT+    * The server port to connect to. For example, ""8080""+* --test_case=TESTCASE+    * The name of the test case to execute. For example, ""goaway""++Note+-----++Note that the server and client must be invoked with the same test case or else+the test will be meaningless. For convenience, we provide a shell script wrapper+that invokes both server and client at the same time, with the same test_case.+This is the preferred way to run these tests.++## Test Cases++### goaway++This test verifies that the client correctly responds to a goaway sent by the+server. The client should handle the goaway by switching to a new stream without+the user application having to do a thing.++Client Procedure:+ 1. Client sends two UnaryCall requests with:+ +     ```+    {+      response_size: 1024",Let's standardize these to use the same response_size and payload as the large_unary interop test case.,
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/9128,92881421,2016-12-16T20:34:22Z,doc/negative-http2-interop-test-descriptions.md,"@@ -0,0 +1,193 @@+Negative HTTP/2 Interop Test Case Descriptions+=======================================++Client and server use+[test.proto](../src/proto/grpc/testing/test.proto).++Server+------+The code for the custom http2 server can be found+[here](https://github.com/grpc/grpc/tree/master/test/http2_test).+It is responsible for handling requests and sending responses, and also for +fulfilling the behavior of each particular test case.++Server should accept these arguments:+* --port=PORT+  * The port the server will run on. For example, ""8080""+* --test_case=TESTCASE+  * The name of the test case to execute. For example, ""goaway""++Client+------++Clients implement test cases that test certain functionally. Each client is+provided the test case it is expected to run as a command-line parameter. Names+should be lowercase and without spaces.++Clients should accept these arguments:+* --server_host=HOSTNAME+    * The server host to connect to. For example, ""localhost"" or ""127.0.0.1""+* --server_port=PORT+    * The server port to connect to. For example, ""8080""+* --test_case=TESTCASE+    * The name of the test case to execute. For example, ""goaway""++Note+-----++Note that the server and client must be invoked with the same test case or else+the test will be meaningless. For convenience, we provide a shell script wrapper+that invokes both server and client at the same time, with the same test_case.+This is the preferred way to run these tests.++## Test Cases++### goaway++This test verifies that the client correctly responds to a goaway sent by the+server. The client should handle the goaway by switching to a new stream without+the user application having to do a thing.++Client Procedure:+ 1. Client sends two UnaryCall requests with:+ +     ```+    {+      response_size: 1024+      payload:{+        body: 1024 bytes of zeros+      }+    }+    ```++Client asserts:+* call was successful.+* response payload body is 1024 bytes in size.++Server Procedure:+  1. Server sends a GOAWAY after receiving the first UnaryCall.++Server asserts:+* The second UnaryCall has a different stream_id than the first one.++### rst_after_header++This test verifies that the client fails ""correctly"" when the server sends a+RST_STREAM immediately after sending headers to the client.++Procedure:+ 1. Client sends UnaryCall with:+ +  ```+  {+    response_size: 1024+    payload:{+      body: 1024 bytes of zeros+    }+  }+  ```++Client asserts:+* Call was not successful++Server Procedure:+  1. Server sends a RST_STREAM with error code 0 after sending headers to the client.+  +*At the moment the error code and message returned are not standardized throughout all+languages. Those checks will be added once all client languages behave the same way.*++### rst_during_data++This test verifies that the client fails ""correctly"" when the server sends a+RST_STREAM halfway through sending data to the client.++Procedure:+ 1. Client sends UnaryCall with:+ +  ```+  {+    response_size: 1024+    payload:{+      body: 1024 bytes of zeros+    }+  }+  ```++Client asserts:+* Call was not successful++Server Procedure:+  1. Server sends a RST_STREAM with error code 0 after sending half of +     the requested data to the client.++### rst_after_data++This test verifies that the client fails ""correctly"" when the server sends a+RST_STREAM after sending all of the data to the client.++Procedure:+ 1. Client sends UnaryCall with:+  ```+  {+    response_size: 1024+    payload:{+      body: 1024 bytes of zeros+    }+  }","This code block is all showing on one line in Github's preview: https://github.com/ncteisen/grpc/blob/fcb2d1470664419a79692610f9aa60587f0aedc1/doc/negative-http2-interop-test-descriptions.mdIt's fine in other markdown editor previews, not sure if it needs a newline before the start of the codeblock or something else is happening?",
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/9128,92881608,2016-12-16T20:35:29Z,doc/negative-http2-interop-test-descriptions.md,"@@ -0,0 +1,193 @@+Negative HTTP/2 Interop Test Case Descriptions+=======================================++Client and server use+[test.proto](../src/proto/grpc/testing/test.proto).++Server+------+The code for the custom http2 server can be found+[here](https://github.com/grpc/grpc/tree/master/test/http2_test).+It is responsible for handling requests and sending responses, and also for +fulfilling the behavior of each particular test case.++Server should accept these arguments:+* --port=PORT+  * The port the server will run on. For example, ""8080""+* --test_case=TESTCASE+  * The name of the test case to execute. For example, ""goaway""++Client+------++Clients implement test cases that test certain functionally. Each client is+provided the test case it is expected to run as a command-line parameter. Names+should be lowercase and without spaces.++Clients should accept these arguments:+* --server_host=HOSTNAME+    * The server host to connect to. For example, ""localhost"" or ""127.0.0.1""+* --server_port=PORT+    * The server port to connect to. For example, ""8080""+* --test_case=TESTCASE+    * The name of the test case to execute. For example, ""goaway""++Note+-----++Note that the server and client must be invoked with the same test case or else+the test will be meaningless. For convenience, we provide a shell script wrapper+that invokes both server and client at the same time, with the same test_case.+This is the preferred way to run these tests.++## Test Cases++### goaway++This test verifies that the client correctly responds to a goaway sent by the+server. The client should handle the goaway by switching to a new stream without+the user application having to do a thing.++Client Procedure:+ 1. Client sends two UnaryCall requests with:+ +     ```+    {+      response_size: 1024+      payload:{+        body: 1024 bytes of zeros+      }+    }+    ```++Client asserts:+* call was successful.+* response payload body is 1024 bytes in size.++Server Procedure:+  1. Server sends a GOAWAY after receiving the first UnaryCall.++Server asserts:+* The second UnaryCall has a different stream_id than the first one.++### rst_after_header++This test verifies that the client fails ""correctly"" when the server sends a+RST_STREAM immediately after sending headers to the client.++Procedure:+ 1. Client sends UnaryCall with:+ +  ```+  {+    response_size: 1024+    payload:{+      body: 1024 bytes of zeros+    }+  }+  ```++Client asserts:+* Call was not successful++Server Procedure:+  1. Server sends a RST_STREAM with error code 0 after sending headers to the client.+  +*At the moment the error code and message returned are not standardized throughout all+languages. Those checks will be added once all client languages behave the same way.*++### rst_during_data++This test verifies that the client fails ""correctly"" when the server sends a+RST_STREAM halfway through sending data to the client.++Procedure:+ 1. Client sends UnaryCall with:+ +  ```+  {+    response_size: 1024+    payload:{+      body: 1024 bytes of zeros+    }+  }+  ```++Client asserts:+* Call was not successful++Server Procedure:+  1. Server sends a RST_STREAM with error code 0 after sending half of +     the requested data to the client.++### rst_after_data++This test verifies that the client fails ""correctly"" when the server sends a+RST_STREAM after sending all of the data to the client.++Procedure:+ 1. Client sends UnaryCall with:+  ```+  {+    response_size: 1024+    payload:{+      body: 1024 bytes of zeros+    }+  }+  ```++Client asserts:+* Call was not successful++Server Procedure:+  1. Server sends a RST_STREAM with error code 0 after sending all of the+  data to the client.++*Certain client languages allow the data to be accessed even though a RST_STREAM+was encountered. Once all client languages behave this way, checks will be added on+the incoming data.*","I thought all languages could access the incoming data via the async API? Either way, we can resolve this later.",
961599,murgatroid99,https://api.github.com/repos/grpc/grpc/pulls/9145,92900299,2016-12-16T22:56:43Z,src/ruby/spec/generic/rpc_server_spec.rb,"@@ -414,8 +414,8 @@ def an_rpc(req, call)             stub = SlowStub.new(alt_host, :this_channel_is_insecure)             begin               stub.an_rpc(req)-            rescue GRPC::BadStatus => e-              bad_status_code = e.code+            rescue GRPC::ResourceExhausted+              one_failed_as_unavailable = true","Something is definitely off with this merge. This line changes from `bad_status_code` to `one_failed_as_unavailable`, but the check on line 425 still looks at `bad_status_code`.",
6081171,thunderboltsid,https://api.github.com/repos/grpc/grpc/pulls/8686,92901886,2016-12-16T23:12:07Z,src/python/grpcio_tests/tests/tests.json,"@@ -25,7 +25,8 @@   ""_implementations_test.CallCredentialsTest"",   ""_implementations_test.ChannelCredentialsTest"",   ""_insecure_interop_test.InsecureInteropTest"",-  ""_invalid_metadata_test.InvalidMetadataTest""+  ""_invalid_metadata_test.InvalidMetadataTest"",",@nathanielmanistaatgoogle It's an artefact of the string missing a comma delimiter at the end of the line on the current v1.0.x head. https://github.com/grpc/grpc/blob/v1.0.x/src/python/grpcio_tests/tests/tests.json#L28,
14932100,adelez,https://api.github.com/repos/grpc/grpc/pulls/9097,92906334,2016-12-17T00:03:42Z,src/python/grpcio_tests/tests/http2/_negative_http2_client.py,"@@ -0,0 +1,158 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""The Python client used to test negative http2 conditions.""""""++import argparse++import grpc+from src.proto.grpc.testing import test_pb2+from src.proto.grpc.testing import messages_pb2++def _validate_payload_type_and_length(response, expected_type, expected_length):+  if response.payload.type is not expected_type:+    raise ValueError(+      'expected payload type %s, got %s' %+          (expected_type, type(response.payload.type)))+  elif len(response.payload.body) != expected_length:+    raise ValueError(+      'expected payload body size %d, got %d' %+          (expected_length, len(response.payload.body)))++def _expect_status_code(call, expected_code):+  if call.code() != expected_code:+    raise ValueError(+      'expected code %s, got %s' % (expected_code, call.code()))++def _expect_status_details(call, expected_details):+  if call.details() != expected_details:+    raise ValueError(+      'expected message %s, got %s' % (expected_details, call.details()))++def _validate_status_code_and_details(call, expected_code, expected_details):+  _expect_status_code(call, expected_code)+  _expect_status_details(call, expected_details)++# common requests+_SMALL_SIZE = 1024+_LARGE_SIZE = 314159++_SMALL_SIMPLE_REQUEST = messages_pb2.SimpleRequest(","According to the doc https://github.com/ncteisen/grpc/blob/0eb69186f0b22f0e4bd5d6f1b4e31252bf614b76/doc/negative-http2-interop-test-descriptions.md, the request size is 271828.",
10131044,nathanielmanistaatgoogle,https://api.github.com/repos/grpc/grpc/pulls/9145,92909987,2016-12-17T01:01:28Z,src/python/grpcio_tests/tests/unit/_invalid_metadata_test.py,"@@ -0,0 +1,175 @@+# Copyright 2016, Google Inc.+# All rights reserved.+#+# Redistribution and use in source and binary forms, with or without+# modification, are permitted provided that the following conditions are+# met:+#+#     * Redistributions of source code must retain the above copyright+# notice, this list of conditions and the following disclaimer.+#     * Redistributions in binary form must reproduce the above+# copyright notice, this list of conditions and the following disclaimer+# in the documentation and/or other materials provided with the+# distribution.+#     * Neither the name of Google Inc. nor the names of its+# contributors may be used to endorse or promote products derived from+# this software without specific prior written permission.+#+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.++""""""Test of RPCs made against gRPC Python's application-layer API.""""""++import unittest++import grpc++from tests.unit.framework.common import test_constants++_SERIALIZE_REQUEST = lambda bytestring: bytestring * 2+_DESERIALIZE_REQUEST = lambda bytestring: bytestring[len(bytestring) // 2:]+_SERIALIZE_RESPONSE = lambda bytestring: bytestring * 3+_DESERIALIZE_RESPONSE = lambda bytestring: bytestring[:len(bytestring) // 3]++_UNARY_UNARY = '/test/UnaryUnary'+_UNARY_STREAM = '/test/UnaryStream'+_STREAM_UNARY = '/test/StreamUnary'+_STREAM_STREAM = '/test/StreamStream'+++def _unary_unary_multi_callable(channel):+  return channel.unary_unary(_UNARY_UNARY)+++def _unary_stream_multi_callable(channel):+  return channel.unary_stream(+      _UNARY_STREAM,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_unary_multi_callable(channel):+  return channel.stream_unary(+      _STREAM_UNARY,+      request_serializer=_SERIALIZE_REQUEST,+      response_deserializer=_DESERIALIZE_RESPONSE)+++def _stream_stream_multi_callable(channel):+  return channel.stream_stream(_STREAM_STREAM)+++class InvalidMetadataTest(unittest.TestCase):++  def setUp(self):+    self._channel = grpc.insecure_channel('localhost:8080')+    self._unary_unary = _unary_unary_multi_callable(self._channel)+    self._unary_stream = _unary_stream_multi_callable(self._channel)+    self._stream_unary = _stream_unary_multi_callable(self._channel)+    self._stream_stream = _stream_stream_multi_callable(self._channel)++  def testUnaryRequestBlockingUnaryResponse(self):+    request = b'\x07\x08'+    metadata = (('InVaLiD', 'UnaryRequestBlockingUnaryResponse'),)+    expected_error_details = ""metadata was invalid: %s"" % metadata+    with self.assertRaises(ValueError) as exception_context:+      self._unary_unary(request, metadata=metadata)+    self.assertIn(expected_error_details, str(exception_context.exception))","Thanks! I want to keep it in this form because I don't want to constrain the system under test to always raise a `ValueError` that always has a certain exact string. This test condition comes close to that, sure, but it at least buys a little flexibility for the system under test.",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/9168,93308039,2016-12-20T19:31:20Z,test/cpp/qps/driver.cc,"@@ -241,8 +242,10 @@ std::unique_ptr<ScenarioResult> RunScenario(     }   } -  // Setup the hosts and core counts-  auto hosts_cores = get_hosts_and_cores(workers);+  std::unordered_map<string, std::deque<int>> hosts_cores;",Maybe this whole variable and its initialization need to be moved down below where it is actually used? That way you are just checking configure_core_lists once down below and then only declaring and setting up this variable if it's needed.,
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/9168,93310658,2016-12-20T19:45:32Z,test/cpp/qps/driver.cc,"@@ -315,11 +317,18 @@ std::unique_ptr<ScenarioResult> RunScenario(     if (!servers[i].stream->Read(&init_status)) {       gpr_log(GPR_ERROR, ""Server %zu did not yield initial status"", i);     }-    gpr_join_host_port(&cli_target, host, init_status.port());-    client_config.add_server_targets(cli_target);-    gpr_free(host);-    gpr_free(driver_port);-    gpr_free(cli_target);+    if (qps_server_target_override != NULL && strlen(qps_server_target_override) > 0) {","Partly I was trying to avoid host-port parsing, but mostly the benefit was to allow configuring of the qps server target when invoking the driver, rather than from info provided by the worker. I could change the parameter to a list?",
8864912,vjpai,https://api.github.com/repos/grpc/grpc/pulls/9168,93345834,2016-12-20T23:14:27Z,test/cpp/qps/driver.cc,"@@ -264,44 +262,47 @@ std::unique_ptr<ScenarioResult> RunScenario(     unique_ptr<ClientReaderWriter<ServerArgs, ServerStatus>> stream;   };   std::vector<ServerData> servers(num_servers);+  std::unordered_map<string, std::deque<int>> hosts_cores;   for (size_t i = 0; i < num_servers; i++) {     gpr_log(GPR_INFO, ""Starting server on %s (worker #%"" PRIuPTR "")"",             workers[i].c_str(), i);     servers[i].stub = WorkerService::NewStub(         CreateChannel(workers[i], InsecureChannelCredentials()));      ServerConfig server_config = initial_server_config;-    char* host;-    char* driver_port;-    char* cli_target;-    gpr_split_host_port(workers[i].c_str(), &host, &driver_port);-    string host_str(host);     int server_core_limit = initial_server_config.core_limit();     int client_core_limit = initial_client_config.core_limit(); -    if (server_core_limit == 0 && client_core_limit > 0) {-      // In this case, limit the server cores if it matches the-      // same host as one or more clients-      const auto& dq = hosts_cores.at(host_str);-      bool match = false;-      int limit = dq.size();-      for (size_t cli = 0; cli < num_clients; cli++) {-        if (host_str == get_host(workers[cli + num_servers])) {-          limit -= client_core_limit;-          match = true;-        }+    if (configure_core_lists) {+      if (i == 0) {+        hosts_cores = get_hosts_and_cores(workers);","Oops, I made a bad suggestion. I guess you should just pull this back out of the loop after all; it's ugly under a nested conditional like this.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/9165,93975155,2016-12-27T22:08:50Z,src/core/ext/census/trace_string.h,"@@ -0,0 +1,43 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_CENSUS_TRACE_STRING_H+#define GRPC_CORE_EXT_CENSUS_TRACE_STRING_H++/* String struct for tracing messages. */","Maybe expand on comment a little? Make it clear that since the C API is really only intended for use by higher level languages, most of which have a string type which knows the length, we can make a more efficient system in general by using this type for string parameters.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/9165,93975602,2016-12-27T22:15:03Z,src/core/ext/census/trace_propagation.h,"@@ -0,0 +1,62 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_CENSUS_TRACE_PROPAGATION_H+#define GRPC_CORE_EXT_CENSUS_TRACE_PROPAGATION_H++#include ""src/core/ext/census/tracing.h""++/* Encoding and decoding functions for receiving and sending propagating data",suggest s/propagating data/trace contexts/,
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/9165,93975688,2016-12-27T22:16:31Z,src/core/ext/census/trace_propagation.h,"@@ -0,0 +1,62 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_CENSUS_TRACE_PROPAGATION_H+#define GRPC_CORE_EXT_CENSUS_TRACE_PROPAGATION_H++#include ""src/core/ext/census/tracing.h""++/* Encoding and decoding functions for receiving and sending propagating data+   over the wire.  Only RPC libraries should be calling these+   functions.  These functions return the number of bytes encoded/decoded+   (0 if a failure has occurred). buf_size indicates the size of the+   input/output buffer. trace_span_context is a struct that includes the+   trace ID, span ID, and a set of option flags (is_sampled, etc.). */++/* Converts a span context to a binary byte buffer. */+size_t trace_span_context_to_binary(const trace_span_context *ctxt, char *buf,+                                    size_t buf_size);++/* Reads a binary byte buffer and populates a span context structure. */+size_t binary_to_trace_span_context(const char *buf, size_t buf_size,+                                    trace_span_context *ctxt);++/* Converts a span context to a http format buffer. */","Expand comments to make it clear that by ""http format"" we mean an ASCII format that can be cleanly sent as HTTP metadata.",
10503072,a-veitch,https://api.github.com/repos/grpc/grpc/pulls/9165,93976240,2016-12-27T22:24:29Z,src/core/ext/census/tracing.h,"@@ -0,0 +1,101 @@+/*+ *+ * Copyright 2016, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_CENSUS_TRACING_H+#define GRPC_CORE_EXT_CENSUS_TRACING_H++#include <grpc/support/time.h>+#include <stdbool.h>+#include ""src/core/ext/census/trace_context.h""+#include ""src/core/ext/census/trace_label.h""+#include ""src/core/ext/census/trace_status.h""++typedef struct trace_span_context {+  /* Trace span context stores Span ID, Trace ID, and option flags. */+  uint64_t trace_id_hi;+  uint64_t trace_id_lo;+  uint64_t span_id;+  uint32_t flags;+} trace_span_context;++typedef struct start_span_options {+  /* If set, this will override the Span.local_start_time for the Span. */+  gpr_timespec local_start_timestamp;++  /* If set, the Spans are linked to the created Span. */+  trace_span_context *linked_spans;+  /* The number of linked spans. */+  size_t n_linked_spans;+} start_span_options;++/* Create a new child Span (or root if parent is NULL), with parent being the+   designated Span. The child span will have the provided name and starting+   span options (optional). The bool has_remote_parent marks whether the+   context refers to a remote parent span or not. */+void trace_start_span(const trace_span_context *span_ctxt,+                      const trace_string name, const start_span_options *opts,+                      trace_span_context *new_span_ctxt,+                      bool has_remote_parent);++/* Add a new Annotation to the Span. The description corresponds to+   Span->annotations[].description. */+void trace_add_span_annotation(const trace_string description,+                               const trace_label *labels, const size_t n_labels,+                               trace_span_context *span_ctxt);++/* Add a new NetworkEvent annotation to a Span. This function is only intended+  to be used by RPC systems (either client or server), not by higher level+  applications. The timestamp type will be system-defined, the sent argument+  designates whether this is a network send event (client request, server+  reply)or receive (server request, client reply). The id argument corresponds+  to Span.Annotation.NetworkEvent.id from the data model, and serves to uniquely","This comment (about the data model) won't make sense to the reader. Please edit, and add a TODO at the top of the file to add a (probably quite long) comment that explains all the concepts used in this API.",
10122250,yang-g,https://api.github.com/repos/grpc/grpc/pulls/9208,94106770,2016-12-29T07:09:01Z,src/core/lib/support/string.c,"@@ -279,7 +279,8 @@ int gpr_stricmp(const char *a, const char *b) { void *gpr_memrchr(const void *s, int c, size_t n) {   if (s == NULL) return NULL;   char *b = (char *)s;-  for (size_t i = 0; i < n; i++) {+  size_t i;",I think we use this pattern in many places. Is this a problem? The source is not c89 :),
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/9246,94896015,2017-01-06T03:41:06Z,test/core/end2end/tests/packet_coalescing.c,"@@ -0,0 +1,288 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */+#include ""test/core/end2end/end2end_tests.h""++#include <stdio.h>+#include <string.h>++#include <grpc/byte_buffer.h>+#include <grpc/support/alloc.h>+#include <grpc/support/log.h>+#include <grpc/support/time.h>+#include <grpc/support/useful.h>+#include ""test/core/end2end/cq_verifier.h""++extern void gpr_default_log(gpr_log_func_args *args);++static void *tag(intptr_t t) { return (void *)t; }++static grpc_end2end_test_fixture begin_test(grpc_end2end_test_config config,+                                            const char *test_name,+                                            grpc_channel_args *client_args,+                                            grpc_channel_args *server_args) {+  grpc_end2end_test_fixture f;+  gpr_log(GPR_INFO, ""%s/%s"", test_name, config.name);+  f = config.create_fixture(client_args, server_args);+  config.init_server(&f, server_args);+  config.init_client(&f, client_args);+  return f;+}++static gpr_timespec n_seconds_time(int n) {+  return GRPC_TIMEOUT_SECONDS_TO_DEADLINE(n);+}++static gpr_timespec five_seconds_time(void) { return n_seconds_time(5); }++static void drain_cq(grpc_completion_queue *cq) {+  grpc_event ev;+  do {+    ev = grpc_completion_queue_next(cq, five_seconds_time(), NULL);+  } while (ev.type != GRPC_QUEUE_SHUTDOWN);+}++static void shutdown_server(grpc_end2end_test_fixture *f) {+  if (!f->server) return;+  grpc_server_shutdown_and_notify(f->server, f->cq, tag(1000));+  GPR_ASSERT(grpc_completion_queue_pluck(+                 f->cq, tag(1000), GRPC_TIMEOUT_SECONDS_TO_DEADLINE(5), NULL)+                 .type == GRPC_OP_COMPLETE);+  grpc_server_destroy(f->server);+  f->server = NULL;+}++static void shutdown_client(grpc_end2end_test_fixture *f) {+  if (!f->client) return;+  grpc_channel_destroy(f->client);+  f->client = NULL;+}++static void end_test(grpc_end2end_test_fixture *f) {+  shutdown_server(f);+  shutdown_client(f);++  grpc_completion_queue_shutdown(f->cq);+  drain_cq(f->cq);+  grpc_completion_queue_destroy(f->cq);+}++static bool coalesced_message_and_eos;++static void log_processor(gpr_log_func_args *args) {","A problem is that the test will be used (actually mainly be used) for Cronet, and the endpoint of Cronet is inside the Cronet library which cannot be overriden.FWIW, following your suggestion I am thinking of either of the following ways:1. Create a server like what e2e test does and override the reading endpoint of the server2. Override entire Cronet layer (requires making two different test case drivers for Cronet and chttp2)3. Make the test for Cronet only. chttp2 and Cronet behavior will be potentially different.Do you think any of them reasonable?",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/9274,95025172,2017-01-06T21:39:09Z,src/core/ext/resolver/README.md,"@@ -0,0 +1,3 @@+# Resolver++Implementations of various name resolution schemes.","Perhaps add a link to doc/naming.md here?This will be more relevant once #9106 is reviewed -- hint, hint. :)",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/9274,95025410,2017-01-06T21:40:48Z,src/core/ext/README.md,"@@ -0,0 +1,5 @@+Optional plugins for gRPC Core: Modules in this directory extend gRPC Core in+useful ways.++NOTE: The movement of code between lib and ext is an ongoing effort, so this","Do we have a plan to finish this up, or at least a list of which code should ideally live in which place?  I have to say that the intended division has always been a bit unclear to me, but if I had a clearer idea of how things were *supposed* to be laid out, I could at least try to move in the right direction over time.",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/9244,95219929,2017-01-09T18:49:46Z,src/ruby/pb/test/client.rb,"@@ -502,6 +514,163 @@ def cancel_after_first_response     op.wait   end +  def unimplemented_method+    begin+      resp = @stub.unimplemented_call(Empty.new)+    rescue GRPC::BadStatus => e+      if e.code != GRPC::Core::StatusCodes::UNIMPLEMENTED+        fail AssertionError,+          ""Expected status 12 (UNIMPLEMENTED). Received: #{e.code}""+      end+    rescue Exception => e+      fail AssertionError, ""Expected BadStatus. Received: #{e.inspect}""+    end+  end++  def unimplemented_service+    begin+      resp = @stub.unimplemented_call(Empty.new)+    rescue GRPC::BadStatus => e+      if e.code != GRPC::Core::StatusCodes::UNIMPLEMENTED+        fail AssertionError,+          ""Expected status 12 (UNIMPLEMENTED). Received: #{e.code}""+      end+    rescue Exception => e+      fail AssertionError, ""Expected BadStatus. Received: #{e.inspect}""+    end+  end++  def status_code_and_message++    # Function wide constants.+    message = ""test status method""+    code = 2+    status = GRPC::Core::StatusCodes::UNKNOWN++    # Testing with UnaryCall.+    payload = Payload.new(type: :COMPRESSABLE, body: nulls(1))+    echo_status = EchoStatus.new(code: code, message: message)+    req = SimpleRequest.new(response_type: :COMPRESSABLE,+			    response_size: 1,+			    payload: payload,+			    response_status: echo_status)+    seen_correct_exception = false+    begin+      resp = @stub.unary_call(req)+    rescue GRPC::BadStatus => e+      if e.code != status","nit: since the recent change to error classes, I think the `rescue BadStatus` comparison could be replaced with something like `rescue GRPC::Core::StatusCodes::UNKNOWN` https://github.com/grpc/grpc/blob/master/src/ruby/pb/test/client.rb#L489",
9566254,apolcyn,https://api.github.com/repos/grpc/grpc/pulls/9244,95222500,2017-01-09T19:01:55Z,src/ruby/pb/test/client.rb,"@@ -502,6 +514,163 @@ def cancel_after_first_response     op.wait   end +  def unimplemented_method+    begin+      resp = @stub.unimplemented_call(Empty.new)+    rescue GRPC::BadStatus => e+      if e.code != GRPC::Core::StatusCodes::UNIMPLEMENTED+        fail AssertionError,+          ""Expected status 12 (UNIMPLEMENTED). Received: #{e.code}""+      end+    rescue Exception => e+      fail AssertionError, ""Expected BadStatus. Received: #{e.inspect}""+    end+  end++  def unimplemented_service+    begin+      resp = @stub.unimplemented_call(Empty.new)+    rescue GRPC::BadStatus => e+      if e.code != GRPC::Core::StatusCodes::UNIMPLEMENTED+        fail AssertionError,+          ""Expected status 12 (UNIMPLEMENTED). Received: #{e.code}""+      end+    rescue Exception => e+      fail AssertionError, ""Expected BadStatus. Received: #{e.inspect}""+    end+  end++  def status_code_and_message++    # Function wide constants.+    message = ""test status method""+    code = 2+    status = GRPC::Core::StatusCodes::UNKNOWN++    # Testing with UnaryCall.+    payload = Payload.new(type: :COMPRESSABLE, body: nulls(1))+    echo_status = EchoStatus.new(code: code, message: message)+    req = SimpleRequest.new(response_type: :COMPRESSABLE,+			    response_size: 1,+			    payload: payload,+			    response_status: echo_status)+    seen_correct_exception = false+    begin+      resp = @stub.unary_call(req)+    rescue GRPC::BadStatus => e+      if e.code != status+        fail AssertionError,+	        ""Expected status 2 (UNKOWN). Received: #{e.code}""+      elsif e.details != message+	      fail AssertionError,+	        ""Expected message #{message}. Received: #{e.details}""+      end+      seen_correct_exception = true+    rescue Exception => e+      fail AssertionError, ""Expected BadStatus. Received: #{e.inspect}""+    end++    if not seen_correct_exception+      fail AssertionError, ""Did not see expected status from UnaryCall""+    end++    # testing with FullDuplex+    req_cls, p_cls = StreamingOutputCallRequest, ResponseParameters+    duplex_req = req_cls.new(payload: Payload.new(body: nulls(1)),+                  response_type: :COMPRESSABLE,+                  response_parameters: [p_cls.new(size: 1)],+                  response_status: echo_status)+    seen_correct_exception = false+    begin+      resp = @stub.full_duplex_call([duplex_req])+      resp.next # triggers initial req to be sent+    rescue GRPC::BadStatus => e+      if e.code != status+        fail AssertionError,+          ""Expected status 2 (UNKOWN). Received: #{e.code}""+      elsif e.details != message+        fail AssertionError,+          ""Expected message #{message}. Received: #{e.details}""+      end+      seen_correct_exception = true+    rescue Exception => e+      fail AssertionError, ""Expected BadStatus. Received: #{e.inspect}""+    end++    if not seen_correct_exception+      fail AssertionError, ""Did not see expected status from FullDuplexCall""+    end++  end+++  def custom_metadata++    # Function wide constants+    initial_metadata_key = ""x-grpc-test-echo-initial""+    initial_metadata_value = ""test_initial_metadata_value""+    trailing_metadata_key = ""x-grpc-test-echo-trailing-bin""+    trailing_metadata_value = ""\x0a\x0b\x0a\x0b\x0a\x0b""++    metadata = {+      initial_metadata_key => initial_metadata_value,+      trailing_metadata_key => trailing_metadata_value+    }++    # Testing with UnaryCall+    payload = Payload.new(type: :COMPRESSABLE, body: nulls(1))+    req = SimpleRequest.new(response_type: :COMPRESSABLE,+			    response_size: 1,",is there a mismatch between the message response sizes in here and the sizes in the test description (https://github.com/grpc/grpc/blob/master/doc/interop-test-descriptions.md)?not sure if relevant to the test though,
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/9286,95276608,2017-01-10T00:12:43Z,src/python/grpcio_tests/tests/stress/client.py,"@@ -110,10 +110,19 @@ def _get_channel(target, args):     channel_credentials = grpc.ssl_channel_credentials(         root_certificates=root_certificates)     options = (('grpc.ssl_target_name_override', args.server_host_override,),)-    return grpc.secure_channel(-        target, channel_credentials, options=options)+    channel = grpc.secure_channel(target, channel_credentials, options=options)   else:-    return grpc.insecure_channel(target)+    channel = grpc.insecure_channel(target)++  # waits to the channel to be ready before we start sending messages",Ahh I did not know of that call. I was mimicking the pattern I saw [here](https://github.com/grpc/grpc/blob/master/src/python/grpcio_tests/tests/qps/benchmark_client.py#L71).I will use the simpler call.,
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/9298,95470518,2017-01-10T22:17:06Z,tools/run_tests/run_interop_tests.py,"@@ -179,10 +182,10 @@ def global_env(self):     return {}    def unimplemented_test_cases(self):-    return _SKIP_COMPRESSION+    return _SKIP_ADVANCED + _SKIP_COMPRESSION",Why blacklist the advanced tests again? They are implemented.,
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/9298,95470868,2017-01-10T22:19:13Z,tools/run_tests/run_interop_tests.py,"@@ -226,11 +229,15 @@ class Http2Client:   """"""   def __init__(self):     self.client_cwd = None+    self.server_cwd = None     self.safename = str(self)    def client_cmd(self, args):     return ['tools/http2_interop/http2_interop.test', '-test.v'] + args +  def server_cmd(self, args):",I think that the http2 server should have its own class. It doesn't really make sense to push it into the Http2Client class.,
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/9298,95472764,2017-01-10T22:30:15Z,tools/run_tests/run_interop_tests.py,"@@ -797,6 +848,14 @@ def aggregate_http2_results(stdout):     server_jobs[lang] = job     server_addresses[lang] = ('localhost', job.mapped_port(_DEFAULT_SERVER_PORT)) +  if args.http2_badserver_interop:+    # launch a HTTP2 server emulator that creates edge cases+    lang = str(http2Interop)+    spec = server_jobspec(Http2Client(), docker_images.get(lang))","Made this point above, but to give another example, it is confusing that you are instantiating an object called Http2Client, but it is starting a server process",
5067076,ericgribkoff,https://api.github.com/repos/grpc/grpc/pulls/9298,95473290,2017-01-10T22:33:15Z,tools/run_tests/run_interop_tests.py,"@@ -843,7 +902,7 @@ def aggregate_http2_results(stdout):     for language in languages:       for test_case in _TEST_CASES:         if not test_case in language.unimplemented_test_cases():-          if not test_case in skip_server:+          if not test_case in skip_server and not args.http2_badserver_interop:","Can the check for `...and not args.http2_badserver_interop` be pushed up above the start of the for loops? This would make the flow clearer here, I think.Also, should this also check to make sure that `args.http2_interop` is false?",
17325098,makdharma,https://api.github.com/repos/grpc/grpc/pulls/9298,95478795,2017-01-10T23:07:22Z,tools/run_tests/run_interop_tests.py,"@@ -843,7 +902,7 @@ def aggregate_http2_results(stdout):     for language in languages:       for test_case in _TEST_CASES:         if not test_case in language.unimplemented_test_cases():-          if not test_case in skip_server:+          if not test_case in skip_server and not args.http2_badserver_interop:",Moved the if condition several lines up. This should be executed even when http2_interop is true as it is launching servers which are used during http2_interop.,
6148140,ncteisen,https://api.github.com/repos/grpc/grpc/pulls/9298,95480947,2017-01-10T23:22:34Z,tools/run_tests/run_interop_tests.py,"@@ -850,8 +875,8 @@ def aggregate_http2_results(stdout):    if args.http2_badserver_interop:     # launch a HTTP2 server emulator that creates edge cases-    lang = str(http2Interop)-    spec = server_jobspec(Http2Client(), docker_images.get(lang))+    lang = str(http2InteropServer)+    spec = server_jobspec(Http2Server(), docker_images.get(lang))",Why not use `http2InteropServer` instead of instantiating a new object?,
14932100,adelez,https://api.github.com/repos/grpc/grpc/pulls/9299,95643152,2017-01-11T18:41:35Z,doc/negative-http2-interop-test-descriptions.md,"@@ -49,7 +49,7 @@ server. The client should handle the goaway by switching to a new stream without the user application having to do a thing.  Client Procedure:- 1. Client sends two UnaryCall requests with:+ 1. Client sends two UnaryCall requests (and sleeps for 1 second in-between).",Can you comment on why this is needed? Is this to avoid the race condition?,
10120821,ctiller,https://api.github.com/repos/grpc/grpc/pulls/9169,95678134,2017-01-11T21:39:39Z,src/core/ext/client_channel/generic_uri_parse.h,"@@ -0,0 +1,82 @@+/*+ *+ * Copyright 2015, Google Inc.+ * All rights reserved.+ *+ * Redistribution and use in source and binary forms, with or without+ * modification, are permitted provided that the following conditions are+ * met:+ *+ *     * Redistributions of source code must retain the above copyright+ * notice, this list of conditions and the following disclaimer.+ *     * Redistributions in binary form must reproduce the above+ * copyright notice, this list of conditions and the following disclaimer+ * in the documentation and/or other materials provided with the+ * distribution.+ *     * Neither the name of Google Inc. nor the names of its+ * contributors may be used to endorse or promote products derived from+ * this software without specific prior written permission.+ *+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS+ * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.+ *+ */++#ifndef GRPC_CORE_EXT_CLIENT_CHANNEL_GENERIC_URI_PARSE_H+#define GRPC_CORE_EXT_CLIENT_CHANNEL_GENERIC_URI_PARSE_H++#include ""src/core/ext/client_channel/client_channel_factory.h""+#include ""src/core/ext/client_channel/resolver.h""+#include ""src/core/ext/client_channel/uri_parser.h""++typedef struct grpc_host_port_parser grpc_host_port_parser;",Could we eliminate this file by adding the host/port parsing as part of grpc_resolver_factory?I find it difficult to imagine a time when I'd want to declare a grpc_resolver_factory without a corresponding grpc_host_port_parser: they seem to occupy the same semantic space.Perhaps s/grpc_resolver_factory/grpc_naming_scheme/g?,
1054404,muxi,https://api.github.com/repos/grpc/grpc/pulls/9246,95947099,2017-01-13T07:15:02Z,src/core/ext/transport/cronet/transport/cronet_transport.c,"@@ -151,6 +151,11 @@ struct op_state {   bool state_callback_received[OP_NUM_OPS];   bool fail_state;   bool flush_read;+#ifdef GRPC_CRONET_WITH_PACKET_COALESCING",@makdharma is current framework allow any configuration information (e.g. enable_packet_coalescing) into cronet_transport? Using initial metadata seems to be a way to me but I am wondering if there is any dedicated approach.,
9939684,jtattermusch,https://api.github.com/repos/grpc/grpc/pulls/9338,95949363,2017-01-13T07:41:48Z,build.yaml,"@@ -3187,8 +3194,8 @@ targets:   deps:","Btw, the order of dependencies in the original code https://github.com/grpc/grpc/blob/6b6954050cf0379dbbee90dd18313a3779e0dd52/build.yaml#L3204 (it should be mostly the reverse, as for all the other targets).",
18664614,markdroth,https://api.github.com/repos/grpc/grpc/pulls/9194,96438555,2017-01-17T15:42:18Z,src/core/ext/client_channel/client_channel_factory.c,"@@ -85,3 +90,120 @@ grpc_arg grpc_client_channel_factory_create_channel_arg(   arg.value.pointer.vtable = &factory_arg_vtable;   return arg; }++struct grpc_channel_targets_info {","Instead of creating a custom class for this mapping, can you use one of the existing data structures, such as an avl or an mdstr_hash_table?",